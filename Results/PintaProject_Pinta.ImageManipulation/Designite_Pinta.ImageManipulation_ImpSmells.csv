Implementation smell,Namespace,Class,File,Method,Description
Long Method,Pinta.ImageManipulation,SurfaceDiff,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\SurfaceDiff.cs,Create,The method has 109 lines of code.
Long Method,Pinta.ImageManipulation.Effects,GaussianBlurEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\GaussianBlurEffect.cs,RenderLine,The method has 150 lines of code.
Long Method,Pinta.ImageManipulation.Effects,LocalHistogramEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\LocalHistogramEffect.cs,RenderRect,The method has 136 lines of code.
Long Method,Pinta.ImageManipulation.Effects,LocalHistogramEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\LocalHistogramEffect.cs,RenderRectWithAlpha,The method has 140 lines of code.
Complex Method,Pinta.ImageManipulation.Effects,ColorDifferenceEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\ColorDifferenceEffect.cs,RenderColorDifferenceEffect,Cyclomatic complexity of the method is 15
Complex Method,Pinta.ImageManipulation.Effects,RadialBlurEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\RadialBlurEffect.cs,RenderLine,Cyclomatic complexity of the method is 8
Complex Method,Pinta.ImageManipulation.Effects,OutlineEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\OutlineEffect.cs,Apply,Cyclomatic complexity of the method is 13
Complex Method,Pinta.ImageManipulation.Effects,OilPaintingEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\OilPaintingEffect.cs,RenderLine,Cyclomatic complexity of the method is 11
Complex Method,Pinta.ImageManipulation.Effects,FrostedGlassEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\FrostedGlassEffect.cs,RenderLine,Cyclomatic complexity of the method is 12
Complex Method,Pinta.ImageManipulation.Effects,EmbossEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\EmbossEffect.cs,RenderLine,Cyclomatic complexity of the method is 11
Complex Method,Pinta.ImageManipulation.Effects,GaussianBlurEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\GaussianBlurEffect.cs,RenderLine,Cyclomatic complexity of the method is 16
Complex Method,Pinta.ImageManipulation.Effects,InkSketchEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\InkSketchEffect.cs,RenderLine,Cyclomatic complexity of the method is 10
Complex Method,Pinta.ImageManipulation.Effects,LocalHistogramEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\LocalHistogramEffect.cs,GetPercentile,Cyclomatic complexity of the method is 9
Complex Method,Pinta.ImageManipulation.Effects,LocalHistogramEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\LocalHistogramEffect.cs,RenderRect,Cyclomatic complexity of the method is 21
Complex Method,Pinta.ImageManipulation.Effects,LocalHistogramEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\LocalHistogramEffect.cs,RenderRectWithAlpha,Cyclomatic complexity of the method is 21
Long Parameter List,Pinta.ImageManipulation,BaseEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\BaseEffect.cs,RenderAsync,The method has 5 parameters. Parameters: src' dst' roi' token' progress
Long Parameter List,Pinta.ImageManipulation,BaseEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\BaseEffect.cs,RenderLoop,The method has 5 parameters. Parameters: src' dst' roi' token' progress
Long Parameter List,Pinta.ImageManipulation,BinaryPixelOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelOperations\BinaryPixelOp.cs,ApplyAsync,The method has 5 parameters. Parameters: src' dst' roi' token' progress
Long Parameter List,Pinta.ImageManipulation,BinaryPixelOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelOperations\BinaryPixelOp.cs,ApplyAsync,The method has 5 parameters. Parameters: lhs' rhs' dst' roi' token
Long Parameter List,Pinta.ImageManipulation,BinaryPixelOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelOperations\BinaryPixelOp.cs,ApplyAsync,The method has 6 parameters. Parameters: lhs' rhs' dst' roi' token' progress
Long Parameter List,Pinta.ImageManipulation,BinaryPixelOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelOperations\BinaryPixelOp.cs,ApplyLoop,The method has 5 parameters. Parameters: src' dst' roi' token' progress
Long Parameter List,Pinta.ImageManipulation,BinaryPixelOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelOperations\BinaryPixelOp.cs,ApplyLoop,The method has 6 parameters. Parameters: lhs' rhs' dst' roi' token' progress
Long Parameter List,Pinta.ImageManipulation,UnaryPixelOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelOperations\UnaryPixelOp.cs,ApplyAsync,The method has 5 parameters. Parameters: src' dst' roi' token' progress
Long Parameter List,Pinta.ImageManipulation,UnaryPixelOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelOperations\UnaryPixelOp.cs,ApplyLoop,The method has 5 parameters. Parameters: src' dst' roi' token' progress
Long Parameter List,Pinta.ImageManipulation,ScaleFactor,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\ScaleFactor.cs,Min,The method has 5 parameters. Parameters: n1' d1' n2' d2' lastResort
Long Parameter List,Pinta.ImageManipulation,ScaleFactor,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\ScaleFactor.cs,Max,The method has 5 parameters. Parameters: n1' d1' n2' d2' lastResort
Long Parameter List,Pinta.ImageManipulation,ColorBgra,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Structs\ColorBgra.cs,BlendColors4W16IP,The method has 8 parameters. Parameters: c1' w1' c2' w2' c3' w3' c4' w4
Long Parameter List,Pinta.ImageManipulation,Utility,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Utility.cs,GetBilinearSampleWrapped,The method has 6 parameters. Parameters: src' srcDataPtr' srcWidth' srcHeight' x' y
Long Parameter List,Pinta.ImageManipulation.Effects,CloudsEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\CloudsEffect.cs,CloudsEffect,The method has 6 parameters. Parameters: scale' power' seed' fromColor' toColor' blendMode
Long Parameter List,Pinta.ImageManipulation.Effects,CloudsEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\CloudsEffect.cs,Noise,The method has 5 parameters. Parameters: ix' iy' x' y' seed
Long Parameter List,Pinta.ImageManipulation.Effects,CloudsEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\CloudsEffect.cs,RenderClouds,The method has 7 parameters. Parameters: surface' rect' scale' seed' power' colorFrom' colorTo
Long Parameter List,Pinta.ImageManipulation.Effects,PolarInversionEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\PolarInversionEffect.cs,PolarInversionEffect,The method has 6 parameters. Parameters: amount' quality' centerOffset' edgeBehavior' primaryColor' secondaryColor
Long Parameter List,Pinta.ImageManipulation.Effects,WarpEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\WarpEffect.cs,WarpEffect,The method has 5 parameters. Parameters: quality' centerOffset' edgeBehavior' primaryColor' secondaryColor
Long Parameter List,Pinta.ImageManipulation.Effects,UnfocusEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\UnfocusEffect.cs,ApplyWithAlpha,The method has 6 parameters. Parameters: src' area' sum' hb' hg' hr
Long Parameter List,Pinta.ImageManipulation.Effects,SharpenEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\SharpenEffect.cs,Apply,The method has 6 parameters. Parameters: src' area' hb' hg' hr' ha
Long Parameter List,Pinta.ImageManipulation.Effects,ReduceNoiseEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\ReduceNoiseEffect.cs,Apply,The method has 6 parameters. Parameters: color' area' hb' hg' hr' ha
Long Parameter List,Pinta.ImageManipulation.Effects,ReduceNoiseEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\ReduceNoiseEffect.cs,GetPercentileOfColor,The method has 6 parameters. Parameters: color' area' hb' hg' hr' ha
Long Parameter List,Pinta.ImageManipulation.Effects,PixelateEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\PixelateEffect.cs,ComputeCellColor,The method has 5 parameters. Parameters: x' y' src' cellSize' srcBounds
Long Parameter List,Pinta.ImageManipulation.Effects,OutlineEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\OutlineEffect.cs,Apply,The method has 6 parameters. Parameters: src' area' hb' hg' hr' ha
Long Parameter List,Pinta.ImageManipulation.Effects,MedianEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\MedianEffect.cs,Apply,The method has 6 parameters. Parameters: src' area' hb' hg' hr' ha
Long Parameter List,Pinta.ImageManipulation.Effects,MandelbrotFractalEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\MandelbrotFractalEffect.cs,MandelbrotFractalEffect,The method has 5 parameters. Parameters: factor' quality' zoom' angle' invertColors
Long Parameter List,Pinta.ImageManipulation.Effects,LocalHistogramEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\LocalHistogramEffect.cs,Apply,The method has 6 parameters. Parameters: src' area' hb' hg' hr' ha
Long Parameter List,Pinta.ImageManipulation.Effects,LocalHistogramEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\LocalHistogramEffect.cs,ApplyWithAlpha,The method has 6 parameters. Parameters: src' area' sum' hb' hg' hr
Long Parameter List,Pinta.ImageManipulation.Effects,LocalHistogramEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\LocalHistogramEffect.cs,GetPercentile,The method has 6 parameters. Parameters: percentile' area' hb' hg' hr' ha
Long Parameter List,Pinta.ImageManipulation.Gradients,BaseGradientRenderer,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Gradients\BaseGradientRenderer.cs,ProcessGradientLine,The method has 5 parameters. Parameters: startAlpha' endAlpha' y' rect' surface
Long Parameter List,Pinta.ImageManipulation.UnaryPixelOperations,LevelOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\UnaryPixelOperations\LevelOp.cs,LevelOp,The method has 5 parameters. Parameters: in_lo' in_hi' gamma' out_lo' out_hi
Long Statement,Pinta.ImageManipulation,UnaryPixelOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelOperations\UnaryPixelOp.cs,Apply,The length of the statement  "				throw new InvalidOperationException ("Source and destination surfaces must be the same size or use an overload with a specified bounds."); " is 138.
Long Statement,Pinta.ImageManipulation,UnaryPixelOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelOperations\UnaryPixelOp.cs,ApplyAsync,The length of the statement  "				throw new InvalidOperationException ("Source and destination surfaces must be the same size or use an overload with a specified bounds."); " is 138.
Long Statement,Pinta.ImageManipulation,UnaryPixelOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelOperations\UnaryPixelOp.cs,ApplyAsync,The length of the statement  "				throw new InvalidOperationException ("Source and destination surfaces must be the same size or use an overload with a specified bounds."); " is 138.
Long Statement,Pinta.ImageManipulation,UnaryPixelOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelOperations\UnaryPixelOp.cs,ApplyAsync,The length of the statement  "				throw new InvalidOperationException ("Source and destination surfaces must be the same size or use an overload with a specified bounds."); " is 138.
Long Statement,Pinta.ImageManipulation,UserBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelOperations\UserBlendOp.cs,ToString,The length of the statement  "			PropertyInfo pi = this.GetType ().GetProperty ("StaticName"' BindingFlags.Static | BindingFlags.Public | BindingFlags.GetProperty); " is 131.
Long Statement,Pinta.ImageManipulation,ColorBgra,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Structs\ColorBgra.cs,BlendColors4W16IP,The length of the statement  "                b = (uint)((((long)c1.A * c1.B * w1) + ((long)c2.A * c2.B * w2) + ((long)c3.A * c3.B * w3) + ((long)c4.A * c4.B * w4)) / af); " is 125.
Long Statement,Pinta.ImageManipulation,ColorBgra,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Structs\ColorBgra.cs,BlendColors4W16IP,The length of the statement  "                g = (uint)((((long)c1.A * c1.G * w1) + ((long)c2.A * c2.G * w2) + ((long)c3.A * c3.G * w3) + ((long)c4.A * c4.G * w4)) / af); " is 125.
Long Statement,Pinta.ImageManipulation,ColorBgra,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Structs\ColorBgra.cs,BlendColors4W16IP,The length of the statement  "                r = (uint)((((long)c1.A * c1.R * w1) + ((long)c2.A * c2.R * w2) + ((long)c3.A * c3.R * w3) + ((long)c4.A * c4.R * w4)) / af); " is 125.
Long Statement,Pinta.ImageManipulation.Effects,PixelateEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\PixelateEffect.cs,ComputeCellColor,The length of the statement  "			var c = ColorBgra.BlendColors4W16IP (colorTopLeft' 16384' colorTopRight' 16384' colorBottomLeft' 16384' colorBottomRight' 16384); " is 129.
Long Statement,Pinta.ImageManipulation.Effects,MandelbrotFractalEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\MandelbrotFractalEffect.cs,RenderLine,The length of the statement  "					*dstPtr = ColorBgra.FromBgra (Utility.ClampToByte (b / count)' Utility.ClampToByte (g / count)' Utility.ClampToByte (r / count)' Utility.ClampToByte (a / count)); " is 162.
Long Statement,Pinta.ImageManipulation.Effects,JuliaFractalEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\JuliaFractalEffect.cs,RenderLine,The length of the statement  "					*dstPtr = ColorBgra.FromBgra (Utility.ClampToByte (b / count)' Utility.ClampToByte (g / count)' Utility.ClampToByte (r / count)' Utility.ClampToByte (a / count)); " is 162.
Long Statement,Pinta.ImageManipulation.PixelBlendOperations,AdditiveBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\AdditiveBlendOp.cs,Apply,The length of the statement  "{ int lhsA; { lhsA = ((lhs).A); }; int rhsA; { rhsA = ((rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min (255' ((lhs).B) + ((rhs).B)); }; { fG = Math.Min (255' ((lhs).G) + ((rhs).G)); }; { fR = Math.Min (255' ((lhs).R) + ((rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; return ColorBgra.FromUInt32 (ret); }" is 1092.
Long Statement,Pinta.ImageManipulation.PixelBlendOperations,AdditiveBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\AdditiveBlendOp.cs,Apply,The length of the statement  "{ while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min (255' ((*dst).B) + ((*src).B)); }; { fG = Math.Min (255' ((*dst).G) + ((*src).G)); }; { fR = Math.Min (255' ((*dst).R) + ((*src).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; } }" is 1135.
Long Statement,Pinta.ImageManipulation.PixelBlendOperations,AdditiveBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\AdditiveBlendOp.cs,Apply,The length of the statement  "{ while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min (255' ((*lhs).B) + ((*rhs).B)); }; { fG = Math.Min (255' ((*lhs).G) + ((*rhs).G)); }; { fR = Math.Min (255' ((*lhs).R) + ((*rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; } }" is 1142.
Long Statement,Pinta.ImageManipulation.PixelBlendOperations,AdditiveBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\AdditiveBlendOp.cs,ApplyStatic,The length of the statement  "{ int lhsA; { lhsA = ((lhs).A); }; int rhsA; { rhsA = ((rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min (255' ((lhs).B) + ((rhs).B)); }; { fG = Math.Min (255' ((lhs).G) + ((rhs).G)); }; { fR = Math.Min (255' ((lhs).R) + ((rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; return ColorBgra.FromUInt32 (ret); }" is 1092.
Long Statement,Pinta.ImageManipulation.PixelBlendOperations,AdditiveBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\AdditiveBlendOp.cs,Apply,The length of the statement  "{ int lhsA; { lhsA = ((lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min (255' ((lhs).B) + ((rhs).B)); }; { fG = Math.Min (255' ((lhs).G) + ((rhs).G)); }; { fR = Math.Min (255' ((lhs).R) + ((rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; return ColorBgra.FromUInt32 (ret); }" is 1105.
Long Statement,Pinta.ImageManipulation.PixelBlendOperations,AdditiveBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\AdditiveBlendOp.cs,Apply,The length of the statement  "{ while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min (255' ((*dst).B) + ((*src).B)); }; { fG = Math.Min (255' ((*dst).G) + ((*src).G)); }; { fR = Math.Min (255' ((*dst).R) + ((*src).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; } }" is 1148.
Long Statement,Pinta.ImageManipulation.PixelBlendOperations,AdditiveBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\AdditiveBlendOp.cs,Apply,The length of the statement  "{ while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min (255' ((*lhs).B) + ((*rhs).B)); }; { fG = Math.Min (255' ((*lhs).G) + ((*rhs).G)); }; { fR = Math.Min (255' ((*lhs).R) + ((*rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; } }" is 1155.
Long Statement,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The length of the statement  "{ int lhsA; { lhsA = ((lhs).A); }; int rhsA; { rhsA = ((rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 0) { fB = 0; } else { { int i = (((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((rhs).G) == 0) { fG = 0; } else { { int i = (((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((rhs).R) == 0) { fR = 0; } else { { int i = (((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; return ColorBgra.FromUInt32 (ret); }" is 1692.
Long Statement,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The length of the statement  "{ while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 0) { fB = 0; } else { { int i = (((*src).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((*dst).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((*src).G) == 0) { fG = 0; } else { { int i = (((*src).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((*dst).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((*src).R) == 0) { fR = 0; } else { { int i = (((*src).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((*dst).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; } }" is 1738.
Long Statement,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The length of the statement  "{ while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 0) { fB = 0; } else { { int i = (((*rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((*lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((*rhs).G) == 0) { fG = 0; } else { { int i = (((*rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((*lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((*rhs).R) == 0) { fR = 0; } else { { int i = (((*rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((*lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; } }" is 1745.
Long Statement,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,ApplyStatic,The length of the statement  "{ int lhsA; { lhsA = ((lhs).A); }; int rhsA; { rhsA = ((rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 0) { fB = 0; } else { { int i = (((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((rhs).G) == 0) { fG = 0; } else { { int i = (((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((rhs).R) == 0) { fR = 0; } else { { int i = (((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; return ColorBgra.FromUInt32 (ret); }" is 1692.
Long Statement,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The length of the statement  "{ int lhsA; { lhsA = ((lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 0) { fB = 0; } else { { int i = (((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((rhs).G) == 0) { fG = 0; } else { { int i = (((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((rhs).R) == 0) { fR = 0; } else { { int i = (((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; return ColorBgra.FromUInt32 (ret); }" is 1705.
Long Statement,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The length of the statement  "{ while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 0) { fB = 0; } else { { int i = (((*src).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((*dst).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((*src).G) == 0) { fG = 0; } else { { int i = (((*src).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((*dst).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((*src).R) == 0) { fR = 0; } else { { int i = (((*src).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((*dst).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; } }" is 1751.
Long Statement,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The length of the statement  "{ while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 0) { fB = 0; } else { { int i = (((*rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((*lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((*rhs).G) == 0) { fG = 0; } else { { int i = (((*rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((*lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((*rhs).R) == 0) { fR = 0; } else { { int i = (((*rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((*lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; } }" is 1758.
Long Statement,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The length of the statement  "{ int lhsA; { lhsA = ((lhs).A); }; int rhsA; { rhsA = ((rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; return ColorBgra.FromUInt32 (ret); }" is 1665.
Long Statement,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The length of the statement  "{ while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = ((255 - ((*src).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*dst).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = ((255 - ((*src).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*dst).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = ((255 - ((*src).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*dst).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; } }" is 1711.
Long Statement,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The length of the statement  "{ while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((*rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((*rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((*rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; } }" is 1718.
Long Statement,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,ApplyStatic,The length of the statement  "{ int lhsA; { lhsA = ((lhs).A); }; int rhsA; { rhsA = ((rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; return ColorBgra.FromUInt32 (ret); }" is 1665.
Long Statement,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The length of the statement  "{ int lhsA; { lhsA = ((lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; return ColorBgra.FromUInt32 (ret); }" is 1678.
Long Statement,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The length of the statement  "{ while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = ((255 - ((*src).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*dst).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = ((255 - ((*src).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*dst).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = ((255 - ((*src).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*dst).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; } }" is 1724.
Long Statement,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The length of the statement  "{ while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((*rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((*rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((*rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; } }" is 1731.
Long Statement,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,Apply,The length of the statement  "{ int lhsA; { lhsA = ((lhs).A); }; int rhsA; { rhsA = ((rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((rhs).B)) * (((lhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = ((rhs).B) + ((lhs).B) - fB; }; { { fG = ((((rhs).G)) * (((lhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = ((rhs).G) + ((lhs).G) - fG; }; { { fR = ((((rhs).R)) * (((lhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = ((rhs).R) + ((lhs).R) - fR; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; return ColorBgra.FromUInt32 (ret); }" is 1299.
Long Statement,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,Apply,The length of the statement  "{ while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*src).B)) * (((*dst).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = ((*src).B) + ((*dst).B) - fB; }; { { fG = ((((*src).G)) * (((*dst).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = ((*src).G) + ((*dst).G) - fG; }; { { fR = ((((*src).R)) * (((*dst).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = ((*src).R) + ((*dst).R) - fR; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; } }" is 1348.
Long Statement,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,Apply,The length of the statement  "{ while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*rhs).B)) * (((*lhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = ((*rhs).B) + ((*lhs).B) - fB; }; { { fG = ((((*rhs).G)) * (((*lhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = ((*rhs).G) + ((*lhs).G) - fG; }; { { fR = ((((*rhs).R)) * (((*lhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = ((*rhs).R) + ((*lhs).R) - fR; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; } }" is 1355.
Long Statement,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,ApplyStatic,The length of the statement  "{ int lhsA; { lhsA = ((lhs).A); }; int rhsA; { rhsA = ((rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((rhs).B)) * (((lhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = ((rhs).B) + ((lhs).B) - fB; }; { { fG = ((((rhs).G)) * (((lhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = ((rhs).G) + ((lhs).G) - fG; }; { { fR = ((((rhs).R)) * (((lhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = ((rhs).R) + ((lhs).R) - fR; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; return ColorBgra.FromUInt32 (ret); }" is 1299.
Long Statement,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,Apply,The length of the statement  "{ int lhsA; { lhsA = ((lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((rhs).B)) * (((lhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = ((rhs).B) + ((lhs).B) - fB; }; { { fG = ((((rhs).G)) * (((lhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = ((rhs).G) + ((lhs).G) - fG; }; { { fR = ((((rhs).R)) * (((lhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = ((rhs).R) + ((lhs).R) - fR; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; return ColorBgra.FromUInt32 (ret); }" is 1312.
Long Statement,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,Apply,The length of the statement  "{ while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*src).B)) * (((*dst).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = ((*src).B) + ((*dst).B) - fB; }; { { fG = ((((*src).G)) * (((*dst).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = ((*src).G) + ((*dst).G) - fG; }; { { fR = ((((*src).R)) * (((*dst).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = ((*src).R) + ((*dst).R) - fR; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; } }" is 1361.
Long Statement,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,Apply,The length of the statement  "{ while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*rhs).B)) * (((*lhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = ((*rhs).B) + ((*lhs).B) - fB; }; { { fG = ((((*rhs).G)) * (((*lhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = ((*rhs).G) + ((*lhs).G) - fG; }; { { fR = ((((*rhs).R)) * (((*lhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = ((*rhs).R) + ((*lhs).R) - fR; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; } }" is 1368.
Long Statement,Pinta.ImageManipulation.PixelBlendOperations,DarkenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DarkenBlendOp.cs,Apply,The length of the statement  "{ int lhsA; { lhsA = ((lhs).A); }; int rhsA; { rhsA = ((rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min ((lhs).B' (rhs).B); }; { fG = Math.Min ((lhs).G' (rhs).G); }; { fR = Math.Min ((lhs).R' (rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; return ColorBgra.FromUInt32 (ret); }" is 1062.
Long Statement,Pinta.ImageManipulation.PixelBlendOperations,DarkenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DarkenBlendOp.cs,Apply,The length of the statement  "{ while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min ((*dst).B' (*src).B); }; { fG = Math.Min ((*dst).G' (*src).G); }; { fR = Math.Min ((*dst).R' (*src).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; } }" is 1105.
Long Statement,Pinta.ImageManipulation.PixelBlendOperations,DarkenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DarkenBlendOp.cs,Apply,The length of the statement  "{ while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min ((*lhs).B' (*rhs).B); }; { fG = Math.Min ((*lhs).G' (*rhs).G); }; { fR = Math.Min ((*lhs).R' (*rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; } }" is 1112.
Long Statement,Pinta.ImageManipulation.PixelBlendOperations,DarkenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DarkenBlendOp.cs,ApplyStatic,The length of the statement  "{ int lhsA; { lhsA = ((lhs).A); }; int rhsA; { rhsA = ((rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min ((lhs).B' (rhs).B); }; { fG = Math.Min ((lhs).G' (rhs).G); }; { fR = Math.Min ((lhs).R' (rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; return ColorBgra.FromUInt32 (ret); }" is 1062.
Long Statement,Pinta.ImageManipulation.PixelBlendOperations,DarkenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DarkenBlendOp.cs,Apply,The length of the statement  "{ int lhsA; { lhsA = ((lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min ((lhs).B' (rhs).B); }; { fG = Math.Min ((lhs).G' (rhs).G); }; { fR = Math.Min ((lhs).R' (rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; return ColorBgra.FromUInt32 (ret); }" is 1075.
Long Statement,Pinta.ImageManipulation.PixelBlendOperations,DarkenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DarkenBlendOp.cs,Apply,The length of the statement  "{ while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min ((*dst).B' (*src).B); }; { fG = Math.Min ((*dst).G' (*src).G); }; { fR = Math.Min ((*dst).R' (*src).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; } }" is 1118.
Long Statement,Pinta.ImageManipulation.PixelBlendOperations,DarkenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DarkenBlendOp.cs,Apply,The length of the statement  "{ while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min ((*lhs).B' (*rhs).B); }; { fG = Math.Min ((*lhs).G' (*rhs).G); }; { fR = Math.Min ((*lhs).R' (*rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; } }" is 1125.
Long Statement,Pinta.ImageManipulation.PixelBlendOperations,LightenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\LightenBlendOp.cs,Apply,The length of the statement  "{ int lhsA; { lhsA = ((lhs).A); }; int rhsA; { rhsA = ((rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Max ((lhs).B' (rhs).B); }; { fG = Math.Max ((lhs).G' (rhs).G); }; { fR = Math.Max ((lhs).R' (rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; return ColorBgra.FromUInt32 (ret); }" is 1062.
Long Statement,Pinta.ImageManipulation.PixelBlendOperations,LightenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\LightenBlendOp.cs,Apply,The length of the statement  "{ while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Max ((*dst).B' (*src).B); }; { fG = Math.Max ((*dst).G' (*src).G); }; { fR = Math.Max ((*dst).R' (*src).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; } }" is 1105.
Long Statement,Pinta.ImageManipulation.PixelBlendOperations,LightenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\LightenBlendOp.cs,Apply,The length of the statement  "{ while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Max ((*lhs).B' (*rhs).B); }; { fG = Math.Max ((*lhs).G' (*rhs).G); }; { fR = Math.Max ((*lhs).R' (*rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; } }" is 1112.
Long Statement,Pinta.ImageManipulation.PixelBlendOperations,LightenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\LightenBlendOp.cs,ApplyStatic,The length of the statement  "{ int lhsA; { lhsA = ((lhs).A); }; int rhsA; { rhsA = ((rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Max ((lhs).B' (rhs).B); }; { fG = Math.Max ((lhs).G' (rhs).G); }; { fR = Math.Max ((lhs).R' (rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; return ColorBgra.FromUInt32 (ret); }" is 1062.
Long Statement,Pinta.ImageManipulation.PixelBlendOperations,LightenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\LightenBlendOp.cs,Apply,The length of the statement  "{ int lhsA; { lhsA = ((lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Max ((lhs).B' (rhs).B); }; { fG = Math.Max ((lhs).G' (rhs).G); }; { fR = Math.Max ((lhs).R' (rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; return ColorBgra.FromUInt32 (ret); }" is 1075.
Long Statement,Pinta.ImageManipulation.PixelBlendOperations,LightenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\LightenBlendOp.cs,Apply,The length of the statement  "{ while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Max ((*dst).B' (*src).B); }; { fG = Math.Max ((*dst).G' (*src).G); }; { fR = Math.Max ((*dst).R' (*src).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; } }" is 1118.
Long Statement,Pinta.ImageManipulation.PixelBlendOperations,LightenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\LightenBlendOp.cs,Apply,The length of the statement  "{ while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Max ((*lhs).B' (*rhs).B); }; { fG = Math.Max ((*lhs).G' (*rhs).G); }; { fR = Math.Max ((*lhs).R' (*rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; } }" is 1125.
Long Statement,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,Apply,The length of the statement  "{ int lhsA; { lhsA = ((lhs).A); }; int rhsA; { rhsA = ((rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (255 - Math.Abs (255 - ((lhs).B) - ((rhs).B))); }; { fG = (255 - Math.Abs (255 - ((lhs).G) - ((rhs).G))); }; { fR = (255 - Math.Abs (255 - ((lhs).R) - ((rhs).R))); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; return ColorBgra.FromUInt32 (ret); }" is 1119.
Long Statement,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,Apply,The length of the statement  "{ while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (255 - Math.Abs (255 - ((*dst).B) - ((*src).B))); }; { fG = (255 - Math.Abs (255 - ((*dst).G) - ((*src).G))); }; { fR = (255 - Math.Abs (255 - ((*dst).R) - ((*src).R))); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; } }" is 1162.
Long Statement,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,Apply,The length of the statement  "{ while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (255 - Math.Abs (255 - ((*lhs).B) - ((*rhs).B))); }; { fG = (255 - Math.Abs (255 - ((*lhs).G) - ((*rhs).G))); }; { fR = (255 - Math.Abs (255 - ((*lhs).R) - ((*rhs).R))); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; } }" is 1169.
Long Statement,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,ApplyStatic,The length of the statement  "{ int lhsA; { lhsA = ((lhs).A); }; int rhsA; { rhsA = ((rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (255 - Math.Abs (255 - ((lhs).B) - ((rhs).B))); }; { fG = (255 - Math.Abs (255 - ((lhs).G) - ((rhs).G))); }; { fR = (255 - Math.Abs (255 - ((lhs).R) - ((rhs).R))); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; return ColorBgra.FromUInt32 (ret); }" is 1119.
Long Statement,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,Apply,The length of the statement  "{ int lhsA; { lhsA = ((lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (255 - Math.Abs (255 - ((lhs).B) - ((rhs).B))); }; { fG = (255 - Math.Abs (255 - ((lhs).G) - ((rhs).G))); }; { fR = (255 - Math.Abs (255 - ((lhs).R) - ((rhs).R))); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; return ColorBgra.FromUInt32 (ret); }" is 1132.
Long Statement,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,Apply,The length of the statement  "{ while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (255 - Math.Abs (255 - ((*dst).B) - ((*src).B))); }; { fG = (255 - Math.Abs (255 - ((*dst).G) - ((*src).G))); }; { fR = (255 - Math.Abs (255 - ((*dst).R) - ((*src).R))); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; } }" is 1175.
Long Statement,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,Apply,The length of the statement  "{ while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (255 - Math.Abs (255 - ((*lhs).B) - ((*rhs).B))); }; { fG = (255 - Math.Abs (255 - ((*lhs).G) - ((*rhs).G))); }; { fR = (255 - Math.Abs (255 - ((*lhs).R) - ((*rhs).R))); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; } }" is 1182.
Long Statement,Pinta.ImageManipulation.PixelBlendOperations,DifferenceBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DifferenceBlendOp.cs,Apply,The length of the statement  "{ int lhsA; { lhsA = ((lhs).A); }; int rhsA; { rhsA = ((rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Abs (((rhs).B) - ((lhs).B)); }; { fG = Math.Abs (((rhs).G) - ((lhs).G)); }; { fR = Math.Abs (((rhs).R) - ((lhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; return ColorBgra.FromUInt32 (ret); }" is 1077.
Long Statement,Pinta.ImageManipulation.PixelBlendOperations,DifferenceBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DifferenceBlendOp.cs,Apply,The length of the statement  "{ while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Abs (((*src).B) - ((*dst).B)); }; { fG = Math.Abs (((*src).G) - ((*dst).G)); }; { fR = Math.Abs (((*src).R) - ((*dst).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; } }" is 1120.
Long Statement,Pinta.ImageManipulation.PixelBlendOperations,DifferenceBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DifferenceBlendOp.cs,Apply,The length of the statement  "{ while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Abs (((*rhs).B) - ((*lhs).B)); }; { fG = Math.Abs (((*rhs).G) - ((*lhs).G)); }; { fR = Math.Abs (((*rhs).R) - ((*lhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; } }" is 1127.
Long Statement,Pinta.ImageManipulation.PixelBlendOperations,DifferenceBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DifferenceBlendOp.cs,ApplyStatic,The length of the statement  "{ int lhsA; { lhsA = ((lhs).A); }; int rhsA; { rhsA = ((rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Abs (((rhs).B) - ((lhs).B)); }; { fG = Math.Abs (((rhs).G) - ((lhs).G)); }; { fR = Math.Abs (((rhs).R) - ((lhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; return ColorBgra.FromUInt32 (ret); }" is 1077.
Long Statement,Pinta.ImageManipulation.PixelBlendOperations,DifferenceBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DifferenceBlendOp.cs,Apply,The length of the statement  "{ int lhsA; { lhsA = ((lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Abs (((rhs).B) - ((lhs).B)); }; { fG = Math.Abs (((rhs).G) - ((lhs).G)); }; { fR = Math.Abs (((rhs).R) - ((lhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; return ColorBgra.FromUInt32 (ret); }" is 1090.
Long Statement,Pinta.ImageManipulation.PixelBlendOperations,DifferenceBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DifferenceBlendOp.cs,Apply,The length of the statement  "{ while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Abs (((*src).B) - ((*dst).B)); }; { fG = Math.Abs (((*src).G) - ((*dst).G)); }; { fR = Math.Abs (((*src).R) - ((*dst).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; } }" is 1133.
Long Statement,Pinta.ImageManipulation.PixelBlendOperations,DifferenceBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DifferenceBlendOp.cs,Apply,The length of the statement  "{ while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Abs (((*rhs).B) - ((*lhs).B)); }; { fG = Math.Abs (((*rhs).G) - ((*lhs).G)); }; { fR = Math.Abs (((*rhs).R) - ((*lhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; } }" is 1140.
Long Statement,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The length of the statement  "{ int lhsA; { lhsA = ((lhs).A); }; int rhsA; { rhsA = ((rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) < 128) { { fB = ((2 * ((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((lhs).B))) * (255 - ((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((lhs).G) < 128) { { fG = ((2 * ((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((lhs).G))) * (255 - ((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((lhs).R) < 128) { { fR = ((2 * ((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((lhs).R))) * (255 - ((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; return ColorBgra.FromUInt32 (ret); }" is 1653.
Long Statement,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The length of the statement  "{ while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) < 128) { { fB = ((2 * ((*dst).B)) * (((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*dst).B))) * (255 - ((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*dst).G) < 128) { { fG = ((2 * ((*dst).G)) * (((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*dst).G))) * (255 - ((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*dst).R) < 128) { { fR = ((2 * ((*dst).R)) * (((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*dst).R))) * (255 - ((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; } }" is 1705.
Long Statement,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The length of the statement  "{ while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) < 128) { { fB = ((2 * ((*lhs).B)) * (((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*lhs).B))) * (255 - ((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*lhs).G) < 128) { { fG = ((2 * ((*lhs).G)) * (((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*lhs).G))) * (255 - ((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*lhs).R) < 128) { { fR = ((2 * ((*lhs).R)) * (((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*lhs).R))) * (255 - ((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; } }" is 1712.
Long Statement,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,ApplyStatic,The length of the statement  "{ int lhsA; { lhsA = ((lhs).A); }; int rhsA; { rhsA = ((rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) < 128) { { fB = ((2 * ((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((lhs).B))) * (255 - ((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((lhs).G) < 128) { { fG = ((2 * ((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((lhs).G))) * (255 - ((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((lhs).R) < 128) { { fR = ((2 * ((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((lhs).R))) * (255 - ((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; return ColorBgra.FromUInt32 (ret); }" is 1653.
Long Statement,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The length of the statement  "{ int lhsA; { lhsA = ((lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) < 128) { { fB = ((2 * ((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((lhs).B))) * (255 - ((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((lhs).G) < 128) { { fG = ((2 * ((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((lhs).G))) * (255 - ((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((lhs).R) < 128) { { fR = ((2 * ((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((lhs).R))) * (255 - ((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; return ColorBgra.FromUInt32 (ret); }" is 1666.
Long Statement,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The length of the statement  "{ while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) < 128) { { fB = ((2 * ((*dst).B)) * (((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*dst).B))) * (255 - ((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*dst).G) < 128) { { fG = ((2 * ((*dst).G)) * (((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*dst).G))) * (255 - ((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*dst).R) < 128) { { fR = ((2 * ((*dst).R)) * (((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*dst).R))) * (255 - ((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; } }" is 1718.
Long Statement,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The length of the statement  "{ while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) < 128) { { fB = ((2 * ((*lhs).B)) * (((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*lhs).B))) * (255 - ((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*lhs).G) < 128) { { fG = ((2 * ((*lhs).G)) * (((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*lhs).G))) * (255 - ((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*lhs).R) < 128) { { fR = ((2 * ((*lhs).R)) * (((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*lhs).R))) * (255 - ((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; } }" is 1725.
Long Statement,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The length of the statement  "{ int lhsA; { lhsA = ((lhs).A); }; int rhsA; { rhsA = ((rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((rhs).B) * ((rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((rhs).G) * ((rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((rhs).R) * ((rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; return ColorBgra.FromUInt32 (ret); }" is 1671.
Long Statement,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The length of the statement  "{ while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) == 255) { fB = 255; } else { { int i = (255 - ((*dst).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*src).B) * ((*src).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*dst).G) == 255) { fG = 255; } else { { int i = (255 - ((*dst).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*src).G) * ((*src).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*dst).R) == 255) { fR = 255; } else { { int i = (255 - ((*dst).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*src).R) * ((*src).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; } }" is 1720.
Long Statement,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The length of the statement  "{ while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((*lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*rhs).B) * ((*rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((*lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*rhs).G) * ((*rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((*lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*rhs).R) * ((*rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; } }" is 1727.
Long Statement,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,ApplyStatic,The length of the statement  "{ int lhsA; { lhsA = ((lhs).A); }; int rhsA; { rhsA = ((rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((rhs).B) * ((rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((rhs).G) * ((rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((rhs).R) * ((rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; return ColorBgra.FromUInt32 (ret); }" is 1671.
Long Statement,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The length of the statement  "{ int lhsA; { lhsA = ((lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((rhs).B) * ((rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((rhs).G) * ((rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((rhs).R) * ((rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; return ColorBgra.FromUInt32 (ret); }" is 1684.
Long Statement,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The length of the statement  "{ while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) == 255) { fB = 255; } else { { int i = (255 - ((*dst).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*src).B) * ((*src).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*dst).G) == 255) { fG = 255; } else { { int i = (255 - ((*dst).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*src).G) * ((*src).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*dst).R) == 255) { fR = 255; } else { { int i = (255 - ((*dst).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*src).R) * ((*src).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; } }" is 1733.
Long Statement,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The length of the statement  "{ while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((*lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*rhs).B) * ((*rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((*lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*rhs).G) * ((*rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((*lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*rhs).R) * ((*rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; } }" is 1740.
Long Statement,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The length of the statement  "{ int lhsA; { lhsA = ((lhs).A); }; int rhsA; { rhsA = ((rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((lhs).B) * ((lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((lhs).G) * ((lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((lhs).R) * ((lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; return ColorBgra.FromUInt32 (ret); }" is 1671.
Long Statement,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The length of the statement  "{ while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = (255 - ((*src).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*dst).B) * ((*dst).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = (255 - ((*src).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*dst).G) * ((*dst).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = (255 - ((*src).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*dst).R) * ((*dst).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; } }" is 1720.
Long Statement,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The length of the statement  "{ while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((*rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*lhs).B) * ((*lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((*rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*lhs).G) * ((*lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((*rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*lhs).R) * ((*lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; } }" is 1727.
Long Statement,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,ApplyStatic,The length of the statement  "{ int lhsA; { lhsA = ((lhs).A); }; int rhsA; { rhsA = ((rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((lhs).B) * ((lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((lhs).G) * ((lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((lhs).R) * ((lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; return ColorBgra.FromUInt32 (ret); }" is 1671.
Long Statement,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The length of the statement  "{ int lhsA; { lhsA = ((lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((lhs).B) * ((lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((lhs).G) * ((lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((lhs).R) * ((lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; return ColorBgra.FromUInt32 (ret); }" is 1684.
Long Statement,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The length of the statement  "{ while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = (255 - ((*src).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*dst).B) * ((*dst).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = (255 - ((*src).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*dst).G) * ((*dst).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = (255 - ((*src).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*dst).R) * ((*dst).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; } }" is 1733.
Long Statement,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The length of the statement  "{ while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((*rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*lhs).B) * ((*lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((*rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*lhs).G) * ((*lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((*rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*lhs).R) * ((*lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; } }" is 1740.
Long Statement,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,Apply,The length of the statement  "{ int lhsA; { lhsA = ((lhs).A); }; int rhsA; { rhsA = ((rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; }; { { fG = ((((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; }; { { fR = ((((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; return ColorBgra.FromUInt32 (ret); }" is 1200.
Long Statement,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,Apply,The length of the statement  "{ while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*dst).B)) * (((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; }; { { fG = ((((*dst).G)) * (((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; }; { { fR = ((((*dst).R)) * (((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; } }" is 1243.
Long Statement,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,Apply,The length of the statement  "{ while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*lhs).B)) * (((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; }; { { fG = ((((*lhs).G)) * (((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; }; { { fR = ((((*lhs).R)) * (((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; } }" is 1250.
Long Statement,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,ApplyStatic,The length of the statement  "{ int lhsA; { lhsA = ((lhs).A); }; int rhsA; { rhsA = ((rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; }; { { fG = ((((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; }; { { fR = ((((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; return ColorBgra.FromUInt32 (ret); }" is 1200.
Long Statement,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,Apply,The length of the statement  "{ int lhsA; { lhsA = ((lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; }; { { fG = ((((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; }; { { fR = ((((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; return ColorBgra.FromUInt32 (ret); }" is 1213.
Long Statement,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,Apply,The length of the statement  "{ while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*dst).B)) * (((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; }; { { fG = ((((*dst).G)) * (((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; }; { { fR = ((((*dst).R)) * (((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; } }" is 1256.
Long Statement,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,Apply,The length of the statement  "{ while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*lhs).B)) * (((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; }; { { fG = ((((*lhs).G)) * (((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; }; { { fR = ((((*lhs).R)) * (((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; } }" is 1263.
Long Statement,Pinta.ImageManipulation.PixelBlendOperations,XorBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\XorBlendOp.cs,Apply,The length of the statement  "{ int lhsA; { lhsA = ((lhs).A); }; int rhsA; { rhsA = ((rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (((lhs).B) ^ ((rhs).B)); }; { fG = (((lhs).G) ^ ((rhs).G)); }; { fR = (((lhs).R) ^ ((rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; return ColorBgra.FromUInt32 (ret); }" is 1050.
Long Statement,Pinta.ImageManipulation.PixelBlendOperations,XorBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\XorBlendOp.cs,Apply,The length of the statement  "{ while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (((*dst).B) ^ ((*src).B)); }; { fG = (((*dst).G) ^ ((*src).G)); }; { fR = (((*dst).R) ^ ((*src).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; } }" is 1093.
Long Statement,Pinta.ImageManipulation.PixelBlendOperations,XorBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\XorBlendOp.cs,Apply,The length of the statement  "{ while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (((*lhs).B) ^ ((*rhs).B)); }; { fG = (((*lhs).G) ^ ((*rhs).G)); }; { fR = (((*lhs).R) ^ ((*rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; } }" is 1100.
Long Statement,Pinta.ImageManipulation.PixelBlendOperations,XorBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\XorBlendOp.cs,ApplyStatic,The length of the statement  "{ int lhsA; { lhsA = ((lhs).A); }; int rhsA; { rhsA = ((rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (((lhs).B) ^ ((rhs).B)); }; { fG = (((lhs).G) ^ ((rhs).G)); }; { fR = (((lhs).R) ^ ((rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; return ColorBgra.FromUInt32 (ret); }" is 1050.
Long Statement,Pinta.ImageManipulation.PixelBlendOperations,XorBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\XorBlendOp.cs,Apply,The length of the statement  "{ int lhsA; { lhsA = ((lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (((lhs).B) ^ ((rhs).B)); }; { fG = (((lhs).G) ^ ((rhs).G)); }; { fR = (((lhs).R) ^ ((rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; return ColorBgra.FromUInt32 (ret); }" is 1063.
Long Statement,Pinta.ImageManipulation.PixelBlendOperations,XorBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\XorBlendOp.cs,Apply,The length of the statement  "{ while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (((*dst).B) ^ ((*src).B)); }; { fG = (((*dst).G) ^ ((*src).G)); }; { fR = (((*dst).R) ^ ((*src).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; } }" is 1106.
Long Statement,Pinta.ImageManipulation.PixelBlendOperations,XorBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\XorBlendOp.cs,Apply,The length of the statement  "{ while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (((*lhs).B) ^ ((*rhs).B)); }; { fG = (((*lhs).G) ^ ((*rhs).G)); }; { fR = (((*lhs).R) ^ ((*rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; } }" is 1113.
Long Statement,Pinta.ImageManipulation.PixelBlendOperations,NormalBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NormalBlendOp.cs,Apply,The length of the statement  "				int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = ((*src).B); }; { fG = ((*src).G); }; { fR = ((*src).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; " is 953.
Long Statement,Pinta.ImageManipulation.PixelBlendOperations,NormalBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NormalBlendOp.cs,Apply,The length of the statement  "{ while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = ((*rhs).B); }; { fG = ((*rhs).G); }; { fR = ((*rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; } }" is 1055.
Long Statement,Pinta.ImageManipulation.PixelBlendOperations,NormalBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NormalBlendOp.cs,ApplyStatic,The length of the statement  "{ int lhsA; { lhsA = ((lhs).A); }; int rhsA; { rhsA = ((rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = ((rhs).B); }; { fG = ((rhs).G); }; { fR = ((rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; return ColorBgra.FromUInt32 (ret); }" is 1008.
Long Statement,Pinta.ImageManipulation.PixelBlendOperations,NormalBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NormalBlendOp.cs,Apply,The length of the statement  "{ int lhsA; { lhsA = ((lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = ((rhs).B); }; { fG = ((rhs).G); }; { fR = ((rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; return ColorBgra.FromUInt32 (ret); }" is 1021.
Long Statement,Pinta.ImageManipulation.PixelBlendOperations,NormalBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NormalBlendOp.cs,Apply,The length of the statement  "{ while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = ((*src).B); }; { fG = ((*src).G); }; { fR = ((*src).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; } }" is 1061.
Long Statement,Pinta.ImageManipulation.PixelBlendOperations,NormalBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NormalBlendOp.cs,Apply,The length of the statement  "{ while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = ((*rhs).B); }; { fG = ((*rhs).G); }; { fR = ((*rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; } }" is 1068.
Complex Conditional,Pinta.ImageManipulation,HistogramRgb,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\HistogramRGB.cs,SetFromLeveledHistogram,The conditional expression  "after[c] > upo.ColorOutHigh[c]  					    || after[c] < upo.ColorOutLow[c]  					    || (int)Math.Floor (before[c]) < 0  					    || (int)Math.Ceiling (before[c]) > 255  					    || float.IsNaN (before[c])"  is complex.
Complex Conditional,Pinta.ImageManipulation.Effects,RadialBlurEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\RadialBlurEffect.cs,RenderLine,The conditional expression  "u1 > 0 && v1 > 0 && u1 < w && v1 < h"  is complex.
Complex Conditional,Pinta.ImageManipulation.Effects,RadialBlurEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\RadialBlurEffect.cs,RenderLine,The conditional expression  "u2 > 0 && v2 > 0 && u2 < w && v2 < h"  is complex.
Complex Conditional,Pinta.ImageManipulation.Effects,MotionBlurEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\MotionBlurEffect.cs,RenderLine,The conditional expression  "pt.X >= 0 && pt.Y >= 0 && pt.X <= (src_width - 1) && pt.Y <= (src_height - 1)"  is complex.
Complex Conditional,Pinta.ImageManipulation.Effects,FragmentEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\FragmentEffect.cs,RenderLine,The conditional expression  "u >= 0 && u < src_width && v >= 0 && v < src_height"  is complex.
Complex Conditional,Pinta.ImageManipulation.Gradients,BaseGradientRenderer,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Gradients\BaseGradientRenderer.cs,ProcessGradientLine,The conditional expression  "!AlphaOnly && (AlphaBlending && (startAlpha != 255 || endAlpha != 255))"  is complex.
Magic Number,Pinta.ImageManipulation,BitVector2DSurfaceAdapter,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\BitVector2DSurfaceAdapter.cs,Clear,The following statement contains a magic number: unsafe {  				uint val = newValue ? 0xffffffff : 0;    				for (int y = 0; y < Height; ++y) {  					ColorBgra* row = surface.GetRowAddress (y);    					int w = (this.Width + 31) / 32;    					while (w > 0) {  						row->Bgra = val;  						++row;  						--w;  					}  				}  			}
Magic Number,Pinta.ImageManipulation,BitVector2DSurfaceAdapter,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\BitVector2DSurfaceAdapter.cs,Clear,The following statement contains a magic number: unsafe {  				uint val = newValue ? 0xffffffff : 0;    				for (int y = 0; y < Height; ++y) {  					ColorBgra* row = surface.GetRowAddress (y);    					int w = (this.Width + 31) / 32;    					while (w > 0) {  						row->Bgra = val;  						++row;  						--w;  					}  				}  			}
Magic Number,Pinta.ImageManipulation,BitVector2DSurfaceAdapter,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\BitVector2DSurfaceAdapter.cs,GetUnchecked,The following statement contains a magic number: int cx = x / 32;
Magic Number,Pinta.ImageManipulation,BitVector2DSurfaceAdapter,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\BitVector2DSurfaceAdapter.cs,GetUnchecked,The following statement contains a magic number: int sx = x % 32;
Magic Number,Pinta.ImageManipulation,BitVector2DSurfaceAdapter,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\BitVector2DSurfaceAdapter.cs,SetUnchecked,The following statement contains a magic number: int cx = x / 32;
Magic Number,Pinta.ImageManipulation,BitVector2DSurfaceAdapter,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\BitVector2DSurfaceAdapter.cs,SetUnchecked,The following statement contains a magic number: int sx = x % 32;
Magic Number,Pinta.ImageManipulation,HistogramRgb,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\HistogramRGB.cs,GetMeanColor,The following statement contains a magic number: return ColorBgra.FromBgr ((byte)(mean[0] + 0.5f)' (byte)(mean[1] + 0.5f)' (byte)(mean[2] + 0.5f));
Magic Number,Pinta.ImageManipulation,HistogramRgb,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\HistogramRGB.cs,GetPercentileColor,The following statement contains a magic number: return ColorBgra.FromBgr ((byte)(perc[0])' (byte)(perc[1])' (byte)(perc[2]));
Magic Number,Pinta.ImageManipulation,HistogramRgb,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\HistogramRGB.cs,AddSurfaceRectangleToHistogram,The following statement contains a magic number: long[] histogramR = histogram[2];
Magic Number,Pinta.ImageManipulation,HistogramRgb,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\HistogramRGB.cs,SetFromLeveledHistogram,The following statement contains a magic number: float[] before = new float[3];
Magic Number,Pinta.ImageManipulation,HistogramRgb,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\HistogramRGB.cs,SetFromLeveledHistogram,The following statement contains a magic number: float[] slopes = new float[3];
Magic Number,Pinta.ImageManipulation,HistogramRgb,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\HistogramRGB.cs,SetFromLeveledHistogram,The following statement contains a magic number: for (int c = 0; c < 3; c++) {  				long[] channelHistogramOutput = histogram[c];  				long[] channelHistogramInput = inputHistogram.histogram[c];    				for (int v = 0; v <= 255; v++) {  					ColorBgra after = ColorBgra.FromBgr ((byte)v' (byte)v' (byte)v);    					upo.UnApply (after' before' slopes);    					if (after[c] > upo.ColorOutHigh[c]  					    || after[c] < upo.ColorOutLow[c]  					    || (int)Math.Floor (before[c]) < 0  					    || (int)Math.Ceiling (before[c]) > 255  					    || float.IsNaN (before[c])) {  						channelHistogramOutput[v] = 0;  					} else if (before[c] <= upo.ColorInLow[c]) {  						channelHistogramOutput[v] = 0;    						for (int i = 0; i <= upo.ColorInLow[c]; i++) {  							channelHistogramOutput[v] += channelHistogramInput[i];  						}  					} else if (before[c] >= upo.ColorInHigh[c]) {  						channelHistogramOutput[v] = 0;    						for (int i = upo.ColorInHigh[c]; i < 256; i++) {  							channelHistogramOutput[v] += channelHistogramInput[i];  						}  					} else {  						channelHistogramOutput[v] = (int)(slopes[c] * Utility.Lerp (  						    channelHistogramInput[(int)Math.Floor (before[c])]'  						    channelHistogramInput[(int)Math.Ceiling (before[c])]'  						    before[c] - Math.Floor (before[c])));  					}  				}  			}
Magic Number,Pinta.ImageManipulation,HistogramRgb,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\HistogramRGB.cs,SetFromLeveledHistogram,The following statement contains a magic number: for (int c = 0; c < 3; c++) {  				long[] channelHistogramOutput = histogram[c];  				long[] channelHistogramInput = inputHistogram.histogram[c];    				for (int v = 0; v <= 255; v++) {  					ColorBgra after = ColorBgra.FromBgr ((byte)v' (byte)v' (byte)v);    					upo.UnApply (after' before' slopes);    					if (after[c] > upo.ColorOutHigh[c]  					    || after[c] < upo.ColorOutLow[c]  					    || (int)Math.Floor (before[c]) < 0  					    || (int)Math.Ceiling (before[c]) > 255  					    || float.IsNaN (before[c])) {  						channelHistogramOutput[v] = 0;  					} else if (before[c] <= upo.ColorInLow[c]) {  						channelHistogramOutput[v] = 0;    						for (int i = 0; i <= upo.ColorInLow[c]; i++) {  							channelHistogramOutput[v] += channelHistogramInput[i];  						}  					} else if (before[c] >= upo.ColorInHigh[c]) {  						channelHistogramOutput[v] = 0;    						for (int i = upo.ColorInHigh[c]; i < 256; i++) {  							channelHistogramOutput[v] += channelHistogramInput[i];  						}  					} else {  						channelHistogramOutput[v] = (int)(slopes[c] * Utility.Lerp (  						    channelHistogramInput[(int)Math.Floor (before[c])]'  						    channelHistogramInput[(int)Math.Ceiling (before[c])]'  						    before[c] - Math.Floor (before[c])));  					}  				}  			}
Magic Number,Pinta.ImageManipulation,HistogramRgb,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\HistogramRGB.cs,SetFromLeveledHistogram,The following statement contains a magic number: for (int c = 0; c < 3; c++) {  				long[] channelHistogramOutput = histogram[c];  				long[] channelHistogramInput = inputHistogram.histogram[c];    				for (int v = 0; v <= 255; v++) {  					ColorBgra after = ColorBgra.FromBgr ((byte)v' (byte)v' (byte)v);    					upo.UnApply (after' before' slopes);    					if (after[c] > upo.ColorOutHigh[c]  					    || after[c] < upo.ColorOutLow[c]  					    || (int)Math.Floor (before[c]) < 0  					    || (int)Math.Ceiling (before[c]) > 255  					    || float.IsNaN (before[c])) {  						channelHistogramOutput[v] = 0;  					} else if (before[c] <= upo.ColorInLow[c]) {  						channelHistogramOutput[v] = 0;    						for (int i = 0; i <= upo.ColorInLow[c]; i++) {  							channelHistogramOutput[v] += channelHistogramInput[i];  						}  					} else if (before[c] >= upo.ColorInHigh[c]) {  						channelHistogramOutput[v] = 0;    						for (int i = upo.ColorInHigh[c]; i < 256; i++) {  							channelHistogramOutput[v] += channelHistogramInput[i];  						}  					} else {  						channelHistogramOutput[v] = (int)(slopes[c] * Utility.Lerp (  						    channelHistogramInput[(int)Math.Floor (before[c])]'  						    channelHistogramInput[(int)Math.Ceiling (before[c])]'  						    before[c] - Math.Floor (before[c])));  					}  				}  			}
Magic Number,Pinta.ImageManipulation,HistogramRgb,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\HistogramRGB.cs,SetFromLeveledHistogram,The following statement contains a magic number: for (int c = 0; c < 3; c++) {  				long[] channelHistogramOutput = histogram[c];  				long[] channelHistogramInput = inputHistogram.histogram[c];    				for (int v = 0; v <= 255; v++) {  					ColorBgra after = ColorBgra.FromBgr ((byte)v' (byte)v' (byte)v);    					upo.UnApply (after' before' slopes);    					if (after[c] > upo.ColorOutHigh[c]  					    || after[c] < upo.ColorOutLow[c]  					    || (int)Math.Floor (before[c]) < 0  					    || (int)Math.Ceiling (before[c]) > 255  					    || float.IsNaN (before[c])) {  						channelHistogramOutput[v] = 0;  					} else if (before[c] <= upo.ColorInLow[c]) {  						channelHistogramOutput[v] = 0;    						for (int i = 0; i <= upo.ColorInLow[c]; i++) {  							channelHistogramOutput[v] += channelHistogramInput[i];  						}  					} else if (before[c] >= upo.ColorInHigh[c]) {  						channelHistogramOutput[v] = 0;    						for (int i = upo.ColorInHigh[c]; i < 256; i++) {  							channelHistogramOutput[v] += channelHistogramInput[i];  						}  					} else {  						channelHistogramOutput[v] = (int)(slopes[c] * Utility.Lerp (  						    channelHistogramInput[(int)Math.Floor (before[c])]'  						    channelHistogramInput[(int)Math.Ceiling (before[c])]'  						    before[c] - Math.Floor (before[c])));  					}  				}  			}
Magic Number,Pinta.ImageManipulation,ScaleFactor,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\ScaleFactor.cs,GetNextLarger,The following statement contains a magic number: double ratio = Ratio + 0.005;
Magic Number,Pinta.ImageManipulation,ScaleFactor,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\ScaleFactor.cs,GetNextSmaller,The following statement contains a magic number: double ratio = Ratio - 0.005;
Magic Number,Pinta.ImageManipulation,ScaleFactor,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\ScaleFactor.cs,Reduce,The following statement contains a magic number: int factor = 2;
Magic Number,Pinta.ImageManipulation,ScaleFactor,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\ScaleFactor.cs,FromDouble,The following statement contains a magic number: int numerator = (int)(Math.Floor (scalar * 1000.0));
Magic Number,Pinta.ImageManipulation,ScaleFactor,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\ScaleFactor.cs,FromDouble,The following statement contains a magic number: int denominator = 1000;
Magic Number,Pinta.ImageManipulation,SplineInterpolator,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\SplineInterpolator.cs,Interpolate,The following statement contains a magic number: return a * ya[klo] + b * ya[khi] +                   ((a * a * a - a) * y2[klo] + (b * b * b - b) * y2[khi]) * (h * h) / 6.0;
Magic Number,Pinta.ImageManipulation,SplineInterpolator,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\SplineInterpolator.cs,PreCompute,The following statement contains a magic number: for (int i = 1; i < n - 1; ++i)              {                  // This is the decomposition loop of the tridiagonal algorithm.                   // y2 and u are used for temporary storage of the decomposed factors.                  double wx = xa[i + 1] - xa[i - 1];                  double sig = (xa[i] - xa[i - 1]) / wx;                  double p = sig * y2[i - 1] + 2.0;                    this.y2[i] = (sig - 1.0) / p;                    double ddydx =                       (ya[i + 1] - ya[i]) / (xa[i + 1] - xa[i]) -                       (ya[i] - ya[i - 1]) / (xa[i] - xa[i - 1]);                    u[i] = (6.0 * ddydx / wx - sig * u[i - 1]) / p;              }
Magic Number,Pinta.ImageManipulation,SplineInterpolator,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\SplineInterpolator.cs,PreCompute,The following statement contains a magic number: for (int i = 1; i < n - 1; ++i)              {                  // This is the decomposition loop of the tridiagonal algorithm.                   // y2 and u are used for temporary storage of the decomposed factors.                  double wx = xa[i + 1] - xa[i - 1];                  double sig = (xa[i] - xa[i - 1]) / wx;                  double p = sig * y2[i - 1] + 2.0;                    this.y2[i] = (sig - 1.0) / p;                    double ddydx =                       (ya[i + 1] - ya[i]) / (xa[i + 1] - xa[i]) -                       (ya[i] - ya[i - 1]) / (xa[i] - xa[i - 1]);                    u[i] = (6.0 * ddydx / wx - sig * u[i - 1]) / p;              }
Magic Number,Pinta.ImageManipulation,SplineInterpolator,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\SplineInterpolator.cs,PreCompute,The following statement contains a magic number: for (int i = n - 2; i >= 0; --i)              {                  this.y2[i] = this.y2[i] * this.y2[i + 1] + u[i];              }
Magic Number,Pinta.ImageManipulation,HsvColor,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Structs\HsvColor.cs,GetHashCode,The following statement contains a magic number: return (Hue + (Saturation << 8) + (Value << 16)).GetHashCode();
Magic Number,Pinta.ImageManipulation,HsvColor,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Structs\HsvColor.cs,GetHashCode,The following statement contains a magic number: return (Hue + (Saturation << 8) + (Value << 16)).GetHashCode();
Magic Number,Pinta.ImageManipulation,HsvColor,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Structs\HsvColor.cs,HsvColor,The following statement contains a magic number: if (hue < 0 || hue > 360)              {                  throw new ArgumentOutOfRangeException("hue"' "must be in the range [0' 360]");              }
Magic Number,Pinta.ImageManipulation,HsvColor,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Structs\HsvColor.cs,HsvColor,The following statement contains a magic number: if (saturation < 0 || saturation > 100)              {                  throw new ArgumentOutOfRangeException("saturation"' "must be in the range [0' 100]");              }
Magic Number,Pinta.ImageManipulation,HsvColor,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Structs\HsvColor.cs,HsvColor,The following statement contains a magic number: if (value < 0 || value > 100)              {                  throw new ArgumentOutOfRangeException("value"' "must be in the range [0' 100]");              }
Magic Number,Pinta.ImageManipulation,HsvColor,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Structs\HsvColor.cs,ToRgb,The following statement contains a magic number: h = (double) Hue % 360;
Magic Number,Pinta.ImageManipulation,HsvColor,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Structs\HsvColor.cs,ToRgb,The following statement contains a magic number: s = (double) Saturation / 100;
Magic Number,Pinta.ImageManipulation,HsvColor,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Structs\HsvColor.cs,ToRgb,The following statement contains a magic number: v = (double) Value / 100;
Magic Number,Pinta.ImageManipulation,HsvColor,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Structs\HsvColor.cs,ToRgb,The following statement contains a magic number: if (s == 0)              {                  // If s is 0' all colors are the same.                  // This is some flavor of gray.                  r = v;                  g = v;                  b = v;              }               else               {                  double p;                  double q;                  double t;                    double fractionalSector;                  int sectorNumber;                  double sectorPos;                    // The color wheel consists of 6 sectors.                  // Figure out which sector you're in.                  sectorPos = h / 60;                  sectorNumber = (int)(Math.Floor(sectorPos));                    // get the fractional part of the sector.                  // That is' how many degrees into the sector                  // are you?                  fractionalSector = sectorPos - sectorNumber;                    // Calculate values for the three axes                  // of the color.                   p = v * (1 - s);                  q = v * (1 - (s * fractionalSector));                  t = v * (1 - (s * (1 - fractionalSector)));                    // Assign the fractional colors to r' g' and b                  // based on the sector the angle is in.                  switch (sectorNumber)                   {                      case 0:                          r = v;                          g = t;                          b = p;                          break;                        case 1:                          r = q;                          g = v;                          b = p;                          break;                        case 2:                          r = p;                          g = v;                          b = t;                          break;                        case 3:                          r = p;                          g = q;                          b = v;                          break;                        case 4:                          r = t;                          g = p;                          b = v;                          break;                        case 5:                          r = v;                          g = p;                          b = q;                          break;                  }              }
Magic Number,Pinta.ImageManipulation,HsvColor,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Structs\HsvColor.cs,ToRgb,The following statement contains a magic number: if (s == 0)              {                  // If s is 0' all colors are the same.                  // This is some flavor of gray.                  r = v;                  g = v;                  b = v;              }               else               {                  double p;                  double q;                  double t;                    double fractionalSector;                  int sectorNumber;                  double sectorPos;                    // The color wheel consists of 6 sectors.                  // Figure out which sector you're in.                  sectorPos = h / 60;                  sectorNumber = (int)(Math.Floor(sectorPos));                    // get the fractional part of the sector.                  // That is' how many degrees into the sector                  // are you?                  fractionalSector = sectorPos - sectorNumber;                    // Calculate values for the three axes                  // of the color.                   p = v * (1 - s);                  q = v * (1 - (s * fractionalSector));                  t = v * (1 - (s * (1 - fractionalSector)));                    // Assign the fractional colors to r' g' and b                  // based on the sector the angle is in.                  switch (sectorNumber)                   {                      case 0:                          r = v;                          g = t;                          b = p;                          break;                        case 1:                          r = q;                          g = v;                          b = p;                          break;                        case 2:                          r = p;                          g = v;                          b = t;                          break;                        case 3:                          r = p;                          g = q;                          b = v;                          break;                        case 4:                          r = t;                          g = p;                          b = v;                          break;                        case 5:                          r = v;                          g = p;                          b = q;                          break;                  }              }
Magic Number,Pinta.ImageManipulation,HsvColor,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Structs\HsvColor.cs,ToRgb,The following statement contains a magic number: if (s == 0)              {                  // If s is 0' all colors are the same.                  // This is some flavor of gray.                  r = v;                  g = v;                  b = v;              }               else               {                  double p;                  double q;                  double t;                    double fractionalSector;                  int sectorNumber;                  double sectorPos;                    // The color wheel consists of 6 sectors.                  // Figure out which sector you're in.                  sectorPos = h / 60;                  sectorNumber = (int)(Math.Floor(sectorPos));                    // get the fractional part of the sector.                  // That is' how many degrees into the sector                  // are you?                  fractionalSector = sectorPos - sectorNumber;                    // Calculate values for the three axes                  // of the color.                   p = v * (1 - s);                  q = v * (1 - (s * fractionalSector));                  t = v * (1 - (s * (1 - fractionalSector)));                    // Assign the fractional colors to r' g' and b                  // based on the sector the angle is in.                  switch (sectorNumber)                   {                      case 0:                          r = v;                          g = t;                          b = p;                          break;                        case 1:                          r = q;                          g = v;                          b = p;                          break;                        case 2:                          r = p;                          g = v;                          b = t;                          break;                        case 3:                          r = p;                          g = q;                          b = v;                          break;                        case 4:                          r = t;                          g = p;                          b = v;                          break;                        case 5:                          r = v;                          g = p;                          b = q;                          break;                  }              }
Magic Number,Pinta.ImageManipulation,HsvColor,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Structs\HsvColor.cs,ToRgb,The following statement contains a magic number: if (s == 0)              {                  // If s is 0' all colors are the same.                  // This is some flavor of gray.                  r = v;                  g = v;                  b = v;              }               else               {                  double p;                  double q;                  double t;                    double fractionalSector;                  int sectorNumber;                  double sectorPos;                    // The color wheel consists of 6 sectors.                  // Figure out which sector you're in.                  sectorPos = h / 60;                  sectorNumber = (int)(Math.Floor(sectorPos));                    // get the fractional part of the sector.                  // That is' how many degrees into the sector                  // are you?                  fractionalSector = sectorPos - sectorNumber;                    // Calculate values for the three axes                  // of the color.                   p = v * (1 - s);                  q = v * (1 - (s * fractionalSector));                  t = v * (1 - (s * (1 - fractionalSector)));                    // Assign the fractional colors to r' g' and b                  // based on the sector the angle is in.                  switch (sectorNumber)                   {                      case 0:                          r = v;                          g = t;                          b = p;                          break;                        case 1:                          r = q;                          g = v;                          b = p;                          break;                        case 2:                          r = p;                          g = v;                          b = t;                          break;                        case 3:                          r = p;                          g = q;                          b = v;                          break;                        case 4:                          r = t;                          g = p;                          b = v;                          break;                        case 5:                          r = v;                          g = p;                          b = q;                          break;                  }              }
Magic Number,Pinta.ImageManipulation,HsvColor,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Structs\HsvColor.cs,ToRgb,The following statement contains a magic number: if (s == 0)              {                  // If s is 0' all colors are the same.                  // This is some flavor of gray.                  r = v;                  g = v;                  b = v;              }               else               {                  double p;                  double q;                  double t;                    double fractionalSector;                  int sectorNumber;                  double sectorPos;                    // The color wheel consists of 6 sectors.                  // Figure out which sector you're in.                  sectorPos = h / 60;                  sectorNumber = (int)(Math.Floor(sectorPos));                    // get the fractional part of the sector.                  // That is' how many degrees into the sector                  // are you?                  fractionalSector = sectorPos - sectorNumber;                    // Calculate values for the three axes                  // of the color.                   p = v * (1 - s);                  q = v * (1 - (s * fractionalSector));                  t = v * (1 - (s * (1 - fractionalSector)));                    // Assign the fractional colors to r' g' and b                  // based on the sector the angle is in.                  switch (sectorNumber)                   {                      case 0:                          r = v;                          g = t;                          b = p;                          break;                        case 1:                          r = q;                          g = v;                          b = p;                          break;                        case 2:                          r = p;                          g = v;                          b = t;                          break;                        case 3:                          r = p;                          g = q;                          b = v;                          break;                        case 4:                          r = t;                          g = p;                          b = v;                          break;                        case 5:                          r = v;                          g = p;                          b = q;                          break;                  }              }
Magic Number,Pinta.ImageManipulation,HsvColor,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Structs\HsvColor.cs,ToRgb,The following statement contains a magic number: return new RgbColor((int)(r * 255)' (int)(g * 255)' (int)(b * 255));
Magic Number,Pinta.ImageManipulation,HsvColor,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Structs\HsvColor.cs,ToRgb,The following statement contains a magic number: return new RgbColor((int)(r * 255)' (int)(g * 255)' (int)(b * 255));
Magic Number,Pinta.ImageManipulation,HsvColor,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Structs\HsvColor.cs,ToRgb,The following statement contains a magic number: return new RgbColor((int)(r * 255)' (int)(g * 255)' (int)(b * 255));
Magic Number,Pinta.ImageManipulation,RgbColor,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Structs\RgbColor.cs,RgbColor,The following statement contains a magic number: if (R < 0 || R > 255)               {                  throw new ArgumentOutOfRangeException("R"' R' "R must corrospond to a byte value");              }
Magic Number,Pinta.ImageManipulation,RgbColor,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Structs\RgbColor.cs,RgbColor,The following statement contains a magic number: if (G < 0 || G > 255)               {                  throw new ArgumentOutOfRangeException("G"' G' "G must corrospond to a byte value");              }
Magic Number,Pinta.ImageManipulation,RgbColor,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Structs\RgbColor.cs,RgbColor,The following statement contains a magic number: if (B < 0 || B > 255)               {                  throw new ArgumentOutOfRangeException("B"' B' "B must corrospond to a byte value");              }
Magic Number,Pinta.ImageManipulation,RgbColor,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Structs\RgbColor.cs,ToHsv,The following statement contains a magic number: double r = (double) Red / 255;
Magic Number,Pinta.ImageManipulation,RgbColor,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Structs\RgbColor.cs,ToHsv,The following statement contains a magic number: double g = (double) Green / 255;
Magic Number,Pinta.ImageManipulation,RgbColor,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Structs\RgbColor.cs,ToHsv,The following statement contains a magic number: double b = (double) Blue / 255;
Magic Number,Pinta.ImageManipulation,RgbColor,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Structs\RgbColor.cs,ToHsv,The following statement contains a magic number: if (max == 0 || delta == 0)               {                  // R' G' and B must be 0' or all the same.                  // In this case' S is 0' and H is undefined.                  // Using H = 0 is as good as any...                  s = 0;                  h = 0;              }               else               {                  s = delta / max;                  if (r == max)                   {                      // Between Yellow and Magenta                      h = (g - b) / delta;                  }                   else if (g == max)                   {                      // Between Cyan and Yellow                      h = 2 + (b - r) / delta;                  }                   else                   {                      // Between Magenta and Cyan                      h = 4 + (r - g) / delta;                  }                }
Magic Number,Pinta.ImageManipulation,RgbColor,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Structs\RgbColor.cs,ToHsv,The following statement contains a magic number: if (max == 0 || delta == 0)               {                  // R' G' and B must be 0' or all the same.                  // In this case' S is 0' and H is undefined.                  // Using H = 0 is as good as any...                  s = 0;                  h = 0;              }               else               {                  s = delta / max;                  if (r == max)                   {                      // Between Yellow and Magenta                      h = (g - b) / delta;                  }                   else if (g == max)                   {                      // Between Cyan and Yellow                      h = 2 + (b - r) / delta;                  }                   else                   {                      // Between Magenta and Cyan                      h = 4 + (r - g) / delta;                  }                }
Magic Number,Pinta.ImageManipulation,RgbColor,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Structs\RgbColor.cs,ToHsv,The following statement contains a magic number: h *= 60;
Magic Number,Pinta.ImageManipulation,RgbColor,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Structs\RgbColor.cs,ToHsv,The following statement contains a magic number: if (h < 0)              {                  h += 360;              }
Magic Number,Pinta.ImageManipulation,RgbColor,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Structs\RgbColor.cs,ToHsv,The following statement contains a magic number: return new HsvColor((int)h' (int)(s * 100)' (int)(v * 100));
Magic Number,Pinta.ImageManipulation,RgbColor,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Structs\RgbColor.cs,ToHsv,The following statement contains a magic number: return new HsvColor((int)h' (int)(s * 100)' (int)(v * 100));
Magic Number,Pinta.ImageManipulation,ColorBgra,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Structs\ColorBgra.cs,ParseHexString,The following statement contains a magic number: uint value = Convert.ToUInt32(hexString' 16);
Magic Number,Pinta.ImageManipulation,ColorBgra,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Structs\ColorBgra.cs,ToHexString,The following statement contains a magic number: int rgbNumber = (this.R << 16) | (this.G << 8) | this.B;
Magic Number,Pinta.ImageManipulation,ColorBgra,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Structs\ColorBgra.cs,ToHexString,The following statement contains a magic number: int rgbNumber = (this.R << 16) | (this.G << 8) | this.B;
Magic Number,Pinta.ImageManipulation,ColorBgra,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Structs\ColorBgra.cs,ToHexString,The following statement contains a magic number: string colorString = Convert.ToString(rgbNumber' 16);
Magic Number,Pinta.ImageManipulation,ColorBgra,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Structs\ColorBgra.cs,ToHexString,The following statement contains a magic number: while (colorString.Length < 6)              {                  colorString = "0" + colorString;              }
Magic Number,Pinta.ImageManipulation,ColorBgra,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Structs\ColorBgra.cs,ToHexString,The following statement contains a magic number: string alphaString = System.Convert.ToString(this.A' 16);
Magic Number,Pinta.ImageManipulation,ColorBgra,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Structs\ColorBgra.cs,ToHexString,The following statement contains a magic number: while (alphaString.Length < 2)              {                  alphaString = "0" + alphaString;              }
Magic Number,Pinta.ImageManipulation,ColorBgra,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Structs\ColorBgra.cs,GetIntensity,The following statement contains a magic number: return ((0.114 * (double)B) + (0.587 * (double)G) + (0.299 * (double)R)) / 255.0;
Magic Number,Pinta.ImageManipulation,ColorBgra,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Structs\ColorBgra.cs,GetIntensity,The following statement contains a magic number: return ((0.114 * (double)B) + (0.587 * (double)G) + (0.299 * (double)R)) / 255.0;
Magic Number,Pinta.ImageManipulation,ColorBgra,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Structs\ColorBgra.cs,GetIntensity,The following statement contains a magic number: return ((0.114 * (double)B) + (0.587 * (double)G) + (0.299 * (double)R)) / 255.0;
Magic Number,Pinta.ImageManipulation,ColorBgra,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Structs\ColorBgra.cs,GetIntensity,The following statement contains a magic number: return ((0.114 * (double)B) + (0.587 * (double)G) + (0.299 * (double)R)) / 255.0;
Magic Number,Pinta.ImageManipulation,ColorBgra,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Structs\ColorBgra.cs,GetIntensityByte,The following statement contains a magic number: return (byte)((7471 * B + 38470 * G + 19595 * R) >> 16);
Magic Number,Pinta.ImageManipulation,ColorBgra,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Structs\ColorBgra.cs,GetIntensityByte,The following statement contains a magic number: return (byte)((7471 * B + 38470 * G + 19595 * R) >> 16);
Magic Number,Pinta.ImageManipulation,ColorBgra,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Structs\ColorBgra.cs,GetIntensityByte,The following statement contains a magic number: return (byte)((7471 * B + 38470 * G + 19595 * R) >> 16);
Magic Number,Pinta.ImageManipulation,ColorBgra,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Structs\ColorBgra.cs,GetIntensityByte,The following statement contains a magic number: return (byte)((7471 * B + 38470 * G + 19595 * R) >> 16);
Magic Number,Pinta.ImageManipulation,ColorBgra,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Structs\ColorBgra.cs,GetAverageColorChannelValue,The following statement contains a magic number: return (byte)((this.B + this.G + this.R) / 3);
Magic Number,Pinta.ImageManipulation,ColorBgra,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Structs\ColorBgra.cs,ClampToByte,The following statement contains a magic number: if (x > 255)              {                  return 255;              }              else if (x < 0)              {                  return 0;              }              else              {                  return (byte)x;              }
Magic Number,Pinta.ImageManipulation,ColorBgra,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Structs\ColorBgra.cs,ClampToByte,The following statement contains a magic number: if (x > 255)              {                  return 255;              }              else if (x < 0)              {                  return 0;              }              else              {                  return (byte)x;              }
Magic Number,Pinta.ImageManipulation,ColorBgra,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Structs\ColorBgra.cs,BgraToUInt32,The following statement contains a magic number: return (uint)b + ((uint)g << 8) + ((uint)r << 16) + ((uint)a << 24);
Magic Number,Pinta.ImageManipulation,ColorBgra,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Structs\ColorBgra.cs,BgraToUInt32,The following statement contains a magic number: return (uint)b + ((uint)g << 8) + ((uint)r << 16) + ((uint)a << 24);
Magic Number,Pinta.ImageManipulation,ColorBgra,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Structs\ColorBgra.cs,BgraToUInt32,The following statement contains a magic number: return (uint)b + ((uint)g << 8) + ((uint)r << 16) + ((uint)a << 24);
Magic Number,Pinta.ImageManipulation,ColorBgra,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Structs\ColorBgra.cs,BgraToUInt32,The following statement contains a magic number: return (uint)b + ((uint)g << 8) + ((uint)r << 16) + ((uint)a << 24);
Magic Number,Pinta.ImageManipulation,ColorBgra,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Structs\ColorBgra.cs,BgraToUInt32,The following statement contains a magic number: return (uint)b + ((uint)g << 8) + ((uint)r << 16) + ((uint)a << 24);
Magic Number,Pinta.ImageManipulation,ColorBgra,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Structs\ColorBgra.cs,BgraToUInt32,The following statement contains a magic number: return (uint)b + ((uint)g << 8) + ((uint)r << 16) + ((uint)a << 24);
Magic Number,Pinta.ImageManipulation,ColorBgra,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Structs\ColorBgra.cs,FromBgr,The following statement contains a magic number: return FromBgra(b' g' r' 255);
Magic Number,Pinta.ImageManipulation,ColorBgra,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Structs\ColorBgra.cs,ClampToByte,The following statement contains a magic number: if (x > 255)              {                  return 255;              }              else if (x < 0)              {                  return 0;              }              else              {                  return (byte)x;              }
Magic Number,Pinta.ImageManipulation,ColorBgra,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Structs\ColorBgra.cs,ClampToByte,The following statement contains a magic number: if (x > 255)              {                  return 255;              }              else if (x < 0)              {                  return 0;              }              else              {                  return (byte)x;              }
Magic Number,Pinta.ImageManipulation,ColorBgra,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Structs\ColorBgra.cs,Blend,The following statement contains a magic number: uint caA = (uint)Utility.FastScaleByteByByte ((byte)(255 - cbAlpha)' ca.A);
Magic Number,Pinta.ImageManipulation,ColorBgra,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Structs\ColorBgra.cs,ClampToByte,The following statement contains a magic number: if (x > 255)              {                  return 255;              }              else if (x < 0)              {                  return 0;              }              else              {                  return (byte)x;              }
Magic Number,Pinta.ImageManipulation,ColorBgra,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Structs\ColorBgra.cs,ClampToByte,The following statement contains a magic number: if (x > 255)              {                  return 255;              }              else if (x < 0)              {                  return 0;              }              else              {                  return (byte)x;              }
Magic Number,Pinta.ImageManipulation,ColorBgra,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Structs\ColorBgra.cs,BlendColors4W16IP,The following statement contains a magic number: if ((w1 + w2 + w3 + w4) != 65536)              {                  throw new ArgumentOutOfRangeException("w1 + w2 + w3 + w4 must equal 65536!");              }
Magic Number,Pinta.ImageManipulation,ColorBgra,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Structs\ColorBgra.cs,BlendColors4W16IP,The following statement contains a magic number: const uint ww = 32768;
Magic Number,Pinta.ImageManipulation,ColorBgra,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Structs\ColorBgra.cs,BlendColors4W16IP,The following statement contains a magic number: uint a = (af + ww) >> 16;
Magic Number,Pinta.ImageManipulation,ColorBgra,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Structs\ColorBgra.cs,BlendColorsWAIP,The following statement contains a magic number: return ColorBgra.FromUInt32((uint)b + ((uint)g << 8) + ((uint)r << 16) + ((uint)a << 24));
Magic Number,Pinta.ImageManipulation,ColorBgra,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Structs\ColorBgra.cs,BlendColorsWAIP,The following statement contains a magic number: return ColorBgra.FromUInt32((uint)b + ((uint)g << 8) + ((uint)r << 16) + ((uint)a << 24));
Magic Number,Pinta.ImageManipulation,ColorBgra,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Structs\ColorBgra.cs,BlendColorsWAIP,The following statement contains a magic number: return ColorBgra.FromUInt32((uint)b + ((uint)g << 8) + ((uint)r << 16) + ((uint)a << 24));
Magic Number,Pinta.ImageManipulation,SurfaceDiff,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\SurfaceDiff.cs,Create,The following statement contains a magic number: var savings = 100 - (float)num_changed / (float)(orig_width * orig_height) * 100;
Magic Number,Pinta.ImageManipulation,SurfaceDiff,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\SurfaceDiff.cs,Create,The following statement contains a magic number: var savings = 100 - (float)num_changed / (float)(orig_width * orig_height) * 100;
Magic Number,Pinta.ImageManipulation,Utility,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Utility.cs,ClampToByte,The following statement contains a magic number: if (x > 255) {  				return 255;  			} else if (x < 0) {  				return 0;  			} else {  				return (byte)x;  			}
Magic Number,Pinta.ImageManipulation,Utility,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Utility.cs,ClampToByte,The following statement contains a magic number: if (x > 255) {  				return 255;  			} else if (x < 0) {  				return 0;  			} else {  				return (byte)x;  			}
Magic Number,Pinta.ImageManipulation,Utility,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Utility.cs,ClampToByte,The following statement contains a magic number: if (x > 255) {  				return 255;  			} else if (x < 0) {  				return 0;  			} else {  				return (byte)x;  			}
Magic Number,Pinta.ImageManipulation,Utility,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Utility.cs,ClampToByte,The following statement contains a magic number: if (x > 255) {  				return 255;  			} else if (x < 0) {  				return 0;  			} else {  				return (byte)x;  			}
Magic Number,Pinta.ImageManipulation,Utility,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Utility.cs,ClampToByte,The following statement contains a magic number: if (x > 255) {  				return 255;  			} else if (x < 0) {  				return 0;  			} else {  				return (byte)x;  			}
Magic Number,Pinta.ImageManipulation,Utility,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Utility.cs,ClampToByte,The following statement contains a magic number: if (x > 255) {  				return 255;  			} else if (x < 0) {  				return 0;  			} else {  				return (byte)x;  			}
Magic Number,Pinta.ImageManipulation,Utility,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Utility.cs,FastDivideShortByByte,The following statement contains a magic number: int i = d * 3;
Magic Number,Pinta.ImageManipulation,Utility,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Utility.cs,FastDivideShortByByte,The following statement contains a magic number: uint s = masTable[i + 2];
Magic Number,Pinta.ImageManipulation,Utility,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Utility.cs,GetBilinearSampleClamped,The following statement contains a magic number: unchecked {  				int iu = (int)Math.Floor (u);  				uint sxfrac = (uint)(256 * (u - (float)iu));  				uint sxfracinv = 256 - sxfrac;    				int iv = (int)Math.Floor (v);  				uint syfrac = (uint)(256 * (v - (float)iv));  				uint syfracinv = 256 - syfrac;    				uint wul = (uint)(sxfracinv * syfracinv);  				uint wur = (uint)(sxfrac * syfracinv);  				uint wll = (uint)(sxfracinv * syfrac);  				uint wlr = (uint)(sxfrac * syfrac);    				int sx = iu;  				int sy = iv;  				int sleft = sx;  				int sright;    				if (sleft == (src.Width - 1))  					sright = sleft;  				else  					sright = sleft + 1;    				int stop = sy;  				int sbottom;    				if (stop == (src.Height - 1))  					sbottom = stop;  				else  					sbottom = stop + 1;    				ColorBgra* cul = src.GetPointAddress (sleft' stop);  				ColorBgra* cur = cul + (sright - sleft);  				ColorBgra* cll = src.GetPointAddress (sleft' sbottom);  				ColorBgra* clr = cll + (sright - sleft);    				ColorBgra c = ColorBgra.BlendColors4W16IP (*cul' wul' *cur' wur' *cll' wll' *clr' wlr);  				return c;  			}
Magic Number,Pinta.ImageManipulation,Utility,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Utility.cs,GetBilinearSampleClamped,The following statement contains a magic number: unchecked {  				int iu = (int)Math.Floor (u);  				uint sxfrac = (uint)(256 * (u - (float)iu));  				uint sxfracinv = 256 - sxfrac;    				int iv = (int)Math.Floor (v);  				uint syfrac = (uint)(256 * (v - (float)iv));  				uint syfracinv = 256 - syfrac;    				uint wul = (uint)(sxfracinv * syfracinv);  				uint wur = (uint)(sxfrac * syfracinv);  				uint wll = (uint)(sxfracinv * syfrac);  				uint wlr = (uint)(sxfrac * syfrac);    				int sx = iu;  				int sy = iv;  				int sleft = sx;  				int sright;    				if (sleft == (src.Width - 1))  					sright = sleft;  				else  					sright = sleft + 1;    				int stop = sy;  				int sbottom;    				if (stop == (src.Height - 1))  					sbottom = stop;  				else  					sbottom = stop + 1;    				ColorBgra* cul = src.GetPointAddress (sleft' stop);  				ColorBgra* cur = cul + (sright - sleft);  				ColorBgra* cll = src.GetPointAddress (sleft' sbottom);  				ColorBgra* clr = cll + (sright - sleft);    				ColorBgra c = ColorBgra.BlendColors4W16IP (*cul' wul' *cur' wur' *cll' wll' *clr' wlr);  				return c;  			}
Magic Number,Pinta.ImageManipulation,Utility,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Utility.cs,GetBilinearSampleClamped,The following statement contains a magic number: unchecked {  				int iu = (int)Math.Floor (u);  				uint sxfrac = (uint)(256 * (u - (float)iu));  				uint sxfracinv = 256 - sxfrac;    				int iv = (int)Math.Floor (v);  				uint syfrac = (uint)(256 * (v - (float)iv));  				uint syfracinv = 256 - syfrac;    				uint wul = (uint)(sxfracinv * syfracinv);  				uint wur = (uint)(sxfrac * syfracinv);  				uint wll = (uint)(sxfracinv * syfrac);  				uint wlr = (uint)(sxfrac * syfrac);    				int sx = iu;  				int sy = iv;  				int sleft = sx;  				int sright;    				if (sleft == (src.Width - 1))  					sright = sleft;  				else  					sright = sleft + 1;    				int stop = sy;  				int sbottom;    				if (stop == (src.Height - 1))  					sbottom = stop;  				else  					sbottom = stop + 1;    				ColorBgra* cul = src.GetPointAddress (sleft' stop);  				ColorBgra* cur = cul + (sright - sleft);  				ColorBgra* cll = src.GetPointAddress (sleft' sbottom);  				ColorBgra* clr = cll + (sright - sleft);    				ColorBgra c = ColorBgra.BlendColors4W16IP (*cul' wul' *cur' wur' *cll' wll' *clr' wlr);  				return c;  			}
Magic Number,Pinta.ImageManipulation,Utility,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Utility.cs,GetBilinearSampleClamped,The following statement contains a magic number: unchecked {  				int iu = (int)Math.Floor (u);  				uint sxfrac = (uint)(256 * (u - (float)iu));  				uint sxfracinv = 256 - sxfrac;    				int iv = (int)Math.Floor (v);  				uint syfrac = (uint)(256 * (v - (float)iv));  				uint syfracinv = 256 - syfrac;    				uint wul = (uint)(sxfracinv * syfracinv);  				uint wur = (uint)(sxfrac * syfracinv);  				uint wll = (uint)(sxfracinv * syfrac);  				uint wlr = (uint)(sxfrac * syfrac);    				int sx = iu;  				int sy = iv;  				int sleft = sx;  				int sright;    				if (sleft == (src.Width - 1))  					sright = sleft;  				else  					sright = sleft + 1;    				int stop = sy;  				int sbottom;    				if (stop == (src.Height - 1))  					sbottom = stop;  				else  					sbottom = stop + 1;    				ColorBgra* cul = src.GetPointAddress (sleft' stop);  				ColorBgra* cur = cul + (sright - sleft);  				ColorBgra* cll = src.GetPointAddress (sleft' sbottom);  				ColorBgra* clr = cll + (sright - sleft);    				ColorBgra c = ColorBgra.BlendColors4W16IP (*cul' wul' *cur' wur' *cll' wll' *clr' wlr);  				return c;  			}
Magic Number,Pinta.ImageManipulation,Utility,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Utility.cs,GetBilinearSampleWrapped,The following statement contains a magic number: unchecked {  				int iu = (int)Math.Floor (u);  				uint sxfrac = (uint)(256 * (u - (float)iu));  				uint sxfracinv = 256 - sxfrac;    				int iv = (int)Math.Floor (v);  				uint syfrac = (uint)(256 * (v - (float)iv));  				uint syfracinv = 256 - syfrac;    				uint wul = (uint)(sxfracinv * syfracinv);  				uint wur = (uint)(sxfrac * syfracinv);  				uint wll = (uint)(sxfracinv * syfrac);  				uint wlr = (uint)(sxfrac * syfrac);    				int sx = iu;  				if (sx < 0)  					sx = (srcWidth - 1) + ((sx + 1) % srcWidth);  				else if (sx > (srcWidth - 1))  					sx = sx % srcWidth;    				int sy = iv;  				if (sy < 0)  					sy = (srcHeight - 1) + ((sy + 1) % srcHeight);  				else if (sy > (srcHeight - 1))  					sy = sy % srcHeight;    				int sleft = sx;  				int sright;    				if (sleft == (srcWidth - 1))  					sright = 0;  				else  					sright = sleft + 1;    				int stop = sy;  				int sbottom;    				if (stop == (srcHeight - 1))  					sbottom = 0;  				else  					sbottom = stop + 1;    				ColorBgra cul = src.GetPoint (sleft' stop);  				ColorBgra cur = src.GetPoint (sright' stop);  				ColorBgra cll = src.GetPoint (sleft' sbottom);  				ColorBgra clr = src.GetPoint (sright' sbottom);    				ColorBgra c = ColorBgra.BlendColors4W16IP (cul' wul' cur' wur' cll' wll' clr' wlr);    				return c;  			}
Magic Number,Pinta.ImageManipulation,Utility,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Utility.cs,GetBilinearSampleWrapped,The following statement contains a magic number: unchecked {  				int iu = (int)Math.Floor (u);  				uint sxfrac = (uint)(256 * (u - (float)iu));  				uint sxfracinv = 256 - sxfrac;    				int iv = (int)Math.Floor (v);  				uint syfrac = (uint)(256 * (v - (float)iv));  				uint syfracinv = 256 - syfrac;    				uint wul = (uint)(sxfracinv * syfracinv);  				uint wur = (uint)(sxfrac * syfracinv);  				uint wll = (uint)(sxfracinv * syfrac);  				uint wlr = (uint)(sxfrac * syfrac);    				int sx = iu;  				if (sx < 0)  					sx = (srcWidth - 1) + ((sx + 1) % srcWidth);  				else if (sx > (srcWidth - 1))  					sx = sx % srcWidth;    				int sy = iv;  				if (sy < 0)  					sy = (srcHeight - 1) + ((sy + 1) % srcHeight);  				else if (sy > (srcHeight - 1))  					sy = sy % srcHeight;    				int sleft = sx;  				int sright;    				if (sleft == (srcWidth - 1))  					sright = 0;  				else  					sright = sleft + 1;    				int stop = sy;  				int sbottom;    				if (stop == (srcHeight - 1))  					sbottom = 0;  				else  					sbottom = stop + 1;    				ColorBgra cul = src.GetPoint (sleft' stop);  				ColorBgra cur = src.GetPoint (sright' stop);  				ColorBgra cll = src.GetPoint (sleft' sbottom);  				ColorBgra clr = src.GetPoint (sright' sbottom);    				ColorBgra c = ColorBgra.BlendColors4W16IP (cul' wul' cur' wur' cll' wll' clr' wlr);    				return c;  			}
Magic Number,Pinta.ImageManipulation,Utility,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Utility.cs,GetBilinearSampleWrapped,The following statement contains a magic number: unchecked {  				int iu = (int)Math.Floor (u);  				uint sxfrac = (uint)(256 * (u - (float)iu));  				uint sxfracinv = 256 - sxfrac;    				int iv = (int)Math.Floor (v);  				uint syfrac = (uint)(256 * (v - (float)iv));  				uint syfracinv = 256 - syfrac;    				uint wul = (uint)(sxfracinv * syfracinv);  				uint wur = (uint)(sxfrac * syfracinv);  				uint wll = (uint)(sxfracinv * syfrac);  				uint wlr = (uint)(sxfrac * syfrac);    				int sx = iu;  				if (sx < 0)  					sx = (srcWidth - 1) + ((sx + 1) % srcWidth);  				else if (sx > (srcWidth - 1))  					sx = sx % srcWidth;    				int sy = iv;  				if (sy < 0)  					sy = (srcHeight - 1) + ((sy + 1) % srcHeight);  				else if (sy > (srcHeight - 1))  					sy = sy % srcHeight;    				int sleft = sx;  				int sright;    				if (sleft == (srcWidth - 1))  					sright = 0;  				else  					sright = sleft + 1;    				int stop = sy;  				int sbottom;    				if (stop == (srcHeight - 1))  					sbottom = 0;  				else  					sbottom = stop + 1;    				ColorBgra cul = src.GetPoint (sleft' stop);  				ColorBgra cur = src.GetPoint (sright' stop);  				ColorBgra cll = src.GetPoint (sleft' sbottom);  				ColorBgra clr = src.GetPoint (sright' sbottom);    				ColorBgra c = ColorBgra.BlendColors4W16IP (cul' wul' cur' wur' cll' wll' clr' wlr);    				return c;  			}
Magic Number,Pinta.ImageManipulation,Utility,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Utility.cs,GetBilinearSampleWrapped,The following statement contains a magic number: unchecked {  				int iu = (int)Math.Floor (u);  				uint sxfrac = (uint)(256 * (u - (float)iu));  				uint sxfracinv = 256 - sxfrac;    				int iv = (int)Math.Floor (v);  				uint syfrac = (uint)(256 * (v - (float)iv));  				uint syfracinv = 256 - syfrac;    				uint wul = (uint)(sxfracinv * syfracinv);  				uint wur = (uint)(sxfrac * syfracinv);  				uint wll = (uint)(sxfracinv * syfrac);  				uint wlr = (uint)(sxfrac * syfrac);    				int sx = iu;  				if (sx < 0)  					sx = (srcWidth - 1) + ((sx + 1) % srcWidth);  				else if (sx > (srcWidth - 1))  					sx = sx % srcWidth;    				int sy = iv;  				if (sy < 0)  					sy = (srcHeight - 1) + ((sy + 1) % srcHeight);  				else if (sy > (srcHeight - 1))  					sy = sy % srcHeight;    				int sleft = sx;  				int sright;    				if (sleft == (srcWidth - 1))  					sright = 0;  				else  					sright = sleft + 1;    				int stop = sy;  				int sbottom;    				if (stop == (srcHeight - 1))  					sbottom = 0;  				else  					sbottom = stop + 1;    				ColorBgra cul = src.GetPoint (sleft' stop);  				ColorBgra cur = src.GetPoint (sright' stop);  				ColorBgra cll = src.GetPoint (sleft' sbottom);  				ColorBgra clr = src.GetPoint (sright' sbottom);    				ColorBgra c = ColorBgra.BlendColors4W16IP (cul' wul' cur' wur' cll' wll' clr' wlr);    				return c;  			}
Magic Number,Pinta.ImageManipulation,Utility,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Utility.cs,FastScaleByteByByte,The following statement contains a magic number: int r2 = ((r1 >> 8) + r1) >> 8;
Magic Number,Pinta.ImageManipulation,Utility,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Utility.cs,FastScaleByteByByte,The following statement contains a magic number: int r2 = ((r1 >> 8) + r1) >> 8;
Magic Number,Pinta.ImageManipulation.Effects,AddNoiseEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\AddNoiseEffect.cs,AddNoiseEffect,The following statement contains a magic number: if (intensity < 0 || intensity > 100)  				throw new ArgumentOutOfRangeException ("intensity");
Magic Number,Pinta.ImageManipulation.Effects,AddNoiseEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\AddNoiseEffect.cs,AddNoiseEffect,The following statement contains a magic number: if (colorSaturation < 0 || colorSaturation > 400)  				throw new ArgumentOutOfRangeException ("colorSaturation");
Magic Number,Pinta.ImageManipulation.Effects,AddNoiseEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\AddNoiseEffect.cs,AddNoiseEffect,The following statement contains a magic number: if (coverage < 0 || coverage > 100)  				throw new ArgumentOutOfRangeException ("coverage");
Magic Number,Pinta.ImageManipulation.Effects,AddNoiseEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\AddNoiseEffect.cs,AddNoiseEffect,The following statement contains a magic number: this.coverage = coverage * 0.01;
Magic Number,Pinta.ImageManipulation.Effects,AddNoiseEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\AddNoiseEffect.cs,AddNoiseEffect,The following statement contains a magic number: dev = this.intensity * this.intensity / 4;
Magic Number,Pinta.ImageManipulation.Effects,AddNoiseEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\AddNoiseEffect.cs,AddNoiseEffect,The following statement contains a magic number: sat = this.color_saturation * 4096 / 100;
Magic Number,Pinta.ImageManipulation.Effects,AddNoiseEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\AddNoiseEffect.cs,AddNoiseEffect,The following statement contains a magic number: sat = this.color_saturation * 4096 / 100;
Magic Number,Pinta.ImageManipulation.Effects,AddNoiseEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\AddNoiseEffect.cs,Render,The following statement contains a magic number: for (var x = 0; x < length; ++x) {  				if (threadRand.NextDouble () > coverage) {  					*dst = *src;  				} else {  					int r;  					int g;  					int b;  					int i;    					r = localLookup[threadRand.Next (tableSize)];  					g = localLookup[threadRand.Next (tableSize)];  					b = localLookup[threadRand.Next (tableSize)];    					i = (4899 * r + 9618 * g + 1867 * b) >> 14;      					r = i + (((r - i) * sat) >> 12);  					g = i + (((g - i) * sat) >> 12);  					b = i + (((b - i) * sat) >> 12);    					dst->R = Utility.ClampToByte (src->R + ((r * dev + 32768) >> 16));  					dst->G = Utility.ClampToByte (src->G + ((g * dev + 32768) >> 16));  					dst->B = Utility.ClampToByte (src->B + ((b * dev + 32768) >> 16));  					dst->A = src->A;  				}    				++src;  				++dst;  			}
Magic Number,Pinta.ImageManipulation.Effects,AddNoiseEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\AddNoiseEffect.cs,Render,The following statement contains a magic number: for (var x = 0; x < length; ++x) {  				if (threadRand.NextDouble () > coverage) {  					*dst = *src;  				} else {  					int r;  					int g;  					int b;  					int i;    					r = localLookup[threadRand.Next (tableSize)];  					g = localLookup[threadRand.Next (tableSize)];  					b = localLookup[threadRand.Next (tableSize)];    					i = (4899 * r + 9618 * g + 1867 * b) >> 14;      					r = i + (((r - i) * sat) >> 12);  					g = i + (((g - i) * sat) >> 12);  					b = i + (((b - i) * sat) >> 12);    					dst->R = Utility.ClampToByte (src->R + ((r * dev + 32768) >> 16));  					dst->G = Utility.ClampToByte (src->G + ((g * dev + 32768) >> 16));  					dst->B = Utility.ClampToByte (src->B + ((b * dev + 32768) >> 16));  					dst->A = src->A;  				}    				++src;  				++dst;  			}
Magic Number,Pinta.ImageManipulation.Effects,AddNoiseEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\AddNoiseEffect.cs,Render,The following statement contains a magic number: for (var x = 0; x < length; ++x) {  				if (threadRand.NextDouble () > coverage) {  					*dst = *src;  				} else {  					int r;  					int g;  					int b;  					int i;    					r = localLookup[threadRand.Next (tableSize)];  					g = localLookup[threadRand.Next (tableSize)];  					b = localLookup[threadRand.Next (tableSize)];    					i = (4899 * r + 9618 * g + 1867 * b) >> 14;      					r = i + (((r - i) * sat) >> 12);  					g = i + (((g - i) * sat) >> 12);  					b = i + (((b - i) * sat) >> 12);    					dst->R = Utility.ClampToByte (src->R + ((r * dev + 32768) >> 16));  					dst->G = Utility.ClampToByte (src->G + ((g * dev + 32768) >> 16));  					dst->B = Utility.ClampToByte (src->B + ((b * dev + 32768) >> 16));  					dst->A = src->A;  				}    				++src;  				++dst;  			}
Magic Number,Pinta.ImageManipulation.Effects,AddNoiseEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\AddNoiseEffect.cs,Render,The following statement contains a magic number: for (var x = 0; x < length; ++x) {  				if (threadRand.NextDouble () > coverage) {  					*dst = *src;  				} else {  					int r;  					int g;  					int b;  					int i;    					r = localLookup[threadRand.Next (tableSize)];  					g = localLookup[threadRand.Next (tableSize)];  					b = localLookup[threadRand.Next (tableSize)];    					i = (4899 * r + 9618 * g + 1867 * b) >> 14;      					r = i + (((r - i) * sat) >> 12);  					g = i + (((g - i) * sat) >> 12);  					b = i + (((b - i) * sat) >> 12);    					dst->R = Utility.ClampToByte (src->R + ((r * dev + 32768) >> 16));  					dst->G = Utility.ClampToByte (src->G + ((g * dev + 32768) >> 16));  					dst->B = Utility.ClampToByte (src->B + ((b * dev + 32768) >> 16));  					dst->A = src->A;  				}    				++src;  				++dst;  			}
Magic Number,Pinta.ImageManipulation.Effects,AddNoiseEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\AddNoiseEffect.cs,Render,The following statement contains a magic number: for (var x = 0; x < length; ++x) {  				if (threadRand.NextDouble () > coverage) {  					*dst = *src;  				} else {  					int r;  					int g;  					int b;  					int i;    					r = localLookup[threadRand.Next (tableSize)];  					g = localLookup[threadRand.Next (tableSize)];  					b = localLookup[threadRand.Next (tableSize)];    					i = (4899 * r + 9618 * g + 1867 * b) >> 14;      					r = i + (((r - i) * sat) >> 12);  					g = i + (((g - i) * sat) >> 12);  					b = i + (((b - i) * sat) >> 12);    					dst->R = Utility.ClampToByte (src->R + ((r * dev + 32768) >> 16));  					dst->G = Utility.ClampToByte (src->G + ((g * dev + 32768) >> 16));  					dst->B = Utility.ClampToByte (src->B + ((b * dev + 32768) >> 16));  					dst->A = src->A;  				}    				++src;  				++dst;  			}
Magic Number,Pinta.ImageManipulation.Effects,AddNoiseEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\AddNoiseEffect.cs,Render,The following statement contains a magic number: for (var x = 0; x < length; ++x) {  				if (threadRand.NextDouble () > coverage) {  					*dst = *src;  				} else {  					int r;  					int g;  					int b;  					int i;    					r = localLookup[threadRand.Next (tableSize)];  					g = localLookup[threadRand.Next (tableSize)];  					b = localLookup[threadRand.Next (tableSize)];    					i = (4899 * r + 9618 * g + 1867 * b) >> 14;      					r = i + (((r - i) * sat) >> 12);  					g = i + (((g - i) * sat) >> 12);  					b = i + (((b - i) * sat) >> 12);    					dst->R = Utility.ClampToByte (src->R + ((r * dev + 32768) >> 16));  					dst->G = Utility.ClampToByte (src->G + ((g * dev + 32768) >> 16));  					dst->B = Utility.ClampToByte (src->B + ((b * dev + 32768) >> 16));  					dst->A = src->A;  				}    				++src;  				++dst;  			}
Magic Number,Pinta.ImageManipulation.Effects,AddNoiseEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\AddNoiseEffect.cs,Render,The following statement contains a magic number: for (var x = 0; x < length; ++x) {  				if (threadRand.NextDouble () > coverage) {  					*dst = *src;  				} else {  					int r;  					int g;  					int b;  					int i;    					r = localLookup[threadRand.Next (tableSize)];  					g = localLookup[threadRand.Next (tableSize)];  					b = localLookup[threadRand.Next (tableSize)];    					i = (4899 * r + 9618 * g + 1867 * b) >> 14;      					r = i + (((r - i) * sat) >> 12);  					g = i + (((g - i) * sat) >> 12);  					b = i + (((b - i) * sat) >> 12);    					dst->R = Utility.ClampToByte (src->R + ((r * dev + 32768) >> 16));  					dst->G = Utility.ClampToByte (src->G + ((g * dev + 32768) >> 16));  					dst->B = Utility.ClampToByte (src->B + ((b * dev + 32768) >> 16));  					dst->A = src->A;  				}    				++src;  				++dst;  			}
Magic Number,Pinta.ImageManipulation.Effects,AddNoiseEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\AddNoiseEffect.cs,Render,The following statement contains a magic number: for (var x = 0; x < length; ++x) {  				if (threadRand.NextDouble () > coverage) {  					*dst = *src;  				} else {  					int r;  					int g;  					int b;  					int i;    					r = localLookup[threadRand.Next (tableSize)];  					g = localLookup[threadRand.Next (tableSize)];  					b = localLookup[threadRand.Next (tableSize)];    					i = (4899 * r + 9618 * g + 1867 * b) >> 14;      					r = i + (((r - i) * sat) >> 12);  					g = i + (((g - i) * sat) >> 12);  					b = i + (((b - i) * sat) >> 12);    					dst->R = Utility.ClampToByte (src->R + ((r * dev + 32768) >> 16));  					dst->G = Utility.ClampToByte (src->G + ((g * dev + 32768) >> 16));  					dst->B = Utility.ClampToByte (src->B + ((b * dev + 32768) >> 16));  					dst->A = src->A;  				}    				++src;  				++dst;  			}
Magic Number,Pinta.ImageManipulation.Effects,AddNoiseEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\AddNoiseEffect.cs,Render,The following statement contains a magic number: for (var x = 0; x < length; ++x) {  				if (threadRand.NextDouble () > coverage) {  					*dst = *src;  				} else {  					int r;  					int g;  					int b;  					int i;    					r = localLookup[threadRand.Next (tableSize)];  					g = localLookup[threadRand.Next (tableSize)];  					b = localLookup[threadRand.Next (tableSize)];    					i = (4899 * r + 9618 * g + 1867 * b) >> 14;      					r = i + (((r - i) * sat) >> 12);  					g = i + (((g - i) * sat) >> 12);  					b = i + (((b - i) * sat) >> 12);    					dst->R = Utility.ClampToByte (src->R + ((r * dev + 32768) >> 16));  					dst->G = Utility.ClampToByte (src->G + ((g * dev + 32768) >> 16));  					dst->B = Utility.ClampToByte (src->B + ((b * dev + 32768) >> 16));  					dst->A = src->A;  				}    				++src;  				++dst;  			}
Magic Number,Pinta.ImageManipulation.Effects,AddNoiseEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\AddNoiseEffect.cs,Render,The following statement contains a magic number: for (var x = 0; x < length; ++x) {  				if (threadRand.NextDouble () > coverage) {  					*dst = *src;  				} else {  					int r;  					int g;  					int b;  					int i;    					r = localLookup[threadRand.Next (tableSize)];  					g = localLookup[threadRand.Next (tableSize)];  					b = localLookup[threadRand.Next (tableSize)];    					i = (4899 * r + 9618 * g + 1867 * b) >> 14;      					r = i + (((r - i) * sat) >> 12);  					g = i + (((g - i) * sat) >> 12);  					b = i + (((b - i) * sat) >> 12);    					dst->R = Utility.ClampToByte (src->R + ((r * dev + 32768) >> 16));  					dst->G = Utility.ClampToByte (src->G + ((g * dev + 32768) >> 16));  					dst->B = Utility.ClampToByte (src->B + ((b * dev + 32768) >> 16));  					dst->A = src->A;  				}    				++src;  				++dst;  			}
Magic Number,Pinta.ImageManipulation.Effects,AddNoiseEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\AddNoiseEffect.cs,Render,The following statement contains a magic number: for (var x = 0; x < length; ++x) {  				if (threadRand.NextDouble () > coverage) {  					*dst = *src;  				} else {  					int r;  					int g;  					int b;  					int i;    					r = localLookup[threadRand.Next (tableSize)];  					g = localLookup[threadRand.Next (tableSize)];  					b = localLookup[threadRand.Next (tableSize)];    					i = (4899 * r + 9618 * g + 1867 * b) >> 14;      					r = i + (((r - i) * sat) >> 12);  					g = i + (((g - i) * sat) >> 12);  					b = i + (((b - i) * sat) >> 12);    					dst->R = Utility.ClampToByte (src->R + ((r * dev + 32768) >> 16));  					dst->G = Utility.ClampToByte (src->G + ((g * dev + 32768) >> 16));  					dst->B = Utility.ClampToByte (src->B + ((b * dev + 32768) >> 16));  					dst->A = src->A;  				}    				++src;  				++dst;  			}
Magic Number,Pinta.ImageManipulation.Effects,AddNoiseEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\AddNoiseEffect.cs,Render,The following statement contains a magic number: for (var x = 0; x < length; ++x) {  				if (threadRand.NextDouble () > coverage) {  					*dst = *src;  				} else {  					int r;  					int g;  					int b;  					int i;    					r = localLookup[threadRand.Next (tableSize)];  					g = localLookup[threadRand.Next (tableSize)];  					b = localLookup[threadRand.Next (tableSize)];    					i = (4899 * r + 9618 * g + 1867 * b) >> 14;      					r = i + (((r - i) * sat) >> 12);  					g = i + (((g - i) * sat) >> 12);  					b = i + (((b - i) * sat) >> 12);    					dst->R = Utility.ClampToByte (src->R + ((r * dev + 32768) >> 16));  					dst->G = Utility.ClampToByte (src->G + ((g * dev + 32768) >> 16));  					dst->B = Utility.ClampToByte (src->B + ((b * dev + 32768) >> 16));  					dst->A = src->A;  				}    				++src;  				++dst;  			}
Magic Number,Pinta.ImageManipulation.Effects,AddNoiseEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\AddNoiseEffect.cs,Render,The following statement contains a magic number: for (var x = 0; x < length; ++x) {  				if (threadRand.NextDouble () > coverage) {  					*dst = *src;  				} else {  					int r;  					int g;  					int b;  					int i;    					r = localLookup[threadRand.Next (tableSize)];  					g = localLookup[threadRand.Next (tableSize)];  					b = localLookup[threadRand.Next (tableSize)];    					i = (4899 * r + 9618 * g + 1867 * b) >> 14;      					r = i + (((r - i) * sat) >> 12);  					g = i + (((g - i) * sat) >> 12);  					b = i + (((b - i) * sat) >> 12);    					dst->R = Utility.ClampToByte (src->R + ((r * dev + 32768) >> 16));  					dst->G = Utility.ClampToByte (src->G + ((g * dev + 32768) >> 16));  					dst->B = Utility.ClampToByte (src->B + ((b * dev + 32768) >> 16));  					dst->A = src->A;  				}    				++src;  				++dst;  			}
Magic Number,Pinta.ImageManipulation.Effects,AddNoiseEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\AddNoiseEffect.cs,NormalCurve,The following statement contains a magic number: return scale * Math.Exp (-x * x / 2);
Magic Number,Pinta.ImageManipulation.Effects,AddNoiseEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\AddNoiseEffect.cs,InitLookup,The following statement contains a magic number: double l = 5;
Magic Number,Pinta.ImageManipulation.Effects,AddNoiseEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\AddNoiseEffect.cs,InitLookup,The following statement contains a magic number: double r = 10;
Magic Number,Pinta.ImageManipulation.Effects,AddNoiseEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\AddNoiseEffect.cs,InitLookup,The following statement contains a magic number: double scale = 50;
Magic Number,Pinta.ImageManipulation.Effects,AddNoiseEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\AddNoiseEffect.cs,InitLookup,The following statement contains a magic number: while (r - l > 0.0000001) {  				sum = 0;  				scale = (l + r) * 0.5;    				for (var i = 0; i < tableSize; ++i) {  					sum += NormalCurve (16.0 * ((double)i - tableSize / 2) / tableSize' scale);    					if (sum > 1000000) {  						break;  					}  				}    				if (sum > tableSize) {  					r = scale;  				} else if (sum < tableSize) {  					l = scale;  				} else {  					break;  				}  			}
Magic Number,Pinta.ImageManipulation.Effects,AddNoiseEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\AddNoiseEffect.cs,InitLookup,The following statement contains a magic number: while (r - l > 0.0000001) {  				sum = 0;  				scale = (l + r) * 0.5;    				for (var i = 0; i < tableSize; ++i) {  					sum += NormalCurve (16.0 * ((double)i - tableSize / 2) / tableSize' scale);    					if (sum > 1000000) {  						break;  					}  				}    				if (sum > tableSize) {  					r = scale;  				} else if (sum < tableSize) {  					l = scale;  				} else {  					break;  				}  			}
Magic Number,Pinta.ImageManipulation.Effects,AddNoiseEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\AddNoiseEffect.cs,InitLookup,The following statement contains a magic number: while (r - l > 0.0000001) {  				sum = 0;  				scale = (l + r) * 0.5;    				for (var i = 0; i < tableSize; ++i) {  					sum += NormalCurve (16.0 * ((double)i - tableSize / 2) / tableSize' scale);    					if (sum > 1000000) {  						break;  					}  				}    				if (sum > tableSize) {  					r = scale;  				} else if (sum < tableSize) {  					l = scale;  				} else {  					break;  				}  			}
Magic Number,Pinta.ImageManipulation.Effects,AddNoiseEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\AddNoiseEffect.cs,InitLookup,The following statement contains a magic number: while (r - l > 0.0000001) {  				sum = 0;  				scale = (l + r) * 0.5;    				for (var i = 0; i < tableSize; ++i) {  					sum += NormalCurve (16.0 * ((double)i - tableSize / 2) / tableSize' scale);    					if (sum > 1000000) {  						break;  					}  				}    				if (sum > tableSize) {  					r = scale;  				} else if (sum < tableSize) {  					l = scale;  				} else {  					break;  				}  			}
Magic Number,Pinta.ImageManipulation.Effects,AddNoiseEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\AddNoiseEffect.cs,InitLookup,The following statement contains a magic number: while (r - l > 0.0000001) {  				sum = 0;  				scale = (l + r) * 0.5;    				for (var i = 0; i < tableSize; ++i) {  					sum += NormalCurve (16.0 * ((double)i - tableSize / 2) / tableSize' scale);    					if (sum > 1000000) {  						break;  					}  				}    				if (sum > tableSize) {  					r = scale;  				} else if (sum < tableSize) {  					l = scale;  				} else {  					break;  				}  			}
Magic Number,Pinta.ImageManipulation.Effects,AddNoiseEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\AddNoiseEffect.cs,InitLookup,The following statement contains a magic number: for (var i = 0; i < tableSize; ++i) {  				sum += NormalCurve (16.0 * ((double)i - tableSize / 2) / tableSize' scale);  				lastRoundedSum = roundedSum;  				roundedSum = (int)sum;    				for (var j = lastRoundedSum; j < roundedSum; ++j) {  					lookup[j] = (i - tableSize / 2) * 65536 / tableSize;  				}  			}
Magic Number,Pinta.ImageManipulation.Effects,AddNoiseEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\AddNoiseEffect.cs,InitLookup,The following statement contains a magic number: for (var i = 0; i < tableSize; ++i) {  				sum += NormalCurve (16.0 * ((double)i - tableSize / 2) / tableSize' scale);  				lastRoundedSum = roundedSum;  				roundedSum = (int)sum;    				for (var j = lastRoundedSum; j < roundedSum; ++j) {  					lookup[j] = (i - tableSize / 2) * 65536 / tableSize;  				}  			}
Magic Number,Pinta.ImageManipulation.Effects,AddNoiseEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\AddNoiseEffect.cs,InitLookup,The following statement contains a magic number: for (var i = 0; i < tableSize; ++i) {  				sum += NormalCurve (16.0 * ((double)i - tableSize / 2) / tableSize' scale);  				lastRoundedSum = roundedSum;  				roundedSum = (int)sum;    				for (var j = lastRoundedSum; j < roundedSum; ++j) {  					lookup[j] = (i - tableSize / 2) * 65536 / tableSize;  				}  			}
Magic Number,Pinta.ImageManipulation.Effects,AddNoiseEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\AddNoiseEffect.cs,InitLookup,The following statement contains a magic number: for (var i = 0; i < tableSize; ++i) {  				sum += NormalCurve (16.0 * ((double)i - tableSize / 2) / tableSize' scale);  				lastRoundedSum = roundedSum;  				roundedSum = (int)sum;    				for (var j = lastRoundedSum; j < roundedSum; ++j) {  					lookup[j] = (i - tableSize / 2) * 65536 / tableSize;  				}  			}
Magic Number,Pinta.ImageManipulation.Effects,BulgeEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\BulgeEffect.cs,BulgeEffect,The following statement contains a magic number: if (amount < -200 || amount > 100)  				throw new ArgumentOutOfRangeException ("amount");
Magic Number,Pinta.ImageManipulation.Effects,BulgeEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\BulgeEffect.cs,BulgeEffect,The following statement contains a magic number: if (amount < -200 || amount > 100)  				throw new ArgumentOutOfRangeException ("amount");
Magic Number,Pinta.ImageManipulation.Effects,CloudsEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\CloudsEffect.cs,CloudsEffect,The following statement contains a magic number: if (scale < 2 || scale > 1000)  				throw new ArgumentOutOfRangeException ("scale");
Magic Number,Pinta.ImageManipulation.Effects,CloudsEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\CloudsEffect.cs,CloudsEffect,The following statement contains a magic number: if (scale < 2 || scale > 1000)  				throw new ArgumentOutOfRangeException ("scale");
Magic Number,Pinta.ImageManipulation.Effects,CloudsEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\CloudsEffect.cs,CloudsEffect,The following statement contains a magic number: if (power < 0 || power > 100)  				throw new ArgumentOutOfRangeException ("radius");
Magic Number,Pinta.ImageManipulation.Effects,CloudsEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\CloudsEffect.cs,CloudsEffect,The following statement contains a magic number: for (int i = 0; i < 256; i++) {  				permuteLookup[256 + i] = permutationTable[i];  				permuteLookup[i] = permutationTable[i];  			}
Magic Number,Pinta.ImageManipulation.Effects,CloudsEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\CloudsEffect.cs,CloudsEffect,The following statement contains a magic number: for (int i = 0; i < 256; i++) {  				permuteLookup[256 + i] = permutationTable[i];  				permuteLookup[i] = permutationTable[i];  			}
Magic Number,Pinta.ImageManipulation.Effects,CloudsEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\CloudsEffect.cs,RenderLine,The following statement contains a magic number: RenderClouds (dst' roi' scale' (byte)(seed)' power / 100.0' from_color' to_color);
Magic Number,Pinta.ImageManipulation.Effects,CloudsEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\CloudsEffect.cs,Fade,The following statement contains a magic number: return t * t * t * (t * (t * 6 - 15) + 10);
Magic Number,Pinta.ImageManipulation.Effects,CloudsEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\CloudsEffect.cs,Fade,The following statement contains a magic number: return t * t * t * (t * (t * 6 - 15) + 10);
Magic Number,Pinta.ImageManipulation.Effects,CloudsEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\CloudsEffect.cs,Fade,The following statement contains a magic number: return t * t * t * (t * (t * 6 - 15) + 10);
Magic Number,Pinta.ImageManipulation.Effects,CloudsEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\CloudsEffect.cs,Grad,The following statement contains a magic number: int h = hash & 15;
Magic Number,Pinta.ImageManipulation.Effects,CloudsEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\CloudsEffect.cs,Grad,The following statement contains a magic number: double u = h < 8 ? x : y;
Magic Number,Pinta.ImageManipulation.Effects,CloudsEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\CloudsEffect.cs,Grad,The following statement contains a magic number: double v = h < 4 ? y : h == 12 || h == 14 ? x : 0;
Magic Number,Pinta.ImageManipulation.Effects,CloudsEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\CloudsEffect.cs,Grad,The following statement contains a magic number: double v = h < 4 ? y : h == 12 || h == 14 ? x : 0;
Magic Number,Pinta.ImageManipulation.Effects,CloudsEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\CloudsEffect.cs,Grad,The following statement contains a magic number: double v = h < 4 ? y : h == 12 || h == 14 ? x : 0;
Magic Number,Pinta.ImageManipulation.Effects,CloudsEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\CloudsEffect.cs,Grad,The following statement contains a magic number: return ((h & 1) == 0 ? u : -u) + ((h & 2) == 0 ? v : -v);
Magic Number,Pinta.ImageManipulation.Effects,CloudsEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\CloudsEffect.cs,RenderClouds,The following statement contains a magic number: for (int y = rect.Top; y <= rect.Bottom; ++y) {  				ColorBgra* ptr = surface.GetPointAddress (rect.Left' y);  				int dy = 2 * y - h;    				for (int x = rect.Left; x <= rect.Right; ++x) {  					int dx = 2 * x - w;  					double val = 0;  					double mult = 1;  					int div = scale;    					for (int i = 0; i < 12 && mult > 0.03 && div > 0; ++i) {  						double dxr = 65536 + (double)dx / (double)div;  						double dyr = 65536 + (double)dy / (double)div;    						int dxd = (int)dxr;  						int dyd = (int)dyr;    						dxr -= dxd;  						dyr -= dyd;    						double noise = Noise (  						    unchecked ((byte)dxd)'  						    unchecked ((byte)dyd)'  						    dxr' //(double)dxr / div'  						    dyr' //(double)dyr / div'  						    (byte)(seed ^ i));    						val += noise * mult;  						div /= 2;  						mult *= power;  					}    					*ptr = ColorBgra.Lerp (colorFrom' colorTo' (val + 1) / 2);  					++ptr;  				}  			}
Magic Number,Pinta.ImageManipulation.Effects,CloudsEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\CloudsEffect.cs,RenderClouds,The following statement contains a magic number: for (int y = rect.Top; y <= rect.Bottom; ++y) {  				ColorBgra* ptr = surface.GetPointAddress (rect.Left' y);  				int dy = 2 * y - h;    				for (int x = rect.Left; x <= rect.Right; ++x) {  					int dx = 2 * x - w;  					double val = 0;  					double mult = 1;  					int div = scale;    					for (int i = 0; i < 12 && mult > 0.03 && div > 0; ++i) {  						double dxr = 65536 + (double)dx / (double)div;  						double dyr = 65536 + (double)dy / (double)div;    						int dxd = (int)dxr;  						int dyd = (int)dyr;    						dxr -= dxd;  						dyr -= dyd;    						double noise = Noise (  						    unchecked ((byte)dxd)'  						    unchecked ((byte)dyd)'  						    dxr' //(double)dxr / div'  						    dyr' //(double)dyr / div'  						    (byte)(seed ^ i));    						val += noise * mult;  						div /= 2;  						mult *= power;  					}    					*ptr = ColorBgra.Lerp (colorFrom' colorTo' (val + 1) / 2);  					++ptr;  				}  			}
Magic Number,Pinta.ImageManipulation.Effects,CloudsEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\CloudsEffect.cs,RenderClouds,The following statement contains a magic number: for (int y = rect.Top; y <= rect.Bottom; ++y) {  				ColorBgra* ptr = surface.GetPointAddress (rect.Left' y);  				int dy = 2 * y - h;    				for (int x = rect.Left; x <= rect.Right; ++x) {  					int dx = 2 * x - w;  					double val = 0;  					double mult = 1;  					int div = scale;    					for (int i = 0; i < 12 && mult > 0.03 && div > 0; ++i) {  						double dxr = 65536 + (double)dx / (double)div;  						double dyr = 65536 + (double)dy / (double)div;    						int dxd = (int)dxr;  						int dyd = (int)dyr;    						dxr -= dxd;  						dyr -= dyd;    						double noise = Noise (  						    unchecked ((byte)dxd)'  						    unchecked ((byte)dyd)'  						    dxr' //(double)dxr / div'  						    dyr' //(double)dyr / div'  						    (byte)(seed ^ i));    						val += noise * mult;  						div /= 2;  						mult *= power;  					}    					*ptr = ColorBgra.Lerp (colorFrom' colorTo' (val + 1) / 2);  					++ptr;  				}  			}
Magic Number,Pinta.ImageManipulation.Effects,CloudsEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\CloudsEffect.cs,RenderClouds,The following statement contains a magic number: for (int y = rect.Top; y <= rect.Bottom; ++y) {  				ColorBgra* ptr = surface.GetPointAddress (rect.Left' y);  				int dy = 2 * y - h;    				for (int x = rect.Left; x <= rect.Right; ++x) {  					int dx = 2 * x - w;  					double val = 0;  					double mult = 1;  					int div = scale;    					for (int i = 0; i < 12 && mult > 0.03 && div > 0; ++i) {  						double dxr = 65536 + (double)dx / (double)div;  						double dyr = 65536 + (double)dy / (double)div;    						int dxd = (int)dxr;  						int dyd = (int)dyr;    						dxr -= dxd;  						dyr -= dyd;    						double noise = Noise (  						    unchecked ((byte)dxd)'  						    unchecked ((byte)dyd)'  						    dxr' //(double)dxr / div'  						    dyr' //(double)dyr / div'  						    (byte)(seed ^ i));    						val += noise * mult;  						div /= 2;  						mult *= power;  					}    					*ptr = ColorBgra.Lerp (colorFrom' colorTo' (val + 1) / 2);  					++ptr;  				}  			}
Magic Number,Pinta.ImageManipulation.Effects,CloudsEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\CloudsEffect.cs,RenderClouds,The following statement contains a magic number: for (int y = rect.Top; y <= rect.Bottom; ++y) {  				ColorBgra* ptr = surface.GetPointAddress (rect.Left' y);  				int dy = 2 * y - h;    				for (int x = rect.Left; x <= rect.Right; ++x) {  					int dx = 2 * x - w;  					double val = 0;  					double mult = 1;  					int div = scale;    					for (int i = 0; i < 12 && mult > 0.03 && div > 0; ++i) {  						double dxr = 65536 + (double)dx / (double)div;  						double dyr = 65536 + (double)dy / (double)div;    						int dxd = (int)dxr;  						int dyd = (int)dyr;    						dxr -= dxd;  						dyr -= dyd;    						double noise = Noise (  						    unchecked ((byte)dxd)'  						    unchecked ((byte)dyd)'  						    dxr' //(double)dxr / div'  						    dyr' //(double)dyr / div'  						    (byte)(seed ^ i));    						val += noise * mult;  						div /= 2;  						mult *= power;  					}    					*ptr = ColorBgra.Lerp (colorFrom' colorTo' (val + 1) / 2);  					++ptr;  				}  			}
Magic Number,Pinta.ImageManipulation.Effects,CloudsEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\CloudsEffect.cs,RenderClouds,The following statement contains a magic number: for (int y = rect.Top; y <= rect.Bottom; ++y) {  				ColorBgra* ptr = surface.GetPointAddress (rect.Left' y);  				int dy = 2 * y - h;    				for (int x = rect.Left; x <= rect.Right; ++x) {  					int dx = 2 * x - w;  					double val = 0;  					double mult = 1;  					int div = scale;    					for (int i = 0; i < 12 && mult > 0.03 && div > 0; ++i) {  						double dxr = 65536 + (double)dx / (double)div;  						double dyr = 65536 + (double)dy / (double)div;    						int dxd = (int)dxr;  						int dyd = (int)dyr;    						dxr -= dxd;  						dyr -= dyd;    						double noise = Noise (  						    unchecked ((byte)dxd)'  						    unchecked ((byte)dyd)'  						    dxr' //(double)dxr / div'  						    dyr' //(double)dyr / div'  						    (byte)(seed ^ i));    						val += noise * mult;  						div /= 2;  						mult *= power;  					}    					*ptr = ColorBgra.Lerp (colorFrom' colorTo' (val + 1) / 2);  					++ptr;  				}  			}
Magic Number,Pinta.ImageManipulation.Effects,CloudsEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\CloudsEffect.cs,RenderClouds,The following statement contains a magic number: for (int y = rect.Top; y <= rect.Bottom; ++y) {  				ColorBgra* ptr = surface.GetPointAddress (rect.Left' y);  				int dy = 2 * y - h;    				for (int x = rect.Left; x <= rect.Right; ++x) {  					int dx = 2 * x - w;  					double val = 0;  					double mult = 1;  					int div = scale;    					for (int i = 0; i < 12 && mult > 0.03 && div > 0; ++i) {  						double dxr = 65536 + (double)dx / (double)div;  						double dyr = 65536 + (double)dy / (double)div;    						int dxd = (int)dxr;  						int dyd = (int)dyr;    						dxr -= dxd;  						dyr -= dyd;    						double noise = Noise (  						    unchecked ((byte)dxd)'  						    unchecked ((byte)dyd)'  						    dxr' //(double)dxr / div'  						    dyr' //(double)dyr / div'  						    (byte)(seed ^ i));    						val += noise * mult;  						div /= 2;  						mult *= power;  					}    					*ptr = ColorBgra.Lerp (colorFrom' colorTo' (val + 1) / 2);  					++ptr;  				}  			}
Magic Number,Pinta.ImageManipulation.Effects,CloudsEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\CloudsEffect.cs,RenderClouds,The following statement contains a magic number: for (int y = rect.Top; y <= rect.Bottom; ++y) {  				ColorBgra* ptr = surface.GetPointAddress (rect.Left' y);  				int dy = 2 * y - h;    				for (int x = rect.Left; x <= rect.Right; ++x) {  					int dx = 2 * x - w;  					double val = 0;  					double mult = 1;  					int div = scale;    					for (int i = 0; i < 12 && mult > 0.03 && div > 0; ++i) {  						double dxr = 65536 + (double)dx / (double)div;  						double dyr = 65536 + (double)dy / (double)div;    						int dxd = (int)dxr;  						int dyd = (int)dyr;    						dxr -= dxd;  						dyr -= dyd;    						double noise = Noise (  						    unchecked ((byte)dxd)'  						    unchecked ((byte)dyd)'  						    dxr' //(double)dxr / div'  						    dyr' //(double)dyr / div'  						    (byte)(seed ^ i));    						val += noise * mult;  						div /= 2;  						mult *= power;  					}    					*ptr = ColorBgra.Lerp (colorFrom' colorTo' (val + 1) / 2);  					++ptr;  				}  			}
Magic Number,Pinta.ImageManipulation.Effects,ColorDifferenceEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\ColorDifferenceEffect.cs,RenderColorDifferenceEffect,The following statement contains a magic number: for (int y = rect.Y; y < rect.Y + rect.Height; ++y) {  				int fyStart = 0;  				int fyEnd = 3;    				if (y == src_rect.Y)  					fyStart = 1;  				if (y == src_rect.Y + src_rect.Height - 1)  					fyEnd = 2;    				// loop through each point in the line   				ColorBgra* dstPtr = dest.GetPointAddress (rect.X' y);    				for (int x = rect.X; x < rect.X + rect.Width; ++x) {  					int fxStart = 0;  					int fxEnd = 3;    					if (x == src_rect.X)  						fxStart = 1;    					if (x == src_rect.X + src_rect.Width - 1)  						fxEnd = 2;    					// loop through each weight  					double rSum = 0.0;  					double gSum = 0.0;  					double bSum = 0.0;    					for (int fy = fyStart; fy < fyEnd; ++fy) {  						for (int fx = fxStart; fx < fxEnd; ++fx) {  							double weight = weights[fy][fx];  							ColorBgra c = src.GetPoint (x - 1 + fx' y - 1 + fy);    							rSum += weight * (double)c.R;  							gSum += weight * (double)c.G;  							bSum += weight * (double)c.B;  						}  					}    					int iRsum = (int)rSum;  					int iGsum = (int)gSum;  					int iBsum = (int)bSum;    					if (iRsum > 255)  						iRsum = 255;    					if (iGsum > 255)  						iGsum = 255;    					if (iBsum > 255)  						iBsum = 255;    					if (iRsum < 0)  						iRsum = 0;    					if (iGsum < 0)  						iGsum = 0;    					if (iBsum < 0)  						iBsum = 0;    					*dstPtr = ColorBgra.FromBgra ((byte)iBsum' (byte)iGsum' (byte)iRsum' 255);  					++dstPtr;  				}  			}
Magic Number,Pinta.ImageManipulation.Effects,ColorDifferenceEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\ColorDifferenceEffect.cs,RenderColorDifferenceEffect,The following statement contains a magic number: for (int y = rect.Y; y < rect.Y + rect.Height; ++y) {  				int fyStart = 0;  				int fyEnd = 3;    				if (y == src_rect.Y)  					fyStart = 1;  				if (y == src_rect.Y + src_rect.Height - 1)  					fyEnd = 2;    				// loop through each point in the line   				ColorBgra* dstPtr = dest.GetPointAddress (rect.X' y);    				for (int x = rect.X; x < rect.X + rect.Width; ++x) {  					int fxStart = 0;  					int fxEnd = 3;    					if (x == src_rect.X)  						fxStart = 1;    					if (x == src_rect.X + src_rect.Width - 1)  						fxEnd = 2;    					// loop through each weight  					double rSum = 0.0;  					double gSum = 0.0;  					double bSum = 0.0;    					for (int fy = fyStart; fy < fyEnd; ++fy) {  						for (int fx = fxStart; fx < fxEnd; ++fx) {  							double weight = weights[fy][fx];  							ColorBgra c = src.GetPoint (x - 1 + fx' y - 1 + fy);    							rSum += weight * (double)c.R;  							gSum += weight * (double)c.G;  							bSum += weight * (double)c.B;  						}  					}    					int iRsum = (int)rSum;  					int iGsum = (int)gSum;  					int iBsum = (int)bSum;    					if (iRsum > 255)  						iRsum = 255;    					if (iGsum > 255)  						iGsum = 255;    					if (iBsum > 255)  						iBsum = 255;    					if (iRsum < 0)  						iRsum = 0;    					if (iGsum < 0)  						iGsum = 0;    					if (iBsum < 0)  						iBsum = 0;    					*dstPtr = ColorBgra.FromBgra ((byte)iBsum' (byte)iGsum' (byte)iRsum' 255);  					++dstPtr;  				}  			}
Magic Number,Pinta.ImageManipulation.Effects,ColorDifferenceEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\ColorDifferenceEffect.cs,RenderColorDifferenceEffect,The following statement contains a magic number: for (int y = rect.Y; y < rect.Y + rect.Height; ++y) {  				int fyStart = 0;  				int fyEnd = 3;    				if (y == src_rect.Y)  					fyStart = 1;  				if (y == src_rect.Y + src_rect.Height - 1)  					fyEnd = 2;    				// loop through each point in the line   				ColorBgra* dstPtr = dest.GetPointAddress (rect.X' y);    				for (int x = rect.X; x < rect.X + rect.Width; ++x) {  					int fxStart = 0;  					int fxEnd = 3;    					if (x == src_rect.X)  						fxStart = 1;    					if (x == src_rect.X + src_rect.Width - 1)  						fxEnd = 2;    					// loop through each weight  					double rSum = 0.0;  					double gSum = 0.0;  					double bSum = 0.0;    					for (int fy = fyStart; fy < fyEnd; ++fy) {  						for (int fx = fxStart; fx < fxEnd; ++fx) {  							double weight = weights[fy][fx];  							ColorBgra c = src.GetPoint (x - 1 + fx' y - 1 + fy);    							rSum += weight * (double)c.R;  							gSum += weight * (double)c.G;  							bSum += weight * (double)c.B;  						}  					}    					int iRsum = (int)rSum;  					int iGsum = (int)gSum;  					int iBsum = (int)bSum;    					if (iRsum > 255)  						iRsum = 255;    					if (iGsum > 255)  						iGsum = 255;    					if (iBsum > 255)  						iBsum = 255;    					if (iRsum < 0)  						iRsum = 0;    					if (iGsum < 0)  						iGsum = 0;    					if (iBsum < 0)  						iBsum = 0;    					*dstPtr = ColorBgra.FromBgra ((byte)iBsum' (byte)iGsum' (byte)iRsum' 255);  					++dstPtr;  				}  			}
Magic Number,Pinta.ImageManipulation.Effects,ColorDifferenceEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\ColorDifferenceEffect.cs,RenderColorDifferenceEffect,The following statement contains a magic number: for (int y = rect.Y; y < rect.Y + rect.Height; ++y) {  				int fyStart = 0;  				int fyEnd = 3;    				if (y == src_rect.Y)  					fyStart = 1;  				if (y == src_rect.Y + src_rect.Height - 1)  					fyEnd = 2;    				// loop through each point in the line   				ColorBgra* dstPtr = dest.GetPointAddress (rect.X' y);    				for (int x = rect.X; x < rect.X + rect.Width; ++x) {  					int fxStart = 0;  					int fxEnd = 3;    					if (x == src_rect.X)  						fxStart = 1;    					if (x == src_rect.X + src_rect.Width - 1)  						fxEnd = 2;    					// loop through each weight  					double rSum = 0.0;  					double gSum = 0.0;  					double bSum = 0.0;    					for (int fy = fyStart; fy < fyEnd; ++fy) {  						for (int fx = fxStart; fx < fxEnd; ++fx) {  							double weight = weights[fy][fx];  							ColorBgra c = src.GetPoint (x - 1 + fx' y - 1 + fy);    							rSum += weight * (double)c.R;  							gSum += weight * (double)c.G;  							bSum += weight * (double)c.B;  						}  					}    					int iRsum = (int)rSum;  					int iGsum = (int)gSum;  					int iBsum = (int)bSum;    					if (iRsum > 255)  						iRsum = 255;    					if (iGsum > 255)  						iGsum = 255;    					if (iBsum > 255)  						iBsum = 255;    					if (iRsum < 0)  						iRsum = 0;    					if (iGsum < 0)  						iGsum = 0;    					if (iBsum < 0)  						iBsum = 0;    					*dstPtr = ColorBgra.FromBgra ((byte)iBsum' (byte)iGsum' (byte)iRsum' 255);  					++dstPtr;  				}  			}
Magic Number,Pinta.ImageManipulation.Effects,ColorDifferenceEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\ColorDifferenceEffect.cs,RenderColorDifferenceEffect,The following statement contains a magic number: for (int y = rect.Y; y < rect.Y + rect.Height; ++y) {  				int fyStart = 0;  				int fyEnd = 3;    				if (y == src_rect.Y)  					fyStart = 1;  				if (y == src_rect.Y + src_rect.Height - 1)  					fyEnd = 2;    				// loop through each point in the line   				ColorBgra* dstPtr = dest.GetPointAddress (rect.X' y);    				for (int x = rect.X; x < rect.X + rect.Width; ++x) {  					int fxStart = 0;  					int fxEnd = 3;    					if (x == src_rect.X)  						fxStart = 1;    					if (x == src_rect.X + src_rect.Width - 1)  						fxEnd = 2;    					// loop through each weight  					double rSum = 0.0;  					double gSum = 0.0;  					double bSum = 0.0;    					for (int fy = fyStart; fy < fyEnd; ++fy) {  						for (int fx = fxStart; fx < fxEnd; ++fx) {  							double weight = weights[fy][fx];  							ColorBgra c = src.GetPoint (x - 1 + fx' y - 1 + fy);    							rSum += weight * (double)c.R;  							gSum += weight * (double)c.G;  							bSum += weight * (double)c.B;  						}  					}    					int iRsum = (int)rSum;  					int iGsum = (int)gSum;  					int iBsum = (int)bSum;    					if (iRsum > 255)  						iRsum = 255;    					if (iGsum > 255)  						iGsum = 255;    					if (iBsum > 255)  						iBsum = 255;    					if (iRsum < 0)  						iRsum = 0;    					if (iGsum < 0)  						iGsum = 0;    					if (iBsum < 0)  						iBsum = 0;    					*dstPtr = ColorBgra.FromBgra ((byte)iBsum' (byte)iGsum' (byte)iRsum' 255);  					++dstPtr;  				}  			}
Magic Number,Pinta.ImageManipulation.Effects,ColorDifferenceEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\ColorDifferenceEffect.cs,RenderColorDifferenceEffect,The following statement contains a magic number: for (int y = rect.Y; y < rect.Y + rect.Height; ++y) {  				int fyStart = 0;  				int fyEnd = 3;    				if (y == src_rect.Y)  					fyStart = 1;  				if (y == src_rect.Y + src_rect.Height - 1)  					fyEnd = 2;    				// loop through each point in the line   				ColorBgra* dstPtr = dest.GetPointAddress (rect.X' y);    				for (int x = rect.X; x < rect.X + rect.Width; ++x) {  					int fxStart = 0;  					int fxEnd = 3;    					if (x == src_rect.X)  						fxStart = 1;    					if (x == src_rect.X + src_rect.Width - 1)  						fxEnd = 2;    					// loop through each weight  					double rSum = 0.0;  					double gSum = 0.0;  					double bSum = 0.0;    					for (int fy = fyStart; fy < fyEnd; ++fy) {  						for (int fx = fxStart; fx < fxEnd; ++fx) {  							double weight = weights[fy][fx];  							ColorBgra c = src.GetPoint (x - 1 + fx' y - 1 + fy);    							rSum += weight * (double)c.R;  							gSum += weight * (double)c.G;  							bSum += weight * (double)c.B;  						}  					}    					int iRsum = (int)rSum;  					int iGsum = (int)gSum;  					int iBsum = (int)bSum;    					if (iRsum > 255)  						iRsum = 255;    					if (iGsum > 255)  						iGsum = 255;    					if (iBsum > 255)  						iBsum = 255;    					if (iRsum < 0)  						iRsum = 0;    					if (iGsum < 0)  						iGsum = 0;    					if (iBsum < 0)  						iBsum = 0;    					*dstPtr = ColorBgra.FromBgra ((byte)iBsum' (byte)iGsum' (byte)iRsum' 255);  					++dstPtr;  				}  			}
Magic Number,Pinta.ImageManipulation.Effects,ColorDifferenceEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\ColorDifferenceEffect.cs,RenderColorDifferenceEffect,The following statement contains a magic number: for (int y = rect.Y; y < rect.Y + rect.Height; ++y) {  				int fyStart = 0;  				int fyEnd = 3;    				if (y == src_rect.Y)  					fyStart = 1;  				if (y == src_rect.Y + src_rect.Height - 1)  					fyEnd = 2;    				// loop through each point in the line   				ColorBgra* dstPtr = dest.GetPointAddress (rect.X' y);    				for (int x = rect.X; x < rect.X + rect.Width; ++x) {  					int fxStart = 0;  					int fxEnd = 3;    					if (x == src_rect.X)  						fxStart = 1;    					if (x == src_rect.X + src_rect.Width - 1)  						fxEnd = 2;    					// loop through each weight  					double rSum = 0.0;  					double gSum = 0.0;  					double bSum = 0.0;    					for (int fy = fyStart; fy < fyEnd; ++fy) {  						for (int fx = fxStart; fx < fxEnd; ++fx) {  							double weight = weights[fy][fx];  							ColorBgra c = src.GetPoint (x - 1 + fx' y - 1 + fy);    							rSum += weight * (double)c.R;  							gSum += weight * (double)c.G;  							bSum += weight * (double)c.B;  						}  					}    					int iRsum = (int)rSum;  					int iGsum = (int)gSum;  					int iBsum = (int)bSum;    					if (iRsum > 255)  						iRsum = 255;    					if (iGsum > 255)  						iGsum = 255;    					if (iBsum > 255)  						iBsum = 255;    					if (iRsum < 0)  						iRsum = 0;    					if (iGsum < 0)  						iGsum = 0;    					if (iBsum < 0)  						iBsum = 0;    					*dstPtr = ColorBgra.FromBgra ((byte)iBsum' (byte)iGsum' (byte)iRsum' 255);  					++dstPtr;  				}  			}
Magic Number,Pinta.ImageManipulation.Effects,ColorDifferenceEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\ColorDifferenceEffect.cs,RenderColorDifferenceEffect,The following statement contains a magic number: for (int y = rect.Y; y < rect.Y + rect.Height; ++y) {  				int fyStart = 0;  				int fyEnd = 3;    				if (y == src_rect.Y)  					fyStart = 1;  				if (y == src_rect.Y + src_rect.Height - 1)  					fyEnd = 2;    				// loop through each point in the line   				ColorBgra* dstPtr = dest.GetPointAddress (rect.X' y);    				for (int x = rect.X; x < rect.X + rect.Width; ++x) {  					int fxStart = 0;  					int fxEnd = 3;    					if (x == src_rect.X)  						fxStart = 1;    					if (x == src_rect.X + src_rect.Width - 1)  						fxEnd = 2;    					// loop through each weight  					double rSum = 0.0;  					double gSum = 0.0;  					double bSum = 0.0;    					for (int fy = fyStart; fy < fyEnd; ++fy) {  						for (int fx = fxStart; fx < fxEnd; ++fx) {  							double weight = weights[fy][fx];  							ColorBgra c = src.GetPoint (x - 1 + fx' y - 1 + fy);    							rSum += weight * (double)c.R;  							gSum += weight * (double)c.G;  							bSum += weight * (double)c.B;  						}  					}    					int iRsum = (int)rSum;  					int iGsum = (int)gSum;  					int iBsum = (int)bSum;    					if (iRsum > 255)  						iRsum = 255;    					if (iGsum > 255)  						iGsum = 255;    					if (iBsum > 255)  						iBsum = 255;    					if (iRsum < 0)  						iRsum = 0;    					if (iGsum < 0)  						iGsum = 0;    					if (iBsum < 0)  						iBsum = 0;    					*dstPtr = ColorBgra.FromBgra ((byte)iBsum' (byte)iGsum' (byte)iRsum' 255);  					++dstPtr;  				}  			}
Magic Number,Pinta.ImageManipulation.Effects,ColorDifferenceEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\ColorDifferenceEffect.cs,RenderColorDifferenceEffect,The following statement contains a magic number: for (int y = rect.Y; y < rect.Y + rect.Height; ++y) {  				int fyStart = 0;  				int fyEnd = 3;    				if (y == src_rect.Y)  					fyStart = 1;  				if (y == src_rect.Y + src_rect.Height - 1)  					fyEnd = 2;    				// loop through each point in the line   				ColorBgra* dstPtr = dest.GetPointAddress (rect.X' y);    				for (int x = rect.X; x < rect.X + rect.Width; ++x) {  					int fxStart = 0;  					int fxEnd = 3;    					if (x == src_rect.X)  						fxStart = 1;    					if (x == src_rect.X + src_rect.Width - 1)  						fxEnd = 2;    					// loop through each weight  					double rSum = 0.0;  					double gSum = 0.0;  					double bSum = 0.0;    					for (int fy = fyStart; fy < fyEnd; ++fy) {  						for (int fx = fxStart; fx < fxEnd; ++fx) {  							double weight = weights[fy][fx];  							ColorBgra c = src.GetPoint (x - 1 + fx' y - 1 + fy);    							rSum += weight * (double)c.R;  							gSum += weight * (double)c.G;  							bSum += weight * (double)c.B;  						}  					}    					int iRsum = (int)rSum;  					int iGsum = (int)gSum;  					int iBsum = (int)bSum;    					if (iRsum > 255)  						iRsum = 255;    					if (iGsum > 255)  						iGsum = 255;    					if (iBsum > 255)  						iBsum = 255;    					if (iRsum < 0)  						iRsum = 0;    					if (iGsum < 0)  						iGsum = 0;    					if (iBsum < 0)  						iBsum = 0;    					*dstPtr = ColorBgra.FromBgra ((byte)iBsum' (byte)iGsum' (byte)iRsum' 255);  					++dstPtr;  				}  			}
Magic Number,Pinta.ImageManipulation.Effects,ColorDifferenceEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\ColorDifferenceEffect.cs,RenderColorDifferenceEffect,The following statement contains a magic number: for (int y = rect.Y; y < rect.Y + rect.Height; ++y) {  				int fyStart = 0;  				int fyEnd = 3;    				if (y == src_rect.Y)  					fyStart = 1;  				if (y == src_rect.Y + src_rect.Height - 1)  					fyEnd = 2;    				// loop through each point in the line   				ColorBgra* dstPtr = dest.GetPointAddress (rect.X' y);    				for (int x = rect.X; x < rect.X + rect.Width; ++x) {  					int fxStart = 0;  					int fxEnd = 3;    					if (x == src_rect.X)  						fxStart = 1;    					if (x == src_rect.X + src_rect.Width - 1)  						fxEnd = 2;    					// loop through each weight  					double rSum = 0.0;  					double gSum = 0.0;  					double bSum = 0.0;    					for (int fy = fyStart; fy < fyEnd; ++fy) {  						for (int fx = fxStart; fx < fxEnd; ++fx) {  							double weight = weights[fy][fx];  							ColorBgra c = src.GetPoint (x - 1 + fx' y - 1 + fy);    							rSum += weight * (double)c.R;  							gSum += weight * (double)c.G;  							bSum += weight * (double)c.B;  						}  					}    					int iRsum = (int)rSum;  					int iGsum = (int)gSum;  					int iBsum = (int)bSum;    					if (iRsum > 255)  						iRsum = 255;    					if (iGsum > 255)  						iGsum = 255;    					if (iBsum > 255)  						iBsum = 255;    					if (iRsum < 0)  						iRsum = 0;    					if (iGsum < 0)  						iGsum = 0;    					if (iBsum < 0)  						iBsum = 0;    					*dstPtr = ColorBgra.FromBgra ((byte)iBsum' (byte)iGsum' (byte)iRsum' 255);  					++dstPtr;  				}  			}
Magic Number,Pinta.ImageManipulation.Effects,ColorDifferenceEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\ColorDifferenceEffect.cs,RenderColorDifferenceEffect,The following statement contains a magic number: for (int y = rect.Y; y < rect.Y + rect.Height; ++y) {  				int fyStart = 0;  				int fyEnd = 3;    				if (y == src_rect.Y)  					fyStart = 1;  				if (y == src_rect.Y + src_rect.Height - 1)  					fyEnd = 2;    				// loop through each point in the line   				ColorBgra* dstPtr = dest.GetPointAddress (rect.X' y);    				for (int x = rect.X; x < rect.X + rect.Width; ++x) {  					int fxStart = 0;  					int fxEnd = 3;    					if (x == src_rect.X)  						fxStart = 1;    					if (x == src_rect.X + src_rect.Width - 1)  						fxEnd = 2;    					// loop through each weight  					double rSum = 0.0;  					double gSum = 0.0;  					double bSum = 0.0;    					for (int fy = fyStart; fy < fyEnd; ++fy) {  						for (int fx = fxStart; fx < fxEnd; ++fx) {  							double weight = weights[fy][fx];  							ColorBgra c = src.GetPoint (x - 1 + fx' y - 1 + fy);    							rSum += weight * (double)c.R;  							gSum += weight * (double)c.G;  							bSum += weight * (double)c.B;  						}  					}    					int iRsum = (int)rSum;  					int iGsum = (int)gSum;  					int iBsum = (int)bSum;    					if (iRsum > 255)  						iRsum = 255;    					if (iGsum > 255)  						iGsum = 255;    					if (iBsum > 255)  						iBsum = 255;    					if (iRsum < 0)  						iRsum = 0;    					if (iGsum < 0)  						iGsum = 0;    					if (iBsum < 0)  						iBsum = 0;    					*dstPtr = ColorBgra.FromBgra ((byte)iBsum' (byte)iGsum' (byte)iRsum' 255);  					++dstPtr;  				}  			}
Magic Number,Pinta.ImageManipulation.Effects,BrightnessContrastEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\BrightnessContrastEffect.cs,BrightnessContrastEffect,The following statement contains a magic number: if (brightness < -100 || brightness > 100)  				throw new ArgumentOutOfRangeException ("brightness");
Magic Number,Pinta.ImageManipulation.Effects,BrightnessContrastEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\BrightnessContrastEffect.cs,BrightnessContrastEffect,The following statement contains a magic number: if (brightness < -100 || brightness > 100)  				throw new ArgumentOutOfRangeException ("brightness");
Magic Number,Pinta.ImageManipulation.Effects,BrightnessContrastEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\BrightnessContrastEffect.cs,BrightnessContrastEffect,The following statement contains a magic number: if (contrast < -100 || contrast > 100)  				throw new ArgumentOutOfRangeException ("contrast");
Magic Number,Pinta.ImageManipulation.Effects,BrightnessContrastEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\BrightnessContrastEffect.cs,BrightnessContrastEffect,The following statement contains a magic number: if (contrast < -100 || contrast > 100)  				throw new ArgumentOutOfRangeException ("contrast");
Magic Number,Pinta.ImageManipulation.Effects,BrightnessContrastEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\BrightnessContrastEffect.cs,Render,The following statement contains a magic number: if (divide == 0) {  				while (dstRowPtr < dstRowEndPtr) {  					var col = *srcRowPtr;  					var i = col.GetIntensityByte ();  					uint c = rgbTable[i];  					dstRowPtr->Bgra = (col.Bgra & 0xff000000) | c | (c << 8) | (c << 16);    					++dstRowPtr;  					++srcRowPtr;  				}  			} else {  				while (dstRowPtr < dstRowEndPtr) {  					var col = *srcRowPtr;  					var i = col.GetIntensityByte ();  					var shiftIndex = i * 256;    					col.R = rgbTable[shiftIndex + col.R];  					col.G = rgbTable[shiftIndex + col.G];  					col.B = rgbTable[shiftIndex + col.B];    					*dstRowPtr = col;  					++dstRowPtr;  					++srcRowPtr;  				}  			}
Magic Number,Pinta.ImageManipulation.Effects,BrightnessContrastEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\BrightnessContrastEffect.cs,Render,The following statement contains a magic number: if (divide == 0) {  				while (dstRowPtr < dstRowEndPtr) {  					var col = *srcRowPtr;  					var i = col.GetIntensityByte ();  					uint c = rgbTable[i];  					dstRowPtr->Bgra = (col.Bgra & 0xff000000) | c | (c << 8) | (c << 16);    					++dstRowPtr;  					++srcRowPtr;  				}  			} else {  				while (dstRowPtr < dstRowEndPtr) {  					var col = *srcRowPtr;  					var i = col.GetIntensityByte ();  					var shiftIndex = i * 256;    					col.R = rgbTable[shiftIndex + col.R];  					col.G = rgbTable[shiftIndex + col.G];  					col.B = rgbTable[shiftIndex + col.B];    					*dstRowPtr = col;  					++dstRowPtr;  					++srcRowPtr;  				}  			}
Magic Number,Pinta.ImageManipulation.Effects,BrightnessContrastEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\BrightnessContrastEffect.cs,Render,The following statement contains a magic number: if (divide == 0) {  				while (dstRowPtr < dstRowEndPtr) {  					var col = *srcRowPtr;  					var i = col.GetIntensityByte ();  					uint c = rgbTable[i];  					dstRowPtr->Bgra = (col.Bgra & 0xff000000) | c | (c << 8) | (c << 16);    					++dstRowPtr;  					++srcRowPtr;  				}  			} else {  				while (dstRowPtr < dstRowEndPtr) {  					var col = *srcRowPtr;  					var i = col.GetIntensityByte ();  					var shiftIndex = i * 256;    					col.R = rgbTable[shiftIndex + col.R];  					col.G = rgbTable[shiftIndex + col.G];  					col.B = rgbTable[shiftIndex + col.B];    					*dstRowPtr = col;  					++dstRowPtr;  					++srcRowPtr;  				}  			}
Magic Number,Pinta.ImageManipulation.Effects,BrightnessContrastEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\BrightnessContrastEffect.cs,Calculate,The following statement contains a magic number: if (contrast < 0) {  				multiply = contrast + 100;  				divide = 100;  			} else if (contrast > 0) {  				multiply = 100;  				divide = 100 - contrast;  			} else {  				multiply = 1;  				divide = 1;  			}
Magic Number,Pinta.ImageManipulation.Effects,BrightnessContrastEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\BrightnessContrastEffect.cs,Calculate,The following statement contains a magic number: if (contrast < 0) {  				multiply = contrast + 100;  				divide = 100;  			} else if (contrast > 0) {  				multiply = 100;  				divide = 100 - contrast;  			} else {  				multiply = 1;  				divide = 1;  			}
Magic Number,Pinta.ImageManipulation.Effects,BrightnessContrastEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\BrightnessContrastEffect.cs,Calculate,The following statement contains a magic number: if (contrast < 0) {  				multiply = contrast + 100;  				divide = 100;  			} else if (contrast > 0) {  				multiply = 100;  				divide = 100 - contrast;  			} else {  				multiply = 1;  				divide = 1;  			}
Magic Number,Pinta.ImageManipulation.Effects,BrightnessContrastEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\BrightnessContrastEffect.cs,Calculate,The following statement contains a magic number: if (contrast < 0) {  				multiply = contrast + 100;  				divide = 100;  			} else if (contrast > 0) {  				multiply = 100;  				divide = 100 - contrast;  			} else {  				multiply = 1;  				divide = 1;  			}
Magic Number,Pinta.ImageManipulation.Effects,BrightnessContrastEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\BrightnessContrastEffect.cs,Calculate,The following statement contains a magic number: if (rgbTable == null)  				rgbTable = new byte[65536];
Magic Number,Pinta.ImageManipulation.Effects,BrightnessContrastEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\BrightnessContrastEffect.cs,Calculate,The following statement contains a magic number: if (divide == 0) {  				for (var intensity = 0; intensity < 256; intensity++) {  					if (intensity + brightness < 128)  						rgbTable[intensity] = 0;  					else  						rgbTable[intensity] = 255;  				}  			} else if (divide == 100) {  				for (var intensity = 0; intensity < 256; intensity++) {  					var shift = (intensity - 127) * multiply / divide + 127 - intensity + brightness;    					for (var col = 0; col < 256; ++col) {  						var index = (intensity * 256) + col;  						rgbTable[index] = Utility.ClampToByte (col + shift);  					}  				}  			} else {  				for (var intensity = 0; intensity < 256; ++intensity) {  					var shift = (intensity - 127 + brightness) * multiply / divide + 127 - intensity;    					for (var col = 0; col < 256; ++col) {  						var index = (intensity * 256) + col;  						rgbTable[index] = Utility.ClampToByte (col + shift);  					}  				}  			}
Magic Number,Pinta.ImageManipulation.Effects,BrightnessContrastEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\BrightnessContrastEffect.cs,Calculate,The following statement contains a magic number: if (divide == 0) {  				for (var intensity = 0; intensity < 256; intensity++) {  					if (intensity + brightness < 128)  						rgbTable[intensity] = 0;  					else  						rgbTable[intensity] = 255;  				}  			} else if (divide == 100) {  				for (var intensity = 0; intensity < 256; intensity++) {  					var shift = (intensity - 127) * multiply / divide + 127 - intensity + brightness;    					for (var col = 0; col < 256; ++col) {  						var index = (intensity * 256) + col;  						rgbTable[index] = Utility.ClampToByte (col + shift);  					}  				}  			} else {  				for (var intensity = 0; intensity < 256; ++intensity) {  					var shift = (intensity - 127 + brightness) * multiply / divide + 127 - intensity;    					for (var col = 0; col < 256; ++col) {  						var index = (intensity * 256) + col;  						rgbTable[index] = Utility.ClampToByte (col + shift);  					}  				}  			}
Magic Number,Pinta.ImageManipulation.Effects,BrightnessContrastEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\BrightnessContrastEffect.cs,Calculate,The following statement contains a magic number: if (divide == 0) {  				for (var intensity = 0; intensity < 256; intensity++) {  					if (intensity + brightness < 128)  						rgbTable[intensity] = 0;  					else  						rgbTable[intensity] = 255;  				}  			} else if (divide == 100) {  				for (var intensity = 0; intensity < 256; intensity++) {  					var shift = (intensity - 127) * multiply / divide + 127 - intensity + brightness;    					for (var col = 0; col < 256; ++col) {  						var index = (intensity * 256) + col;  						rgbTable[index] = Utility.ClampToByte (col + shift);  					}  				}  			} else {  				for (var intensity = 0; intensity < 256; ++intensity) {  					var shift = (intensity - 127 + brightness) * multiply / divide + 127 - intensity;    					for (var col = 0; col < 256; ++col) {  						var index = (intensity * 256) + col;  						rgbTable[index] = Utility.ClampToByte (col + shift);  					}  				}  			}
Magic Number,Pinta.ImageManipulation.Effects,BrightnessContrastEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\BrightnessContrastEffect.cs,Calculate,The following statement contains a magic number: if (divide == 0) {  				for (var intensity = 0; intensity < 256; intensity++) {  					if (intensity + brightness < 128)  						rgbTable[intensity] = 0;  					else  						rgbTable[intensity] = 255;  				}  			} else if (divide == 100) {  				for (var intensity = 0; intensity < 256; intensity++) {  					var shift = (intensity - 127) * multiply / divide + 127 - intensity + brightness;    					for (var col = 0; col < 256; ++col) {  						var index = (intensity * 256) + col;  						rgbTable[index] = Utility.ClampToByte (col + shift);  					}  				}  			} else {  				for (var intensity = 0; intensity < 256; ++intensity) {  					var shift = (intensity - 127 + brightness) * multiply / divide + 127 - intensity;    					for (var col = 0; col < 256; ++col) {  						var index = (intensity * 256) + col;  						rgbTable[index] = Utility.ClampToByte (col + shift);  					}  				}  			}
Magic Number,Pinta.ImageManipulation.Effects,BrightnessContrastEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\BrightnessContrastEffect.cs,Calculate,The following statement contains a magic number: if (divide == 0) {  				for (var intensity = 0; intensity < 256; intensity++) {  					if (intensity + brightness < 128)  						rgbTable[intensity] = 0;  					else  						rgbTable[intensity] = 255;  				}  			} else if (divide == 100) {  				for (var intensity = 0; intensity < 256; intensity++) {  					var shift = (intensity - 127) * multiply / divide + 127 - intensity + brightness;    					for (var col = 0; col < 256; ++col) {  						var index = (intensity * 256) + col;  						rgbTable[index] = Utility.ClampToByte (col + shift);  					}  				}  			} else {  				for (var intensity = 0; intensity < 256; ++intensity) {  					var shift = (intensity - 127 + brightness) * multiply / divide + 127 - intensity;    					for (var col = 0; col < 256; ++col) {  						var index = (intensity * 256) + col;  						rgbTable[index] = Utility.ClampToByte (col + shift);  					}  				}  			}
Magic Number,Pinta.ImageManipulation.Effects,BrightnessContrastEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\BrightnessContrastEffect.cs,Calculate,The following statement contains a magic number: if (divide == 0) {  				for (var intensity = 0; intensity < 256; intensity++) {  					if (intensity + brightness < 128)  						rgbTable[intensity] = 0;  					else  						rgbTable[intensity] = 255;  				}  			} else if (divide == 100) {  				for (var intensity = 0; intensity < 256; intensity++) {  					var shift = (intensity - 127) * multiply / divide + 127 - intensity + brightness;    					for (var col = 0; col < 256; ++col) {  						var index = (intensity * 256) + col;  						rgbTable[index] = Utility.ClampToByte (col + shift);  					}  				}  			} else {  				for (var intensity = 0; intensity < 256; ++intensity) {  					var shift = (intensity - 127 + brightness) * multiply / divide + 127 - intensity;    					for (var col = 0; col < 256; ++col) {  						var index = (intensity * 256) + col;  						rgbTable[index] = Utility.ClampToByte (col + shift);  					}  				}  			}
Magic Number,Pinta.ImageManipulation.Effects,BrightnessContrastEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\BrightnessContrastEffect.cs,Calculate,The following statement contains a magic number: if (divide == 0) {  				for (var intensity = 0; intensity < 256; intensity++) {  					if (intensity + brightness < 128)  						rgbTable[intensity] = 0;  					else  						rgbTable[intensity] = 255;  				}  			} else if (divide == 100) {  				for (var intensity = 0; intensity < 256; intensity++) {  					var shift = (intensity - 127) * multiply / divide + 127 - intensity + brightness;    					for (var col = 0; col < 256; ++col) {  						var index = (intensity * 256) + col;  						rgbTable[index] = Utility.ClampToByte (col + shift);  					}  				}  			} else {  				for (var intensity = 0; intensity < 256; ++intensity) {  					var shift = (intensity - 127 + brightness) * multiply / divide + 127 - intensity;    					for (var col = 0; col < 256; ++col) {  						var index = (intensity * 256) + col;  						rgbTable[index] = Utility.ClampToByte (col + shift);  					}  				}  			}
Magic Number,Pinta.ImageManipulation.Effects,BrightnessContrastEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\BrightnessContrastEffect.cs,Calculate,The following statement contains a magic number: if (divide == 0) {  				for (var intensity = 0; intensity < 256; intensity++) {  					if (intensity + brightness < 128)  						rgbTable[intensity] = 0;  					else  						rgbTable[intensity] = 255;  				}  			} else if (divide == 100) {  				for (var intensity = 0; intensity < 256; intensity++) {  					var shift = (intensity - 127) * multiply / divide + 127 - intensity + brightness;    					for (var col = 0; col < 256; ++col) {  						var index = (intensity * 256) + col;  						rgbTable[index] = Utility.ClampToByte (col + shift);  					}  				}  			} else {  				for (var intensity = 0; intensity < 256; ++intensity) {  					var shift = (intensity - 127 + brightness) * multiply / divide + 127 - intensity;    					for (var col = 0; col < 256; ++col) {  						var index = (intensity * 256) + col;  						rgbTable[index] = Utility.ClampToByte (col + shift);  					}  				}  			}
Magic Number,Pinta.ImageManipulation.Effects,BrightnessContrastEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\BrightnessContrastEffect.cs,Calculate,The following statement contains a magic number: if (divide == 0) {  				for (var intensity = 0; intensity < 256; intensity++) {  					if (intensity + brightness < 128)  						rgbTable[intensity] = 0;  					else  						rgbTable[intensity] = 255;  				}  			} else if (divide == 100) {  				for (var intensity = 0; intensity < 256; intensity++) {  					var shift = (intensity - 127) * multiply / divide + 127 - intensity + brightness;    					for (var col = 0; col < 256; ++col) {  						var index = (intensity * 256) + col;  						rgbTable[index] = Utility.ClampToByte (col + shift);  					}  				}  			} else {  				for (var intensity = 0; intensity < 256; ++intensity) {  					var shift = (intensity - 127 + brightness) * multiply / divide + 127 - intensity;    					for (var col = 0; col < 256; ++col) {  						var index = (intensity * 256) + col;  						rgbTable[index] = Utility.ClampToByte (col + shift);  					}  				}  			}
Magic Number,Pinta.ImageManipulation.Effects,BrightnessContrastEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\BrightnessContrastEffect.cs,Calculate,The following statement contains a magic number: if (divide == 0) {  				for (var intensity = 0; intensity < 256; intensity++) {  					if (intensity + brightness < 128)  						rgbTable[intensity] = 0;  					else  						rgbTable[intensity] = 255;  				}  			} else if (divide == 100) {  				for (var intensity = 0; intensity < 256; intensity++) {  					var shift = (intensity - 127) * multiply / divide + 127 - intensity + brightness;    					for (var col = 0; col < 256; ++col) {  						var index = (intensity * 256) + col;  						rgbTable[index] = Utility.ClampToByte (col + shift);  					}  				}  			} else {  				for (var intensity = 0; intensity < 256; ++intensity) {  					var shift = (intensity - 127 + brightness) * multiply / divide + 127 - intensity;    					for (var col = 0; col < 256; ++col) {  						var index = (intensity * 256) + col;  						rgbTable[index] = Utility.ClampToByte (col + shift);  					}  				}  			}
Magic Number,Pinta.ImageManipulation.Effects,BrightnessContrastEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\BrightnessContrastEffect.cs,Calculate,The following statement contains a magic number: if (divide == 0) {  				for (var intensity = 0; intensity < 256; intensity++) {  					if (intensity + brightness < 128)  						rgbTable[intensity] = 0;  					else  						rgbTable[intensity] = 255;  				}  			} else if (divide == 100) {  				for (var intensity = 0; intensity < 256; intensity++) {  					var shift = (intensity - 127) * multiply / divide + 127 - intensity + brightness;    					for (var col = 0; col < 256; ++col) {  						var index = (intensity * 256) + col;  						rgbTable[index] = Utility.ClampToByte (col + shift);  					}  				}  			} else {  				for (var intensity = 0; intensity < 256; ++intensity) {  					var shift = (intensity - 127 + brightness) * multiply / divide + 127 - intensity;    					for (var col = 0; col < 256; ++col) {  						var index = (intensity * 256) + col;  						rgbTable[index] = Utility.ClampToByte (col + shift);  					}  				}  			}
Magic Number,Pinta.ImageManipulation.Effects,BrightnessContrastEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\BrightnessContrastEffect.cs,Calculate,The following statement contains a magic number: if (divide == 0) {  				for (var intensity = 0; intensity < 256; intensity++) {  					if (intensity + brightness < 128)  						rgbTable[intensity] = 0;  					else  						rgbTable[intensity] = 255;  				}  			} else if (divide == 100) {  				for (var intensity = 0; intensity < 256; intensity++) {  					var shift = (intensity - 127) * multiply / divide + 127 - intensity + brightness;    					for (var col = 0; col < 256; ++col) {  						var index = (intensity * 256) + col;  						rgbTable[index] = Utility.ClampToByte (col + shift);  					}  				}  			} else {  				for (var intensity = 0; intensity < 256; ++intensity) {  					var shift = (intensity - 127 + brightness) * multiply / divide + 127 - intensity;    					for (var col = 0; col < 256; ++col) {  						var index = (intensity * 256) + col;  						rgbTable[index] = Utility.ClampToByte (col + shift);  					}  				}  			}
Magic Number,Pinta.ImageManipulation.Effects,BrightnessContrastEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\BrightnessContrastEffect.cs,Calculate,The following statement contains a magic number: if (divide == 0) {  				for (var intensity = 0; intensity < 256; intensity++) {  					if (intensity + brightness < 128)  						rgbTable[intensity] = 0;  					else  						rgbTable[intensity] = 255;  				}  			} else if (divide == 100) {  				for (var intensity = 0; intensity < 256; intensity++) {  					var shift = (intensity - 127) * multiply / divide + 127 - intensity + brightness;    					for (var col = 0; col < 256; ++col) {  						var index = (intensity * 256) + col;  						rgbTable[index] = Utility.ClampToByte (col + shift);  					}  				}  			} else {  				for (var intensity = 0; intensity < 256; ++intensity) {  					var shift = (intensity - 127 + brightness) * multiply / divide + 127 - intensity;    					for (var col = 0; col < 256; ++col) {  						var index = (intensity * 256) + col;  						rgbTable[index] = Utility.ClampToByte (col + shift);  					}  				}  			}
Magic Number,Pinta.ImageManipulation.Effects,BrightnessContrastEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\BrightnessContrastEffect.cs,Calculate,The following statement contains a magic number: if (divide == 0) {  				for (var intensity = 0; intensity < 256; intensity++) {  					if (intensity + brightness < 128)  						rgbTable[intensity] = 0;  					else  						rgbTable[intensity] = 255;  				}  			} else if (divide == 100) {  				for (var intensity = 0; intensity < 256; intensity++) {  					var shift = (intensity - 127) * multiply / divide + 127 - intensity + brightness;    					for (var col = 0; col < 256; ++col) {  						var index = (intensity * 256) + col;  						rgbTable[index] = Utility.ClampToByte (col + shift);  					}  				}  			} else {  				for (var intensity = 0; intensity < 256; ++intensity) {  					var shift = (intensity - 127 + brightness) * multiply / divide + 127 - intensity;    					for (var col = 0; col < 256; ++col) {  						var index = (intensity * 256) + col;  						rgbTable[index] = Utility.ClampToByte (col + shift);  					}  				}  			}
Magic Number,Pinta.ImageManipulation.Effects,HueSaturationEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\HueSaturationEffect.cs,HueSaturationEffect,The following statement contains a magic number: if (hue < -180 || hue > 180)  				throw new ArgumentOutOfRangeException ("hue");
Magic Number,Pinta.ImageManipulation.Effects,HueSaturationEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\HueSaturationEffect.cs,HueSaturationEffect,The following statement contains a magic number: if (hue < -180 || hue > 180)  				throw new ArgumentOutOfRangeException ("hue");
Magic Number,Pinta.ImageManipulation.Effects,HueSaturationEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\HueSaturationEffect.cs,HueSaturationEffect,The following statement contains a magic number: if (saturation < 0 || saturation > 200)  				throw new ArgumentOutOfRangeException ("saturation");
Magic Number,Pinta.ImageManipulation.Effects,HueSaturationEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\HueSaturationEffect.cs,HueSaturationEffect,The following statement contains a magic number: if (lightness < -100 || lightness > 100)  				throw new ArgumentOutOfRangeException ("lightness");
Magic Number,Pinta.ImageManipulation.Effects,HueSaturationEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\HueSaturationEffect.cs,HueSaturationEffect,The following statement contains a magic number: if (lightness < -100 || lightness > 100)  				throw new ArgumentOutOfRangeException ("lightness");
Magic Number,Pinta.ImageManipulation.Effects,HueSaturationEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\HueSaturationEffect.cs,HueSaturationEffect,The following statement contains a magic number: if (hue == 0 && saturation == 100 && lightness == 0)  				op = new IdentityOp ();  			else  				op = new HueSaturationLightnessOp (hue' saturation' lightness);
Magic Number,Pinta.ImageManipulation.Effects,CurvesEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\CurvesEffect.cs,MakeUop,The following statement contains a magic number: switch (mode) {  				case ColorTransferMode.Rgb:  					var cc = new ChannelCurveOp ();  					transferCurves = new byte[][] { cc.CurveR' cc.CurveG' cc.CurveB };  					entries = 256;  					op = cc;  					break;    				case ColorTransferMode.Luminosity:  					var lc = new LuminosityCurveOp ();  					transferCurves = new byte[][] { lc.Curve };  					entries = 256;  					op = lc;  					break;    				default:  					throw new InvalidEnumArgumentException ();  			}
Magic Number,Pinta.ImageManipulation.Effects,CurvesEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\CurvesEffect.cs,MakeUop,The following statement contains a magic number: switch (mode) {  				case ColorTransferMode.Rgb:  					var cc = new ChannelCurveOp ();  					transferCurves = new byte[][] { cc.CurveR' cc.CurveG' cc.CurveB };  					entries = 256;  					op = cc;  					break;    				case ColorTransferMode.Luminosity:  					var lc = new LuminosityCurveOp ();  					transferCurves = new byte[][] { lc.Curve };  					entries = 256;  					op = lc;  					break;    				default:  					throw new InvalidEnumArgumentException ();  			}
Magic Number,Pinta.ImageManipulation.Effects,EdgeDetectEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\EdgeDetectEffect.cs,SetWeights,The following statement contains a magic number: weights = new double[3][];
Magic Number,Pinta.ImageManipulation.Effects,EdgeDetectEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\EdgeDetectEffect.cs,SetWeights,The following statement contains a magic number: for (int i = 0; i < this.weights.Length; ++i) {  				this.weights[i] = new double[3];  			}
Magic Number,Pinta.ImageManipulation.Effects,EdgeDetectEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\EdgeDetectEffect.cs,SetWeights,The following statement contains a magic number: double r = (double)angle * 2.0 * Math.PI / 360.0;
Magic Number,Pinta.ImageManipulation.Effects,EdgeDetectEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\EdgeDetectEffect.cs,SetWeights,The following statement contains a magic number: double r = (double)angle * 2.0 * Math.PI / 360.0;
Magic Number,Pinta.ImageManipulation.Effects,EdgeDetectEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\EdgeDetectEffect.cs,SetWeights,The following statement contains a magic number: double dr = Math.PI / 4.0;
Magic Number,Pinta.ImageManipulation.Effects,EdgeDetectEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\EdgeDetectEffect.cs,SetWeights,The following statement contains a magic number: this.weights[0][1] = Math.Cos (r + 2.0 * dr);
Magic Number,Pinta.ImageManipulation.Effects,EdgeDetectEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\EdgeDetectEffect.cs,SetWeights,The following statement contains a magic number: this.weights[0][2] = Math.Cos (r + 3.0 * dr);
Magic Number,Pinta.ImageManipulation.Effects,EdgeDetectEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\EdgeDetectEffect.cs,SetWeights,The following statement contains a magic number: this.weights[0][2] = Math.Cos (r + 3.0 * dr);
Magic Number,Pinta.ImageManipulation.Effects,EdgeDetectEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\EdgeDetectEffect.cs,SetWeights,The following statement contains a magic number: this.weights[1][2] = Math.Cos (r + 4.0 * dr);
Magic Number,Pinta.ImageManipulation.Effects,EdgeDetectEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\EdgeDetectEffect.cs,SetWeights,The following statement contains a magic number: this.weights[1][2] = Math.Cos (r + 4.0 * dr);
Magic Number,Pinta.ImageManipulation.Effects,EdgeDetectEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\EdgeDetectEffect.cs,SetWeights,The following statement contains a magic number: this.weights[2][0] = Math.Cos (r - dr);
Magic Number,Pinta.ImageManipulation.Effects,EdgeDetectEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\EdgeDetectEffect.cs,SetWeights,The following statement contains a magic number: this.weights[2][1] = Math.Cos (r - 2.0 * dr);
Magic Number,Pinta.ImageManipulation.Effects,EdgeDetectEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\EdgeDetectEffect.cs,SetWeights,The following statement contains a magic number: this.weights[2][1] = Math.Cos (r - 2.0 * dr);
Magic Number,Pinta.ImageManipulation.Effects,EdgeDetectEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\EdgeDetectEffect.cs,SetWeights,The following statement contains a magic number: this.weights[2][2] = Math.Cos (r - 3.0 * dr);
Magic Number,Pinta.ImageManipulation.Effects,EdgeDetectEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\EdgeDetectEffect.cs,SetWeights,The following statement contains a magic number: this.weights[2][2] = Math.Cos (r - 3.0 * dr);
Magic Number,Pinta.ImageManipulation.Effects,EdgeDetectEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\EdgeDetectEffect.cs,SetWeights,The following statement contains a magic number: this.weights[2][2] = Math.Cos (r - 3.0 * dr);
Magic Number,Pinta.ImageManipulation.Effects,ZoomBlurEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\ZoomBlurEffect.cs,ZoomBlurEffect,The following statement contains a magic number: if (amount < 0 || amount > 200)  				throw new ArgumentOutOfRangeException ("amount");
Magic Number,Pinta.ImageManipulation.Effects,ZoomBlurEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\ZoomBlurEffect.cs,RenderLine,The following statement contains a magic number: long fox = (long)(dst.Width * offset.X * 32768.0);
Magic Number,Pinta.ImageManipulation.Effects,ZoomBlurEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\ZoomBlurEffect.cs,RenderLine,The following statement contains a magic number: long foy = (long)(dst.Height * offset.Y * 32768.0);
Magic Number,Pinta.ImageManipulation.Effects,ZoomBlurEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\ZoomBlurEffect.cs,RenderLine,The following statement contains a magic number: long fcx = fox + (w << 15);
Magic Number,Pinta.ImageManipulation.Effects,ZoomBlurEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\ZoomBlurEffect.cs,RenderLine,The following statement contains a magic number: long fcy = foy + (h << 15);
Magic Number,Pinta.ImageManipulation.Effects,ZoomBlurEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\ZoomBlurEffect.cs,RenderLine,The following statement contains a magic number: const int n = 64;
Magic Number,Pinta.ImageManipulation.Effects,ZoomBlurEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\ZoomBlurEffect.cs,RenderLine,The following statement contains a magic number: for (int y = rect.Top; y <= rect.Bottom; ++y) {  				ColorBgra* dstPtr = dst.GetPointAddress (rect.Left' y);  				ColorBgra* srcPtr = src.GetPointAddress (rect.Left' y);    				for (int x = rect.Left; x <= rect.Right; ++x) {  					long fx = (x << 16) - fcx;  					long fy = (y << 16) - fcy;    					int sr = 0;  					int sg = 0;  					int sb = 0;  					int sa = 0;  					int sc = 0;    					sr += srcPtr->R * srcPtr->A;  					sg += srcPtr->G * srcPtr->A;  					sb += srcPtr->B * srcPtr->A;  					sa += srcPtr->A;  					++sc;    					for (int i = 0; i < n; ++i) {  						fx -= ((fx >> 4) * fz) >> 10;  						fy -= ((fy >> 4) * fz) >> 10;    						int u = (int)(fx + fcx + 32768 >> 16);  						int v = (int)(fy + fcy + 32768 >> 16);    						if (src_bounds.Contains (u' v)) {  							ColorBgra* srcPtr2 = src.GetPointAddress (u' v);    							sr += srcPtr2->R * srcPtr2->A;  							sg += srcPtr2->G * srcPtr2->A;  							sb += srcPtr2->B * srcPtr2->A;  							sa += srcPtr2->A;  							++sc;  						}  					}    					if (sa != 0) {  						*dstPtr = ColorBgra.FromBgra (  							Utility.ClampToByte (sb / sa)'  							Utility.ClampToByte (sg / sa)'  							Utility.ClampToByte (sr / sa)'  							Utility.ClampToByte (sa / sc));  					} else {  						dstPtr->Bgra = 0;  					}    					++srcPtr;  					++dstPtr;  				}  			}
Magic Number,Pinta.ImageManipulation.Effects,ZoomBlurEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\ZoomBlurEffect.cs,RenderLine,The following statement contains a magic number: for (int y = rect.Top; y <= rect.Bottom; ++y) {  				ColorBgra* dstPtr = dst.GetPointAddress (rect.Left' y);  				ColorBgra* srcPtr = src.GetPointAddress (rect.Left' y);    				for (int x = rect.Left; x <= rect.Right; ++x) {  					long fx = (x << 16) - fcx;  					long fy = (y << 16) - fcy;    					int sr = 0;  					int sg = 0;  					int sb = 0;  					int sa = 0;  					int sc = 0;    					sr += srcPtr->R * srcPtr->A;  					sg += srcPtr->G * srcPtr->A;  					sb += srcPtr->B * srcPtr->A;  					sa += srcPtr->A;  					++sc;    					for (int i = 0; i < n; ++i) {  						fx -= ((fx >> 4) * fz) >> 10;  						fy -= ((fy >> 4) * fz) >> 10;    						int u = (int)(fx + fcx + 32768 >> 16);  						int v = (int)(fy + fcy + 32768 >> 16);    						if (src_bounds.Contains (u' v)) {  							ColorBgra* srcPtr2 = src.GetPointAddress (u' v);    							sr += srcPtr2->R * srcPtr2->A;  							sg += srcPtr2->G * srcPtr2->A;  							sb += srcPtr2->B * srcPtr2->A;  							sa += srcPtr2->A;  							++sc;  						}  					}    					if (sa != 0) {  						*dstPtr = ColorBgra.FromBgra (  							Utility.ClampToByte (sb / sa)'  							Utility.ClampToByte (sg / sa)'  							Utility.ClampToByte (sr / sa)'  							Utility.ClampToByte (sa / sc));  					} else {  						dstPtr->Bgra = 0;  					}    					++srcPtr;  					++dstPtr;  				}  			}
Magic Number,Pinta.ImageManipulation.Effects,ZoomBlurEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\ZoomBlurEffect.cs,RenderLine,The following statement contains a magic number: for (int y = rect.Top; y <= rect.Bottom; ++y) {  				ColorBgra* dstPtr = dst.GetPointAddress (rect.Left' y);  				ColorBgra* srcPtr = src.GetPointAddress (rect.Left' y);    				for (int x = rect.Left; x <= rect.Right; ++x) {  					long fx = (x << 16) - fcx;  					long fy = (y << 16) - fcy;    					int sr = 0;  					int sg = 0;  					int sb = 0;  					int sa = 0;  					int sc = 0;    					sr += srcPtr->R * srcPtr->A;  					sg += srcPtr->G * srcPtr->A;  					sb += srcPtr->B * srcPtr->A;  					sa += srcPtr->A;  					++sc;    					for (int i = 0; i < n; ++i) {  						fx -= ((fx >> 4) * fz) >> 10;  						fy -= ((fy >> 4) * fz) >> 10;    						int u = (int)(fx + fcx + 32768 >> 16);  						int v = (int)(fy + fcy + 32768 >> 16);    						if (src_bounds.Contains (u' v)) {  							ColorBgra* srcPtr2 = src.GetPointAddress (u' v);    							sr += srcPtr2->R * srcPtr2->A;  							sg += srcPtr2->G * srcPtr2->A;  							sb += srcPtr2->B * srcPtr2->A;  							sa += srcPtr2->A;  							++sc;  						}  					}    					if (sa != 0) {  						*dstPtr = ColorBgra.FromBgra (  							Utility.ClampToByte (sb / sa)'  							Utility.ClampToByte (sg / sa)'  							Utility.ClampToByte (sr / sa)'  							Utility.ClampToByte (sa / sc));  					} else {  						dstPtr->Bgra = 0;  					}    					++srcPtr;  					++dstPtr;  				}  			}
Magic Number,Pinta.ImageManipulation.Effects,ZoomBlurEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\ZoomBlurEffect.cs,RenderLine,The following statement contains a magic number: for (int y = rect.Top; y <= rect.Bottom; ++y) {  				ColorBgra* dstPtr = dst.GetPointAddress (rect.Left' y);  				ColorBgra* srcPtr = src.GetPointAddress (rect.Left' y);    				for (int x = rect.Left; x <= rect.Right; ++x) {  					long fx = (x << 16) - fcx;  					long fy = (y << 16) - fcy;    					int sr = 0;  					int sg = 0;  					int sb = 0;  					int sa = 0;  					int sc = 0;    					sr += srcPtr->R * srcPtr->A;  					sg += srcPtr->G * srcPtr->A;  					sb += srcPtr->B * srcPtr->A;  					sa += srcPtr->A;  					++sc;    					for (int i = 0; i < n; ++i) {  						fx -= ((fx >> 4) * fz) >> 10;  						fy -= ((fy >> 4) * fz) >> 10;    						int u = (int)(fx + fcx + 32768 >> 16);  						int v = (int)(fy + fcy + 32768 >> 16);    						if (src_bounds.Contains (u' v)) {  							ColorBgra* srcPtr2 = src.GetPointAddress (u' v);    							sr += srcPtr2->R * srcPtr2->A;  							sg += srcPtr2->G * srcPtr2->A;  							sb += srcPtr2->B * srcPtr2->A;  							sa += srcPtr2->A;  							++sc;  						}  					}    					if (sa != 0) {  						*dstPtr = ColorBgra.FromBgra (  							Utility.ClampToByte (sb / sa)'  							Utility.ClampToByte (sg / sa)'  							Utility.ClampToByte (sr / sa)'  							Utility.ClampToByte (sa / sc));  					} else {  						dstPtr->Bgra = 0;  					}    					++srcPtr;  					++dstPtr;  				}  			}
Magic Number,Pinta.ImageManipulation.Effects,ZoomBlurEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\ZoomBlurEffect.cs,RenderLine,The following statement contains a magic number: for (int y = rect.Top; y <= rect.Bottom; ++y) {  				ColorBgra* dstPtr = dst.GetPointAddress (rect.Left' y);  				ColorBgra* srcPtr = src.GetPointAddress (rect.Left' y);    				for (int x = rect.Left; x <= rect.Right; ++x) {  					long fx = (x << 16) - fcx;  					long fy = (y << 16) - fcy;    					int sr = 0;  					int sg = 0;  					int sb = 0;  					int sa = 0;  					int sc = 0;    					sr += srcPtr->R * srcPtr->A;  					sg += srcPtr->G * srcPtr->A;  					sb += srcPtr->B * srcPtr->A;  					sa += srcPtr->A;  					++sc;    					for (int i = 0; i < n; ++i) {  						fx -= ((fx >> 4) * fz) >> 10;  						fy -= ((fy >> 4) * fz) >> 10;    						int u = (int)(fx + fcx + 32768 >> 16);  						int v = (int)(fy + fcy + 32768 >> 16);    						if (src_bounds.Contains (u' v)) {  							ColorBgra* srcPtr2 = src.GetPointAddress (u' v);    							sr += srcPtr2->R * srcPtr2->A;  							sg += srcPtr2->G * srcPtr2->A;  							sb += srcPtr2->B * srcPtr2->A;  							sa += srcPtr2->A;  							++sc;  						}  					}    					if (sa != 0) {  						*dstPtr = ColorBgra.FromBgra (  							Utility.ClampToByte (sb / sa)'  							Utility.ClampToByte (sg / sa)'  							Utility.ClampToByte (sr / sa)'  							Utility.ClampToByte (sa / sc));  					} else {  						dstPtr->Bgra = 0;  					}    					++srcPtr;  					++dstPtr;  				}  			}
Magic Number,Pinta.ImageManipulation.Effects,ZoomBlurEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\ZoomBlurEffect.cs,RenderLine,The following statement contains a magic number: for (int y = rect.Top; y <= rect.Bottom; ++y) {  				ColorBgra* dstPtr = dst.GetPointAddress (rect.Left' y);  				ColorBgra* srcPtr = src.GetPointAddress (rect.Left' y);    				for (int x = rect.Left; x <= rect.Right; ++x) {  					long fx = (x << 16) - fcx;  					long fy = (y << 16) - fcy;    					int sr = 0;  					int sg = 0;  					int sb = 0;  					int sa = 0;  					int sc = 0;    					sr += srcPtr->R * srcPtr->A;  					sg += srcPtr->G * srcPtr->A;  					sb += srcPtr->B * srcPtr->A;  					sa += srcPtr->A;  					++sc;    					for (int i = 0; i < n; ++i) {  						fx -= ((fx >> 4) * fz) >> 10;  						fy -= ((fy >> 4) * fz) >> 10;    						int u = (int)(fx + fcx + 32768 >> 16);  						int v = (int)(fy + fcy + 32768 >> 16);    						if (src_bounds.Contains (u' v)) {  							ColorBgra* srcPtr2 = src.GetPointAddress (u' v);    							sr += srcPtr2->R * srcPtr2->A;  							sg += srcPtr2->G * srcPtr2->A;  							sb += srcPtr2->B * srcPtr2->A;  							sa += srcPtr2->A;  							++sc;  						}  					}    					if (sa != 0) {  						*dstPtr = ColorBgra.FromBgra (  							Utility.ClampToByte (sb / sa)'  							Utility.ClampToByte (sg / sa)'  							Utility.ClampToByte (sr / sa)'  							Utility.ClampToByte (sa / sc));  					} else {  						dstPtr->Bgra = 0;  					}    					++srcPtr;  					++dstPtr;  				}  			}
Magic Number,Pinta.ImageManipulation.Effects,ZoomBlurEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\ZoomBlurEffect.cs,RenderLine,The following statement contains a magic number: for (int y = rect.Top; y <= rect.Bottom; ++y) {  				ColorBgra* dstPtr = dst.GetPointAddress (rect.Left' y);  				ColorBgra* srcPtr = src.GetPointAddress (rect.Left' y);    				for (int x = rect.Left; x <= rect.Right; ++x) {  					long fx = (x << 16) - fcx;  					long fy = (y << 16) - fcy;    					int sr = 0;  					int sg = 0;  					int sb = 0;  					int sa = 0;  					int sc = 0;    					sr += srcPtr->R * srcPtr->A;  					sg += srcPtr->G * srcPtr->A;  					sb += srcPtr->B * srcPtr->A;  					sa += srcPtr->A;  					++sc;    					for (int i = 0; i < n; ++i) {  						fx -= ((fx >> 4) * fz) >> 10;  						fy -= ((fy >> 4) * fz) >> 10;    						int u = (int)(fx + fcx + 32768 >> 16);  						int v = (int)(fy + fcy + 32768 >> 16);    						if (src_bounds.Contains (u' v)) {  							ColorBgra* srcPtr2 = src.GetPointAddress (u' v);    							sr += srcPtr2->R * srcPtr2->A;  							sg += srcPtr2->G * srcPtr2->A;  							sb += srcPtr2->B * srcPtr2->A;  							sa += srcPtr2->A;  							++sc;  						}  					}    					if (sa != 0) {  						*dstPtr = ColorBgra.FromBgra (  							Utility.ClampToByte (sb / sa)'  							Utility.ClampToByte (sg / sa)'  							Utility.ClampToByte (sr / sa)'  							Utility.ClampToByte (sa / sc));  					} else {  						dstPtr->Bgra = 0;  					}    					++srcPtr;  					++dstPtr;  				}  			}
Magic Number,Pinta.ImageManipulation.Effects,ZoomBlurEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\ZoomBlurEffect.cs,RenderLine,The following statement contains a magic number: for (int y = rect.Top; y <= rect.Bottom; ++y) {  				ColorBgra* dstPtr = dst.GetPointAddress (rect.Left' y);  				ColorBgra* srcPtr = src.GetPointAddress (rect.Left' y);    				for (int x = rect.Left; x <= rect.Right; ++x) {  					long fx = (x << 16) - fcx;  					long fy = (y << 16) - fcy;    					int sr = 0;  					int sg = 0;  					int sb = 0;  					int sa = 0;  					int sc = 0;    					sr += srcPtr->R * srcPtr->A;  					sg += srcPtr->G * srcPtr->A;  					sb += srcPtr->B * srcPtr->A;  					sa += srcPtr->A;  					++sc;    					for (int i = 0; i < n; ++i) {  						fx -= ((fx >> 4) * fz) >> 10;  						fy -= ((fy >> 4) * fz) >> 10;    						int u = (int)(fx + fcx + 32768 >> 16);  						int v = (int)(fy + fcy + 32768 >> 16);    						if (src_bounds.Contains (u' v)) {  							ColorBgra* srcPtr2 = src.GetPointAddress (u' v);    							sr += srcPtr2->R * srcPtr2->A;  							sg += srcPtr2->G * srcPtr2->A;  							sb += srcPtr2->B * srcPtr2->A;  							sa += srcPtr2->A;  							++sc;  						}  					}    					if (sa != 0) {  						*dstPtr = ColorBgra.FromBgra (  							Utility.ClampToByte (sb / sa)'  							Utility.ClampToByte (sg / sa)'  							Utility.ClampToByte (sr / sa)'  							Utility.ClampToByte (sa / sc));  					} else {  						dstPtr->Bgra = 0;  					}    					++srcPtr;  					++dstPtr;  				}  			}
Magic Number,Pinta.ImageManipulation.Effects,ZoomBlurEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\ZoomBlurEffect.cs,RenderLine,The following statement contains a magic number: for (int y = rect.Top; y <= rect.Bottom; ++y) {  				ColorBgra* dstPtr = dst.GetPointAddress (rect.Left' y);  				ColorBgra* srcPtr = src.GetPointAddress (rect.Left' y);    				for (int x = rect.Left; x <= rect.Right; ++x) {  					long fx = (x << 16) - fcx;  					long fy = (y << 16) - fcy;    					int sr = 0;  					int sg = 0;  					int sb = 0;  					int sa = 0;  					int sc = 0;    					sr += srcPtr->R * srcPtr->A;  					sg += srcPtr->G * srcPtr->A;  					sb += srcPtr->B * srcPtr->A;  					sa += srcPtr->A;  					++sc;    					for (int i = 0; i < n; ++i) {  						fx -= ((fx >> 4) * fz) >> 10;  						fy -= ((fy >> 4) * fz) >> 10;    						int u = (int)(fx + fcx + 32768 >> 16);  						int v = (int)(fy + fcy + 32768 >> 16);    						if (src_bounds.Contains (u' v)) {  							ColorBgra* srcPtr2 = src.GetPointAddress (u' v);    							sr += srcPtr2->R * srcPtr2->A;  							sg += srcPtr2->G * srcPtr2->A;  							sb += srcPtr2->B * srcPtr2->A;  							sa += srcPtr2->A;  							++sc;  						}  					}    					if (sa != 0) {  						*dstPtr = ColorBgra.FromBgra (  							Utility.ClampToByte (sb / sa)'  							Utility.ClampToByte (sg / sa)'  							Utility.ClampToByte (sr / sa)'  							Utility.ClampToByte (sa / sc));  					} else {  						dstPtr->Bgra = 0;  					}    					++srcPtr;  					++dstPtr;  				}  			}
Magic Number,Pinta.ImageManipulation.Effects,ZoomBlurEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\ZoomBlurEffect.cs,RenderLine,The following statement contains a magic number: for (int y = rect.Top; y <= rect.Bottom; ++y) {  				ColorBgra* dstPtr = dst.GetPointAddress (rect.Left' y);  				ColorBgra* srcPtr = src.GetPointAddress (rect.Left' y);    				for (int x = rect.Left; x <= rect.Right; ++x) {  					long fx = (x << 16) - fcx;  					long fy = (y << 16) - fcy;    					int sr = 0;  					int sg = 0;  					int sb = 0;  					int sa = 0;  					int sc = 0;    					sr += srcPtr->R * srcPtr->A;  					sg += srcPtr->G * srcPtr->A;  					sb += srcPtr->B * srcPtr->A;  					sa += srcPtr->A;  					++sc;    					for (int i = 0; i < n; ++i) {  						fx -= ((fx >> 4) * fz) >> 10;  						fy -= ((fy >> 4) * fz) >> 10;    						int u = (int)(fx + fcx + 32768 >> 16);  						int v = (int)(fy + fcy + 32768 >> 16);    						if (src_bounds.Contains (u' v)) {  							ColorBgra* srcPtr2 = src.GetPointAddress (u' v);    							sr += srcPtr2->R * srcPtr2->A;  							sg += srcPtr2->G * srcPtr2->A;  							sb += srcPtr2->B * srcPtr2->A;  							sa += srcPtr2->A;  							++sc;  						}  					}    					if (sa != 0) {  						*dstPtr = ColorBgra.FromBgra (  							Utility.ClampToByte (sb / sa)'  							Utility.ClampToByte (sg / sa)'  							Utility.ClampToByte (sr / sa)'  							Utility.ClampToByte (sa / sc));  					} else {  						dstPtr->Bgra = 0;  					}    					++srcPtr;  					++dstPtr;  				}  			}
Magic Number,Pinta.ImageManipulation.Effects,PolarInversionEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\PolarInversionEffect.cs,PolarInversionEffect,The following statement contains a magic number: if (amount < -4 || amount > 4)  				throw new ArgumentOutOfRangeException ("amount");
Magic Number,Pinta.ImageManipulation.Effects,PolarInversionEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\PolarInversionEffect.cs,PolarInversionEffect,The following statement contains a magic number: if (amount < -4 || amount > 4)  				throw new ArgumentOutOfRangeException ("amount");
Magic Number,Pinta.ImageManipulation.Effects,WarpEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\WarpEffect.cs,WarpEffect,The following statement contains a magic number: if (quality < 1 || quality > 5)  				throw new ArgumentOutOfRangeException ("quality");
Magic Number,Pinta.ImageManipulation.Effects,UnfocusEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\UnfocusEffect.cs,UnfocusEffect,The following statement contains a magic number: if (radius < 1 || radius > 200)  				throw new ArgumentOutOfRangeException ("radius");
Magic Number,Pinta.ImageManipulation.Effects,UnfocusEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\UnfocusEffect.cs,ApplyWithAlpha,The following statement contains a magic number: if (area < 32768) {  				int b = 0;  				int g = 0;  				int r = 0;    				for (int i = 1; i < 256; ++i) {  					b += i * hb[i];  					g += i * hg[i];  					r += i * hr[i];  				}    				int alpha = sum / area;  				int div = area * 255;    				return ColorBgra.FromBgraClamped (b / div' g / div' r / div' alpha);  			} else {	//use a long if an int will overflow.  				long b = 0;  				long g = 0;  				long r = 0;    				for (long i = 1; i < 256; ++i) {  					b += i * hb[i];  					g += i * hg[i];  					r += i * hr[i];  				}    				int alpha = sum / area;  				int div = area * 255;    				return ColorBgra.FromBgraClamped (b / div' g / div' r / div' alpha);  			}
Magic Number,Pinta.ImageManipulation.Effects,UnfocusEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\UnfocusEffect.cs,ApplyWithAlpha,The following statement contains a magic number: if (area < 32768) {  				int b = 0;  				int g = 0;  				int r = 0;    				for (int i = 1; i < 256; ++i) {  					b += i * hb[i];  					g += i * hg[i];  					r += i * hr[i];  				}    				int alpha = sum / area;  				int div = area * 255;    				return ColorBgra.FromBgraClamped (b / div' g / div' r / div' alpha);  			} else {	//use a long if an int will overflow.  				long b = 0;  				long g = 0;  				long r = 0;    				for (long i = 1; i < 256; ++i) {  					b += i * hb[i];  					g += i * hg[i];  					r += i * hr[i];  				}    				int alpha = sum / area;  				int div = area * 255;    				return ColorBgra.FromBgraClamped (b / div' g / div' r / div' alpha);  			}
Magic Number,Pinta.ImageManipulation.Effects,UnfocusEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\UnfocusEffect.cs,ApplyWithAlpha,The following statement contains a magic number: if (area < 32768) {  				int b = 0;  				int g = 0;  				int r = 0;    				for (int i = 1; i < 256; ++i) {  					b += i * hb[i];  					g += i * hg[i];  					r += i * hr[i];  				}    				int alpha = sum / area;  				int div = area * 255;    				return ColorBgra.FromBgraClamped (b / div' g / div' r / div' alpha);  			} else {	//use a long if an int will overflow.  				long b = 0;  				long g = 0;  				long r = 0;    				for (long i = 1; i < 256; ++i) {  					b += i * hb[i];  					g += i * hg[i];  					r += i * hr[i];  				}    				int alpha = sum / area;  				int div = area * 255;    				return ColorBgra.FromBgraClamped (b / div' g / div' r / div' alpha);  			}
Magic Number,Pinta.ImageManipulation.Effects,UnfocusEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\UnfocusEffect.cs,ApplyWithAlpha,The following statement contains a magic number: if (area < 32768) {  				int b = 0;  				int g = 0;  				int r = 0;    				for (int i = 1; i < 256; ++i) {  					b += i * hb[i];  					g += i * hg[i];  					r += i * hr[i];  				}    				int alpha = sum / area;  				int div = area * 255;    				return ColorBgra.FromBgraClamped (b / div' g / div' r / div' alpha);  			} else {	//use a long if an int will overflow.  				long b = 0;  				long g = 0;  				long r = 0;    				for (long i = 1; i < 256; ++i) {  					b += i * hb[i];  					g += i * hg[i];  					r += i * hr[i];  				}    				int alpha = sum / area;  				int div = area * 255;    				return ColorBgra.FromBgraClamped (b / div' g / div' r / div' alpha);  			}
Magic Number,Pinta.ImageManipulation.Effects,UnfocusEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\UnfocusEffect.cs,ApplyWithAlpha,The following statement contains a magic number: if (area < 32768) {  				int b = 0;  				int g = 0;  				int r = 0;    				for (int i = 1; i < 256; ++i) {  					b += i * hb[i];  					g += i * hg[i];  					r += i * hr[i];  				}    				int alpha = sum / area;  				int div = area * 255;    				return ColorBgra.FromBgraClamped (b / div' g / div' r / div' alpha);  			} else {	//use a long if an int will overflow.  				long b = 0;  				long g = 0;  				long r = 0;    				for (long i = 1; i < 256; ++i) {  					b += i * hb[i];  					g += i * hg[i];  					r += i * hr[i];  				}    				int alpha = sum / area;  				int div = area * 255;    				return ColorBgra.FromBgraClamped (b / div' g / div' r / div' alpha);  			}
Magic Number,Pinta.ImageManipulation.Effects,TwistEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\TwistEffect.cs,TwistEffect,The following statement contains a magic number: if (amount < -100 || amount > 100)  				throw new ArgumentOutOfRangeException ("amount");
Magic Number,Pinta.ImageManipulation.Effects,TwistEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\TwistEffect.cs,TwistEffect,The following statement contains a magic number: if (amount < -100 || amount > 100)  				throw new ArgumentOutOfRangeException ("amount");
Magic Number,Pinta.ImageManipulation.Effects,TwistEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\TwistEffect.cs,TwistEffect,The following statement contains a magic number: if (antialias < 0 || antialias > 5)  				throw new ArgumentOutOfRangeException ("antialias");
Magic Number,Pinta.ImageManipulation.Effects,TwistEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\TwistEffect.cs,RenderLine,The following statement contains a magic number: for (int y = rect.Top; y <= rect.Bottom; y++) {  				float j = y - hh;  				ColorBgra* dstPtr = dst.GetPointAddress (rect.Left' y);  				ColorBgra* srcPtr = src.GetPointAddress (rect.Left' y);    				for (int x = rect.Left; x <= rect.Right; x++) {  					float i = x - hw;    					if (i * i + j * j > (maxrad + 1) * (maxrad + 1)) {  						*dstPtr = *srcPtr;  					} else {  						int b = 0;  						int g = 0;  						int r = 0;  						int a = 0;    						for (int p = 0; p < aaSamples; ++p) {  							float u = i + (float)aaPoints[p].X;  							float v = j + (float)aaPoints[p].Y;  							double rad = Math.Sqrt (u * u + v * v);  							double theta = Math.Atan2 (v' u);    							double t = 1 - rad / maxrad;    							t = (t < 0) ? 0 : (t * t * t);    							theta += (t * twist) / 100;    							ColorBgra sample = src.GetPoint (  								(int)(hw + (float)(rad * Math.Cos (theta)))'  								(int)(hh + (float)(rad * Math.Sin (theta))));    							b += sample.B;  							g += sample.G;  							r += sample.R;  							a += sample.A;  						}    						*dstPtr = ColorBgra.FromBgra (  							(byte)(b / aaSamples)'  							(byte)(g / aaSamples)'  							(byte)(r / aaSamples)'  							(byte)(a / aaSamples));  					}    					++dstPtr;  					++srcPtr;  				}  			}
Magic Number,Pinta.ImageManipulation.Effects,TileEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\TileEffect.cs,TileEffect,The following statement contains a magic number: if (tileSize < 2 || tileSize > 200)  				throw new ArgumentOutOfRangeException ("tileSize");
Magic Number,Pinta.ImageManipulation.Effects,TileEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\TileEffect.cs,TileEffect,The following statement contains a magic number: if (tileSize < 2 || tileSize > 200)  				throw new ArgumentOutOfRangeException ("tileSize");
Magic Number,Pinta.ImageManipulation.Effects,TileEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\TileEffect.cs,TileEffect,The following statement contains a magic number: if (intensity < -20 || intensity > 20)  				throw new ArgumentOutOfRangeException ("intensity");
Magic Number,Pinta.ImageManipulation.Effects,TileEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\TileEffect.cs,TileEffect,The following statement contains a magic number: if (intensity < -20 || intensity > 20)  				throw new ArgumentOutOfRangeException ("intensity");
Magic Number,Pinta.ImageManipulation.Effects,TileEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\TileEffect.cs,RenderLine,The following statement contains a magic number: float sin = (float)Math.Sin (rotation * Math.PI / 180.0);
Magic Number,Pinta.ImageManipulation.Effects,TileEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\TileEffect.cs,RenderLine,The following statement contains a magic number: float cos = (float)Math.Cos (rotation * Math.PI / 180.0);
Magic Number,Pinta.ImageManipulation.Effects,TileEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\TileEffect.cs,RenderLine,The following statement contains a magic number: intensity = intensity * intensity / 10 * Math.Sign (intensity);
Magic Number,Pinta.ImageManipulation.Effects,TileEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\TileEffect.cs,RenderLine,The following statement contains a magic number: int aaLevel = 4;
Magic Number,Pinta.ImageManipulation.Effects,SoftenPortraitEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\SoftenPortraitEffect.cs,SoftenPortraitEffect,The following statement contains a magic number: if (softness < 0 || softness > 10)  				throw new ArgumentOutOfRangeException ("softness");
Magic Number,Pinta.ImageManipulation.Effects,SoftenPortraitEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\SoftenPortraitEffect.cs,SoftenPortraitEffect,The following statement contains a magic number: if (lighting < -20 || lighting > 20)  				throw new ArgumentOutOfRangeException ("lighting");
Magic Number,Pinta.ImageManipulation.Effects,SoftenPortraitEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\SoftenPortraitEffect.cs,SoftenPortraitEffect,The following statement contains a magic number: if (lighting < -20 || lighting > 20)  				throw new ArgumentOutOfRangeException ("lighting");
Magic Number,Pinta.ImageManipulation.Effects,SoftenPortraitEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\SoftenPortraitEffect.cs,SoftenPortraitEffect,The following statement contains a magic number: if (warmth < 0 || warmth > 20)  				throw new ArgumentOutOfRangeException ("warmth");
Magic Number,Pinta.ImageManipulation.Effects,SoftenPortraitEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\SoftenPortraitEffect.cs,SoftenPortraitEffect,The following statement contains a magic number: blur_effect = new GaussianBlurEffect (2);
Magic Number,Pinta.ImageManipulation.Effects,SharpenEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\SharpenEffect.cs,SharpenEffect,The following statement contains a magic number: if (amount < 1 || amount > 20)  				throw new ArgumentOutOfRangeException ("amount");
Magic Number,Pinta.ImageManipulation.Effects,SharpenEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\SharpenEffect.cs,Apply,The following statement contains a magic number: var median = GetPercentile (50' area' hb' hg' hr' ha);
Magic Number,Pinta.ImageManipulation.Effects,ReduceNoiseEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\ReduceNoiseEffect.cs,ReduceNoiseEffect,The following statement contains a magic number: if (radius < 1 || radius > 200)  				throw new ArgumentOutOfRangeException ("radius");
Magic Number,Pinta.ImageManipulation.Effects,ReduceNoiseEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\ReduceNoiseEffect.cs,ReduceNoiseEffect,The following statement contains a magic number: this.strength = -0.2 * strength;
Magic Number,Pinta.ImageManipulation.Effects,ReduceNoiseEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\ReduceNoiseEffect.cs,Apply,The following statement contains a magic number: var lerp = strength * (1 - 0.75 * color.GetIntensity ());
Magic Number,Pinta.ImageManipulation.Effects,ReduceNoiseEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\ReduceNoiseEffect.cs,GetPercentileOfColor,The following statement contains a magic number: rc = (rc * 255) / area;
Magic Number,Pinta.ImageManipulation.Effects,ReduceNoiseEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\ReduceNoiseEffect.cs,GetPercentileOfColor,The following statement contains a magic number: gc = (gc * 255) / area;
Magic Number,Pinta.ImageManipulation.Effects,ReduceNoiseEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\ReduceNoiseEffect.cs,GetPercentileOfColor,The following statement contains a magic number: bc = (bc * 255) / area;
Magic Number,Pinta.ImageManipulation.Effects,RedEyeRemoveEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\RedEyeRemoveEffect.cs,RedEyeRemoveEffect,The following statement contains a magic number: if (tolerance < 0 || tolerance > 100)  				throw new ArgumentOutOfRangeException ("tolerance");
Magic Number,Pinta.ImageManipulation.Effects,RedEyeRemoveEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\RedEyeRemoveEffect.cs,RedEyeRemoveEffect,The following statement contains a magic number: if (saturation < 0 || saturation > 100)  				throw new ArgumentOutOfRangeException ("saturation");
Magic Number,Pinta.ImageManipulation.Effects,RadialBlurEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\RadialBlurEffect.cs,RadialBlurEffect,The following statement contains a magic number: if (quality < 1 || quality > 5)  				throw new ArgumentOutOfRangeException ("quality");
Magic Number,Pinta.ImageManipulation.Effects,RadialBlurEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\RadialBlurEffect.cs,RenderLine,The following statement contains a magic number: int fcx = (w << 15) + (int)(offset.X * (w << 15));
Magic Number,Pinta.ImageManipulation.Effects,RadialBlurEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\RadialBlurEffect.cs,RenderLine,The following statement contains a magic number: int fcx = (w << 15) + (int)(offset.X * (w << 15));
Magic Number,Pinta.ImageManipulation.Effects,RadialBlurEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\RadialBlurEffect.cs,RenderLine,The following statement contains a magic number: int fcy = (h << 15) + (int)(offset.Y * (h << 15));
Magic Number,Pinta.ImageManipulation.Effects,RadialBlurEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\RadialBlurEffect.cs,RenderLine,The following statement contains a magic number: int fcy = (h << 15) + (int)(offset.Y * (h << 15));
Magic Number,Pinta.ImageManipulation.Effects,RadialBlurEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\RadialBlurEffect.cs,RenderLine,The following statement contains a magic number: int n = (quality * quality) * (30 + quality * quality);
Magic Number,Pinta.ImageManipulation.Effects,RadialBlurEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\RadialBlurEffect.cs,RenderLine,The following statement contains a magic number: int fr = (int)(angle * Math.PI * 65536.0 / 181.0);
Magic Number,Pinta.ImageManipulation.Effects,RadialBlurEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\RadialBlurEffect.cs,RenderLine,The following statement contains a magic number: int fr = (int)(angle * Math.PI * 65536.0 / 181.0);
Magic Number,Pinta.ImageManipulation.Effects,RadialBlurEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\RadialBlurEffect.cs,RenderLine,The following statement contains a magic number: for (int y = rect.Top; y <= rect.Bottom; ++y) {  				ColorBgra* dstPtr = dst.GetPointAddress (rect.Left' y);  				ColorBgra* srcPtr = src.GetPointAddress (rect.Left' y);    				for (int x = rect.Left; x <= rect.Right; ++x) {  					int fx = (x << 16) - fcx;  					int fy = (y << 16) - fcy;    					int fsr = fr / n;    					int sr = 0;  					int sg = 0;  					int sb = 0;  					int sa = 0;  					int sc = 0;    					sr += srcPtr->R * srcPtr->A;  					sg += srcPtr->G * srcPtr->A;  					sb += srcPtr->B * srcPtr->A;  					sa += srcPtr->A;  					++sc;    					int ox1 = fx;  					int ox2 = fx;  					int oy1 = fy;  					int oy2 = fy;    					for (int i = 0; i < n; ++i) {  						Rotate (ref ox1' ref oy1' fsr);  						Rotate (ref ox2' ref oy2' -fsr);    						int u1 = ox1 + fcx + 32768 >> 16;  						int v1 = oy1 + fcy + 32768 >> 16;    						if (u1 > 0 && v1 > 0 && u1 < w && v1 < h) {  							ColorBgra* sample = src.GetPointAddress (u1' v1);    							sr += sample->R * sample->A;  							sg += sample->G * sample->A;  							sb += sample->B * sample->A;  							sa += sample->A;  							++sc;  						}    						int u2 = ox2 + fcx + 32768 >> 16;  						int v2 = oy2 + fcy + 32768 >> 16;    						if (u2 > 0 && v2 > 0 && u2 < w && v2 < h) {  							ColorBgra* sample = src.GetPointAddress (u2' v2);    							sr += sample->R * sample->A;  							sg += sample->G * sample->A;  							sb += sample->B * sample->A;  							sa += sample->A;  							++sc;  						}  					}    					if (sa > 0) {  						*dstPtr = ColorBgra.FromBgra (  							Utility.ClampToByte (sb / sa)'  							Utility.ClampToByte (sg / sa)'  							Utility.ClampToByte (sr / sa)'  							Utility.ClampToByte (sa / sc));  					} else {  						dstPtr->Bgra = 0;  					}    					++dstPtr;  					++srcPtr;  				}  			}
Magic Number,Pinta.ImageManipulation.Effects,RadialBlurEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\RadialBlurEffect.cs,RenderLine,The following statement contains a magic number: for (int y = rect.Top; y <= rect.Bottom; ++y) {  				ColorBgra* dstPtr = dst.GetPointAddress (rect.Left' y);  				ColorBgra* srcPtr = src.GetPointAddress (rect.Left' y);    				for (int x = rect.Left; x <= rect.Right; ++x) {  					int fx = (x << 16) - fcx;  					int fy = (y << 16) - fcy;    					int fsr = fr / n;    					int sr = 0;  					int sg = 0;  					int sb = 0;  					int sa = 0;  					int sc = 0;    					sr += srcPtr->R * srcPtr->A;  					sg += srcPtr->G * srcPtr->A;  					sb += srcPtr->B * srcPtr->A;  					sa += srcPtr->A;  					++sc;    					int ox1 = fx;  					int ox2 = fx;  					int oy1 = fy;  					int oy2 = fy;    					for (int i = 0; i < n; ++i) {  						Rotate (ref ox1' ref oy1' fsr);  						Rotate (ref ox2' ref oy2' -fsr);    						int u1 = ox1 + fcx + 32768 >> 16;  						int v1 = oy1 + fcy + 32768 >> 16;    						if (u1 > 0 && v1 > 0 && u1 < w && v1 < h) {  							ColorBgra* sample = src.GetPointAddress (u1' v1);    							sr += sample->R * sample->A;  							sg += sample->G * sample->A;  							sb += sample->B * sample->A;  							sa += sample->A;  							++sc;  						}    						int u2 = ox2 + fcx + 32768 >> 16;  						int v2 = oy2 + fcy + 32768 >> 16;    						if (u2 > 0 && v2 > 0 && u2 < w && v2 < h) {  							ColorBgra* sample = src.GetPointAddress (u2' v2);    							sr += sample->R * sample->A;  							sg += sample->G * sample->A;  							sb += sample->B * sample->A;  							sa += sample->A;  							++sc;  						}  					}    					if (sa > 0) {  						*dstPtr = ColorBgra.FromBgra (  							Utility.ClampToByte (sb / sa)'  							Utility.ClampToByte (sg / sa)'  							Utility.ClampToByte (sr / sa)'  							Utility.ClampToByte (sa / sc));  					} else {  						dstPtr->Bgra = 0;  					}    					++dstPtr;  					++srcPtr;  				}  			}
Magic Number,Pinta.ImageManipulation.Effects,RadialBlurEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\RadialBlurEffect.cs,RenderLine,The following statement contains a magic number: for (int y = rect.Top; y <= rect.Bottom; ++y) {  				ColorBgra* dstPtr = dst.GetPointAddress (rect.Left' y);  				ColorBgra* srcPtr = src.GetPointAddress (rect.Left' y);    				for (int x = rect.Left; x <= rect.Right; ++x) {  					int fx = (x << 16) - fcx;  					int fy = (y << 16) - fcy;    					int fsr = fr / n;    					int sr = 0;  					int sg = 0;  					int sb = 0;  					int sa = 0;  					int sc = 0;    					sr += srcPtr->R * srcPtr->A;  					sg += srcPtr->G * srcPtr->A;  					sb += srcPtr->B * srcPtr->A;  					sa += srcPtr->A;  					++sc;    					int ox1 = fx;  					int ox2 = fx;  					int oy1 = fy;  					int oy2 = fy;    					for (int i = 0; i < n; ++i) {  						Rotate (ref ox1' ref oy1' fsr);  						Rotate (ref ox2' ref oy2' -fsr);    						int u1 = ox1 + fcx + 32768 >> 16;  						int v1 = oy1 + fcy + 32768 >> 16;    						if (u1 > 0 && v1 > 0 && u1 < w && v1 < h) {  							ColorBgra* sample = src.GetPointAddress (u1' v1);    							sr += sample->R * sample->A;  							sg += sample->G * sample->A;  							sb += sample->B * sample->A;  							sa += sample->A;  							++sc;  						}    						int u2 = ox2 + fcx + 32768 >> 16;  						int v2 = oy2 + fcy + 32768 >> 16;    						if (u2 > 0 && v2 > 0 && u2 < w && v2 < h) {  							ColorBgra* sample = src.GetPointAddress (u2' v2);    							sr += sample->R * sample->A;  							sg += sample->G * sample->A;  							sb += sample->B * sample->A;  							sa += sample->A;  							++sc;  						}  					}    					if (sa > 0) {  						*dstPtr = ColorBgra.FromBgra (  							Utility.ClampToByte (sb / sa)'  							Utility.ClampToByte (sg / sa)'  							Utility.ClampToByte (sr / sa)'  							Utility.ClampToByte (sa / sc));  					} else {  						dstPtr->Bgra = 0;  					}    					++dstPtr;  					++srcPtr;  				}  			}
Magic Number,Pinta.ImageManipulation.Effects,RadialBlurEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\RadialBlurEffect.cs,RenderLine,The following statement contains a magic number: for (int y = rect.Top; y <= rect.Bottom; ++y) {  				ColorBgra* dstPtr = dst.GetPointAddress (rect.Left' y);  				ColorBgra* srcPtr = src.GetPointAddress (rect.Left' y);    				for (int x = rect.Left; x <= rect.Right; ++x) {  					int fx = (x << 16) - fcx;  					int fy = (y << 16) - fcy;    					int fsr = fr / n;    					int sr = 0;  					int sg = 0;  					int sb = 0;  					int sa = 0;  					int sc = 0;    					sr += srcPtr->R * srcPtr->A;  					sg += srcPtr->G * srcPtr->A;  					sb += srcPtr->B * srcPtr->A;  					sa += srcPtr->A;  					++sc;    					int ox1 = fx;  					int ox2 = fx;  					int oy1 = fy;  					int oy2 = fy;    					for (int i = 0; i < n; ++i) {  						Rotate (ref ox1' ref oy1' fsr);  						Rotate (ref ox2' ref oy2' -fsr);    						int u1 = ox1 + fcx + 32768 >> 16;  						int v1 = oy1 + fcy + 32768 >> 16;    						if (u1 > 0 && v1 > 0 && u1 < w && v1 < h) {  							ColorBgra* sample = src.GetPointAddress (u1' v1);    							sr += sample->R * sample->A;  							sg += sample->G * sample->A;  							sb += sample->B * sample->A;  							sa += sample->A;  							++sc;  						}    						int u2 = ox2 + fcx + 32768 >> 16;  						int v2 = oy2 + fcy + 32768 >> 16;    						if (u2 > 0 && v2 > 0 && u2 < w && v2 < h) {  							ColorBgra* sample = src.GetPointAddress (u2' v2);    							sr += sample->R * sample->A;  							sg += sample->G * sample->A;  							sb += sample->B * sample->A;  							sa += sample->A;  							++sc;  						}  					}    					if (sa > 0) {  						*dstPtr = ColorBgra.FromBgra (  							Utility.ClampToByte (sb / sa)'  							Utility.ClampToByte (sg / sa)'  							Utility.ClampToByte (sr / sa)'  							Utility.ClampToByte (sa / sc));  					} else {  						dstPtr->Bgra = 0;  					}    					++dstPtr;  					++srcPtr;  				}  			}
Magic Number,Pinta.ImageManipulation.Effects,RadialBlurEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\RadialBlurEffect.cs,RenderLine,The following statement contains a magic number: for (int y = rect.Top; y <= rect.Bottom; ++y) {  				ColorBgra* dstPtr = dst.GetPointAddress (rect.Left' y);  				ColorBgra* srcPtr = src.GetPointAddress (rect.Left' y);    				for (int x = rect.Left; x <= rect.Right; ++x) {  					int fx = (x << 16) - fcx;  					int fy = (y << 16) - fcy;    					int fsr = fr / n;    					int sr = 0;  					int sg = 0;  					int sb = 0;  					int sa = 0;  					int sc = 0;    					sr += srcPtr->R * srcPtr->A;  					sg += srcPtr->G * srcPtr->A;  					sb += srcPtr->B * srcPtr->A;  					sa += srcPtr->A;  					++sc;    					int ox1 = fx;  					int ox2 = fx;  					int oy1 = fy;  					int oy2 = fy;    					for (int i = 0; i < n; ++i) {  						Rotate (ref ox1' ref oy1' fsr);  						Rotate (ref ox2' ref oy2' -fsr);    						int u1 = ox1 + fcx + 32768 >> 16;  						int v1 = oy1 + fcy + 32768 >> 16;    						if (u1 > 0 && v1 > 0 && u1 < w && v1 < h) {  							ColorBgra* sample = src.GetPointAddress (u1' v1);    							sr += sample->R * sample->A;  							sg += sample->G * sample->A;  							sb += sample->B * sample->A;  							sa += sample->A;  							++sc;  						}    						int u2 = ox2 + fcx + 32768 >> 16;  						int v2 = oy2 + fcy + 32768 >> 16;    						if (u2 > 0 && v2 > 0 && u2 < w && v2 < h) {  							ColorBgra* sample = src.GetPointAddress (u2' v2);    							sr += sample->R * sample->A;  							sg += sample->G * sample->A;  							sb += sample->B * sample->A;  							sa += sample->A;  							++sc;  						}  					}    					if (sa > 0) {  						*dstPtr = ColorBgra.FromBgra (  							Utility.ClampToByte (sb / sa)'  							Utility.ClampToByte (sg / sa)'  							Utility.ClampToByte (sr / sa)'  							Utility.ClampToByte (sa / sc));  					} else {  						dstPtr->Bgra = 0;  					}    					++dstPtr;  					++srcPtr;  				}  			}
Magic Number,Pinta.ImageManipulation.Effects,RadialBlurEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\RadialBlurEffect.cs,RenderLine,The following statement contains a magic number: for (int y = rect.Top; y <= rect.Bottom; ++y) {  				ColorBgra* dstPtr = dst.GetPointAddress (rect.Left' y);  				ColorBgra* srcPtr = src.GetPointAddress (rect.Left' y);    				for (int x = rect.Left; x <= rect.Right; ++x) {  					int fx = (x << 16) - fcx;  					int fy = (y << 16) - fcy;    					int fsr = fr / n;    					int sr = 0;  					int sg = 0;  					int sb = 0;  					int sa = 0;  					int sc = 0;    					sr += srcPtr->R * srcPtr->A;  					sg += srcPtr->G * srcPtr->A;  					sb += srcPtr->B * srcPtr->A;  					sa += srcPtr->A;  					++sc;    					int ox1 = fx;  					int ox2 = fx;  					int oy1 = fy;  					int oy2 = fy;    					for (int i = 0; i < n; ++i) {  						Rotate (ref ox1' ref oy1' fsr);  						Rotate (ref ox2' ref oy2' -fsr);    						int u1 = ox1 + fcx + 32768 >> 16;  						int v1 = oy1 + fcy + 32768 >> 16;    						if (u1 > 0 && v1 > 0 && u1 < w && v1 < h) {  							ColorBgra* sample = src.GetPointAddress (u1' v1);    							sr += sample->R * sample->A;  							sg += sample->G * sample->A;  							sb += sample->B * sample->A;  							sa += sample->A;  							++sc;  						}    						int u2 = ox2 + fcx + 32768 >> 16;  						int v2 = oy2 + fcy + 32768 >> 16;    						if (u2 > 0 && v2 > 0 && u2 < w && v2 < h) {  							ColorBgra* sample = src.GetPointAddress (u2' v2);    							sr += sample->R * sample->A;  							sg += sample->G * sample->A;  							sb += sample->B * sample->A;  							sa += sample->A;  							++sc;  						}  					}    					if (sa > 0) {  						*dstPtr = ColorBgra.FromBgra (  							Utility.ClampToByte (sb / sa)'  							Utility.ClampToByte (sg / sa)'  							Utility.ClampToByte (sr / sa)'  							Utility.ClampToByte (sa / sc));  					} else {  						dstPtr->Bgra = 0;  					}    					++dstPtr;  					++srcPtr;  				}  			}
Magic Number,Pinta.ImageManipulation.Effects,RadialBlurEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\RadialBlurEffect.cs,RenderLine,The following statement contains a magic number: for (int y = rect.Top; y <= rect.Bottom; ++y) {  				ColorBgra* dstPtr = dst.GetPointAddress (rect.Left' y);  				ColorBgra* srcPtr = src.GetPointAddress (rect.Left' y);    				for (int x = rect.Left; x <= rect.Right; ++x) {  					int fx = (x << 16) - fcx;  					int fy = (y << 16) - fcy;    					int fsr = fr / n;    					int sr = 0;  					int sg = 0;  					int sb = 0;  					int sa = 0;  					int sc = 0;    					sr += srcPtr->R * srcPtr->A;  					sg += srcPtr->G * srcPtr->A;  					sb += srcPtr->B * srcPtr->A;  					sa += srcPtr->A;  					++sc;    					int ox1 = fx;  					int ox2 = fx;  					int oy1 = fy;  					int oy2 = fy;    					for (int i = 0; i < n; ++i) {  						Rotate (ref ox1' ref oy1' fsr);  						Rotate (ref ox2' ref oy2' -fsr);    						int u1 = ox1 + fcx + 32768 >> 16;  						int v1 = oy1 + fcy + 32768 >> 16;    						if (u1 > 0 && v1 > 0 && u1 < w && v1 < h) {  							ColorBgra* sample = src.GetPointAddress (u1' v1);    							sr += sample->R * sample->A;  							sg += sample->G * sample->A;  							sb += sample->B * sample->A;  							sa += sample->A;  							++sc;  						}    						int u2 = ox2 + fcx + 32768 >> 16;  						int v2 = oy2 + fcy + 32768 >> 16;    						if (u2 > 0 && v2 > 0 && u2 < w && v2 < h) {  							ColorBgra* sample = src.GetPointAddress (u2' v2);    							sr += sample->R * sample->A;  							sg += sample->G * sample->A;  							sb += sample->B * sample->A;  							sa += sample->A;  							++sc;  						}  					}    					if (sa > 0) {  						*dstPtr = ColorBgra.FromBgra (  							Utility.ClampToByte (sb / sa)'  							Utility.ClampToByte (sg / sa)'  							Utility.ClampToByte (sr / sa)'  							Utility.ClampToByte (sa / sc));  					} else {  						dstPtr->Bgra = 0;  					}    					++dstPtr;  					++srcPtr;  				}  			}
Magic Number,Pinta.ImageManipulation.Effects,RadialBlurEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\RadialBlurEffect.cs,RenderLine,The following statement contains a magic number: for (int y = rect.Top; y <= rect.Bottom; ++y) {  				ColorBgra* dstPtr = dst.GetPointAddress (rect.Left' y);  				ColorBgra* srcPtr = src.GetPointAddress (rect.Left' y);    				for (int x = rect.Left; x <= rect.Right; ++x) {  					int fx = (x << 16) - fcx;  					int fy = (y << 16) - fcy;    					int fsr = fr / n;    					int sr = 0;  					int sg = 0;  					int sb = 0;  					int sa = 0;  					int sc = 0;    					sr += srcPtr->R * srcPtr->A;  					sg += srcPtr->G * srcPtr->A;  					sb += srcPtr->B * srcPtr->A;  					sa += srcPtr->A;  					++sc;    					int ox1 = fx;  					int ox2 = fx;  					int oy1 = fy;  					int oy2 = fy;    					for (int i = 0; i < n; ++i) {  						Rotate (ref ox1' ref oy1' fsr);  						Rotate (ref ox2' ref oy2' -fsr);    						int u1 = ox1 + fcx + 32768 >> 16;  						int v1 = oy1 + fcy + 32768 >> 16;    						if (u1 > 0 && v1 > 0 && u1 < w && v1 < h) {  							ColorBgra* sample = src.GetPointAddress (u1' v1);    							sr += sample->R * sample->A;  							sg += sample->G * sample->A;  							sb += sample->B * sample->A;  							sa += sample->A;  							++sc;  						}    						int u2 = ox2 + fcx + 32768 >> 16;  						int v2 = oy2 + fcy + 32768 >> 16;    						if (u2 > 0 && v2 > 0 && u2 < w && v2 < h) {  							ColorBgra* sample = src.GetPointAddress (u2' v2);    							sr += sample->R * sample->A;  							sg += sample->G * sample->A;  							sb += sample->B * sample->A;  							sa += sample->A;  							++sc;  						}  					}    					if (sa > 0) {  						*dstPtr = ColorBgra.FromBgra (  							Utility.ClampToByte (sb / sa)'  							Utility.ClampToByte (sg / sa)'  							Utility.ClampToByte (sr / sa)'  							Utility.ClampToByte (sa / sc));  					} else {  						dstPtr->Bgra = 0;  					}    					++dstPtr;  					++srcPtr;  				}  			}
Magic Number,Pinta.ImageManipulation.Effects,RadialBlurEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\RadialBlurEffect.cs,RenderLine,The following statement contains a magic number: for (int y = rect.Top; y <= rect.Bottom; ++y) {  				ColorBgra* dstPtr = dst.GetPointAddress (rect.Left' y);  				ColorBgra* srcPtr = src.GetPointAddress (rect.Left' y);    				for (int x = rect.Left; x <= rect.Right; ++x) {  					int fx = (x << 16) - fcx;  					int fy = (y << 16) - fcy;    					int fsr = fr / n;    					int sr = 0;  					int sg = 0;  					int sb = 0;  					int sa = 0;  					int sc = 0;    					sr += srcPtr->R * srcPtr->A;  					sg += srcPtr->G * srcPtr->A;  					sb += srcPtr->B * srcPtr->A;  					sa += srcPtr->A;  					++sc;    					int ox1 = fx;  					int ox2 = fx;  					int oy1 = fy;  					int oy2 = fy;    					for (int i = 0; i < n; ++i) {  						Rotate (ref ox1' ref oy1' fsr);  						Rotate (ref ox2' ref oy2' -fsr);    						int u1 = ox1 + fcx + 32768 >> 16;  						int v1 = oy1 + fcy + 32768 >> 16;    						if (u1 > 0 && v1 > 0 && u1 < w && v1 < h) {  							ColorBgra* sample = src.GetPointAddress (u1' v1);    							sr += sample->R * sample->A;  							sg += sample->G * sample->A;  							sb += sample->B * sample->A;  							sa += sample->A;  							++sc;  						}    						int u2 = ox2 + fcx + 32768 >> 16;  						int v2 = oy2 + fcy + 32768 >> 16;    						if (u2 > 0 && v2 > 0 && u2 < w && v2 < h) {  							ColorBgra* sample = src.GetPointAddress (u2' v2);    							sr += sample->R * sample->A;  							sg += sample->G * sample->A;  							sb += sample->B * sample->A;  							sa += sample->A;  							++sc;  						}  					}    					if (sa > 0) {  						*dstPtr = ColorBgra.FromBgra (  							Utility.ClampToByte (sb / sa)'  							Utility.ClampToByte (sg / sa)'  							Utility.ClampToByte (sr / sa)'  							Utility.ClampToByte (sa / sc));  					} else {  						dstPtr->Bgra = 0;  					}    					++dstPtr;  					++srcPtr;  				}  			}
Magic Number,Pinta.ImageManipulation.Effects,RadialBlurEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\RadialBlurEffect.cs,RenderLine,The following statement contains a magic number: for (int y = rect.Top; y <= rect.Bottom; ++y) {  				ColorBgra* dstPtr = dst.GetPointAddress (rect.Left' y);  				ColorBgra* srcPtr = src.GetPointAddress (rect.Left' y);    				for (int x = rect.Left; x <= rect.Right; ++x) {  					int fx = (x << 16) - fcx;  					int fy = (y << 16) - fcy;    					int fsr = fr / n;    					int sr = 0;  					int sg = 0;  					int sb = 0;  					int sa = 0;  					int sc = 0;    					sr += srcPtr->R * srcPtr->A;  					sg += srcPtr->G * srcPtr->A;  					sb += srcPtr->B * srcPtr->A;  					sa += srcPtr->A;  					++sc;    					int ox1 = fx;  					int ox2 = fx;  					int oy1 = fy;  					int oy2 = fy;    					for (int i = 0; i < n; ++i) {  						Rotate (ref ox1' ref oy1' fsr);  						Rotate (ref ox2' ref oy2' -fsr);    						int u1 = ox1 + fcx + 32768 >> 16;  						int v1 = oy1 + fcy + 32768 >> 16;    						if (u1 > 0 && v1 > 0 && u1 < w && v1 < h) {  							ColorBgra* sample = src.GetPointAddress (u1' v1);    							sr += sample->R * sample->A;  							sg += sample->G * sample->A;  							sb += sample->B * sample->A;  							sa += sample->A;  							++sc;  						}    						int u2 = ox2 + fcx + 32768 >> 16;  						int v2 = oy2 + fcy + 32768 >> 16;    						if (u2 > 0 && v2 > 0 && u2 < w && v2 < h) {  							ColorBgra* sample = src.GetPointAddress (u2' v2);    							sr += sample->R * sample->A;  							sg += sample->G * sample->A;  							sb += sample->B * sample->A;  							sa += sample->A;  							++sc;  						}  					}    					if (sa > 0) {  						*dstPtr = ColorBgra.FromBgra (  							Utility.ClampToByte (sb / sa)'  							Utility.ClampToByte (sg / sa)'  							Utility.ClampToByte (sr / sa)'  							Utility.ClampToByte (sa / sc));  					} else {  						dstPtr->Bgra = 0;  					}    					++dstPtr;  					++srcPtr;  				}  			}
Magic Number,Pinta.ImageManipulation.Effects,RadialBlurEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\RadialBlurEffect.cs,Rotate,The following statement contains a magic number: fx = cx - ((cy >> 8) * fr >> 8) - ((cx >> 14) * (fr * fr >> 11) >> 8);
Magic Number,Pinta.ImageManipulation.Effects,RadialBlurEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\RadialBlurEffect.cs,Rotate,The following statement contains a magic number: fx = cx - ((cy >> 8) * fr >> 8) - ((cx >> 14) * (fr * fr >> 11) >> 8);
Magic Number,Pinta.ImageManipulation.Effects,RadialBlurEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\RadialBlurEffect.cs,Rotate,The following statement contains a magic number: fx = cx - ((cy >> 8) * fr >> 8) - ((cx >> 14) * (fr * fr >> 11) >> 8);
Magic Number,Pinta.ImageManipulation.Effects,RadialBlurEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\RadialBlurEffect.cs,Rotate,The following statement contains a magic number: fx = cx - ((cy >> 8) * fr >> 8) - ((cx >> 14) * (fr * fr >> 11) >> 8);
Magic Number,Pinta.ImageManipulation.Effects,RadialBlurEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\RadialBlurEffect.cs,Rotate,The following statement contains a magic number: fx = cx - ((cy >> 8) * fr >> 8) - ((cx >> 14) * (fr * fr >> 11) >> 8);
Magic Number,Pinta.ImageManipulation.Effects,RadialBlurEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\RadialBlurEffect.cs,Rotate,The following statement contains a magic number: fy = cy + ((cx >> 8) * fr >> 8) - ((cy >> 14) * (fr * fr >> 11) >> 8);
Magic Number,Pinta.ImageManipulation.Effects,RadialBlurEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\RadialBlurEffect.cs,Rotate,The following statement contains a magic number: fy = cy + ((cx >> 8) * fr >> 8) - ((cy >> 14) * (fr * fr >> 11) >> 8);
Magic Number,Pinta.ImageManipulation.Effects,RadialBlurEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\RadialBlurEffect.cs,Rotate,The following statement contains a magic number: fy = cy + ((cx >> 8) * fr >> 8) - ((cy >> 14) * (fr * fr >> 11) >> 8);
Magic Number,Pinta.ImageManipulation.Effects,RadialBlurEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\RadialBlurEffect.cs,Rotate,The following statement contains a magic number: fy = cy + ((cx >> 8) * fr >> 8) - ((cy >> 14) * (fr * fr >> 11) >> 8);
Magic Number,Pinta.ImageManipulation.Effects,RadialBlurEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\RadialBlurEffect.cs,Rotate,The following statement contains a magic number: fy = cy + ((cx >> 8) * fr >> 8) - ((cy >> 14) * (fr * fr >> 11) >> 8);
Magic Number,Pinta.ImageManipulation.Effects,PixelateEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\PixelateEffect.cs,PixelateEffect,The following statement contains a magic number: if (cellSize < 0 || cellSize > 100)  				throw new ArgumentOutOfRangeException ("cellSize");
Magic Number,Pinta.ImageManipulation.Effects,PixelateEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\PixelateEffect.cs,ComputeCellColor,The following statement contains a magic number: var c = ColorBgra.BlendColors4W16IP (colorTopLeft' 16384' colorTopRight' 16384' colorBottomLeft' 16384' colorBottomRight' 16384);
Magic Number,Pinta.ImageManipulation.Effects,PixelateEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\PixelateEffect.cs,ComputeCellColor,The following statement contains a magic number: var c = ColorBgra.BlendColors4W16IP (colorTopLeft' 16384' colorTopRight' 16384' colorBottomLeft' 16384' colorBottomRight' 16384);
Magic Number,Pinta.ImageManipulation.Effects,PixelateEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\PixelateEffect.cs,ComputeCellColor,The following statement contains a magic number: var c = ColorBgra.BlendColors4W16IP (colorTopLeft' 16384' colorTopRight' 16384' colorBottomLeft' 16384' colorBottomRight' 16384);
Magic Number,Pinta.ImageManipulation.Effects,PixelateEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\PixelateEffect.cs,ComputeCellColor,The following statement contains a magic number: var c = ColorBgra.BlendColors4W16IP (colorTopLeft' 16384' colorTopRight' 16384' colorBottomLeft' 16384' colorBottomRight' 16384);
Magic Number,Pinta.ImageManipulation.Effects,PencilSketchEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\PencilSketchEffect.cs,PencilSketchEffect,The following statement contains a magic number: if (pencilSize < 1 || pencilSize > 20)  				throw new ArgumentOutOfRangeException ("pencilSize");
Magic Number,Pinta.ImageManipulation.Effects,PencilSketchEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\PencilSketchEffect.cs,PencilSketchEffect,The following statement contains a magic number: if (colorRange < -20 || colorRange > 20)  				throw new ArgumentOutOfRangeException ("colorRange");
Magic Number,Pinta.ImageManipulation.Effects,PencilSketchEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\PencilSketchEffect.cs,PencilSketchEffect,The following statement contains a magic number: if (colorRange < -20 || colorRange > 20)  				throw new ArgumentOutOfRangeException ("colorRange");
Magic Number,Pinta.ImageManipulation.Effects,OutlineEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\OutlineEffect.cs,OutlineEffect,The following statement contains a magic number: if (thickness < 1 || thickness > 200)  				throw new ArgumentOutOfRangeException ("thickness");
Magic Number,Pinta.ImageManipulation.Effects,OutlineEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\OutlineEffect.cs,OutlineEffect,The following statement contains a magic number: if (intensity < 0 || intensity > 100)  				throw new ArgumentOutOfRangeException ("intensity");
Magic Number,Pinta.ImageManipulation.Effects,OutlineEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\OutlineEffect.cs,Apply,The following statement contains a magic number: int minCount1 = area * (100 - this.intensity) / 200;
Magic Number,Pinta.ImageManipulation.Effects,OutlineEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\OutlineEffect.cs,Apply,The following statement contains a magic number: int minCount1 = area * (100 - this.intensity) / 200;
Magic Number,Pinta.ImageManipulation.Effects,OutlineEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\OutlineEffect.cs,Apply,The following statement contains a magic number: int minCount2 = area * (100 + this.intensity) / 200;
Magic Number,Pinta.ImageManipulation.Effects,OutlineEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\OutlineEffect.cs,Apply,The following statement contains a magic number: int minCount2 = area * (100 + this.intensity) / 200;
Magic Number,Pinta.ImageManipulation.Effects,OutlineEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\OutlineEffect.cs,Apply,The following statement contains a magic number: while (b1 < 255 && hb[b1] == 0)  				++b1;
Magic Number,Pinta.ImageManipulation.Effects,OutlineEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\OutlineEffect.cs,Apply,The following statement contains a magic number: while (b1 < 255 && bCount < minCount1) {  				bCount += hb[b1];  				++b1;  			}
Magic Number,Pinta.ImageManipulation.Effects,OutlineEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\OutlineEffect.cs,Apply,The following statement contains a magic number: while (b2 < 255 && bCount < minCount2) {  				bCount += hb[b2];  				++b2;  			}
Magic Number,Pinta.ImageManipulation.Effects,OutlineEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\OutlineEffect.cs,Apply,The following statement contains a magic number: while (g1 < 255 && hg[g1] == 0)  				++g1;
Magic Number,Pinta.ImageManipulation.Effects,OutlineEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\OutlineEffect.cs,Apply,The following statement contains a magic number: while (g1 < 255 && gCount < minCount1) {  				gCount += hg[g1];  				++g1;  			}
Magic Number,Pinta.ImageManipulation.Effects,OutlineEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\OutlineEffect.cs,Apply,The following statement contains a magic number: while (g2 < 255 && gCount < minCount2) {  				gCount += hg[g2];  				++g2;  			}
Magic Number,Pinta.ImageManipulation.Effects,OutlineEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\OutlineEffect.cs,Apply,The following statement contains a magic number: while (r1 < 255 && hr[r1] == 0)  				++r1;
Magic Number,Pinta.ImageManipulation.Effects,OutlineEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\OutlineEffect.cs,Apply,The following statement contains a magic number: while (r1 < 255 && rCount < minCount1) {  				rCount += hr[r1];  				++r1;  			}
Magic Number,Pinta.ImageManipulation.Effects,OutlineEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\OutlineEffect.cs,Apply,The following statement contains a magic number: while (r2 < 255 && rCount < minCount2) {  				rCount += hr[r2];  				++r2;  			}
Magic Number,Pinta.ImageManipulation.Effects,OutlineEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\OutlineEffect.cs,Apply,The following statement contains a magic number: while (a1 < 255 && hb[a1] == 0)  				++a1;
Magic Number,Pinta.ImageManipulation.Effects,OutlineEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\OutlineEffect.cs,Apply,The following statement contains a magic number: while (a1 < 255 && aCount < minCount1) {  				aCount += ha[a1];  				++a1;  			}
Magic Number,Pinta.ImageManipulation.Effects,OutlineEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\OutlineEffect.cs,Apply,The following statement contains a magic number: while (a2 < 255 && aCount < minCount2) {  				aCount += ha[a2];  				++a2;  			}
Magic Number,Pinta.ImageManipulation.Effects,OutlineEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\OutlineEffect.cs,Apply,The following statement contains a magic number: return ColorBgra.FromBgra (  				(byte)(255 - (b2 - b1))'  				(byte)(255 - (g2 - g1))'  				(byte)(255 - (r2 - r1))'  				(byte)(a2));
Magic Number,Pinta.ImageManipulation.Effects,OutlineEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\OutlineEffect.cs,Apply,The following statement contains a magic number: return ColorBgra.FromBgra (  				(byte)(255 - (b2 - b1))'  				(byte)(255 - (g2 - g1))'  				(byte)(255 - (r2 - r1))'  				(byte)(a2));
Magic Number,Pinta.ImageManipulation.Effects,OutlineEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\OutlineEffect.cs,Apply,The following statement contains a magic number: return ColorBgra.FromBgra (  				(byte)(255 - (b2 - b1))'  				(byte)(255 - (g2 - g1))'  				(byte)(255 - (r2 - r1))'  				(byte)(a2));
Magic Number,Pinta.ImageManipulation.Effects,OilPaintingEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\OilPaintingEffect.cs,OilPaintingEffect,The following statement contains a magic number: if (brushSize < 1 || brushSize > 8)  				throw new ArgumentOutOfRangeException ("brushSize");
Magic Number,Pinta.ImageManipulation.Effects,OilPaintingEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\OilPaintingEffect.cs,OilPaintingEffect,The following statement contains a magic number: if (coarseness < 3 || coarseness > 255)  				throw new ArgumentOutOfRangeException ("coarseness");
Magic Number,Pinta.ImageManipulation.Effects,OilPaintingEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\OilPaintingEffect.cs,OilPaintingEffect,The following statement contains a magic number: if (coarseness < 3 || coarseness > 255)  				throw new ArgumentOutOfRangeException ("coarseness");
Magic Number,Pinta.ImageManipulation.Effects,OilPaintingEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\OilPaintingEffect.cs,RenderLine,The following statement contains a magic number: int localStoreSize = arrayLens * 5 * sizeof (int);
Magic Number,Pinta.ImageManipulation.Effects,OilPaintingEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\OilPaintingEffect.cs,SetToZero,The following statement contains a magic number: for (ulong i = 0; i < length / 4; i++) {  				*ptr = 0;  				ptr++;  			}
Magic Number,Pinta.ImageManipulation.Effects,MotionBlurEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\MotionBlurEffect.cs,MotionBlurEffect,The following statement contains a magic number: if (distance < 1 || distance > 200)  				throw new ArgumentOutOfRangeException ("distance");
Magic Number,Pinta.ImageManipulation.Effects,MotionBlurEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\MotionBlurEffect.cs,RenderLine,The following statement contains a magic number: double theta = ((double)(angle + 180) * 2 * Math.PI) / 360.0;
Magic Number,Pinta.ImageManipulation.Effects,MotionBlurEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\MotionBlurEffect.cs,RenderLine,The following statement contains a magic number: double theta = ((double)(angle + 180) * 2 * Math.PI) / 360.0;
Magic Number,Pinta.ImageManipulation.Effects,MotionBlurEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\MotionBlurEffect.cs,RenderLine,The following statement contains a magic number: double theta = ((double)(angle + 180) * 2 * Math.PI) / 360.0;
Magic Number,Pinta.ImageManipulation.Effects,MotionBlurEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\MotionBlurEffect.cs,RenderLine,The following statement contains a magic number: PointD[] points = new PointD[((1 + distance) * 3) / 2];
Magic Number,Pinta.ImageManipulation.Effects,MotionBlurEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\MotionBlurEffect.cs,RenderLine,The following statement contains a magic number: PointD[] points = new PointD[((1 + distance) * 3) / 2];
Magic Number,Pinta.ImageManipulation.Effects,MedianEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\MedianEffect.cs,MedianEffect,The following statement contains a magic number: if (radius < 1 || radius > 200)  				throw new ArgumentOutOfRangeException ("radius");
Magic Number,Pinta.ImageManipulation.Effects,MedianEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\MedianEffect.cs,MedianEffect,The following statement contains a magic number: if (percentile < 0 || percentile > 100)  				throw new ArgumentOutOfRangeException ("percentile");
Magic Number,Pinta.ImageManipulation.Effects,MandelbrotFractalEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\MandelbrotFractalEffect.cs,MandelbrotFractalEffect,The following statement contains a magic number: if (factor < 1 || factor > 10)  				throw new ArgumentOutOfRangeException ("factor");
Magic Number,Pinta.ImageManipulation.Effects,MandelbrotFractalEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\MandelbrotFractalEffect.cs,MandelbrotFractalEffect,The following statement contains a magic number: if (quality < 1 || quality > 5)  				throw new ArgumentOutOfRangeException ("quality");
Magic Number,Pinta.ImageManipulation.Effects,MandelbrotFractalEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\MandelbrotFractalEffect.cs,MandelbrotFractalEffect,The following statement contains a magic number: if (zoom < 0 || zoom > 100)  				throw new ArgumentOutOfRangeException ("zoom");
Magic Number,Pinta.ImageManipulation.Effects,MandelbrotFractalEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\MandelbrotFractalEffect.cs,RenderLine,The following statement contains a magic number: double angleTheta = (angle * 2 * Math.PI) / 360;
Magic Number,Pinta.ImageManipulation.Effects,MandelbrotFractalEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\MandelbrotFractalEffect.cs,RenderLine,The following statement contains a magic number: double angleTheta = (angle * 2 * Math.PI) / 360;
Magic Number,Pinta.ImageManipulation.Effects,MandelbrotFractalEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\MandelbrotFractalEffect.cs,RenderLine,The following statement contains a magic number: for (int y = rect.Top; y <= rect.Bottom; y++) {  				ColorBgra* dstPtr = dst.GetPointAddress (rect.Left' y);    				for (int x = rect.Left; x <= rect.Right; x++) {  					int r = 0;  					int g = 0;  					int b = 0;  					int a = 0;    					for (double i = 0; i < count; i++) {  						double u = (2.0 * x - w + (i * invCount)) * invH;  						double v = (2.0 * y - h + ((i * invQuality) % 1)) * invH;    						double radius = Math.Sqrt ((u * u) + (v * v));  						double radiusP = radius;  						double theta = Math.Atan2 (v' u);  						double thetaP = theta + angleTheta;    						double uP = radiusP * Math.Cos (thetaP);  						double vP = radiusP * Math.Sin (thetaP);    						double m = Mandelbrot ((uP * invZoom) + this.xOffset' (vP * invZoom) + this.yOffset' factor);    						double c = 64 + factor * m;    						r += Utility.ClampToByte (c - 768);  						g += Utility.ClampToByte (c - 512);  						b += Utility.ClampToByte (c - 256);  						a += Utility.ClampToByte (c - 0);  					}    					*dstPtr = ColorBgra.FromBgra (Utility.ClampToByte (b / count)' Utility.ClampToByte (g / count)' Utility.ClampToByte (r / count)' Utility.ClampToByte (a / count));    					++dstPtr;  				}  			}
Magic Number,Pinta.ImageManipulation.Effects,MandelbrotFractalEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\MandelbrotFractalEffect.cs,RenderLine,The following statement contains a magic number: for (int y = rect.Top; y <= rect.Bottom; y++) {  				ColorBgra* dstPtr = dst.GetPointAddress (rect.Left' y);    				for (int x = rect.Left; x <= rect.Right; x++) {  					int r = 0;  					int g = 0;  					int b = 0;  					int a = 0;    					for (double i = 0; i < count; i++) {  						double u = (2.0 * x - w + (i * invCount)) * invH;  						double v = (2.0 * y - h + ((i * invQuality) % 1)) * invH;    						double radius = Math.Sqrt ((u * u) + (v * v));  						double radiusP = radius;  						double theta = Math.Atan2 (v' u);  						double thetaP = theta + angleTheta;    						double uP = radiusP * Math.Cos (thetaP);  						double vP = radiusP * Math.Sin (thetaP);    						double m = Mandelbrot ((uP * invZoom) + this.xOffset' (vP * invZoom) + this.yOffset' factor);    						double c = 64 + factor * m;    						r += Utility.ClampToByte (c - 768);  						g += Utility.ClampToByte (c - 512);  						b += Utility.ClampToByte (c - 256);  						a += Utility.ClampToByte (c - 0);  					}    					*dstPtr = ColorBgra.FromBgra (Utility.ClampToByte (b / count)' Utility.ClampToByte (g / count)' Utility.ClampToByte (r / count)' Utility.ClampToByte (a / count));    					++dstPtr;  				}  			}
Magic Number,Pinta.ImageManipulation.Effects,MandelbrotFractalEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\MandelbrotFractalEffect.cs,RenderLine,The following statement contains a magic number: for (int y = rect.Top; y <= rect.Bottom; y++) {  				ColorBgra* dstPtr = dst.GetPointAddress (rect.Left' y);    				for (int x = rect.Left; x <= rect.Right; x++) {  					int r = 0;  					int g = 0;  					int b = 0;  					int a = 0;    					for (double i = 0; i < count; i++) {  						double u = (2.0 * x - w + (i * invCount)) * invH;  						double v = (2.0 * y - h + ((i * invQuality) % 1)) * invH;    						double radius = Math.Sqrt ((u * u) + (v * v));  						double radiusP = radius;  						double theta = Math.Atan2 (v' u);  						double thetaP = theta + angleTheta;    						double uP = radiusP * Math.Cos (thetaP);  						double vP = radiusP * Math.Sin (thetaP);    						double m = Mandelbrot ((uP * invZoom) + this.xOffset' (vP * invZoom) + this.yOffset' factor);    						double c = 64 + factor * m;    						r += Utility.ClampToByte (c - 768);  						g += Utility.ClampToByte (c - 512);  						b += Utility.ClampToByte (c - 256);  						a += Utility.ClampToByte (c - 0);  					}    					*dstPtr = ColorBgra.FromBgra (Utility.ClampToByte (b / count)' Utility.ClampToByte (g / count)' Utility.ClampToByte (r / count)' Utility.ClampToByte (a / count));    					++dstPtr;  				}  			}
Magic Number,Pinta.ImageManipulation.Effects,MandelbrotFractalEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\MandelbrotFractalEffect.cs,RenderLine,The following statement contains a magic number: for (int y = rect.Top; y <= rect.Bottom; y++) {  				ColorBgra* dstPtr = dst.GetPointAddress (rect.Left' y);    				for (int x = rect.Left; x <= rect.Right; x++) {  					int r = 0;  					int g = 0;  					int b = 0;  					int a = 0;    					for (double i = 0; i < count; i++) {  						double u = (2.0 * x - w + (i * invCount)) * invH;  						double v = (2.0 * y - h + ((i * invQuality) % 1)) * invH;    						double radius = Math.Sqrt ((u * u) + (v * v));  						double radiusP = radius;  						double theta = Math.Atan2 (v' u);  						double thetaP = theta + angleTheta;    						double uP = radiusP * Math.Cos (thetaP);  						double vP = radiusP * Math.Sin (thetaP);    						double m = Mandelbrot ((uP * invZoom) + this.xOffset' (vP * invZoom) + this.yOffset' factor);    						double c = 64 + factor * m;    						r += Utility.ClampToByte (c - 768);  						g += Utility.ClampToByte (c - 512);  						b += Utility.ClampToByte (c - 256);  						a += Utility.ClampToByte (c - 0);  					}    					*dstPtr = ColorBgra.FromBgra (Utility.ClampToByte (b / count)' Utility.ClampToByte (g / count)' Utility.ClampToByte (r / count)' Utility.ClampToByte (a / count));    					++dstPtr;  				}  			}
Magic Number,Pinta.ImageManipulation.Effects,MandelbrotFractalEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\MandelbrotFractalEffect.cs,RenderLine,The following statement contains a magic number: for (int y = rect.Top; y <= rect.Bottom; y++) {  				ColorBgra* dstPtr = dst.GetPointAddress (rect.Left' y);    				for (int x = rect.Left; x <= rect.Right; x++) {  					int r = 0;  					int g = 0;  					int b = 0;  					int a = 0;    					for (double i = 0; i < count; i++) {  						double u = (2.0 * x - w + (i * invCount)) * invH;  						double v = (2.0 * y - h + ((i * invQuality) % 1)) * invH;    						double radius = Math.Sqrt ((u * u) + (v * v));  						double radiusP = radius;  						double theta = Math.Atan2 (v' u);  						double thetaP = theta + angleTheta;    						double uP = radiusP * Math.Cos (thetaP);  						double vP = radiusP * Math.Sin (thetaP);    						double m = Mandelbrot ((uP * invZoom) + this.xOffset' (vP * invZoom) + this.yOffset' factor);    						double c = 64 + factor * m;    						r += Utility.ClampToByte (c - 768);  						g += Utility.ClampToByte (c - 512);  						b += Utility.ClampToByte (c - 256);  						a += Utility.ClampToByte (c - 0);  					}    					*dstPtr = ColorBgra.FromBgra (Utility.ClampToByte (b / count)' Utility.ClampToByte (g / count)' Utility.ClampToByte (r / count)' Utility.ClampToByte (a / count));    					++dstPtr;  				}  			}
Magic Number,Pinta.ImageManipulation.Effects,MandelbrotFractalEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\MandelbrotFractalEffect.cs,RenderLine,The following statement contains a magic number: for (int y = rect.Top; y <= rect.Bottom; y++) {  				ColorBgra* dstPtr = dst.GetPointAddress (rect.Left' y);    				for (int x = rect.Left; x <= rect.Right; x++) {  					int r = 0;  					int g = 0;  					int b = 0;  					int a = 0;    					for (double i = 0; i < count; i++) {  						double u = (2.0 * x - w + (i * invCount)) * invH;  						double v = (2.0 * y - h + ((i * invQuality) % 1)) * invH;    						double radius = Math.Sqrt ((u * u) + (v * v));  						double radiusP = radius;  						double theta = Math.Atan2 (v' u);  						double thetaP = theta + angleTheta;    						double uP = radiusP * Math.Cos (thetaP);  						double vP = radiusP * Math.Sin (thetaP);    						double m = Mandelbrot ((uP * invZoom) + this.xOffset' (vP * invZoom) + this.yOffset' factor);    						double c = 64 + factor * m;    						r += Utility.ClampToByte (c - 768);  						g += Utility.ClampToByte (c - 512);  						b += Utility.ClampToByte (c - 256);  						a += Utility.ClampToByte (c - 0);  					}    					*dstPtr = ColorBgra.FromBgra (Utility.ClampToByte (b / count)' Utility.ClampToByte (g / count)' Utility.ClampToByte (r / count)' Utility.ClampToByte (a / count));    					++dstPtr;  				}  			}
Magic Number,Pinta.ImageManipulation.Effects,MandelbrotFractalEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\MandelbrotFractalEffect.cs,RenderLine,The following statement contains a magic number: if (invert_colors) {  				for (int y = rect.Top; y <= rect.Bottom; y++) {  					ColorBgra* dstPtr = dst.GetPointAddress (rect.Left' y);    					for (int x = rect.Left; x <= rect.Right; ++x) {  						ColorBgra c = *dstPtr;    						c.B = (byte)(255 - c.B);  						c.G = (byte)(255 - c.G);  						c.R = (byte)(255 - c.R);    						*dstPtr = c;  						++dstPtr;  					}  				}  			}
Magic Number,Pinta.ImageManipulation.Effects,MandelbrotFractalEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\MandelbrotFractalEffect.cs,RenderLine,The following statement contains a magic number: if (invert_colors) {  				for (int y = rect.Top; y <= rect.Bottom; y++) {  					ColorBgra* dstPtr = dst.GetPointAddress (rect.Left' y);    					for (int x = rect.Left; x <= rect.Right; ++x) {  						ColorBgra c = *dstPtr;    						c.B = (byte)(255 - c.B);  						c.G = (byte)(255 - c.G);  						c.R = (byte)(255 - c.R);    						*dstPtr = c;  						++dstPtr;  					}  				}  			}
Magic Number,Pinta.ImageManipulation.Effects,MandelbrotFractalEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\MandelbrotFractalEffect.cs,RenderLine,The following statement contains a magic number: if (invert_colors) {  				for (int y = rect.Top; y <= rect.Bottom; y++) {  					ColorBgra* dstPtr = dst.GetPointAddress (rect.Left' y);    					for (int x = rect.Left; x <= rect.Right; ++x) {  						ColorBgra c = *dstPtr;    						c.B = (byte)(255 - c.B);  						c.G = (byte)(255 - c.G);  						c.R = (byte)(255 - c.R);    						*dstPtr = c;  						++dstPtr;  					}  				}  			}
Magic Number,Pinta.ImageManipulation.Effects,MandelbrotFractalEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\MandelbrotFractalEffect.cs,Mandelbrot,The following statement contains a magic number: while ((c * factor) < 1024 && ((x * x) + (y * y)) < max) {  				double t = x;    				x = x * x - y * y + r;  				y = 2 * t * y + i;    				++c;  			}
Magic Number,Pinta.ImageManipulation.Effects,MandelbrotFractalEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\MandelbrotFractalEffect.cs,Mandelbrot,The following statement contains a magic number: while ((c * factor) < 1024 && ((x * x) + (y * y)) < max) {  				double t = x;    				x = x * x - y * y + r;  				y = 2 * t * y + i;    				++c;  			}
Magic Number,Pinta.ImageManipulation.Effects,JuliaFractalEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\JuliaFractalEffect.cs,JuliaFractalEffect,The following statement contains a magic number: if (factor < 1 || factor > 10)  				throw new ArgumentOutOfRangeException ("factor");
Magic Number,Pinta.ImageManipulation.Effects,JuliaFractalEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\JuliaFractalEffect.cs,JuliaFractalEffect,The following statement contains a magic number: if (quality < 1 || quality > 5)  				throw new ArgumentOutOfRangeException ("quality");
Magic Number,Pinta.ImageManipulation.Effects,JuliaFractalEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\JuliaFractalEffect.cs,JuliaFractalEffect,The following statement contains a magic number: if (zoom < 0 || zoom > 50)  				throw new ArgumentOutOfRangeException ("zoom");
Magic Number,Pinta.ImageManipulation.Effects,JuliaFractalEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\JuliaFractalEffect.cs,RenderLine,The following statement contains a magic number: const double jr = 0.3125;
Magic Number,Pinta.ImageManipulation.Effects,JuliaFractalEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\JuliaFractalEffect.cs,RenderLine,The following statement contains a magic number: const double ji = 0.03;
Magic Number,Pinta.ImageManipulation.Effects,JuliaFractalEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\JuliaFractalEffect.cs,RenderLine,The following statement contains a magic number: double angleTheta = (angle * Math.PI * 2) / 360.0;
Magic Number,Pinta.ImageManipulation.Effects,JuliaFractalEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\JuliaFractalEffect.cs,RenderLine,The following statement contains a magic number: double angleTheta = (angle * Math.PI * 2) / 360.0;
Magic Number,Pinta.ImageManipulation.Effects,JuliaFractalEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\JuliaFractalEffect.cs,RenderLine,The following statement contains a magic number: for (int y = rect.Top; y <= rect.Bottom; y++) {  				ColorBgra* dstPtr = dst.GetPointAddress (rect.Left' y);    				for (int x = rect.Left; x <= rect.Right; x++) {  					int r = 0;  					int g = 0;  					int b = 0;  					int a = 0;    					for (double i = 0; i < count; i++) {  						double u = (2.0 * x - w + (i * invCount)) * invH;  						double v = (2.0 * y - h + ((i * invQuality) % 1)) * invH;    						double radius = Math.Sqrt ((u * u) + (v * v));  						double radiusP = radius;  						double theta = Math.Atan2 (v' u);  						double thetaP = theta + angleTheta;    						double uP = radiusP * Math.Cos (thetaP);  						double vP = radiusP * Math.Sin (thetaP);    						double jX = (uP - vP * aspect) * invZoom;  						double jY = (vP + uP * aspect) * invZoom;    						double j = Julia (jX' jY' jr' ji);    						double c = factor * j;    						b += Utility.ClampToByte (c - 768);  						g += Utility.ClampToByte (c - 512);  						r += Utility.ClampToByte (c - 256);  						a += Utility.ClampToByte (c - 0);  					}    					*dstPtr = ColorBgra.FromBgra (Utility.ClampToByte (b / count)' Utility.ClampToByte (g / count)' Utility.ClampToByte (r / count)' Utility.ClampToByte (a / count));    					++dstPtr;  				}  			}
Magic Number,Pinta.ImageManipulation.Effects,JuliaFractalEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\JuliaFractalEffect.cs,RenderLine,The following statement contains a magic number: for (int y = rect.Top; y <= rect.Bottom; y++) {  				ColorBgra* dstPtr = dst.GetPointAddress (rect.Left' y);    				for (int x = rect.Left; x <= rect.Right; x++) {  					int r = 0;  					int g = 0;  					int b = 0;  					int a = 0;    					for (double i = 0; i < count; i++) {  						double u = (2.0 * x - w + (i * invCount)) * invH;  						double v = (2.0 * y - h + ((i * invQuality) % 1)) * invH;    						double radius = Math.Sqrt ((u * u) + (v * v));  						double radiusP = radius;  						double theta = Math.Atan2 (v' u);  						double thetaP = theta + angleTheta;    						double uP = radiusP * Math.Cos (thetaP);  						double vP = radiusP * Math.Sin (thetaP);    						double jX = (uP - vP * aspect) * invZoom;  						double jY = (vP + uP * aspect) * invZoom;    						double j = Julia (jX' jY' jr' ji);    						double c = factor * j;    						b += Utility.ClampToByte (c - 768);  						g += Utility.ClampToByte (c - 512);  						r += Utility.ClampToByte (c - 256);  						a += Utility.ClampToByte (c - 0);  					}    					*dstPtr = ColorBgra.FromBgra (Utility.ClampToByte (b / count)' Utility.ClampToByte (g / count)' Utility.ClampToByte (r / count)' Utility.ClampToByte (a / count));    					++dstPtr;  				}  			}
Magic Number,Pinta.ImageManipulation.Effects,JuliaFractalEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\JuliaFractalEffect.cs,RenderLine,The following statement contains a magic number: for (int y = rect.Top; y <= rect.Bottom; y++) {  				ColorBgra* dstPtr = dst.GetPointAddress (rect.Left' y);    				for (int x = rect.Left; x <= rect.Right; x++) {  					int r = 0;  					int g = 0;  					int b = 0;  					int a = 0;    					for (double i = 0; i < count; i++) {  						double u = (2.0 * x - w + (i * invCount)) * invH;  						double v = (2.0 * y - h + ((i * invQuality) % 1)) * invH;    						double radius = Math.Sqrt ((u * u) + (v * v));  						double radiusP = radius;  						double theta = Math.Atan2 (v' u);  						double thetaP = theta + angleTheta;    						double uP = radiusP * Math.Cos (thetaP);  						double vP = radiusP * Math.Sin (thetaP);    						double jX = (uP - vP * aspect) * invZoom;  						double jY = (vP + uP * aspect) * invZoom;    						double j = Julia (jX' jY' jr' ji);    						double c = factor * j;    						b += Utility.ClampToByte (c - 768);  						g += Utility.ClampToByte (c - 512);  						r += Utility.ClampToByte (c - 256);  						a += Utility.ClampToByte (c - 0);  					}    					*dstPtr = ColorBgra.FromBgra (Utility.ClampToByte (b / count)' Utility.ClampToByte (g / count)' Utility.ClampToByte (r / count)' Utility.ClampToByte (a / count));    					++dstPtr;  				}  			}
Magic Number,Pinta.ImageManipulation.Effects,JuliaFractalEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\JuliaFractalEffect.cs,RenderLine,The following statement contains a magic number: for (int y = rect.Top; y <= rect.Bottom; y++) {  				ColorBgra* dstPtr = dst.GetPointAddress (rect.Left' y);    				for (int x = rect.Left; x <= rect.Right; x++) {  					int r = 0;  					int g = 0;  					int b = 0;  					int a = 0;    					for (double i = 0; i < count; i++) {  						double u = (2.0 * x - w + (i * invCount)) * invH;  						double v = (2.0 * y - h + ((i * invQuality) % 1)) * invH;    						double radius = Math.Sqrt ((u * u) + (v * v));  						double radiusP = radius;  						double theta = Math.Atan2 (v' u);  						double thetaP = theta + angleTheta;    						double uP = radiusP * Math.Cos (thetaP);  						double vP = radiusP * Math.Sin (thetaP);    						double jX = (uP - vP * aspect) * invZoom;  						double jY = (vP + uP * aspect) * invZoom;    						double j = Julia (jX' jY' jr' ji);    						double c = factor * j;    						b += Utility.ClampToByte (c - 768);  						g += Utility.ClampToByte (c - 512);  						r += Utility.ClampToByte (c - 256);  						a += Utility.ClampToByte (c - 0);  					}    					*dstPtr = ColorBgra.FromBgra (Utility.ClampToByte (b / count)' Utility.ClampToByte (g / count)' Utility.ClampToByte (r / count)' Utility.ClampToByte (a / count));    					++dstPtr;  				}  			}
Magic Number,Pinta.ImageManipulation.Effects,JuliaFractalEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\JuliaFractalEffect.cs,RenderLine,The following statement contains a magic number: for (int y = rect.Top; y <= rect.Bottom; y++) {  				ColorBgra* dstPtr = dst.GetPointAddress (rect.Left' y);    				for (int x = rect.Left; x <= rect.Right; x++) {  					int r = 0;  					int g = 0;  					int b = 0;  					int a = 0;    					for (double i = 0; i < count; i++) {  						double u = (2.0 * x - w + (i * invCount)) * invH;  						double v = (2.0 * y - h + ((i * invQuality) % 1)) * invH;    						double radius = Math.Sqrt ((u * u) + (v * v));  						double radiusP = radius;  						double theta = Math.Atan2 (v' u);  						double thetaP = theta + angleTheta;    						double uP = radiusP * Math.Cos (thetaP);  						double vP = radiusP * Math.Sin (thetaP);    						double jX = (uP - vP * aspect) * invZoom;  						double jY = (vP + uP * aspect) * invZoom;    						double j = Julia (jX' jY' jr' ji);    						double c = factor * j;    						b += Utility.ClampToByte (c - 768);  						g += Utility.ClampToByte (c - 512);  						r += Utility.ClampToByte (c - 256);  						a += Utility.ClampToByte (c - 0);  					}    					*dstPtr = ColorBgra.FromBgra (Utility.ClampToByte (b / count)' Utility.ClampToByte (g / count)' Utility.ClampToByte (r / count)' Utility.ClampToByte (a / count));    					++dstPtr;  				}  			}
Magic Number,Pinta.ImageManipulation.Effects,JuliaFractalEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\JuliaFractalEffect.cs,Julia,The following statement contains a magic number: while (c < 256 && x * x + y * y < 10000) {  				double t = x;  				x = x * x - y * y + r;  				y = 2 * t * y + i;  				++c;  			}
Magic Number,Pinta.ImageManipulation.Effects,JuliaFractalEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\JuliaFractalEffect.cs,Julia,The following statement contains a magic number: while (c < 256 && x * x + y * y < 10000) {  				double t = x;  				x = x * x - y * y + r;  				y = 2 * t * y + i;  				++c;  			}
Magic Number,Pinta.ImageManipulation.Effects,JuliaFractalEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\JuliaFractalEffect.cs,Julia,The following statement contains a magic number: while (c < 256 && x * x + y * y < 10000) {  				double t = x;  				x = x * x - y * y + r;  				y = 2 * t * y + i;  				++c;  			}
Magic Number,Pinta.ImageManipulation.Effects,JuliaFractalEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\JuliaFractalEffect.cs,Julia,The following statement contains a magic number: c -= 2 - 2 * log2_10000 / Math.Log (x * x + y * y);
Magic Number,Pinta.ImageManipulation.Effects,JuliaFractalEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\JuliaFractalEffect.cs,Julia,The following statement contains a magic number: c -= 2 - 2 * log2_10000 / Math.Log (x * x + y * y);
Magic Number,Pinta.ImageManipulation.Effects,GlowEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\GlowEffect.cs,GlowEffect,The following statement contains a magic number: if (radius < 1 || radius > 20)  				throw new ArgumentOutOfRangeException ("radius");
Magic Number,Pinta.ImageManipulation.Effects,GlowEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\GlowEffect.cs,GlowEffect,The following statement contains a magic number: if (brightness < -100 || brightness > 100)  				throw new ArgumentOutOfRangeException ("brightness");
Magic Number,Pinta.ImageManipulation.Effects,GlowEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\GlowEffect.cs,GlowEffect,The following statement contains a magic number: if (brightness < -100 || brightness > 100)  				throw new ArgumentOutOfRangeException ("brightness");
Magic Number,Pinta.ImageManipulation.Effects,GlowEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\GlowEffect.cs,GlowEffect,The following statement contains a magic number: if (contrast < -100 || contrast > 100)  				throw new ArgumentOutOfRangeException ("contrast");
Magic Number,Pinta.ImageManipulation.Effects,GlowEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\GlowEffect.cs,GlowEffect,The following statement contains a magic number: if (contrast < -100 || contrast > 100)  				throw new ArgumentOutOfRangeException ("contrast");
Magic Number,Pinta.ImageManipulation.Effects,FrostedGlassEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\FrostedGlassEffect.cs,FrostedGlassEffect,The following statement contains a magic number: if (amount < 1 || amount > 10)  				throw new ArgumentOutOfRangeException ("amount");
Magic Number,Pinta.ImageManipulation.Effects,FrostedGlassEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\FrostedGlassEffect.cs,RenderLine,The following statement contains a magic number: int* intensityCount = stackalloc int[256];
Magic Number,Pinta.ImageManipulation.Effects,FrostedGlassEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\FrostedGlassEffect.cs,RenderLine,The following statement contains a magic number: uint* avgRed = stackalloc uint[256];
Magic Number,Pinta.ImageManipulation.Effects,FrostedGlassEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\FrostedGlassEffect.cs,RenderLine,The following statement contains a magic number: uint* avgGreen = stackalloc uint[256];
Magic Number,Pinta.ImageManipulation.Effects,FrostedGlassEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\FrostedGlassEffect.cs,RenderLine,The following statement contains a magic number: uint* avgBlue = stackalloc uint[256];
Magic Number,Pinta.ImageManipulation.Effects,FrostedGlassEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\FrostedGlassEffect.cs,RenderLine,The following statement contains a magic number: uint* avgAlpha = stackalloc uint[256];
Magic Number,Pinta.ImageManipulation.Effects,FrostedGlassEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\FrostedGlassEffect.cs,RenderLine,The following statement contains a magic number: byte* intensityChoices = stackalloc byte[(1 + (r * 2)) * (1 + (r * 2))];
Magic Number,Pinta.ImageManipulation.Effects,FrostedGlassEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\FrostedGlassEffect.cs,RenderLine,The following statement contains a magic number: byte* intensityChoices = stackalloc byte[(1 + (r * 2)) * (1 + (r * 2))];
Magic Number,Pinta.ImageManipulation.Effects,FrostedGlassEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\FrostedGlassEffect.cs,RenderLine,The following statement contains a magic number: for (int y = rectTop; y <= rectBottom; ++y) {  				ColorBgra* dstPtr = dst.GetPointAddress (rect.Left' y);    				int top = y - r;  				int bottom = y + r + 1;    				if (top < 0) {  					top = 0;  				}    				if (bottom > height) {  					bottom = height;  				}    				for (int x = rectLeft; x <= rectRight; ++x) {  					int intensityChoicesIndex = 0;    					for (int i = 0; i < 256; ++i) {  						intensityCount[i] = 0;  						avgRed[i] = 0;  						avgGreen[i] = 0;  						avgBlue[i] = 0;  						avgAlpha[i] = 0;  					}    					int left = x - r;  					int right = x + r + 1;    					if (left < 0) {  						left = 0;  					}    					if (right > width) {  						right = width;  					}    					for (int j = top; j < bottom; ++j) {  						if (j < 0 || j >= height) {  							continue;  						}    						ColorBgra* srcPtr = src.GetPointAddress (left' j);    						for (int i = left; i < right; ++i) {  							byte intensity = srcPtr->GetIntensityByte ();    							intensityChoices[intensityChoicesIndex] = intensity;  							++intensityChoicesIndex;    							++intensityCount[intensity];    							avgRed[intensity] += srcPtr->R;  							avgGreen[intensity] += srcPtr->G;  							avgBlue[intensity] += srcPtr->B;  							avgAlpha[intensity] += srcPtr->A;    							++srcPtr;  						}  					}    					int randNum;    					lock (localRandom) {  						randNum = localRandom.Next (intensityChoicesIndex);  					}    					byte chosenIntensity = intensityChoices[randNum];    					byte R = (byte)(avgRed[chosenIntensity] / intensityCount[chosenIntensity]);  					byte G = (byte)(avgGreen[chosenIntensity] / intensityCount[chosenIntensity]);  					byte B = (byte)(avgBlue[chosenIntensity] / intensityCount[chosenIntensity]);  					byte A = (byte)(avgAlpha[chosenIntensity] / intensityCount[chosenIntensity]);    					*dstPtr = ColorBgra.FromBgra (B' G' R' A);  					++dstPtr;    					// prepare the array for the next loop iteration  					for (int i = 0; i < intensityChoicesIndex; ++i) {  						intensityChoices[i] = 0;  					}  				}  			}
Magic Number,Pinta.ImageManipulation.Effects,FragmentEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\FragmentEffect.cs,FragmentEffect,The following statement contains a magic number: if (fragments < 2 || fragments > 50)  				throw new ArgumentOutOfRangeException ("fragments");
Magic Number,Pinta.ImageManipulation.Effects,FragmentEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\FragmentEffect.cs,FragmentEffect,The following statement contains a magic number: if (fragments < 2 || fragments > 50)  				throw new ArgumentOutOfRangeException ("fragments");
Magic Number,Pinta.ImageManipulation.Effects,FragmentEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\FragmentEffect.cs,FragmentEffect,The following statement contains a magic number: if (distance < 0 || distance > 100)  				throw new ArgumentOutOfRangeException ("distance");
Magic Number,Pinta.ImageManipulation.Effects,FragmentEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\FragmentEffect.cs,RecalcPointOffsets,The following statement contains a magic number: double pointStep = 2 * Math.PI / (double)fragments;
Magic Number,Pinta.ImageManipulation.Effects,FragmentEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\FragmentEffect.cs,RecalcPointOffsets,The following statement contains a magic number: double rotationRadians = ((rotationAngle - 90.0) * Math.PI) / 180.0;
Magic Number,Pinta.ImageManipulation.Effects,FragmentEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\FragmentEffect.cs,RecalcPointOffsets,The following statement contains a magic number: double rotationRadians = ((rotationAngle - 90.0) * Math.PI) / 180.0;
Magic Number,Pinta.ImageManipulation.Effects,EmbossEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\EmbossEffect.cs,EmbossEffect,The following statement contains a magic number: if (angle < 0 || angle > 360)  				throw new ArgumentOutOfRangeException ("angle");
Magic Number,Pinta.ImageManipulation.Effects,EmbossEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\EmbossEffect.cs,RenderLine,The following statement contains a magic number: for (int y = rect.Top; y <= rect.Bottom; ++y) {  				int fyStart = 0;  				int fyEnd = 3;    				if (y == 0)  					fyStart = 1;    				if (y == srcHeight - 1)  					fyEnd = 2;    				// loop through each point in the line   				ColorBgra* dstPtr = dst.GetPointAddress (rect.Left' y);    				for (int x = rect.Left; x <= rect.Right; ++x) {  					int fxStart = 0;  					int fxEnd = 3;    					if (x == 0)  						fxStart = 1;    					if (x == srcWidth - 1)  						fxEnd = 2;    					// loop through each weight  					double sum = 0.0;    					for (int fy = fyStart; fy < fyEnd; ++fy) {  						for (int fx = fxStart; fx < fxEnd; ++fx) {  							double weight = weights[fy' fx];  							ColorBgra c = src.GetPoint (x - 1 + fx' y - 1 + fy);  							double intensity = (double)c.GetIntensityByte ();  							sum += weight * intensity;  						}  					}    					int iSum = (int)sum;  					iSum += 128;    					if (iSum > 255)  						iSum = 255;    					if (iSum < 0)  						iSum = 0;    					*dstPtr = ColorBgra.FromBgra ((byte)iSum' (byte)iSum' (byte)iSum' 255);    					++dstPtr;  				}  			}
Magic Number,Pinta.ImageManipulation.Effects,EmbossEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\EmbossEffect.cs,RenderLine,The following statement contains a magic number: for (int y = rect.Top; y <= rect.Bottom; ++y) {  				int fyStart = 0;  				int fyEnd = 3;    				if (y == 0)  					fyStart = 1;    				if (y == srcHeight - 1)  					fyEnd = 2;    				// loop through each point in the line   				ColorBgra* dstPtr = dst.GetPointAddress (rect.Left' y);    				for (int x = rect.Left; x <= rect.Right; ++x) {  					int fxStart = 0;  					int fxEnd = 3;    					if (x == 0)  						fxStart = 1;    					if (x == srcWidth - 1)  						fxEnd = 2;    					// loop through each weight  					double sum = 0.0;    					for (int fy = fyStart; fy < fyEnd; ++fy) {  						for (int fx = fxStart; fx < fxEnd; ++fx) {  							double weight = weights[fy' fx];  							ColorBgra c = src.GetPoint (x - 1 + fx' y - 1 + fy);  							double intensity = (double)c.GetIntensityByte ();  							sum += weight * intensity;  						}  					}    					int iSum = (int)sum;  					iSum += 128;    					if (iSum > 255)  						iSum = 255;    					if (iSum < 0)  						iSum = 0;    					*dstPtr = ColorBgra.FromBgra ((byte)iSum' (byte)iSum' (byte)iSum' 255);    					++dstPtr;  				}  			}
Magic Number,Pinta.ImageManipulation.Effects,EmbossEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\EmbossEffect.cs,RenderLine,The following statement contains a magic number: for (int y = rect.Top; y <= rect.Bottom; ++y) {  				int fyStart = 0;  				int fyEnd = 3;    				if (y == 0)  					fyStart = 1;    				if (y == srcHeight - 1)  					fyEnd = 2;    				// loop through each point in the line   				ColorBgra* dstPtr = dst.GetPointAddress (rect.Left' y);    				for (int x = rect.Left; x <= rect.Right; ++x) {  					int fxStart = 0;  					int fxEnd = 3;    					if (x == 0)  						fxStart = 1;    					if (x == srcWidth - 1)  						fxEnd = 2;    					// loop through each weight  					double sum = 0.0;    					for (int fy = fyStart; fy < fyEnd; ++fy) {  						for (int fx = fxStart; fx < fxEnd; ++fx) {  							double weight = weights[fy' fx];  							ColorBgra c = src.GetPoint (x - 1 + fx' y - 1 + fy);  							double intensity = (double)c.GetIntensityByte ();  							sum += weight * intensity;  						}  					}    					int iSum = (int)sum;  					iSum += 128;    					if (iSum > 255)  						iSum = 255;    					if (iSum < 0)  						iSum = 0;    					*dstPtr = ColorBgra.FromBgra ((byte)iSum' (byte)iSum' (byte)iSum' 255);    					++dstPtr;  				}  			}
Magic Number,Pinta.ImageManipulation.Effects,EmbossEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\EmbossEffect.cs,RenderLine,The following statement contains a magic number: for (int y = rect.Top; y <= rect.Bottom; ++y) {  				int fyStart = 0;  				int fyEnd = 3;    				if (y == 0)  					fyStart = 1;    				if (y == srcHeight - 1)  					fyEnd = 2;    				// loop through each point in the line   				ColorBgra* dstPtr = dst.GetPointAddress (rect.Left' y);    				for (int x = rect.Left; x <= rect.Right; ++x) {  					int fxStart = 0;  					int fxEnd = 3;    					if (x == 0)  						fxStart = 1;    					if (x == srcWidth - 1)  						fxEnd = 2;    					// loop through each weight  					double sum = 0.0;    					for (int fy = fyStart; fy < fyEnd; ++fy) {  						for (int fx = fxStart; fx < fxEnd; ++fx) {  							double weight = weights[fy' fx];  							ColorBgra c = src.GetPoint (x - 1 + fx' y - 1 + fy);  							double intensity = (double)c.GetIntensityByte ();  							sum += weight * intensity;  						}  					}    					int iSum = (int)sum;  					iSum += 128;    					if (iSum > 255)  						iSum = 255;    					if (iSum < 0)  						iSum = 0;    					*dstPtr = ColorBgra.FromBgra ((byte)iSum' (byte)iSum' (byte)iSum' 255);    					++dstPtr;  				}  			}
Magic Number,Pinta.ImageManipulation.Effects,EmbossEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\EmbossEffect.cs,RenderLine,The following statement contains a magic number: for (int y = rect.Top; y <= rect.Bottom; ++y) {  				int fyStart = 0;  				int fyEnd = 3;    				if (y == 0)  					fyStart = 1;    				if (y == srcHeight - 1)  					fyEnd = 2;    				// loop through each point in the line   				ColorBgra* dstPtr = dst.GetPointAddress (rect.Left' y);    				for (int x = rect.Left; x <= rect.Right; ++x) {  					int fxStart = 0;  					int fxEnd = 3;    					if (x == 0)  						fxStart = 1;    					if (x == srcWidth - 1)  						fxEnd = 2;    					// loop through each weight  					double sum = 0.0;    					for (int fy = fyStart; fy < fyEnd; ++fy) {  						for (int fx = fxStart; fx < fxEnd; ++fx) {  							double weight = weights[fy' fx];  							ColorBgra c = src.GetPoint (x - 1 + fx' y - 1 + fy);  							double intensity = (double)c.GetIntensityByte ();  							sum += weight * intensity;  						}  					}    					int iSum = (int)sum;  					iSum += 128;    					if (iSum > 255)  						iSum = 255;    					if (iSum < 0)  						iSum = 0;    					*dstPtr = ColorBgra.FromBgra ((byte)iSum' (byte)iSum' (byte)iSum' 255);    					++dstPtr;  				}  			}
Magic Number,Pinta.ImageManipulation.Effects,EmbossEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\EmbossEffect.cs,RenderLine,The following statement contains a magic number: for (int y = rect.Top; y <= rect.Bottom; ++y) {  				int fyStart = 0;  				int fyEnd = 3;    				if (y == 0)  					fyStart = 1;    				if (y == srcHeight - 1)  					fyEnd = 2;    				// loop through each point in the line   				ColorBgra* dstPtr = dst.GetPointAddress (rect.Left' y);    				for (int x = rect.Left; x <= rect.Right; ++x) {  					int fxStart = 0;  					int fxEnd = 3;    					if (x == 0)  						fxStart = 1;    					if (x == srcWidth - 1)  						fxEnd = 2;    					// loop through each weight  					double sum = 0.0;    					for (int fy = fyStart; fy < fyEnd; ++fy) {  						for (int fx = fxStart; fx < fxEnd; ++fx) {  							double weight = weights[fy' fx];  							ColorBgra c = src.GetPoint (x - 1 + fx' y - 1 + fy);  							double intensity = (double)c.GetIntensityByte ();  							sum += weight * intensity;  						}  					}    					int iSum = (int)sum;  					iSum += 128;    					if (iSum > 255)  						iSum = 255;    					if (iSum < 0)  						iSum = 0;    					*dstPtr = ColorBgra.FromBgra ((byte)iSum' (byte)iSum' (byte)iSum' 255);    					++dstPtr;  				}  			}
Magic Number,Pinta.ImageManipulation.Effects,EmbossEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\EmbossEffect.cs,RenderLine,The following statement contains a magic number: for (int y = rect.Top; y <= rect.Bottom; ++y) {  				int fyStart = 0;  				int fyEnd = 3;    				if (y == 0)  					fyStart = 1;    				if (y == srcHeight - 1)  					fyEnd = 2;    				// loop through each point in the line   				ColorBgra* dstPtr = dst.GetPointAddress (rect.Left' y);    				for (int x = rect.Left; x <= rect.Right; ++x) {  					int fxStart = 0;  					int fxEnd = 3;    					if (x == 0)  						fxStart = 1;    					if (x == srcWidth - 1)  						fxEnd = 2;    					// loop through each weight  					double sum = 0.0;    					for (int fy = fyStart; fy < fyEnd; ++fy) {  						for (int fx = fxStart; fx < fxEnd; ++fx) {  							double weight = weights[fy' fx];  							ColorBgra c = src.GetPoint (x - 1 + fx' y - 1 + fy);  							double intensity = (double)c.GetIntensityByte ();  							sum += weight * intensity;  						}  					}    					int iSum = (int)sum;  					iSum += 128;    					if (iSum > 255)  						iSum = 255;    					if (iSum < 0)  						iSum = 0;    					*dstPtr = ColorBgra.FromBgra ((byte)iSum' (byte)iSum' (byte)iSum' 255);    					++dstPtr;  				}  			}
Magic Number,Pinta.ImageManipulation.Effects,EmbossEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\EmbossEffect.cs,RenderLine,The following statement contains a magic number: for (int y = rect.Top; y <= rect.Bottom; ++y) {  				int fyStart = 0;  				int fyEnd = 3;    				if (y == 0)  					fyStart = 1;    				if (y == srcHeight - 1)  					fyEnd = 2;    				// loop through each point in the line   				ColorBgra* dstPtr = dst.GetPointAddress (rect.Left' y);    				for (int x = rect.Left; x <= rect.Right; ++x) {  					int fxStart = 0;  					int fxEnd = 3;    					if (x == 0)  						fxStart = 1;    					if (x == srcWidth - 1)  						fxEnd = 2;    					// loop through each weight  					double sum = 0.0;    					for (int fy = fyStart; fy < fyEnd; ++fy) {  						for (int fx = fxStart; fx < fxEnd; ++fx) {  							double weight = weights[fy' fx];  							ColorBgra c = src.GetPoint (x - 1 + fx' y - 1 + fy);  							double intensity = (double)c.GetIntensityByte ();  							sum += weight * intensity;  						}  					}    					int iSum = (int)sum;  					iSum += 128;    					if (iSum > 255)  						iSum = 255;    					if (iSum < 0)  						iSum = 0;    					*dstPtr = ColorBgra.FromBgra ((byte)iSum' (byte)iSum' (byte)iSum' 255);    					++dstPtr;  				}  			}
Magic Number,Pinta.ImageManipulation.Effects,GaussianBlurEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\GaussianBlurEffect.cs,GaussianBlurEffect,The following statement contains a magic number: if (radius < 0 || radius > 200)  				throw new ArgumentOutOfRangeException ("radius");
Magic Number,Pinta.ImageManipulation.Effects,GaussianBlurEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\GaussianBlurEffect.cs,CreateGaussianBlurRow,The following statement contains a magic number: int size = 1 + (amount * 2);
Magic Number,Pinta.ImageManipulation.Effects,GaussianBlurEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\GaussianBlurEffect.cs,CreateGaussianBlurRow,The following statement contains a magic number: for (int i = 0; i <= amount; ++i) {  				// 1 + aa - aa + 2ai - ii  				weights[i] = 16 * (i + 1);  				weights[weights.Length - i - 1] = weights[i];  			}
Magic Number,Pinta.ImageManipulation.Effects,GaussianBlurEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\GaussianBlurEffect.cs,RenderLine,The following statement contains a magic number: int localStoreSize = wlen * 6 * sizeof (long);
Magic Number,Pinta.ImageManipulation.Effects,GaussianBlurEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\GaussianBlurEffect.cs,RenderLine,The following statement contains a magic number: if (rect.Height >= 1 && rect.Width >= 1) {  					for (int y = rect.Top; y <= rect.Bottom; ++y) {  						//Memory.SetToZero (localStore' (ulong)localStoreSize);    						long waSum = 0;  						long wcSum = 0;  						long aSum = 0;  						long bSum = 0;  						long gSum = 0;  						long rSum = 0;    						ColorBgra* dstPtr = dest.GetPointAddress (rect.Left' y);    						for (int wx = 0; wx < wlen; ++wx) {  							int srcX = rect.Left + wx - r;  							waSums[wx] = 0;  							wcSums[wx] = 0;  							aSums[wx] = 0;  							bSums[wx] = 0;  							gSums[wx] = 0;  							rSums[wx] = 0;    							if (srcX >= 0 && srcX < src_width) {  								for (int wy = 0; wy < wlen; ++wy) {  									int srcY = y + wy - r;    									if (srcY >= 0 && srcY < src_height) {  										ColorBgra c = src.GetPoint (srcX' srcY);  										int wp = w[wy];    										waSums[wx] += wp;  										wp *= c.A + (c.A >> 7);  										wcSums[wx] += wp;  										wp >>= 8;    										aSums[wx] += wp * c.A;  										bSums[wx] += wp * c.B;  										gSums[wx] += wp * c.G;  										rSums[wx] += wp * c.R;  									}  								}    								int wwx = w[wx];  								waSum += wwx * waSums[wx];  								wcSum += wwx * wcSums[wx];  								aSum += wwx * aSums[wx];  								bSum += wwx * bSums[wx];  								gSum += wwx * gSums[wx];  								rSum += wwx * rSums[wx];  							}  						}    						wcSum >>= 8;    						if (waSum == 0 || wcSum == 0) {  							dstPtr->Bgra = 0;  						} else {  							int alpha = (int)(aSum / waSum);  							int blue = (int)(bSum / wcSum);  							int green = (int)(gSum / wcSum);  							int red = (int)(rSum / wcSum);    							dstPtr->Bgra = ColorBgra.BgraToUInt32 (blue' green' red' alpha);  						}    						++dstPtr;    						for (int x = rect.Left + 1; x <= rect.Right; ++x) {  							for (int i = 0; i < wlen - 1; ++i) {  								waSums[i] = waSums[i + 1];  								wcSums[i] = wcSums[i + 1];  								aSums[i] = aSums[i + 1];  								bSums[i] = bSums[i + 1];  								gSums[i] = gSums[i + 1];  								rSums[i] = rSums[i + 1];  							}    							waSum = 0;  							wcSum = 0;  							aSum = 0;  							bSum = 0;  							gSum = 0;  							rSum = 0;    							int wx;  							for (wx = 0; wx < wlen - 1; ++wx) {  								long wwx = (long)w[wx];  								waSum += wwx * waSums[wx];  								wcSum += wwx * wcSums[wx];  								aSum += wwx * aSums[wx];  								bSum += wwx * bSums[wx];  								gSum += wwx * gSums[wx];  								rSum += wwx * rSums[wx];  							}    							wx = wlen - 1;    							waSums[wx] = 0;  							wcSums[wx] = 0;  							aSums[wx] = 0;  							bSums[wx] = 0;  							gSums[wx] = 0;  							rSums[wx] = 0;    							int srcX = x + wx - r;    							if (srcX >= 0 && srcX < src_width) {  								for (int wy = 0; wy < wlen; ++wy) {  									int srcY = y + wy - r;    									if (srcY >= 0 && srcY < src_height) {  										ColorBgra c = src.GetPoint (srcX' srcY);  										int wp = w[wy];    										waSums[wx] += wp;  										wp *= c.A + (c.A >> 7);  										wcSums[wx] += wp;  										wp >>= 8;    										aSums[wx] += wp * (long)c.A;  										bSums[wx] += wp * (long)c.B;  										gSums[wx] += wp * (long)c.G;  										rSums[wx] += wp * (long)c.R;  									}  								}    								int wr = w[wx];  								waSum += (long)wr * waSums[wx];  								wcSum += (long)wr * wcSums[wx];  								aSum += (long)wr * aSums[wx];  								bSum += (long)wr * bSums[wx];  								gSum += (long)wr * gSums[wx];  								rSum += (long)wr * rSums[wx];  							}    							wcSum >>= 8;    							if (waSum == 0 || wcSum == 0) {  								dstPtr->Bgra = 0;  							} else {  								int alpha = (int)(aSum / waSum);  								int blue = (int)(bSum / wcSum);  								int green = (int)(gSum / wcSum);  								int red = (int)(rSum / wcSum);    								dstPtr->Bgra = ColorBgra.BgraToUInt32 (blue' green' red' alpha);  							}    							++dstPtr;  						}  					}  			}
Magic Number,Pinta.ImageManipulation.Effects,GaussianBlurEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\GaussianBlurEffect.cs,RenderLine,The following statement contains a magic number: if (rect.Height >= 1 && rect.Width >= 1) {  					for (int y = rect.Top; y <= rect.Bottom; ++y) {  						//Memory.SetToZero (localStore' (ulong)localStoreSize);    						long waSum = 0;  						long wcSum = 0;  						long aSum = 0;  						long bSum = 0;  						long gSum = 0;  						long rSum = 0;    						ColorBgra* dstPtr = dest.GetPointAddress (rect.Left' y);    						for (int wx = 0; wx < wlen; ++wx) {  							int srcX = rect.Left + wx - r;  							waSums[wx] = 0;  							wcSums[wx] = 0;  							aSums[wx] = 0;  							bSums[wx] = 0;  							gSums[wx] = 0;  							rSums[wx] = 0;    							if (srcX >= 0 && srcX < src_width) {  								for (int wy = 0; wy < wlen; ++wy) {  									int srcY = y + wy - r;    									if (srcY >= 0 && srcY < src_height) {  										ColorBgra c = src.GetPoint (srcX' srcY);  										int wp = w[wy];    										waSums[wx] += wp;  										wp *= c.A + (c.A >> 7);  										wcSums[wx] += wp;  										wp >>= 8;    										aSums[wx] += wp * c.A;  										bSums[wx] += wp * c.B;  										gSums[wx] += wp * c.G;  										rSums[wx] += wp * c.R;  									}  								}    								int wwx = w[wx];  								waSum += wwx * waSums[wx];  								wcSum += wwx * wcSums[wx];  								aSum += wwx * aSums[wx];  								bSum += wwx * bSums[wx];  								gSum += wwx * gSums[wx];  								rSum += wwx * rSums[wx];  							}  						}    						wcSum >>= 8;    						if (waSum == 0 || wcSum == 0) {  							dstPtr->Bgra = 0;  						} else {  							int alpha = (int)(aSum / waSum);  							int blue = (int)(bSum / wcSum);  							int green = (int)(gSum / wcSum);  							int red = (int)(rSum / wcSum);    							dstPtr->Bgra = ColorBgra.BgraToUInt32 (blue' green' red' alpha);  						}    						++dstPtr;    						for (int x = rect.Left + 1; x <= rect.Right; ++x) {  							for (int i = 0; i < wlen - 1; ++i) {  								waSums[i] = waSums[i + 1];  								wcSums[i] = wcSums[i + 1];  								aSums[i] = aSums[i + 1];  								bSums[i] = bSums[i + 1];  								gSums[i] = gSums[i + 1];  								rSums[i] = rSums[i + 1];  							}    							waSum = 0;  							wcSum = 0;  							aSum = 0;  							bSum = 0;  							gSum = 0;  							rSum = 0;    							int wx;  							for (wx = 0; wx < wlen - 1; ++wx) {  								long wwx = (long)w[wx];  								waSum += wwx * waSums[wx];  								wcSum += wwx * wcSums[wx];  								aSum += wwx * aSums[wx];  								bSum += wwx * bSums[wx];  								gSum += wwx * gSums[wx];  								rSum += wwx * rSums[wx];  							}    							wx = wlen - 1;    							waSums[wx] = 0;  							wcSums[wx] = 0;  							aSums[wx] = 0;  							bSums[wx] = 0;  							gSums[wx] = 0;  							rSums[wx] = 0;    							int srcX = x + wx - r;    							if (srcX >= 0 && srcX < src_width) {  								for (int wy = 0; wy < wlen; ++wy) {  									int srcY = y + wy - r;    									if (srcY >= 0 && srcY < src_height) {  										ColorBgra c = src.GetPoint (srcX' srcY);  										int wp = w[wy];    										waSums[wx] += wp;  										wp *= c.A + (c.A >> 7);  										wcSums[wx] += wp;  										wp >>= 8;    										aSums[wx] += wp * (long)c.A;  										bSums[wx] += wp * (long)c.B;  										gSums[wx] += wp * (long)c.G;  										rSums[wx] += wp * (long)c.R;  									}  								}    								int wr = w[wx];  								waSum += (long)wr * waSums[wx];  								wcSum += (long)wr * wcSums[wx];  								aSum += (long)wr * aSums[wx];  								bSum += (long)wr * bSums[wx];  								gSum += (long)wr * gSums[wx];  								rSum += (long)wr * rSums[wx];  							}    							wcSum >>= 8;    							if (waSum == 0 || wcSum == 0) {  								dstPtr->Bgra = 0;  							} else {  								int alpha = (int)(aSum / waSum);  								int blue = (int)(bSum / wcSum);  								int green = (int)(gSum / wcSum);  								int red = (int)(rSum / wcSum);    								dstPtr->Bgra = ColorBgra.BgraToUInt32 (blue' green' red' alpha);  							}    							++dstPtr;  						}  					}  			}
Magic Number,Pinta.ImageManipulation.Effects,GaussianBlurEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\GaussianBlurEffect.cs,RenderLine,The following statement contains a magic number: if (rect.Height >= 1 && rect.Width >= 1) {  					for (int y = rect.Top; y <= rect.Bottom; ++y) {  						//Memory.SetToZero (localStore' (ulong)localStoreSize);    						long waSum = 0;  						long wcSum = 0;  						long aSum = 0;  						long bSum = 0;  						long gSum = 0;  						long rSum = 0;    						ColorBgra* dstPtr = dest.GetPointAddress (rect.Left' y);    						for (int wx = 0; wx < wlen; ++wx) {  							int srcX = rect.Left + wx - r;  							waSums[wx] = 0;  							wcSums[wx] = 0;  							aSums[wx] = 0;  							bSums[wx] = 0;  							gSums[wx] = 0;  							rSums[wx] = 0;    							if (srcX >= 0 && srcX < src_width) {  								for (int wy = 0; wy < wlen; ++wy) {  									int srcY = y + wy - r;    									if (srcY >= 0 && srcY < src_height) {  										ColorBgra c = src.GetPoint (srcX' srcY);  										int wp = w[wy];    										waSums[wx] += wp;  										wp *= c.A + (c.A >> 7);  										wcSums[wx] += wp;  										wp >>= 8;    										aSums[wx] += wp * c.A;  										bSums[wx] += wp * c.B;  										gSums[wx] += wp * c.G;  										rSums[wx] += wp * c.R;  									}  								}    								int wwx = w[wx];  								waSum += wwx * waSums[wx];  								wcSum += wwx * wcSums[wx];  								aSum += wwx * aSums[wx];  								bSum += wwx * bSums[wx];  								gSum += wwx * gSums[wx];  								rSum += wwx * rSums[wx];  							}  						}    						wcSum >>= 8;    						if (waSum == 0 || wcSum == 0) {  							dstPtr->Bgra = 0;  						} else {  							int alpha = (int)(aSum / waSum);  							int blue = (int)(bSum / wcSum);  							int green = (int)(gSum / wcSum);  							int red = (int)(rSum / wcSum);    							dstPtr->Bgra = ColorBgra.BgraToUInt32 (blue' green' red' alpha);  						}    						++dstPtr;    						for (int x = rect.Left + 1; x <= rect.Right; ++x) {  							for (int i = 0; i < wlen - 1; ++i) {  								waSums[i] = waSums[i + 1];  								wcSums[i] = wcSums[i + 1];  								aSums[i] = aSums[i + 1];  								bSums[i] = bSums[i + 1];  								gSums[i] = gSums[i + 1];  								rSums[i] = rSums[i + 1];  							}    							waSum = 0;  							wcSum = 0;  							aSum = 0;  							bSum = 0;  							gSum = 0;  							rSum = 0;    							int wx;  							for (wx = 0; wx < wlen - 1; ++wx) {  								long wwx = (long)w[wx];  								waSum += wwx * waSums[wx];  								wcSum += wwx * wcSums[wx];  								aSum += wwx * aSums[wx];  								bSum += wwx * bSums[wx];  								gSum += wwx * gSums[wx];  								rSum += wwx * rSums[wx];  							}    							wx = wlen - 1;    							waSums[wx] = 0;  							wcSums[wx] = 0;  							aSums[wx] = 0;  							bSums[wx] = 0;  							gSums[wx] = 0;  							rSums[wx] = 0;    							int srcX = x + wx - r;    							if (srcX >= 0 && srcX < src_width) {  								for (int wy = 0; wy < wlen; ++wy) {  									int srcY = y + wy - r;    									if (srcY >= 0 && srcY < src_height) {  										ColorBgra c = src.GetPoint (srcX' srcY);  										int wp = w[wy];    										waSums[wx] += wp;  										wp *= c.A + (c.A >> 7);  										wcSums[wx] += wp;  										wp >>= 8;    										aSums[wx] += wp * (long)c.A;  										bSums[wx] += wp * (long)c.B;  										gSums[wx] += wp * (long)c.G;  										rSums[wx] += wp * (long)c.R;  									}  								}    								int wr = w[wx];  								waSum += (long)wr * waSums[wx];  								wcSum += (long)wr * wcSums[wx];  								aSum += (long)wr * aSums[wx];  								bSum += (long)wr * bSums[wx];  								gSum += (long)wr * gSums[wx];  								rSum += (long)wr * rSums[wx];  							}    							wcSum >>= 8;    							if (waSum == 0 || wcSum == 0) {  								dstPtr->Bgra = 0;  							} else {  								int alpha = (int)(aSum / waSum);  								int blue = (int)(bSum / wcSum);  								int green = (int)(gSum / wcSum);  								int red = (int)(rSum / wcSum);    								dstPtr->Bgra = ColorBgra.BgraToUInt32 (blue' green' red' alpha);  							}    							++dstPtr;  						}  					}  			}
Magic Number,Pinta.ImageManipulation.Effects,GaussianBlurEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\GaussianBlurEffect.cs,RenderLine,The following statement contains a magic number: if (rect.Height >= 1 && rect.Width >= 1) {  					for (int y = rect.Top; y <= rect.Bottom; ++y) {  						//Memory.SetToZero (localStore' (ulong)localStoreSize);    						long waSum = 0;  						long wcSum = 0;  						long aSum = 0;  						long bSum = 0;  						long gSum = 0;  						long rSum = 0;    						ColorBgra* dstPtr = dest.GetPointAddress (rect.Left' y);    						for (int wx = 0; wx < wlen; ++wx) {  							int srcX = rect.Left + wx - r;  							waSums[wx] = 0;  							wcSums[wx] = 0;  							aSums[wx] = 0;  							bSums[wx] = 0;  							gSums[wx] = 0;  							rSums[wx] = 0;    							if (srcX >= 0 && srcX < src_width) {  								for (int wy = 0; wy < wlen; ++wy) {  									int srcY = y + wy - r;    									if (srcY >= 0 && srcY < src_height) {  										ColorBgra c = src.GetPoint (srcX' srcY);  										int wp = w[wy];    										waSums[wx] += wp;  										wp *= c.A + (c.A >> 7);  										wcSums[wx] += wp;  										wp >>= 8;    										aSums[wx] += wp * c.A;  										bSums[wx] += wp * c.B;  										gSums[wx] += wp * c.G;  										rSums[wx] += wp * c.R;  									}  								}    								int wwx = w[wx];  								waSum += wwx * waSums[wx];  								wcSum += wwx * wcSums[wx];  								aSum += wwx * aSums[wx];  								bSum += wwx * bSums[wx];  								gSum += wwx * gSums[wx];  								rSum += wwx * rSums[wx];  							}  						}    						wcSum >>= 8;    						if (waSum == 0 || wcSum == 0) {  							dstPtr->Bgra = 0;  						} else {  							int alpha = (int)(aSum / waSum);  							int blue = (int)(bSum / wcSum);  							int green = (int)(gSum / wcSum);  							int red = (int)(rSum / wcSum);    							dstPtr->Bgra = ColorBgra.BgraToUInt32 (blue' green' red' alpha);  						}    						++dstPtr;    						for (int x = rect.Left + 1; x <= rect.Right; ++x) {  							for (int i = 0; i < wlen - 1; ++i) {  								waSums[i] = waSums[i + 1];  								wcSums[i] = wcSums[i + 1];  								aSums[i] = aSums[i + 1];  								bSums[i] = bSums[i + 1];  								gSums[i] = gSums[i + 1];  								rSums[i] = rSums[i + 1];  							}    							waSum = 0;  							wcSum = 0;  							aSum = 0;  							bSum = 0;  							gSum = 0;  							rSum = 0;    							int wx;  							for (wx = 0; wx < wlen - 1; ++wx) {  								long wwx = (long)w[wx];  								waSum += wwx * waSums[wx];  								wcSum += wwx * wcSums[wx];  								aSum += wwx * aSums[wx];  								bSum += wwx * bSums[wx];  								gSum += wwx * gSums[wx];  								rSum += wwx * rSums[wx];  							}    							wx = wlen - 1;    							waSums[wx] = 0;  							wcSums[wx] = 0;  							aSums[wx] = 0;  							bSums[wx] = 0;  							gSums[wx] = 0;  							rSums[wx] = 0;    							int srcX = x + wx - r;    							if (srcX >= 0 && srcX < src_width) {  								for (int wy = 0; wy < wlen; ++wy) {  									int srcY = y + wy - r;    									if (srcY >= 0 && srcY < src_height) {  										ColorBgra c = src.GetPoint (srcX' srcY);  										int wp = w[wy];    										waSums[wx] += wp;  										wp *= c.A + (c.A >> 7);  										wcSums[wx] += wp;  										wp >>= 8;    										aSums[wx] += wp * (long)c.A;  										bSums[wx] += wp * (long)c.B;  										gSums[wx] += wp * (long)c.G;  										rSums[wx] += wp * (long)c.R;  									}  								}    								int wr = w[wx];  								waSum += (long)wr * waSums[wx];  								wcSum += (long)wr * wcSums[wx];  								aSum += (long)wr * aSums[wx];  								bSum += (long)wr * bSums[wx];  								gSum += (long)wr * gSums[wx];  								rSum += (long)wr * rSums[wx];  							}    							wcSum >>= 8;    							if (waSum == 0 || wcSum == 0) {  								dstPtr->Bgra = 0;  							} else {  								int alpha = (int)(aSum / waSum);  								int blue = (int)(bSum / wcSum);  								int green = (int)(gSum / wcSum);  								int red = (int)(rSum / wcSum);    								dstPtr->Bgra = ColorBgra.BgraToUInt32 (blue' green' red' alpha);  							}    							++dstPtr;  						}  					}  			}
Magic Number,Pinta.ImageManipulation.Effects,GaussianBlurEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\GaussianBlurEffect.cs,RenderLine,The following statement contains a magic number: if (rect.Height >= 1 && rect.Width >= 1) {  					for (int y = rect.Top; y <= rect.Bottom; ++y) {  						//Memory.SetToZero (localStore' (ulong)localStoreSize);    						long waSum = 0;  						long wcSum = 0;  						long aSum = 0;  						long bSum = 0;  						long gSum = 0;  						long rSum = 0;    						ColorBgra* dstPtr = dest.GetPointAddress (rect.Left' y);    						for (int wx = 0; wx < wlen; ++wx) {  							int srcX = rect.Left + wx - r;  							waSums[wx] = 0;  							wcSums[wx] = 0;  							aSums[wx] = 0;  							bSums[wx] = 0;  							gSums[wx] = 0;  							rSums[wx] = 0;    							if (srcX >= 0 && srcX < src_width) {  								for (int wy = 0; wy < wlen; ++wy) {  									int srcY = y + wy - r;    									if (srcY >= 0 && srcY < src_height) {  										ColorBgra c = src.GetPoint (srcX' srcY);  										int wp = w[wy];    										waSums[wx] += wp;  										wp *= c.A + (c.A >> 7);  										wcSums[wx] += wp;  										wp >>= 8;    										aSums[wx] += wp * c.A;  										bSums[wx] += wp * c.B;  										gSums[wx] += wp * c.G;  										rSums[wx] += wp * c.R;  									}  								}    								int wwx = w[wx];  								waSum += wwx * waSums[wx];  								wcSum += wwx * wcSums[wx];  								aSum += wwx * aSums[wx];  								bSum += wwx * bSums[wx];  								gSum += wwx * gSums[wx];  								rSum += wwx * rSums[wx];  							}  						}    						wcSum >>= 8;    						if (waSum == 0 || wcSum == 0) {  							dstPtr->Bgra = 0;  						} else {  							int alpha = (int)(aSum / waSum);  							int blue = (int)(bSum / wcSum);  							int green = (int)(gSum / wcSum);  							int red = (int)(rSum / wcSum);    							dstPtr->Bgra = ColorBgra.BgraToUInt32 (blue' green' red' alpha);  						}    						++dstPtr;    						for (int x = rect.Left + 1; x <= rect.Right; ++x) {  							for (int i = 0; i < wlen - 1; ++i) {  								waSums[i] = waSums[i + 1];  								wcSums[i] = wcSums[i + 1];  								aSums[i] = aSums[i + 1];  								bSums[i] = bSums[i + 1];  								gSums[i] = gSums[i + 1];  								rSums[i] = rSums[i + 1];  							}    							waSum = 0;  							wcSum = 0;  							aSum = 0;  							bSum = 0;  							gSum = 0;  							rSum = 0;    							int wx;  							for (wx = 0; wx < wlen - 1; ++wx) {  								long wwx = (long)w[wx];  								waSum += wwx * waSums[wx];  								wcSum += wwx * wcSums[wx];  								aSum += wwx * aSums[wx];  								bSum += wwx * bSums[wx];  								gSum += wwx * gSums[wx];  								rSum += wwx * rSums[wx];  							}    							wx = wlen - 1;    							waSums[wx] = 0;  							wcSums[wx] = 0;  							aSums[wx] = 0;  							bSums[wx] = 0;  							gSums[wx] = 0;  							rSums[wx] = 0;    							int srcX = x + wx - r;    							if (srcX >= 0 && srcX < src_width) {  								for (int wy = 0; wy < wlen; ++wy) {  									int srcY = y + wy - r;    									if (srcY >= 0 && srcY < src_height) {  										ColorBgra c = src.GetPoint (srcX' srcY);  										int wp = w[wy];    										waSums[wx] += wp;  										wp *= c.A + (c.A >> 7);  										wcSums[wx] += wp;  										wp >>= 8;    										aSums[wx] += wp * (long)c.A;  										bSums[wx] += wp * (long)c.B;  										gSums[wx] += wp * (long)c.G;  										rSums[wx] += wp * (long)c.R;  									}  								}    								int wr = w[wx];  								waSum += (long)wr * waSums[wx];  								wcSum += (long)wr * wcSums[wx];  								aSum += (long)wr * aSums[wx];  								bSum += (long)wr * bSums[wx];  								gSum += (long)wr * gSums[wx];  								rSum += (long)wr * rSums[wx];  							}    							wcSum >>= 8;    							if (waSum == 0 || wcSum == 0) {  								dstPtr->Bgra = 0;  							} else {  								int alpha = (int)(aSum / waSum);  								int blue = (int)(bSum / wcSum);  								int green = (int)(gSum / wcSum);  								int red = (int)(rSum / wcSum);    								dstPtr->Bgra = ColorBgra.BgraToUInt32 (blue' green' red' alpha);  							}    							++dstPtr;  						}  					}  			}
Magic Number,Pinta.ImageManipulation.Effects,GaussianBlurEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\GaussianBlurEffect.cs,RenderLine,The following statement contains a magic number: if (rect.Height >= 1 && rect.Width >= 1) {  					for (int y = rect.Top; y <= rect.Bottom; ++y) {  						//Memory.SetToZero (localStore' (ulong)localStoreSize);    						long waSum = 0;  						long wcSum = 0;  						long aSum = 0;  						long bSum = 0;  						long gSum = 0;  						long rSum = 0;    						ColorBgra* dstPtr = dest.GetPointAddress (rect.Left' y);    						for (int wx = 0; wx < wlen; ++wx) {  							int srcX = rect.Left + wx - r;  							waSums[wx] = 0;  							wcSums[wx] = 0;  							aSums[wx] = 0;  							bSums[wx] = 0;  							gSums[wx] = 0;  							rSums[wx] = 0;    							if (srcX >= 0 && srcX < src_width) {  								for (int wy = 0; wy < wlen; ++wy) {  									int srcY = y + wy - r;    									if (srcY >= 0 && srcY < src_height) {  										ColorBgra c = src.GetPoint (srcX' srcY);  										int wp = w[wy];    										waSums[wx] += wp;  										wp *= c.A + (c.A >> 7);  										wcSums[wx] += wp;  										wp >>= 8;    										aSums[wx] += wp * c.A;  										bSums[wx] += wp * c.B;  										gSums[wx] += wp * c.G;  										rSums[wx] += wp * c.R;  									}  								}    								int wwx = w[wx];  								waSum += wwx * waSums[wx];  								wcSum += wwx * wcSums[wx];  								aSum += wwx * aSums[wx];  								bSum += wwx * bSums[wx];  								gSum += wwx * gSums[wx];  								rSum += wwx * rSums[wx];  							}  						}    						wcSum >>= 8;    						if (waSum == 0 || wcSum == 0) {  							dstPtr->Bgra = 0;  						} else {  							int alpha = (int)(aSum / waSum);  							int blue = (int)(bSum / wcSum);  							int green = (int)(gSum / wcSum);  							int red = (int)(rSum / wcSum);    							dstPtr->Bgra = ColorBgra.BgraToUInt32 (blue' green' red' alpha);  						}    						++dstPtr;    						for (int x = rect.Left + 1; x <= rect.Right; ++x) {  							for (int i = 0; i < wlen - 1; ++i) {  								waSums[i] = waSums[i + 1];  								wcSums[i] = wcSums[i + 1];  								aSums[i] = aSums[i + 1];  								bSums[i] = bSums[i + 1];  								gSums[i] = gSums[i + 1];  								rSums[i] = rSums[i + 1];  							}    							waSum = 0;  							wcSum = 0;  							aSum = 0;  							bSum = 0;  							gSum = 0;  							rSum = 0;    							int wx;  							for (wx = 0; wx < wlen - 1; ++wx) {  								long wwx = (long)w[wx];  								waSum += wwx * waSums[wx];  								wcSum += wwx * wcSums[wx];  								aSum += wwx * aSums[wx];  								bSum += wwx * bSums[wx];  								gSum += wwx * gSums[wx];  								rSum += wwx * rSums[wx];  							}    							wx = wlen - 1;    							waSums[wx] = 0;  							wcSums[wx] = 0;  							aSums[wx] = 0;  							bSums[wx] = 0;  							gSums[wx] = 0;  							rSums[wx] = 0;    							int srcX = x + wx - r;    							if (srcX >= 0 && srcX < src_width) {  								for (int wy = 0; wy < wlen; ++wy) {  									int srcY = y + wy - r;    									if (srcY >= 0 && srcY < src_height) {  										ColorBgra c = src.GetPoint (srcX' srcY);  										int wp = w[wy];    										waSums[wx] += wp;  										wp *= c.A + (c.A >> 7);  										wcSums[wx] += wp;  										wp >>= 8;    										aSums[wx] += wp * (long)c.A;  										bSums[wx] += wp * (long)c.B;  										gSums[wx] += wp * (long)c.G;  										rSums[wx] += wp * (long)c.R;  									}  								}    								int wr = w[wx];  								waSum += (long)wr * waSums[wx];  								wcSum += (long)wr * wcSums[wx];  								aSum += (long)wr * aSums[wx];  								bSum += (long)wr * bSums[wx];  								gSum += (long)wr * gSums[wx];  								rSum += (long)wr * rSums[wx];  							}    							wcSum >>= 8;    							if (waSum == 0 || wcSum == 0) {  								dstPtr->Bgra = 0;  							} else {  								int alpha = (int)(aSum / waSum);  								int blue = (int)(bSum / wcSum);  								int green = (int)(gSum / wcSum);  								int red = (int)(rSum / wcSum);    								dstPtr->Bgra = ColorBgra.BgraToUInt32 (blue' green' red' alpha);  							}    							++dstPtr;  						}  					}  			}
Magic Number,Pinta.ImageManipulation.Effects,InkSketchEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\InkSketchEffect.cs,InkSketchEffect,The following statement contains a magic number: conv = new int[5][];
Magic Number,Pinta.ImageManipulation.Effects,InkSketchEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\InkSketchEffect.cs,InkSketchEffect,The following statement contains a magic number: for (var i = 0; i < conv.Length; ++i)  				conv[i] = new int[5];
Magic Number,Pinta.ImageManipulation.Effects,InkSketchEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\InkSketchEffect.cs,InkSketchEffect,The following statement contains a magic number: conv[2] = new int[] { -1' -1' 30' -1' -1 };
Magic Number,Pinta.ImageManipulation.Effects,InkSketchEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\InkSketchEffect.cs,InkSketchEffect,The following statement contains a magic number: conv[2] = new int[] { -1' -1' 30' -1' -1 };
Magic Number,Pinta.ImageManipulation.Effects,InkSketchEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\InkSketchEffect.cs,InkSketchEffect,The following statement contains a magic number: conv[3] = new int[] { -1' -1' -1' -1' -1 };
Magic Number,Pinta.ImageManipulation.Effects,InkSketchEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\InkSketchEffect.cs,InkSketchEffect,The following statement contains a magic number: conv[4] = new int[] { -1' -1' -5' -1' -1 };
Magic Number,Pinta.ImageManipulation.Effects,InkSketchEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\InkSketchEffect.cs,InkSketchEffect,The following statement contains a magic number: conv[4] = new int[] { -1' -1' -5' -1' -1 };
Magic Number,Pinta.ImageManipulation.Effects,InkSketchEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\InkSketchEffect.cs,InkSketchEffect,The following statement contains a magic number: if (inkOutline < 0 || inkOutline > 99)  				throw new ArgumentOutOfRangeException ("inkOutline");
Magic Number,Pinta.ImageManipulation.Effects,InkSketchEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\InkSketchEffect.cs,InkSketchEffect,The following statement contains a magic number: if (coloring < 0 || coloring > 100)  				throw new ArgumentOutOfRangeException ("coloring");
Magic Number,Pinta.ImageManipulation.Effects,InkSketchEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\InkSketchEffect.cs,InkSketchEffect,The following statement contains a magic number: glow_effect = new GlowEffect (6' -(coloring - 50) * 2' -(coloring - 50) * 2);
Magic Number,Pinta.ImageManipulation.Effects,InkSketchEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\InkSketchEffect.cs,InkSketchEffect,The following statement contains a magic number: glow_effect = new GlowEffect (6' -(coloring - 50) * 2' -(coloring - 50) * 2);
Magic Number,Pinta.ImageManipulation.Effects,InkSketchEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\InkSketchEffect.cs,InkSketchEffect,The following statement contains a magic number: glow_effect = new GlowEffect (6' -(coloring - 50) * 2' -(coloring - 50) * 2);
Magic Number,Pinta.ImageManipulation.Effects,InkSketchEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\InkSketchEffect.cs,InkSketchEffect,The following statement contains a magic number: glow_effect = new GlowEffect (6' -(coloring - 50) * 2' -(coloring - 50) * 2);
Magic Number,Pinta.ImageManipulation.Effects,InkSketchEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\InkSketchEffect.cs,InkSketchEffect,The following statement contains a magic number: glow_effect = new GlowEffect (6' -(coloring - 50) * 2' -(coloring - 50) * 2);
Magic Number,Pinta.ImageManipulation.Effects,InkSketchEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\InkSketchEffect.cs,RenderLine,The following statement contains a magic number: for (int y = roi.Top; y <= roi.Bottom; ++y) {  				int top = y - radius;  				int bottom = y + radius + 1;    				if (top < 0) {  					top = 0;  				}    				if (bottom > dest.Height) {  					bottom = dest.Height;  				}    				ColorBgra* srcPtr = src.GetPointAddress (roi.X' y);  				ColorBgra* dstPtr = dest.GetPointAddress (roi.X' y);    				for (int x = roi.Left; x <= roi.Right; ++x) {  					int left = x - radius;  					int right = x + radius + 1;    					if (left < 0) {  						left = 0;  					}    					if (right > dest.Width) {  						right = dest.Width;  					}    					int r = 0;  					int g = 0;  					int b = 0;    					for (int v = top; v < bottom; v++) {  						ColorBgra* pRow = src.GetRowAddress (v);  						int j = v - y + radius;    						for (int u = left; u < right; u++) {  							int i1 = u - x + radius;  							int w = conv[j][i1];    							ColorBgra* pRef = pRow + u;    							r += pRef->R * w;  							g += pRef->G * w;  							b += pRef->B * w;  						}  					}    					ColorBgra topLayer = ColorBgra.FromBgr (  						Utility.ClampToByte (b)'  						Utility.ClampToByte (g)'  						Utility.ClampToByte (r));    					// Desaturate   					topLayer = this.desaturate_op.Apply (topLayer);    					// Adjust Brightness and Contrast   					if (topLayer.R > (ink_outline * 255 / 100)) {  						topLayer = ColorBgra.FromBgra (255' 255' 255' topLayer.A);  					} else {  						topLayer = ColorBgra.FromBgra (0' 0' 0' topLayer.A);  					}    					// Change Blend Mode to Darken   					ColorBgra myPixel = this.darken_op.Apply (topLayer' *dstPtr);  					*dstPtr = myPixel;    					++srcPtr;  					++dstPtr;  				}  			}
Magic Number,Pinta.ImageManipulation.Effects,InkSketchEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\InkSketchEffect.cs,RenderLine,The following statement contains a magic number: for (int y = roi.Top; y <= roi.Bottom; ++y) {  				int top = y - radius;  				int bottom = y + radius + 1;    				if (top < 0) {  					top = 0;  				}    				if (bottom > dest.Height) {  					bottom = dest.Height;  				}    				ColorBgra* srcPtr = src.GetPointAddress (roi.X' y);  				ColorBgra* dstPtr = dest.GetPointAddress (roi.X' y);    				for (int x = roi.Left; x <= roi.Right; ++x) {  					int left = x - radius;  					int right = x + radius + 1;    					if (left < 0) {  						left = 0;  					}    					if (right > dest.Width) {  						right = dest.Width;  					}    					int r = 0;  					int g = 0;  					int b = 0;    					for (int v = top; v < bottom; v++) {  						ColorBgra* pRow = src.GetRowAddress (v);  						int j = v - y + radius;    						for (int u = left; u < right; u++) {  							int i1 = u - x + radius;  							int w = conv[j][i1];    							ColorBgra* pRef = pRow + u;    							r += pRef->R * w;  							g += pRef->G * w;  							b += pRef->B * w;  						}  					}    					ColorBgra topLayer = ColorBgra.FromBgr (  						Utility.ClampToByte (b)'  						Utility.ClampToByte (g)'  						Utility.ClampToByte (r));    					// Desaturate   					topLayer = this.desaturate_op.Apply (topLayer);    					// Adjust Brightness and Contrast   					if (topLayer.R > (ink_outline * 255 / 100)) {  						topLayer = ColorBgra.FromBgra (255' 255' 255' topLayer.A);  					} else {  						topLayer = ColorBgra.FromBgra (0' 0' 0' topLayer.A);  					}    					// Change Blend Mode to Darken   					ColorBgra myPixel = this.darken_op.Apply (topLayer' *dstPtr);  					*dstPtr = myPixel;    					++srcPtr;  					++dstPtr;  				}  			}
Magic Number,Pinta.ImageManipulation.Effects,InkSketchEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\InkSketchEffect.cs,RenderLine,The following statement contains a magic number: for (int y = roi.Top; y <= roi.Bottom; ++y) {  				int top = y - radius;  				int bottom = y + radius + 1;    				if (top < 0) {  					top = 0;  				}    				if (bottom > dest.Height) {  					bottom = dest.Height;  				}    				ColorBgra* srcPtr = src.GetPointAddress (roi.X' y);  				ColorBgra* dstPtr = dest.GetPointAddress (roi.X' y);    				for (int x = roi.Left; x <= roi.Right; ++x) {  					int left = x - radius;  					int right = x + radius + 1;    					if (left < 0) {  						left = 0;  					}    					if (right > dest.Width) {  						right = dest.Width;  					}    					int r = 0;  					int g = 0;  					int b = 0;    					for (int v = top; v < bottom; v++) {  						ColorBgra* pRow = src.GetRowAddress (v);  						int j = v - y + radius;    						for (int u = left; u < right; u++) {  							int i1 = u - x + radius;  							int w = conv[j][i1];    							ColorBgra* pRef = pRow + u;    							r += pRef->R * w;  							g += pRef->G * w;  							b += pRef->B * w;  						}  					}    					ColorBgra topLayer = ColorBgra.FromBgr (  						Utility.ClampToByte (b)'  						Utility.ClampToByte (g)'  						Utility.ClampToByte (r));    					// Desaturate   					topLayer = this.desaturate_op.Apply (topLayer);    					// Adjust Brightness and Contrast   					if (topLayer.R > (ink_outline * 255 / 100)) {  						topLayer = ColorBgra.FromBgra (255' 255' 255' topLayer.A);  					} else {  						topLayer = ColorBgra.FromBgra (0' 0' 0' topLayer.A);  					}    					// Change Blend Mode to Darken   					ColorBgra myPixel = this.darken_op.Apply (topLayer' *dstPtr);  					*dstPtr = myPixel;    					++srcPtr;  					++dstPtr;  				}  			}
Magic Number,Pinta.ImageManipulation.Effects,InkSketchEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\InkSketchEffect.cs,RenderLine,The following statement contains a magic number: for (int y = roi.Top; y <= roi.Bottom; ++y) {  				int top = y - radius;  				int bottom = y + radius + 1;    				if (top < 0) {  					top = 0;  				}    				if (bottom > dest.Height) {  					bottom = dest.Height;  				}    				ColorBgra* srcPtr = src.GetPointAddress (roi.X' y);  				ColorBgra* dstPtr = dest.GetPointAddress (roi.X' y);    				for (int x = roi.Left; x <= roi.Right; ++x) {  					int left = x - radius;  					int right = x + radius + 1;    					if (left < 0) {  						left = 0;  					}    					if (right > dest.Width) {  						right = dest.Width;  					}    					int r = 0;  					int g = 0;  					int b = 0;    					for (int v = top; v < bottom; v++) {  						ColorBgra* pRow = src.GetRowAddress (v);  						int j = v - y + radius;    						for (int u = left; u < right; u++) {  							int i1 = u - x + radius;  							int w = conv[j][i1];    							ColorBgra* pRef = pRow + u;    							r += pRef->R * w;  							g += pRef->G * w;  							b += pRef->B * w;  						}  					}    					ColorBgra topLayer = ColorBgra.FromBgr (  						Utility.ClampToByte (b)'  						Utility.ClampToByte (g)'  						Utility.ClampToByte (r));    					// Desaturate   					topLayer = this.desaturate_op.Apply (topLayer);    					// Adjust Brightness and Contrast   					if (topLayer.R > (ink_outline * 255 / 100)) {  						topLayer = ColorBgra.FromBgra (255' 255' 255' topLayer.A);  					} else {  						topLayer = ColorBgra.FromBgra (0' 0' 0' topLayer.A);  					}    					// Change Blend Mode to Darken   					ColorBgra myPixel = this.darken_op.Apply (topLayer' *dstPtr);  					*dstPtr = myPixel;    					++srcPtr;  					++dstPtr;  				}  			}
Magic Number,Pinta.ImageManipulation.Effects,InkSketchEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\InkSketchEffect.cs,RenderLine,The following statement contains a magic number: for (int y = roi.Top; y <= roi.Bottom; ++y) {  				int top = y - radius;  				int bottom = y + radius + 1;    				if (top < 0) {  					top = 0;  				}    				if (bottom > dest.Height) {  					bottom = dest.Height;  				}    				ColorBgra* srcPtr = src.GetPointAddress (roi.X' y);  				ColorBgra* dstPtr = dest.GetPointAddress (roi.X' y);    				for (int x = roi.Left; x <= roi.Right; ++x) {  					int left = x - radius;  					int right = x + radius + 1;    					if (left < 0) {  						left = 0;  					}    					if (right > dest.Width) {  						right = dest.Width;  					}    					int r = 0;  					int g = 0;  					int b = 0;    					for (int v = top; v < bottom; v++) {  						ColorBgra* pRow = src.GetRowAddress (v);  						int j = v - y + radius;    						for (int u = left; u < right; u++) {  							int i1 = u - x + radius;  							int w = conv[j][i1];    							ColorBgra* pRef = pRow + u;    							r += pRef->R * w;  							g += pRef->G * w;  							b += pRef->B * w;  						}  					}    					ColorBgra topLayer = ColorBgra.FromBgr (  						Utility.ClampToByte (b)'  						Utility.ClampToByte (g)'  						Utility.ClampToByte (r));    					// Desaturate   					topLayer = this.desaturate_op.Apply (topLayer);    					// Adjust Brightness and Contrast   					if (topLayer.R > (ink_outline * 255 / 100)) {  						topLayer = ColorBgra.FromBgra (255' 255' 255' topLayer.A);  					} else {  						topLayer = ColorBgra.FromBgra (0' 0' 0' topLayer.A);  					}    					// Change Blend Mode to Darken   					ColorBgra myPixel = this.darken_op.Apply (topLayer' *dstPtr);  					*dstPtr = myPixel;    					++srcPtr;  					++dstPtr;  				}  			}
Magic Number,Pinta.ImageManipulation.Effects,LocalHistogramEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\LocalHistogramEffect.cs,GetMaxAreaForRadius,The following statement contains a magic number: int cutoff = ((radius * 2 + 1) * (radius * 2 + 1) + 2) / 4;
Magic Number,Pinta.ImageManipulation.Effects,LocalHistogramEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\LocalHistogramEffect.cs,GetMaxAreaForRadius,The following statement contains a magic number: int cutoff = ((radius * 2 + 1) * (radius * 2 + 1) + 2) / 4;
Magic Number,Pinta.ImageManipulation.Effects,LocalHistogramEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\LocalHistogramEffect.cs,GetMaxAreaForRadius,The following statement contains a magic number: int cutoff = ((radius * 2 + 1) * (radius * 2 + 1) + 2) / 4;
Magic Number,Pinta.ImageManipulation.Effects,LocalHistogramEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\LocalHistogramEffect.cs,GetMaxAreaForRadius,The following statement contains a magic number: int cutoff = ((radius * 2 + 1) * (radius * 2 + 1) + 2) / 4;
Magic Number,Pinta.ImageManipulation.Effects,LocalHistogramEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\LocalHistogramEffect.cs,GetPercentile,The following statement contains a magic number: int minCount = area * percentile / 100;
Magic Number,Pinta.ImageManipulation.Effects,LocalHistogramEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\LocalHistogramEffect.cs,GetPercentile,The following statement contains a magic number: while (b < 255 && hb[b] == 0) {  				++b;  			}
Magic Number,Pinta.ImageManipulation.Effects,LocalHistogramEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\LocalHistogramEffect.cs,GetPercentile,The following statement contains a magic number: while (b < 255 && bCount < minCount) {  				bCount += hb[b];  				++b;  			}
Magic Number,Pinta.ImageManipulation.Effects,LocalHistogramEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\LocalHistogramEffect.cs,GetPercentile,The following statement contains a magic number: while (g < 255 && hg[g] == 0) {  				++g;  			}
Magic Number,Pinta.ImageManipulation.Effects,LocalHistogramEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\LocalHistogramEffect.cs,GetPercentile,The following statement contains a magic number: while (g < 255 && gCount < minCount) {  				gCount += hg[g];  				++g;  			}
Magic Number,Pinta.ImageManipulation.Effects,LocalHistogramEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\LocalHistogramEffect.cs,GetPercentile,The following statement contains a magic number: while (r < 255 && hr[r] == 0) {  				++r;  			}
Magic Number,Pinta.ImageManipulation.Effects,LocalHistogramEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\LocalHistogramEffect.cs,GetPercentile,The following statement contains a magic number: while (r < 255 && rCount < minCount) {  				rCount += hr[r];  				++r;  			}
Magic Number,Pinta.ImageManipulation.Effects,LocalHistogramEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\LocalHistogramEffect.cs,GetPercentile,The following statement contains a magic number: while (a < 255 && ha[a] == 0) {  				++a;  			}
Magic Number,Pinta.ImageManipulation.Effects,LocalHistogramEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\LocalHistogramEffect.cs,GetPercentile,The following statement contains a magic number: while (a < 255 && aCount < minCount) {  				aCount += ha[a];  				++a;  			}
Magic Number,Pinta.ImageManipulation.Effects,LocalHistogramEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\LocalHistogramEffect.cs,RenderRect,The following statement contains a magic number: int cutoff = ((rad * 2 + 1) * (rad * 2 + 1) + 2) / 4;
Magic Number,Pinta.ImageManipulation.Effects,LocalHistogramEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\LocalHistogramEffect.cs,RenderRect,The following statement contains a magic number: int cutoff = ((rad * 2 + 1) * (rad * 2 + 1) + 2) / 4;
Magic Number,Pinta.ImageManipulation.Effects,LocalHistogramEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\LocalHistogramEffect.cs,RenderRect,The following statement contains a magic number: int cutoff = ((rad * 2 + 1) * (rad * 2 + 1) + 2) / 4;
Magic Number,Pinta.ImageManipulation.Effects,LocalHistogramEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\LocalHistogramEffect.cs,RenderRect,The following statement contains a magic number: int cutoff = ((rad * 2 + 1) * (rad * 2 + 1) + 2) / 4;
Magic Number,Pinta.ImageManipulation.Effects,LocalHistogramEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\LocalHistogramEffect.cs,RenderRect,The following statement contains a magic number: const int hLength = 256;
Magic Number,Pinta.ImageManipulation.Effects,LocalHistogramEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\LocalHistogramEffect.cs,RenderRectWithAlpha,The following statement contains a magic number: int cutoff = ((rad * 2 + 1) * (rad * 2 + 1) + 2) / 4;
Magic Number,Pinta.ImageManipulation.Effects,LocalHistogramEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\LocalHistogramEffect.cs,RenderRectWithAlpha,The following statement contains a magic number: int cutoff = ((rad * 2 + 1) * (rad * 2 + 1) + 2) / 4;
Magic Number,Pinta.ImageManipulation.Effects,LocalHistogramEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\LocalHistogramEffect.cs,RenderRectWithAlpha,The following statement contains a magic number: int cutoff = ((rad * 2 + 1) * (rad * 2 + 1) + 2) / 4;
Magic Number,Pinta.ImageManipulation.Effects,LocalHistogramEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\LocalHistogramEffect.cs,RenderRectWithAlpha,The following statement contains a magic number: int cutoff = ((rad * 2 + 1) * (rad * 2 + 1) + 2) / 4;
Magic Number,Pinta.ImageManipulation.Effects,LocalHistogramEffect,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Effects\LocalHistogramEffect.cs,RenderRectWithAlpha,The following statement contains a magic number: const int hLength = 256;
Magic Number,Pinta.ImageManipulation.Gradients,BaseGradientRenderer,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Gradients\BaseGradientRenderer.cs,BeforeRender,The following statement contains a magic number: if (!this.lerpCacheIsValid) {  				byte startAlpha;  				byte endAlpha;  				  				if (this.AlphaOnly) {  					ComputeAlphaOnlyValuesFromColors (this.startColor' this.endColor' out startAlpha' out endAlpha);  				} else {  					startAlpha = this.startColor.A;  					endAlpha = this.endColor.A;  				}  				  				this.lerpAlphas = new byte[256];  				this.lerpColors = new ColorBgra[256];  				  				for (int i = 0; i < 256; ++i) {  					byte a = (byte)i;  					this.lerpColors[a] = ColorBgra.Blend (this.startColor' this.endColor' a);  					this.lerpAlphas[a] = (byte)(startAlpha + ((endAlpha - startAlpha) * a) / 255);  				}  				  				this.lerpCacheIsValid = true;  			}
Magic Number,Pinta.ImageManipulation.Gradients,BaseGradientRenderer,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Gradients\BaseGradientRenderer.cs,BeforeRender,The following statement contains a magic number: if (!this.lerpCacheIsValid) {  				byte startAlpha;  				byte endAlpha;  				  				if (this.AlphaOnly) {  					ComputeAlphaOnlyValuesFromColors (this.startColor' this.endColor' out startAlpha' out endAlpha);  				} else {  					startAlpha = this.startColor.A;  					endAlpha = this.endColor.A;  				}  				  				this.lerpAlphas = new byte[256];  				this.lerpColors = new ColorBgra[256];  				  				for (int i = 0; i < 256; ++i) {  					byte a = (byte)i;  					this.lerpColors[a] = ColorBgra.Blend (this.startColor' this.endColor' a);  					this.lerpAlphas[a] = (byte)(startAlpha + ((endAlpha - startAlpha) * a) / 255);  				}  				  				this.lerpCacheIsValid = true;  			}
Magic Number,Pinta.ImageManipulation.Gradients,BaseGradientRenderer,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Gradients\BaseGradientRenderer.cs,BeforeRender,The following statement contains a magic number: if (!this.lerpCacheIsValid) {  				byte startAlpha;  				byte endAlpha;  				  				if (this.AlphaOnly) {  					ComputeAlphaOnlyValuesFromColors (this.startColor' this.endColor' out startAlpha' out endAlpha);  				} else {  					startAlpha = this.startColor.A;  					endAlpha = this.endColor.A;  				}  				  				this.lerpAlphas = new byte[256];  				this.lerpColors = new ColorBgra[256];  				  				for (int i = 0; i < 256; ++i) {  					byte a = (byte)i;  					this.lerpColors[a] = ColorBgra.Blend (this.startColor' this.endColor' a);  					this.lerpAlphas[a] = (byte)(startAlpha + ((endAlpha - startAlpha) * a) / 255);  				}  				  				this.lerpCacheIsValid = true;  			}
Magic Number,Pinta.ImageManipulation.Gradients,BaseGradientRenderer,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Gradients\BaseGradientRenderer.cs,BeforeRender,The following statement contains a magic number: if (!this.lerpCacheIsValid) {  				byte startAlpha;  				byte endAlpha;  				  				if (this.AlphaOnly) {  					ComputeAlphaOnlyValuesFromColors (this.startColor' this.endColor' out startAlpha' out endAlpha);  				} else {  					startAlpha = this.startColor.A;  					endAlpha = this.endColor.A;  				}  				  				this.lerpAlphas = new byte[256];  				this.lerpColors = new ColorBgra[256];  				  				for (int i = 0; i < 256; ++i) {  					byte a = (byte)i;  					this.lerpColors[a] = ColorBgra.Blend (this.startColor' this.endColor' a);  					this.lerpAlphas[a] = (byte)(startAlpha + ((endAlpha - startAlpha) * a) / 255);  				}  				  				this.lerpCacheIsValid = true;  			}
Magic Number,Pinta.ImageManipulation.Gradients,BaseGradientRenderer,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Gradients\BaseGradientRenderer.cs,Render,The following statement contains a magic number: for (int ri = 0; ri < rois.Length; ++ri) {  				var rect = rois[ri];  				  				if (this.StartPoint.X == this.EndPoint.X && this.StartPoint.Y == this.EndPoint.Y) {  					// Start and End point are the same ... fill with solid color.  					for (int y = rect.Top; y <= rect.Bottom; ++y) {  						var pixelPtr = surface.GetPointAddress(rect.Left' y);  						  						for (int x = rect.Left; x <= rect.Right; ++x) {  							ColorBgra result;  							  							if (this.AlphaOnly && this.AlphaBlending) {  								byte resultAlpha = (byte)Utility.FastDivideShortByByte ((ushort)(pixelPtr->A * endAlpha)' 255);  								result = *pixelPtr;  								result.A = resultAlpha;  							} else if (this.AlphaOnly && !this.AlphaBlending) {  								result = *pixelPtr;  								result.A = endAlpha;  							} else if (!this.AlphaOnly && this.AlphaBlending) {  								result = this.normalBlendOp.Apply (*pixelPtr' this.endColor);  							//if (!this.alphaOnly && !this.alphaBlending)  							} else {  								result = this.endColor;  							}  							  							*pixelPtr = result;  							++pixelPtr;  						}  					}  				} else {  					var mainrect = rect;  					Parallel.ForEach(Enumerable.Range (rect.Top' rect.Bottom + 1)'  						(y) => ProcessGradientLine(startAlpha' endAlpha' y' mainrect' surface));  				}  			}
Magic Number,Pinta.ImageManipulation.Gradients,BaseGradientRenderer,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Gradients\BaseGradientRenderer.cs,ComputeAlphaOnlyValuesFromColors,The following statement contains a magic number: endAlpha = (byte)(255 - endColor.A);
Magic Number,Pinta.ImageManipulation.Gradients,BaseGradientRenderer,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Gradients\BaseGradientRenderer.cs,ProcessGradientLine,The following statement contains a magic number: if (AlphaOnly && AlphaBlending)  			{  				for (var x = rect.Left; x <= right; ++x)  				{  					var lerpByte = ComputeByteLerp(x' y);  					var lerpAlpha = lerpAlphas[lerpByte];  					var resultAlpha = Utility.FastScaleByteByByte(pixelPtr->A' lerpAlpha);  					pixelPtr->A = resultAlpha;  					++pixelPtr;  				}  			}  			else if (AlphaOnly && !AlphaBlending)  			{  				for (var x = rect.Left; x <= right; ++x)  				{  					var lerpByte = ComputeByteLerp(x' y);  					var lerpAlpha = lerpAlphas[lerpByte];  					pixelPtr->A = lerpAlpha;  					++pixelPtr;  				}  			}  			else if (!AlphaOnly && (AlphaBlending && (startAlpha != 255 || endAlpha != 255)))  			{  				// If we're doing all color channels' and we're doing alpha blending' and if alpha blending is necessary  				for (var x = rect.Left; x <= right; ++x)  				{  					var lerpByte = ComputeByteLerp(x' y);  					var lerpColor = lerpColors[lerpByte];  					var result = normalBlendOp.Apply((*pixelPtr)' lerpColor);  					*pixelPtr = result;  					++pixelPtr;  				}  				//if (!this.alphaOnly && !this.alphaBlending) // or sC.A == 255 && eC.A == 255  			}  			else  			{  				for (var x = rect.Left; x <= right; ++x)  				{  					var lerpByte = ComputeByteLerp(x' y);  					var lerpColor = lerpColors[lerpByte];  					*pixelPtr = lerpColor;  					++pixelPtr;  				}  			}
Magic Number,Pinta.ImageManipulation.Gradients,BaseGradientRenderer,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Gradients\BaseGradientRenderer.cs,ProcessGradientLine,The following statement contains a magic number: if (AlphaOnly && AlphaBlending)  			{  				for (var x = rect.Left; x <= right; ++x)  				{  					var lerpByte = ComputeByteLerp(x' y);  					var lerpAlpha = lerpAlphas[lerpByte];  					var resultAlpha = Utility.FastScaleByteByByte(pixelPtr->A' lerpAlpha);  					pixelPtr->A = resultAlpha;  					++pixelPtr;  				}  			}  			else if (AlphaOnly && !AlphaBlending)  			{  				for (var x = rect.Left; x <= right; ++x)  				{  					var lerpByte = ComputeByteLerp(x' y);  					var lerpAlpha = lerpAlphas[lerpByte];  					pixelPtr->A = lerpAlpha;  					++pixelPtr;  				}  			}  			else if (!AlphaOnly && (AlphaBlending && (startAlpha != 255 || endAlpha != 255)))  			{  				// If we're doing all color channels' and we're doing alpha blending' and if alpha blending is necessary  				for (var x = rect.Left; x <= right; ++x)  				{  					var lerpByte = ComputeByteLerp(x' y);  					var lerpColor = lerpColors[lerpByte];  					var result = normalBlendOp.Apply((*pixelPtr)' lerpColor);  					*pixelPtr = result;  					++pixelPtr;  				}  				//if (!this.alphaOnly && !this.alphaBlending) // or sC.A == 255 && eC.A == 255  			}  			else  			{  				for (var x = rect.Left; x <= right; ++x)  				{  					var lerpByte = ComputeByteLerp(x' y);  					var lerpColor = lerpColors[lerpByte];  					*pixelPtr = lerpColor;  					++pixelPtr;  				}  			}
Magic Number,Pinta.ImageManipulation.Gradients,ConicalRenderer,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Gradients\ConicalRenderer.cs,BoundLerp,The following statement contains a magic number: if (t > 1)  				t -= 2;  			else if (t < -1)  				t += 2;
Magic Number,Pinta.ImageManipulation.Gradients,ConicalRenderer,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Gradients\ConicalRenderer.cs,BoundLerp,The following statement contains a magic number: if (t > 1)  				t -= 2;  			else if (t < -1)  				t += 2;
Magic Number,Pinta.ImageManipulation.Gradients,RadialRenderer,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Gradients\RadialRenderer.cs,ComputeByteLerp,The following statement contains a magic number: return result > 1.0 ? (byte)255 : (byte)(result * 255f);
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,AdditiveBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\AdditiveBlendOp.cs,Apply,The following statement contains a magic number: { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,AdditiveBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\AdditiveBlendOp.cs,Apply,The following statement contains a magic number: { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,AdditiveBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\AdditiveBlendOp.cs,Apply,The following statement contains a magic number: { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,AdditiveBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\AdditiveBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min (255' ((lhs).B) + ((rhs).B)); }; { fG = Math.Min (255' ((lhs).G) + ((rhs).G)); }; { fR = Math.Min (255' ((lhs).R) + ((rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,AdditiveBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\AdditiveBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min (255' ((lhs).B) + ((rhs).B)); }; { fG = Math.Min (255' ((lhs).G) + ((rhs).G)); }; { fR = Math.Min (255' ((lhs).R) + ((rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,AdditiveBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\AdditiveBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min (255' ((lhs).B) + ((rhs).B)); }; { fG = Math.Min (255' ((lhs).G) + ((rhs).G)); }; { fR = Math.Min (255' ((lhs).R) + ((rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,AdditiveBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\AdditiveBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min (255' ((lhs).B) + ((rhs).B)); }; { fG = Math.Min (255' ((lhs).G) + ((rhs).G)); }; { fR = Math.Min (255' ((lhs).R) + ((rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,AdditiveBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\AdditiveBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min (255' ((lhs).B) + ((rhs).B)); }; { fG = Math.Min (255' ((lhs).G) + ((rhs).G)); }; { fR = Math.Min (255' ((lhs).R) + ((rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,AdditiveBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\AdditiveBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min (255' ((lhs).B) + ((rhs).B)); }; { fG = Math.Min (255' ((lhs).G) + ((rhs).G)); }; { fR = Math.Min (255' ((lhs).R) + ((rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,AdditiveBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\AdditiveBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min (255' ((lhs).B) + ((rhs).B)); }; { fG = Math.Min (255' ((lhs).G) + ((rhs).G)); }; { fR = Math.Min (255' ((lhs).R) + ((rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,AdditiveBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\AdditiveBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min (255' ((lhs).B) + ((rhs).B)); }; { fG = Math.Min (255' ((lhs).G) + ((rhs).G)); }; { fR = Math.Min (255' ((lhs).R) + ((rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,AdditiveBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\AdditiveBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min (255' ((lhs).B) + ((rhs).B)); }; { fG = Math.Min (255' ((lhs).G) + ((rhs).G)); }; { fR = Math.Min (255' ((lhs).R) + ((rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,AdditiveBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\AdditiveBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min (255' ((lhs).B) + ((rhs).B)); }; { fG = Math.Min (255' ((lhs).G) + ((rhs).G)); }; { fR = Math.Min (255' ((lhs).R) + ((rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,AdditiveBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\AdditiveBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min (255' ((lhs).B) + ((rhs).B)); }; { fG = Math.Min (255' ((lhs).G) + ((rhs).G)); }; { fR = Math.Min (255' ((lhs).R) + ((rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,AdditiveBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\AdditiveBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min (255' ((lhs).B) + ((rhs).B)); }; { fG = Math.Min (255' ((lhs).G) + ((rhs).G)); }; { fR = Math.Min (255' ((lhs).R) + ((rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,AdditiveBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\AdditiveBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min (255' ((lhs).B) + ((rhs).B)); }; { fG = Math.Min (255' ((lhs).G) + ((rhs).G)); }; { fR = Math.Min (255' ((lhs).R) + ((rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,AdditiveBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\AdditiveBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min (255' ((*dst).B) + ((*src).B)); }; { fG = Math.Min (255' ((*dst).G) + ((*src).G)); }; { fR = Math.Min (255' ((*dst).R) + ((*src).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,AdditiveBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\AdditiveBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min (255' ((*dst).B) + ((*src).B)); }; { fG = Math.Min (255' ((*dst).G) + ((*src).G)); }; { fR = Math.Min (255' ((*dst).R) + ((*src).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,AdditiveBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\AdditiveBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min (255' ((*dst).B) + ((*src).B)); }; { fG = Math.Min (255' ((*dst).G) + ((*src).G)); }; { fR = Math.Min (255' ((*dst).R) + ((*src).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,AdditiveBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\AdditiveBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min (255' ((*dst).B) + ((*src).B)); }; { fG = Math.Min (255' ((*dst).G) + ((*src).G)); }; { fR = Math.Min (255' ((*dst).R) + ((*src).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,AdditiveBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\AdditiveBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min (255' ((*dst).B) + ((*src).B)); }; { fG = Math.Min (255' ((*dst).G) + ((*src).G)); }; { fR = Math.Min (255' ((*dst).R) + ((*src).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,AdditiveBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\AdditiveBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min (255' ((*dst).B) + ((*src).B)); }; { fG = Math.Min (255' ((*dst).G) + ((*src).G)); }; { fR = Math.Min (255' ((*dst).R) + ((*src).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,AdditiveBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\AdditiveBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min (255' ((*dst).B) + ((*src).B)); }; { fG = Math.Min (255' ((*dst).G) + ((*src).G)); }; { fR = Math.Min (255' ((*dst).R) + ((*src).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,AdditiveBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\AdditiveBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min (255' ((*dst).B) + ((*src).B)); }; { fG = Math.Min (255' ((*dst).G) + ((*src).G)); }; { fR = Math.Min (255' ((*dst).R) + ((*src).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,AdditiveBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\AdditiveBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min (255' ((*dst).B) + ((*src).B)); }; { fG = Math.Min (255' ((*dst).G) + ((*src).G)); }; { fR = Math.Min (255' ((*dst).R) + ((*src).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,AdditiveBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\AdditiveBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min (255' ((*dst).B) + ((*src).B)); }; { fG = Math.Min (255' ((*dst).G) + ((*src).G)); }; { fR = Math.Min (255' ((*dst).R) + ((*src).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,AdditiveBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\AdditiveBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min (255' ((*dst).B) + ((*src).B)); }; { fG = Math.Min (255' ((*dst).G) + ((*src).G)); }; { fR = Math.Min (255' ((*dst).R) + ((*src).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,AdditiveBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\AdditiveBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min (255' ((*dst).B) + ((*src).B)); }; { fG = Math.Min (255' ((*dst).G) + ((*src).G)); }; { fR = Math.Min (255' ((*dst).R) + ((*src).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,AdditiveBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\AdditiveBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min (255' ((*dst).B) + ((*src).B)); }; { fG = Math.Min (255' ((*dst).G) + ((*src).G)); }; { fR = Math.Min (255' ((*dst).R) + ((*src).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,AdditiveBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\AdditiveBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min (255' ((*dst).B) + ((*src).B)); }; { fG = Math.Min (255' ((*dst).G) + ((*src).G)); }; { fR = Math.Min (255' ((*dst).R) + ((*src).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,AdditiveBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\AdditiveBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min (255' ((*dst).B) + ((*src).B)); }; { fG = Math.Min (255' ((*dst).G) + ((*src).G)); }; { fR = Math.Min (255' ((*dst).R) + ((*src).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,AdditiveBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\AdditiveBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min (255' ((*dst).B) + ((*src).B)); }; { fG = Math.Min (255' ((*dst).G) + ((*src).G)); }; { fR = Math.Min (255' ((*dst).R) + ((*src).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,AdditiveBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\AdditiveBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min (255' ((*lhs).B) + ((*rhs).B)); }; { fG = Math.Min (255' ((*lhs).G) + ((*rhs).G)); }; { fR = Math.Min (255' ((*lhs).R) + ((*rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,AdditiveBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\AdditiveBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min (255' ((*lhs).B) + ((*rhs).B)); }; { fG = Math.Min (255' ((*lhs).G) + ((*rhs).G)); }; { fR = Math.Min (255' ((*lhs).R) + ((*rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,AdditiveBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\AdditiveBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min (255' ((*lhs).B) + ((*rhs).B)); }; { fG = Math.Min (255' ((*lhs).G) + ((*rhs).G)); }; { fR = Math.Min (255' ((*lhs).R) + ((*rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,AdditiveBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\AdditiveBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min (255' ((*lhs).B) + ((*rhs).B)); }; { fG = Math.Min (255' ((*lhs).G) + ((*rhs).G)); }; { fR = Math.Min (255' ((*lhs).R) + ((*rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,AdditiveBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\AdditiveBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min (255' ((*lhs).B) + ((*rhs).B)); }; { fG = Math.Min (255' ((*lhs).G) + ((*rhs).G)); }; { fR = Math.Min (255' ((*lhs).R) + ((*rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,AdditiveBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\AdditiveBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min (255' ((*lhs).B) + ((*rhs).B)); }; { fG = Math.Min (255' ((*lhs).G) + ((*rhs).G)); }; { fR = Math.Min (255' ((*lhs).R) + ((*rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,AdditiveBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\AdditiveBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min (255' ((*lhs).B) + ((*rhs).B)); }; { fG = Math.Min (255' ((*lhs).G) + ((*rhs).G)); }; { fR = Math.Min (255' ((*lhs).R) + ((*rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,AdditiveBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\AdditiveBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min (255' ((*lhs).B) + ((*rhs).B)); }; { fG = Math.Min (255' ((*lhs).G) + ((*rhs).G)); }; { fR = Math.Min (255' ((*lhs).R) + ((*rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,AdditiveBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\AdditiveBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min (255' ((*lhs).B) + ((*rhs).B)); }; { fG = Math.Min (255' ((*lhs).G) + ((*rhs).G)); }; { fR = Math.Min (255' ((*lhs).R) + ((*rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,AdditiveBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\AdditiveBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min (255' ((*lhs).B) + ((*rhs).B)); }; { fG = Math.Min (255' ((*lhs).G) + ((*rhs).G)); }; { fR = Math.Min (255' ((*lhs).R) + ((*rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,AdditiveBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\AdditiveBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min (255' ((*lhs).B) + ((*rhs).B)); }; { fG = Math.Min (255' ((*lhs).G) + ((*rhs).G)); }; { fR = Math.Min (255' ((*lhs).R) + ((*rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,AdditiveBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\AdditiveBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min (255' ((*lhs).B) + ((*rhs).B)); }; { fG = Math.Min (255' ((*lhs).G) + ((*rhs).G)); }; { fR = Math.Min (255' ((*lhs).R) + ((*rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,AdditiveBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\AdditiveBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min (255' ((*lhs).B) + ((*rhs).B)); }; { fG = Math.Min (255' ((*lhs).G) + ((*rhs).G)); }; { fR = Math.Min (255' ((*lhs).R) + ((*rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,AdditiveBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\AdditiveBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min (255' ((*lhs).B) + ((*rhs).B)); }; { fG = Math.Min (255' ((*lhs).G) + ((*rhs).G)); }; { fR = Math.Min (255' ((*lhs).R) + ((*rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,AdditiveBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\AdditiveBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min (255' ((*lhs).B) + ((*rhs).B)); }; { fG = Math.Min (255' ((*lhs).G) + ((*rhs).G)); }; { fR = Math.Min (255' ((*lhs).R) + ((*rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,AdditiveBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\AdditiveBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min (255' ((*lhs).B) + ((*rhs).B)); }; { fG = Math.Min (255' ((*lhs).G) + ((*rhs).G)); }; { fR = Math.Min (255' ((*lhs).R) + ((*rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,AdditiveBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\AdditiveBlendOp.cs,ApplyStatic,The following statement contains a magic number: { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,AdditiveBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\AdditiveBlendOp.cs,ApplyStatic,The following statement contains a magic number: { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,AdditiveBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\AdditiveBlendOp.cs,ApplyStatic,The following statement contains a magic number: { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,AdditiveBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\AdditiveBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min (255' ((lhs).B) + ((rhs).B)); }; { fG = Math.Min (255' ((lhs).G) + ((rhs).G)); }; { fR = Math.Min (255' ((lhs).R) + ((rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,AdditiveBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\AdditiveBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min (255' ((lhs).B) + ((rhs).B)); }; { fG = Math.Min (255' ((lhs).G) + ((rhs).G)); }; { fR = Math.Min (255' ((lhs).R) + ((rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,AdditiveBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\AdditiveBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min (255' ((lhs).B) + ((rhs).B)); }; { fG = Math.Min (255' ((lhs).G) + ((rhs).G)); }; { fR = Math.Min (255' ((lhs).R) + ((rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,AdditiveBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\AdditiveBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min (255' ((lhs).B) + ((rhs).B)); }; { fG = Math.Min (255' ((lhs).G) + ((rhs).G)); }; { fR = Math.Min (255' ((lhs).R) + ((rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,AdditiveBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\AdditiveBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min (255' ((lhs).B) + ((rhs).B)); }; { fG = Math.Min (255' ((lhs).G) + ((rhs).G)); }; { fR = Math.Min (255' ((lhs).R) + ((rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,AdditiveBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\AdditiveBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min (255' ((lhs).B) + ((rhs).B)); }; { fG = Math.Min (255' ((lhs).G) + ((rhs).G)); }; { fR = Math.Min (255' ((lhs).R) + ((rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,AdditiveBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\AdditiveBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min (255' ((lhs).B) + ((rhs).B)); }; { fG = Math.Min (255' ((lhs).G) + ((rhs).G)); }; { fR = Math.Min (255' ((lhs).R) + ((rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,AdditiveBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\AdditiveBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min (255' ((lhs).B) + ((rhs).B)); }; { fG = Math.Min (255' ((lhs).G) + ((rhs).G)); }; { fR = Math.Min (255' ((lhs).R) + ((rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,AdditiveBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\AdditiveBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min (255' ((lhs).B) + ((rhs).B)); }; { fG = Math.Min (255' ((lhs).G) + ((rhs).G)); }; { fR = Math.Min (255' ((lhs).R) + ((rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,AdditiveBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\AdditiveBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min (255' ((lhs).B) + ((rhs).B)); }; { fG = Math.Min (255' ((lhs).G) + ((rhs).G)); }; { fR = Math.Min (255' ((lhs).R) + ((rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,AdditiveBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\AdditiveBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min (255' ((lhs).B) + ((rhs).B)); }; { fG = Math.Min (255' ((lhs).G) + ((rhs).G)); }; { fR = Math.Min (255' ((lhs).R) + ((rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,AdditiveBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\AdditiveBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min (255' ((lhs).B) + ((rhs).B)); }; { fG = Math.Min (255' ((lhs).G) + ((rhs).G)); }; { fR = Math.Min (255' ((lhs).R) + ((rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,AdditiveBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\AdditiveBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min (255' ((lhs).B) + ((rhs).B)); }; { fG = Math.Min (255' ((lhs).G) + ((rhs).G)); }; { fR = Math.Min (255' ((lhs).R) + ((rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,AdditiveBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\AdditiveBlendOp.cs,ApplyOpacity,The following statement contains a magic number: { r = ((r) * (this.opacity) + 0x80); r = ((((r) >> 8) + (r)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,AdditiveBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\AdditiveBlendOp.cs,ApplyOpacity,The following statement contains a magic number: { r = ((r) * (this.opacity) + 0x80); r = ((((r) >> 8) + (r)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,AdditiveBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\AdditiveBlendOp.cs,Apply,The following statement contains a magic number: { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,AdditiveBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\AdditiveBlendOp.cs,Apply,The following statement contains a magic number: { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,AdditiveBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\AdditiveBlendOp.cs,Apply,The following statement contains a magic number: { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,AdditiveBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\AdditiveBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min (255' ((lhs).B) + ((rhs).B)); }; { fG = Math.Min (255' ((lhs).G) + ((rhs).G)); }; { fR = Math.Min (255' ((lhs).R) + ((rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,AdditiveBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\AdditiveBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min (255' ((lhs).B) + ((rhs).B)); }; { fG = Math.Min (255' ((lhs).G) + ((rhs).G)); }; { fR = Math.Min (255' ((lhs).R) + ((rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,AdditiveBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\AdditiveBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min (255' ((lhs).B) + ((rhs).B)); }; { fG = Math.Min (255' ((lhs).G) + ((rhs).G)); }; { fR = Math.Min (255' ((lhs).R) + ((rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,AdditiveBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\AdditiveBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min (255' ((lhs).B) + ((rhs).B)); }; { fG = Math.Min (255' ((lhs).G) + ((rhs).G)); }; { fR = Math.Min (255' ((lhs).R) + ((rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,AdditiveBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\AdditiveBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min (255' ((lhs).B) + ((rhs).B)); }; { fG = Math.Min (255' ((lhs).G) + ((rhs).G)); }; { fR = Math.Min (255' ((lhs).R) + ((rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,AdditiveBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\AdditiveBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min (255' ((lhs).B) + ((rhs).B)); }; { fG = Math.Min (255' ((lhs).G) + ((rhs).G)); }; { fR = Math.Min (255' ((lhs).R) + ((rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,AdditiveBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\AdditiveBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min (255' ((lhs).B) + ((rhs).B)); }; { fG = Math.Min (255' ((lhs).G) + ((rhs).G)); }; { fR = Math.Min (255' ((lhs).R) + ((rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,AdditiveBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\AdditiveBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min (255' ((lhs).B) + ((rhs).B)); }; { fG = Math.Min (255' ((lhs).G) + ((rhs).G)); }; { fR = Math.Min (255' ((lhs).R) + ((rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,AdditiveBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\AdditiveBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min (255' ((lhs).B) + ((rhs).B)); }; { fG = Math.Min (255' ((lhs).G) + ((rhs).G)); }; { fR = Math.Min (255' ((lhs).R) + ((rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,AdditiveBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\AdditiveBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min (255' ((lhs).B) + ((rhs).B)); }; { fG = Math.Min (255' ((lhs).G) + ((rhs).G)); }; { fR = Math.Min (255' ((lhs).R) + ((rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,AdditiveBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\AdditiveBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min (255' ((lhs).B) + ((rhs).B)); }; { fG = Math.Min (255' ((lhs).G) + ((rhs).G)); }; { fR = Math.Min (255' ((lhs).R) + ((rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,AdditiveBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\AdditiveBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min (255' ((lhs).B) + ((rhs).B)); }; { fG = Math.Min (255' ((lhs).G) + ((rhs).G)); }; { fR = Math.Min (255' ((lhs).R) + ((rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,AdditiveBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\AdditiveBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min (255' ((lhs).B) + ((rhs).B)); }; { fG = Math.Min (255' ((lhs).G) + ((rhs).G)); }; { fR = Math.Min (255' ((lhs).R) + ((rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,AdditiveBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\AdditiveBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min (255' ((*dst).B) + ((*src).B)); }; { fG = Math.Min (255' ((*dst).G) + ((*src).G)); }; { fR = Math.Min (255' ((*dst).R) + ((*src).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,AdditiveBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\AdditiveBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min (255' ((*dst).B) + ((*src).B)); }; { fG = Math.Min (255' ((*dst).G) + ((*src).G)); }; { fR = Math.Min (255' ((*dst).R) + ((*src).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,AdditiveBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\AdditiveBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min (255' ((*dst).B) + ((*src).B)); }; { fG = Math.Min (255' ((*dst).G) + ((*src).G)); }; { fR = Math.Min (255' ((*dst).R) + ((*src).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,AdditiveBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\AdditiveBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min (255' ((*dst).B) + ((*src).B)); }; { fG = Math.Min (255' ((*dst).G) + ((*src).G)); }; { fR = Math.Min (255' ((*dst).R) + ((*src).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,AdditiveBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\AdditiveBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min (255' ((*dst).B) + ((*src).B)); }; { fG = Math.Min (255' ((*dst).G) + ((*src).G)); }; { fR = Math.Min (255' ((*dst).R) + ((*src).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,AdditiveBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\AdditiveBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min (255' ((*dst).B) + ((*src).B)); }; { fG = Math.Min (255' ((*dst).G) + ((*src).G)); }; { fR = Math.Min (255' ((*dst).R) + ((*src).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,AdditiveBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\AdditiveBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min (255' ((*dst).B) + ((*src).B)); }; { fG = Math.Min (255' ((*dst).G) + ((*src).G)); }; { fR = Math.Min (255' ((*dst).R) + ((*src).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,AdditiveBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\AdditiveBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min (255' ((*dst).B) + ((*src).B)); }; { fG = Math.Min (255' ((*dst).G) + ((*src).G)); }; { fR = Math.Min (255' ((*dst).R) + ((*src).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,AdditiveBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\AdditiveBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min (255' ((*dst).B) + ((*src).B)); }; { fG = Math.Min (255' ((*dst).G) + ((*src).G)); }; { fR = Math.Min (255' ((*dst).R) + ((*src).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,AdditiveBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\AdditiveBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min (255' ((*dst).B) + ((*src).B)); }; { fG = Math.Min (255' ((*dst).G) + ((*src).G)); }; { fR = Math.Min (255' ((*dst).R) + ((*src).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,AdditiveBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\AdditiveBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min (255' ((*dst).B) + ((*src).B)); }; { fG = Math.Min (255' ((*dst).G) + ((*src).G)); }; { fR = Math.Min (255' ((*dst).R) + ((*src).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,AdditiveBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\AdditiveBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min (255' ((*dst).B) + ((*src).B)); }; { fG = Math.Min (255' ((*dst).G) + ((*src).G)); }; { fR = Math.Min (255' ((*dst).R) + ((*src).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,AdditiveBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\AdditiveBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min (255' ((*dst).B) + ((*src).B)); }; { fG = Math.Min (255' ((*dst).G) + ((*src).G)); }; { fR = Math.Min (255' ((*dst).R) + ((*src).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,AdditiveBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\AdditiveBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min (255' ((*dst).B) + ((*src).B)); }; { fG = Math.Min (255' ((*dst).G) + ((*src).G)); }; { fR = Math.Min (255' ((*dst).R) + ((*src).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,AdditiveBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\AdditiveBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min (255' ((*dst).B) + ((*src).B)); }; { fG = Math.Min (255' ((*dst).G) + ((*src).G)); }; { fR = Math.Min (255' ((*dst).R) + ((*src).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,AdditiveBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\AdditiveBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min (255' ((*dst).B) + ((*src).B)); }; { fG = Math.Min (255' ((*dst).G) + ((*src).G)); }; { fR = Math.Min (255' ((*dst).R) + ((*src).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,AdditiveBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\AdditiveBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min (255' ((*lhs).B) + ((*rhs).B)); }; { fG = Math.Min (255' ((*lhs).G) + ((*rhs).G)); }; { fR = Math.Min (255' ((*lhs).R) + ((*rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,AdditiveBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\AdditiveBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min (255' ((*lhs).B) + ((*rhs).B)); }; { fG = Math.Min (255' ((*lhs).G) + ((*rhs).G)); }; { fR = Math.Min (255' ((*lhs).R) + ((*rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,AdditiveBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\AdditiveBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min (255' ((*lhs).B) + ((*rhs).B)); }; { fG = Math.Min (255' ((*lhs).G) + ((*rhs).G)); }; { fR = Math.Min (255' ((*lhs).R) + ((*rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,AdditiveBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\AdditiveBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min (255' ((*lhs).B) + ((*rhs).B)); }; { fG = Math.Min (255' ((*lhs).G) + ((*rhs).G)); }; { fR = Math.Min (255' ((*lhs).R) + ((*rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,AdditiveBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\AdditiveBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min (255' ((*lhs).B) + ((*rhs).B)); }; { fG = Math.Min (255' ((*lhs).G) + ((*rhs).G)); }; { fR = Math.Min (255' ((*lhs).R) + ((*rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,AdditiveBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\AdditiveBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min (255' ((*lhs).B) + ((*rhs).B)); }; { fG = Math.Min (255' ((*lhs).G) + ((*rhs).G)); }; { fR = Math.Min (255' ((*lhs).R) + ((*rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,AdditiveBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\AdditiveBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min (255' ((*lhs).B) + ((*rhs).B)); }; { fG = Math.Min (255' ((*lhs).G) + ((*rhs).G)); }; { fR = Math.Min (255' ((*lhs).R) + ((*rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,AdditiveBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\AdditiveBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min (255' ((*lhs).B) + ((*rhs).B)); }; { fG = Math.Min (255' ((*lhs).G) + ((*rhs).G)); }; { fR = Math.Min (255' ((*lhs).R) + ((*rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,AdditiveBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\AdditiveBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min (255' ((*lhs).B) + ((*rhs).B)); }; { fG = Math.Min (255' ((*lhs).G) + ((*rhs).G)); }; { fR = Math.Min (255' ((*lhs).R) + ((*rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,AdditiveBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\AdditiveBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min (255' ((*lhs).B) + ((*rhs).B)); }; { fG = Math.Min (255' ((*lhs).G) + ((*rhs).G)); }; { fR = Math.Min (255' ((*lhs).R) + ((*rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,AdditiveBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\AdditiveBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min (255' ((*lhs).B) + ((*rhs).B)); }; { fG = Math.Min (255' ((*lhs).G) + ((*rhs).G)); }; { fR = Math.Min (255' ((*lhs).R) + ((*rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,AdditiveBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\AdditiveBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min (255' ((*lhs).B) + ((*rhs).B)); }; { fG = Math.Min (255' ((*lhs).G) + ((*rhs).G)); }; { fR = Math.Min (255' ((*lhs).R) + ((*rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,AdditiveBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\AdditiveBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min (255' ((*lhs).B) + ((*rhs).B)); }; { fG = Math.Min (255' ((*lhs).G) + ((*rhs).G)); }; { fR = Math.Min (255' ((*lhs).R) + ((*rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,AdditiveBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\AdditiveBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min (255' ((*lhs).B) + ((*rhs).B)); }; { fG = Math.Min (255' ((*lhs).G) + ((*rhs).G)); }; { fR = Math.Min (255' ((*lhs).R) + ((*rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,AdditiveBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\AdditiveBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min (255' ((*lhs).B) + ((*rhs).B)); }; { fG = Math.Min (255' ((*lhs).G) + ((*rhs).G)); }; { fR = Math.Min (255' ((*lhs).R) + ((*rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,AdditiveBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\AdditiveBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min (255' ((*lhs).B) + ((*rhs).B)); }; { fG = Math.Min (255' ((*lhs).G) + ((*rhs).G)); }; { fR = Math.Min (255' ((*lhs).R) + ((*rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,AdditiveBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\AdditiveBlendOp.cs,AdditiveBlendOpWithOpacity,The following statement contains a magic number: if (this.opacity < 0 || this.opacity > 255) { throw new ArgumentOutOfRangeException (); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 0) { fB = 0; } else { { int i = (((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((rhs).G) == 0) { fG = 0; } else { { int i = (((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((rhs).R) == 0) { fR = 0; } else { { int i = (((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 0) { fB = 0; } else { { int i = (((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((rhs).G) == 0) { fG = 0; } else { { int i = (((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((rhs).R) == 0) { fR = 0; } else { { int i = (((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 0) { fB = 0; } else { { int i = (((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((rhs).G) == 0) { fG = 0; } else { { int i = (((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((rhs).R) == 0) { fR = 0; } else { { int i = (((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 0) { fB = 0; } else { { int i = (((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((rhs).G) == 0) { fG = 0; } else { { int i = (((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((rhs).R) == 0) { fR = 0; } else { { int i = (((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 0) { fB = 0; } else { { int i = (((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((rhs).G) == 0) { fG = 0; } else { { int i = (((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((rhs).R) == 0) { fR = 0; } else { { int i = (((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 0) { fB = 0; } else { { int i = (((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((rhs).G) == 0) { fG = 0; } else { { int i = (((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((rhs).R) == 0) { fR = 0; } else { { int i = (((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 0) { fB = 0; } else { { int i = (((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((rhs).G) == 0) { fG = 0; } else { { int i = (((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((rhs).R) == 0) { fR = 0; } else { { int i = (((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 0) { fB = 0; } else { { int i = (((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((rhs).G) == 0) { fG = 0; } else { { int i = (((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((rhs).R) == 0) { fR = 0; } else { { int i = (((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 0) { fB = 0; } else { { int i = (((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((rhs).G) == 0) { fG = 0; } else { { int i = (((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((rhs).R) == 0) { fR = 0; } else { { int i = (((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 0) { fB = 0; } else { { int i = (((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((rhs).G) == 0) { fG = 0; } else { { int i = (((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((rhs).R) == 0) { fR = 0; } else { { int i = (((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 0) { fB = 0; } else { { int i = (((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((rhs).G) == 0) { fG = 0; } else { { int i = (((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((rhs).R) == 0) { fR = 0; } else { { int i = (((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 0) { fB = 0; } else { { int i = (((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((rhs).G) == 0) { fG = 0; } else { { int i = (((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((rhs).R) == 0) { fR = 0; } else { { int i = (((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 0) { fB = 0; } else { { int i = (((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((rhs).G) == 0) { fG = 0; } else { { int i = (((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((rhs).R) == 0) { fR = 0; } else { { int i = (((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 0) { fB = 0; } else { { int i = (((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((rhs).G) == 0) { fG = 0; } else { { int i = (((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((rhs).R) == 0) { fR = 0; } else { { int i = (((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 0) { fB = 0; } else { { int i = (((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((rhs).G) == 0) { fG = 0; } else { { int i = (((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((rhs).R) == 0) { fR = 0; } else { { int i = (((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 0) { fB = 0; } else { { int i = (((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((rhs).G) == 0) { fG = 0; } else { { int i = (((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((rhs).R) == 0) { fR = 0; } else { { int i = (((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 0) { fB = 0; } else { { int i = (((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((rhs).G) == 0) { fG = 0; } else { { int i = (((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((rhs).R) == 0) { fR = 0; } else { { int i = (((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 0) { fB = 0; } else { { int i = (((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((rhs).G) == 0) { fG = 0; } else { { int i = (((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((rhs).R) == 0) { fR = 0; } else { { int i = (((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 0) { fB = 0; } else { { int i = (((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((rhs).G) == 0) { fG = 0; } else { { int i = (((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((rhs).R) == 0) { fR = 0; } else { { int i = (((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 0) { fB = 0; } else { { int i = (((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((rhs).G) == 0) { fG = 0; } else { { int i = (((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((rhs).R) == 0) { fR = 0; } else { { int i = (((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 0) { fB = 0; } else { { int i = (((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((rhs).G) == 0) { fG = 0; } else { { int i = (((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((rhs).R) == 0) { fR = 0; } else { { int i = (((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 0) { fB = 0; } else { { int i = (((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((rhs).G) == 0) { fG = 0; } else { { int i = (((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((rhs).R) == 0) { fR = 0; } else { { int i = (((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 0) { fB = 0; } else { { int i = (((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((rhs).G) == 0) { fG = 0; } else { { int i = (((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((rhs).R) == 0) { fR = 0; } else { { int i = (((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 0) { fB = 0; } else { { int i = (((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((rhs).G) == 0) { fG = 0; } else { { int i = (((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((rhs).R) == 0) { fR = 0; } else { { int i = (((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 0) { fB = 0; } else { { int i = (((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((rhs).G) == 0) { fG = 0; } else { { int i = (((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((rhs).R) == 0) { fR = 0; } else { { int i = (((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 0) { fB = 0; } else { { int i = (((*src).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((*dst).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((*src).G) == 0) { fG = 0; } else { { int i = (((*src).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((*dst).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((*src).R) == 0) { fR = 0; } else { { int i = (((*src).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((*dst).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 0) { fB = 0; } else { { int i = (((*src).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((*dst).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((*src).G) == 0) { fG = 0; } else { { int i = (((*src).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((*dst).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((*src).R) == 0) { fR = 0; } else { { int i = (((*src).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((*dst).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 0) { fB = 0; } else { { int i = (((*src).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((*dst).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((*src).G) == 0) { fG = 0; } else { { int i = (((*src).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((*dst).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((*src).R) == 0) { fR = 0; } else { { int i = (((*src).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((*dst).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 0) { fB = 0; } else { { int i = (((*src).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((*dst).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((*src).G) == 0) { fG = 0; } else { { int i = (((*src).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((*dst).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((*src).R) == 0) { fR = 0; } else { { int i = (((*src).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((*dst).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 0) { fB = 0; } else { { int i = (((*src).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((*dst).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((*src).G) == 0) { fG = 0; } else { { int i = (((*src).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((*dst).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((*src).R) == 0) { fR = 0; } else { { int i = (((*src).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((*dst).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 0) { fB = 0; } else { { int i = (((*src).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((*dst).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((*src).G) == 0) { fG = 0; } else { { int i = (((*src).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((*dst).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((*src).R) == 0) { fR = 0; } else { { int i = (((*src).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((*dst).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 0) { fB = 0; } else { { int i = (((*src).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((*dst).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((*src).G) == 0) { fG = 0; } else { { int i = (((*src).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((*dst).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((*src).R) == 0) { fR = 0; } else { { int i = (((*src).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((*dst).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 0) { fB = 0; } else { { int i = (((*src).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((*dst).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((*src).G) == 0) { fG = 0; } else { { int i = (((*src).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((*dst).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((*src).R) == 0) { fR = 0; } else { { int i = (((*src).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((*dst).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 0) { fB = 0; } else { { int i = (((*src).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((*dst).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((*src).G) == 0) { fG = 0; } else { { int i = (((*src).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((*dst).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((*src).R) == 0) { fR = 0; } else { { int i = (((*src).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((*dst).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 0) { fB = 0; } else { { int i = (((*src).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((*dst).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((*src).G) == 0) { fG = 0; } else { { int i = (((*src).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((*dst).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((*src).R) == 0) { fR = 0; } else { { int i = (((*src).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((*dst).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 0) { fB = 0; } else { { int i = (((*src).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((*dst).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((*src).G) == 0) { fG = 0; } else { { int i = (((*src).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((*dst).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((*src).R) == 0) { fR = 0; } else { { int i = (((*src).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((*dst).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 0) { fB = 0; } else { { int i = (((*src).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((*dst).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((*src).G) == 0) { fG = 0; } else { { int i = (((*src).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((*dst).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((*src).R) == 0) { fR = 0; } else { { int i = (((*src).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((*dst).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 0) { fB = 0; } else { { int i = (((*src).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((*dst).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((*src).G) == 0) { fG = 0; } else { { int i = (((*src).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((*dst).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((*src).R) == 0) { fR = 0; } else { { int i = (((*src).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((*dst).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 0) { fB = 0; } else { { int i = (((*src).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((*dst).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((*src).G) == 0) { fG = 0; } else { { int i = (((*src).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((*dst).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((*src).R) == 0) { fR = 0; } else { { int i = (((*src).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((*dst).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 0) { fB = 0; } else { { int i = (((*src).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((*dst).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((*src).G) == 0) { fG = 0; } else { { int i = (((*src).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((*dst).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((*src).R) == 0) { fR = 0; } else { { int i = (((*src).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((*dst).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 0) { fB = 0; } else { { int i = (((*src).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((*dst).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((*src).G) == 0) { fG = 0; } else { { int i = (((*src).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((*dst).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((*src).R) == 0) { fR = 0; } else { { int i = (((*src).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((*dst).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 0) { fB = 0; } else { { int i = (((*src).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((*dst).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((*src).G) == 0) { fG = 0; } else { { int i = (((*src).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((*dst).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((*src).R) == 0) { fR = 0; } else { { int i = (((*src).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((*dst).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 0) { fB = 0; } else { { int i = (((*src).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((*dst).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((*src).G) == 0) { fG = 0; } else { { int i = (((*src).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((*dst).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((*src).R) == 0) { fR = 0; } else { { int i = (((*src).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((*dst).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 0) { fB = 0; } else { { int i = (((*src).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((*dst).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((*src).G) == 0) { fG = 0; } else { { int i = (((*src).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((*dst).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((*src).R) == 0) { fR = 0; } else { { int i = (((*src).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((*dst).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 0) { fB = 0; } else { { int i = (((*src).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((*dst).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((*src).G) == 0) { fG = 0; } else { { int i = (((*src).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((*dst).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((*src).R) == 0) { fR = 0; } else { { int i = (((*src).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((*dst).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 0) { fB = 0; } else { { int i = (((*src).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((*dst).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((*src).G) == 0) { fG = 0; } else { { int i = (((*src).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((*dst).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((*src).R) == 0) { fR = 0; } else { { int i = (((*src).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((*dst).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 0) { fB = 0; } else { { int i = (((*src).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((*dst).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((*src).G) == 0) { fG = 0; } else { { int i = (((*src).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((*dst).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((*src).R) == 0) { fR = 0; } else { { int i = (((*src).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((*dst).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 0) { fB = 0; } else { { int i = (((*src).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((*dst).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((*src).G) == 0) { fG = 0; } else { { int i = (((*src).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((*dst).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((*src).R) == 0) { fR = 0; } else { { int i = (((*src).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((*dst).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 0) { fB = 0; } else { { int i = (((*src).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((*dst).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((*src).G) == 0) { fG = 0; } else { { int i = (((*src).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((*dst).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((*src).R) == 0) { fR = 0; } else { { int i = (((*src).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((*dst).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 0) { fB = 0; } else { { int i = (((*src).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((*dst).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((*src).G) == 0) { fG = 0; } else { { int i = (((*src).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((*dst).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((*src).R) == 0) { fR = 0; } else { { int i = (((*src).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((*dst).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 0) { fB = 0; } else { { int i = (((*src).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((*dst).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((*src).G) == 0) { fG = 0; } else { { int i = (((*src).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((*dst).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((*src).R) == 0) { fR = 0; } else { { int i = (((*src).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((*dst).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 0) { fB = 0; } else { { int i = (((*src).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((*dst).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((*src).G) == 0) { fG = 0; } else { { int i = (((*src).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((*dst).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((*src).R) == 0) { fR = 0; } else { { int i = (((*src).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((*dst).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 0) { fB = 0; } else { { int i = (((*src).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((*dst).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((*src).G) == 0) { fG = 0; } else { { int i = (((*src).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((*dst).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((*src).R) == 0) { fR = 0; } else { { int i = (((*src).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((*dst).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 0) { fB = 0; } else { { int i = (((*rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((*lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((*rhs).G) == 0) { fG = 0; } else { { int i = (((*rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((*lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((*rhs).R) == 0) { fR = 0; } else { { int i = (((*rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((*lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 0) { fB = 0; } else { { int i = (((*rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((*lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((*rhs).G) == 0) { fG = 0; } else { { int i = (((*rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((*lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((*rhs).R) == 0) { fR = 0; } else { { int i = (((*rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((*lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 0) { fB = 0; } else { { int i = (((*rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((*lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((*rhs).G) == 0) { fG = 0; } else { { int i = (((*rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((*lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((*rhs).R) == 0) { fR = 0; } else { { int i = (((*rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((*lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 0) { fB = 0; } else { { int i = (((*rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((*lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((*rhs).G) == 0) { fG = 0; } else { { int i = (((*rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((*lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((*rhs).R) == 0) { fR = 0; } else { { int i = (((*rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((*lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 0) { fB = 0; } else { { int i = (((*rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((*lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((*rhs).G) == 0) { fG = 0; } else { { int i = (((*rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((*lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((*rhs).R) == 0) { fR = 0; } else { { int i = (((*rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((*lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 0) { fB = 0; } else { { int i = (((*rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((*lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((*rhs).G) == 0) { fG = 0; } else { { int i = (((*rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((*lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((*rhs).R) == 0) { fR = 0; } else { { int i = (((*rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((*lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 0) { fB = 0; } else { { int i = (((*rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((*lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((*rhs).G) == 0) { fG = 0; } else { { int i = (((*rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((*lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((*rhs).R) == 0) { fR = 0; } else { { int i = (((*rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((*lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 0) { fB = 0; } else { { int i = (((*rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((*lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((*rhs).G) == 0) { fG = 0; } else { { int i = (((*rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((*lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((*rhs).R) == 0) { fR = 0; } else { { int i = (((*rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((*lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 0) { fB = 0; } else { { int i = (((*rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((*lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((*rhs).G) == 0) { fG = 0; } else { { int i = (((*rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((*lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((*rhs).R) == 0) { fR = 0; } else { { int i = (((*rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((*lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 0) { fB = 0; } else { { int i = (((*rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((*lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((*rhs).G) == 0) { fG = 0; } else { { int i = (((*rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((*lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((*rhs).R) == 0) { fR = 0; } else { { int i = (((*rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((*lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 0) { fB = 0; } else { { int i = (((*rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((*lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((*rhs).G) == 0) { fG = 0; } else { { int i = (((*rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((*lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((*rhs).R) == 0) { fR = 0; } else { { int i = (((*rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((*lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 0) { fB = 0; } else { { int i = (((*rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((*lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((*rhs).G) == 0) { fG = 0; } else { { int i = (((*rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((*lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((*rhs).R) == 0) { fR = 0; } else { { int i = (((*rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((*lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 0) { fB = 0; } else { { int i = (((*rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((*lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((*rhs).G) == 0) { fG = 0; } else { { int i = (((*rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((*lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((*rhs).R) == 0) { fR = 0; } else { { int i = (((*rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((*lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 0) { fB = 0; } else { { int i = (((*rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((*lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((*rhs).G) == 0) { fG = 0; } else { { int i = (((*rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((*lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((*rhs).R) == 0) { fR = 0; } else { { int i = (((*rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((*lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 0) { fB = 0; } else { { int i = (((*rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((*lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((*rhs).G) == 0) { fG = 0; } else { { int i = (((*rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((*lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((*rhs).R) == 0) { fR = 0; } else { { int i = (((*rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((*lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 0) { fB = 0; } else { { int i = (((*rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((*lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((*rhs).G) == 0) { fG = 0; } else { { int i = (((*rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((*lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((*rhs).R) == 0) { fR = 0; } else { { int i = (((*rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((*lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 0) { fB = 0; } else { { int i = (((*rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((*lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((*rhs).G) == 0) { fG = 0; } else { { int i = (((*rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((*lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((*rhs).R) == 0) { fR = 0; } else { { int i = (((*rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((*lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 0) { fB = 0; } else { { int i = (((*rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((*lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((*rhs).G) == 0) { fG = 0; } else { { int i = (((*rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((*lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((*rhs).R) == 0) { fR = 0; } else { { int i = (((*rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((*lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 0) { fB = 0; } else { { int i = (((*rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((*lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((*rhs).G) == 0) { fG = 0; } else { { int i = (((*rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((*lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((*rhs).R) == 0) { fR = 0; } else { { int i = (((*rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((*lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 0) { fB = 0; } else { { int i = (((*rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((*lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((*rhs).G) == 0) { fG = 0; } else { { int i = (((*rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((*lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((*rhs).R) == 0) { fR = 0; } else { { int i = (((*rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((*lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 0) { fB = 0; } else { { int i = (((*rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((*lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((*rhs).G) == 0) { fG = 0; } else { { int i = (((*rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((*lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((*rhs).R) == 0) { fR = 0; } else { { int i = (((*rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((*lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 0) { fB = 0; } else { { int i = (((*rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((*lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((*rhs).G) == 0) { fG = 0; } else { { int i = (((*rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((*lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((*rhs).R) == 0) { fR = 0; } else { { int i = (((*rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((*lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 0) { fB = 0; } else { { int i = (((*rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((*lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((*rhs).G) == 0) { fG = 0; } else { { int i = (((*rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((*lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((*rhs).R) == 0) { fR = 0; } else { { int i = (((*rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((*lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 0) { fB = 0; } else { { int i = (((*rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((*lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((*rhs).G) == 0) { fG = 0; } else { { int i = (((*rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((*lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((*rhs).R) == 0) { fR = 0; } else { { int i = (((*rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((*lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 0) { fB = 0; } else { { int i = (((*rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((*lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((*rhs).G) == 0) { fG = 0; } else { { int i = (((*rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((*lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((*rhs).R) == 0) { fR = 0; } else { { int i = (((*rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((*lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 0) { fB = 0; } else { { int i = (((*rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((*lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((*rhs).G) == 0) { fG = 0; } else { { int i = (((*rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((*lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((*rhs).R) == 0) { fR = 0; } else { { int i = (((*rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((*lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 0) { fB = 0; } else { { int i = (((*rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((*lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((*rhs).G) == 0) { fG = 0; } else { { int i = (((*rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((*lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((*rhs).R) == 0) { fR = 0; } else { { int i = (((*rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((*lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 0) { fB = 0; } else { { int i = (((*rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((*lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((*rhs).G) == 0) { fG = 0; } else { { int i = (((*rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((*lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((*rhs).R) == 0) { fR = 0; } else { { int i = (((*rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((*lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,ApplyStatic,The following statement contains a magic number: { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,ApplyStatic,The following statement contains a magic number: { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,ApplyStatic,The following statement contains a magic number: { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 0) { fB = 0; } else { { int i = (((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((rhs).G) == 0) { fG = 0; } else { { int i = (((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((rhs).R) == 0) { fR = 0; } else { { int i = (((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 0) { fB = 0; } else { { int i = (((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((rhs).G) == 0) { fG = 0; } else { { int i = (((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((rhs).R) == 0) { fR = 0; } else { { int i = (((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 0) { fB = 0; } else { { int i = (((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((rhs).G) == 0) { fG = 0; } else { { int i = (((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((rhs).R) == 0) { fR = 0; } else { { int i = (((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 0) { fB = 0; } else { { int i = (((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((rhs).G) == 0) { fG = 0; } else { { int i = (((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((rhs).R) == 0) { fR = 0; } else { { int i = (((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 0) { fB = 0; } else { { int i = (((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((rhs).G) == 0) { fG = 0; } else { { int i = (((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((rhs).R) == 0) { fR = 0; } else { { int i = (((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 0) { fB = 0; } else { { int i = (((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((rhs).G) == 0) { fG = 0; } else { { int i = (((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((rhs).R) == 0) { fR = 0; } else { { int i = (((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 0) { fB = 0; } else { { int i = (((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((rhs).G) == 0) { fG = 0; } else { { int i = (((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((rhs).R) == 0) { fR = 0; } else { { int i = (((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 0) { fB = 0; } else { { int i = (((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((rhs).G) == 0) { fG = 0; } else { { int i = (((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((rhs).R) == 0) { fR = 0; } else { { int i = (((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 0) { fB = 0; } else { { int i = (((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((rhs).G) == 0) { fG = 0; } else { { int i = (((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((rhs).R) == 0) { fR = 0; } else { { int i = (((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 0) { fB = 0; } else { { int i = (((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((rhs).G) == 0) { fG = 0; } else { { int i = (((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((rhs).R) == 0) { fR = 0; } else { { int i = (((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 0) { fB = 0; } else { { int i = (((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((rhs).G) == 0) { fG = 0; } else { { int i = (((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((rhs).R) == 0) { fR = 0; } else { { int i = (((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 0) { fB = 0; } else { { int i = (((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((rhs).G) == 0) { fG = 0; } else { { int i = (((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((rhs).R) == 0) { fR = 0; } else { { int i = (((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 0) { fB = 0; } else { { int i = (((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((rhs).G) == 0) { fG = 0; } else { { int i = (((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((rhs).R) == 0) { fR = 0; } else { { int i = (((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 0) { fB = 0; } else { { int i = (((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((rhs).G) == 0) { fG = 0; } else { { int i = (((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((rhs).R) == 0) { fR = 0; } else { { int i = (((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 0) { fB = 0; } else { { int i = (((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((rhs).G) == 0) { fG = 0; } else { { int i = (((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((rhs).R) == 0) { fR = 0; } else { { int i = (((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 0) { fB = 0; } else { { int i = (((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((rhs).G) == 0) { fG = 0; } else { { int i = (((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((rhs).R) == 0) { fR = 0; } else { { int i = (((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 0) { fB = 0; } else { { int i = (((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((rhs).G) == 0) { fG = 0; } else { { int i = (((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((rhs).R) == 0) { fR = 0; } else { { int i = (((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 0) { fB = 0; } else { { int i = (((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((rhs).G) == 0) { fG = 0; } else { { int i = (((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((rhs).R) == 0) { fR = 0; } else { { int i = (((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 0) { fB = 0; } else { { int i = (((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((rhs).G) == 0) { fG = 0; } else { { int i = (((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((rhs).R) == 0) { fR = 0; } else { { int i = (((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 0) { fB = 0; } else { { int i = (((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((rhs).G) == 0) { fG = 0; } else { { int i = (((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((rhs).R) == 0) { fR = 0; } else { { int i = (((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 0) { fB = 0; } else { { int i = (((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((rhs).G) == 0) { fG = 0; } else { { int i = (((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((rhs).R) == 0) { fR = 0; } else { { int i = (((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 0) { fB = 0; } else { { int i = (((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((rhs).G) == 0) { fG = 0; } else { { int i = (((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((rhs).R) == 0) { fR = 0; } else { { int i = (((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 0) { fB = 0; } else { { int i = (((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((rhs).G) == 0) { fG = 0; } else { { int i = (((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((rhs).R) == 0) { fR = 0; } else { { int i = (((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 0) { fB = 0; } else { { int i = (((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((rhs).G) == 0) { fG = 0; } else { { int i = (((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((rhs).R) == 0) { fR = 0; } else { { int i = (((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 0) { fB = 0; } else { { int i = (((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((rhs).G) == 0) { fG = 0; } else { { int i = (((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((rhs).R) == 0) { fR = 0; } else { { int i = (((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,ApplyOpacity,The following statement contains a magic number: { r = ((r) * (this.opacity) + 0x80); r = ((((r) >> 8) + (r)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,ApplyOpacity,The following statement contains a magic number: { r = ((r) * (this.opacity) + 0x80); r = ((((r) >> 8) + (r)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 0) { fB = 0; } else { { int i = (((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((rhs).G) == 0) { fG = 0; } else { { int i = (((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((rhs).R) == 0) { fR = 0; } else { { int i = (((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 0) { fB = 0; } else { { int i = (((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((rhs).G) == 0) { fG = 0; } else { { int i = (((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((rhs).R) == 0) { fR = 0; } else { { int i = (((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 0) { fB = 0; } else { { int i = (((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((rhs).G) == 0) { fG = 0; } else { { int i = (((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((rhs).R) == 0) { fR = 0; } else { { int i = (((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 0) { fB = 0; } else { { int i = (((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((rhs).G) == 0) { fG = 0; } else { { int i = (((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((rhs).R) == 0) { fR = 0; } else { { int i = (((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 0) { fB = 0; } else { { int i = (((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((rhs).G) == 0) { fG = 0; } else { { int i = (((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((rhs).R) == 0) { fR = 0; } else { { int i = (((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 0) { fB = 0; } else { { int i = (((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((rhs).G) == 0) { fG = 0; } else { { int i = (((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((rhs).R) == 0) { fR = 0; } else { { int i = (((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 0) { fB = 0; } else { { int i = (((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((rhs).G) == 0) { fG = 0; } else { { int i = (((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((rhs).R) == 0) { fR = 0; } else { { int i = (((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 0) { fB = 0; } else { { int i = (((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((rhs).G) == 0) { fG = 0; } else { { int i = (((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((rhs).R) == 0) { fR = 0; } else { { int i = (((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 0) { fB = 0; } else { { int i = (((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((rhs).G) == 0) { fG = 0; } else { { int i = (((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((rhs).R) == 0) { fR = 0; } else { { int i = (((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 0) { fB = 0; } else { { int i = (((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((rhs).G) == 0) { fG = 0; } else { { int i = (((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((rhs).R) == 0) { fR = 0; } else { { int i = (((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 0) { fB = 0; } else { { int i = (((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((rhs).G) == 0) { fG = 0; } else { { int i = (((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((rhs).R) == 0) { fR = 0; } else { { int i = (((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 0) { fB = 0; } else { { int i = (((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((rhs).G) == 0) { fG = 0; } else { { int i = (((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((rhs).R) == 0) { fR = 0; } else { { int i = (((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 0) { fB = 0; } else { { int i = (((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((rhs).G) == 0) { fG = 0; } else { { int i = (((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((rhs).R) == 0) { fR = 0; } else { { int i = (((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 0) { fB = 0; } else { { int i = (((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((rhs).G) == 0) { fG = 0; } else { { int i = (((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((rhs).R) == 0) { fR = 0; } else { { int i = (((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 0) { fB = 0; } else { { int i = (((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((rhs).G) == 0) { fG = 0; } else { { int i = (((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((rhs).R) == 0) { fR = 0; } else { { int i = (((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 0) { fB = 0; } else { { int i = (((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((rhs).G) == 0) { fG = 0; } else { { int i = (((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((rhs).R) == 0) { fR = 0; } else { { int i = (((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 0) { fB = 0; } else { { int i = (((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((rhs).G) == 0) { fG = 0; } else { { int i = (((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((rhs).R) == 0) { fR = 0; } else { { int i = (((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 0) { fB = 0; } else { { int i = (((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((rhs).G) == 0) { fG = 0; } else { { int i = (((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((rhs).R) == 0) { fR = 0; } else { { int i = (((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 0) { fB = 0; } else { { int i = (((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((rhs).G) == 0) { fG = 0; } else { { int i = (((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((rhs).R) == 0) { fR = 0; } else { { int i = (((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 0) { fB = 0; } else { { int i = (((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((rhs).G) == 0) { fG = 0; } else { { int i = (((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((rhs).R) == 0) { fR = 0; } else { { int i = (((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 0) { fB = 0; } else { { int i = (((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((rhs).G) == 0) { fG = 0; } else { { int i = (((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((rhs).R) == 0) { fR = 0; } else { { int i = (((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 0) { fB = 0; } else { { int i = (((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((rhs).G) == 0) { fG = 0; } else { { int i = (((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((rhs).R) == 0) { fR = 0; } else { { int i = (((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 0) { fB = 0; } else { { int i = (((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((rhs).G) == 0) { fG = 0; } else { { int i = (((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((rhs).R) == 0) { fR = 0; } else { { int i = (((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 0) { fB = 0; } else { { int i = (((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((rhs).G) == 0) { fG = 0; } else { { int i = (((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((rhs).R) == 0) { fR = 0; } else { { int i = (((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 0) { fB = 0; } else { { int i = (((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((rhs).G) == 0) { fG = 0; } else { { int i = (((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((rhs).R) == 0) { fR = 0; } else { { int i = (((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 0) { fB = 0; } else { { int i = (((*src).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((*dst).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((*src).G) == 0) { fG = 0; } else { { int i = (((*src).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((*dst).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((*src).R) == 0) { fR = 0; } else { { int i = (((*src).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((*dst).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 0) { fB = 0; } else { { int i = (((*src).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((*dst).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((*src).G) == 0) { fG = 0; } else { { int i = (((*src).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((*dst).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((*src).R) == 0) { fR = 0; } else { { int i = (((*src).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((*dst).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 0) { fB = 0; } else { { int i = (((*src).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((*dst).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((*src).G) == 0) { fG = 0; } else { { int i = (((*src).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((*dst).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((*src).R) == 0) { fR = 0; } else { { int i = (((*src).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((*dst).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 0) { fB = 0; } else { { int i = (((*src).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((*dst).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((*src).G) == 0) { fG = 0; } else { { int i = (((*src).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((*dst).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((*src).R) == 0) { fR = 0; } else { { int i = (((*src).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((*dst).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 0) { fB = 0; } else { { int i = (((*src).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((*dst).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((*src).G) == 0) { fG = 0; } else { { int i = (((*src).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((*dst).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((*src).R) == 0) { fR = 0; } else { { int i = (((*src).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((*dst).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 0) { fB = 0; } else { { int i = (((*src).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((*dst).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((*src).G) == 0) { fG = 0; } else { { int i = (((*src).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((*dst).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((*src).R) == 0) { fR = 0; } else { { int i = (((*src).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((*dst).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 0) { fB = 0; } else { { int i = (((*src).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((*dst).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((*src).G) == 0) { fG = 0; } else { { int i = (((*src).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((*dst).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((*src).R) == 0) { fR = 0; } else { { int i = (((*src).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((*dst).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 0) { fB = 0; } else { { int i = (((*src).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((*dst).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((*src).G) == 0) { fG = 0; } else { { int i = (((*src).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((*dst).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((*src).R) == 0) { fR = 0; } else { { int i = (((*src).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((*dst).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 0) { fB = 0; } else { { int i = (((*src).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((*dst).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((*src).G) == 0) { fG = 0; } else { { int i = (((*src).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((*dst).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((*src).R) == 0) { fR = 0; } else { { int i = (((*src).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((*dst).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 0) { fB = 0; } else { { int i = (((*src).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((*dst).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((*src).G) == 0) { fG = 0; } else { { int i = (((*src).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((*dst).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((*src).R) == 0) { fR = 0; } else { { int i = (((*src).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((*dst).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 0) { fB = 0; } else { { int i = (((*src).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((*dst).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((*src).G) == 0) { fG = 0; } else { { int i = (((*src).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((*dst).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((*src).R) == 0) { fR = 0; } else { { int i = (((*src).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((*dst).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 0) { fB = 0; } else { { int i = (((*src).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((*dst).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((*src).G) == 0) { fG = 0; } else { { int i = (((*src).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((*dst).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((*src).R) == 0) { fR = 0; } else { { int i = (((*src).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((*dst).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 0) { fB = 0; } else { { int i = (((*src).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((*dst).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((*src).G) == 0) { fG = 0; } else { { int i = (((*src).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((*dst).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((*src).R) == 0) { fR = 0; } else { { int i = (((*src).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((*dst).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 0) { fB = 0; } else { { int i = (((*src).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((*dst).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((*src).G) == 0) { fG = 0; } else { { int i = (((*src).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((*dst).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((*src).R) == 0) { fR = 0; } else { { int i = (((*src).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((*dst).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 0) { fB = 0; } else { { int i = (((*src).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((*dst).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((*src).G) == 0) { fG = 0; } else { { int i = (((*src).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((*dst).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((*src).R) == 0) { fR = 0; } else { { int i = (((*src).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((*dst).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 0) { fB = 0; } else { { int i = (((*src).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((*dst).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((*src).G) == 0) { fG = 0; } else { { int i = (((*src).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((*dst).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((*src).R) == 0) { fR = 0; } else { { int i = (((*src).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((*dst).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 0) { fB = 0; } else { { int i = (((*src).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((*dst).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((*src).G) == 0) { fG = 0; } else { { int i = (((*src).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((*dst).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((*src).R) == 0) { fR = 0; } else { { int i = (((*src).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((*dst).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 0) { fB = 0; } else { { int i = (((*src).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((*dst).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((*src).G) == 0) { fG = 0; } else { { int i = (((*src).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((*dst).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((*src).R) == 0) { fR = 0; } else { { int i = (((*src).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((*dst).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 0) { fB = 0; } else { { int i = (((*src).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((*dst).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((*src).G) == 0) { fG = 0; } else { { int i = (((*src).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((*dst).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((*src).R) == 0) { fR = 0; } else { { int i = (((*src).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((*dst).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 0) { fB = 0; } else { { int i = (((*src).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((*dst).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((*src).G) == 0) { fG = 0; } else { { int i = (((*src).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((*dst).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((*src).R) == 0) { fR = 0; } else { { int i = (((*src).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((*dst).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 0) { fB = 0; } else { { int i = (((*src).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((*dst).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((*src).G) == 0) { fG = 0; } else { { int i = (((*src).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((*dst).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((*src).R) == 0) { fR = 0; } else { { int i = (((*src).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((*dst).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 0) { fB = 0; } else { { int i = (((*src).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((*dst).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((*src).G) == 0) { fG = 0; } else { { int i = (((*src).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((*dst).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((*src).R) == 0) { fR = 0; } else { { int i = (((*src).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((*dst).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 0) { fB = 0; } else { { int i = (((*src).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((*dst).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((*src).G) == 0) { fG = 0; } else { { int i = (((*src).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((*dst).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((*src).R) == 0) { fR = 0; } else { { int i = (((*src).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((*dst).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 0) { fB = 0; } else { { int i = (((*src).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((*dst).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((*src).G) == 0) { fG = 0; } else { { int i = (((*src).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((*dst).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((*src).R) == 0) { fR = 0; } else { { int i = (((*src).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((*dst).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 0) { fB = 0; } else { { int i = (((*src).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((*dst).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((*src).G) == 0) { fG = 0; } else { { int i = (((*src).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((*dst).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((*src).R) == 0) { fR = 0; } else { { int i = (((*src).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((*dst).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 0) { fB = 0; } else { { int i = (((*src).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((*dst).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((*src).G) == 0) { fG = 0; } else { { int i = (((*src).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((*dst).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((*src).R) == 0) { fR = 0; } else { { int i = (((*src).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((*dst).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 0) { fB = 0; } else { { int i = (((*src).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((*dst).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((*src).G) == 0) { fG = 0; } else { { int i = (((*src).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((*dst).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((*src).R) == 0) { fR = 0; } else { { int i = (((*src).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((*dst).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 0) { fB = 0; } else { { int i = (((*src).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((*dst).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((*src).G) == 0) { fG = 0; } else { { int i = (((*src).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((*dst).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((*src).R) == 0) { fR = 0; } else { { int i = (((*src).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((*dst).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 0) { fB = 0; } else { { int i = (((*rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((*lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((*rhs).G) == 0) { fG = 0; } else { { int i = (((*rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((*lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((*rhs).R) == 0) { fR = 0; } else { { int i = (((*rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((*lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 0) { fB = 0; } else { { int i = (((*rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((*lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((*rhs).G) == 0) { fG = 0; } else { { int i = (((*rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((*lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((*rhs).R) == 0) { fR = 0; } else { { int i = (((*rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((*lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 0) { fB = 0; } else { { int i = (((*rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((*lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((*rhs).G) == 0) { fG = 0; } else { { int i = (((*rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((*lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((*rhs).R) == 0) { fR = 0; } else { { int i = (((*rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((*lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 0) { fB = 0; } else { { int i = (((*rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((*lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((*rhs).G) == 0) { fG = 0; } else { { int i = (((*rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((*lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((*rhs).R) == 0) { fR = 0; } else { { int i = (((*rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((*lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 0) { fB = 0; } else { { int i = (((*rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((*lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((*rhs).G) == 0) { fG = 0; } else { { int i = (((*rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((*lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((*rhs).R) == 0) { fR = 0; } else { { int i = (((*rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((*lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 0) { fB = 0; } else { { int i = (((*rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((*lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((*rhs).G) == 0) { fG = 0; } else { { int i = (((*rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((*lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((*rhs).R) == 0) { fR = 0; } else { { int i = (((*rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((*lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 0) { fB = 0; } else { { int i = (((*rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((*lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((*rhs).G) == 0) { fG = 0; } else { { int i = (((*rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((*lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((*rhs).R) == 0) { fR = 0; } else { { int i = (((*rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((*lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 0) { fB = 0; } else { { int i = (((*rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((*lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((*rhs).G) == 0) { fG = 0; } else { { int i = (((*rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((*lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((*rhs).R) == 0) { fR = 0; } else { { int i = (((*rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((*lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 0) { fB = 0; } else { { int i = (((*rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((*lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((*rhs).G) == 0) { fG = 0; } else { { int i = (((*rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((*lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((*rhs).R) == 0) { fR = 0; } else { { int i = (((*rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((*lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 0) { fB = 0; } else { { int i = (((*rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((*lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((*rhs).G) == 0) { fG = 0; } else { { int i = (((*rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((*lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((*rhs).R) == 0) { fR = 0; } else { { int i = (((*rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((*lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 0) { fB = 0; } else { { int i = (((*rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((*lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((*rhs).G) == 0) { fG = 0; } else { { int i = (((*rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((*lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((*rhs).R) == 0) { fR = 0; } else { { int i = (((*rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((*lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 0) { fB = 0; } else { { int i = (((*rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((*lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((*rhs).G) == 0) { fG = 0; } else { { int i = (((*rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((*lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((*rhs).R) == 0) { fR = 0; } else { { int i = (((*rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((*lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 0) { fB = 0; } else { { int i = (((*rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((*lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((*rhs).G) == 0) { fG = 0; } else { { int i = (((*rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((*lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((*rhs).R) == 0) { fR = 0; } else { { int i = (((*rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((*lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 0) { fB = 0; } else { { int i = (((*rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((*lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((*rhs).G) == 0) { fG = 0; } else { { int i = (((*rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((*lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((*rhs).R) == 0) { fR = 0; } else { { int i = (((*rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((*lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 0) { fB = 0; } else { { int i = (((*rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((*lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((*rhs).G) == 0) { fG = 0; } else { { int i = (((*rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((*lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((*rhs).R) == 0) { fR = 0; } else { { int i = (((*rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((*lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 0) { fB = 0; } else { { int i = (((*rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((*lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((*rhs).G) == 0) { fG = 0; } else { { int i = (((*rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((*lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((*rhs).R) == 0) { fR = 0; } else { { int i = (((*rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((*lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 0) { fB = 0; } else { { int i = (((*rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((*lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((*rhs).G) == 0) { fG = 0; } else { { int i = (((*rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((*lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((*rhs).R) == 0) { fR = 0; } else { { int i = (((*rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((*lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 0) { fB = 0; } else { { int i = (((*rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((*lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((*rhs).G) == 0) { fG = 0; } else { { int i = (((*rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((*lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((*rhs).R) == 0) { fR = 0; } else { { int i = (((*rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((*lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 0) { fB = 0; } else { { int i = (((*rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((*lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((*rhs).G) == 0) { fG = 0; } else { { int i = (((*rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((*lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((*rhs).R) == 0) { fR = 0; } else { { int i = (((*rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((*lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 0) { fB = 0; } else { { int i = (((*rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((*lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((*rhs).G) == 0) { fG = 0; } else { { int i = (((*rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((*lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((*rhs).R) == 0) { fR = 0; } else { { int i = (((*rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((*lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 0) { fB = 0; } else { { int i = (((*rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((*lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((*rhs).G) == 0) { fG = 0; } else { { int i = (((*rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((*lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((*rhs).R) == 0) { fR = 0; } else { { int i = (((*rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((*lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 0) { fB = 0; } else { { int i = (((*rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((*lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((*rhs).G) == 0) { fG = 0; } else { { int i = (((*rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((*lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((*rhs).R) == 0) { fR = 0; } else { { int i = (((*rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((*lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 0) { fB = 0; } else { { int i = (((*rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((*lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((*rhs).G) == 0) { fG = 0; } else { { int i = (((*rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((*lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((*rhs).R) == 0) { fR = 0; } else { { int i = (((*rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((*lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 0) { fB = 0; } else { { int i = (((*rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((*lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((*rhs).G) == 0) { fG = 0; } else { { int i = (((*rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((*lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((*rhs).R) == 0) { fR = 0; } else { { int i = (((*rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((*lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 0) { fB = 0; } else { { int i = (((*rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((*lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((*rhs).G) == 0) { fG = 0; } else { { int i = (((*rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((*lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((*rhs).R) == 0) { fR = 0; } else { { int i = (((*rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((*lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 0) { fB = 0; } else { { int i = (((*rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((*lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((*rhs).G) == 0) { fG = 0; } else { { int i = (((*rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((*lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((*rhs).R) == 0) { fR = 0; } else { { int i = (((*rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((*lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 0) { fB = 0; } else { { int i = (((*rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((*lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((*rhs).G) == 0) { fG = 0; } else { { int i = (((*rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((*lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((*rhs).R) == 0) { fR = 0; } else { { int i = (((*rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((*lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 0) { fB = 0; } else { { int i = (((*rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((255 - ((*lhs).B)) * 255) * M) + A) >> (int)S); }; fB = 255 - fB; fB = Math.Max (0' fB); } }; { if (((*rhs).G) == 0) { fG = 0; } else { { int i = (((*rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((255 - ((*lhs).G)) * 255) * M) + A) >> (int)S); }; fG = 255 - fG; fG = Math.Max (0' fG); } }; { if (((*rhs).R) == 0) { fR = 0; } else { { int i = (((*rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((255 - ((*lhs).R)) * 255) * M) + A) >> (int)S); }; fR = 255 - fR; fR = Math.Max (0' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorBurnBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorBurnBlendOp.cs,ColorBurnBlendOpWithOpacity,The following statement contains a magic number: if (this.opacity < 0 || this.opacity > 255) { throw new ArgumentOutOfRangeException (); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = ((255 - ((*src).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*dst).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = ((255 - ((*src).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*dst).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = ((255 - ((*src).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*dst).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = ((255 - ((*src).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*dst).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = ((255 - ((*src).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*dst).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = ((255 - ((*src).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*dst).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = ((255 - ((*src).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*dst).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = ((255 - ((*src).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*dst).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = ((255 - ((*src).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*dst).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = ((255 - ((*src).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*dst).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = ((255 - ((*src).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*dst).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = ((255 - ((*src).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*dst).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = ((255 - ((*src).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*dst).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = ((255 - ((*src).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*dst).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = ((255 - ((*src).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*dst).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = ((255 - ((*src).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*dst).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = ((255 - ((*src).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*dst).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = ((255 - ((*src).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*dst).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = ((255 - ((*src).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*dst).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = ((255 - ((*src).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*dst).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = ((255 - ((*src).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*dst).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = ((255 - ((*src).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*dst).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = ((255 - ((*src).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*dst).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = ((255 - ((*src).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*dst).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = ((255 - ((*src).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*dst).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = ((255 - ((*src).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*dst).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = ((255 - ((*src).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*dst).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = ((255 - ((*src).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*dst).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = ((255 - ((*src).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*dst).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = ((255 - ((*src).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*dst).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = ((255 - ((*src).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*dst).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = ((255 - ((*src).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*dst).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = ((255 - ((*src).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*dst).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = ((255 - ((*src).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*dst).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = ((255 - ((*src).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*dst).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = ((255 - ((*src).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*dst).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = ((255 - ((*src).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*dst).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = ((255 - ((*src).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*dst).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = ((255 - ((*src).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*dst).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = ((255 - ((*src).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*dst).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = ((255 - ((*src).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*dst).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = ((255 - ((*src).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*dst).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = ((255 - ((*src).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*dst).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = ((255 - ((*src).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*dst).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = ((255 - ((*src).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*dst).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = ((255 - ((*src).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*dst).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = ((255 - ((*src).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*dst).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = ((255 - ((*src).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*dst).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = ((255 - ((*src).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*dst).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = ((255 - ((*src).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*dst).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = ((255 - ((*src).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*dst).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = ((255 - ((*src).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*dst).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = ((255 - ((*src).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*dst).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = ((255 - ((*src).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*dst).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = ((255 - ((*src).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*dst).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = ((255 - ((*src).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*dst).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = ((255 - ((*src).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*dst).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = ((255 - ((*src).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*dst).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = ((255 - ((*src).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*dst).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = ((255 - ((*src).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*dst).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = ((255 - ((*src).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*dst).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = ((255 - ((*src).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*dst).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = ((255 - ((*src).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*dst).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = ((255 - ((*src).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*dst).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = ((255 - ((*src).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*dst).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = ((255 - ((*src).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*dst).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = ((255 - ((*src).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*dst).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = ((255 - ((*src).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*dst).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = ((255 - ((*src).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*dst).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = ((255 - ((*src).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*dst).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = ((255 - ((*src).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*dst).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = ((255 - ((*src).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*dst).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = ((255 - ((*src).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*dst).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = ((255 - ((*src).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*dst).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = ((255 - ((*src).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*dst).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = ((255 - ((*src).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*dst).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = ((255 - ((*src).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*dst).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = ((255 - ((*src).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*dst).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = ((255 - ((*src).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*dst).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = ((255 - ((*src).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*dst).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = ((255 - ((*src).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*dst).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = ((255 - ((*src).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*dst).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = ((255 - ((*src).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*dst).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = ((255 - ((*src).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*dst).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = ((255 - ((*src).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*dst).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = ((255 - ((*src).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*dst).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = ((255 - ((*src).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*dst).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = ((255 - ((*src).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*dst).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = ((255 - ((*src).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*dst).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = ((255 - ((*src).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*dst).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = ((255 - ((*src).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*dst).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = ((255 - ((*src).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*dst).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = ((255 - ((*src).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*dst).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = ((255 - ((*src).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*dst).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = ((255 - ((*src).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*dst).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = ((255 - ((*src).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*dst).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = ((255 - ((*src).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*dst).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = ((255 - ((*src).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*dst).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = ((255 - ((*src).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*dst).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = ((255 - ((*src).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*dst).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = ((255 - ((*src).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*dst).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = ((255 - ((*src).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*dst).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((*rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((*rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((*rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((*rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((*rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((*rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((*rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((*rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((*rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((*rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((*rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((*rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((*rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((*rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((*rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((*rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((*rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((*rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((*rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((*rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((*rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((*rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((*rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((*rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((*rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((*rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((*rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((*rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((*rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((*rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((*rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((*rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((*rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((*rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((*rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((*rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((*rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((*rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((*rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((*rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((*rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((*rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((*rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((*rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((*rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((*rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((*rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((*rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((*rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((*rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((*rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((*rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((*rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((*rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((*rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((*rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((*rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((*rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((*rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((*rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((*rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((*rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((*rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((*rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((*rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((*rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((*rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((*rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((*rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((*rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((*rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((*rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((*rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((*rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((*rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((*rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((*rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((*rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((*rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((*rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((*rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((*rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((*rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((*rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((*rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((*rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((*rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((*rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((*rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((*rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((*rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((*rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((*rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((*rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((*rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((*rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((*rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((*rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((*rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((*rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((*rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((*rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,ApplyStatic,The following statement contains a magic number: { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,ApplyStatic,The following statement contains a magic number: { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,ApplyStatic,The following statement contains a magic number: { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,ApplyOpacity,The following statement contains a magic number: { r = ((r) * (this.opacity) + 0x80); r = ((((r) >> 8) + (r)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,ApplyOpacity,The following statement contains a magic number: { r = ((r) * (this.opacity) + 0x80); r = ((((r) >> 8) + (r)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = ((255 - ((*src).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*dst).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = ((255 - ((*src).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*dst).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = ((255 - ((*src).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*dst).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = ((255 - ((*src).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*dst).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = ((255 - ((*src).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*dst).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = ((255 - ((*src).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*dst).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = ((255 - ((*src).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*dst).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = ((255 - ((*src).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*dst).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = ((255 - ((*src).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*dst).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = ((255 - ((*src).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*dst).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = ((255 - ((*src).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*dst).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = ((255 - ((*src).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*dst).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = ((255 - ((*src).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*dst).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = ((255 - ((*src).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*dst).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = ((255 - ((*src).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*dst).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = ((255 - ((*src).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*dst).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = ((255 - ((*src).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*dst).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = ((255 - ((*src).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*dst).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = ((255 - ((*src).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*dst).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = ((255 - ((*src).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*dst).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = ((255 - ((*src).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*dst).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = ((255 - ((*src).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*dst).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = ((255 - ((*src).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*dst).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = ((255 - ((*src).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*dst).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = ((255 - ((*src).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*dst).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = ((255 - ((*src).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*dst).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = ((255 - ((*src).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*dst).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = ((255 - ((*src).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*dst).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = ((255 - ((*src).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*dst).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = ((255 - ((*src).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*dst).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = ((255 - ((*src).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*dst).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = ((255 - ((*src).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*dst).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = ((255 - ((*src).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*dst).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = ((255 - ((*src).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*dst).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = ((255 - ((*src).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*dst).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = ((255 - ((*src).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*dst).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = ((255 - ((*src).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*dst).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = ((255 - ((*src).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*dst).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = ((255 - ((*src).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*dst).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = ((255 - ((*src).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*dst).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = ((255 - ((*src).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*dst).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = ((255 - ((*src).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*dst).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = ((255 - ((*src).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*dst).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = ((255 - ((*src).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*dst).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = ((255 - ((*src).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*dst).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = ((255 - ((*src).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*dst).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = ((255 - ((*src).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*dst).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = ((255 - ((*src).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*dst).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = ((255 - ((*src).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*dst).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = ((255 - ((*src).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*dst).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = ((255 - ((*src).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*dst).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = ((255 - ((*src).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*dst).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = ((255 - ((*src).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*dst).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = ((255 - ((*src).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*dst).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = ((255 - ((*src).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*dst).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = ((255 - ((*src).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*dst).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = ((255 - ((*src).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*dst).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = ((255 - ((*src).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*dst).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = ((255 - ((*src).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*dst).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = ((255 - ((*src).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*dst).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = ((255 - ((*src).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*dst).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = ((255 - ((*src).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*dst).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = ((255 - ((*src).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*dst).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = ((255 - ((*src).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*dst).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = ((255 - ((*src).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*dst).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = ((255 - ((*src).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*dst).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = ((255 - ((*src).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*dst).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = ((255 - ((*src).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*dst).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = ((255 - ((*src).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*dst).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = ((255 - ((*src).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*dst).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = ((255 - ((*src).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*dst).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = ((255 - ((*src).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*dst).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = ((255 - ((*src).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*dst).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = ((255 - ((*src).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*dst).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = ((255 - ((*src).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*dst).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = ((255 - ((*src).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*dst).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = ((255 - ((*src).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*dst).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = ((255 - ((*src).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*dst).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = ((255 - ((*src).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*dst).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = ((255 - ((*src).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*dst).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = ((255 - ((*src).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*dst).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = ((255 - ((*src).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*dst).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = ((255 - ((*src).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*dst).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = ((255 - ((*src).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*dst).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = ((255 - ((*src).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*dst).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = ((255 - ((*src).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*dst).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = ((255 - ((*src).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*dst).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = ((255 - ((*src).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*dst).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = ((255 - ((*src).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*dst).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = ((255 - ((*src).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*dst).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = ((255 - ((*src).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*dst).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = ((255 - ((*src).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*dst).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = ((255 - ((*src).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*dst).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = ((255 - ((*src).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*dst).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = ((255 - ((*src).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*dst).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = ((255 - ((*src).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*dst).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = ((255 - ((*src).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*dst).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = ((255 - ((*src).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*dst).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = ((255 - ((*src).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*dst).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = ((255 - ((*src).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*dst).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = ((255 - ((*src).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*dst).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = ((255 - ((*src).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*dst).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((*rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((*rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((*rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((*rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((*rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((*rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((*rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((*rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((*rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((*rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((*rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((*rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((*rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((*rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((*rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((*rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((*rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((*rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((*rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((*rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((*rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((*rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((*rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((*rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((*rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((*rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((*rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((*rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((*rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((*rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((*rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((*rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((*rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((*rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((*rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((*rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((*rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((*rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((*rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((*rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((*rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((*rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((*rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((*rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((*rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((*rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((*rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((*rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((*rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((*rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((*rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((*rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((*rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((*rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((*rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((*rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((*rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((*rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((*rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((*rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((*rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((*rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((*rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((*rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((*rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((*rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((*rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((*rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((*rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((*rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((*rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((*rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((*rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((*rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((*rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((*rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((*rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((*rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((*rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((*rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((*rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((*rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((*rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((*rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((*rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((*rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((*rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((*rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((*rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((*rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((*rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((*rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((*rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((*rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((*rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((*rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((*rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((*rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((*rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = ((255 - ((*rhs).B))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)((((((*lhs).B) * 255) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = ((255 - ((*rhs).G))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)((((((*lhs).G) * 255) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = ((255 - ((*rhs).R))) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)((((((*lhs).R) * 255) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ColorDodgeBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ColorDodgeBlendOp.cs,ColorDodgeBlendOpWithOpacity,The following statement contains a magic number: if (this.opacity < 0 || this.opacity > 255) { throw new ArgumentOutOfRangeException (); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,Apply,The following statement contains a magic number: { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,Apply,The following statement contains a magic number: { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,Apply,The following statement contains a magic number: { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((rhs).B)) * (((lhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = ((rhs).B) + ((lhs).B) - fB; }; { { fG = ((((rhs).G)) * (((lhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = ((rhs).G) + ((lhs).G) - fG; }; { { fR = ((((rhs).R)) * (((lhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = ((rhs).R) + ((lhs).R) - fR; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((rhs).B)) * (((lhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = ((rhs).B) + ((lhs).B) - fB; }; { { fG = ((((rhs).G)) * (((lhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = ((rhs).G) + ((lhs).G) - fG; }; { { fR = ((((rhs).R)) * (((lhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = ((rhs).R) + ((lhs).R) - fR; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((rhs).B)) * (((lhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = ((rhs).B) + ((lhs).B) - fB; }; { { fG = ((((rhs).G)) * (((lhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = ((rhs).G) + ((lhs).G) - fG; }; { { fR = ((((rhs).R)) * (((lhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = ((rhs).R) + ((lhs).R) - fR; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((rhs).B)) * (((lhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = ((rhs).B) + ((lhs).B) - fB; }; { { fG = ((((rhs).G)) * (((lhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = ((rhs).G) + ((lhs).G) - fG; }; { { fR = ((((rhs).R)) * (((lhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = ((rhs).R) + ((lhs).R) - fR; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((rhs).B)) * (((lhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = ((rhs).B) + ((lhs).B) - fB; }; { { fG = ((((rhs).G)) * (((lhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = ((rhs).G) + ((lhs).G) - fG; }; { { fR = ((((rhs).R)) * (((lhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = ((rhs).R) + ((lhs).R) - fR; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((rhs).B)) * (((lhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = ((rhs).B) + ((lhs).B) - fB; }; { { fG = ((((rhs).G)) * (((lhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = ((rhs).G) + ((lhs).G) - fG; }; { { fR = ((((rhs).R)) * (((lhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = ((rhs).R) + ((lhs).R) - fR; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((rhs).B)) * (((lhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = ((rhs).B) + ((lhs).B) - fB; }; { { fG = ((((rhs).G)) * (((lhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = ((rhs).G) + ((lhs).G) - fG; }; { { fR = ((((rhs).R)) * (((lhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = ((rhs).R) + ((lhs).R) - fR; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((rhs).B)) * (((lhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = ((rhs).B) + ((lhs).B) - fB; }; { { fG = ((((rhs).G)) * (((lhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = ((rhs).G) + ((lhs).G) - fG; }; { { fR = ((((rhs).R)) * (((lhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = ((rhs).R) + ((lhs).R) - fR; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((rhs).B)) * (((lhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = ((rhs).B) + ((lhs).B) - fB; }; { { fG = ((((rhs).G)) * (((lhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = ((rhs).G) + ((lhs).G) - fG; }; { { fR = ((((rhs).R)) * (((lhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = ((rhs).R) + ((lhs).R) - fR; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((rhs).B)) * (((lhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = ((rhs).B) + ((lhs).B) - fB; }; { { fG = ((((rhs).G)) * (((lhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = ((rhs).G) + ((lhs).G) - fG; }; { { fR = ((((rhs).R)) * (((lhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = ((rhs).R) + ((lhs).R) - fR; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((rhs).B)) * (((lhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = ((rhs).B) + ((lhs).B) - fB; }; { { fG = ((((rhs).G)) * (((lhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = ((rhs).G) + ((lhs).G) - fG; }; { { fR = ((((rhs).R)) * (((lhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = ((rhs).R) + ((lhs).R) - fR; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((rhs).B)) * (((lhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = ((rhs).B) + ((lhs).B) - fB; }; { { fG = ((((rhs).G)) * (((lhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = ((rhs).G) + ((lhs).G) - fG; }; { { fR = ((((rhs).R)) * (((lhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = ((rhs).R) + ((lhs).R) - fR; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((rhs).B)) * (((lhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = ((rhs).B) + ((lhs).B) - fB; }; { { fG = ((((rhs).G)) * (((lhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = ((rhs).G) + ((lhs).G) - fG; }; { { fR = ((((rhs).R)) * (((lhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = ((rhs).R) + ((lhs).R) - fR; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((rhs).B)) * (((lhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = ((rhs).B) + ((lhs).B) - fB; }; { { fG = ((((rhs).G)) * (((lhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = ((rhs).G) + ((lhs).G) - fG; }; { { fR = ((((rhs).R)) * (((lhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = ((rhs).R) + ((lhs).R) - fR; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((rhs).B)) * (((lhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = ((rhs).B) + ((lhs).B) - fB; }; { { fG = ((((rhs).G)) * (((lhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = ((rhs).G) + ((lhs).G) - fG; }; { { fR = ((((rhs).R)) * (((lhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = ((rhs).R) + ((lhs).R) - fR; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((rhs).B)) * (((lhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = ((rhs).B) + ((lhs).B) - fB; }; { { fG = ((((rhs).G)) * (((lhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = ((rhs).G) + ((lhs).G) - fG; }; { { fR = ((((rhs).R)) * (((lhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = ((rhs).R) + ((lhs).R) - fR; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*src).B)) * (((*dst).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = ((*src).B) + ((*dst).B) - fB; }; { { fG = ((((*src).G)) * (((*dst).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = ((*src).G) + ((*dst).G) - fG; }; { { fR = ((((*src).R)) * (((*dst).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = ((*src).R) + ((*dst).R) - fR; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*src).B)) * (((*dst).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = ((*src).B) + ((*dst).B) - fB; }; { { fG = ((((*src).G)) * (((*dst).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = ((*src).G) + ((*dst).G) - fG; }; { { fR = ((((*src).R)) * (((*dst).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = ((*src).R) + ((*dst).R) - fR; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*src).B)) * (((*dst).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = ((*src).B) + ((*dst).B) - fB; }; { { fG = ((((*src).G)) * (((*dst).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = ((*src).G) + ((*dst).G) - fG; }; { { fR = ((((*src).R)) * (((*dst).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = ((*src).R) + ((*dst).R) - fR; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*src).B)) * (((*dst).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = ((*src).B) + ((*dst).B) - fB; }; { { fG = ((((*src).G)) * (((*dst).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = ((*src).G) + ((*dst).G) - fG; }; { { fR = ((((*src).R)) * (((*dst).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = ((*src).R) + ((*dst).R) - fR; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*src).B)) * (((*dst).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = ((*src).B) + ((*dst).B) - fB; }; { { fG = ((((*src).G)) * (((*dst).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = ((*src).G) + ((*dst).G) - fG; }; { { fR = ((((*src).R)) * (((*dst).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = ((*src).R) + ((*dst).R) - fR; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*src).B)) * (((*dst).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = ((*src).B) + ((*dst).B) - fB; }; { { fG = ((((*src).G)) * (((*dst).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = ((*src).G) + ((*dst).G) - fG; }; { { fR = ((((*src).R)) * (((*dst).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = ((*src).R) + ((*dst).R) - fR; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*src).B)) * (((*dst).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = ((*src).B) + ((*dst).B) - fB; }; { { fG = ((((*src).G)) * (((*dst).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = ((*src).G) + ((*dst).G) - fG; }; { { fR = ((((*src).R)) * (((*dst).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = ((*src).R) + ((*dst).R) - fR; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*src).B)) * (((*dst).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = ((*src).B) + ((*dst).B) - fB; }; { { fG = ((((*src).G)) * (((*dst).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = ((*src).G) + ((*dst).G) - fG; }; { { fR = ((((*src).R)) * (((*dst).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = ((*src).R) + ((*dst).R) - fR; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*src).B)) * (((*dst).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = ((*src).B) + ((*dst).B) - fB; }; { { fG = ((((*src).G)) * (((*dst).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = ((*src).G) + ((*dst).G) - fG; }; { { fR = ((((*src).R)) * (((*dst).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = ((*src).R) + ((*dst).R) - fR; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*src).B)) * (((*dst).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = ((*src).B) + ((*dst).B) - fB; }; { { fG = ((((*src).G)) * (((*dst).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = ((*src).G) + ((*dst).G) - fG; }; { { fR = ((((*src).R)) * (((*dst).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = ((*src).R) + ((*dst).R) - fR; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*src).B)) * (((*dst).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = ((*src).B) + ((*dst).B) - fB; }; { { fG = ((((*src).G)) * (((*dst).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = ((*src).G) + ((*dst).G) - fG; }; { { fR = ((((*src).R)) * (((*dst).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = ((*src).R) + ((*dst).R) - fR; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*src).B)) * (((*dst).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = ((*src).B) + ((*dst).B) - fB; }; { { fG = ((((*src).G)) * (((*dst).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = ((*src).G) + ((*dst).G) - fG; }; { { fR = ((((*src).R)) * (((*dst).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = ((*src).R) + ((*dst).R) - fR; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*src).B)) * (((*dst).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = ((*src).B) + ((*dst).B) - fB; }; { { fG = ((((*src).G)) * (((*dst).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = ((*src).G) + ((*dst).G) - fG; }; { { fR = ((((*src).R)) * (((*dst).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = ((*src).R) + ((*dst).R) - fR; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*src).B)) * (((*dst).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = ((*src).B) + ((*dst).B) - fB; }; { { fG = ((((*src).G)) * (((*dst).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = ((*src).G) + ((*dst).G) - fG; }; { { fR = ((((*src).R)) * (((*dst).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = ((*src).R) + ((*dst).R) - fR; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*src).B)) * (((*dst).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = ((*src).B) + ((*dst).B) - fB; }; { { fG = ((((*src).G)) * (((*dst).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = ((*src).G) + ((*dst).G) - fG; }; { { fR = ((((*src).R)) * (((*dst).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = ((*src).R) + ((*dst).R) - fR; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*src).B)) * (((*dst).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = ((*src).B) + ((*dst).B) - fB; }; { { fG = ((((*src).G)) * (((*dst).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = ((*src).G) + ((*dst).G) - fG; }; { { fR = ((((*src).R)) * (((*dst).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = ((*src).R) + ((*dst).R) - fR; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*src).B)) * (((*dst).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = ((*src).B) + ((*dst).B) - fB; }; { { fG = ((((*src).G)) * (((*dst).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = ((*src).G) + ((*dst).G) - fG; }; { { fR = ((((*src).R)) * (((*dst).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = ((*src).R) + ((*dst).R) - fR; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*src).B)) * (((*dst).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = ((*src).B) + ((*dst).B) - fB; }; { { fG = ((((*src).G)) * (((*dst).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = ((*src).G) + ((*dst).G) - fG; }; { { fR = ((((*src).R)) * (((*dst).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = ((*src).R) + ((*dst).R) - fR; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*src).B)) * (((*dst).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = ((*src).B) + ((*dst).B) - fB; }; { { fG = ((((*src).G)) * (((*dst).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = ((*src).G) + ((*dst).G) - fG; }; { { fR = ((((*src).R)) * (((*dst).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = ((*src).R) + ((*dst).R) - fR; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*rhs).B)) * (((*lhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = ((*rhs).B) + ((*lhs).B) - fB; }; { { fG = ((((*rhs).G)) * (((*lhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = ((*rhs).G) + ((*lhs).G) - fG; }; { { fR = ((((*rhs).R)) * (((*lhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = ((*rhs).R) + ((*lhs).R) - fR; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*rhs).B)) * (((*lhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = ((*rhs).B) + ((*lhs).B) - fB; }; { { fG = ((((*rhs).G)) * (((*lhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = ((*rhs).G) + ((*lhs).G) - fG; }; { { fR = ((((*rhs).R)) * (((*lhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = ((*rhs).R) + ((*lhs).R) - fR; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*rhs).B)) * (((*lhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = ((*rhs).B) + ((*lhs).B) - fB; }; { { fG = ((((*rhs).G)) * (((*lhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = ((*rhs).G) + ((*lhs).G) - fG; }; { { fR = ((((*rhs).R)) * (((*lhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = ((*rhs).R) + ((*lhs).R) - fR; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*rhs).B)) * (((*lhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = ((*rhs).B) + ((*lhs).B) - fB; }; { { fG = ((((*rhs).G)) * (((*lhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = ((*rhs).G) + ((*lhs).G) - fG; }; { { fR = ((((*rhs).R)) * (((*lhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = ((*rhs).R) + ((*lhs).R) - fR; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*rhs).B)) * (((*lhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = ((*rhs).B) + ((*lhs).B) - fB; }; { { fG = ((((*rhs).G)) * (((*lhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = ((*rhs).G) + ((*lhs).G) - fG; }; { { fR = ((((*rhs).R)) * (((*lhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = ((*rhs).R) + ((*lhs).R) - fR; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*rhs).B)) * (((*lhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = ((*rhs).B) + ((*lhs).B) - fB; }; { { fG = ((((*rhs).G)) * (((*lhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = ((*rhs).G) + ((*lhs).G) - fG; }; { { fR = ((((*rhs).R)) * (((*lhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = ((*rhs).R) + ((*lhs).R) - fR; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*rhs).B)) * (((*lhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = ((*rhs).B) + ((*lhs).B) - fB; }; { { fG = ((((*rhs).G)) * (((*lhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = ((*rhs).G) + ((*lhs).G) - fG; }; { { fR = ((((*rhs).R)) * (((*lhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = ((*rhs).R) + ((*lhs).R) - fR; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*rhs).B)) * (((*lhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = ((*rhs).B) + ((*lhs).B) - fB; }; { { fG = ((((*rhs).G)) * (((*lhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = ((*rhs).G) + ((*lhs).G) - fG; }; { { fR = ((((*rhs).R)) * (((*lhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = ((*rhs).R) + ((*lhs).R) - fR; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*rhs).B)) * (((*lhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = ((*rhs).B) + ((*lhs).B) - fB; }; { { fG = ((((*rhs).G)) * (((*lhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = ((*rhs).G) + ((*lhs).G) - fG; }; { { fR = ((((*rhs).R)) * (((*lhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = ((*rhs).R) + ((*lhs).R) - fR; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*rhs).B)) * (((*lhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = ((*rhs).B) + ((*lhs).B) - fB; }; { { fG = ((((*rhs).G)) * (((*lhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = ((*rhs).G) + ((*lhs).G) - fG; }; { { fR = ((((*rhs).R)) * (((*lhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = ((*rhs).R) + ((*lhs).R) - fR; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*rhs).B)) * (((*lhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = ((*rhs).B) + ((*lhs).B) - fB; }; { { fG = ((((*rhs).G)) * (((*lhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = ((*rhs).G) + ((*lhs).G) - fG; }; { { fR = ((((*rhs).R)) * (((*lhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = ((*rhs).R) + ((*lhs).R) - fR; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*rhs).B)) * (((*lhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = ((*rhs).B) + ((*lhs).B) - fB; }; { { fG = ((((*rhs).G)) * (((*lhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = ((*rhs).G) + ((*lhs).G) - fG; }; { { fR = ((((*rhs).R)) * (((*lhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = ((*rhs).R) + ((*lhs).R) - fR; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*rhs).B)) * (((*lhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = ((*rhs).B) + ((*lhs).B) - fB; }; { { fG = ((((*rhs).G)) * (((*lhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = ((*rhs).G) + ((*lhs).G) - fG; }; { { fR = ((((*rhs).R)) * (((*lhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = ((*rhs).R) + ((*lhs).R) - fR; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*rhs).B)) * (((*lhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = ((*rhs).B) + ((*lhs).B) - fB; }; { { fG = ((((*rhs).G)) * (((*lhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = ((*rhs).G) + ((*lhs).G) - fG; }; { { fR = ((((*rhs).R)) * (((*lhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = ((*rhs).R) + ((*lhs).R) - fR; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*rhs).B)) * (((*lhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = ((*rhs).B) + ((*lhs).B) - fB; }; { { fG = ((((*rhs).G)) * (((*lhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = ((*rhs).G) + ((*lhs).G) - fG; }; { { fR = ((((*rhs).R)) * (((*lhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = ((*rhs).R) + ((*lhs).R) - fR; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*rhs).B)) * (((*lhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = ((*rhs).B) + ((*lhs).B) - fB; }; { { fG = ((((*rhs).G)) * (((*lhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = ((*rhs).G) + ((*lhs).G) - fG; }; { { fR = ((((*rhs).R)) * (((*lhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = ((*rhs).R) + ((*lhs).R) - fR; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*rhs).B)) * (((*lhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = ((*rhs).B) + ((*lhs).B) - fB; }; { { fG = ((((*rhs).G)) * (((*lhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = ((*rhs).G) + ((*lhs).G) - fG; }; { { fR = ((((*rhs).R)) * (((*lhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = ((*rhs).R) + ((*lhs).R) - fR; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*rhs).B)) * (((*lhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = ((*rhs).B) + ((*lhs).B) - fB; }; { { fG = ((((*rhs).G)) * (((*lhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = ((*rhs).G) + ((*lhs).G) - fG; }; { { fR = ((((*rhs).R)) * (((*lhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = ((*rhs).R) + ((*lhs).R) - fR; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*rhs).B)) * (((*lhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = ((*rhs).B) + ((*lhs).B) - fB; }; { { fG = ((((*rhs).G)) * (((*lhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = ((*rhs).G) + ((*lhs).G) - fG; }; { { fR = ((((*rhs).R)) * (((*lhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = ((*rhs).R) + ((*lhs).R) - fR; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,ApplyStatic,The following statement contains a magic number: { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,ApplyStatic,The following statement contains a magic number: { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,ApplyStatic,The following statement contains a magic number: { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((rhs).B)) * (((lhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = ((rhs).B) + ((lhs).B) - fB; }; { { fG = ((((rhs).G)) * (((lhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = ((rhs).G) + ((lhs).G) - fG; }; { { fR = ((((rhs).R)) * (((lhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = ((rhs).R) + ((lhs).R) - fR; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((rhs).B)) * (((lhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = ((rhs).B) + ((lhs).B) - fB; }; { { fG = ((((rhs).G)) * (((lhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = ((rhs).G) + ((lhs).G) - fG; }; { { fR = ((((rhs).R)) * (((lhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = ((rhs).R) + ((lhs).R) - fR; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((rhs).B)) * (((lhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = ((rhs).B) + ((lhs).B) - fB; }; { { fG = ((((rhs).G)) * (((lhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = ((rhs).G) + ((lhs).G) - fG; }; { { fR = ((((rhs).R)) * (((lhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = ((rhs).R) + ((lhs).R) - fR; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((rhs).B)) * (((lhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = ((rhs).B) + ((lhs).B) - fB; }; { { fG = ((((rhs).G)) * (((lhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = ((rhs).G) + ((lhs).G) - fG; }; { { fR = ((((rhs).R)) * (((lhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = ((rhs).R) + ((lhs).R) - fR; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((rhs).B)) * (((lhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = ((rhs).B) + ((lhs).B) - fB; }; { { fG = ((((rhs).G)) * (((lhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = ((rhs).G) + ((lhs).G) - fG; }; { { fR = ((((rhs).R)) * (((lhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = ((rhs).R) + ((lhs).R) - fR; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((rhs).B)) * (((lhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = ((rhs).B) + ((lhs).B) - fB; }; { { fG = ((((rhs).G)) * (((lhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = ((rhs).G) + ((lhs).G) - fG; }; { { fR = ((((rhs).R)) * (((lhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = ((rhs).R) + ((lhs).R) - fR; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((rhs).B)) * (((lhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = ((rhs).B) + ((lhs).B) - fB; }; { { fG = ((((rhs).G)) * (((lhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = ((rhs).G) + ((lhs).G) - fG; }; { { fR = ((((rhs).R)) * (((lhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = ((rhs).R) + ((lhs).R) - fR; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((rhs).B)) * (((lhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = ((rhs).B) + ((lhs).B) - fB; }; { { fG = ((((rhs).G)) * (((lhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = ((rhs).G) + ((lhs).G) - fG; }; { { fR = ((((rhs).R)) * (((lhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = ((rhs).R) + ((lhs).R) - fR; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((rhs).B)) * (((lhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = ((rhs).B) + ((lhs).B) - fB; }; { { fG = ((((rhs).G)) * (((lhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = ((rhs).G) + ((lhs).G) - fG; }; { { fR = ((((rhs).R)) * (((lhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = ((rhs).R) + ((lhs).R) - fR; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((rhs).B)) * (((lhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = ((rhs).B) + ((lhs).B) - fB; }; { { fG = ((((rhs).G)) * (((lhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = ((rhs).G) + ((lhs).G) - fG; }; { { fR = ((((rhs).R)) * (((lhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = ((rhs).R) + ((lhs).R) - fR; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((rhs).B)) * (((lhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = ((rhs).B) + ((lhs).B) - fB; }; { { fG = ((((rhs).G)) * (((lhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = ((rhs).G) + ((lhs).G) - fG; }; { { fR = ((((rhs).R)) * (((lhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = ((rhs).R) + ((lhs).R) - fR; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((rhs).B)) * (((lhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = ((rhs).B) + ((lhs).B) - fB; }; { { fG = ((((rhs).G)) * (((lhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = ((rhs).G) + ((lhs).G) - fG; }; { { fR = ((((rhs).R)) * (((lhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = ((rhs).R) + ((lhs).R) - fR; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((rhs).B)) * (((lhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = ((rhs).B) + ((lhs).B) - fB; }; { { fG = ((((rhs).G)) * (((lhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = ((rhs).G) + ((lhs).G) - fG; }; { { fR = ((((rhs).R)) * (((lhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = ((rhs).R) + ((lhs).R) - fR; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((rhs).B)) * (((lhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = ((rhs).B) + ((lhs).B) - fB; }; { { fG = ((((rhs).G)) * (((lhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = ((rhs).G) + ((lhs).G) - fG; }; { { fR = ((((rhs).R)) * (((lhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = ((rhs).R) + ((lhs).R) - fR; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((rhs).B)) * (((lhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = ((rhs).B) + ((lhs).B) - fB; }; { { fG = ((((rhs).G)) * (((lhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = ((rhs).G) + ((lhs).G) - fG; }; { { fR = ((((rhs).R)) * (((lhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = ((rhs).R) + ((lhs).R) - fR; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((rhs).B)) * (((lhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = ((rhs).B) + ((lhs).B) - fB; }; { { fG = ((((rhs).G)) * (((lhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = ((rhs).G) + ((lhs).G) - fG; }; { { fR = ((((rhs).R)) * (((lhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = ((rhs).R) + ((lhs).R) - fR; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,ApplyOpacity,The following statement contains a magic number: { r = ((r) * (this.opacity) + 0x80); r = ((((r) >> 8) + (r)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,ApplyOpacity,The following statement contains a magic number: { r = ((r) * (this.opacity) + 0x80); r = ((((r) >> 8) + (r)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,Apply,The following statement contains a magic number: { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,Apply,The following statement contains a magic number: { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,Apply,The following statement contains a magic number: { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((rhs).B)) * (((lhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = ((rhs).B) + ((lhs).B) - fB; }; { { fG = ((((rhs).G)) * (((lhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = ((rhs).G) + ((lhs).G) - fG; }; { { fR = ((((rhs).R)) * (((lhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = ((rhs).R) + ((lhs).R) - fR; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((rhs).B)) * (((lhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = ((rhs).B) + ((lhs).B) - fB; }; { { fG = ((((rhs).G)) * (((lhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = ((rhs).G) + ((lhs).G) - fG; }; { { fR = ((((rhs).R)) * (((lhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = ((rhs).R) + ((lhs).R) - fR; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((rhs).B)) * (((lhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = ((rhs).B) + ((lhs).B) - fB; }; { { fG = ((((rhs).G)) * (((lhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = ((rhs).G) + ((lhs).G) - fG; }; { { fR = ((((rhs).R)) * (((lhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = ((rhs).R) + ((lhs).R) - fR; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((rhs).B)) * (((lhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = ((rhs).B) + ((lhs).B) - fB; }; { { fG = ((((rhs).G)) * (((lhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = ((rhs).G) + ((lhs).G) - fG; }; { { fR = ((((rhs).R)) * (((lhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = ((rhs).R) + ((lhs).R) - fR; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((rhs).B)) * (((lhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = ((rhs).B) + ((lhs).B) - fB; }; { { fG = ((((rhs).G)) * (((lhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = ((rhs).G) + ((lhs).G) - fG; }; { { fR = ((((rhs).R)) * (((lhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = ((rhs).R) + ((lhs).R) - fR; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((rhs).B)) * (((lhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = ((rhs).B) + ((lhs).B) - fB; }; { { fG = ((((rhs).G)) * (((lhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = ((rhs).G) + ((lhs).G) - fG; }; { { fR = ((((rhs).R)) * (((lhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = ((rhs).R) + ((lhs).R) - fR; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((rhs).B)) * (((lhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = ((rhs).B) + ((lhs).B) - fB; }; { { fG = ((((rhs).G)) * (((lhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = ((rhs).G) + ((lhs).G) - fG; }; { { fR = ((((rhs).R)) * (((lhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = ((rhs).R) + ((lhs).R) - fR; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((rhs).B)) * (((lhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = ((rhs).B) + ((lhs).B) - fB; }; { { fG = ((((rhs).G)) * (((lhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = ((rhs).G) + ((lhs).G) - fG; }; { { fR = ((((rhs).R)) * (((lhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = ((rhs).R) + ((lhs).R) - fR; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((rhs).B)) * (((lhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = ((rhs).B) + ((lhs).B) - fB; }; { { fG = ((((rhs).G)) * (((lhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = ((rhs).G) + ((lhs).G) - fG; }; { { fR = ((((rhs).R)) * (((lhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = ((rhs).R) + ((lhs).R) - fR; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((rhs).B)) * (((lhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = ((rhs).B) + ((lhs).B) - fB; }; { { fG = ((((rhs).G)) * (((lhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = ((rhs).G) + ((lhs).G) - fG; }; { { fR = ((((rhs).R)) * (((lhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = ((rhs).R) + ((lhs).R) - fR; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((rhs).B)) * (((lhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = ((rhs).B) + ((lhs).B) - fB; }; { { fG = ((((rhs).G)) * (((lhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = ((rhs).G) + ((lhs).G) - fG; }; { { fR = ((((rhs).R)) * (((lhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = ((rhs).R) + ((lhs).R) - fR; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((rhs).B)) * (((lhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = ((rhs).B) + ((lhs).B) - fB; }; { { fG = ((((rhs).G)) * (((lhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = ((rhs).G) + ((lhs).G) - fG; }; { { fR = ((((rhs).R)) * (((lhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = ((rhs).R) + ((lhs).R) - fR; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((rhs).B)) * (((lhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = ((rhs).B) + ((lhs).B) - fB; }; { { fG = ((((rhs).G)) * (((lhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = ((rhs).G) + ((lhs).G) - fG; }; { { fR = ((((rhs).R)) * (((lhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = ((rhs).R) + ((lhs).R) - fR; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((rhs).B)) * (((lhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = ((rhs).B) + ((lhs).B) - fB; }; { { fG = ((((rhs).G)) * (((lhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = ((rhs).G) + ((lhs).G) - fG; }; { { fR = ((((rhs).R)) * (((lhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = ((rhs).R) + ((lhs).R) - fR; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((rhs).B)) * (((lhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = ((rhs).B) + ((lhs).B) - fB; }; { { fG = ((((rhs).G)) * (((lhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = ((rhs).G) + ((lhs).G) - fG; }; { { fR = ((((rhs).R)) * (((lhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = ((rhs).R) + ((lhs).R) - fR; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((rhs).B)) * (((lhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = ((rhs).B) + ((lhs).B) - fB; }; { { fG = ((((rhs).G)) * (((lhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = ((rhs).G) + ((lhs).G) - fG; }; { { fR = ((((rhs).R)) * (((lhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = ((rhs).R) + ((lhs).R) - fR; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*src).B)) * (((*dst).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = ((*src).B) + ((*dst).B) - fB; }; { { fG = ((((*src).G)) * (((*dst).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = ((*src).G) + ((*dst).G) - fG; }; { { fR = ((((*src).R)) * (((*dst).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = ((*src).R) + ((*dst).R) - fR; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*src).B)) * (((*dst).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = ((*src).B) + ((*dst).B) - fB; }; { { fG = ((((*src).G)) * (((*dst).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = ((*src).G) + ((*dst).G) - fG; }; { { fR = ((((*src).R)) * (((*dst).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = ((*src).R) + ((*dst).R) - fR; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*src).B)) * (((*dst).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = ((*src).B) + ((*dst).B) - fB; }; { { fG = ((((*src).G)) * (((*dst).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = ((*src).G) + ((*dst).G) - fG; }; { { fR = ((((*src).R)) * (((*dst).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = ((*src).R) + ((*dst).R) - fR; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*src).B)) * (((*dst).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = ((*src).B) + ((*dst).B) - fB; }; { { fG = ((((*src).G)) * (((*dst).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = ((*src).G) + ((*dst).G) - fG; }; { { fR = ((((*src).R)) * (((*dst).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = ((*src).R) + ((*dst).R) - fR; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*src).B)) * (((*dst).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = ((*src).B) + ((*dst).B) - fB; }; { { fG = ((((*src).G)) * (((*dst).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = ((*src).G) + ((*dst).G) - fG; }; { { fR = ((((*src).R)) * (((*dst).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = ((*src).R) + ((*dst).R) - fR; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*src).B)) * (((*dst).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = ((*src).B) + ((*dst).B) - fB; }; { { fG = ((((*src).G)) * (((*dst).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = ((*src).G) + ((*dst).G) - fG; }; { { fR = ((((*src).R)) * (((*dst).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = ((*src).R) + ((*dst).R) - fR; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*src).B)) * (((*dst).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = ((*src).B) + ((*dst).B) - fB; }; { { fG = ((((*src).G)) * (((*dst).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = ((*src).G) + ((*dst).G) - fG; }; { { fR = ((((*src).R)) * (((*dst).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = ((*src).R) + ((*dst).R) - fR; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*src).B)) * (((*dst).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = ((*src).B) + ((*dst).B) - fB; }; { { fG = ((((*src).G)) * (((*dst).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = ((*src).G) + ((*dst).G) - fG; }; { { fR = ((((*src).R)) * (((*dst).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = ((*src).R) + ((*dst).R) - fR; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*src).B)) * (((*dst).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = ((*src).B) + ((*dst).B) - fB; }; { { fG = ((((*src).G)) * (((*dst).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = ((*src).G) + ((*dst).G) - fG; }; { { fR = ((((*src).R)) * (((*dst).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = ((*src).R) + ((*dst).R) - fR; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*src).B)) * (((*dst).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = ((*src).B) + ((*dst).B) - fB; }; { { fG = ((((*src).G)) * (((*dst).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = ((*src).G) + ((*dst).G) - fG; }; { { fR = ((((*src).R)) * (((*dst).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = ((*src).R) + ((*dst).R) - fR; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*src).B)) * (((*dst).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = ((*src).B) + ((*dst).B) - fB; }; { { fG = ((((*src).G)) * (((*dst).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = ((*src).G) + ((*dst).G) - fG; }; { { fR = ((((*src).R)) * (((*dst).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = ((*src).R) + ((*dst).R) - fR; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*src).B)) * (((*dst).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = ((*src).B) + ((*dst).B) - fB; }; { { fG = ((((*src).G)) * (((*dst).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = ((*src).G) + ((*dst).G) - fG; }; { { fR = ((((*src).R)) * (((*dst).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = ((*src).R) + ((*dst).R) - fR; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*src).B)) * (((*dst).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = ((*src).B) + ((*dst).B) - fB; }; { { fG = ((((*src).G)) * (((*dst).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = ((*src).G) + ((*dst).G) - fG; }; { { fR = ((((*src).R)) * (((*dst).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = ((*src).R) + ((*dst).R) - fR; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*src).B)) * (((*dst).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = ((*src).B) + ((*dst).B) - fB; }; { { fG = ((((*src).G)) * (((*dst).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = ((*src).G) + ((*dst).G) - fG; }; { { fR = ((((*src).R)) * (((*dst).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = ((*src).R) + ((*dst).R) - fR; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*src).B)) * (((*dst).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = ((*src).B) + ((*dst).B) - fB; }; { { fG = ((((*src).G)) * (((*dst).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = ((*src).G) + ((*dst).G) - fG; }; { { fR = ((((*src).R)) * (((*dst).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = ((*src).R) + ((*dst).R) - fR; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*src).B)) * (((*dst).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = ((*src).B) + ((*dst).B) - fB; }; { { fG = ((((*src).G)) * (((*dst).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = ((*src).G) + ((*dst).G) - fG; }; { { fR = ((((*src).R)) * (((*dst).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = ((*src).R) + ((*dst).R) - fR; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*src).B)) * (((*dst).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = ((*src).B) + ((*dst).B) - fB; }; { { fG = ((((*src).G)) * (((*dst).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = ((*src).G) + ((*dst).G) - fG; }; { { fR = ((((*src).R)) * (((*dst).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = ((*src).R) + ((*dst).R) - fR; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*src).B)) * (((*dst).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = ((*src).B) + ((*dst).B) - fB; }; { { fG = ((((*src).G)) * (((*dst).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = ((*src).G) + ((*dst).G) - fG; }; { { fR = ((((*src).R)) * (((*dst).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = ((*src).R) + ((*dst).R) - fR; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*src).B)) * (((*dst).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = ((*src).B) + ((*dst).B) - fB; }; { { fG = ((((*src).G)) * (((*dst).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = ((*src).G) + ((*dst).G) - fG; }; { { fR = ((((*src).R)) * (((*dst).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = ((*src).R) + ((*dst).R) - fR; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*rhs).B)) * (((*lhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = ((*rhs).B) + ((*lhs).B) - fB; }; { { fG = ((((*rhs).G)) * (((*lhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = ((*rhs).G) + ((*lhs).G) - fG; }; { { fR = ((((*rhs).R)) * (((*lhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = ((*rhs).R) + ((*lhs).R) - fR; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*rhs).B)) * (((*lhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = ((*rhs).B) + ((*lhs).B) - fB; }; { { fG = ((((*rhs).G)) * (((*lhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = ((*rhs).G) + ((*lhs).G) - fG; }; { { fR = ((((*rhs).R)) * (((*lhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = ((*rhs).R) + ((*lhs).R) - fR; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*rhs).B)) * (((*lhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = ((*rhs).B) + ((*lhs).B) - fB; }; { { fG = ((((*rhs).G)) * (((*lhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = ((*rhs).G) + ((*lhs).G) - fG; }; { { fR = ((((*rhs).R)) * (((*lhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = ((*rhs).R) + ((*lhs).R) - fR; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*rhs).B)) * (((*lhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = ((*rhs).B) + ((*lhs).B) - fB; }; { { fG = ((((*rhs).G)) * (((*lhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = ((*rhs).G) + ((*lhs).G) - fG; }; { { fR = ((((*rhs).R)) * (((*lhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = ((*rhs).R) + ((*lhs).R) - fR; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*rhs).B)) * (((*lhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = ((*rhs).B) + ((*lhs).B) - fB; }; { { fG = ((((*rhs).G)) * (((*lhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = ((*rhs).G) + ((*lhs).G) - fG; }; { { fR = ((((*rhs).R)) * (((*lhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = ((*rhs).R) + ((*lhs).R) - fR; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*rhs).B)) * (((*lhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = ((*rhs).B) + ((*lhs).B) - fB; }; { { fG = ((((*rhs).G)) * (((*lhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = ((*rhs).G) + ((*lhs).G) - fG; }; { { fR = ((((*rhs).R)) * (((*lhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = ((*rhs).R) + ((*lhs).R) - fR; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*rhs).B)) * (((*lhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = ((*rhs).B) + ((*lhs).B) - fB; }; { { fG = ((((*rhs).G)) * (((*lhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = ((*rhs).G) + ((*lhs).G) - fG; }; { { fR = ((((*rhs).R)) * (((*lhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = ((*rhs).R) + ((*lhs).R) - fR; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*rhs).B)) * (((*lhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = ((*rhs).B) + ((*lhs).B) - fB; }; { { fG = ((((*rhs).G)) * (((*lhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = ((*rhs).G) + ((*lhs).G) - fG; }; { { fR = ((((*rhs).R)) * (((*lhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = ((*rhs).R) + ((*lhs).R) - fR; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*rhs).B)) * (((*lhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = ((*rhs).B) + ((*lhs).B) - fB; }; { { fG = ((((*rhs).G)) * (((*lhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = ((*rhs).G) + ((*lhs).G) - fG; }; { { fR = ((((*rhs).R)) * (((*lhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = ((*rhs).R) + ((*lhs).R) - fR; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*rhs).B)) * (((*lhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = ((*rhs).B) + ((*lhs).B) - fB; }; { { fG = ((((*rhs).G)) * (((*lhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = ((*rhs).G) + ((*lhs).G) - fG; }; { { fR = ((((*rhs).R)) * (((*lhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = ((*rhs).R) + ((*lhs).R) - fR; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*rhs).B)) * (((*lhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = ((*rhs).B) + ((*lhs).B) - fB; }; { { fG = ((((*rhs).G)) * (((*lhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = ((*rhs).G) + ((*lhs).G) - fG; }; { { fR = ((((*rhs).R)) * (((*lhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = ((*rhs).R) + ((*lhs).R) - fR; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*rhs).B)) * (((*lhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = ((*rhs).B) + ((*lhs).B) - fB; }; { { fG = ((((*rhs).G)) * (((*lhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = ((*rhs).G) + ((*lhs).G) - fG; }; { { fR = ((((*rhs).R)) * (((*lhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = ((*rhs).R) + ((*lhs).R) - fR; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*rhs).B)) * (((*lhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = ((*rhs).B) + ((*lhs).B) - fB; }; { { fG = ((((*rhs).G)) * (((*lhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = ((*rhs).G) + ((*lhs).G) - fG; }; { { fR = ((((*rhs).R)) * (((*lhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = ((*rhs).R) + ((*lhs).R) - fR; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*rhs).B)) * (((*lhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = ((*rhs).B) + ((*lhs).B) - fB; }; { { fG = ((((*rhs).G)) * (((*lhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = ((*rhs).G) + ((*lhs).G) - fG; }; { { fR = ((((*rhs).R)) * (((*lhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = ((*rhs).R) + ((*lhs).R) - fR; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*rhs).B)) * (((*lhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = ((*rhs).B) + ((*lhs).B) - fB; }; { { fG = ((((*rhs).G)) * (((*lhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = ((*rhs).G) + ((*lhs).G) - fG; }; { { fR = ((((*rhs).R)) * (((*lhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = ((*rhs).R) + ((*lhs).R) - fR; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*rhs).B)) * (((*lhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = ((*rhs).B) + ((*lhs).B) - fB; }; { { fG = ((((*rhs).G)) * (((*lhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = ((*rhs).G) + ((*lhs).G) - fG; }; { { fR = ((((*rhs).R)) * (((*lhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = ((*rhs).R) + ((*lhs).R) - fR; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*rhs).B)) * (((*lhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = ((*rhs).B) + ((*lhs).B) - fB; }; { { fG = ((((*rhs).G)) * (((*lhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = ((*rhs).G) + ((*lhs).G) - fG; }; { { fR = ((((*rhs).R)) * (((*lhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = ((*rhs).R) + ((*lhs).R) - fR; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*rhs).B)) * (((*lhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = ((*rhs).B) + ((*lhs).B) - fB; }; { { fG = ((((*rhs).G)) * (((*lhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = ((*rhs).G) + ((*lhs).G) - fG; }; { { fR = ((((*rhs).R)) * (((*lhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = ((*rhs).R) + ((*lhs).R) - fR; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*rhs).B)) * (((*lhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = ((*rhs).B) + ((*lhs).B) - fB; }; { { fG = ((((*rhs).G)) * (((*lhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = ((*rhs).G) + ((*lhs).G) - fG; }; { { fR = ((((*rhs).R)) * (((*lhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = ((*rhs).R) + ((*lhs).R) - fR; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ScreenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ScreenBlendOp.cs,ScreenBlendOpWithOpacity,The following statement contains a magic number: if (this.opacity < 0 || this.opacity > 255) { throw new ArgumentOutOfRangeException (); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DarkenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DarkenBlendOp.cs,Apply,The following statement contains a magic number: { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DarkenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DarkenBlendOp.cs,Apply,The following statement contains a magic number: { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DarkenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DarkenBlendOp.cs,Apply,The following statement contains a magic number: { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DarkenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DarkenBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min ((lhs).B' (rhs).B); }; { fG = Math.Min ((lhs).G' (rhs).G); }; { fR = Math.Min ((lhs).R' (rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DarkenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DarkenBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min ((lhs).B' (rhs).B); }; { fG = Math.Min ((lhs).G' (rhs).G); }; { fR = Math.Min ((lhs).R' (rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DarkenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DarkenBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min ((lhs).B' (rhs).B); }; { fG = Math.Min ((lhs).G' (rhs).G); }; { fR = Math.Min ((lhs).R' (rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DarkenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DarkenBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min ((lhs).B' (rhs).B); }; { fG = Math.Min ((lhs).G' (rhs).G); }; { fR = Math.Min ((lhs).R' (rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DarkenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DarkenBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min ((lhs).B' (rhs).B); }; { fG = Math.Min ((lhs).G' (rhs).G); }; { fR = Math.Min ((lhs).R' (rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DarkenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DarkenBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min ((lhs).B' (rhs).B); }; { fG = Math.Min ((lhs).G' (rhs).G); }; { fR = Math.Min ((lhs).R' (rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DarkenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DarkenBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min ((lhs).B' (rhs).B); }; { fG = Math.Min ((lhs).G' (rhs).G); }; { fR = Math.Min ((lhs).R' (rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DarkenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DarkenBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min ((lhs).B' (rhs).B); }; { fG = Math.Min ((lhs).G' (rhs).G); }; { fR = Math.Min ((lhs).R' (rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DarkenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DarkenBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min ((lhs).B' (rhs).B); }; { fG = Math.Min ((lhs).G' (rhs).G); }; { fR = Math.Min ((lhs).R' (rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DarkenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DarkenBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min ((lhs).B' (rhs).B); }; { fG = Math.Min ((lhs).G' (rhs).G); }; { fR = Math.Min ((lhs).R' (rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DarkenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DarkenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min ((*dst).B' (*src).B); }; { fG = Math.Min ((*dst).G' (*src).G); }; { fR = Math.Min ((*dst).R' (*src).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DarkenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DarkenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min ((*dst).B' (*src).B); }; { fG = Math.Min ((*dst).G' (*src).G); }; { fR = Math.Min ((*dst).R' (*src).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DarkenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DarkenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min ((*dst).B' (*src).B); }; { fG = Math.Min ((*dst).G' (*src).G); }; { fR = Math.Min ((*dst).R' (*src).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DarkenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DarkenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min ((*dst).B' (*src).B); }; { fG = Math.Min ((*dst).G' (*src).G); }; { fR = Math.Min ((*dst).R' (*src).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DarkenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DarkenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min ((*dst).B' (*src).B); }; { fG = Math.Min ((*dst).G' (*src).G); }; { fR = Math.Min ((*dst).R' (*src).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DarkenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DarkenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min ((*dst).B' (*src).B); }; { fG = Math.Min ((*dst).G' (*src).G); }; { fR = Math.Min ((*dst).R' (*src).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DarkenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DarkenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min ((*dst).B' (*src).B); }; { fG = Math.Min ((*dst).G' (*src).G); }; { fR = Math.Min ((*dst).R' (*src).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DarkenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DarkenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min ((*dst).B' (*src).B); }; { fG = Math.Min ((*dst).G' (*src).G); }; { fR = Math.Min ((*dst).R' (*src).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DarkenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DarkenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min ((*dst).B' (*src).B); }; { fG = Math.Min ((*dst).G' (*src).G); }; { fR = Math.Min ((*dst).R' (*src).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DarkenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DarkenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min ((*dst).B' (*src).B); }; { fG = Math.Min ((*dst).G' (*src).G); }; { fR = Math.Min ((*dst).R' (*src).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DarkenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DarkenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min ((*dst).B' (*src).B); }; { fG = Math.Min ((*dst).G' (*src).G); }; { fR = Math.Min ((*dst).R' (*src).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DarkenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DarkenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min ((*dst).B' (*src).B); }; { fG = Math.Min ((*dst).G' (*src).G); }; { fR = Math.Min ((*dst).R' (*src).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DarkenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DarkenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min ((*dst).B' (*src).B); }; { fG = Math.Min ((*dst).G' (*src).G); }; { fR = Math.Min ((*dst).R' (*src).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DarkenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DarkenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min ((*lhs).B' (*rhs).B); }; { fG = Math.Min ((*lhs).G' (*rhs).G); }; { fR = Math.Min ((*lhs).R' (*rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DarkenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DarkenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min ((*lhs).B' (*rhs).B); }; { fG = Math.Min ((*lhs).G' (*rhs).G); }; { fR = Math.Min ((*lhs).R' (*rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DarkenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DarkenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min ((*lhs).B' (*rhs).B); }; { fG = Math.Min ((*lhs).G' (*rhs).G); }; { fR = Math.Min ((*lhs).R' (*rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DarkenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DarkenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min ((*lhs).B' (*rhs).B); }; { fG = Math.Min ((*lhs).G' (*rhs).G); }; { fR = Math.Min ((*lhs).R' (*rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DarkenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DarkenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min ((*lhs).B' (*rhs).B); }; { fG = Math.Min ((*lhs).G' (*rhs).G); }; { fR = Math.Min ((*lhs).R' (*rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DarkenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DarkenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min ((*lhs).B' (*rhs).B); }; { fG = Math.Min ((*lhs).G' (*rhs).G); }; { fR = Math.Min ((*lhs).R' (*rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DarkenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DarkenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min ((*lhs).B' (*rhs).B); }; { fG = Math.Min ((*lhs).G' (*rhs).G); }; { fR = Math.Min ((*lhs).R' (*rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DarkenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DarkenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min ((*lhs).B' (*rhs).B); }; { fG = Math.Min ((*lhs).G' (*rhs).G); }; { fR = Math.Min ((*lhs).R' (*rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DarkenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DarkenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min ((*lhs).B' (*rhs).B); }; { fG = Math.Min ((*lhs).G' (*rhs).G); }; { fR = Math.Min ((*lhs).R' (*rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DarkenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DarkenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min ((*lhs).B' (*rhs).B); }; { fG = Math.Min ((*lhs).G' (*rhs).G); }; { fR = Math.Min ((*lhs).R' (*rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DarkenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DarkenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min ((*lhs).B' (*rhs).B); }; { fG = Math.Min ((*lhs).G' (*rhs).G); }; { fR = Math.Min ((*lhs).R' (*rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DarkenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DarkenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min ((*lhs).B' (*rhs).B); }; { fG = Math.Min ((*lhs).G' (*rhs).G); }; { fR = Math.Min ((*lhs).R' (*rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DarkenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DarkenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min ((*lhs).B' (*rhs).B); }; { fG = Math.Min ((*lhs).G' (*rhs).G); }; { fR = Math.Min ((*lhs).R' (*rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DarkenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DarkenBlendOp.cs,ApplyStatic,The following statement contains a magic number: { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DarkenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DarkenBlendOp.cs,ApplyStatic,The following statement contains a magic number: { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DarkenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DarkenBlendOp.cs,ApplyStatic,The following statement contains a magic number: { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DarkenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DarkenBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min ((lhs).B' (rhs).B); }; { fG = Math.Min ((lhs).G' (rhs).G); }; { fR = Math.Min ((lhs).R' (rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DarkenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DarkenBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min ((lhs).B' (rhs).B); }; { fG = Math.Min ((lhs).G' (rhs).G); }; { fR = Math.Min ((lhs).R' (rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DarkenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DarkenBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min ((lhs).B' (rhs).B); }; { fG = Math.Min ((lhs).G' (rhs).G); }; { fR = Math.Min ((lhs).R' (rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DarkenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DarkenBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min ((lhs).B' (rhs).B); }; { fG = Math.Min ((lhs).G' (rhs).G); }; { fR = Math.Min ((lhs).R' (rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DarkenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DarkenBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min ((lhs).B' (rhs).B); }; { fG = Math.Min ((lhs).G' (rhs).G); }; { fR = Math.Min ((lhs).R' (rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DarkenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DarkenBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min ((lhs).B' (rhs).B); }; { fG = Math.Min ((lhs).G' (rhs).G); }; { fR = Math.Min ((lhs).R' (rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DarkenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DarkenBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min ((lhs).B' (rhs).B); }; { fG = Math.Min ((lhs).G' (rhs).G); }; { fR = Math.Min ((lhs).R' (rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DarkenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DarkenBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min ((lhs).B' (rhs).B); }; { fG = Math.Min ((lhs).G' (rhs).G); }; { fR = Math.Min ((lhs).R' (rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DarkenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DarkenBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min ((lhs).B' (rhs).B); }; { fG = Math.Min ((lhs).G' (rhs).G); }; { fR = Math.Min ((lhs).R' (rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DarkenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DarkenBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min ((lhs).B' (rhs).B); }; { fG = Math.Min ((lhs).G' (rhs).G); }; { fR = Math.Min ((lhs).R' (rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DarkenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DarkenBlendOp.cs,ApplyOpacity,The following statement contains a magic number: { r = ((r) * (this.opacity) + 0x80); r = ((((r) >> 8) + (r)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DarkenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DarkenBlendOp.cs,ApplyOpacity,The following statement contains a magic number: { r = ((r) * (this.opacity) + 0x80); r = ((((r) >> 8) + (r)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DarkenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DarkenBlendOp.cs,Apply,The following statement contains a magic number: { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DarkenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DarkenBlendOp.cs,Apply,The following statement contains a magic number: { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DarkenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DarkenBlendOp.cs,Apply,The following statement contains a magic number: { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DarkenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DarkenBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min ((lhs).B' (rhs).B); }; { fG = Math.Min ((lhs).G' (rhs).G); }; { fR = Math.Min ((lhs).R' (rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DarkenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DarkenBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min ((lhs).B' (rhs).B); }; { fG = Math.Min ((lhs).G' (rhs).G); }; { fR = Math.Min ((lhs).R' (rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DarkenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DarkenBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min ((lhs).B' (rhs).B); }; { fG = Math.Min ((lhs).G' (rhs).G); }; { fR = Math.Min ((lhs).R' (rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DarkenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DarkenBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min ((lhs).B' (rhs).B); }; { fG = Math.Min ((lhs).G' (rhs).G); }; { fR = Math.Min ((lhs).R' (rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DarkenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DarkenBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min ((lhs).B' (rhs).B); }; { fG = Math.Min ((lhs).G' (rhs).G); }; { fR = Math.Min ((lhs).R' (rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DarkenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DarkenBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min ((lhs).B' (rhs).B); }; { fG = Math.Min ((lhs).G' (rhs).G); }; { fR = Math.Min ((lhs).R' (rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DarkenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DarkenBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min ((lhs).B' (rhs).B); }; { fG = Math.Min ((lhs).G' (rhs).G); }; { fR = Math.Min ((lhs).R' (rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DarkenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DarkenBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min ((lhs).B' (rhs).B); }; { fG = Math.Min ((lhs).G' (rhs).G); }; { fR = Math.Min ((lhs).R' (rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DarkenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DarkenBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min ((lhs).B' (rhs).B); }; { fG = Math.Min ((lhs).G' (rhs).G); }; { fR = Math.Min ((lhs).R' (rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DarkenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DarkenBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min ((lhs).B' (rhs).B); }; { fG = Math.Min ((lhs).G' (rhs).G); }; { fR = Math.Min ((lhs).R' (rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DarkenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DarkenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min ((*dst).B' (*src).B); }; { fG = Math.Min ((*dst).G' (*src).G); }; { fR = Math.Min ((*dst).R' (*src).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DarkenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DarkenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min ((*dst).B' (*src).B); }; { fG = Math.Min ((*dst).G' (*src).G); }; { fR = Math.Min ((*dst).R' (*src).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DarkenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DarkenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min ((*dst).B' (*src).B); }; { fG = Math.Min ((*dst).G' (*src).G); }; { fR = Math.Min ((*dst).R' (*src).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DarkenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DarkenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min ((*dst).B' (*src).B); }; { fG = Math.Min ((*dst).G' (*src).G); }; { fR = Math.Min ((*dst).R' (*src).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DarkenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DarkenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min ((*dst).B' (*src).B); }; { fG = Math.Min ((*dst).G' (*src).G); }; { fR = Math.Min ((*dst).R' (*src).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DarkenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DarkenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min ((*dst).B' (*src).B); }; { fG = Math.Min ((*dst).G' (*src).G); }; { fR = Math.Min ((*dst).R' (*src).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DarkenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DarkenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min ((*dst).B' (*src).B); }; { fG = Math.Min ((*dst).G' (*src).G); }; { fR = Math.Min ((*dst).R' (*src).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DarkenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DarkenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min ((*dst).B' (*src).B); }; { fG = Math.Min ((*dst).G' (*src).G); }; { fR = Math.Min ((*dst).R' (*src).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DarkenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DarkenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min ((*dst).B' (*src).B); }; { fG = Math.Min ((*dst).G' (*src).G); }; { fR = Math.Min ((*dst).R' (*src).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DarkenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DarkenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min ((*dst).B' (*src).B); }; { fG = Math.Min ((*dst).G' (*src).G); }; { fR = Math.Min ((*dst).R' (*src).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DarkenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DarkenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min ((*dst).B' (*src).B); }; { fG = Math.Min ((*dst).G' (*src).G); }; { fR = Math.Min ((*dst).R' (*src).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DarkenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DarkenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min ((*dst).B' (*src).B); }; { fG = Math.Min ((*dst).G' (*src).G); }; { fR = Math.Min ((*dst).R' (*src).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DarkenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DarkenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min ((*dst).B' (*src).B); }; { fG = Math.Min ((*dst).G' (*src).G); }; { fR = Math.Min ((*dst).R' (*src).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DarkenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DarkenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min ((*lhs).B' (*rhs).B); }; { fG = Math.Min ((*lhs).G' (*rhs).G); }; { fR = Math.Min ((*lhs).R' (*rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DarkenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DarkenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min ((*lhs).B' (*rhs).B); }; { fG = Math.Min ((*lhs).G' (*rhs).G); }; { fR = Math.Min ((*lhs).R' (*rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DarkenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DarkenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min ((*lhs).B' (*rhs).B); }; { fG = Math.Min ((*lhs).G' (*rhs).G); }; { fR = Math.Min ((*lhs).R' (*rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DarkenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DarkenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min ((*lhs).B' (*rhs).B); }; { fG = Math.Min ((*lhs).G' (*rhs).G); }; { fR = Math.Min ((*lhs).R' (*rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DarkenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DarkenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min ((*lhs).B' (*rhs).B); }; { fG = Math.Min ((*lhs).G' (*rhs).G); }; { fR = Math.Min ((*lhs).R' (*rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DarkenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DarkenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min ((*lhs).B' (*rhs).B); }; { fG = Math.Min ((*lhs).G' (*rhs).G); }; { fR = Math.Min ((*lhs).R' (*rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DarkenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DarkenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min ((*lhs).B' (*rhs).B); }; { fG = Math.Min ((*lhs).G' (*rhs).G); }; { fR = Math.Min ((*lhs).R' (*rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DarkenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DarkenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min ((*lhs).B' (*rhs).B); }; { fG = Math.Min ((*lhs).G' (*rhs).G); }; { fR = Math.Min ((*lhs).R' (*rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DarkenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DarkenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min ((*lhs).B' (*rhs).B); }; { fG = Math.Min ((*lhs).G' (*rhs).G); }; { fR = Math.Min ((*lhs).R' (*rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DarkenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DarkenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min ((*lhs).B' (*rhs).B); }; { fG = Math.Min ((*lhs).G' (*rhs).G); }; { fR = Math.Min ((*lhs).R' (*rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DarkenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DarkenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min ((*lhs).B' (*rhs).B); }; { fG = Math.Min ((*lhs).G' (*rhs).G); }; { fR = Math.Min ((*lhs).R' (*rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DarkenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DarkenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min ((*lhs).B' (*rhs).B); }; { fG = Math.Min ((*lhs).G' (*rhs).G); }; { fR = Math.Min ((*lhs).R' (*rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DarkenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DarkenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Min ((*lhs).B' (*rhs).B); }; { fG = Math.Min ((*lhs).G' (*rhs).G); }; { fR = Math.Min ((*lhs).R' (*rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DarkenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DarkenBlendOp.cs,DarkenBlendOpWithOpacity,The following statement contains a magic number: if (this.opacity < 0 || this.opacity > 255) { throw new ArgumentOutOfRangeException (); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,LightenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\LightenBlendOp.cs,Apply,The following statement contains a magic number: { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,LightenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\LightenBlendOp.cs,Apply,The following statement contains a magic number: { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,LightenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\LightenBlendOp.cs,Apply,The following statement contains a magic number: { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,LightenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\LightenBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Max ((lhs).B' (rhs).B); }; { fG = Math.Max ((lhs).G' (rhs).G); }; { fR = Math.Max ((lhs).R' (rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,LightenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\LightenBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Max ((lhs).B' (rhs).B); }; { fG = Math.Max ((lhs).G' (rhs).G); }; { fR = Math.Max ((lhs).R' (rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,LightenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\LightenBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Max ((lhs).B' (rhs).B); }; { fG = Math.Max ((lhs).G' (rhs).G); }; { fR = Math.Max ((lhs).R' (rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,LightenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\LightenBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Max ((lhs).B' (rhs).B); }; { fG = Math.Max ((lhs).G' (rhs).G); }; { fR = Math.Max ((lhs).R' (rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,LightenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\LightenBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Max ((lhs).B' (rhs).B); }; { fG = Math.Max ((lhs).G' (rhs).G); }; { fR = Math.Max ((lhs).R' (rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,LightenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\LightenBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Max ((lhs).B' (rhs).B); }; { fG = Math.Max ((lhs).G' (rhs).G); }; { fR = Math.Max ((lhs).R' (rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,LightenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\LightenBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Max ((lhs).B' (rhs).B); }; { fG = Math.Max ((lhs).G' (rhs).G); }; { fR = Math.Max ((lhs).R' (rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,LightenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\LightenBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Max ((lhs).B' (rhs).B); }; { fG = Math.Max ((lhs).G' (rhs).G); }; { fR = Math.Max ((lhs).R' (rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,LightenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\LightenBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Max ((lhs).B' (rhs).B); }; { fG = Math.Max ((lhs).G' (rhs).G); }; { fR = Math.Max ((lhs).R' (rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,LightenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\LightenBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Max ((lhs).B' (rhs).B); }; { fG = Math.Max ((lhs).G' (rhs).G); }; { fR = Math.Max ((lhs).R' (rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,LightenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\LightenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Max ((*dst).B' (*src).B); }; { fG = Math.Max ((*dst).G' (*src).G); }; { fR = Math.Max ((*dst).R' (*src).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,LightenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\LightenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Max ((*dst).B' (*src).B); }; { fG = Math.Max ((*dst).G' (*src).G); }; { fR = Math.Max ((*dst).R' (*src).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,LightenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\LightenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Max ((*dst).B' (*src).B); }; { fG = Math.Max ((*dst).G' (*src).G); }; { fR = Math.Max ((*dst).R' (*src).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,LightenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\LightenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Max ((*dst).B' (*src).B); }; { fG = Math.Max ((*dst).G' (*src).G); }; { fR = Math.Max ((*dst).R' (*src).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,LightenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\LightenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Max ((*dst).B' (*src).B); }; { fG = Math.Max ((*dst).G' (*src).G); }; { fR = Math.Max ((*dst).R' (*src).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,LightenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\LightenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Max ((*dst).B' (*src).B); }; { fG = Math.Max ((*dst).G' (*src).G); }; { fR = Math.Max ((*dst).R' (*src).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,LightenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\LightenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Max ((*dst).B' (*src).B); }; { fG = Math.Max ((*dst).G' (*src).G); }; { fR = Math.Max ((*dst).R' (*src).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,LightenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\LightenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Max ((*dst).B' (*src).B); }; { fG = Math.Max ((*dst).G' (*src).G); }; { fR = Math.Max ((*dst).R' (*src).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,LightenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\LightenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Max ((*dst).B' (*src).B); }; { fG = Math.Max ((*dst).G' (*src).G); }; { fR = Math.Max ((*dst).R' (*src).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,LightenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\LightenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Max ((*dst).B' (*src).B); }; { fG = Math.Max ((*dst).G' (*src).G); }; { fR = Math.Max ((*dst).R' (*src).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,LightenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\LightenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Max ((*dst).B' (*src).B); }; { fG = Math.Max ((*dst).G' (*src).G); }; { fR = Math.Max ((*dst).R' (*src).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,LightenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\LightenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Max ((*dst).B' (*src).B); }; { fG = Math.Max ((*dst).G' (*src).G); }; { fR = Math.Max ((*dst).R' (*src).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,LightenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\LightenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Max ((*dst).B' (*src).B); }; { fG = Math.Max ((*dst).G' (*src).G); }; { fR = Math.Max ((*dst).R' (*src).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,LightenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\LightenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Max ((*lhs).B' (*rhs).B); }; { fG = Math.Max ((*lhs).G' (*rhs).G); }; { fR = Math.Max ((*lhs).R' (*rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,LightenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\LightenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Max ((*lhs).B' (*rhs).B); }; { fG = Math.Max ((*lhs).G' (*rhs).G); }; { fR = Math.Max ((*lhs).R' (*rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,LightenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\LightenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Max ((*lhs).B' (*rhs).B); }; { fG = Math.Max ((*lhs).G' (*rhs).G); }; { fR = Math.Max ((*lhs).R' (*rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,LightenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\LightenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Max ((*lhs).B' (*rhs).B); }; { fG = Math.Max ((*lhs).G' (*rhs).G); }; { fR = Math.Max ((*lhs).R' (*rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,LightenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\LightenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Max ((*lhs).B' (*rhs).B); }; { fG = Math.Max ((*lhs).G' (*rhs).G); }; { fR = Math.Max ((*lhs).R' (*rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,LightenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\LightenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Max ((*lhs).B' (*rhs).B); }; { fG = Math.Max ((*lhs).G' (*rhs).G); }; { fR = Math.Max ((*lhs).R' (*rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,LightenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\LightenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Max ((*lhs).B' (*rhs).B); }; { fG = Math.Max ((*lhs).G' (*rhs).G); }; { fR = Math.Max ((*lhs).R' (*rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,LightenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\LightenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Max ((*lhs).B' (*rhs).B); }; { fG = Math.Max ((*lhs).G' (*rhs).G); }; { fR = Math.Max ((*lhs).R' (*rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,LightenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\LightenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Max ((*lhs).B' (*rhs).B); }; { fG = Math.Max ((*lhs).G' (*rhs).G); }; { fR = Math.Max ((*lhs).R' (*rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,LightenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\LightenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Max ((*lhs).B' (*rhs).B); }; { fG = Math.Max ((*lhs).G' (*rhs).G); }; { fR = Math.Max ((*lhs).R' (*rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,LightenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\LightenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Max ((*lhs).B' (*rhs).B); }; { fG = Math.Max ((*lhs).G' (*rhs).G); }; { fR = Math.Max ((*lhs).R' (*rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,LightenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\LightenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Max ((*lhs).B' (*rhs).B); }; { fG = Math.Max ((*lhs).G' (*rhs).G); }; { fR = Math.Max ((*lhs).R' (*rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,LightenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\LightenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Max ((*lhs).B' (*rhs).B); }; { fG = Math.Max ((*lhs).G' (*rhs).G); }; { fR = Math.Max ((*lhs).R' (*rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,LightenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\LightenBlendOp.cs,ApplyStatic,The following statement contains a magic number: { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,LightenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\LightenBlendOp.cs,ApplyStatic,The following statement contains a magic number: { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,LightenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\LightenBlendOp.cs,ApplyStatic,The following statement contains a magic number: { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,LightenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\LightenBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Max ((lhs).B' (rhs).B); }; { fG = Math.Max ((lhs).G' (rhs).G); }; { fR = Math.Max ((lhs).R' (rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,LightenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\LightenBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Max ((lhs).B' (rhs).B); }; { fG = Math.Max ((lhs).G' (rhs).G); }; { fR = Math.Max ((lhs).R' (rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,LightenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\LightenBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Max ((lhs).B' (rhs).B); }; { fG = Math.Max ((lhs).G' (rhs).G); }; { fR = Math.Max ((lhs).R' (rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,LightenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\LightenBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Max ((lhs).B' (rhs).B); }; { fG = Math.Max ((lhs).G' (rhs).G); }; { fR = Math.Max ((lhs).R' (rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,LightenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\LightenBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Max ((lhs).B' (rhs).B); }; { fG = Math.Max ((lhs).G' (rhs).G); }; { fR = Math.Max ((lhs).R' (rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,LightenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\LightenBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Max ((lhs).B' (rhs).B); }; { fG = Math.Max ((lhs).G' (rhs).G); }; { fR = Math.Max ((lhs).R' (rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,LightenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\LightenBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Max ((lhs).B' (rhs).B); }; { fG = Math.Max ((lhs).G' (rhs).G); }; { fR = Math.Max ((lhs).R' (rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,LightenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\LightenBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Max ((lhs).B' (rhs).B); }; { fG = Math.Max ((lhs).G' (rhs).G); }; { fR = Math.Max ((lhs).R' (rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,LightenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\LightenBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Max ((lhs).B' (rhs).B); }; { fG = Math.Max ((lhs).G' (rhs).G); }; { fR = Math.Max ((lhs).R' (rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,LightenBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\LightenBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Max ((lhs).B' (rhs).B); }; { fG = Math.Max ((lhs).G' (rhs).G); }; { fR = Math.Max ((lhs).R' (rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,LightenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\LightenBlendOp.cs,ApplyOpacity,The following statement contains a magic number: { r = ((r) * (this.opacity) + 0x80); r = ((((r) >> 8) + (r)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,LightenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\LightenBlendOp.cs,ApplyOpacity,The following statement contains a magic number: { r = ((r) * (this.opacity) + 0x80); r = ((((r) >> 8) + (r)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,LightenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\LightenBlendOp.cs,Apply,The following statement contains a magic number: { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,LightenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\LightenBlendOp.cs,Apply,The following statement contains a magic number: { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,LightenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\LightenBlendOp.cs,Apply,The following statement contains a magic number: { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,LightenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\LightenBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Max ((lhs).B' (rhs).B); }; { fG = Math.Max ((lhs).G' (rhs).G); }; { fR = Math.Max ((lhs).R' (rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,LightenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\LightenBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Max ((lhs).B' (rhs).B); }; { fG = Math.Max ((lhs).G' (rhs).G); }; { fR = Math.Max ((lhs).R' (rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,LightenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\LightenBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Max ((lhs).B' (rhs).B); }; { fG = Math.Max ((lhs).G' (rhs).G); }; { fR = Math.Max ((lhs).R' (rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,LightenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\LightenBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Max ((lhs).B' (rhs).B); }; { fG = Math.Max ((lhs).G' (rhs).G); }; { fR = Math.Max ((lhs).R' (rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,LightenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\LightenBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Max ((lhs).B' (rhs).B); }; { fG = Math.Max ((lhs).G' (rhs).G); }; { fR = Math.Max ((lhs).R' (rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,LightenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\LightenBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Max ((lhs).B' (rhs).B); }; { fG = Math.Max ((lhs).G' (rhs).G); }; { fR = Math.Max ((lhs).R' (rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,LightenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\LightenBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Max ((lhs).B' (rhs).B); }; { fG = Math.Max ((lhs).G' (rhs).G); }; { fR = Math.Max ((lhs).R' (rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,LightenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\LightenBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Max ((lhs).B' (rhs).B); }; { fG = Math.Max ((lhs).G' (rhs).G); }; { fR = Math.Max ((lhs).R' (rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,LightenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\LightenBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Max ((lhs).B' (rhs).B); }; { fG = Math.Max ((lhs).G' (rhs).G); }; { fR = Math.Max ((lhs).R' (rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,LightenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\LightenBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Max ((lhs).B' (rhs).B); }; { fG = Math.Max ((lhs).G' (rhs).G); }; { fR = Math.Max ((lhs).R' (rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,LightenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\LightenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Max ((*dst).B' (*src).B); }; { fG = Math.Max ((*dst).G' (*src).G); }; { fR = Math.Max ((*dst).R' (*src).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,LightenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\LightenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Max ((*dst).B' (*src).B); }; { fG = Math.Max ((*dst).G' (*src).G); }; { fR = Math.Max ((*dst).R' (*src).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,LightenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\LightenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Max ((*dst).B' (*src).B); }; { fG = Math.Max ((*dst).G' (*src).G); }; { fR = Math.Max ((*dst).R' (*src).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,LightenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\LightenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Max ((*dst).B' (*src).B); }; { fG = Math.Max ((*dst).G' (*src).G); }; { fR = Math.Max ((*dst).R' (*src).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,LightenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\LightenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Max ((*dst).B' (*src).B); }; { fG = Math.Max ((*dst).G' (*src).G); }; { fR = Math.Max ((*dst).R' (*src).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,LightenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\LightenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Max ((*dst).B' (*src).B); }; { fG = Math.Max ((*dst).G' (*src).G); }; { fR = Math.Max ((*dst).R' (*src).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,LightenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\LightenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Max ((*dst).B' (*src).B); }; { fG = Math.Max ((*dst).G' (*src).G); }; { fR = Math.Max ((*dst).R' (*src).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,LightenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\LightenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Max ((*dst).B' (*src).B); }; { fG = Math.Max ((*dst).G' (*src).G); }; { fR = Math.Max ((*dst).R' (*src).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,LightenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\LightenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Max ((*dst).B' (*src).B); }; { fG = Math.Max ((*dst).G' (*src).G); }; { fR = Math.Max ((*dst).R' (*src).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,LightenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\LightenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Max ((*dst).B' (*src).B); }; { fG = Math.Max ((*dst).G' (*src).G); }; { fR = Math.Max ((*dst).R' (*src).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,LightenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\LightenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Max ((*dst).B' (*src).B); }; { fG = Math.Max ((*dst).G' (*src).G); }; { fR = Math.Max ((*dst).R' (*src).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,LightenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\LightenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Max ((*dst).B' (*src).B); }; { fG = Math.Max ((*dst).G' (*src).G); }; { fR = Math.Max ((*dst).R' (*src).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,LightenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\LightenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Max ((*dst).B' (*src).B); }; { fG = Math.Max ((*dst).G' (*src).G); }; { fR = Math.Max ((*dst).R' (*src).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,LightenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\LightenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Max ((*lhs).B' (*rhs).B); }; { fG = Math.Max ((*lhs).G' (*rhs).G); }; { fR = Math.Max ((*lhs).R' (*rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,LightenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\LightenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Max ((*lhs).B' (*rhs).B); }; { fG = Math.Max ((*lhs).G' (*rhs).G); }; { fR = Math.Max ((*lhs).R' (*rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,LightenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\LightenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Max ((*lhs).B' (*rhs).B); }; { fG = Math.Max ((*lhs).G' (*rhs).G); }; { fR = Math.Max ((*lhs).R' (*rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,LightenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\LightenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Max ((*lhs).B' (*rhs).B); }; { fG = Math.Max ((*lhs).G' (*rhs).G); }; { fR = Math.Max ((*lhs).R' (*rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,LightenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\LightenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Max ((*lhs).B' (*rhs).B); }; { fG = Math.Max ((*lhs).G' (*rhs).G); }; { fR = Math.Max ((*lhs).R' (*rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,LightenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\LightenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Max ((*lhs).B' (*rhs).B); }; { fG = Math.Max ((*lhs).G' (*rhs).G); }; { fR = Math.Max ((*lhs).R' (*rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,LightenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\LightenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Max ((*lhs).B' (*rhs).B); }; { fG = Math.Max ((*lhs).G' (*rhs).G); }; { fR = Math.Max ((*lhs).R' (*rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,LightenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\LightenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Max ((*lhs).B' (*rhs).B); }; { fG = Math.Max ((*lhs).G' (*rhs).G); }; { fR = Math.Max ((*lhs).R' (*rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,LightenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\LightenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Max ((*lhs).B' (*rhs).B); }; { fG = Math.Max ((*lhs).G' (*rhs).G); }; { fR = Math.Max ((*lhs).R' (*rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,LightenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\LightenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Max ((*lhs).B' (*rhs).B); }; { fG = Math.Max ((*lhs).G' (*rhs).G); }; { fR = Math.Max ((*lhs).R' (*rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,LightenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\LightenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Max ((*lhs).B' (*rhs).B); }; { fG = Math.Max ((*lhs).G' (*rhs).G); }; { fR = Math.Max ((*lhs).R' (*rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,LightenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\LightenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Max ((*lhs).B' (*rhs).B); }; { fG = Math.Max ((*lhs).G' (*rhs).G); }; { fR = Math.Max ((*lhs).R' (*rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,LightenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\LightenBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Max ((*lhs).B' (*rhs).B); }; { fG = Math.Max ((*lhs).G' (*rhs).G); }; { fR = Math.Max ((*lhs).R' (*rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,LightenBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\LightenBlendOp.cs,LightenBlendOpWithOpacity,The following statement contains a magic number: if (this.opacity < 0 || this.opacity > 255) { throw new ArgumentOutOfRangeException (); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,Apply,The following statement contains a magic number: { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,Apply,The following statement contains a magic number: { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,Apply,The following statement contains a magic number: { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (255 - Math.Abs (255 - ((lhs).B) - ((rhs).B))); }; { fG = (255 - Math.Abs (255 - ((lhs).G) - ((rhs).G))); }; { fR = (255 - Math.Abs (255 - ((lhs).R) - ((rhs).R))); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (255 - Math.Abs (255 - ((lhs).B) - ((rhs).B))); }; { fG = (255 - Math.Abs (255 - ((lhs).G) - ((rhs).G))); }; { fR = (255 - Math.Abs (255 - ((lhs).R) - ((rhs).R))); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (255 - Math.Abs (255 - ((lhs).B) - ((rhs).B))); }; { fG = (255 - Math.Abs (255 - ((lhs).G) - ((rhs).G))); }; { fR = (255 - Math.Abs (255 - ((lhs).R) - ((rhs).R))); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (255 - Math.Abs (255 - ((lhs).B) - ((rhs).B))); }; { fG = (255 - Math.Abs (255 - ((lhs).G) - ((rhs).G))); }; { fR = (255 - Math.Abs (255 - ((lhs).R) - ((rhs).R))); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (255 - Math.Abs (255 - ((lhs).B) - ((rhs).B))); }; { fG = (255 - Math.Abs (255 - ((lhs).G) - ((rhs).G))); }; { fR = (255 - Math.Abs (255 - ((lhs).R) - ((rhs).R))); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (255 - Math.Abs (255 - ((lhs).B) - ((rhs).B))); }; { fG = (255 - Math.Abs (255 - ((lhs).G) - ((rhs).G))); }; { fR = (255 - Math.Abs (255 - ((lhs).R) - ((rhs).R))); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (255 - Math.Abs (255 - ((lhs).B) - ((rhs).B))); }; { fG = (255 - Math.Abs (255 - ((lhs).G) - ((rhs).G))); }; { fR = (255 - Math.Abs (255 - ((lhs).R) - ((rhs).R))); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (255 - Math.Abs (255 - ((lhs).B) - ((rhs).B))); }; { fG = (255 - Math.Abs (255 - ((lhs).G) - ((rhs).G))); }; { fR = (255 - Math.Abs (255 - ((lhs).R) - ((rhs).R))); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (255 - Math.Abs (255 - ((lhs).B) - ((rhs).B))); }; { fG = (255 - Math.Abs (255 - ((lhs).G) - ((rhs).G))); }; { fR = (255 - Math.Abs (255 - ((lhs).R) - ((rhs).R))); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (255 - Math.Abs (255 - ((lhs).B) - ((rhs).B))); }; { fG = (255 - Math.Abs (255 - ((lhs).G) - ((rhs).G))); }; { fR = (255 - Math.Abs (255 - ((lhs).R) - ((rhs).R))); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (255 - Math.Abs (255 - ((lhs).B) - ((rhs).B))); }; { fG = (255 - Math.Abs (255 - ((lhs).G) - ((rhs).G))); }; { fR = (255 - Math.Abs (255 - ((lhs).R) - ((rhs).R))); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (255 - Math.Abs (255 - ((lhs).B) - ((rhs).B))); }; { fG = (255 - Math.Abs (255 - ((lhs).G) - ((rhs).G))); }; { fR = (255 - Math.Abs (255 - ((lhs).R) - ((rhs).R))); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (255 - Math.Abs (255 - ((lhs).B) - ((rhs).B))); }; { fG = (255 - Math.Abs (255 - ((lhs).G) - ((rhs).G))); }; { fR = (255 - Math.Abs (255 - ((lhs).R) - ((rhs).R))); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (255 - Math.Abs (255 - ((lhs).B) - ((rhs).B))); }; { fG = (255 - Math.Abs (255 - ((lhs).G) - ((rhs).G))); }; { fR = (255 - Math.Abs (255 - ((lhs).R) - ((rhs).R))); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (255 - Math.Abs (255 - ((lhs).B) - ((rhs).B))); }; { fG = (255 - Math.Abs (255 - ((lhs).G) - ((rhs).G))); }; { fR = (255 - Math.Abs (255 - ((lhs).R) - ((rhs).R))); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (255 - Math.Abs (255 - ((lhs).B) - ((rhs).B))); }; { fG = (255 - Math.Abs (255 - ((lhs).G) - ((rhs).G))); }; { fR = (255 - Math.Abs (255 - ((lhs).R) - ((rhs).R))); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (255 - Math.Abs (255 - ((*dst).B) - ((*src).B))); }; { fG = (255 - Math.Abs (255 - ((*dst).G) - ((*src).G))); }; { fR = (255 - Math.Abs (255 - ((*dst).R) - ((*src).R))); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (255 - Math.Abs (255 - ((*dst).B) - ((*src).B))); }; { fG = (255 - Math.Abs (255 - ((*dst).G) - ((*src).G))); }; { fR = (255 - Math.Abs (255 - ((*dst).R) - ((*src).R))); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (255 - Math.Abs (255 - ((*dst).B) - ((*src).B))); }; { fG = (255 - Math.Abs (255 - ((*dst).G) - ((*src).G))); }; { fR = (255 - Math.Abs (255 - ((*dst).R) - ((*src).R))); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (255 - Math.Abs (255 - ((*dst).B) - ((*src).B))); }; { fG = (255 - Math.Abs (255 - ((*dst).G) - ((*src).G))); }; { fR = (255 - Math.Abs (255 - ((*dst).R) - ((*src).R))); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (255 - Math.Abs (255 - ((*dst).B) - ((*src).B))); }; { fG = (255 - Math.Abs (255 - ((*dst).G) - ((*src).G))); }; { fR = (255 - Math.Abs (255 - ((*dst).R) - ((*src).R))); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (255 - Math.Abs (255 - ((*dst).B) - ((*src).B))); }; { fG = (255 - Math.Abs (255 - ((*dst).G) - ((*src).G))); }; { fR = (255 - Math.Abs (255 - ((*dst).R) - ((*src).R))); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (255 - Math.Abs (255 - ((*dst).B) - ((*src).B))); }; { fG = (255 - Math.Abs (255 - ((*dst).G) - ((*src).G))); }; { fR = (255 - Math.Abs (255 - ((*dst).R) - ((*src).R))); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (255 - Math.Abs (255 - ((*dst).B) - ((*src).B))); }; { fG = (255 - Math.Abs (255 - ((*dst).G) - ((*src).G))); }; { fR = (255 - Math.Abs (255 - ((*dst).R) - ((*src).R))); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (255 - Math.Abs (255 - ((*dst).B) - ((*src).B))); }; { fG = (255 - Math.Abs (255 - ((*dst).G) - ((*src).G))); }; { fR = (255 - Math.Abs (255 - ((*dst).R) - ((*src).R))); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (255 - Math.Abs (255 - ((*dst).B) - ((*src).B))); }; { fG = (255 - Math.Abs (255 - ((*dst).G) - ((*src).G))); }; { fR = (255 - Math.Abs (255 - ((*dst).R) - ((*src).R))); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (255 - Math.Abs (255 - ((*dst).B) - ((*src).B))); }; { fG = (255 - Math.Abs (255 - ((*dst).G) - ((*src).G))); }; { fR = (255 - Math.Abs (255 - ((*dst).R) - ((*src).R))); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (255 - Math.Abs (255 - ((*dst).B) - ((*src).B))); }; { fG = (255 - Math.Abs (255 - ((*dst).G) - ((*src).G))); }; { fR = (255 - Math.Abs (255 - ((*dst).R) - ((*src).R))); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (255 - Math.Abs (255 - ((*dst).B) - ((*src).B))); }; { fG = (255 - Math.Abs (255 - ((*dst).G) - ((*src).G))); }; { fR = (255 - Math.Abs (255 - ((*dst).R) - ((*src).R))); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (255 - Math.Abs (255 - ((*dst).B) - ((*src).B))); }; { fG = (255 - Math.Abs (255 - ((*dst).G) - ((*src).G))); }; { fR = (255 - Math.Abs (255 - ((*dst).R) - ((*src).R))); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (255 - Math.Abs (255 - ((*dst).B) - ((*src).B))); }; { fG = (255 - Math.Abs (255 - ((*dst).G) - ((*src).G))); }; { fR = (255 - Math.Abs (255 - ((*dst).R) - ((*src).R))); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (255 - Math.Abs (255 - ((*dst).B) - ((*src).B))); }; { fG = (255 - Math.Abs (255 - ((*dst).G) - ((*src).G))); }; { fR = (255 - Math.Abs (255 - ((*dst).R) - ((*src).R))); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (255 - Math.Abs (255 - ((*dst).B) - ((*src).B))); }; { fG = (255 - Math.Abs (255 - ((*dst).G) - ((*src).G))); }; { fR = (255 - Math.Abs (255 - ((*dst).R) - ((*src).R))); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (255 - Math.Abs (255 - ((*dst).B) - ((*src).B))); }; { fG = (255 - Math.Abs (255 - ((*dst).G) - ((*src).G))); }; { fR = (255 - Math.Abs (255 - ((*dst).R) - ((*src).R))); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (255 - Math.Abs (255 - ((*dst).B) - ((*src).B))); }; { fG = (255 - Math.Abs (255 - ((*dst).G) - ((*src).G))); }; { fR = (255 - Math.Abs (255 - ((*dst).R) - ((*src).R))); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (255 - Math.Abs (255 - ((*lhs).B) - ((*rhs).B))); }; { fG = (255 - Math.Abs (255 - ((*lhs).G) - ((*rhs).G))); }; { fR = (255 - Math.Abs (255 - ((*lhs).R) - ((*rhs).R))); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (255 - Math.Abs (255 - ((*lhs).B) - ((*rhs).B))); }; { fG = (255 - Math.Abs (255 - ((*lhs).G) - ((*rhs).G))); }; { fR = (255 - Math.Abs (255 - ((*lhs).R) - ((*rhs).R))); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (255 - Math.Abs (255 - ((*lhs).B) - ((*rhs).B))); }; { fG = (255 - Math.Abs (255 - ((*lhs).G) - ((*rhs).G))); }; { fR = (255 - Math.Abs (255 - ((*lhs).R) - ((*rhs).R))); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (255 - Math.Abs (255 - ((*lhs).B) - ((*rhs).B))); }; { fG = (255 - Math.Abs (255 - ((*lhs).G) - ((*rhs).G))); }; { fR = (255 - Math.Abs (255 - ((*lhs).R) - ((*rhs).R))); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (255 - Math.Abs (255 - ((*lhs).B) - ((*rhs).B))); }; { fG = (255 - Math.Abs (255 - ((*lhs).G) - ((*rhs).G))); }; { fR = (255 - Math.Abs (255 - ((*lhs).R) - ((*rhs).R))); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (255 - Math.Abs (255 - ((*lhs).B) - ((*rhs).B))); }; { fG = (255 - Math.Abs (255 - ((*lhs).G) - ((*rhs).G))); }; { fR = (255 - Math.Abs (255 - ((*lhs).R) - ((*rhs).R))); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (255 - Math.Abs (255 - ((*lhs).B) - ((*rhs).B))); }; { fG = (255 - Math.Abs (255 - ((*lhs).G) - ((*rhs).G))); }; { fR = (255 - Math.Abs (255 - ((*lhs).R) - ((*rhs).R))); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (255 - Math.Abs (255 - ((*lhs).B) - ((*rhs).B))); }; { fG = (255 - Math.Abs (255 - ((*lhs).G) - ((*rhs).G))); }; { fR = (255 - Math.Abs (255 - ((*lhs).R) - ((*rhs).R))); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (255 - Math.Abs (255 - ((*lhs).B) - ((*rhs).B))); }; { fG = (255 - Math.Abs (255 - ((*lhs).G) - ((*rhs).G))); }; { fR = (255 - Math.Abs (255 - ((*lhs).R) - ((*rhs).R))); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (255 - Math.Abs (255 - ((*lhs).B) - ((*rhs).B))); }; { fG = (255 - Math.Abs (255 - ((*lhs).G) - ((*rhs).G))); }; { fR = (255 - Math.Abs (255 - ((*lhs).R) - ((*rhs).R))); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (255 - Math.Abs (255 - ((*lhs).B) - ((*rhs).B))); }; { fG = (255 - Math.Abs (255 - ((*lhs).G) - ((*rhs).G))); }; { fR = (255 - Math.Abs (255 - ((*lhs).R) - ((*rhs).R))); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (255 - Math.Abs (255 - ((*lhs).B) - ((*rhs).B))); }; { fG = (255 - Math.Abs (255 - ((*lhs).G) - ((*rhs).G))); }; { fR = (255 - Math.Abs (255 - ((*lhs).R) - ((*rhs).R))); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (255 - Math.Abs (255 - ((*lhs).B) - ((*rhs).B))); }; { fG = (255 - Math.Abs (255 - ((*lhs).G) - ((*rhs).G))); }; { fR = (255 - Math.Abs (255 - ((*lhs).R) - ((*rhs).R))); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (255 - Math.Abs (255 - ((*lhs).B) - ((*rhs).B))); }; { fG = (255 - Math.Abs (255 - ((*lhs).G) - ((*rhs).G))); }; { fR = (255 - Math.Abs (255 - ((*lhs).R) - ((*rhs).R))); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (255 - Math.Abs (255 - ((*lhs).B) - ((*rhs).B))); }; { fG = (255 - Math.Abs (255 - ((*lhs).G) - ((*rhs).G))); }; { fR = (255 - Math.Abs (255 - ((*lhs).R) - ((*rhs).R))); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (255 - Math.Abs (255 - ((*lhs).B) - ((*rhs).B))); }; { fG = (255 - Math.Abs (255 - ((*lhs).G) - ((*rhs).G))); }; { fR = (255 - Math.Abs (255 - ((*lhs).R) - ((*rhs).R))); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (255 - Math.Abs (255 - ((*lhs).B) - ((*rhs).B))); }; { fG = (255 - Math.Abs (255 - ((*lhs).G) - ((*rhs).G))); }; { fR = (255 - Math.Abs (255 - ((*lhs).R) - ((*rhs).R))); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (255 - Math.Abs (255 - ((*lhs).B) - ((*rhs).B))); }; { fG = (255 - Math.Abs (255 - ((*lhs).G) - ((*rhs).G))); }; { fR = (255 - Math.Abs (255 - ((*lhs).R) - ((*rhs).R))); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (255 - Math.Abs (255 - ((*lhs).B) - ((*rhs).B))); }; { fG = (255 - Math.Abs (255 - ((*lhs).G) - ((*rhs).G))); }; { fR = (255 - Math.Abs (255 - ((*lhs).R) - ((*rhs).R))); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,ApplyStatic,The following statement contains a magic number: { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,ApplyStatic,The following statement contains a magic number: { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,ApplyStatic,The following statement contains a magic number: { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (255 - Math.Abs (255 - ((lhs).B) - ((rhs).B))); }; { fG = (255 - Math.Abs (255 - ((lhs).G) - ((rhs).G))); }; { fR = (255 - Math.Abs (255 - ((lhs).R) - ((rhs).R))); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (255 - Math.Abs (255 - ((lhs).B) - ((rhs).B))); }; { fG = (255 - Math.Abs (255 - ((lhs).G) - ((rhs).G))); }; { fR = (255 - Math.Abs (255 - ((lhs).R) - ((rhs).R))); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (255 - Math.Abs (255 - ((lhs).B) - ((rhs).B))); }; { fG = (255 - Math.Abs (255 - ((lhs).G) - ((rhs).G))); }; { fR = (255 - Math.Abs (255 - ((lhs).R) - ((rhs).R))); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (255 - Math.Abs (255 - ((lhs).B) - ((rhs).B))); }; { fG = (255 - Math.Abs (255 - ((lhs).G) - ((rhs).G))); }; { fR = (255 - Math.Abs (255 - ((lhs).R) - ((rhs).R))); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (255 - Math.Abs (255 - ((lhs).B) - ((rhs).B))); }; { fG = (255 - Math.Abs (255 - ((lhs).G) - ((rhs).G))); }; { fR = (255 - Math.Abs (255 - ((lhs).R) - ((rhs).R))); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (255 - Math.Abs (255 - ((lhs).B) - ((rhs).B))); }; { fG = (255 - Math.Abs (255 - ((lhs).G) - ((rhs).G))); }; { fR = (255 - Math.Abs (255 - ((lhs).R) - ((rhs).R))); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (255 - Math.Abs (255 - ((lhs).B) - ((rhs).B))); }; { fG = (255 - Math.Abs (255 - ((lhs).G) - ((rhs).G))); }; { fR = (255 - Math.Abs (255 - ((lhs).R) - ((rhs).R))); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (255 - Math.Abs (255 - ((lhs).B) - ((rhs).B))); }; { fG = (255 - Math.Abs (255 - ((lhs).G) - ((rhs).G))); }; { fR = (255 - Math.Abs (255 - ((lhs).R) - ((rhs).R))); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (255 - Math.Abs (255 - ((lhs).B) - ((rhs).B))); }; { fG = (255 - Math.Abs (255 - ((lhs).G) - ((rhs).G))); }; { fR = (255 - Math.Abs (255 - ((lhs).R) - ((rhs).R))); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (255 - Math.Abs (255 - ((lhs).B) - ((rhs).B))); }; { fG = (255 - Math.Abs (255 - ((lhs).G) - ((rhs).G))); }; { fR = (255 - Math.Abs (255 - ((lhs).R) - ((rhs).R))); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (255 - Math.Abs (255 - ((lhs).B) - ((rhs).B))); }; { fG = (255 - Math.Abs (255 - ((lhs).G) - ((rhs).G))); }; { fR = (255 - Math.Abs (255 - ((lhs).R) - ((rhs).R))); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (255 - Math.Abs (255 - ((lhs).B) - ((rhs).B))); }; { fG = (255 - Math.Abs (255 - ((lhs).G) - ((rhs).G))); }; { fR = (255 - Math.Abs (255 - ((lhs).R) - ((rhs).R))); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (255 - Math.Abs (255 - ((lhs).B) - ((rhs).B))); }; { fG = (255 - Math.Abs (255 - ((lhs).G) - ((rhs).G))); }; { fR = (255 - Math.Abs (255 - ((lhs).R) - ((rhs).R))); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (255 - Math.Abs (255 - ((lhs).B) - ((rhs).B))); }; { fG = (255 - Math.Abs (255 - ((lhs).G) - ((rhs).G))); }; { fR = (255 - Math.Abs (255 - ((lhs).R) - ((rhs).R))); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (255 - Math.Abs (255 - ((lhs).B) - ((rhs).B))); }; { fG = (255 - Math.Abs (255 - ((lhs).G) - ((rhs).G))); }; { fR = (255 - Math.Abs (255 - ((lhs).R) - ((rhs).R))); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (255 - Math.Abs (255 - ((lhs).B) - ((rhs).B))); }; { fG = (255 - Math.Abs (255 - ((lhs).G) - ((rhs).G))); }; { fR = (255 - Math.Abs (255 - ((lhs).R) - ((rhs).R))); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,ApplyOpacity,The following statement contains a magic number: { r = ((r) * (this.opacity) + 0x80); r = ((((r) >> 8) + (r)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,ApplyOpacity,The following statement contains a magic number: { r = ((r) * (this.opacity) + 0x80); r = ((((r) >> 8) + (r)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,Apply,The following statement contains a magic number: { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,Apply,The following statement contains a magic number: { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,Apply,The following statement contains a magic number: { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (255 - Math.Abs (255 - ((lhs).B) - ((rhs).B))); }; { fG = (255 - Math.Abs (255 - ((lhs).G) - ((rhs).G))); }; { fR = (255 - Math.Abs (255 - ((lhs).R) - ((rhs).R))); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (255 - Math.Abs (255 - ((lhs).B) - ((rhs).B))); }; { fG = (255 - Math.Abs (255 - ((lhs).G) - ((rhs).G))); }; { fR = (255 - Math.Abs (255 - ((lhs).R) - ((rhs).R))); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (255 - Math.Abs (255 - ((lhs).B) - ((rhs).B))); }; { fG = (255 - Math.Abs (255 - ((lhs).G) - ((rhs).G))); }; { fR = (255 - Math.Abs (255 - ((lhs).R) - ((rhs).R))); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (255 - Math.Abs (255 - ((lhs).B) - ((rhs).B))); }; { fG = (255 - Math.Abs (255 - ((lhs).G) - ((rhs).G))); }; { fR = (255 - Math.Abs (255 - ((lhs).R) - ((rhs).R))); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (255 - Math.Abs (255 - ((lhs).B) - ((rhs).B))); }; { fG = (255 - Math.Abs (255 - ((lhs).G) - ((rhs).G))); }; { fR = (255 - Math.Abs (255 - ((lhs).R) - ((rhs).R))); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (255 - Math.Abs (255 - ((lhs).B) - ((rhs).B))); }; { fG = (255 - Math.Abs (255 - ((lhs).G) - ((rhs).G))); }; { fR = (255 - Math.Abs (255 - ((lhs).R) - ((rhs).R))); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (255 - Math.Abs (255 - ((lhs).B) - ((rhs).B))); }; { fG = (255 - Math.Abs (255 - ((lhs).G) - ((rhs).G))); }; { fR = (255 - Math.Abs (255 - ((lhs).R) - ((rhs).R))); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (255 - Math.Abs (255 - ((lhs).B) - ((rhs).B))); }; { fG = (255 - Math.Abs (255 - ((lhs).G) - ((rhs).G))); }; { fR = (255 - Math.Abs (255 - ((lhs).R) - ((rhs).R))); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (255 - Math.Abs (255 - ((lhs).B) - ((rhs).B))); }; { fG = (255 - Math.Abs (255 - ((lhs).G) - ((rhs).G))); }; { fR = (255 - Math.Abs (255 - ((lhs).R) - ((rhs).R))); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (255 - Math.Abs (255 - ((lhs).B) - ((rhs).B))); }; { fG = (255 - Math.Abs (255 - ((lhs).G) - ((rhs).G))); }; { fR = (255 - Math.Abs (255 - ((lhs).R) - ((rhs).R))); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (255 - Math.Abs (255 - ((lhs).B) - ((rhs).B))); }; { fG = (255 - Math.Abs (255 - ((lhs).G) - ((rhs).G))); }; { fR = (255 - Math.Abs (255 - ((lhs).R) - ((rhs).R))); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (255 - Math.Abs (255 - ((lhs).B) - ((rhs).B))); }; { fG = (255 - Math.Abs (255 - ((lhs).G) - ((rhs).G))); }; { fR = (255 - Math.Abs (255 - ((lhs).R) - ((rhs).R))); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (255 - Math.Abs (255 - ((lhs).B) - ((rhs).B))); }; { fG = (255 - Math.Abs (255 - ((lhs).G) - ((rhs).G))); }; { fR = (255 - Math.Abs (255 - ((lhs).R) - ((rhs).R))); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (255 - Math.Abs (255 - ((lhs).B) - ((rhs).B))); }; { fG = (255 - Math.Abs (255 - ((lhs).G) - ((rhs).G))); }; { fR = (255 - Math.Abs (255 - ((lhs).R) - ((rhs).R))); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (255 - Math.Abs (255 - ((lhs).B) - ((rhs).B))); }; { fG = (255 - Math.Abs (255 - ((lhs).G) - ((rhs).G))); }; { fR = (255 - Math.Abs (255 - ((lhs).R) - ((rhs).R))); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (255 - Math.Abs (255 - ((lhs).B) - ((rhs).B))); }; { fG = (255 - Math.Abs (255 - ((lhs).G) - ((rhs).G))); }; { fR = (255 - Math.Abs (255 - ((lhs).R) - ((rhs).R))); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (255 - Math.Abs (255 - ((*dst).B) - ((*src).B))); }; { fG = (255 - Math.Abs (255 - ((*dst).G) - ((*src).G))); }; { fR = (255 - Math.Abs (255 - ((*dst).R) - ((*src).R))); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (255 - Math.Abs (255 - ((*dst).B) - ((*src).B))); }; { fG = (255 - Math.Abs (255 - ((*dst).G) - ((*src).G))); }; { fR = (255 - Math.Abs (255 - ((*dst).R) - ((*src).R))); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (255 - Math.Abs (255 - ((*dst).B) - ((*src).B))); }; { fG = (255 - Math.Abs (255 - ((*dst).G) - ((*src).G))); }; { fR = (255 - Math.Abs (255 - ((*dst).R) - ((*src).R))); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (255 - Math.Abs (255 - ((*dst).B) - ((*src).B))); }; { fG = (255 - Math.Abs (255 - ((*dst).G) - ((*src).G))); }; { fR = (255 - Math.Abs (255 - ((*dst).R) - ((*src).R))); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (255 - Math.Abs (255 - ((*dst).B) - ((*src).B))); }; { fG = (255 - Math.Abs (255 - ((*dst).G) - ((*src).G))); }; { fR = (255 - Math.Abs (255 - ((*dst).R) - ((*src).R))); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (255 - Math.Abs (255 - ((*dst).B) - ((*src).B))); }; { fG = (255 - Math.Abs (255 - ((*dst).G) - ((*src).G))); }; { fR = (255 - Math.Abs (255 - ((*dst).R) - ((*src).R))); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (255 - Math.Abs (255 - ((*dst).B) - ((*src).B))); }; { fG = (255 - Math.Abs (255 - ((*dst).G) - ((*src).G))); }; { fR = (255 - Math.Abs (255 - ((*dst).R) - ((*src).R))); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (255 - Math.Abs (255 - ((*dst).B) - ((*src).B))); }; { fG = (255 - Math.Abs (255 - ((*dst).G) - ((*src).G))); }; { fR = (255 - Math.Abs (255 - ((*dst).R) - ((*src).R))); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (255 - Math.Abs (255 - ((*dst).B) - ((*src).B))); }; { fG = (255 - Math.Abs (255 - ((*dst).G) - ((*src).G))); }; { fR = (255 - Math.Abs (255 - ((*dst).R) - ((*src).R))); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (255 - Math.Abs (255 - ((*dst).B) - ((*src).B))); }; { fG = (255 - Math.Abs (255 - ((*dst).G) - ((*src).G))); }; { fR = (255 - Math.Abs (255 - ((*dst).R) - ((*src).R))); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (255 - Math.Abs (255 - ((*dst).B) - ((*src).B))); }; { fG = (255 - Math.Abs (255 - ((*dst).G) - ((*src).G))); }; { fR = (255 - Math.Abs (255 - ((*dst).R) - ((*src).R))); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (255 - Math.Abs (255 - ((*dst).B) - ((*src).B))); }; { fG = (255 - Math.Abs (255 - ((*dst).G) - ((*src).G))); }; { fR = (255 - Math.Abs (255 - ((*dst).R) - ((*src).R))); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (255 - Math.Abs (255 - ((*dst).B) - ((*src).B))); }; { fG = (255 - Math.Abs (255 - ((*dst).G) - ((*src).G))); }; { fR = (255 - Math.Abs (255 - ((*dst).R) - ((*src).R))); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (255 - Math.Abs (255 - ((*dst).B) - ((*src).B))); }; { fG = (255 - Math.Abs (255 - ((*dst).G) - ((*src).G))); }; { fR = (255 - Math.Abs (255 - ((*dst).R) - ((*src).R))); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (255 - Math.Abs (255 - ((*dst).B) - ((*src).B))); }; { fG = (255 - Math.Abs (255 - ((*dst).G) - ((*src).G))); }; { fR = (255 - Math.Abs (255 - ((*dst).R) - ((*src).R))); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (255 - Math.Abs (255 - ((*dst).B) - ((*src).B))); }; { fG = (255 - Math.Abs (255 - ((*dst).G) - ((*src).G))); }; { fR = (255 - Math.Abs (255 - ((*dst).R) - ((*src).R))); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (255 - Math.Abs (255 - ((*dst).B) - ((*src).B))); }; { fG = (255 - Math.Abs (255 - ((*dst).G) - ((*src).G))); }; { fR = (255 - Math.Abs (255 - ((*dst).R) - ((*src).R))); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (255 - Math.Abs (255 - ((*dst).B) - ((*src).B))); }; { fG = (255 - Math.Abs (255 - ((*dst).G) - ((*src).G))); }; { fR = (255 - Math.Abs (255 - ((*dst).R) - ((*src).R))); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (255 - Math.Abs (255 - ((*dst).B) - ((*src).B))); }; { fG = (255 - Math.Abs (255 - ((*dst).G) - ((*src).G))); }; { fR = (255 - Math.Abs (255 - ((*dst).R) - ((*src).R))); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (255 - Math.Abs (255 - ((*lhs).B) - ((*rhs).B))); }; { fG = (255 - Math.Abs (255 - ((*lhs).G) - ((*rhs).G))); }; { fR = (255 - Math.Abs (255 - ((*lhs).R) - ((*rhs).R))); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (255 - Math.Abs (255 - ((*lhs).B) - ((*rhs).B))); }; { fG = (255 - Math.Abs (255 - ((*lhs).G) - ((*rhs).G))); }; { fR = (255 - Math.Abs (255 - ((*lhs).R) - ((*rhs).R))); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (255 - Math.Abs (255 - ((*lhs).B) - ((*rhs).B))); }; { fG = (255 - Math.Abs (255 - ((*lhs).G) - ((*rhs).G))); }; { fR = (255 - Math.Abs (255 - ((*lhs).R) - ((*rhs).R))); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (255 - Math.Abs (255 - ((*lhs).B) - ((*rhs).B))); }; { fG = (255 - Math.Abs (255 - ((*lhs).G) - ((*rhs).G))); }; { fR = (255 - Math.Abs (255 - ((*lhs).R) - ((*rhs).R))); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (255 - Math.Abs (255 - ((*lhs).B) - ((*rhs).B))); }; { fG = (255 - Math.Abs (255 - ((*lhs).G) - ((*rhs).G))); }; { fR = (255 - Math.Abs (255 - ((*lhs).R) - ((*rhs).R))); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (255 - Math.Abs (255 - ((*lhs).B) - ((*rhs).B))); }; { fG = (255 - Math.Abs (255 - ((*lhs).G) - ((*rhs).G))); }; { fR = (255 - Math.Abs (255 - ((*lhs).R) - ((*rhs).R))); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (255 - Math.Abs (255 - ((*lhs).B) - ((*rhs).B))); }; { fG = (255 - Math.Abs (255 - ((*lhs).G) - ((*rhs).G))); }; { fR = (255 - Math.Abs (255 - ((*lhs).R) - ((*rhs).R))); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (255 - Math.Abs (255 - ((*lhs).B) - ((*rhs).B))); }; { fG = (255 - Math.Abs (255 - ((*lhs).G) - ((*rhs).G))); }; { fR = (255 - Math.Abs (255 - ((*lhs).R) - ((*rhs).R))); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (255 - Math.Abs (255 - ((*lhs).B) - ((*rhs).B))); }; { fG = (255 - Math.Abs (255 - ((*lhs).G) - ((*rhs).G))); }; { fR = (255 - Math.Abs (255 - ((*lhs).R) - ((*rhs).R))); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (255 - Math.Abs (255 - ((*lhs).B) - ((*rhs).B))); }; { fG = (255 - Math.Abs (255 - ((*lhs).G) - ((*rhs).G))); }; { fR = (255 - Math.Abs (255 - ((*lhs).R) - ((*rhs).R))); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (255 - Math.Abs (255 - ((*lhs).B) - ((*rhs).B))); }; { fG = (255 - Math.Abs (255 - ((*lhs).G) - ((*rhs).G))); }; { fR = (255 - Math.Abs (255 - ((*lhs).R) - ((*rhs).R))); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (255 - Math.Abs (255 - ((*lhs).B) - ((*rhs).B))); }; { fG = (255 - Math.Abs (255 - ((*lhs).G) - ((*rhs).G))); }; { fR = (255 - Math.Abs (255 - ((*lhs).R) - ((*rhs).R))); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (255 - Math.Abs (255 - ((*lhs).B) - ((*rhs).B))); }; { fG = (255 - Math.Abs (255 - ((*lhs).G) - ((*rhs).G))); }; { fR = (255 - Math.Abs (255 - ((*lhs).R) - ((*rhs).R))); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (255 - Math.Abs (255 - ((*lhs).B) - ((*rhs).B))); }; { fG = (255 - Math.Abs (255 - ((*lhs).G) - ((*rhs).G))); }; { fR = (255 - Math.Abs (255 - ((*lhs).R) - ((*rhs).R))); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (255 - Math.Abs (255 - ((*lhs).B) - ((*rhs).B))); }; { fG = (255 - Math.Abs (255 - ((*lhs).G) - ((*rhs).G))); }; { fR = (255 - Math.Abs (255 - ((*lhs).R) - ((*rhs).R))); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (255 - Math.Abs (255 - ((*lhs).B) - ((*rhs).B))); }; { fG = (255 - Math.Abs (255 - ((*lhs).G) - ((*rhs).G))); }; { fR = (255 - Math.Abs (255 - ((*lhs).R) - ((*rhs).R))); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (255 - Math.Abs (255 - ((*lhs).B) - ((*rhs).B))); }; { fG = (255 - Math.Abs (255 - ((*lhs).G) - ((*rhs).G))); }; { fR = (255 - Math.Abs (255 - ((*lhs).R) - ((*rhs).R))); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (255 - Math.Abs (255 - ((*lhs).B) - ((*rhs).B))); }; { fG = (255 - Math.Abs (255 - ((*lhs).G) - ((*rhs).G))); }; { fR = (255 - Math.Abs (255 - ((*lhs).R) - ((*rhs).R))); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (255 - Math.Abs (255 - ((*lhs).B) - ((*rhs).B))); }; { fG = (255 - Math.Abs (255 - ((*lhs).G) - ((*rhs).G))); }; { fR = (255 - Math.Abs (255 - ((*lhs).R) - ((*rhs).R))); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NegationBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NegationBlendOp.cs,NegationBlendOpWithOpacity,The following statement contains a magic number: if (this.opacity < 0 || this.opacity > 255) { throw new ArgumentOutOfRangeException (); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DifferenceBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DifferenceBlendOp.cs,Apply,The following statement contains a magic number: { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DifferenceBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DifferenceBlendOp.cs,Apply,The following statement contains a magic number: { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DifferenceBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DifferenceBlendOp.cs,Apply,The following statement contains a magic number: { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DifferenceBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DifferenceBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Abs (((rhs).B) - ((lhs).B)); }; { fG = Math.Abs (((rhs).G) - ((lhs).G)); }; { fR = Math.Abs (((rhs).R) - ((lhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DifferenceBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DifferenceBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Abs (((rhs).B) - ((lhs).B)); }; { fG = Math.Abs (((rhs).G) - ((lhs).G)); }; { fR = Math.Abs (((rhs).R) - ((lhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DifferenceBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DifferenceBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Abs (((rhs).B) - ((lhs).B)); }; { fG = Math.Abs (((rhs).G) - ((lhs).G)); }; { fR = Math.Abs (((rhs).R) - ((lhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DifferenceBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DifferenceBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Abs (((rhs).B) - ((lhs).B)); }; { fG = Math.Abs (((rhs).G) - ((lhs).G)); }; { fR = Math.Abs (((rhs).R) - ((lhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DifferenceBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DifferenceBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Abs (((rhs).B) - ((lhs).B)); }; { fG = Math.Abs (((rhs).G) - ((lhs).G)); }; { fR = Math.Abs (((rhs).R) - ((lhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DifferenceBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DifferenceBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Abs (((rhs).B) - ((lhs).B)); }; { fG = Math.Abs (((rhs).G) - ((lhs).G)); }; { fR = Math.Abs (((rhs).R) - ((lhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DifferenceBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DifferenceBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Abs (((rhs).B) - ((lhs).B)); }; { fG = Math.Abs (((rhs).G) - ((lhs).G)); }; { fR = Math.Abs (((rhs).R) - ((lhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DifferenceBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DifferenceBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Abs (((rhs).B) - ((lhs).B)); }; { fG = Math.Abs (((rhs).G) - ((lhs).G)); }; { fR = Math.Abs (((rhs).R) - ((lhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DifferenceBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DifferenceBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Abs (((rhs).B) - ((lhs).B)); }; { fG = Math.Abs (((rhs).G) - ((lhs).G)); }; { fR = Math.Abs (((rhs).R) - ((lhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DifferenceBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DifferenceBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Abs (((rhs).B) - ((lhs).B)); }; { fG = Math.Abs (((rhs).G) - ((lhs).G)); }; { fR = Math.Abs (((rhs).R) - ((lhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DifferenceBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DifferenceBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Abs (((*src).B) - ((*dst).B)); }; { fG = Math.Abs (((*src).G) - ((*dst).G)); }; { fR = Math.Abs (((*src).R) - ((*dst).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DifferenceBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DifferenceBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Abs (((*src).B) - ((*dst).B)); }; { fG = Math.Abs (((*src).G) - ((*dst).G)); }; { fR = Math.Abs (((*src).R) - ((*dst).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DifferenceBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DifferenceBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Abs (((*src).B) - ((*dst).B)); }; { fG = Math.Abs (((*src).G) - ((*dst).G)); }; { fR = Math.Abs (((*src).R) - ((*dst).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DifferenceBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DifferenceBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Abs (((*src).B) - ((*dst).B)); }; { fG = Math.Abs (((*src).G) - ((*dst).G)); }; { fR = Math.Abs (((*src).R) - ((*dst).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DifferenceBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DifferenceBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Abs (((*src).B) - ((*dst).B)); }; { fG = Math.Abs (((*src).G) - ((*dst).G)); }; { fR = Math.Abs (((*src).R) - ((*dst).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DifferenceBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DifferenceBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Abs (((*src).B) - ((*dst).B)); }; { fG = Math.Abs (((*src).G) - ((*dst).G)); }; { fR = Math.Abs (((*src).R) - ((*dst).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DifferenceBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DifferenceBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Abs (((*src).B) - ((*dst).B)); }; { fG = Math.Abs (((*src).G) - ((*dst).G)); }; { fR = Math.Abs (((*src).R) - ((*dst).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DifferenceBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DifferenceBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Abs (((*src).B) - ((*dst).B)); }; { fG = Math.Abs (((*src).G) - ((*dst).G)); }; { fR = Math.Abs (((*src).R) - ((*dst).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DifferenceBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DifferenceBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Abs (((*src).B) - ((*dst).B)); }; { fG = Math.Abs (((*src).G) - ((*dst).G)); }; { fR = Math.Abs (((*src).R) - ((*dst).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DifferenceBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DifferenceBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Abs (((*src).B) - ((*dst).B)); }; { fG = Math.Abs (((*src).G) - ((*dst).G)); }; { fR = Math.Abs (((*src).R) - ((*dst).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DifferenceBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DifferenceBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Abs (((*src).B) - ((*dst).B)); }; { fG = Math.Abs (((*src).G) - ((*dst).G)); }; { fR = Math.Abs (((*src).R) - ((*dst).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DifferenceBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DifferenceBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Abs (((*src).B) - ((*dst).B)); }; { fG = Math.Abs (((*src).G) - ((*dst).G)); }; { fR = Math.Abs (((*src).R) - ((*dst).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DifferenceBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DifferenceBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Abs (((*src).B) - ((*dst).B)); }; { fG = Math.Abs (((*src).G) - ((*dst).G)); }; { fR = Math.Abs (((*src).R) - ((*dst).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DifferenceBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DifferenceBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Abs (((*rhs).B) - ((*lhs).B)); }; { fG = Math.Abs (((*rhs).G) - ((*lhs).G)); }; { fR = Math.Abs (((*rhs).R) - ((*lhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DifferenceBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DifferenceBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Abs (((*rhs).B) - ((*lhs).B)); }; { fG = Math.Abs (((*rhs).G) - ((*lhs).G)); }; { fR = Math.Abs (((*rhs).R) - ((*lhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DifferenceBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DifferenceBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Abs (((*rhs).B) - ((*lhs).B)); }; { fG = Math.Abs (((*rhs).G) - ((*lhs).G)); }; { fR = Math.Abs (((*rhs).R) - ((*lhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DifferenceBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DifferenceBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Abs (((*rhs).B) - ((*lhs).B)); }; { fG = Math.Abs (((*rhs).G) - ((*lhs).G)); }; { fR = Math.Abs (((*rhs).R) - ((*lhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DifferenceBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DifferenceBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Abs (((*rhs).B) - ((*lhs).B)); }; { fG = Math.Abs (((*rhs).G) - ((*lhs).G)); }; { fR = Math.Abs (((*rhs).R) - ((*lhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DifferenceBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DifferenceBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Abs (((*rhs).B) - ((*lhs).B)); }; { fG = Math.Abs (((*rhs).G) - ((*lhs).G)); }; { fR = Math.Abs (((*rhs).R) - ((*lhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DifferenceBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DifferenceBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Abs (((*rhs).B) - ((*lhs).B)); }; { fG = Math.Abs (((*rhs).G) - ((*lhs).G)); }; { fR = Math.Abs (((*rhs).R) - ((*lhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DifferenceBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DifferenceBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Abs (((*rhs).B) - ((*lhs).B)); }; { fG = Math.Abs (((*rhs).G) - ((*lhs).G)); }; { fR = Math.Abs (((*rhs).R) - ((*lhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DifferenceBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DifferenceBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Abs (((*rhs).B) - ((*lhs).B)); }; { fG = Math.Abs (((*rhs).G) - ((*lhs).G)); }; { fR = Math.Abs (((*rhs).R) - ((*lhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DifferenceBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DifferenceBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Abs (((*rhs).B) - ((*lhs).B)); }; { fG = Math.Abs (((*rhs).G) - ((*lhs).G)); }; { fR = Math.Abs (((*rhs).R) - ((*lhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DifferenceBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DifferenceBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Abs (((*rhs).B) - ((*lhs).B)); }; { fG = Math.Abs (((*rhs).G) - ((*lhs).G)); }; { fR = Math.Abs (((*rhs).R) - ((*lhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DifferenceBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DifferenceBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Abs (((*rhs).B) - ((*lhs).B)); }; { fG = Math.Abs (((*rhs).G) - ((*lhs).G)); }; { fR = Math.Abs (((*rhs).R) - ((*lhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DifferenceBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DifferenceBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Abs (((*rhs).B) - ((*lhs).B)); }; { fG = Math.Abs (((*rhs).G) - ((*lhs).G)); }; { fR = Math.Abs (((*rhs).R) - ((*lhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DifferenceBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DifferenceBlendOp.cs,ApplyStatic,The following statement contains a magic number: { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DifferenceBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DifferenceBlendOp.cs,ApplyStatic,The following statement contains a magic number: { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DifferenceBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DifferenceBlendOp.cs,ApplyStatic,The following statement contains a magic number: { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DifferenceBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DifferenceBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Abs (((rhs).B) - ((lhs).B)); }; { fG = Math.Abs (((rhs).G) - ((lhs).G)); }; { fR = Math.Abs (((rhs).R) - ((lhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DifferenceBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DifferenceBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Abs (((rhs).B) - ((lhs).B)); }; { fG = Math.Abs (((rhs).G) - ((lhs).G)); }; { fR = Math.Abs (((rhs).R) - ((lhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DifferenceBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DifferenceBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Abs (((rhs).B) - ((lhs).B)); }; { fG = Math.Abs (((rhs).G) - ((lhs).G)); }; { fR = Math.Abs (((rhs).R) - ((lhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DifferenceBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DifferenceBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Abs (((rhs).B) - ((lhs).B)); }; { fG = Math.Abs (((rhs).G) - ((lhs).G)); }; { fR = Math.Abs (((rhs).R) - ((lhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DifferenceBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DifferenceBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Abs (((rhs).B) - ((lhs).B)); }; { fG = Math.Abs (((rhs).G) - ((lhs).G)); }; { fR = Math.Abs (((rhs).R) - ((lhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DifferenceBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DifferenceBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Abs (((rhs).B) - ((lhs).B)); }; { fG = Math.Abs (((rhs).G) - ((lhs).G)); }; { fR = Math.Abs (((rhs).R) - ((lhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DifferenceBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DifferenceBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Abs (((rhs).B) - ((lhs).B)); }; { fG = Math.Abs (((rhs).G) - ((lhs).G)); }; { fR = Math.Abs (((rhs).R) - ((lhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DifferenceBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DifferenceBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Abs (((rhs).B) - ((lhs).B)); }; { fG = Math.Abs (((rhs).G) - ((lhs).G)); }; { fR = Math.Abs (((rhs).R) - ((lhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DifferenceBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DifferenceBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Abs (((rhs).B) - ((lhs).B)); }; { fG = Math.Abs (((rhs).G) - ((lhs).G)); }; { fR = Math.Abs (((rhs).R) - ((lhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DifferenceBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DifferenceBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Abs (((rhs).B) - ((lhs).B)); }; { fG = Math.Abs (((rhs).G) - ((lhs).G)); }; { fR = Math.Abs (((rhs).R) - ((lhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DifferenceBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DifferenceBlendOp.cs,ApplyOpacity,The following statement contains a magic number: { r = ((r) * (this.opacity) + 0x80); r = ((((r) >> 8) + (r)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DifferenceBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DifferenceBlendOp.cs,ApplyOpacity,The following statement contains a magic number: { r = ((r) * (this.opacity) + 0x80); r = ((((r) >> 8) + (r)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DifferenceBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DifferenceBlendOp.cs,Apply,The following statement contains a magic number: { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DifferenceBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DifferenceBlendOp.cs,Apply,The following statement contains a magic number: { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DifferenceBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DifferenceBlendOp.cs,Apply,The following statement contains a magic number: { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DifferenceBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DifferenceBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Abs (((rhs).B) - ((lhs).B)); }; { fG = Math.Abs (((rhs).G) - ((lhs).G)); }; { fR = Math.Abs (((rhs).R) - ((lhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DifferenceBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DifferenceBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Abs (((rhs).B) - ((lhs).B)); }; { fG = Math.Abs (((rhs).G) - ((lhs).G)); }; { fR = Math.Abs (((rhs).R) - ((lhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DifferenceBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DifferenceBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Abs (((rhs).B) - ((lhs).B)); }; { fG = Math.Abs (((rhs).G) - ((lhs).G)); }; { fR = Math.Abs (((rhs).R) - ((lhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DifferenceBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DifferenceBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Abs (((rhs).B) - ((lhs).B)); }; { fG = Math.Abs (((rhs).G) - ((lhs).G)); }; { fR = Math.Abs (((rhs).R) - ((lhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DifferenceBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DifferenceBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Abs (((rhs).B) - ((lhs).B)); }; { fG = Math.Abs (((rhs).G) - ((lhs).G)); }; { fR = Math.Abs (((rhs).R) - ((lhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DifferenceBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DifferenceBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Abs (((rhs).B) - ((lhs).B)); }; { fG = Math.Abs (((rhs).G) - ((lhs).G)); }; { fR = Math.Abs (((rhs).R) - ((lhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DifferenceBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DifferenceBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Abs (((rhs).B) - ((lhs).B)); }; { fG = Math.Abs (((rhs).G) - ((lhs).G)); }; { fR = Math.Abs (((rhs).R) - ((lhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DifferenceBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DifferenceBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Abs (((rhs).B) - ((lhs).B)); }; { fG = Math.Abs (((rhs).G) - ((lhs).G)); }; { fR = Math.Abs (((rhs).R) - ((lhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DifferenceBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DifferenceBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Abs (((rhs).B) - ((lhs).B)); }; { fG = Math.Abs (((rhs).G) - ((lhs).G)); }; { fR = Math.Abs (((rhs).R) - ((lhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DifferenceBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DifferenceBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Abs (((rhs).B) - ((lhs).B)); }; { fG = Math.Abs (((rhs).G) - ((lhs).G)); }; { fR = Math.Abs (((rhs).R) - ((lhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DifferenceBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DifferenceBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Abs (((*src).B) - ((*dst).B)); }; { fG = Math.Abs (((*src).G) - ((*dst).G)); }; { fR = Math.Abs (((*src).R) - ((*dst).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DifferenceBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DifferenceBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Abs (((*src).B) - ((*dst).B)); }; { fG = Math.Abs (((*src).G) - ((*dst).G)); }; { fR = Math.Abs (((*src).R) - ((*dst).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DifferenceBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DifferenceBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Abs (((*src).B) - ((*dst).B)); }; { fG = Math.Abs (((*src).G) - ((*dst).G)); }; { fR = Math.Abs (((*src).R) - ((*dst).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DifferenceBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DifferenceBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Abs (((*src).B) - ((*dst).B)); }; { fG = Math.Abs (((*src).G) - ((*dst).G)); }; { fR = Math.Abs (((*src).R) - ((*dst).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DifferenceBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DifferenceBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Abs (((*src).B) - ((*dst).B)); }; { fG = Math.Abs (((*src).G) - ((*dst).G)); }; { fR = Math.Abs (((*src).R) - ((*dst).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DifferenceBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DifferenceBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Abs (((*src).B) - ((*dst).B)); }; { fG = Math.Abs (((*src).G) - ((*dst).G)); }; { fR = Math.Abs (((*src).R) - ((*dst).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DifferenceBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DifferenceBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Abs (((*src).B) - ((*dst).B)); }; { fG = Math.Abs (((*src).G) - ((*dst).G)); }; { fR = Math.Abs (((*src).R) - ((*dst).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DifferenceBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DifferenceBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Abs (((*src).B) - ((*dst).B)); }; { fG = Math.Abs (((*src).G) - ((*dst).G)); }; { fR = Math.Abs (((*src).R) - ((*dst).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DifferenceBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DifferenceBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Abs (((*src).B) - ((*dst).B)); }; { fG = Math.Abs (((*src).G) - ((*dst).G)); }; { fR = Math.Abs (((*src).R) - ((*dst).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DifferenceBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DifferenceBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Abs (((*src).B) - ((*dst).B)); }; { fG = Math.Abs (((*src).G) - ((*dst).G)); }; { fR = Math.Abs (((*src).R) - ((*dst).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DifferenceBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DifferenceBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Abs (((*src).B) - ((*dst).B)); }; { fG = Math.Abs (((*src).G) - ((*dst).G)); }; { fR = Math.Abs (((*src).R) - ((*dst).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DifferenceBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DifferenceBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Abs (((*src).B) - ((*dst).B)); }; { fG = Math.Abs (((*src).G) - ((*dst).G)); }; { fR = Math.Abs (((*src).R) - ((*dst).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DifferenceBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DifferenceBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Abs (((*src).B) - ((*dst).B)); }; { fG = Math.Abs (((*src).G) - ((*dst).G)); }; { fR = Math.Abs (((*src).R) - ((*dst).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DifferenceBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DifferenceBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Abs (((*rhs).B) - ((*lhs).B)); }; { fG = Math.Abs (((*rhs).G) - ((*lhs).G)); }; { fR = Math.Abs (((*rhs).R) - ((*lhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DifferenceBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DifferenceBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Abs (((*rhs).B) - ((*lhs).B)); }; { fG = Math.Abs (((*rhs).G) - ((*lhs).G)); }; { fR = Math.Abs (((*rhs).R) - ((*lhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DifferenceBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DifferenceBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Abs (((*rhs).B) - ((*lhs).B)); }; { fG = Math.Abs (((*rhs).G) - ((*lhs).G)); }; { fR = Math.Abs (((*rhs).R) - ((*lhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DifferenceBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DifferenceBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Abs (((*rhs).B) - ((*lhs).B)); }; { fG = Math.Abs (((*rhs).G) - ((*lhs).G)); }; { fR = Math.Abs (((*rhs).R) - ((*lhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DifferenceBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DifferenceBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Abs (((*rhs).B) - ((*lhs).B)); }; { fG = Math.Abs (((*rhs).G) - ((*lhs).G)); }; { fR = Math.Abs (((*rhs).R) - ((*lhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DifferenceBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DifferenceBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Abs (((*rhs).B) - ((*lhs).B)); }; { fG = Math.Abs (((*rhs).G) - ((*lhs).G)); }; { fR = Math.Abs (((*rhs).R) - ((*lhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DifferenceBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DifferenceBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Abs (((*rhs).B) - ((*lhs).B)); }; { fG = Math.Abs (((*rhs).G) - ((*lhs).G)); }; { fR = Math.Abs (((*rhs).R) - ((*lhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DifferenceBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DifferenceBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Abs (((*rhs).B) - ((*lhs).B)); }; { fG = Math.Abs (((*rhs).G) - ((*lhs).G)); }; { fR = Math.Abs (((*rhs).R) - ((*lhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DifferenceBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DifferenceBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Abs (((*rhs).B) - ((*lhs).B)); }; { fG = Math.Abs (((*rhs).G) - ((*lhs).G)); }; { fR = Math.Abs (((*rhs).R) - ((*lhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DifferenceBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DifferenceBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Abs (((*rhs).B) - ((*lhs).B)); }; { fG = Math.Abs (((*rhs).G) - ((*lhs).G)); }; { fR = Math.Abs (((*rhs).R) - ((*lhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DifferenceBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DifferenceBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Abs (((*rhs).B) - ((*lhs).B)); }; { fG = Math.Abs (((*rhs).G) - ((*lhs).G)); }; { fR = Math.Abs (((*rhs).R) - ((*lhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DifferenceBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DifferenceBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Abs (((*rhs).B) - ((*lhs).B)); }; { fG = Math.Abs (((*rhs).G) - ((*lhs).G)); }; { fR = Math.Abs (((*rhs).R) - ((*lhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DifferenceBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DifferenceBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = Math.Abs (((*rhs).B) - ((*lhs).B)); }; { fG = Math.Abs (((*rhs).G) - ((*lhs).G)); }; { fR = Math.Abs (((*rhs).R) - ((*lhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,DifferenceBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\DifferenceBlendOp.cs,DifferenceBlendOpWithOpacity,The following statement contains a magic number: if (this.opacity < 0 || this.opacity > 255) { throw new ArgumentOutOfRangeException (); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) < 128) { { fB = ((2 * ((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((lhs).B))) * (255 - ((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((lhs).G) < 128) { { fG = ((2 * ((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((lhs).G))) * (255 - ((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((lhs).R) < 128) { { fR = ((2 * ((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((lhs).R))) * (255 - ((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) < 128) { { fB = ((2 * ((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((lhs).B))) * (255 - ((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((lhs).G) < 128) { { fG = ((2 * ((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((lhs).G))) * (255 - ((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((lhs).R) < 128) { { fR = ((2 * ((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((lhs).R))) * (255 - ((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) < 128) { { fB = ((2 * ((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((lhs).B))) * (255 - ((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((lhs).G) < 128) { { fG = ((2 * ((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((lhs).G))) * (255 - ((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((lhs).R) < 128) { { fR = ((2 * ((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((lhs).R))) * (255 - ((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) < 128) { { fB = ((2 * ((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((lhs).B))) * (255 - ((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((lhs).G) < 128) { { fG = ((2 * ((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((lhs).G))) * (255 - ((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((lhs).R) < 128) { { fR = ((2 * ((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((lhs).R))) * (255 - ((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) < 128) { { fB = ((2 * ((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((lhs).B))) * (255 - ((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((lhs).G) < 128) { { fG = ((2 * ((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((lhs).G))) * (255 - ((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((lhs).R) < 128) { { fR = ((2 * ((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((lhs).R))) * (255 - ((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) < 128) { { fB = ((2 * ((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((lhs).B))) * (255 - ((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((lhs).G) < 128) { { fG = ((2 * ((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((lhs).G))) * (255 - ((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((lhs).R) < 128) { { fR = ((2 * ((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((lhs).R))) * (255 - ((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) < 128) { { fB = ((2 * ((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((lhs).B))) * (255 - ((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((lhs).G) < 128) { { fG = ((2 * ((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((lhs).G))) * (255 - ((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((lhs).R) < 128) { { fR = ((2 * ((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((lhs).R))) * (255 - ((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) < 128) { { fB = ((2 * ((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((lhs).B))) * (255 - ((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((lhs).G) < 128) { { fG = ((2 * ((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((lhs).G))) * (255 - ((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((lhs).R) < 128) { { fR = ((2 * ((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((lhs).R))) * (255 - ((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) < 128) { { fB = ((2 * ((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((lhs).B))) * (255 - ((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((lhs).G) < 128) { { fG = ((2 * ((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((lhs).G))) * (255 - ((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((lhs).R) < 128) { { fR = ((2 * ((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((lhs).R))) * (255 - ((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) < 128) { { fB = ((2 * ((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((lhs).B))) * (255 - ((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((lhs).G) < 128) { { fG = ((2 * ((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((lhs).G))) * (255 - ((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((lhs).R) < 128) { { fR = ((2 * ((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((lhs).R))) * (255 - ((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) < 128) { { fB = ((2 * ((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((lhs).B))) * (255 - ((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((lhs).G) < 128) { { fG = ((2 * ((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((lhs).G))) * (255 - ((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((lhs).R) < 128) { { fR = ((2 * ((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((lhs).R))) * (255 - ((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) < 128) { { fB = ((2 * ((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((lhs).B))) * (255 - ((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((lhs).G) < 128) { { fG = ((2 * ((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((lhs).G))) * (255 - ((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((lhs).R) < 128) { { fR = ((2 * ((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((lhs).R))) * (255 - ((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) < 128) { { fB = ((2 * ((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((lhs).B))) * (255 - ((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((lhs).G) < 128) { { fG = ((2 * ((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((lhs).G))) * (255 - ((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((lhs).R) < 128) { { fR = ((2 * ((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((lhs).R))) * (255 - ((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) < 128) { { fB = ((2 * ((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((lhs).B))) * (255 - ((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((lhs).G) < 128) { { fG = ((2 * ((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((lhs).G))) * (255 - ((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((lhs).R) < 128) { { fR = ((2 * ((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((lhs).R))) * (255 - ((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) < 128) { { fB = ((2 * ((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((lhs).B))) * (255 - ((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((lhs).G) < 128) { { fG = ((2 * ((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((lhs).G))) * (255 - ((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((lhs).R) < 128) { { fR = ((2 * ((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((lhs).R))) * (255 - ((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) < 128) { { fB = ((2 * ((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((lhs).B))) * (255 - ((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((lhs).G) < 128) { { fG = ((2 * ((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((lhs).G))) * (255 - ((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((lhs).R) < 128) { { fR = ((2 * ((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((lhs).R))) * (255 - ((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) < 128) { { fB = ((2 * ((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((lhs).B))) * (255 - ((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((lhs).G) < 128) { { fG = ((2 * ((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((lhs).G))) * (255 - ((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((lhs).R) < 128) { { fR = ((2 * ((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((lhs).R))) * (255 - ((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) < 128) { { fB = ((2 * ((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((lhs).B))) * (255 - ((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((lhs).G) < 128) { { fG = ((2 * ((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((lhs).G))) * (255 - ((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((lhs).R) < 128) { { fR = ((2 * ((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((lhs).R))) * (255 - ((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) < 128) { { fB = ((2 * ((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((lhs).B))) * (255 - ((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((lhs).G) < 128) { { fG = ((2 * ((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((lhs).G))) * (255 - ((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((lhs).R) < 128) { { fR = ((2 * ((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((lhs).R))) * (255 - ((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) < 128) { { fB = ((2 * ((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((lhs).B))) * (255 - ((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((lhs).G) < 128) { { fG = ((2 * ((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((lhs).G))) * (255 - ((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((lhs).R) < 128) { { fR = ((2 * ((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((lhs).R))) * (255 - ((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) < 128) { { fB = ((2 * ((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((lhs).B))) * (255 - ((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((lhs).G) < 128) { { fG = ((2 * ((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((lhs).G))) * (255 - ((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((lhs).R) < 128) { { fR = ((2 * ((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((lhs).R))) * (255 - ((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) < 128) { { fB = ((2 * ((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((lhs).B))) * (255 - ((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((lhs).G) < 128) { { fG = ((2 * ((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((lhs).G))) * (255 - ((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((lhs).R) < 128) { { fR = ((2 * ((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((lhs).R))) * (255 - ((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) < 128) { { fB = ((2 * ((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((lhs).B))) * (255 - ((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((lhs).G) < 128) { { fG = ((2 * ((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((lhs).G))) * (255 - ((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((lhs).R) < 128) { { fR = ((2 * ((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((lhs).R))) * (255 - ((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) < 128) { { fB = ((2 * ((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((lhs).B))) * (255 - ((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((lhs).G) < 128) { { fG = ((2 * ((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((lhs).G))) * (255 - ((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((lhs).R) < 128) { { fR = ((2 * ((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((lhs).R))) * (255 - ((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) < 128) { { fB = ((2 * ((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((lhs).B))) * (255 - ((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((lhs).G) < 128) { { fG = ((2 * ((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((lhs).G))) * (255 - ((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((lhs).R) < 128) { { fR = ((2 * ((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((lhs).R))) * (255 - ((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) < 128) { { fB = ((2 * ((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((lhs).B))) * (255 - ((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((lhs).G) < 128) { { fG = ((2 * ((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((lhs).G))) * (255 - ((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((lhs).R) < 128) { { fR = ((2 * ((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((lhs).R))) * (255 - ((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) < 128) { { fB = ((2 * ((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((lhs).B))) * (255 - ((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((lhs).G) < 128) { { fG = ((2 * ((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((lhs).G))) * (255 - ((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((lhs).R) < 128) { { fR = ((2 * ((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((lhs).R))) * (255 - ((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) < 128) { { fB = ((2 * ((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((lhs).B))) * (255 - ((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((lhs).G) < 128) { { fG = ((2 * ((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((lhs).G))) * (255 - ((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((lhs).R) < 128) { { fR = ((2 * ((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((lhs).R))) * (255 - ((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) < 128) { { fB = ((2 * ((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((lhs).B))) * (255 - ((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((lhs).G) < 128) { { fG = ((2 * ((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((lhs).G))) * (255 - ((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((lhs).R) < 128) { { fR = ((2 * ((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((lhs).R))) * (255 - ((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) < 128) { { fB = ((2 * ((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((lhs).B))) * (255 - ((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((lhs).G) < 128) { { fG = ((2 * ((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((lhs).G))) * (255 - ((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((lhs).R) < 128) { { fR = ((2 * ((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((lhs).R))) * (255 - ((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) < 128) { { fB = ((2 * ((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((lhs).B))) * (255 - ((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((lhs).G) < 128) { { fG = ((2 * ((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((lhs).G))) * (255 - ((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((lhs).R) < 128) { { fR = ((2 * ((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((lhs).R))) * (255 - ((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) < 128) { { fB = ((2 * ((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((lhs).B))) * (255 - ((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((lhs).G) < 128) { { fG = ((2 * ((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((lhs).G))) * (255 - ((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((lhs).R) < 128) { { fR = ((2 * ((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((lhs).R))) * (255 - ((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) < 128) { { fB = ((2 * ((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((lhs).B))) * (255 - ((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((lhs).G) < 128) { { fG = ((2 * ((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((lhs).G))) * (255 - ((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((lhs).R) < 128) { { fR = ((2 * ((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((lhs).R))) * (255 - ((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) < 128) { { fB = ((2 * ((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((lhs).B))) * (255 - ((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((lhs).G) < 128) { { fG = ((2 * ((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((lhs).G))) * (255 - ((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((lhs).R) < 128) { { fR = ((2 * ((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((lhs).R))) * (255 - ((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) < 128) { { fB = ((2 * ((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((lhs).B))) * (255 - ((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((lhs).G) < 128) { { fG = ((2 * ((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((lhs).G))) * (255 - ((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((lhs).R) < 128) { { fR = ((2 * ((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((lhs).R))) * (255 - ((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) < 128) { { fB = ((2 * ((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((lhs).B))) * (255 - ((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((lhs).G) < 128) { { fG = ((2 * ((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((lhs).G))) * (255 - ((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((lhs).R) < 128) { { fR = ((2 * ((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((lhs).R))) * (255 - ((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) < 128) { { fB = ((2 * ((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((lhs).B))) * (255 - ((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((lhs).G) < 128) { { fG = ((2 * ((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((lhs).G))) * (255 - ((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((lhs).R) < 128) { { fR = ((2 * ((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((lhs).R))) * (255 - ((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) < 128) { { fB = ((2 * ((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((lhs).B))) * (255 - ((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((lhs).G) < 128) { { fG = ((2 * ((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((lhs).G))) * (255 - ((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((lhs).R) < 128) { { fR = ((2 * ((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((lhs).R))) * (255 - ((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) < 128) { { fB = ((2 * ((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((lhs).B))) * (255 - ((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((lhs).G) < 128) { { fG = ((2 * ((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((lhs).G))) * (255 - ((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((lhs).R) < 128) { { fR = ((2 * ((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((lhs).R))) * (255 - ((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) < 128) { { fB = ((2 * ((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((lhs).B))) * (255 - ((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((lhs).G) < 128) { { fG = ((2 * ((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((lhs).G))) * (255 - ((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((lhs).R) < 128) { { fR = ((2 * ((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((lhs).R))) * (255 - ((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) < 128) { { fB = ((2 * ((*dst).B)) * (((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*dst).B))) * (255 - ((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*dst).G) < 128) { { fG = ((2 * ((*dst).G)) * (((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*dst).G))) * (255 - ((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*dst).R) < 128) { { fR = ((2 * ((*dst).R)) * (((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*dst).R))) * (255 - ((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) < 128) { { fB = ((2 * ((*dst).B)) * (((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*dst).B))) * (255 - ((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*dst).G) < 128) { { fG = ((2 * ((*dst).G)) * (((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*dst).G))) * (255 - ((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*dst).R) < 128) { { fR = ((2 * ((*dst).R)) * (((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*dst).R))) * (255 - ((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) < 128) { { fB = ((2 * ((*dst).B)) * (((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*dst).B))) * (255 - ((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*dst).G) < 128) { { fG = ((2 * ((*dst).G)) * (((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*dst).G))) * (255 - ((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*dst).R) < 128) { { fR = ((2 * ((*dst).R)) * (((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*dst).R))) * (255 - ((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) < 128) { { fB = ((2 * ((*dst).B)) * (((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*dst).B))) * (255 - ((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*dst).G) < 128) { { fG = ((2 * ((*dst).G)) * (((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*dst).G))) * (255 - ((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*dst).R) < 128) { { fR = ((2 * ((*dst).R)) * (((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*dst).R))) * (255 - ((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) < 128) { { fB = ((2 * ((*dst).B)) * (((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*dst).B))) * (255 - ((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*dst).G) < 128) { { fG = ((2 * ((*dst).G)) * (((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*dst).G))) * (255 - ((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*dst).R) < 128) { { fR = ((2 * ((*dst).R)) * (((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*dst).R))) * (255 - ((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) < 128) { { fB = ((2 * ((*dst).B)) * (((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*dst).B))) * (255 - ((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*dst).G) < 128) { { fG = ((2 * ((*dst).G)) * (((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*dst).G))) * (255 - ((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*dst).R) < 128) { { fR = ((2 * ((*dst).R)) * (((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*dst).R))) * (255 - ((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) < 128) { { fB = ((2 * ((*dst).B)) * (((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*dst).B))) * (255 - ((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*dst).G) < 128) { { fG = ((2 * ((*dst).G)) * (((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*dst).G))) * (255 - ((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*dst).R) < 128) { { fR = ((2 * ((*dst).R)) * (((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*dst).R))) * (255 - ((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) < 128) { { fB = ((2 * ((*dst).B)) * (((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*dst).B))) * (255 - ((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*dst).G) < 128) { { fG = ((2 * ((*dst).G)) * (((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*dst).G))) * (255 - ((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*dst).R) < 128) { { fR = ((2 * ((*dst).R)) * (((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*dst).R))) * (255 - ((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) < 128) { { fB = ((2 * ((*dst).B)) * (((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*dst).B))) * (255 - ((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*dst).G) < 128) { { fG = ((2 * ((*dst).G)) * (((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*dst).G))) * (255 - ((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*dst).R) < 128) { { fR = ((2 * ((*dst).R)) * (((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*dst).R))) * (255 - ((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) < 128) { { fB = ((2 * ((*dst).B)) * (((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*dst).B))) * (255 - ((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*dst).G) < 128) { { fG = ((2 * ((*dst).G)) * (((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*dst).G))) * (255 - ((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*dst).R) < 128) { { fR = ((2 * ((*dst).R)) * (((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*dst).R))) * (255 - ((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) < 128) { { fB = ((2 * ((*dst).B)) * (((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*dst).B))) * (255 - ((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*dst).G) < 128) { { fG = ((2 * ((*dst).G)) * (((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*dst).G))) * (255 - ((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*dst).R) < 128) { { fR = ((2 * ((*dst).R)) * (((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*dst).R))) * (255 - ((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) < 128) { { fB = ((2 * ((*dst).B)) * (((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*dst).B))) * (255 - ((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*dst).G) < 128) { { fG = ((2 * ((*dst).G)) * (((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*dst).G))) * (255 - ((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*dst).R) < 128) { { fR = ((2 * ((*dst).R)) * (((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*dst).R))) * (255 - ((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) < 128) { { fB = ((2 * ((*dst).B)) * (((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*dst).B))) * (255 - ((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*dst).G) < 128) { { fG = ((2 * ((*dst).G)) * (((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*dst).G))) * (255 - ((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*dst).R) < 128) { { fR = ((2 * ((*dst).R)) * (((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*dst).R))) * (255 - ((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) < 128) { { fB = ((2 * ((*dst).B)) * (((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*dst).B))) * (255 - ((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*dst).G) < 128) { { fG = ((2 * ((*dst).G)) * (((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*dst).G))) * (255 - ((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*dst).R) < 128) { { fR = ((2 * ((*dst).R)) * (((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*dst).R))) * (255 - ((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) < 128) { { fB = ((2 * ((*dst).B)) * (((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*dst).B))) * (255 - ((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*dst).G) < 128) { { fG = ((2 * ((*dst).G)) * (((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*dst).G))) * (255 - ((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*dst).R) < 128) { { fR = ((2 * ((*dst).R)) * (((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*dst).R))) * (255 - ((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) < 128) { { fB = ((2 * ((*dst).B)) * (((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*dst).B))) * (255 - ((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*dst).G) < 128) { { fG = ((2 * ((*dst).G)) * (((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*dst).G))) * (255 - ((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*dst).R) < 128) { { fR = ((2 * ((*dst).R)) * (((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*dst).R))) * (255 - ((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) < 128) { { fB = ((2 * ((*dst).B)) * (((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*dst).B))) * (255 - ((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*dst).G) < 128) { { fG = ((2 * ((*dst).G)) * (((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*dst).G))) * (255 - ((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*dst).R) < 128) { { fR = ((2 * ((*dst).R)) * (((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*dst).R))) * (255 - ((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) < 128) { { fB = ((2 * ((*dst).B)) * (((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*dst).B))) * (255 - ((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*dst).G) < 128) { { fG = ((2 * ((*dst).G)) * (((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*dst).G))) * (255 - ((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*dst).R) < 128) { { fR = ((2 * ((*dst).R)) * (((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*dst).R))) * (255 - ((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) < 128) { { fB = ((2 * ((*dst).B)) * (((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*dst).B))) * (255 - ((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*dst).G) < 128) { { fG = ((2 * ((*dst).G)) * (((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*dst).G))) * (255 - ((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*dst).R) < 128) { { fR = ((2 * ((*dst).R)) * (((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*dst).R))) * (255 - ((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) < 128) { { fB = ((2 * ((*dst).B)) * (((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*dst).B))) * (255 - ((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*dst).G) < 128) { { fG = ((2 * ((*dst).G)) * (((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*dst).G))) * (255 - ((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*dst).R) < 128) { { fR = ((2 * ((*dst).R)) * (((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*dst).R))) * (255 - ((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) < 128) { { fB = ((2 * ((*dst).B)) * (((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*dst).B))) * (255 - ((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*dst).G) < 128) { { fG = ((2 * ((*dst).G)) * (((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*dst).G))) * (255 - ((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*dst).R) < 128) { { fR = ((2 * ((*dst).R)) * (((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*dst).R))) * (255 - ((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) < 128) { { fB = ((2 * ((*dst).B)) * (((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*dst).B))) * (255 - ((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*dst).G) < 128) { { fG = ((2 * ((*dst).G)) * (((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*dst).G))) * (255 - ((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*dst).R) < 128) { { fR = ((2 * ((*dst).R)) * (((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*dst).R))) * (255 - ((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) < 128) { { fB = ((2 * ((*dst).B)) * (((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*dst).B))) * (255 - ((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*dst).G) < 128) { { fG = ((2 * ((*dst).G)) * (((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*dst).G))) * (255 - ((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*dst).R) < 128) { { fR = ((2 * ((*dst).R)) * (((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*dst).R))) * (255 - ((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) < 128) { { fB = ((2 * ((*dst).B)) * (((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*dst).B))) * (255 - ((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*dst).G) < 128) { { fG = ((2 * ((*dst).G)) * (((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*dst).G))) * (255 - ((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*dst).R) < 128) { { fR = ((2 * ((*dst).R)) * (((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*dst).R))) * (255 - ((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) < 128) { { fB = ((2 * ((*dst).B)) * (((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*dst).B))) * (255 - ((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*dst).G) < 128) { { fG = ((2 * ((*dst).G)) * (((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*dst).G))) * (255 - ((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*dst).R) < 128) { { fR = ((2 * ((*dst).R)) * (((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*dst).R))) * (255 - ((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) < 128) { { fB = ((2 * ((*dst).B)) * (((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*dst).B))) * (255 - ((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*dst).G) < 128) { { fG = ((2 * ((*dst).G)) * (((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*dst).G))) * (255 - ((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*dst).R) < 128) { { fR = ((2 * ((*dst).R)) * (((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*dst).R))) * (255 - ((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) < 128) { { fB = ((2 * ((*dst).B)) * (((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*dst).B))) * (255 - ((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*dst).G) < 128) { { fG = ((2 * ((*dst).G)) * (((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*dst).G))) * (255 - ((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*dst).R) < 128) { { fR = ((2 * ((*dst).R)) * (((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*dst).R))) * (255 - ((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) < 128) { { fB = ((2 * ((*dst).B)) * (((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*dst).B))) * (255 - ((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*dst).G) < 128) { { fG = ((2 * ((*dst).G)) * (((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*dst).G))) * (255 - ((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*dst).R) < 128) { { fR = ((2 * ((*dst).R)) * (((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*dst).R))) * (255 - ((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) < 128) { { fB = ((2 * ((*dst).B)) * (((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*dst).B))) * (255 - ((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*dst).G) < 128) { { fG = ((2 * ((*dst).G)) * (((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*dst).G))) * (255 - ((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*dst).R) < 128) { { fR = ((2 * ((*dst).R)) * (((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*dst).R))) * (255 - ((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) < 128) { { fB = ((2 * ((*dst).B)) * (((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*dst).B))) * (255 - ((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*dst).G) < 128) { { fG = ((2 * ((*dst).G)) * (((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*dst).G))) * (255 - ((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*dst).R) < 128) { { fR = ((2 * ((*dst).R)) * (((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*dst).R))) * (255 - ((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) < 128) { { fB = ((2 * ((*dst).B)) * (((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*dst).B))) * (255 - ((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*dst).G) < 128) { { fG = ((2 * ((*dst).G)) * (((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*dst).G))) * (255 - ((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*dst).R) < 128) { { fR = ((2 * ((*dst).R)) * (((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*dst).R))) * (255 - ((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) < 128) { { fB = ((2 * ((*dst).B)) * (((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*dst).B))) * (255 - ((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*dst).G) < 128) { { fG = ((2 * ((*dst).G)) * (((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*dst).G))) * (255 - ((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*dst).R) < 128) { { fR = ((2 * ((*dst).R)) * (((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*dst).R))) * (255 - ((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) < 128) { { fB = ((2 * ((*dst).B)) * (((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*dst).B))) * (255 - ((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*dst).G) < 128) { { fG = ((2 * ((*dst).G)) * (((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*dst).G))) * (255 - ((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*dst).R) < 128) { { fR = ((2 * ((*dst).R)) * (((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*dst).R))) * (255 - ((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) < 128) { { fB = ((2 * ((*dst).B)) * (((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*dst).B))) * (255 - ((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*dst).G) < 128) { { fG = ((2 * ((*dst).G)) * (((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*dst).G))) * (255 - ((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*dst).R) < 128) { { fR = ((2 * ((*dst).R)) * (((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*dst).R))) * (255 - ((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) < 128) { { fB = ((2 * ((*dst).B)) * (((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*dst).B))) * (255 - ((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*dst).G) < 128) { { fG = ((2 * ((*dst).G)) * (((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*dst).G))) * (255 - ((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*dst).R) < 128) { { fR = ((2 * ((*dst).R)) * (((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*dst).R))) * (255 - ((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) < 128) { { fB = ((2 * ((*dst).B)) * (((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*dst).B))) * (255 - ((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*dst).G) < 128) { { fG = ((2 * ((*dst).G)) * (((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*dst).G))) * (255 - ((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*dst).R) < 128) { { fR = ((2 * ((*dst).R)) * (((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*dst).R))) * (255 - ((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) < 128) { { fB = ((2 * ((*dst).B)) * (((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*dst).B))) * (255 - ((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*dst).G) < 128) { { fG = ((2 * ((*dst).G)) * (((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*dst).G))) * (255 - ((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*dst).R) < 128) { { fR = ((2 * ((*dst).R)) * (((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*dst).R))) * (255 - ((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) < 128) { { fB = ((2 * ((*dst).B)) * (((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*dst).B))) * (255 - ((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*dst).G) < 128) { { fG = ((2 * ((*dst).G)) * (((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*dst).G))) * (255 - ((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*dst).R) < 128) { { fR = ((2 * ((*dst).R)) * (((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*dst).R))) * (255 - ((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) < 128) { { fB = ((2 * ((*dst).B)) * (((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*dst).B))) * (255 - ((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*dst).G) < 128) { { fG = ((2 * ((*dst).G)) * (((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*dst).G))) * (255 - ((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*dst).R) < 128) { { fR = ((2 * ((*dst).R)) * (((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*dst).R))) * (255 - ((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) < 128) { { fB = ((2 * ((*dst).B)) * (((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*dst).B))) * (255 - ((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*dst).G) < 128) { { fG = ((2 * ((*dst).G)) * (((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*dst).G))) * (255 - ((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*dst).R) < 128) { { fR = ((2 * ((*dst).R)) * (((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*dst).R))) * (255 - ((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) < 128) { { fB = ((2 * ((*dst).B)) * (((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*dst).B))) * (255 - ((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*dst).G) < 128) { { fG = ((2 * ((*dst).G)) * (((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*dst).G))) * (255 - ((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*dst).R) < 128) { { fR = ((2 * ((*dst).R)) * (((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*dst).R))) * (255 - ((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) < 128) { { fB = ((2 * ((*dst).B)) * (((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*dst).B))) * (255 - ((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*dst).G) < 128) { { fG = ((2 * ((*dst).G)) * (((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*dst).G))) * (255 - ((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*dst).R) < 128) { { fR = ((2 * ((*dst).R)) * (((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*dst).R))) * (255 - ((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) < 128) { { fB = ((2 * ((*dst).B)) * (((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*dst).B))) * (255 - ((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*dst).G) < 128) { { fG = ((2 * ((*dst).G)) * (((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*dst).G))) * (255 - ((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*dst).R) < 128) { { fR = ((2 * ((*dst).R)) * (((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*dst).R))) * (255 - ((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) < 128) { { fB = ((2 * ((*lhs).B)) * (((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*lhs).B))) * (255 - ((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*lhs).G) < 128) { { fG = ((2 * ((*lhs).G)) * (((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*lhs).G))) * (255 - ((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*lhs).R) < 128) { { fR = ((2 * ((*lhs).R)) * (((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*lhs).R))) * (255 - ((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) < 128) { { fB = ((2 * ((*lhs).B)) * (((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*lhs).B))) * (255 - ((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*lhs).G) < 128) { { fG = ((2 * ((*lhs).G)) * (((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*lhs).G))) * (255 - ((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*lhs).R) < 128) { { fR = ((2 * ((*lhs).R)) * (((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*lhs).R))) * (255 - ((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) < 128) { { fB = ((2 * ((*lhs).B)) * (((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*lhs).B))) * (255 - ((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*lhs).G) < 128) { { fG = ((2 * ((*lhs).G)) * (((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*lhs).G))) * (255 - ((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*lhs).R) < 128) { { fR = ((2 * ((*lhs).R)) * (((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*lhs).R))) * (255 - ((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) < 128) { { fB = ((2 * ((*lhs).B)) * (((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*lhs).B))) * (255 - ((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*lhs).G) < 128) { { fG = ((2 * ((*lhs).G)) * (((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*lhs).G))) * (255 - ((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*lhs).R) < 128) { { fR = ((2 * ((*lhs).R)) * (((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*lhs).R))) * (255 - ((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) < 128) { { fB = ((2 * ((*lhs).B)) * (((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*lhs).B))) * (255 - ((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*lhs).G) < 128) { { fG = ((2 * ((*lhs).G)) * (((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*lhs).G))) * (255 - ((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*lhs).R) < 128) { { fR = ((2 * ((*lhs).R)) * (((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*lhs).R))) * (255 - ((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) < 128) { { fB = ((2 * ((*lhs).B)) * (((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*lhs).B))) * (255 - ((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*lhs).G) < 128) { { fG = ((2 * ((*lhs).G)) * (((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*lhs).G))) * (255 - ((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*lhs).R) < 128) { { fR = ((2 * ((*lhs).R)) * (((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*lhs).R))) * (255 - ((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) < 128) { { fB = ((2 * ((*lhs).B)) * (((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*lhs).B))) * (255 - ((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*lhs).G) < 128) { { fG = ((2 * ((*lhs).G)) * (((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*lhs).G))) * (255 - ((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*lhs).R) < 128) { { fR = ((2 * ((*lhs).R)) * (((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*lhs).R))) * (255 - ((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) < 128) { { fB = ((2 * ((*lhs).B)) * (((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*lhs).B))) * (255 - ((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*lhs).G) < 128) { { fG = ((2 * ((*lhs).G)) * (((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*lhs).G))) * (255 - ((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*lhs).R) < 128) { { fR = ((2 * ((*lhs).R)) * (((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*lhs).R))) * (255 - ((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) < 128) { { fB = ((2 * ((*lhs).B)) * (((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*lhs).B))) * (255 - ((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*lhs).G) < 128) { { fG = ((2 * ((*lhs).G)) * (((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*lhs).G))) * (255 - ((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*lhs).R) < 128) { { fR = ((2 * ((*lhs).R)) * (((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*lhs).R))) * (255 - ((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) < 128) { { fB = ((2 * ((*lhs).B)) * (((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*lhs).B))) * (255 - ((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*lhs).G) < 128) { { fG = ((2 * ((*lhs).G)) * (((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*lhs).G))) * (255 - ((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*lhs).R) < 128) { { fR = ((2 * ((*lhs).R)) * (((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*lhs).R))) * (255 - ((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) < 128) { { fB = ((2 * ((*lhs).B)) * (((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*lhs).B))) * (255 - ((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*lhs).G) < 128) { { fG = ((2 * ((*lhs).G)) * (((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*lhs).G))) * (255 - ((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*lhs).R) < 128) { { fR = ((2 * ((*lhs).R)) * (((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*lhs).R))) * (255 - ((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) < 128) { { fB = ((2 * ((*lhs).B)) * (((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*lhs).B))) * (255 - ((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*lhs).G) < 128) { { fG = ((2 * ((*lhs).G)) * (((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*lhs).G))) * (255 - ((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*lhs).R) < 128) { { fR = ((2 * ((*lhs).R)) * (((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*lhs).R))) * (255 - ((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) < 128) { { fB = ((2 * ((*lhs).B)) * (((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*lhs).B))) * (255 - ((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*lhs).G) < 128) { { fG = ((2 * ((*lhs).G)) * (((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*lhs).G))) * (255 - ((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*lhs).R) < 128) { { fR = ((2 * ((*lhs).R)) * (((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*lhs).R))) * (255 - ((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) < 128) { { fB = ((2 * ((*lhs).B)) * (((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*lhs).B))) * (255 - ((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*lhs).G) < 128) { { fG = ((2 * ((*lhs).G)) * (((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*lhs).G))) * (255 - ((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*lhs).R) < 128) { { fR = ((2 * ((*lhs).R)) * (((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*lhs).R))) * (255 - ((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) < 128) { { fB = ((2 * ((*lhs).B)) * (((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*lhs).B))) * (255 - ((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*lhs).G) < 128) { { fG = ((2 * ((*lhs).G)) * (((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*lhs).G))) * (255 - ((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*lhs).R) < 128) { { fR = ((2 * ((*lhs).R)) * (((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*lhs).R))) * (255 - ((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) < 128) { { fB = ((2 * ((*lhs).B)) * (((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*lhs).B))) * (255 - ((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*lhs).G) < 128) { { fG = ((2 * ((*lhs).G)) * (((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*lhs).G))) * (255 - ((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*lhs).R) < 128) { { fR = ((2 * ((*lhs).R)) * (((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*lhs).R))) * (255 - ((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) < 128) { { fB = ((2 * ((*lhs).B)) * (((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*lhs).B))) * (255 - ((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*lhs).G) < 128) { { fG = ((2 * ((*lhs).G)) * (((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*lhs).G))) * (255 - ((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*lhs).R) < 128) { { fR = ((2 * ((*lhs).R)) * (((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*lhs).R))) * (255 - ((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) < 128) { { fB = ((2 * ((*lhs).B)) * (((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*lhs).B))) * (255 - ((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*lhs).G) < 128) { { fG = ((2 * ((*lhs).G)) * (((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*lhs).G))) * (255 - ((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*lhs).R) < 128) { { fR = ((2 * ((*lhs).R)) * (((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*lhs).R))) * (255 - ((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) < 128) { { fB = ((2 * ((*lhs).B)) * (((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*lhs).B))) * (255 - ((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*lhs).G) < 128) { { fG = ((2 * ((*lhs).G)) * (((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*lhs).G))) * (255 - ((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*lhs).R) < 128) { { fR = ((2 * ((*lhs).R)) * (((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*lhs).R))) * (255 - ((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) < 128) { { fB = ((2 * ((*lhs).B)) * (((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*lhs).B))) * (255 - ((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*lhs).G) < 128) { { fG = ((2 * ((*lhs).G)) * (((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*lhs).G))) * (255 - ((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*lhs).R) < 128) { { fR = ((2 * ((*lhs).R)) * (((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*lhs).R))) * (255 - ((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) < 128) { { fB = ((2 * ((*lhs).B)) * (((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*lhs).B))) * (255 - ((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*lhs).G) < 128) { { fG = ((2 * ((*lhs).G)) * (((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*lhs).G))) * (255 - ((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*lhs).R) < 128) { { fR = ((2 * ((*lhs).R)) * (((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*lhs).R))) * (255 - ((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) < 128) { { fB = ((2 * ((*lhs).B)) * (((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*lhs).B))) * (255 - ((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*lhs).G) < 128) { { fG = ((2 * ((*lhs).G)) * (((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*lhs).G))) * (255 - ((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*lhs).R) < 128) { { fR = ((2 * ((*lhs).R)) * (((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*lhs).R))) * (255 - ((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) < 128) { { fB = ((2 * ((*lhs).B)) * (((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*lhs).B))) * (255 - ((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*lhs).G) < 128) { { fG = ((2 * ((*lhs).G)) * (((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*lhs).G))) * (255 - ((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*lhs).R) < 128) { { fR = ((2 * ((*lhs).R)) * (((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*lhs).R))) * (255 - ((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) < 128) { { fB = ((2 * ((*lhs).B)) * (((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*lhs).B))) * (255 - ((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*lhs).G) < 128) { { fG = ((2 * ((*lhs).G)) * (((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*lhs).G))) * (255 - ((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*lhs).R) < 128) { { fR = ((2 * ((*lhs).R)) * (((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*lhs).R))) * (255 - ((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) < 128) { { fB = ((2 * ((*lhs).B)) * (((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*lhs).B))) * (255 - ((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*lhs).G) < 128) { { fG = ((2 * ((*lhs).G)) * (((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*lhs).G))) * (255 - ((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*lhs).R) < 128) { { fR = ((2 * ((*lhs).R)) * (((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*lhs).R))) * (255 - ((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) < 128) { { fB = ((2 * ((*lhs).B)) * (((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*lhs).B))) * (255 - ((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*lhs).G) < 128) { { fG = ((2 * ((*lhs).G)) * (((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*lhs).G))) * (255 - ((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*lhs).R) < 128) { { fR = ((2 * ((*lhs).R)) * (((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*lhs).R))) * (255 - ((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) < 128) { { fB = ((2 * ((*lhs).B)) * (((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*lhs).B))) * (255 - ((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*lhs).G) < 128) { { fG = ((2 * ((*lhs).G)) * (((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*lhs).G))) * (255 - ((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*lhs).R) < 128) { { fR = ((2 * ((*lhs).R)) * (((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*lhs).R))) * (255 - ((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) < 128) { { fB = ((2 * ((*lhs).B)) * (((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*lhs).B))) * (255 - ((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*lhs).G) < 128) { { fG = ((2 * ((*lhs).G)) * (((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*lhs).G))) * (255 - ((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*lhs).R) < 128) { { fR = ((2 * ((*lhs).R)) * (((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*lhs).R))) * (255 - ((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) < 128) { { fB = ((2 * ((*lhs).B)) * (((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*lhs).B))) * (255 - ((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*lhs).G) < 128) { { fG = ((2 * ((*lhs).G)) * (((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*lhs).G))) * (255 - ((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*lhs).R) < 128) { { fR = ((2 * ((*lhs).R)) * (((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*lhs).R))) * (255 - ((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) < 128) { { fB = ((2 * ((*lhs).B)) * (((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*lhs).B))) * (255 - ((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*lhs).G) < 128) { { fG = ((2 * ((*lhs).G)) * (((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*lhs).G))) * (255 - ((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*lhs).R) < 128) { { fR = ((2 * ((*lhs).R)) * (((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*lhs).R))) * (255 - ((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) < 128) { { fB = ((2 * ((*lhs).B)) * (((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*lhs).B))) * (255 - ((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*lhs).G) < 128) { { fG = ((2 * ((*lhs).G)) * (((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*lhs).G))) * (255 - ((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*lhs).R) < 128) { { fR = ((2 * ((*lhs).R)) * (((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*lhs).R))) * (255 - ((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) < 128) { { fB = ((2 * ((*lhs).B)) * (((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*lhs).B))) * (255 - ((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*lhs).G) < 128) { { fG = ((2 * ((*lhs).G)) * (((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*lhs).G))) * (255 - ((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*lhs).R) < 128) { { fR = ((2 * ((*lhs).R)) * (((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*lhs).R))) * (255 - ((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) < 128) { { fB = ((2 * ((*lhs).B)) * (((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*lhs).B))) * (255 - ((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*lhs).G) < 128) { { fG = ((2 * ((*lhs).G)) * (((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*lhs).G))) * (255 - ((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*lhs).R) < 128) { { fR = ((2 * ((*lhs).R)) * (((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*lhs).R))) * (255 - ((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) < 128) { { fB = ((2 * ((*lhs).B)) * (((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*lhs).B))) * (255 - ((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*lhs).G) < 128) { { fG = ((2 * ((*lhs).G)) * (((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*lhs).G))) * (255 - ((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*lhs).R) < 128) { { fR = ((2 * ((*lhs).R)) * (((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*lhs).R))) * (255 - ((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) < 128) { { fB = ((2 * ((*lhs).B)) * (((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*lhs).B))) * (255 - ((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*lhs).G) < 128) { { fG = ((2 * ((*lhs).G)) * (((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*lhs).G))) * (255 - ((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*lhs).R) < 128) { { fR = ((2 * ((*lhs).R)) * (((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*lhs).R))) * (255 - ((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) < 128) { { fB = ((2 * ((*lhs).B)) * (((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*lhs).B))) * (255 - ((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*lhs).G) < 128) { { fG = ((2 * ((*lhs).G)) * (((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*lhs).G))) * (255 - ((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*lhs).R) < 128) { { fR = ((2 * ((*lhs).R)) * (((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*lhs).R))) * (255 - ((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) < 128) { { fB = ((2 * ((*lhs).B)) * (((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*lhs).B))) * (255 - ((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*lhs).G) < 128) { { fG = ((2 * ((*lhs).G)) * (((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*lhs).G))) * (255 - ((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*lhs).R) < 128) { { fR = ((2 * ((*lhs).R)) * (((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*lhs).R))) * (255 - ((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) < 128) { { fB = ((2 * ((*lhs).B)) * (((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*lhs).B))) * (255 - ((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*lhs).G) < 128) { { fG = ((2 * ((*lhs).G)) * (((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*lhs).G))) * (255 - ((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*lhs).R) < 128) { { fR = ((2 * ((*lhs).R)) * (((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*lhs).R))) * (255 - ((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) < 128) { { fB = ((2 * ((*lhs).B)) * (((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*lhs).B))) * (255 - ((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*lhs).G) < 128) { { fG = ((2 * ((*lhs).G)) * (((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*lhs).G))) * (255 - ((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*lhs).R) < 128) { { fR = ((2 * ((*lhs).R)) * (((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*lhs).R))) * (255 - ((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) < 128) { { fB = ((2 * ((*lhs).B)) * (((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*lhs).B))) * (255 - ((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*lhs).G) < 128) { { fG = ((2 * ((*lhs).G)) * (((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*lhs).G))) * (255 - ((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*lhs).R) < 128) { { fR = ((2 * ((*lhs).R)) * (((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*lhs).R))) * (255 - ((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) < 128) { { fB = ((2 * ((*lhs).B)) * (((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*lhs).B))) * (255 - ((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*lhs).G) < 128) { { fG = ((2 * ((*lhs).G)) * (((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*lhs).G))) * (255 - ((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*lhs).R) < 128) { { fR = ((2 * ((*lhs).R)) * (((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*lhs).R))) * (255 - ((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) < 128) { { fB = ((2 * ((*lhs).B)) * (((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*lhs).B))) * (255 - ((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*lhs).G) < 128) { { fG = ((2 * ((*lhs).G)) * (((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*lhs).G))) * (255 - ((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*lhs).R) < 128) { { fR = ((2 * ((*lhs).R)) * (((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*lhs).R))) * (255 - ((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) < 128) { { fB = ((2 * ((*lhs).B)) * (((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*lhs).B))) * (255 - ((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*lhs).G) < 128) { { fG = ((2 * ((*lhs).G)) * (((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*lhs).G))) * (255 - ((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*lhs).R) < 128) { { fR = ((2 * ((*lhs).R)) * (((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*lhs).R))) * (255 - ((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,ApplyStatic,The following statement contains a magic number: { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,ApplyStatic,The following statement contains a magic number: { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,ApplyStatic,The following statement contains a magic number: { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) < 128) { { fB = ((2 * ((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((lhs).B))) * (255 - ((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((lhs).G) < 128) { { fG = ((2 * ((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((lhs).G))) * (255 - ((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((lhs).R) < 128) { { fR = ((2 * ((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((lhs).R))) * (255 - ((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) < 128) { { fB = ((2 * ((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((lhs).B))) * (255 - ((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((lhs).G) < 128) { { fG = ((2 * ((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((lhs).G))) * (255 - ((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((lhs).R) < 128) { { fR = ((2 * ((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((lhs).R))) * (255 - ((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) < 128) { { fB = ((2 * ((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((lhs).B))) * (255 - ((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((lhs).G) < 128) { { fG = ((2 * ((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((lhs).G))) * (255 - ((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((lhs).R) < 128) { { fR = ((2 * ((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((lhs).R))) * (255 - ((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) < 128) { { fB = ((2 * ((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((lhs).B))) * (255 - ((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((lhs).G) < 128) { { fG = ((2 * ((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((lhs).G))) * (255 - ((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((lhs).R) < 128) { { fR = ((2 * ((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((lhs).R))) * (255 - ((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) < 128) { { fB = ((2 * ((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((lhs).B))) * (255 - ((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((lhs).G) < 128) { { fG = ((2 * ((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((lhs).G))) * (255 - ((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((lhs).R) < 128) { { fR = ((2 * ((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((lhs).R))) * (255 - ((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) < 128) { { fB = ((2 * ((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((lhs).B))) * (255 - ((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((lhs).G) < 128) { { fG = ((2 * ((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((lhs).G))) * (255 - ((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((lhs).R) < 128) { { fR = ((2 * ((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((lhs).R))) * (255 - ((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) < 128) { { fB = ((2 * ((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((lhs).B))) * (255 - ((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((lhs).G) < 128) { { fG = ((2 * ((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((lhs).G))) * (255 - ((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((lhs).R) < 128) { { fR = ((2 * ((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((lhs).R))) * (255 - ((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) < 128) { { fB = ((2 * ((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((lhs).B))) * (255 - ((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((lhs).G) < 128) { { fG = ((2 * ((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((lhs).G))) * (255 - ((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((lhs).R) < 128) { { fR = ((2 * ((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((lhs).R))) * (255 - ((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) < 128) { { fB = ((2 * ((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((lhs).B))) * (255 - ((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((lhs).G) < 128) { { fG = ((2 * ((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((lhs).G))) * (255 - ((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((lhs).R) < 128) { { fR = ((2 * ((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((lhs).R))) * (255 - ((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) < 128) { { fB = ((2 * ((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((lhs).B))) * (255 - ((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((lhs).G) < 128) { { fG = ((2 * ((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((lhs).G))) * (255 - ((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((lhs).R) < 128) { { fR = ((2 * ((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((lhs).R))) * (255 - ((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) < 128) { { fB = ((2 * ((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((lhs).B))) * (255 - ((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((lhs).G) < 128) { { fG = ((2 * ((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((lhs).G))) * (255 - ((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((lhs).R) < 128) { { fR = ((2 * ((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((lhs).R))) * (255 - ((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) < 128) { { fB = ((2 * ((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((lhs).B))) * (255 - ((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((lhs).G) < 128) { { fG = ((2 * ((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((lhs).G))) * (255 - ((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((lhs).R) < 128) { { fR = ((2 * ((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((lhs).R))) * (255 - ((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) < 128) { { fB = ((2 * ((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((lhs).B))) * (255 - ((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((lhs).G) < 128) { { fG = ((2 * ((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((lhs).G))) * (255 - ((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((lhs).R) < 128) { { fR = ((2 * ((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((lhs).R))) * (255 - ((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) < 128) { { fB = ((2 * ((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((lhs).B))) * (255 - ((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((lhs).G) < 128) { { fG = ((2 * ((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((lhs).G))) * (255 - ((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((lhs).R) < 128) { { fR = ((2 * ((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((lhs).R))) * (255 - ((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) < 128) { { fB = ((2 * ((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((lhs).B))) * (255 - ((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((lhs).G) < 128) { { fG = ((2 * ((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((lhs).G))) * (255 - ((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((lhs).R) < 128) { { fR = ((2 * ((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((lhs).R))) * (255 - ((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) < 128) { { fB = ((2 * ((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((lhs).B))) * (255 - ((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((lhs).G) < 128) { { fG = ((2 * ((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((lhs).G))) * (255 - ((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((lhs).R) < 128) { { fR = ((2 * ((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((lhs).R))) * (255 - ((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) < 128) { { fB = ((2 * ((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((lhs).B))) * (255 - ((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((lhs).G) < 128) { { fG = ((2 * ((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((lhs).G))) * (255 - ((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((lhs).R) < 128) { { fR = ((2 * ((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((lhs).R))) * (255 - ((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) < 128) { { fB = ((2 * ((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((lhs).B))) * (255 - ((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((lhs).G) < 128) { { fG = ((2 * ((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((lhs).G))) * (255 - ((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((lhs).R) < 128) { { fR = ((2 * ((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((lhs).R))) * (255 - ((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) < 128) { { fB = ((2 * ((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((lhs).B))) * (255 - ((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((lhs).G) < 128) { { fG = ((2 * ((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((lhs).G))) * (255 - ((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((lhs).R) < 128) { { fR = ((2 * ((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((lhs).R))) * (255 - ((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) < 128) { { fB = ((2 * ((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((lhs).B))) * (255 - ((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((lhs).G) < 128) { { fG = ((2 * ((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((lhs).G))) * (255 - ((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((lhs).R) < 128) { { fR = ((2 * ((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((lhs).R))) * (255 - ((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) < 128) { { fB = ((2 * ((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((lhs).B))) * (255 - ((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((lhs).G) < 128) { { fG = ((2 * ((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((lhs).G))) * (255 - ((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((lhs).R) < 128) { { fR = ((2 * ((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((lhs).R))) * (255 - ((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) < 128) { { fB = ((2 * ((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((lhs).B))) * (255 - ((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((lhs).G) < 128) { { fG = ((2 * ((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((lhs).G))) * (255 - ((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((lhs).R) < 128) { { fR = ((2 * ((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((lhs).R))) * (255 - ((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) < 128) { { fB = ((2 * ((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((lhs).B))) * (255 - ((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((lhs).G) < 128) { { fG = ((2 * ((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((lhs).G))) * (255 - ((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((lhs).R) < 128) { { fR = ((2 * ((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((lhs).R))) * (255 - ((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) < 128) { { fB = ((2 * ((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((lhs).B))) * (255 - ((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((lhs).G) < 128) { { fG = ((2 * ((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((lhs).G))) * (255 - ((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((lhs).R) < 128) { { fR = ((2 * ((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((lhs).R))) * (255 - ((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) < 128) { { fB = ((2 * ((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((lhs).B))) * (255 - ((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((lhs).G) < 128) { { fG = ((2 * ((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((lhs).G))) * (255 - ((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((lhs).R) < 128) { { fR = ((2 * ((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((lhs).R))) * (255 - ((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) < 128) { { fB = ((2 * ((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((lhs).B))) * (255 - ((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((lhs).G) < 128) { { fG = ((2 * ((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((lhs).G))) * (255 - ((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((lhs).R) < 128) { { fR = ((2 * ((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((lhs).R))) * (255 - ((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) < 128) { { fB = ((2 * ((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((lhs).B))) * (255 - ((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((lhs).G) < 128) { { fG = ((2 * ((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((lhs).G))) * (255 - ((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((lhs).R) < 128) { { fR = ((2 * ((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((lhs).R))) * (255 - ((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) < 128) { { fB = ((2 * ((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((lhs).B))) * (255 - ((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((lhs).G) < 128) { { fG = ((2 * ((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((lhs).G))) * (255 - ((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((lhs).R) < 128) { { fR = ((2 * ((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((lhs).R))) * (255 - ((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) < 128) { { fB = ((2 * ((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((lhs).B))) * (255 - ((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((lhs).G) < 128) { { fG = ((2 * ((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((lhs).G))) * (255 - ((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((lhs).R) < 128) { { fR = ((2 * ((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((lhs).R))) * (255 - ((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) < 128) { { fB = ((2 * ((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((lhs).B))) * (255 - ((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((lhs).G) < 128) { { fG = ((2 * ((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((lhs).G))) * (255 - ((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((lhs).R) < 128) { { fR = ((2 * ((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((lhs).R))) * (255 - ((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) < 128) { { fB = ((2 * ((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((lhs).B))) * (255 - ((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((lhs).G) < 128) { { fG = ((2 * ((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((lhs).G))) * (255 - ((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((lhs).R) < 128) { { fR = ((2 * ((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((lhs).R))) * (255 - ((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) < 128) { { fB = ((2 * ((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((lhs).B))) * (255 - ((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((lhs).G) < 128) { { fG = ((2 * ((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((lhs).G))) * (255 - ((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((lhs).R) < 128) { { fR = ((2 * ((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((lhs).R))) * (255 - ((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) < 128) { { fB = ((2 * ((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((lhs).B))) * (255 - ((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((lhs).G) < 128) { { fG = ((2 * ((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((lhs).G))) * (255 - ((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((lhs).R) < 128) { { fR = ((2 * ((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((lhs).R))) * (255 - ((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) < 128) { { fB = ((2 * ((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((lhs).B))) * (255 - ((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((lhs).G) < 128) { { fG = ((2 * ((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((lhs).G))) * (255 - ((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((lhs).R) < 128) { { fR = ((2 * ((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((lhs).R))) * (255 - ((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) < 128) { { fB = ((2 * ((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((lhs).B))) * (255 - ((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((lhs).G) < 128) { { fG = ((2 * ((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((lhs).G))) * (255 - ((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((lhs).R) < 128) { { fR = ((2 * ((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((lhs).R))) * (255 - ((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) < 128) { { fB = ((2 * ((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((lhs).B))) * (255 - ((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((lhs).G) < 128) { { fG = ((2 * ((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((lhs).G))) * (255 - ((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((lhs).R) < 128) { { fR = ((2 * ((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((lhs).R))) * (255 - ((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) < 128) { { fB = ((2 * ((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((lhs).B))) * (255 - ((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((lhs).G) < 128) { { fG = ((2 * ((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((lhs).G))) * (255 - ((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((lhs).R) < 128) { { fR = ((2 * ((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((lhs).R))) * (255 - ((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) < 128) { { fB = ((2 * ((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((lhs).B))) * (255 - ((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((lhs).G) < 128) { { fG = ((2 * ((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((lhs).G))) * (255 - ((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((lhs).R) < 128) { { fR = ((2 * ((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((lhs).R))) * (255 - ((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) < 128) { { fB = ((2 * ((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((lhs).B))) * (255 - ((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((lhs).G) < 128) { { fG = ((2 * ((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((lhs).G))) * (255 - ((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((lhs).R) < 128) { { fR = ((2 * ((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((lhs).R))) * (255 - ((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) < 128) { { fB = ((2 * ((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((lhs).B))) * (255 - ((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((lhs).G) < 128) { { fG = ((2 * ((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((lhs).G))) * (255 - ((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((lhs).R) < 128) { { fR = ((2 * ((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((lhs).R))) * (255 - ((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,ApplyOpacity,The following statement contains a magic number: { r = ((r) * (this.opacity) + 0x80); r = ((((r) >> 8) + (r)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,ApplyOpacity,The following statement contains a magic number: { r = ((r) * (this.opacity) + 0x80); r = ((((r) >> 8) + (r)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) < 128) { { fB = ((2 * ((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((lhs).B))) * (255 - ((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((lhs).G) < 128) { { fG = ((2 * ((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((lhs).G))) * (255 - ((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((lhs).R) < 128) { { fR = ((2 * ((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((lhs).R))) * (255 - ((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) < 128) { { fB = ((2 * ((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((lhs).B))) * (255 - ((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((lhs).G) < 128) { { fG = ((2 * ((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((lhs).G))) * (255 - ((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((lhs).R) < 128) { { fR = ((2 * ((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((lhs).R))) * (255 - ((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) < 128) { { fB = ((2 * ((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((lhs).B))) * (255 - ((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((lhs).G) < 128) { { fG = ((2 * ((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((lhs).G))) * (255 - ((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((lhs).R) < 128) { { fR = ((2 * ((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((lhs).R))) * (255 - ((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) < 128) { { fB = ((2 * ((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((lhs).B))) * (255 - ((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((lhs).G) < 128) { { fG = ((2 * ((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((lhs).G))) * (255 - ((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((lhs).R) < 128) { { fR = ((2 * ((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((lhs).R))) * (255 - ((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) < 128) { { fB = ((2 * ((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((lhs).B))) * (255 - ((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((lhs).G) < 128) { { fG = ((2 * ((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((lhs).G))) * (255 - ((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((lhs).R) < 128) { { fR = ((2 * ((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((lhs).R))) * (255 - ((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) < 128) { { fB = ((2 * ((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((lhs).B))) * (255 - ((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((lhs).G) < 128) { { fG = ((2 * ((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((lhs).G))) * (255 - ((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((lhs).R) < 128) { { fR = ((2 * ((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((lhs).R))) * (255 - ((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) < 128) { { fB = ((2 * ((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((lhs).B))) * (255 - ((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((lhs).G) < 128) { { fG = ((2 * ((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((lhs).G))) * (255 - ((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((lhs).R) < 128) { { fR = ((2 * ((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((lhs).R))) * (255 - ((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) < 128) { { fB = ((2 * ((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((lhs).B))) * (255 - ((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((lhs).G) < 128) { { fG = ((2 * ((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((lhs).G))) * (255 - ((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((lhs).R) < 128) { { fR = ((2 * ((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((lhs).R))) * (255 - ((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) < 128) { { fB = ((2 * ((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((lhs).B))) * (255 - ((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((lhs).G) < 128) { { fG = ((2 * ((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((lhs).G))) * (255 - ((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((lhs).R) < 128) { { fR = ((2 * ((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((lhs).R))) * (255 - ((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) < 128) { { fB = ((2 * ((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((lhs).B))) * (255 - ((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((lhs).G) < 128) { { fG = ((2 * ((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((lhs).G))) * (255 - ((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((lhs).R) < 128) { { fR = ((2 * ((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((lhs).R))) * (255 - ((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) < 128) { { fB = ((2 * ((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((lhs).B))) * (255 - ((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((lhs).G) < 128) { { fG = ((2 * ((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((lhs).G))) * (255 - ((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((lhs).R) < 128) { { fR = ((2 * ((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((lhs).R))) * (255 - ((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) < 128) { { fB = ((2 * ((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((lhs).B))) * (255 - ((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((lhs).G) < 128) { { fG = ((2 * ((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((lhs).G))) * (255 - ((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((lhs).R) < 128) { { fR = ((2 * ((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((lhs).R))) * (255 - ((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) < 128) { { fB = ((2 * ((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((lhs).B))) * (255 - ((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((lhs).G) < 128) { { fG = ((2 * ((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((lhs).G))) * (255 - ((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((lhs).R) < 128) { { fR = ((2 * ((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((lhs).R))) * (255 - ((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) < 128) { { fB = ((2 * ((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((lhs).B))) * (255 - ((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((lhs).G) < 128) { { fG = ((2 * ((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((lhs).G))) * (255 - ((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((lhs).R) < 128) { { fR = ((2 * ((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((lhs).R))) * (255 - ((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) < 128) { { fB = ((2 * ((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((lhs).B))) * (255 - ((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((lhs).G) < 128) { { fG = ((2 * ((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((lhs).G))) * (255 - ((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((lhs).R) < 128) { { fR = ((2 * ((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((lhs).R))) * (255 - ((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) < 128) { { fB = ((2 * ((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((lhs).B))) * (255 - ((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((lhs).G) < 128) { { fG = ((2 * ((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((lhs).G))) * (255 - ((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((lhs).R) < 128) { { fR = ((2 * ((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((lhs).R))) * (255 - ((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) < 128) { { fB = ((2 * ((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((lhs).B))) * (255 - ((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((lhs).G) < 128) { { fG = ((2 * ((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((lhs).G))) * (255 - ((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((lhs).R) < 128) { { fR = ((2 * ((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((lhs).R))) * (255 - ((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) < 128) { { fB = ((2 * ((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((lhs).B))) * (255 - ((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((lhs).G) < 128) { { fG = ((2 * ((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((lhs).G))) * (255 - ((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((lhs).R) < 128) { { fR = ((2 * ((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((lhs).R))) * (255 - ((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) < 128) { { fB = ((2 * ((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((lhs).B))) * (255 - ((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((lhs).G) < 128) { { fG = ((2 * ((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((lhs).G))) * (255 - ((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((lhs).R) < 128) { { fR = ((2 * ((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((lhs).R))) * (255 - ((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) < 128) { { fB = ((2 * ((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((lhs).B))) * (255 - ((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((lhs).G) < 128) { { fG = ((2 * ((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((lhs).G))) * (255 - ((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((lhs).R) < 128) { { fR = ((2 * ((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((lhs).R))) * (255 - ((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) < 128) { { fB = ((2 * ((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((lhs).B))) * (255 - ((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((lhs).G) < 128) { { fG = ((2 * ((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((lhs).G))) * (255 - ((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((lhs).R) < 128) { { fR = ((2 * ((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((lhs).R))) * (255 - ((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) < 128) { { fB = ((2 * ((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((lhs).B))) * (255 - ((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((lhs).G) < 128) { { fG = ((2 * ((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((lhs).G))) * (255 - ((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((lhs).R) < 128) { { fR = ((2 * ((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((lhs).R))) * (255 - ((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) < 128) { { fB = ((2 * ((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((lhs).B))) * (255 - ((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((lhs).G) < 128) { { fG = ((2 * ((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((lhs).G))) * (255 - ((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((lhs).R) < 128) { { fR = ((2 * ((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((lhs).R))) * (255 - ((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) < 128) { { fB = ((2 * ((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((lhs).B))) * (255 - ((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((lhs).G) < 128) { { fG = ((2 * ((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((lhs).G))) * (255 - ((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((lhs).R) < 128) { { fR = ((2 * ((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((lhs).R))) * (255 - ((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) < 128) { { fB = ((2 * ((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((lhs).B))) * (255 - ((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((lhs).G) < 128) { { fG = ((2 * ((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((lhs).G))) * (255 - ((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((lhs).R) < 128) { { fR = ((2 * ((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((lhs).R))) * (255 - ((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) < 128) { { fB = ((2 * ((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((lhs).B))) * (255 - ((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((lhs).G) < 128) { { fG = ((2 * ((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((lhs).G))) * (255 - ((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((lhs).R) < 128) { { fR = ((2 * ((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((lhs).R))) * (255 - ((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) < 128) { { fB = ((2 * ((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((lhs).B))) * (255 - ((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((lhs).G) < 128) { { fG = ((2 * ((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((lhs).G))) * (255 - ((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((lhs).R) < 128) { { fR = ((2 * ((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((lhs).R))) * (255 - ((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) < 128) { { fB = ((2 * ((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((lhs).B))) * (255 - ((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((lhs).G) < 128) { { fG = ((2 * ((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((lhs).G))) * (255 - ((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((lhs).R) < 128) { { fR = ((2 * ((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((lhs).R))) * (255 - ((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) < 128) { { fB = ((2 * ((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((lhs).B))) * (255 - ((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((lhs).G) < 128) { { fG = ((2 * ((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((lhs).G))) * (255 - ((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((lhs).R) < 128) { { fR = ((2 * ((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((lhs).R))) * (255 - ((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) < 128) { { fB = ((2 * ((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((lhs).B))) * (255 - ((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((lhs).G) < 128) { { fG = ((2 * ((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((lhs).G))) * (255 - ((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((lhs).R) < 128) { { fR = ((2 * ((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((lhs).R))) * (255 - ((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) < 128) { { fB = ((2 * ((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((lhs).B))) * (255 - ((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((lhs).G) < 128) { { fG = ((2 * ((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((lhs).G))) * (255 - ((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((lhs).R) < 128) { { fR = ((2 * ((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((lhs).R))) * (255 - ((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) < 128) { { fB = ((2 * ((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((lhs).B))) * (255 - ((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((lhs).G) < 128) { { fG = ((2 * ((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((lhs).G))) * (255 - ((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((lhs).R) < 128) { { fR = ((2 * ((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((lhs).R))) * (255 - ((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) < 128) { { fB = ((2 * ((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((lhs).B))) * (255 - ((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((lhs).G) < 128) { { fG = ((2 * ((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((lhs).G))) * (255 - ((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((lhs).R) < 128) { { fR = ((2 * ((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((lhs).R))) * (255 - ((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) < 128) { { fB = ((2 * ((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((lhs).B))) * (255 - ((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((lhs).G) < 128) { { fG = ((2 * ((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((lhs).G))) * (255 - ((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((lhs).R) < 128) { { fR = ((2 * ((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((lhs).R))) * (255 - ((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) < 128) { { fB = ((2 * ((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((lhs).B))) * (255 - ((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((lhs).G) < 128) { { fG = ((2 * ((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((lhs).G))) * (255 - ((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((lhs).R) < 128) { { fR = ((2 * ((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((lhs).R))) * (255 - ((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) < 128) { { fB = ((2 * ((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((lhs).B))) * (255 - ((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((lhs).G) < 128) { { fG = ((2 * ((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((lhs).G))) * (255 - ((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((lhs).R) < 128) { { fR = ((2 * ((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((lhs).R))) * (255 - ((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) < 128) { { fB = ((2 * ((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((lhs).B))) * (255 - ((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((lhs).G) < 128) { { fG = ((2 * ((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((lhs).G))) * (255 - ((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((lhs).R) < 128) { { fR = ((2 * ((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((lhs).R))) * (255 - ((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) < 128) { { fB = ((2 * ((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((lhs).B))) * (255 - ((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((lhs).G) < 128) { { fG = ((2 * ((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((lhs).G))) * (255 - ((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((lhs).R) < 128) { { fR = ((2 * ((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((lhs).R))) * (255 - ((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) < 128) { { fB = ((2 * ((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((lhs).B))) * (255 - ((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((lhs).G) < 128) { { fG = ((2 * ((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((lhs).G))) * (255 - ((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((lhs).R) < 128) { { fR = ((2 * ((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((lhs).R))) * (255 - ((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) < 128) { { fB = ((2 * ((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((lhs).B))) * (255 - ((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((lhs).G) < 128) { { fG = ((2 * ((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((lhs).G))) * (255 - ((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((lhs).R) < 128) { { fR = ((2 * ((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((lhs).R))) * (255 - ((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) < 128) { { fB = ((2 * ((*dst).B)) * (((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*dst).B))) * (255 - ((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*dst).G) < 128) { { fG = ((2 * ((*dst).G)) * (((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*dst).G))) * (255 - ((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*dst).R) < 128) { { fR = ((2 * ((*dst).R)) * (((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*dst).R))) * (255 - ((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) < 128) { { fB = ((2 * ((*dst).B)) * (((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*dst).B))) * (255 - ((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*dst).G) < 128) { { fG = ((2 * ((*dst).G)) * (((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*dst).G))) * (255 - ((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*dst).R) < 128) { { fR = ((2 * ((*dst).R)) * (((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*dst).R))) * (255 - ((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) < 128) { { fB = ((2 * ((*dst).B)) * (((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*dst).B))) * (255 - ((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*dst).G) < 128) { { fG = ((2 * ((*dst).G)) * (((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*dst).G))) * (255 - ((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*dst).R) < 128) { { fR = ((2 * ((*dst).R)) * (((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*dst).R))) * (255 - ((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) < 128) { { fB = ((2 * ((*dst).B)) * (((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*dst).B))) * (255 - ((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*dst).G) < 128) { { fG = ((2 * ((*dst).G)) * (((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*dst).G))) * (255 - ((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*dst).R) < 128) { { fR = ((2 * ((*dst).R)) * (((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*dst).R))) * (255 - ((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) < 128) { { fB = ((2 * ((*dst).B)) * (((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*dst).B))) * (255 - ((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*dst).G) < 128) { { fG = ((2 * ((*dst).G)) * (((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*dst).G))) * (255 - ((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*dst).R) < 128) { { fR = ((2 * ((*dst).R)) * (((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*dst).R))) * (255 - ((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) < 128) { { fB = ((2 * ((*dst).B)) * (((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*dst).B))) * (255 - ((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*dst).G) < 128) { { fG = ((2 * ((*dst).G)) * (((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*dst).G))) * (255 - ((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*dst).R) < 128) { { fR = ((2 * ((*dst).R)) * (((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*dst).R))) * (255 - ((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) < 128) { { fB = ((2 * ((*dst).B)) * (((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*dst).B))) * (255 - ((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*dst).G) < 128) { { fG = ((2 * ((*dst).G)) * (((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*dst).G))) * (255 - ((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*dst).R) < 128) { { fR = ((2 * ((*dst).R)) * (((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*dst).R))) * (255 - ((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) < 128) { { fB = ((2 * ((*dst).B)) * (((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*dst).B))) * (255 - ((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*dst).G) < 128) { { fG = ((2 * ((*dst).G)) * (((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*dst).G))) * (255 - ((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*dst).R) < 128) { { fR = ((2 * ((*dst).R)) * (((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*dst).R))) * (255 - ((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) < 128) { { fB = ((2 * ((*dst).B)) * (((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*dst).B))) * (255 - ((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*dst).G) < 128) { { fG = ((2 * ((*dst).G)) * (((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*dst).G))) * (255 - ((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*dst).R) < 128) { { fR = ((2 * ((*dst).R)) * (((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*dst).R))) * (255 - ((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) < 128) { { fB = ((2 * ((*dst).B)) * (((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*dst).B))) * (255 - ((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*dst).G) < 128) { { fG = ((2 * ((*dst).G)) * (((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*dst).G))) * (255 - ((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*dst).R) < 128) { { fR = ((2 * ((*dst).R)) * (((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*dst).R))) * (255 - ((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) < 128) { { fB = ((2 * ((*dst).B)) * (((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*dst).B))) * (255 - ((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*dst).G) < 128) { { fG = ((2 * ((*dst).G)) * (((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*dst).G))) * (255 - ((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*dst).R) < 128) { { fR = ((2 * ((*dst).R)) * (((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*dst).R))) * (255 - ((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) < 128) { { fB = ((2 * ((*dst).B)) * (((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*dst).B))) * (255 - ((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*dst).G) < 128) { { fG = ((2 * ((*dst).G)) * (((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*dst).G))) * (255 - ((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*dst).R) < 128) { { fR = ((2 * ((*dst).R)) * (((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*dst).R))) * (255 - ((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) < 128) { { fB = ((2 * ((*dst).B)) * (((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*dst).B))) * (255 - ((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*dst).G) < 128) { { fG = ((2 * ((*dst).G)) * (((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*dst).G))) * (255 - ((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*dst).R) < 128) { { fR = ((2 * ((*dst).R)) * (((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*dst).R))) * (255 - ((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) < 128) { { fB = ((2 * ((*dst).B)) * (((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*dst).B))) * (255 - ((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*dst).G) < 128) { { fG = ((2 * ((*dst).G)) * (((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*dst).G))) * (255 - ((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*dst).R) < 128) { { fR = ((2 * ((*dst).R)) * (((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*dst).R))) * (255 - ((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) < 128) { { fB = ((2 * ((*dst).B)) * (((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*dst).B))) * (255 - ((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*dst).G) < 128) { { fG = ((2 * ((*dst).G)) * (((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*dst).G))) * (255 - ((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*dst).R) < 128) { { fR = ((2 * ((*dst).R)) * (((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*dst).R))) * (255 - ((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) < 128) { { fB = ((2 * ((*dst).B)) * (((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*dst).B))) * (255 - ((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*dst).G) < 128) { { fG = ((2 * ((*dst).G)) * (((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*dst).G))) * (255 - ((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*dst).R) < 128) { { fR = ((2 * ((*dst).R)) * (((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*dst).R))) * (255 - ((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) < 128) { { fB = ((2 * ((*dst).B)) * (((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*dst).B))) * (255 - ((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*dst).G) < 128) { { fG = ((2 * ((*dst).G)) * (((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*dst).G))) * (255 - ((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*dst).R) < 128) { { fR = ((2 * ((*dst).R)) * (((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*dst).R))) * (255 - ((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) < 128) { { fB = ((2 * ((*dst).B)) * (((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*dst).B))) * (255 - ((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*dst).G) < 128) { { fG = ((2 * ((*dst).G)) * (((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*dst).G))) * (255 - ((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*dst).R) < 128) { { fR = ((2 * ((*dst).R)) * (((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*dst).R))) * (255 - ((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) < 128) { { fB = ((2 * ((*dst).B)) * (((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*dst).B))) * (255 - ((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*dst).G) < 128) { { fG = ((2 * ((*dst).G)) * (((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*dst).G))) * (255 - ((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*dst).R) < 128) { { fR = ((2 * ((*dst).R)) * (((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*dst).R))) * (255 - ((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) < 128) { { fB = ((2 * ((*dst).B)) * (((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*dst).B))) * (255 - ((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*dst).G) < 128) { { fG = ((2 * ((*dst).G)) * (((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*dst).G))) * (255 - ((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*dst).R) < 128) { { fR = ((2 * ((*dst).R)) * (((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*dst).R))) * (255 - ((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) < 128) { { fB = ((2 * ((*dst).B)) * (((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*dst).B))) * (255 - ((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*dst).G) < 128) { { fG = ((2 * ((*dst).G)) * (((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*dst).G))) * (255 - ((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*dst).R) < 128) { { fR = ((2 * ((*dst).R)) * (((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*dst).R))) * (255 - ((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) < 128) { { fB = ((2 * ((*dst).B)) * (((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*dst).B))) * (255 - ((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*dst).G) < 128) { { fG = ((2 * ((*dst).G)) * (((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*dst).G))) * (255 - ((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*dst).R) < 128) { { fR = ((2 * ((*dst).R)) * (((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*dst).R))) * (255 - ((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) < 128) { { fB = ((2 * ((*dst).B)) * (((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*dst).B))) * (255 - ((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*dst).G) < 128) { { fG = ((2 * ((*dst).G)) * (((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*dst).G))) * (255 - ((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*dst).R) < 128) { { fR = ((2 * ((*dst).R)) * (((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*dst).R))) * (255 - ((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) < 128) { { fB = ((2 * ((*dst).B)) * (((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*dst).B))) * (255 - ((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*dst).G) < 128) { { fG = ((2 * ((*dst).G)) * (((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*dst).G))) * (255 - ((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*dst).R) < 128) { { fR = ((2 * ((*dst).R)) * (((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*dst).R))) * (255 - ((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) < 128) { { fB = ((2 * ((*dst).B)) * (((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*dst).B))) * (255 - ((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*dst).G) < 128) { { fG = ((2 * ((*dst).G)) * (((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*dst).G))) * (255 - ((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*dst).R) < 128) { { fR = ((2 * ((*dst).R)) * (((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*dst).R))) * (255 - ((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) < 128) { { fB = ((2 * ((*dst).B)) * (((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*dst).B))) * (255 - ((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*dst).G) < 128) { { fG = ((2 * ((*dst).G)) * (((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*dst).G))) * (255 - ((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*dst).R) < 128) { { fR = ((2 * ((*dst).R)) * (((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*dst).R))) * (255 - ((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) < 128) { { fB = ((2 * ((*dst).B)) * (((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*dst).B))) * (255 - ((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*dst).G) < 128) { { fG = ((2 * ((*dst).G)) * (((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*dst).G))) * (255 - ((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*dst).R) < 128) { { fR = ((2 * ((*dst).R)) * (((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*dst).R))) * (255 - ((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) < 128) { { fB = ((2 * ((*dst).B)) * (((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*dst).B))) * (255 - ((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*dst).G) < 128) { { fG = ((2 * ((*dst).G)) * (((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*dst).G))) * (255 - ((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*dst).R) < 128) { { fR = ((2 * ((*dst).R)) * (((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*dst).R))) * (255 - ((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) < 128) { { fB = ((2 * ((*dst).B)) * (((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*dst).B))) * (255 - ((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*dst).G) < 128) { { fG = ((2 * ((*dst).G)) * (((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*dst).G))) * (255 - ((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*dst).R) < 128) { { fR = ((2 * ((*dst).R)) * (((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*dst).R))) * (255 - ((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) < 128) { { fB = ((2 * ((*dst).B)) * (((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*dst).B))) * (255 - ((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*dst).G) < 128) { { fG = ((2 * ((*dst).G)) * (((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*dst).G))) * (255 - ((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*dst).R) < 128) { { fR = ((2 * ((*dst).R)) * (((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*dst).R))) * (255 - ((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) < 128) { { fB = ((2 * ((*dst).B)) * (((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*dst).B))) * (255 - ((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*dst).G) < 128) { { fG = ((2 * ((*dst).G)) * (((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*dst).G))) * (255 - ((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*dst).R) < 128) { { fR = ((2 * ((*dst).R)) * (((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*dst).R))) * (255 - ((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) < 128) { { fB = ((2 * ((*dst).B)) * (((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*dst).B))) * (255 - ((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*dst).G) < 128) { { fG = ((2 * ((*dst).G)) * (((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*dst).G))) * (255 - ((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*dst).R) < 128) { { fR = ((2 * ((*dst).R)) * (((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*dst).R))) * (255 - ((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) < 128) { { fB = ((2 * ((*dst).B)) * (((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*dst).B))) * (255 - ((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*dst).G) < 128) { { fG = ((2 * ((*dst).G)) * (((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*dst).G))) * (255 - ((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*dst).R) < 128) { { fR = ((2 * ((*dst).R)) * (((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*dst).R))) * (255 - ((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) < 128) { { fB = ((2 * ((*dst).B)) * (((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*dst).B))) * (255 - ((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*dst).G) < 128) { { fG = ((2 * ((*dst).G)) * (((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*dst).G))) * (255 - ((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*dst).R) < 128) { { fR = ((2 * ((*dst).R)) * (((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*dst).R))) * (255 - ((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) < 128) { { fB = ((2 * ((*dst).B)) * (((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*dst).B))) * (255 - ((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*dst).G) < 128) { { fG = ((2 * ((*dst).G)) * (((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*dst).G))) * (255 - ((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*dst).R) < 128) { { fR = ((2 * ((*dst).R)) * (((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*dst).R))) * (255 - ((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) < 128) { { fB = ((2 * ((*dst).B)) * (((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*dst).B))) * (255 - ((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*dst).G) < 128) { { fG = ((2 * ((*dst).G)) * (((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*dst).G))) * (255 - ((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*dst).R) < 128) { { fR = ((2 * ((*dst).R)) * (((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*dst).R))) * (255 - ((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) < 128) { { fB = ((2 * ((*dst).B)) * (((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*dst).B))) * (255 - ((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*dst).G) < 128) { { fG = ((2 * ((*dst).G)) * (((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*dst).G))) * (255 - ((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*dst).R) < 128) { { fR = ((2 * ((*dst).R)) * (((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*dst).R))) * (255 - ((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) < 128) { { fB = ((2 * ((*dst).B)) * (((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*dst).B))) * (255 - ((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*dst).G) < 128) { { fG = ((2 * ((*dst).G)) * (((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*dst).G))) * (255 - ((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*dst).R) < 128) { { fR = ((2 * ((*dst).R)) * (((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*dst).R))) * (255 - ((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) < 128) { { fB = ((2 * ((*dst).B)) * (((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*dst).B))) * (255 - ((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*dst).G) < 128) { { fG = ((2 * ((*dst).G)) * (((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*dst).G))) * (255 - ((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*dst).R) < 128) { { fR = ((2 * ((*dst).R)) * (((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*dst).R))) * (255 - ((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) < 128) { { fB = ((2 * ((*dst).B)) * (((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*dst).B))) * (255 - ((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*dst).G) < 128) { { fG = ((2 * ((*dst).G)) * (((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*dst).G))) * (255 - ((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*dst).R) < 128) { { fR = ((2 * ((*dst).R)) * (((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*dst).R))) * (255 - ((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) < 128) { { fB = ((2 * ((*dst).B)) * (((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*dst).B))) * (255 - ((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*dst).G) < 128) { { fG = ((2 * ((*dst).G)) * (((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*dst).G))) * (255 - ((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*dst).R) < 128) { { fR = ((2 * ((*dst).R)) * (((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*dst).R))) * (255 - ((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) < 128) { { fB = ((2 * ((*dst).B)) * (((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*dst).B))) * (255 - ((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*dst).G) < 128) { { fG = ((2 * ((*dst).G)) * (((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*dst).G))) * (255 - ((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*dst).R) < 128) { { fR = ((2 * ((*dst).R)) * (((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*dst).R))) * (255 - ((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) < 128) { { fB = ((2 * ((*dst).B)) * (((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*dst).B))) * (255 - ((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*dst).G) < 128) { { fG = ((2 * ((*dst).G)) * (((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*dst).G))) * (255 - ((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*dst).R) < 128) { { fR = ((2 * ((*dst).R)) * (((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*dst).R))) * (255 - ((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) < 128) { { fB = ((2 * ((*lhs).B)) * (((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*lhs).B))) * (255 - ((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*lhs).G) < 128) { { fG = ((2 * ((*lhs).G)) * (((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*lhs).G))) * (255 - ((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*lhs).R) < 128) { { fR = ((2 * ((*lhs).R)) * (((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*lhs).R))) * (255 - ((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) < 128) { { fB = ((2 * ((*lhs).B)) * (((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*lhs).B))) * (255 - ((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*lhs).G) < 128) { { fG = ((2 * ((*lhs).G)) * (((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*lhs).G))) * (255 - ((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*lhs).R) < 128) { { fR = ((2 * ((*lhs).R)) * (((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*lhs).R))) * (255 - ((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) < 128) { { fB = ((2 * ((*lhs).B)) * (((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*lhs).B))) * (255 - ((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*lhs).G) < 128) { { fG = ((2 * ((*lhs).G)) * (((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*lhs).G))) * (255 - ((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*lhs).R) < 128) { { fR = ((2 * ((*lhs).R)) * (((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*lhs).R))) * (255 - ((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) < 128) { { fB = ((2 * ((*lhs).B)) * (((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*lhs).B))) * (255 - ((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*lhs).G) < 128) { { fG = ((2 * ((*lhs).G)) * (((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*lhs).G))) * (255 - ((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*lhs).R) < 128) { { fR = ((2 * ((*lhs).R)) * (((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*lhs).R))) * (255 - ((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) < 128) { { fB = ((2 * ((*lhs).B)) * (((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*lhs).B))) * (255 - ((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*lhs).G) < 128) { { fG = ((2 * ((*lhs).G)) * (((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*lhs).G))) * (255 - ((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*lhs).R) < 128) { { fR = ((2 * ((*lhs).R)) * (((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*lhs).R))) * (255 - ((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) < 128) { { fB = ((2 * ((*lhs).B)) * (((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*lhs).B))) * (255 - ((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*lhs).G) < 128) { { fG = ((2 * ((*lhs).G)) * (((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*lhs).G))) * (255 - ((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*lhs).R) < 128) { { fR = ((2 * ((*lhs).R)) * (((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*lhs).R))) * (255 - ((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) < 128) { { fB = ((2 * ((*lhs).B)) * (((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*lhs).B))) * (255 - ((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*lhs).G) < 128) { { fG = ((2 * ((*lhs).G)) * (((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*lhs).G))) * (255 - ((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*lhs).R) < 128) { { fR = ((2 * ((*lhs).R)) * (((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*lhs).R))) * (255 - ((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) < 128) { { fB = ((2 * ((*lhs).B)) * (((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*lhs).B))) * (255 - ((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*lhs).G) < 128) { { fG = ((2 * ((*lhs).G)) * (((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*lhs).G))) * (255 - ((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*lhs).R) < 128) { { fR = ((2 * ((*lhs).R)) * (((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*lhs).R))) * (255 - ((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) < 128) { { fB = ((2 * ((*lhs).B)) * (((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*lhs).B))) * (255 - ((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*lhs).G) < 128) { { fG = ((2 * ((*lhs).G)) * (((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*lhs).G))) * (255 - ((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*lhs).R) < 128) { { fR = ((2 * ((*lhs).R)) * (((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*lhs).R))) * (255 - ((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) < 128) { { fB = ((2 * ((*lhs).B)) * (((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*lhs).B))) * (255 - ((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*lhs).G) < 128) { { fG = ((2 * ((*lhs).G)) * (((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*lhs).G))) * (255 - ((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*lhs).R) < 128) { { fR = ((2 * ((*lhs).R)) * (((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*lhs).R))) * (255 - ((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) < 128) { { fB = ((2 * ((*lhs).B)) * (((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*lhs).B))) * (255 - ((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*lhs).G) < 128) { { fG = ((2 * ((*lhs).G)) * (((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*lhs).G))) * (255 - ((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*lhs).R) < 128) { { fR = ((2 * ((*lhs).R)) * (((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*lhs).R))) * (255 - ((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) < 128) { { fB = ((2 * ((*lhs).B)) * (((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*lhs).B))) * (255 - ((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*lhs).G) < 128) { { fG = ((2 * ((*lhs).G)) * (((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*lhs).G))) * (255 - ((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*lhs).R) < 128) { { fR = ((2 * ((*lhs).R)) * (((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*lhs).R))) * (255 - ((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) < 128) { { fB = ((2 * ((*lhs).B)) * (((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*lhs).B))) * (255 - ((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*lhs).G) < 128) { { fG = ((2 * ((*lhs).G)) * (((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*lhs).G))) * (255 - ((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*lhs).R) < 128) { { fR = ((2 * ((*lhs).R)) * (((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*lhs).R))) * (255 - ((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) < 128) { { fB = ((2 * ((*lhs).B)) * (((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*lhs).B))) * (255 - ((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*lhs).G) < 128) { { fG = ((2 * ((*lhs).G)) * (((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*lhs).G))) * (255 - ((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*lhs).R) < 128) { { fR = ((2 * ((*lhs).R)) * (((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*lhs).R))) * (255 - ((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) < 128) { { fB = ((2 * ((*lhs).B)) * (((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*lhs).B))) * (255 - ((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*lhs).G) < 128) { { fG = ((2 * ((*lhs).G)) * (((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*lhs).G))) * (255 - ((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*lhs).R) < 128) { { fR = ((2 * ((*lhs).R)) * (((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*lhs).R))) * (255 - ((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) < 128) { { fB = ((2 * ((*lhs).B)) * (((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*lhs).B))) * (255 - ((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*lhs).G) < 128) { { fG = ((2 * ((*lhs).G)) * (((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*lhs).G))) * (255 - ((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*lhs).R) < 128) { { fR = ((2 * ((*lhs).R)) * (((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*lhs).R))) * (255 - ((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) < 128) { { fB = ((2 * ((*lhs).B)) * (((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*lhs).B))) * (255 - ((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*lhs).G) < 128) { { fG = ((2 * ((*lhs).G)) * (((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*lhs).G))) * (255 - ((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*lhs).R) < 128) { { fR = ((2 * ((*lhs).R)) * (((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*lhs).R))) * (255 - ((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) < 128) { { fB = ((2 * ((*lhs).B)) * (((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*lhs).B))) * (255 - ((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*lhs).G) < 128) { { fG = ((2 * ((*lhs).G)) * (((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*lhs).G))) * (255 - ((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*lhs).R) < 128) { { fR = ((2 * ((*lhs).R)) * (((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*lhs).R))) * (255 - ((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) < 128) { { fB = ((2 * ((*lhs).B)) * (((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*lhs).B))) * (255 - ((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*lhs).G) < 128) { { fG = ((2 * ((*lhs).G)) * (((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*lhs).G))) * (255 - ((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*lhs).R) < 128) { { fR = ((2 * ((*lhs).R)) * (((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*lhs).R))) * (255 - ((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) < 128) { { fB = ((2 * ((*lhs).B)) * (((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*lhs).B))) * (255 - ((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*lhs).G) < 128) { { fG = ((2 * ((*lhs).G)) * (((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*lhs).G))) * (255 - ((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*lhs).R) < 128) { { fR = ((2 * ((*lhs).R)) * (((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*lhs).R))) * (255 - ((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) < 128) { { fB = ((2 * ((*lhs).B)) * (((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*lhs).B))) * (255 - ((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*lhs).G) < 128) { { fG = ((2 * ((*lhs).G)) * (((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*lhs).G))) * (255 - ((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*lhs).R) < 128) { { fR = ((2 * ((*lhs).R)) * (((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*lhs).R))) * (255 - ((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) < 128) { { fB = ((2 * ((*lhs).B)) * (((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*lhs).B))) * (255 - ((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*lhs).G) < 128) { { fG = ((2 * ((*lhs).G)) * (((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*lhs).G))) * (255 - ((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*lhs).R) < 128) { { fR = ((2 * ((*lhs).R)) * (((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*lhs).R))) * (255 - ((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) < 128) { { fB = ((2 * ((*lhs).B)) * (((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*lhs).B))) * (255 - ((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*lhs).G) < 128) { { fG = ((2 * ((*lhs).G)) * (((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*lhs).G))) * (255 - ((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*lhs).R) < 128) { { fR = ((2 * ((*lhs).R)) * (((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*lhs).R))) * (255 - ((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) < 128) { { fB = ((2 * ((*lhs).B)) * (((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*lhs).B))) * (255 - ((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*lhs).G) < 128) { { fG = ((2 * ((*lhs).G)) * (((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*lhs).G))) * (255 - ((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*lhs).R) < 128) { { fR = ((2 * ((*lhs).R)) * (((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*lhs).R))) * (255 - ((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) < 128) { { fB = ((2 * ((*lhs).B)) * (((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*lhs).B))) * (255 - ((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*lhs).G) < 128) { { fG = ((2 * ((*lhs).G)) * (((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*lhs).G))) * (255 - ((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*lhs).R) < 128) { { fR = ((2 * ((*lhs).R)) * (((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*lhs).R))) * (255 - ((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) < 128) { { fB = ((2 * ((*lhs).B)) * (((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*lhs).B))) * (255 - ((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*lhs).G) < 128) { { fG = ((2 * ((*lhs).G)) * (((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*lhs).G))) * (255 - ((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*lhs).R) < 128) { { fR = ((2 * ((*lhs).R)) * (((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*lhs).R))) * (255 - ((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) < 128) { { fB = ((2 * ((*lhs).B)) * (((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*lhs).B))) * (255 - ((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*lhs).G) < 128) { { fG = ((2 * ((*lhs).G)) * (((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*lhs).G))) * (255 - ((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*lhs).R) < 128) { { fR = ((2 * ((*lhs).R)) * (((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*lhs).R))) * (255 - ((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) < 128) { { fB = ((2 * ((*lhs).B)) * (((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*lhs).B))) * (255 - ((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*lhs).G) < 128) { { fG = ((2 * ((*lhs).G)) * (((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*lhs).G))) * (255 - ((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*lhs).R) < 128) { { fR = ((2 * ((*lhs).R)) * (((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*lhs).R))) * (255 - ((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) < 128) { { fB = ((2 * ((*lhs).B)) * (((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*lhs).B))) * (255 - ((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*lhs).G) < 128) { { fG = ((2 * ((*lhs).G)) * (((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*lhs).G))) * (255 - ((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*lhs).R) < 128) { { fR = ((2 * ((*lhs).R)) * (((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*lhs).R))) * (255 - ((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) < 128) { { fB = ((2 * ((*lhs).B)) * (((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*lhs).B))) * (255 - ((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*lhs).G) < 128) { { fG = ((2 * ((*lhs).G)) * (((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*lhs).G))) * (255 - ((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*lhs).R) < 128) { { fR = ((2 * ((*lhs).R)) * (((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*lhs).R))) * (255 - ((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) < 128) { { fB = ((2 * ((*lhs).B)) * (((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*lhs).B))) * (255 - ((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*lhs).G) < 128) { { fG = ((2 * ((*lhs).G)) * (((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*lhs).G))) * (255 - ((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*lhs).R) < 128) { { fR = ((2 * ((*lhs).R)) * (((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*lhs).R))) * (255 - ((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) < 128) { { fB = ((2 * ((*lhs).B)) * (((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*lhs).B))) * (255 - ((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*lhs).G) < 128) { { fG = ((2 * ((*lhs).G)) * (((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*lhs).G))) * (255 - ((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*lhs).R) < 128) { { fR = ((2 * ((*lhs).R)) * (((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*lhs).R))) * (255 - ((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) < 128) { { fB = ((2 * ((*lhs).B)) * (((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*lhs).B))) * (255 - ((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*lhs).G) < 128) { { fG = ((2 * ((*lhs).G)) * (((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*lhs).G))) * (255 - ((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*lhs).R) < 128) { { fR = ((2 * ((*lhs).R)) * (((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*lhs).R))) * (255 - ((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) < 128) { { fB = ((2 * ((*lhs).B)) * (((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*lhs).B))) * (255 - ((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*lhs).G) < 128) { { fG = ((2 * ((*lhs).G)) * (((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*lhs).G))) * (255 - ((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*lhs).R) < 128) { { fR = ((2 * ((*lhs).R)) * (((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*lhs).R))) * (255 - ((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) < 128) { { fB = ((2 * ((*lhs).B)) * (((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*lhs).B))) * (255 - ((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*lhs).G) < 128) { { fG = ((2 * ((*lhs).G)) * (((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*lhs).G))) * (255 - ((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*lhs).R) < 128) { { fR = ((2 * ((*lhs).R)) * (((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*lhs).R))) * (255 - ((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) < 128) { { fB = ((2 * ((*lhs).B)) * (((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*lhs).B))) * (255 - ((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*lhs).G) < 128) { { fG = ((2 * ((*lhs).G)) * (((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*lhs).G))) * (255 - ((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*lhs).R) < 128) { { fR = ((2 * ((*lhs).R)) * (((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*lhs).R))) * (255 - ((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) < 128) { { fB = ((2 * ((*lhs).B)) * (((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*lhs).B))) * (255 - ((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*lhs).G) < 128) { { fG = ((2 * ((*lhs).G)) * (((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*lhs).G))) * (255 - ((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*lhs).R) < 128) { { fR = ((2 * ((*lhs).R)) * (((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*lhs).R))) * (255 - ((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) < 128) { { fB = ((2 * ((*lhs).B)) * (((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*lhs).B))) * (255 - ((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*lhs).G) < 128) { { fG = ((2 * ((*lhs).G)) * (((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*lhs).G))) * (255 - ((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*lhs).R) < 128) { { fR = ((2 * ((*lhs).R)) * (((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*lhs).R))) * (255 - ((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) < 128) { { fB = ((2 * ((*lhs).B)) * (((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*lhs).B))) * (255 - ((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*lhs).G) < 128) { { fG = ((2 * ((*lhs).G)) * (((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*lhs).G))) * (255 - ((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*lhs).R) < 128) { { fR = ((2 * ((*lhs).R)) * (((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*lhs).R))) * (255 - ((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) < 128) { { fB = ((2 * ((*lhs).B)) * (((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*lhs).B))) * (255 - ((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*lhs).G) < 128) { { fG = ((2 * ((*lhs).G)) * (((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*lhs).G))) * (255 - ((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*lhs).R) < 128) { { fR = ((2 * ((*lhs).R)) * (((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*lhs).R))) * (255 - ((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) < 128) { { fB = ((2 * ((*lhs).B)) * (((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*lhs).B))) * (255 - ((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*lhs).G) < 128) { { fG = ((2 * ((*lhs).G)) * (((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*lhs).G))) * (255 - ((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*lhs).R) < 128) { { fR = ((2 * ((*lhs).R)) * (((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*lhs).R))) * (255 - ((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) < 128) { { fB = ((2 * ((*lhs).B)) * (((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*lhs).B))) * (255 - ((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*lhs).G) < 128) { { fG = ((2 * ((*lhs).G)) * (((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*lhs).G))) * (255 - ((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*lhs).R) < 128) { { fR = ((2 * ((*lhs).R)) * (((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*lhs).R))) * (255 - ((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) < 128) { { fB = ((2 * ((*lhs).B)) * (((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; } else { { fB = ((2 * (255 - ((*lhs).B))) * (255 - ((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; fB = 255 - fB; } }; { if (((*lhs).G) < 128) { { fG = ((2 * ((*lhs).G)) * (((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; } else { { fG = ((2 * (255 - ((*lhs).G))) * (255 - ((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; fG = 255 - fG; } }; { if (((*lhs).R) < 128) { { fR = ((2 * ((*lhs).R)) * (((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; } else { { fR = ((2 * (255 - ((*lhs).R))) * (255 - ((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; fR = 255 - fR; } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,OverlayBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\OverlayBlendOp.cs,OverlayBlendOpWithOpacity,The following statement contains a magic number: if (this.opacity < 0 || this.opacity > 255) { throw new ArgumentOutOfRangeException (); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((rhs).B) * ((rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((rhs).G) * ((rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((rhs).R) * ((rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((rhs).B) * ((rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((rhs).G) * ((rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((rhs).R) * ((rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((rhs).B) * ((rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((rhs).G) * ((rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((rhs).R) * ((rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((rhs).B) * ((rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((rhs).G) * ((rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((rhs).R) * ((rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((rhs).B) * ((rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((rhs).G) * ((rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((rhs).R) * ((rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((rhs).B) * ((rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((rhs).G) * ((rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((rhs).R) * ((rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((rhs).B) * ((rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((rhs).G) * ((rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((rhs).R) * ((rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((rhs).B) * ((rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((rhs).G) * ((rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((rhs).R) * ((rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((rhs).B) * ((rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((rhs).G) * ((rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((rhs).R) * ((rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((rhs).B) * ((rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((rhs).G) * ((rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((rhs).R) * ((rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((rhs).B) * ((rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((rhs).G) * ((rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((rhs).R) * ((rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((rhs).B) * ((rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((rhs).G) * ((rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((rhs).R) * ((rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((rhs).B) * ((rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((rhs).G) * ((rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((rhs).R) * ((rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((rhs).B) * ((rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((rhs).G) * ((rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((rhs).R) * ((rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((rhs).B) * ((rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((rhs).G) * ((rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((rhs).R) * ((rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((rhs).B) * ((rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((rhs).G) * ((rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((rhs).R) * ((rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((rhs).B) * ((rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((rhs).G) * ((rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((rhs).R) * ((rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((rhs).B) * ((rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((rhs).G) * ((rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((rhs).R) * ((rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((rhs).B) * ((rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((rhs).G) * ((rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((rhs).R) * ((rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((rhs).B) * ((rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((rhs).G) * ((rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((rhs).R) * ((rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((rhs).B) * ((rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((rhs).G) * ((rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((rhs).R) * ((rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((rhs).B) * ((rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((rhs).G) * ((rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((rhs).R) * ((rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((rhs).B) * ((rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((rhs).G) * ((rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((rhs).R) * ((rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((rhs).B) * ((rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((rhs).G) * ((rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((rhs).R) * ((rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((rhs).B) * ((rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((rhs).G) * ((rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((rhs).R) * ((rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((rhs).B) * ((rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((rhs).G) * ((rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((rhs).R) * ((rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((rhs).B) * ((rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((rhs).G) * ((rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((rhs).R) * ((rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((rhs).B) * ((rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((rhs).G) * ((rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((rhs).R) * ((rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) == 255) { fB = 255; } else { { int i = (255 - ((*dst).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*src).B) * ((*src).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*dst).G) == 255) { fG = 255; } else { { int i = (255 - ((*dst).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*src).G) * ((*src).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*dst).R) == 255) { fR = 255; } else { { int i = (255 - ((*dst).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*src).R) * ((*src).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) == 255) { fB = 255; } else { { int i = (255 - ((*dst).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*src).B) * ((*src).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*dst).G) == 255) { fG = 255; } else { { int i = (255 - ((*dst).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*src).G) * ((*src).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*dst).R) == 255) { fR = 255; } else { { int i = (255 - ((*dst).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*src).R) * ((*src).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) == 255) { fB = 255; } else { { int i = (255 - ((*dst).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*src).B) * ((*src).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*dst).G) == 255) { fG = 255; } else { { int i = (255 - ((*dst).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*src).G) * ((*src).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*dst).R) == 255) { fR = 255; } else { { int i = (255 - ((*dst).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*src).R) * ((*src).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) == 255) { fB = 255; } else { { int i = (255 - ((*dst).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*src).B) * ((*src).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*dst).G) == 255) { fG = 255; } else { { int i = (255 - ((*dst).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*src).G) * ((*src).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*dst).R) == 255) { fR = 255; } else { { int i = (255 - ((*dst).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*src).R) * ((*src).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) == 255) { fB = 255; } else { { int i = (255 - ((*dst).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*src).B) * ((*src).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*dst).G) == 255) { fG = 255; } else { { int i = (255 - ((*dst).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*src).G) * ((*src).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*dst).R) == 255) { fR = 255; } else { { int i = (255 - ((*dst).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*src).R) * ((*src).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) == 255) { fB = 255; } else { { int i = (255 - ((*dst).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*src).B) * ((*src).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*dst).G) == 255) { fG = 255; } else { { int i = (255 - ((*dst).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*src).G) * ((*src).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*dst).R) == 255) { fR = 255; } else { { int i = (255 - ((*dst).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*src).R) * ((*src).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) == 255) { fB = 255; } else { { int i = (255 - ((*dst).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*src).B) * ((*src).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*dst).G) == 255) { fG = 255; } else { { int i = (255 - ((*dst).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*src).G) * ((*src).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*dst).R) == 255) { fR = 255; } else { { int i = (255 - ((*dst).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*src).R) * ((*src).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) == 255) { fB = 255; } else { { int i = (255 - ((*dst).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*src).B) * ((*src).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*dst).G) == 255) { fG = 255; } else { { int i = (255 - ((*dst).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*src).G) * ((*src).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*dst).R) == 255) { fR = 255; } else { { int i = (255 - ((*dst).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*src).R) * ((*src).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) == 255) { fB = 255; } else { { int i = (255 - ((*dst).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*src).B) * ((*src).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*dst).G) == 255) { fG = 255; } else { { int i = (255 - ((*dst).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*src).G) * ((*src).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*dst).R) == 255) { fR = 255; } else { { int i = (255 - ((*dst).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*src).R) * ((*src).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) == 255) { fB = 255; } else { { int i = (255 - ((*dst).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*src).B) * ((*src).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*dst).G) == 255) { fG = 255; } else { { int i = (255 - ((*dst).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*src).G) * ((*src).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*dst).R) == 255) { fR = 255; } else { { int i = (255 - ((*dst).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*src).R) * ((*src).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) == 255) { fB = 255; } else { { int i = (255 - ((*dst).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*src).B) * ((*src).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*dst).G) == 255) { fG = 255; } else { { int i = (255 - ((*dst).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*src).G) * ((*src).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*dst).R) == 255) { fR = 255; } else { { int i = (255 - ((*dst).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*src).R) * ((*src).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) == 255) { fB = 255; } else { { int i = (255 - ((*dst).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*src).B) * ((*src).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*dst).G) == 255) { fG = 255; } else { { int i = (255 - ((*dst).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*src).G) * ((*src).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*dst).R) == 255) { fR = 255; } else { { int i = (255 - ((*dst).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*src).R) * ((*src).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) == 255) { fB = 255; } else { { int i = (255 - ((*dst).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*src).B) * ((*src).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*dst).G) == 255) { fG = 255; } else { { int i = (255 - ((*dst).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*src).G) * ((*src).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*dst).R) == 255) { fR = 255; } else { { int i = (255 - ((*dst).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*src).R) * ((*src).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) == 255) { fB = 255; } else { { int i = (255 - ((*dst).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*src).B) * ((*src).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*dst).G) == 255) { fG = 255; } else { { int i = (255 - ((*dst).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*src).G) * ((*src).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*dst).R) == 255) { fR = 255; } else { { int i = (255 - ((*dst).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*src).R) * ((*src).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) == 255) { fB = 255; } else { { int i = (255 - ((*dst).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*src).B) * ((*src).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*dst).G) == 255) { fG = 255; } else { { int i = (255 - ((*dst).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*src).G) * ((*src).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*dst).R) == 255) { fR = 255; } else { { int i = (255 - ((*dst).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*src).R) * ((*src).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) == 255) { fB = 255; } else { { int i = (255 - ((*dst).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*src).B) * ((*src).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*dst).G) == 255) { fG = 255; } else { { int i = (255 - ((*dst).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*src).G) * ((*src).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*dst).R) == 255) { fR = 255; } else { { int i = (255 - ((*dst).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*src).R) * ((*src).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) == 255) { fB = 255; } else { { int i = (255 - ((*dst).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*src).B) * ((*src).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*dst).G) == 255) { fG = 255; } else { { int i = (255 - ((*dst).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*src).G) * ((*src).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*dst).R) == 255) { fR = 255; } else { { int i = (255 - ((*dst).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*src).R) * ((*src).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) == 255) { fB = 255; } else { { int i = (255 - ((*dst).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*src).B) * ((*src).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*dst).G) == 255) { fG = 255; } else { { int i = (255 - ((*dst).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*src).G) * ((*src).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*dst).R) == 255) { fR = 255; } else { { int i = (255 - ((*dst).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*src).R) * ((*src).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) == 255) { fB = 255; } else { { int i = (255 - ((*dst).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*src).B) * ((*src).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*dst).G) == 255) { fG = 255; } else { { int i = (255 - ((*dst).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*src).G) * ((*src).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*dst).R) == 255) { fR = 255; } else { { int i = (255 - ((*dst).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*src).R) * ((*src).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) == 255) { fB = 255; } else { { int i = (255 - ((*dst).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*src).B) * ((*src).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*dst).G) == 255) { fG = 255; } else { { int i = (255 - ((*dst).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*src).G) * ((*src).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*dst).R) == 255) { fR = 255; } else { { int i = (255 - ((*dst).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*src).R) * ((*src).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) == 255) { fB = 255; } else { { int i = (255 - ((*dst).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*src).B) * ((*src).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*dst).G) == 255) { fG = 255; } else { { int i = (255 - ((*dst).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*src).G) * ((*src).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*dst).R) == 255) { fR = 255; } else { { int i = (255 - ((*dst).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*src).R) * ((*src).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) == 255) { fB = 255; } else { { int i = (255 - ((*dst).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*src).B) * ((*src).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*dst).G) == 255) { fG = 255; } else { { int i = (255 - ((*dst).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*src).G) * ((*src).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*dst).R) == 255) { fR = 255; } else { { int i = (255 - ((*dst).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*src).R) * ((*src).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) == 255) { fB = 255; } else { { int i = (255 - ((*dst).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*src).B) * ((*src).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*dst).G) == 255) { fG = 255; } else { { int i = (255 - ((*dst).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*src).G) * ((*src).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*dst).R) == 255) { fR = 255; } else { { int i = (255 - ((*dst).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*src).R) * ((*src).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) == 255) { fB = 255; } else { { int i = (255 - ((*dst).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*src).B) * ((*src).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*dst).G) == 255) { fG = 255; } else { { int i = (255 - ((*dst).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*src).G) * ((*src).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*dst).R) == 255) { fR = 255; } else { { int i = (255 - ((*dst).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*src).R) * ((*src).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) == 255) { fB = 255; } else { { int i = (255 - ((*dst).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*src).B) * ((*src).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*dst).G) == 255) { fG = 255; } else { { int i = (255 - ((*dst).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*src).G) * ((*src).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*dst).R) == 255) { fR = 255; } else { { int i = (255 - ((*dst).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*src).R) * ((*src).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) == 255) { fB = 255; } else { { int i = (255 - ((*dst).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*src).B) * ((*src).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*dst).G) == 255) { fG = 255; } else { { int i = (255 - ((*dst).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*src).G) * ((*src).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*dst).R) == 255) { fR = 255; } else { { int i = (255 - ((*dst).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*src).R) * ((*src).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) == 255) { fB = 255; } else { { int i = (255 - ((*dst).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*src).B) * ((*src).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*dst).G) == 255) { fG = 255; } else { { int i = (255 - ((*dst).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*src).G) * ((*src).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*dst).R) == 255) { fR = 255; } else { { int i = (255 - ((*dst).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*src).R) * ((*src).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) == 255) { fB = 255; } else { { int i = (255 - ((*dst).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*src).B) * ((*src).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*dst).G) == 255) { fG = 255; } else { { int i = (255 - ((*dst).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*src).G) * ((*src).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*dst).R) == 255) { fR = 255; } else { { int i = (255 - ((*dst).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*src).R) * ((*src).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) == 255) { fB = 255; } else { { int i = (255 - ((*dst).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*src).B) * ((*src).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*dst).G) == 255) { fG = 255; } else { { int i = (255 - ((*dst).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*src).G) * ((*src).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*dst).R) == 255) { fR = 255; } else { { int i = (255 - ((*dst).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*src).R) * ((*src).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) == 255) { fB = 255; } else { { int i = (255 - ((*dst).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*src).B) * ((*src).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*dst).G) == 255) { fG = 255; } else { { int i = (255 - ((*dst).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*src).G) * ((*src).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*dst).R) == 255) { fR = 255; } else { { int i = (255 - ((*dst).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*src).R) * ((*src).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) == 255) { fB = 255; } else { { int i = (255 - ((*dst).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*src).B) * ((*src).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*dst).G) == 255) { fG = 255; } else { { int i = (255 - ((*dst).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*src).G) * ((*src).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*dst).R) == 255) { fR = 255; } else { { int i = (255 - ((*dst).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*src).R) * ((*src).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((*lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*rhs).B) * ((*rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((*lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*rhs).G) * ((*rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((*lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*rhs).R) * ((*rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((*lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*rhs).B) * ((*rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((*lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*rhs).G) * ((*rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((*lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*rhs).R) * ((*rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((*lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*rhs).B) * ((*rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((*lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*rhs).G) * ((*rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((*lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*rhs).R) * ((*rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((*lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*rhs).B) * ((*rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((*lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*rhs).G) * ((*rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((*lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*rhs).R) * ((*rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((*lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*rhs).B) * ((*rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((*lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*rhs).G) * ((*rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((*lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*rhs).R) * ((*rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((*lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*rhs).B) * ((*rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((*lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*rhs).G) * ((*rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((*lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*rhs).R) * ((*rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((*lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*rhs).B) * ((*rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((*lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*rhs).G) * ((*rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((*lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*rhs).R) * ((*rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((*lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*rhs).B) * ((*rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((*lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*rhs).G) * ((*rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((*lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*rhs).R) * ((*rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((*lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*rhs).B) * ((*rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((*lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*rhs).G) * ((*rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((*lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*rhs).R) * ((*rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((*lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*rhs).B) * ((*rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((*lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*rhs).G) * ((*rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((*lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*rhs).R) * ((*rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((*lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*rhs).B) * ((*rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((*lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*rhs).G) * ((*rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((*lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*rhs).R) * ((*rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((*lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*rhs).B) * ((*rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((*lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*rhs).G) * ((*rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((*lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*rhs).R) * ((*rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((*lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*rhs).B) * ((*rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((*lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*rhs).G) * ((*rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((*lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*rhs).R) * ((*rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((*lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*rhs).B) * ((*rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((*lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*rhs).G) * ((*rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((*lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*rhs).R) * ((*rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((*lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*rhs).B) * ((*rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((*lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*rhs).G) * ((*rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((*lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*rhs).R) * ((*rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((*lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*rhs).B) * ((*rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((*lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*rhs).G) * ((*rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((*lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*rhs).R) * ((*rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((*lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*rhs).B) * ((*rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((*lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*rhs).G) * ((*rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((*lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*rhs).R) * ((*rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((*lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*rhs).B) * ((*rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((*lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*rhs).G) * ((*rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((*lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*rhs).R) * ((*rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((*lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*rhs).B) * ((*rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((*lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*rhs).G) * ((*rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((*lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*rhs).R) * ((*rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((*lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*rhs).B) * ((*rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((*lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*rhs).G) * ((*rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((*lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*rhs).R) * ((*rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((*lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*rhs).B) * ((*rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((*lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*rhs).G) * ((*rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((*lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*rhs).R) * ((*rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((*lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*rhs).B) * ((*rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((*lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*rhs).G) * ((*rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((*lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*rhs).R) * ((*rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((*lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*rhs).B) * ((*rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((*lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*rhs).G) * ((*rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((*lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*rhs).R) * ((*rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((*lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*rhs).B) * ((*rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((*lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*rhs).G) * ((*rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((*lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*rhs).R) * ((*rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((*lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*rhs).B) * ((*rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((*lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*rhs).G) * ((*rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((*lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*rhs).R) * ((*rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((*lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*rhs).B) * ((*rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((*lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*rhs).G) * ((*rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((*lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*rhs).R) * ((*rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((*lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*rhs).B) * ((*rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((*lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*rhs).G) * ((*rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((*lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*rhs).R) * ((*rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((*lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*rhs).B) * ((*rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((*lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*rhs).G) * ((*rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((*lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*rhs).R) * ((*rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((*lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*rhs).B) * ((*rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((*lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*rhs).G) * ((*rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((*lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*rhs).R) * ((*rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((*lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*rhs).B) * ((*rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((*lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*rhs).G) * ((*rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((*lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*rhs).R) * ((*rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((*lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*rhs).B) * ((*rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((*lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*rhs).G) * ((*rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((*lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*rhs).R) * ((*rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,ApplyStatic,The following statement contains a magic number: { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,ApplyStatic,The following statement contains a magic number: { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,ApplyStatic,The following statement contains a magic number: { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((rhs).B) * ((rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((rhs).G) * ((rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((rhs).R) * ((rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((rhs).B) * ((rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((rhs).G) * ((rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((rhs).R) * ((rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((rhs).B) * ((rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((rhs).G) * ((rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((rhs).R) * ((rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((rhs).B) * ((rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((rhs).G) * ((rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((rhs).R) * ((rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((rhs).B) * ((rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((rhs).G) * ((rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((rhs).R) * ((rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((rhs).B) * ((rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((rhs).G) * ((rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((rhs).R) * ((rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((rhs).B) * ((rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((rhs).G) * ((rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((rhs).R) * ((rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((rhs).B) * ((rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((rhs).G) * ((rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((rhs).R) * ((rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((rhs).B) * ((rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((rhs).G) * ((rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((rhs).R) * ((rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((rhs).B) * ((rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((rhs).G) * ((rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((rhs).R) * ((rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((rhs).B) * ((rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((rhs).G) * ((rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((rhs).R) * ((rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((rhs).B) * ((rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((rhs).G) * ((rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((rhs).R) * ((rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((rhs).B) * ((rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((rhs).G) * ((rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((rhs).R) * ((rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((rhs).B) * ((rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((rhs).G) * ((rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((rhs).R) * ((rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((rhs).B) * ((rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((rhs).G) * ((rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((rhs).R) * ((rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((rhs).B) * ((rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((rhs).G) * ((rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((rhs).R) * ((rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((rhs).B) * ((rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((rhs).G) * ((rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((rhs).R) * ((rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((rhs).B) * ((rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((rhs).G) * ((rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((rhs).R) * ((rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((rhs).B) * ((rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((rhs).G) * ((rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((rhs).R) * ((rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((rhs).B) * ((rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((rhs).G) * ((rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((rhs).R) * ((rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((rhs).B) * ((rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((rhs).G) * ((rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((rhs).R) * ((rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((rhs).B) * ((rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((rhs).G) * ((rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((rhs).R) * ((rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((rhs).B) * ((rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((rhs).G) * ((rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((rhs).R) * ((rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((rhs).B) * ((rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((rhs).G) * ((rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((rhs).R) * ((rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((rhs).B) * ((rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((rhs).G) * ((rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((rhs).R) * ((rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((rhs).B) * ((rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((rhs).G) * ((rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((rhs).R) * ((rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((rhs).B) * ((rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((rhs).G) * ((rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((rhs).R) * ((rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((rhs).B) * ((rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((rhs).G) * ((rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((rhs).R) * ((rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,ApplyOpacity,The following statement contains a magic number: { r = ((r) * (this.opacity) + 0x80); r = ((((r) >> 8) + (r)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,ApplyOpacity,The following statement contains a magic number: { r = ((r) * (this.opacity) + 0x80); r = ((((r) >> 8) + (r)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((rhs).B) * ((rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((rhs).G) * ((rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((rhs).R) * ((rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((rhs).B) * ((rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((rhs).G) * ((rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((rhs).R) * ((rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((rhs).B) * ((rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((rhs).G) * ((rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((rhs).R) * ((rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((rhs).B) * ((rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((rhs).G) * ((rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((rhs).R) * ((rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((rhs).B) * ((rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((rhs).G) * ((rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((rhs).R) * ((rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((rhs).B) * ((rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((rhs).G) * ((rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((rhs).R) * ((rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((rhs).B) * ((rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((rhs).G) * ((rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((rhs).R) * ((rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((rhs).B) * ((rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((rhs).G) * ((rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((rhs).R) * ((rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((rhs).B) * ((rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((rhs).G) * ((rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((rhs).R) * ((rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((rhs).B) * ((rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((rhs).G) * ((rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((rhs).R) * ((rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((rhs).B) * ((rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((rhs).G) * ((rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((rhs).R) * ((rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((rhs).B) * ((rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((rhs).G) * ((rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((rhs).R) * ((rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((rhs).B) * ((rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((rhs).G) * ((rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((rhs).R) * ((rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((rhs).B) * ((rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((rhs).G) * ((rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((rhs).R) * ((rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((rhs).B) * ((rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((rhs).G) * ((rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((rhs).R) * ((rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((rhs).B) * ((rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((rhs).G) * ((rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((rhs).R) * ((rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((rhs).B) * ((rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((rhs).G) * ((rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((rhs).R) * ((rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((rhs).B) * ((rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((rhs).G) * ((rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((rhs).R) * ((rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((rhs).B) * ((rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((rhs).G) * ((rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((rhs).R) * ((rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((rhs).B) * ((rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((rhs).G) * ((rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((rhs).R) * ((rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((rhs).B) * ((rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((rhs).G) * ((rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((rhs).R) * ((rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((rhs).B) * ((rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((rhs).G) * ((rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((rhs).R) * ((rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((rhs).B) * ((rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((rhs).G) * ((rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((rhs).R) * ((rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((rhs).B) * ((rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((rhs).G) * ((rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((rhs).R) * ((rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((rhs).B) * ((rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((rhs).G) * ((rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((rhs).R) * ((rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((rhs).B) * ((rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((rhs).G) * ((rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((rhs).R) * ((rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((rhs).B) * ((rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((rhs).G) * ((rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((rhs).R) * ((rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((rhs).B) * ((rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((rhs).G) * ((rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((rhs).R) * ((rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) == 255) { fB = 255; } else { { int i = (255 - ((*dst).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*src).B) * ((*src).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*dst).G) == 255) { fG = 255; } else { { int i = (255 - ((*dst).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*src).G) * ((*src).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*dst).R) == 255) { fR = 255; } else { { int i = (255 - ((*dst).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*src).R) * ((*src).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) == 255) { fB = 255; } else { { int i = (255 - ((*dst).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*src).B) * ((*src).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*dst).G) == 255) { fG = 255; } else { { int i = (255 - ((*dst).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*src).G) * ((*src).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*dst).R) == 255) { fR = 255; } else { { int i = (255 - ((*dst).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*src).R) * ((*src).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) == 255) { fB = 255; } else { { int i = (255 - ((*dst).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*src).B) * ((*src).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*dst).G) == 255) { fG = 255; } else { { int i = (255 - ((*dst).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*src).G) * ((*src).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*dst).R) == 255) { fR = 255; } else { { int i = (255 - ((*dst).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*src).R) * ((*src).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) == 255) { fB = 255; } else { { int i = (255 - ((*dst).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*src).B) * ((*src).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*dst).G) == 255) { fG = 255; } else { { int i = (255 - ((*dst).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*src).G) * ((*src).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*dst).R) == 255) { fR = 255; } else { { int i = (255 - ((*dst).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*src).R) * ((*src).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) == 255) { fB = 255; } else { { int i = (255 - ((*dst).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*src).B) * ((*src).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*dst).G) == 255) { fG = 255; } else { { int i = (255 - ((*dst).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*src).G) * ((*src).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*dst).R) == 255) { fR = 255; } else { { int i = (255 - ((*dst).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*src).R) * ((*src).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) == 255) { fB = 255; } else { { int i = (255 - ((*dst).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*src).B) * ((*src).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*dst).G) == 255) { fG = 255; } else { { int i = (255 - ((*dst).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*src).G) * ((*src).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*dst).R) == 255) { fR = 255; } else { { int i = (255 - ((*dst).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*src).R) * ((*src).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) == 255) { fB = 255; } else { { int i = (255 - ((*dst).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*src).B) * ((*src).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*dst).G) == 255) { fG = 255; } else { { int i = (255 - ((*dst).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*src).G) * ((*src).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*dst).R) == 255) { fR = 255; } else { { int i = (255 - ((*dst).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*src).R) * ((*src).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) == 255) { fB = 255; } else { { int i = (255 - ((*dst).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*src).B) * ((*src).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*dst).G) == 255) { fG = 255; } else { { int i = (255 - ((*dst).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*src).G) * ((*src).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*dst).R) == 255) { fR = 255; } else { { int i = (255 - ((*dst).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*src).R) * ((*src).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) == 255) { fB = 255; } else { { int i = (255 - ((*dst).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*src).B) * ((*src).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*dst).G) == 255) { fG = 255; } else { { int i = (255 - ((*dst).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*src).G) * ((*src).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*dst).R) == 255) { fR = 255; } else { { int i = (255 - ((*dst).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*src).R) * ((*src).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) == 255) { fB = 255; } else { { int i = (255 - ((*dst).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*src).B) * ((*src).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*dst).G) == 255) { fG = 255; } else { { int i = (255 - ((*dst).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*src).G) * ((*src).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*dst).R) == 255) { fR = 255; } else { { int i = (255 - ((*dst).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*src).R) * ((*src).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) == 255) { fB = 255; } else { { int i = (255 - ((*dst).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*src).B) * ((*src).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*dst).G) == 255) { fG = 255; } else { { int i = (255 - ((*dst).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*src).G) * ((*src).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*dst).R) == 255) { fR = 255; } else { { int i = (255 - ((*dst).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*src).R) * ((*src).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) == 255) { fB = 255; } else { { int i = (255 - ((*dst).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*src).B) * ((*src).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*dst).G) == 255) { fG = 255; } else { { int i = (255 - ((*dst).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*src).G) * ((*src).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*dst).R) == 255) { fR = 255; } else { { int i = (255 - ((*dst).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*src).R) * ((*src).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) == 255) { fB = 255; } else { { int i = (255 - ((*dst).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*src).B) * ((*src).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*dst).G) == 255) { fG = 255; } else { { int i = (255 - ((*dst).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*src).G) * ((*src).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*dst).R) == 255) { fR = 255; } else { { int i = (255 - ((*dst).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*src).R) * ((*src).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) == 255) { fB = 255; } else { { int i = (255 - ((*dst).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*src).B) * ((*src).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*dst).G) == 255) { fG = 255; } else { { int i = (255 - ((*dst).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*src).G) * ((*src).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*dst).R) == 255) { fR = 255; } else { { int i = (255 - ((*dst).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*src).R) * ((*src).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) == 255) { fB = 255; } else { { int i = (255 - ((*dst).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*src).B) * ((*src).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*dst).G) == 255) { fG = 255; } else { { int i = (255 - ((*dst).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*src).G) * ((*src).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*dst).R) == 255) { fR = 255; } else { { int i = (255 - ((*dst).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*src).R) * ((*src).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) == 255) { fB = 255; } else { { int i = (255 - ((*dst).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*src).B) * ((*src).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*dst).G) == 255) { fG = 255; } else { { int i = (255 - ((*dst).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*src).G) * ((*src).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*dst).R) == 255) { fR = 255; } else { { int i = (255 - ((*dst).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*src).R) * ((*src).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) == 255) { fB = 255; } else { { int i = (255 - ((*dst).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*src).B) * ((*src).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*dst).G) == 255) { fG = 255; } else { { int i = (255 - ((*dst).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*src).G) * ((*src).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*dst).R) == 255) { fR = 255; } else { { int i = (255 - ((*dst).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*src).R) * ((*src).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) == 255) { fB = 255; } else { { int i = (255 - ((*dst).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*src).B) * ((*src).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*dst).G) == 255) { fG = 255; } else { { int i = (255 - ((*dst).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*src).G) * ((*src).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*dst).R) == 255) { fR = 255; } else { { int i = (255 - ((*dst).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*src).R) * ((*src).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) == 255) { fB = 255; } else { { int i = (255 - ((*dst).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*src).B) * ((*src).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*dst).G) == 255) { fG = 255; } else { { int i = (255 - ((*dst).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*src).G) * ((*src).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*dst).R) == 255) { fR = 255; } else { { int i = (255 - ((*dst).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*src).R) * ((*src).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) == 255) { fB = 255; } else { { int i = (255 - ((*dst).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*src).B) * ((*src).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*dst).G) == 255) { fG = 255; } else { { int i = (255 - ((*dst).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*src).G) * ((*src).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*dst).R) == 255) { fR = 255; } else { { int i = (255 - ((*dst).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*src).R) * ((*src).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) == 255) { fB = 255; } else { { int i = (255 - ((*dst).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*src).B) * ((*src).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*dst).G) == 255) { fG = 255; } else { { int i = (255 - ((*dst).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*src).G) * ((*src).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*dst).R) == 255) { fR = 255; } else { { int i = (255 - ((*dst).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*src).R) * ((*src).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) == 255) { fB = 255; } else { { int i = (255 - ((*dst).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*src).B) * ((*src).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*dst).G) == 255) { fG = 255; } else { { int i = (255 - ((*dst).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*src).G) * ((*src).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*dst).R) == 255) { fR = 255; } else { { int i = (255 - ((*dst).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*src).R) * ((*src).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) == 255) { fB = 255; } else { { int i = (255 - ((*dst).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*src).B) * ((*src).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*dst).G) == 255) { fG = 255; } else { { int i = (255 - ((*dst).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*src).G) * ((*src).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*dst).R) == 255) { fR = 255; } else { { int i = (255 - ((*dst).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*src).R) * ((*src).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) == 255) { fB = 255; } else { { int i = (255 - ((*dst).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*src).B) * ((*src).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*dst).G) == 255) { fG = 255; } else { { int i = (255 - ((*dst).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*src).G) * ((*src).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*dst).R) == 255) { fR = 255; } else { { int i = (255 - ((*dst).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*src).R) * ((*src).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) == 255) { fB = 255; } else { { int i = (255 - ((*dst).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*src).B) * ((*src).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*dst).G) == 255) { fG = 255; } else { { int i = (255 - ((*dst).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*src).G) * ((*src).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*dst).R) == 255) { fR = 255; } else { { int i = (255 - ((*dst).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*src).R) * ((*src).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) == 255) { fB = 255; } else { { int i = (255 - ((*dst).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*src).B) * ((*src).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*dst).G) == 255) { fG = 255; } else { { int i = (255 - ((*dst).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*src).G) * ((*src).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*dst).R) == 255) { fR = 255; } else { { int i = (255 - ((*dst).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*src).R) * ((*src).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) == 255) { fB = 255; } else { { int i = (255 - ((*dst).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*src).B) * ((*src).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*dst).G) == 255) { fG = 255; } else { { int i = (255 - ((*dst).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*src).G) * ((*src).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*dst).R) == 255) { fR = 255; } else { { int i = (255 - ((*dst).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*src).R) * ((*src).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) == 255) { fB = 255; } else { { int i = (255 - ((*dst).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*src).B) * ((*src).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*dst).G) == 255) { fG = 255; } else { { int i = (255 - ((*dst).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*src).G) * ((*src).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*dst).R) == 255) { fR = 255; } else { { int i = (255 - ((*dst).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*src).R) * ((*src).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) == 255) { fB = 255; } else { { int i = (255 - ((*dst).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*src).B) * ((*src).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*dst).G) == 255) { fG = 255; } else { { int i = (255 - ((*dst).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*src).G) * ((*src).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*dst).R) == 255) { fR = 255; } else { { int i = (255 - ((*dst).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*src).R) * ((*src).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) == 255) { fB = 255; } else { { int i = (255 - ((*dst).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*src).B) * ((*src).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*dst).G) == 255) { fG = 255; } else { { int i = (255 - ((*dst).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*src).G) * ((*src).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*dst).R) == 255) { fR = 255; } else { { int i = (255 - ((*dst).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*src).R) * ((*src).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*dst).B) == 255) { fB = 255; } else { { int i = (255 - ((*dst).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*src).B) * ((*src).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*dst).G) == 255) { fG = 255; } else { { int i = (255 - ((*dst).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*src).G) * ((*src).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*dst).R) == 255) { fR = 255; } else { { int i = (255 - ((*dst).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*src).R) * ((*src).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((*lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*rhs).B) * ((*rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((*lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*rhs).G) * ((*rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((*lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*rhs).R) * ((*rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((*lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*rhs).B) * ((*rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((*lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*rhs).G) * ((*rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((*lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*rhs).R) * ((*rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((*lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*rhs).B) * ((*rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((*lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*rhs).G) * ((*rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((*lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*rhs).R) * ((*rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((*lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*rhs).B) * ((*rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((*lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*rhs).G) * ((*rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((*lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*rhs).R) * ((*rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((*lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*rhs).B) * ((*rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((*lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*rhs).G) * ((*rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((*lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*rhs).R) * ((*rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((*lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*rhs).B) * ((*rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((*lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*rhs).G) * ((*rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((*lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*rhs).R) * ((*rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((*lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*rhs).B) * ((*rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((*lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*rhs).G) * ((*rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((*lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*rhs).R) * ((*rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((*lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*rhs).B) * ((*rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((*lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*rhs).G) * ((*rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((*lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*rhs).R) * ((*rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((*lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*rhs).B) * ((*rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((*lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*rhs).G) * ((*rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((*lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*rhs).R) * ((*rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((*lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*rhs).B) * ((*rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((*lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*rhs).G) * ((*rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((*lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*rhs).R) * ((*rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((*lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*rhs).B) * ((*rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((*lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*rhs).G) * ((*rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((*lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*rhs).R) * ((*rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((*lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*rhs).B) * ((*rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((*lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*rhs).G) * ((*rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((*lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*rhs).R) * ((*rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((*lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*rhs).B) * ((*rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((*lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*rhs).G) * ((*rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((*lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*rhs).R) * ((*rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((*lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*rhs).B) * ((*rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((*lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*rhs).G) * ((*rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((*lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*rhs).R) * ((*rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((*lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*rhs).B) * ((*rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((*lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*rhs).G) * ((*rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((*lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*rhs).R) * ((*rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((*lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*rhs).B) * ((*rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((*lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*rhs).G) * ((*rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((*lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*rhs).R) * ((*rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((*lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*rhs).B) * ((*rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((*lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*rhs).G) * ((*rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((*lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*rhs).R) * ((*rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((*lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*rhs).B) * ((*rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((*lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*rhs).G) * ((*rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((*lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*rhs).R) * ((*rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((*lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*rhs).B) * ((*rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((*lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*rhs).G) * ((*rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((*lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*rhs).R) * ((*rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((*lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*rhs).B) * ((*rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((*lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*rhs).G) * ((*rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((*lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*rhs).R) * ((*rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((*lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*rhs).B) * ((*rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((*lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*rhs).G) * ((*rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((*lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*rhs).R) * ((*rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((*lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*rhs).B) * ((*rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((*lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*rhs).G) * ((*rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((*lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*rhs).R) * ((*rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((*lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*rhs).B) * ((*rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((*lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*rhs).G) * ((*rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((*lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*rhs).R) * ((*rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((*lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*rhs).B) * ((*rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((*lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*rhs).G) * ((*rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((*lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*rhs).R) * ((*rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((*lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*rhs).B) * ((*rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((*lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*rhs).G) * ((*rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((*lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*rhs).R) * ((*rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((*lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*rhs).B) * ((*rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((*lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*rhs).G) * ((*rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((*lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*rhs).R) * ((*rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((*lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*rhs).B) * ((*rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((*lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*rhs).G) * ((*rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((*lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*rhs).R) * ((*rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((*lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*rhs).B) * ((*rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((*lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*rhs).G) * ((*rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((*lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*rhs).R) * ((*rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((*lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*rhs).B) * ((*rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((*lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*rhs).G) * ((*rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((*lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*rhs).R) * ((*rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((*lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*rhs).B) * ((*rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((*lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*rhs).G) * ((*rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((*lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*rhs).R) * ((*rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*lhs).B) == 255) { fB = 255; } else { { int i = (255 - ((*lhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*rhs).B) * ((*rhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*lhs).G) == 255) { fG = 255; } else { { int i = (255 - ((*lhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*rhs).G) * ((*rhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*lhs).R) == 255) { fR = 255; } else { { int i = (255 - ((*lhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*rhs).R) * ((*rhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,GlowBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\GlowBlendOp.cs,GlowBlendOpWithOpacity,The following statement contains a magic number: if (this.opacity < 0 || this.opacity > 255) { throw new ArgumentOutOfRangeException (); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((lhs).B) * ((lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((lhs).G) * ((lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((lhs).R) * ((lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((lhs).B) * ((lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((lhs).G) * ((lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((lhs).R) * ((lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((lhs).B) * ((lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((lhs).G) * ((lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((lhs).R) * ((lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((lhs).B) * ((lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((lhs).G) * ((lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((lhs).R) * ((lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((lhs).B) * ((lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((lhs).G) * ((lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((lhs).R) * ((lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((lhs).B) * ((lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((lhs).G) * ((lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((lhs).R) * ((lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((lhs).B) * ((lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((lhs).G) * ((lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((lhs).R) * ((lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((lhs).B) * ((lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((lhs).G) * ((lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((lhs).R) * ((lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((lhs).B) * ((lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((lhs).G) * ((lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((lhs).R) * ((lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((lhs).B) * ((lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((lhs).G) * ((lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((lhs).R) * ((lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((lhs).B) * ((lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((lhs).G) * ((lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((lhs).R) * ((lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((lhs).B) * ((lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((lhs).G) * ((lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((lhs).R) * ((lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((lhs).B) * ((lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((lhs).G) * ((lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((lhs).R) * ((lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((lhs).B) * ((lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((lhs).G) * ((lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((lhs).R) * ((lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((lhs).B) * ((lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((lhs).G) * ((lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((lhs).R) * ((lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((lhs).B) * ((lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((lhs).G) * ((lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((lhs).R) * ((lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((lhs).B) * ((lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((lhs).G) * ((lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((lhs).R) * ((lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((lhs).B) * ((lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((lhs).G) * ((lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((lhs).R) * ((lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((lhs).B) * ((lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((lhs).G) * ((lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((lhs).R) * ((lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((lhs).B) * ((lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((lhs).G) * ((lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((lhs).R) * ((lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((lhs).B) * ((lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((lhs).G) * ((lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((lhs).R) * ((lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((lhs).B) * ((lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((lhs).G) * ((lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((lhs).R) * ((lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((lhs).B) * ((lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((lhs).G) * ((lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((lhs).R) * ((lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((lhs).B) * ((lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((lhs).G) * ((lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((lhs).R) * ((lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((lhs).B) * ((lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((lhs).G) * ((lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((lhs).R) * ((lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((lhs).B) * ((lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((lhs).G) * ((lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((lhs).R) * ((lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((lhs).B) * ((lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((lhs).G) * ((lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((lhs).R) * ((lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((lhs).B) * ((lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((lhs).G) * ((lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((lhs).R) * ((lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = (255 - ((*src).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*dst).B) * ((*dst).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = (255 - ((*src).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*dst).G) * ((*dst).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = (255 - ((*src).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*dst).R) * ((*dst).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = (255 - ((*src).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*dst).B) * ((*dst).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = (255 - ((*src).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*dst).G) * ((*dst).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = (255 - ((*src).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*dst).R) * ((*dst).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = (255 - ((*src).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*dst).B) * ((*dst).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = (255 - ((*src).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*dst).G) * ((*dst).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = (255 - ((*src).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*dst).R) * ((*dst).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = (255 - ((*src).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*dst).B) * ((*dst).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = (255 - ((*src).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*dst).G) * ((*dst).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = (255 - ((*src).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*dst).R) * ((*dst).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = (255 - ((*src).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*dst).B) * ((*dst).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = (255 - ((*src).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*dst).G) * ((*dst).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = (255 - ((*src).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*dst).R) * ((*dst).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = (255 - ((*src).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*dst).B) * ((*dst).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = (255 - ((*src).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*dst).G) * ((*dst).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = (255 - ((*src).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*dst).R) * ((*dst).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = (255 - ((*src).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*dst).B) * ((*dst).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = (255 - ((*src).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*dst).G) * ((*dst).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = (255 - ((*src).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*dst).R) * ((*dst).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = (255 - ((*src).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*dst).B) * ((*dst).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = (255 - ((*src).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*dst).G) * ((*dst).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = (255 - ((*src).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*dst).R) * ((*dst).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = (255 - ((*src).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*dst).B) * ((*dst).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = (255 - ((*src).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*dst).G) * ((*dst).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = (255 - ((*src).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*dst).R) * ((*dst).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = (255 - ((*src).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*dst).B) * ((*dst).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = (255 - ((*src).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*dst).G) * ((*dst).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = (255 - ((*src).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*dst).R) * ((*dst).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = (255 - ((*src).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*dst).B) * ((*dst).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = (255 - ((*src).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*dst).G) * ((*dst).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = (255 - ((*src).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*dst).R) * ((*dst).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = (255 - ((*src).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*dst).B) * ((*dst).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = (255 - ((*src).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*dst).G) * ((*dst).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = (255 - ((*src).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*dst).R) * ((*dst).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = (255 - ((*src).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*dst).B) * ((*dst).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = (255 - ((*src).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*dst).G) * ((*dst).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = (255 - ((*src).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*dst).R) * ((*dst).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = (255 - ((*src).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*dst).B) * ((*dst).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = (255 - ((*src).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*dst).G) * ((*dst).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = (255 - ((*src).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*dst).R) * ((*dst).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = (255 - ((*src).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*dst).B) * ((*dst).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = (255 - ((*src).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*dst).G) * ((*dst).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = (255 - ((*src).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*dst).R) * ((*dst).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = (255 - ((*src).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*dst).B) * ((*dst).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = (255 - ((*src).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*dst).G) * ((*dst).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = (255 - ((*src).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*dst).R) * ((*dst).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = (255 - ((*src).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*dst).B) * ((*dst).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = (255 - ((*src).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*dst).G) * ((*dst).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = (255 - ((*src).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*dst).R) * ((*dst).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = (255 - ((*src).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*dst).B) * ((*dst).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = (255 - ((*src).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*dst).G) * ((*dst).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = (255 - ((*src).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*dst).R) * ((*dst).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = (255 - ((*src).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*dst).B) * ((*dst).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = (255 - ((*src).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*dst).G) * ((*dst).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = (255 - ((*src).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*dst).R) * ((*dst).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = (255 - ((*src).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*dst).B) * ((*dst).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = (255 - ((*src).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*dst).G) * ((*dst).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = (255 - ((*src).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*dst).R) * ((*dst).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = (255 - ((*src).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*dst).B) * ((*dst).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = (255 - ((*src).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*dst).G) * ((*dst).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = (255 - ((*src).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*dst).R) * ((*dst).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = (255 - ((*src).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*dst).B) * ((*dst).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = (255 - ((*src).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*dst).G) * ((*dst).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = (255 - ((*src).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*dst).R) * ((*dst).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = (255 - ((*src).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*dst).B) * ((*dst).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = (255 - ((*src).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*dst).G) * ((*dst).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = (255 - ((*src).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*dst).R) * ((*dst).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = (255 - ((*src).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*dst).B) * ((*dst).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = (255 - ((*src).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*dst).G) * ((*dst).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = (255 - ((*src).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*dst).R) * ((*dst).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = (255 - ((*src).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*dst).B) * ((*dst).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = (255 - ((*src).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*dst).G) * ((*dst).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = (255 - ((*src).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*dst).R) * ((*dst).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = (255 - ((*src).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*dst).B) * ((*dst).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = (255 - ((*src).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*dst).G) * ((*dst).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = (255 - ((*src).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*dst).R) * ((*dst).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = (255 - ((*src).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*dst).B) * ((*dst).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = (255 - ((*src).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*dst).G) * ((*dst).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = (255 - ((*src).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*dst).R) * ((*dst).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = (255 - ((*src).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*dst).B) * ((*dst).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = (255 - ((*src).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*dst).G) * ((*dst).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = (255 - ((*src).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*dst).R) * ((*dst).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = (255 - ((*src).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*dst).B) * ((*dst).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = (255 - ((*src).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*dst).G) * ((*dst).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = (255 - ((*src).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*dst).R) * ((*dst).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = (255 - ((*src).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*dst).B) * ((*dst).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = (255 - ((*src).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*dst).G) * ((*dst).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = (255 - ((*src).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*dst).R) * ((*dst).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = (255 - ((*src).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*dst).B) * ((*dst).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = (255 - ((*src).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*dst).G) * ((*dst).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = (255 - ((*src).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*dst).R) * ((*dst).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((*rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*lhs).B) * ((*lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((*rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*lhs).G) * ((*lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((*rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*lhs).R) * ((*lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((*rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*lhs).B) * ((*lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((*rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*lhs).G) * ((*lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((*rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*lhs).R) * ((*lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((*rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*lhs).B) * ((*lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((*rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*lhs).G) * ((*lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((*rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*lhs).R) * ((*lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((*rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*lhs).B) * ((*lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((*rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*lhs).G) * ((*lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((*rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*lhs).R) * ((*lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((*rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*lhs).B) * ((*lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((*rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*lhs).G) * ((*lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((*rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*lhs).R) * ((*lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((*rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*lhs).B) * ((*lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((*rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*lhs).G) * ((*lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((*rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*lhs).R) * ((*lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((*rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*lhs).B) * ((*lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((*rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*lhs).G) * ((*lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((*rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*lhs).R) * ((*lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((*rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*lhs).B) * ((*lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((*rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*lhs).G) * ((*lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((*rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*lhs).R) * ((*lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((*rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*lhs).B) * ((*lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((*rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*lhs).G) * ((*lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((*rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*lhs).R) * ((*lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((*rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*lhs).B) * ((*lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((*rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*lhs).G) * ((*lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((*rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*lhs).R) * ((*lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((*rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*lhs).B) * ((*lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((*rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*lhs).G) * ((*lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((*rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*lhs).R) * ((*lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((*rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*lhs).B) * ((*lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((*rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*lhs).G) * ((*lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((*rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*lhs).R) * ((*lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((*rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*lhs).B) * ((*lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((*rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*lhs).G) * ((*lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((*rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*lhs).R) * ((*lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((*rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*lhs).B) * ((*lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((*rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*lhs).G) * ((*lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((*rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*lhs).R) * ((*lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((*rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*lhs).B) * ((*lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((*rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*lhs).G) * ((*lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((*rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*lhs).R) * ((*lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((*rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*lhs).B) * ((*lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((*rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*lhs).G) * ((*lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((*rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*lhs).R) * ((*lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((*rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*lhs).B) * ((*lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((*rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*lhs).G) * ((*lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((*rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*lhs).R) * ((*lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((*rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*lhs).B) * ((*lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((*rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*lhs).G) * ((*lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((*rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*lhs).R) * ((*lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((*rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*lhs).B) * ((*lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((*rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*lhs).G) * ((*lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((*rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*lhs).R) * ((*lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((*rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*lhs).B) * ((*lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((*rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*lhs).G) * ((*lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((*rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*lhs).R) * ((*lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((*rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*lhs).B) * ((*lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((*rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*lhs).G) * ((*lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((*rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*lhs).R) * ((*lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((*rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*lhs).B) * ((*lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((*rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*lhs).G) * ((*lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((*rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*lhs).R) * ((*lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((*rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*lhs).B) * ((*lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((*rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*lhs).G) * ((*lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((*rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*lhs).R) * ((*lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((*rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*lhs).B) * ((*lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((*rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*lhs).G) * ((*lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((*rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*lhs).R) * ((*lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((*rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*lhs).B) * ((*lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((*rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*lhs).G) * ((*lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((*rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*lhs).R) * ((*lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((*rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*lhs).B) * ((*lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((*rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*lhs).G) * ((*lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((*rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*lhs).R) * ((*lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((*rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*lhs).B) * ((*lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((*rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*lhs).G) * ((*lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((*rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*lhs).R) * ((*lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((*rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*lhs).B) * ((*lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((*rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*lhs).G) * ((*lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((*rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*lhs).R) * ((*lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((*rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*lhs).B) * ((*lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((*rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*lhs).G) * ((*lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((*rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*lhs).R) * ((*lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((*rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*lhs).B) * ((*lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((*rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*lhs).G) * ((*lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((*rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*lhs).R) * ((*lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((*rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*lhs).B) * ((*lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((*rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*lhs).G) * ((*lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((*rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*lhs).R) * ((*lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,ApplyStatic,The following statement contains a magic number: { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,ApplyStatic,The following statement contains a magic number: { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,ApplyStatic,The following statement contains a magic number: { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((lhs).B) * ((lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((lhs).G) * ((lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((lhs).R) * ((lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((lhs).B) * ((lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((lhs).G) * ((lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((lhs).R) * ((lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((lhs).B) * ((lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((lhs).G) * ((lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((lhs).R) * ((lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((lhs).B) * ((lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((lhs).G) * ((lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((lhs).R) * ((lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((lhs).B) * ((lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((lhs).G) * ((lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((lhs).R) * ((lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((lhs).B) * ((lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((lhs).G) * ((lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((lhs).R) * ((lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((lhs).B) * ((lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((lhs).G) * ((lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((lhs).R) * ((lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((lhs).B) * ((lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((lhs).G) * ((lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((lhs).R) * ((lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((lhs).B) * ((lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((lhs).G) * ((lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((lhs).R) * ((lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((lhs).B) * ((lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((lhs).G) * ((lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((lhs).R) * ((lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((lhs).B) * ((lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((lhs).G) * ((lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((lhs).R) * ((lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((lhs).B) * ((lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((lhs).G) * ((lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((lhs).R) * ((lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((lhs).B) * ((lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((lhs).G) * ((lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((lhs).R) * ((lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((lhs).B) * ((lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((lhs).G) * ((lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((lhs).R) * ((lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((lhs).B) * ((lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((lhs).G) * ((lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((lhs).R) * ((lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((lhs).B) * ((lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((lhs).G) * ((lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((lhs).R) * ((lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((lhs).B) * ((lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((lhs).G) * ((lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((lhs).R) * ((lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((lhs).B) * ((lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((lhs).G) * ((lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((lhs).R) * ((lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((lhs).B) * ((lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((lhs).G) * ((lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((lhs).R) * ((lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((lhs).B) * ((lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((lhs).G) * ((lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((lhs).R) * ((lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((lhs).B) * ((lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((lhs).G) * ((lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((lhs).R) * ((lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((lhs).B) * ((lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((lhs).G) * ((lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((lhs).R) * ((lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((lhs).B) * ((lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((lhs).G) * ((lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((lhs).R) * ((lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((lhs).B) * ((lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((lhs).G) * ((lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((lhs).R) * ((lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((lhs).B) * ((lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((lhs).G) * ((lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((lhs).R) * ((lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((lhs).B) * ((lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((lhs).G) * ((lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((lhs).R) * ((lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((lhs).B) * ((lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((lhs).G) * ((lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((lhs).R) * ((lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((lhs).B) * ((lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((lhs).G) * ((lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((lhs).R) * ((lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,ApplyOpacity,The following statement contains a magic number: { r = ((r) * (this.opacity) + 0x80); r = ((((r) >> 8) + (r)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,ApplyOpacity,The following statement contains a magic number: { r = ((r) * (this.opacity) + 0x80); r = ((((r) >> 8) + (r)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((lhs).B) * ((lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((lhs).G) * ((lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((lhs).R) * ((lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((lhs).B) * ((lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((lhs).G) * ((lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((lhs).R) * ((lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((lhs).B) * ((lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((lhs).G) * ((lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((lhs).R) * ((lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((lhs).B) * ((lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((lhs).G) * ((lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((lhs).R) * ((lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((lhs).B) * ((lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((lhs).G) * ((lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((lhs).R) * ((lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((lhs).B) * ((lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((lhs).G) * ((lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((lhs).R) * ((lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((lhs).B) * ((lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((lhs).G) * ((lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((lhs).R) * ((lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((lhs).B) * ((lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((lhs).G) * ((lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((lhs).R) * ((lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((lhs).B) * ((lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((lhs).G) * ((lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((lhs).R) * ((lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((lhs).B) * ((lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((lhs).G) * ((lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((lhs).R) * ((lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((lhs).B) * ((lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((lhs).G) * ((lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((lhs).R) * ((lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((lhs).B) * ((lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((lhs).G) * ((lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((lhs).R) * ((lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((lhs).B) * ((lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((lhs).G) * ((lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((lhs).R) * ((lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((lhs).B) * ((lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((lhs).G) * ((lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((lhs).R) * ((lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((lhs).B) * ((lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((lhs).G) * ((lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((lhs).R) * ((lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((lhs).B) * ((lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((lhs).G) * ((lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((lhs).R) * ((lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((lhs).B) * ((lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((lhs).G) * ((lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((lhs).R) * ((lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((lhs).B) * ((lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((lhs).G) * ((lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((lhs).R) * ((lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((lhs).B) * ((lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((lhs).G) * ((lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((lhs).R) * ((lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((lhs).B) * ((lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((lhs).G) * ((lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((lhs).R) * ((lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((lhs).B) * ((lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((lhs).G) * ((lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((lhs).R) * ((lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((lhs).B) * ((lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((lhs).G) * ((lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((lhs).R) * ((lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((lhs).B) * ((lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((lhs).G) * ((lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((lhs).R) * ((lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((lhs).B) * ((lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((lhs).G) * ((lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((lhs).R) * ((lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((lhs).B) * ((lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((lhs).G) * ((lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((lhs).R) * ((lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((lhs).B) * ((lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((lhs).G) * ((lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((lhs).R) * ((lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((lhs).B) * ((lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((lhs).G) * ((lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((lhs).R) * ((lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((lhs).B) * ((lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((lhs).G) * ((lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((lhs).R) * ((lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = (255 - ((*src).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*dst).B) * ((*dst).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = (255 - ((*src).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*dst).G) * ((*dst).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = (255 - ((*src).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*dst).R) * ((*dst).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = (255 - ((*src).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*dst).B) * ((*dst).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = (255 - ((*src).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*dst).G) * ((*dst).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = (255 - ((*src).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*dst).R) * ((*dst).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = (255 - ((*src).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*dst).B) * ((*dst).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = (255 - ((*src).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*dst).G) * ((*dst).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = (255 - ((*src).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*dst).R) * ((*dst).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = (255 - ((*src).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*dst).B) * ((*dst).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = (255 - ((*src).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*dst).G) * ((*dst).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = (255 - ((*src).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*dst).R) * ((*dst).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = (255 - ((*src).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*dst).B) * ((*dst).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = (255 - ((*src).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*dst).G) * ((*dst).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = (255 - ((*src).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*dst).R) * ((*dst).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = (255 - ((*src).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*dst).B) * ((*dst).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = (255 - ((*src).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*dst).G) * ((*dst).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = (255 - ((*src).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*dst).R) * ((*dst).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = (255 - ((*src).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*dst).B) * ((*dst).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = (255 - ((*src).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*dst).G) * ((*dst).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = (255 - ((*src).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*dst).R) * ((*dst).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = (255 - ((*src).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*dst).B) * ((*dst).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = (255 - ((*src).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*dst).G) * ((*dst).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = (255 - ((*src).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*dst).R) * ((*dst).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = (255 - ((*src).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*dst).B) * ((*dst).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = (255 - ((*src).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*dst).G) * ((*dst).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = (255 - ((*src).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*dst).R) * ((*dst).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = (255 - ((*src).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*dst).B) * ((*dst).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = (255 - ((*src).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*dst).G) * ((*dst).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = (255 - ((*src).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*dst).R) * ((*dst).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = (255 - ((*src).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*dst).B) * ((*dst).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = (255 - ((*src).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*dst).G) * ((*dst).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = (255 - ((*src).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*dst).R) * ((*dst).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = (255 - ((*src).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*dst).B) * ((*dst).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = (255 - ((*src).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*dst).G) * ((*dst).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = (255 - ((*src).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*dst).R) * ((*dst).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = (255 - ((*src).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*dst).B) * ((*dst).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = (255 - ((*src).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*dst).G) * ((*dst).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = (255 - ((*src).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*dst).R) * ((*dst).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = (255 - ((*src).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*dst).B) * ((*dst).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = (255 - ((*src).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*dst).G) * ((*dst).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = (255 - ((*src).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*dst).R) * ((*dst).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = (255 - ((*src).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*dst).B) * ((*dst).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = (255 - ((*src).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*dst).G) * ((*dst).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = (255 - ((*src).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*dst).R) * ((*dst).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = (255 - ((*src).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*dst).B) * ((*dst).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = (255 - ((*src).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*dst).G) * ((*dst).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = (255 - ((*src).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*dst).R) * ((*dst).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = (255 - ((*src).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*dst).B) * ((*dst).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = (255 - ((*src).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*dst).G) * ((*dst).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = (255 - ((*src).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*dst).R) * ((*dst).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = (255 - ((*src).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*dst).B) * ((*dst).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = (255 - ((*src).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*dst).G) * ((*dst).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = (255 - ((*src).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*dst).R) * ((*dst).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = (255 - ((*src).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*dst).B) * ((*dst).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = (255 - ((*src).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*dst).G) * ((*dst).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = (255 - ((*src).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*dst).R) * ((*dst).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = (255 - ((*src).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*dst).B) * ((*dst).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = (255 - ((*src).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*dst).G) * ((*dst).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = (255 - ((*src).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*dst).R) * ((*dst).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = (255 - ((*src).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*dst).B) * ((*dst).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = (255 - ((*src).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*dst).G) * ((*dst).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = (255 - ((*src).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*dst).R) * ((*dst).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = (255 - ((*src).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*dst).B) * ((*dst).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = (255 - ((*src).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*dst).G) * ((*dst).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = (255 - ((*src).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*dst).R) * ((*dst).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = (255 - ((*src).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*dst).B) * ((*dst).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = (255 - ((*src).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*dst).G) * ((*dst).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = (255 - ((*src).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*dst).R) * ((*dst).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = (255 - ((*src).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*dst).B) * ((*dst).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = (255 - ((*src).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*dst).G) * ((*dst).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = (255 - ((*src).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*dst).R) * ((*dst).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = (255 - ((*src).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*dst).B) * ((*dst).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = (255 - ((*src).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*dst).G) * ((*dst).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = (255 - ((*src).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*dst).R) * ((*dst).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = (255 - ((*src).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*dst).B) * ((*dst).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = (255 - ((*src).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*dst).G) * ((*dst).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = (255 - ((*src).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*dst).R) * ((*dst).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = (255 - ((*src).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*dst).B) * ((*dst).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = (255 - ((*src).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*dst).G) * ((*dst).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = (255 - ((*src).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*dst).R) * ((*dst).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = (255 - ((*src).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*dst).B) * ((*dst).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = (255 - ((*src).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*dst).G) * ((*dst).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = (255 - ((*src).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*dst).R) * ((*dst).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = (255 - ((*src).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*dst).B) * ((*dst).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = (255 - ((*src).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*dst).G) * ((*dst).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = (255 - ((*src).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*dst).R) * ((*dst).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = (255 - ((*src).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*dst).B) * ((*dst).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = (255 - ((*src).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*dst).G) * ((*dst).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = (255 - ((*src).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*dst).R) * ((*dst).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*src).B) == 255) { fB = 255; } else { { int i = (255 - ((*src).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*dst).B) * ((*dst).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*src).G) == 255) { fG = 255; } else { { int i = (255 - ((*src).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*dst).G) * ((*dst).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*src).R) == 255) { fR = 255; } else { { int i = (255 - ((*src).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*dst).R) * ((*dst).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((*rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*lhs).B) * ((*lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((*rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*lhs).G) * ((*lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((*rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*lhs).R) * ((*lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((*rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*lhs).B) * ((*lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((*rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*lhs).G) * ((*lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((*rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*lhs).R) * ((*lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((*rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*lhs).B) * ((*lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((*rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*lhs).G) * ((*lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((*rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*lhs).R) * ((*lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((*rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*lhs).B) * ((*lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((*rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*lhs).G) * ((*lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((*rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*lhs).R) * ((*lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((*rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*lhs).B) * ((*lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((*rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*lhs).G) * ((*lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((*rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*lhs).R) * ((*lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((*rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*lhs).B) * ((*lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((*rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*lhs).G) * ((*lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((*rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*lhs).R) * ((*lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((*rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*lhs).B) * ((*lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((*rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*lhs).G) * ((*lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((*rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*lhs).R) * ((*lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((*rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*lhs).B) * ((*lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((*rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*lhs).G) * ((*lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((*rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*lhs).R) * ((*lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((*rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*lhs).B) * ((*lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((*rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*lhs).G) * ((*lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((*rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*lhs).R) * ((*lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((*rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*lhs).B) * ((*lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((*rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*lhs).G) * ((*lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((*rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*lhs).R) * ((*lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((*rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*lhs).B) * ((*lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((*rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*lhs).G) * ((*lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((*rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*lhs).R) * ((*lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((*rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*lhs).B) * ((*lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((*rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*lhs).G) * ((*lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((*rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*lhs).R) * ((*lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((*rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*lhs).B) * ((*lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((*rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*lhs).G) * ((*lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((*rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*lhs).R) * ((*lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((*rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*lhs).B) * ((*lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((*rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*lhs).G) * ((*lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((*rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*lhs).R) * ((*lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((*rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*lhs).B) * ((*lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((*rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*lhs).G) * ((*lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((*rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*lhs).R) * ((*lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((*rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*lhs).B) * ((*lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((*rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*lhs).G) * ((*lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((*rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*lhs).R) * ((*lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((*rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*lhs).B) * ((*lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((*rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*lhs).G) * ((*lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((*rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*lhs).R) * ((*lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((*rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*lhs).B) * ((*lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((*rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*lhs).G) * ((*lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((*rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*lhs).R) * ((*lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((*rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*lhs).B) * ((*lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((*rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*lhs).G) * ((*lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((*rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*lhs).R) * ((*lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((*rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*lhs).B) * ((*lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((*rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*lhs).G) * ((*lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((*rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*lhs).R) * ((*lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((*rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*lhs).B) * ((*lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((*rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*lhs).G) * ((*lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((*rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*lhs).R) * ((*lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((*rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*lhs).B) * ((*lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((*rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*lhs).G) * ((*lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((*rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*lhs).R) * ((*lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((*rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*lhs).B) * ((*lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((*rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*lhs).G) * ((*lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((*rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*lhs).R) * ((*lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((*rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*lhs).B) * ((*lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((*rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*lhs).G) * ((*lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((*rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*lhs).R) * ((*lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((*rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*lhs).B) * ((*lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((*rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*lhs).G) * ((*lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((*rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*lhs).R) * ((*lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((*rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*lhs).B) * ((*lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((*rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*lhs).G) * ((*lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((*rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*lhs).R) * ((*lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((*rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*lhs).B) * ((*lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((*rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*lhs).G) * ((*lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((*rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*lhs).R) * ((*lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((*rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*lhs).B) * ((*lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((*rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*lhs).G) * ((*lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((*rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*lhs).R) * ((*lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((*rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*lhs).B) * ((*lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((*rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*lhs).G) * ((*lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((*rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*lhs).R) * ((*lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((*rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*lhs).B) * ((*lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((*rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*lhs).G) * ((*lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((*rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*lhs).R) * ((*lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { if (((*rhs).B) == 255) { fB = 255; } else { { int i = (255 - ((*rhs).B)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fB = (int)(((((*lhs).B) * ((*lhs).B) * M) + A) >> (int)S); }; fB = Math.Min (255' fB); } }; { if (((*rhs).G) == 255) { fG = 255; } else { { int i = (255 - ((*rhs).G)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fG = (int)(((((*lhs).G) * ((*lhs).G) * M) + A) >> (int)S); }; fG = Math.Min (255' fG); } }; { if (((*rhs).R) == 255) { fR = 255; } else { { int i = (255 - ((*rhs).R)) * 3; uint M = masTable[i]; uint A = masTable[i + 1]; uint S = masTable[i + 2]; fR = (int)(((((*lhs).R) * ((*lhs).R) * M) + A) >> (int)S); }; fR = Math.Min (255' fR); } }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,ReflectBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\ReflectBlendOp.cs,ReflectBlendOpWithOpacity,The following statement contains a magic number: if (this.opacity < 0 || this.opacity > 255) { throw new ArgumentOutOfRangeException (); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,Apply,The following statement contains a magic number: { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,Apply,The following statement contains a magic number: { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,Apply,The following statement contains a magic number: { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; }; { { fG = ((((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; }; { { fR = ((((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; }; { { fG = ((((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; }; { { fR = ((((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; }; { { fG = ((((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; }; { { fR = ((((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; }; { { fG = ((((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; }; { { fR = ((((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; }; { { fG = ((((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; }; { { fR = ((((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; }; { { fG = ((((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; }; { { fR = ((((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; }; { { fG = ((((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; }; { { fR = ((((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; }; { { fG = ((((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; }; { { fR = ((((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; }; { { fG = ((((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; }; { { fR = ((((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; }; { { fG = ((((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; }; { { fR = ((((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; }; { { fG = ((((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; }; { { fR = ((((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; }; { { fG = ((((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; }; { { fR = ((((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; }; { { fG = ((((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; }; { { fR = ((((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; }; { { fG = ((((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; }; { { fR = ((((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; }; { { fG = ((((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; }; { { fR = ((((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; }; { { fG = ((((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; }; { { fR = ((((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*dst).B)) * (((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; }; { { fG = ((((*dst).G)) * (((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; }; { { fR = ((((*dst).R)) * (((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*dst).B)) * (((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; }; { { fG = ((((*dst).G)) * (((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; }; { { fR = ((((*dst).R)) * (((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*dst).B)) * (((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; }; { { fG = ((((*dst).G)) * (((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; }; { { fR = ((((*dst).R)) * (((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*dst).B)) * (((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; }; { { fG = ((((*dst).G)) * (((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; }; { { fR = ((((*dst).R)) * (((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*dst).B)) * (((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; }; { { fG = ((((*dst).G)) * (((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; }; { { fR = ((((*dst).R)) * (((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*dst).B)) * (((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; }; { { fG = ((((*dst).G)) * (((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; }; { { fR = ((((*dst).R)) * (((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*dst).B)) * (((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; }; { { fG = ((((*dst).G)) * (((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; }; { { fR = ((((*dst).R)) * (((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*dst).B)) * (((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; }; { { fG = ((((*dst).G)) * (((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; }; { { fR = ((((*dst).R)) * (((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*dst).B)) * (((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; }; { { fG = ((((*dst).G)) * (((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; }; { { fR = ((((*dst).R)) * (((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*dst).B)) * (((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; }; { { fG = ((((*dst).G)) * (((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; }; { { fR = ((((*dst).R)) * (((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*dst).B)) * (((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; }; { { fG = ((((*dst).G)) * (((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; }; { { fR = ((((*dst).R)) * (((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*dst).B)) * (((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; }; { { fG = ((((*dst).G)) * (((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; }; { { fR = ((((*dst).R)) * (((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*dst).B)) * (((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; }; { { fG = ((((*dst).G)) * (((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; }; { { fR = ((((*dst).R)) * (((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*dst).B)) * (((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; }; { { fG = ((((*dst).G)) * (((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; }; { { fR = ((((*dst).R)) * (((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*dst).B)) * (((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; }; { { fG = ((((*dst).G)) * (((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; }; { { fR = ((((*dst).R)) * (((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*dst).B)) * (((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; }; { { fG = ((((*dst).G)) * (((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; }; { { fR = ((((*dst).R)) * (((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*dst).B)) * (((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; }; { { fG = ((((*dst).G)) * (((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; }; { { fR = ((((*dst).R)) * (((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*dst).B)) * (((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; }; { { fG = ((((*dst).G)) * (((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; }; { { fR = ((((*dst).R)) * (((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*dst).B)) * (((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; }; { { fG = ((((*dst).G)) * (((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; }; { { fR = ((((*dst).R)) * (((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*lhs).B)) * (((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; }; { { fG = ((((*lhs).G)) * (((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; }; { { fR = ((((*lhs).R)) * (((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*lhs).B)) * (((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; }; { { fG = ((((*lhs).G)) * (((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; }; { { fR = ((((*lhs).R)) * (((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*lhs).B)) * (((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; }; { { fG = ((((*lhs).G)) * (((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; }; { { fR = ((((*lhs).R)) * (((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*lhs).B)) * (((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; }; { { fG = ((((*lhs).G)) * (((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; }; { { fR = ((((*lhs).R)) * (((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*lhs).B)) * (((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; }; { { fG = ((((*lhs).G)) * (((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; }; { { fR = ((((*lhs).R)) * (((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*lhs).B)) * (((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; }; { { fG = ((((*lhs).G)) * (((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; }; { { fR = ((((*lhs).R)) * (((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*lhs).B)) * (((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; }; { { fG = ((((*lhs).G)) * (((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; }; { { fR = ((((*lhs).R)) * (((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*lhs).B)) * (((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; }; { { fG = ((((*lhs).G)) * (((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; }; { { fR = ((((*lhs).R)) * (((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*lhs).B)) * (((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; }; { { fG = ((((*lhs).G)) * (((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; }; { { fR = ((((*lhs).R)) * (((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*lhs).B)) * (((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; }; { { fG = ((((*lhs).G)) * (((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; }; { { fR = ((((*lhs).R)) * (((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*lhs).B)) * (((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; }; { { fG = ((((*lhs).G)) * (((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; }; { { fR = ((((*lhs).R)) * (((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*lhs).B)) * (((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; }; { { fG = ((((*lhs).G)) * (((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; }; { { fR = ((((*lhs).R)) * (((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*lhs).B)) * (((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; }; { { fG = ((((*lhs).G)) * (((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; }; { { fR = ((((*lhs).R)) * (((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*lhs).B)) * (((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; }; { { fG = ((((*lhs).G)) * (((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; }; { { fR = ((((*lhs).R)) * (((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*lhs).B)) * (((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; }; { { fG = ((((*lhs).G)) * (((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; }; { { fR = ((((*lhs).R)) * (((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*lhs).B)) * (((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; }; { { fG = ((((*lhs).G)) * (((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; }; { { fR = ((((*lhs).R)) * (((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*lhs).B)) * (((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; }; { { fG = ((((*lhs).G)) * (((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; }; { { fR = ((((*lhs).R)) * (((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*lhs).B)) * (((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; }; { { fG = ((((*lhs).G)) * (((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; }; { { fR = ((((*lhs).R)) * (((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*lhs).B)) * (((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; }; { { fG = ((((*lhs).G)) * (((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; }; { { fR = ((((*lhs).R)) * (((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,ApplyStatic,The following statement contains a magic number: { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,ApplyStatic,The following statement contains a magic number: { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,ApplyStatic,The following statement contains a magic number: { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; }; { { fG = ((((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; }; { { fR = ((((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; }; { { fG = ((((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; }; { { fR = ((((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; }; { { fG = ((((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; }; { { fR = ((((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; }; { { fG = ((((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; }; { { fR = ((((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; }; { { fG = ((((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; }; { { fR = ((((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; }; { { fG = ((((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; }; { { fR = ((((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; }; { { fG = ((((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; }; { { fR = ((((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; }; { { fG = ((((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; }; { { fR = ((((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; }; { { fG = ((((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; }; { { fR = ((((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; }; { { fG = ((((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; }; { { fR = ((((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; }; { { fG = ((((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; }; { { fR = ((((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; }; { { fG = ((((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; }; { { fR = ((((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; }; { { fG = ((((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; }; { { fR = ((((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; }; { { fG = ((((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; }; { { fR = ((((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; }; { { fG = ((((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; }; { { fR = ((((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; }; { { fG = ((((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; }; { { fR = ((((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,ApplyOpacity,The following statement contains a magic number: { r = ((r) * (this.opacity) + 0x80); r = ((((r) >> 8) + (r)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,ApplyOpacity,The following statement contains a magic number: { r = ((r) * (this.opacity) + 0x80); r = ((((r) >> 8) + (r)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,Apply,The following statement contains a magic number: { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,Apply,The following statement contains a magic number: { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,Apply,The following statement contains a magic number: { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; }; { { fG = ((((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; }; { { fR = ((((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; }; { { fG = ((((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; }; { { fR = ((((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; }; { { fG = ((((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; }; { { fR = ((((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; }; { { fG = ((((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; }; { { fR = ((((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; }; { { fG = ((((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; }; { { fR = ((((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; }; { { fG = ((((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; }; { { fR = ((((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; }; { { fG = ((((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; }; { { fR = ((((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; }; { { fG = ((((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; }; { { fR = ((((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; }; { { fG = ((((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; }; { { fR = ((((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; }; { { fG = ((((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; }; { { fR = ((((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; }; { { fG = ((((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; }; { { fR = ((((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; }; { { fG = ((((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; }; { { fR = ((((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; }; { { fG = ((((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; }; { { fR = ((((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; }; { { fG = ((((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; }; { { fR = ((((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; }; { { fG = ((((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; }; { { fR = ((((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((lhs).B)) * (((rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; }; { { fG = ((((lhs).G)) * (((rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; }; { { fR = ((((lhs).R)) * (((rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*dst).B)) * (((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; }; { { fG = ((((*dst).G)) * (((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; }; { { fR = ((((*dst).R)) * (((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*dst).B)) * (((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; }; { { fG = ((((*dst).G)) * (((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; }; { { fR = ((((*dst).R)) * (((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*dst).B)) * (((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; }; { { fG = ((((*dst).G)) * (((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; }; { { fR = ((((*dst).R)) * (((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*dst).B)) * (((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; }; { { fG = ((((*dst).G)) * (((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; }; { { fR = ((((*dst).R)) * (((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*dst).B)) * (((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; }; { { fG = ((((*dst).G)) * (((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; }; { { fR = ((((*dst).R)) * (((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*dst).B)) * (((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; }; { { fG = ((((*dst).G)) * (((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; }; { { fR = ((((*dst).R)) * (((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*dst).B)) * (((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; }; { { fG = ((((*dst).G)) * (((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; }; { { fR = ((((*dst).R)) * (((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*dst).B)) * (((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; }; { { fG = ((((*dst).G)) * (((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; }; { { fR = ((((*dst).R)) * (((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*dst).B)) * (((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; }; { { fG = ((((*dst).G)) * (((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; }; { { fR = ((((*dst).R)) * (((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*dst).B)) * (((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; }; { { fG = ((((*dst).G)) * (((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; }; { { fR = ((((*dst).R)) * (((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*dst).B)) * (((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; }; { { fG = ((((*dst).G)) * (((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; }; { { fR = ((((*dst).R)) * (((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*dst).B)) * (((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; }; { { fG = ((((*dst).G)) * (((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; }; { { fR = ((((*dst).R)) * (((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*dst).B)) * (((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; }; { { fG = ((((*dst).G)) * (((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; }; { { fR = ((((*dst).R)) * (((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*dst).B)) * (((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; }; { { fG = ((((*dst).G)) * (((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; }; { { fR = ((((*dst).R)) * (((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*dst).B)) * (((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; }; { { fG = ((((*dst).G)) * (((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; }; { { fR = ((((*dst).R)) * (((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*dst).B)) * (((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; }; { { fG = ((((*dst).G)) * (((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; }; { { fR = ((((*dst).R)) * (((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*dst).B)) * (((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; }; { { fG = ((((*dst).G)) * (((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; }; { { fR = ((((*dst).R)) * (((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*dst).B)) * (((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; }; { { fG = ((((*dst).G)) * (((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; }; { { fR = ((((*dst).R)) * (((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*dst).B)) * (((*src).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; }; { { fG = ((((*dst).G)) * (((*src).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; }; { { fR = ((((*dst).R)) * (((*src).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*lhs).B)) * (((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; }; { { fG = ((((*lhs).G)) * (((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; }; { { fR = ((((*lhs).R)) * (((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*lhs).B)) * (((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; }; { { fG = ((((*lhs).G)) * (((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; }; { { fR = ((((*lhs).R)) * (((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*lhs).B)) * (((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; }; { { fG = ((((*lhs).G)) * (((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; }; { { fR = ((((*lhs).R)) * (((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*lhs).B)) * (((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; }; { { fG = ((((*lhs).G)) * (((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; }; { { fR = ((((*lhs).R)) * (((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*lhs).B)) * (((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; }; { { fG = ((((*lhs).G)) * (((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; }; { { fR = ((((*lhs).R)) * (((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*lhs).B)) * (((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; }; { { fG = ((((*lhs).G)) * (((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; }; { { fR = ((((*lhs).R)) * (((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*lhs).B)) * (((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; }; { { fG = ((((*lhs).G)) * (((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; }; { { fR = ((((*lhs).R)) * (((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*lhs).B)) * (((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; }; { { fG = ((((*lhs).G)) * (((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; }; { { fR = ((((*lhs).R)) * (((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*lhs).B)) * (((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; }; { { fG = ((((*lhs).G)) * (((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; }; { { fR = ((((*lhs).R)) * (((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*lhs).B)) * (((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; }; { { fG = ((((*lhs).G)) * (((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; }; { { fR = ((((*lhs).R)) * (((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*lhs).B)) * (((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; }; { { fG = ((((*lhs).G)) * (((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; }; { { fR = ((((*lhs).R)) * (((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*lhs).B)) * (((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; }; { { fG = ((((*lhs).G)) * (((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; }; { { fR = ((((*lhs).R)) * (((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*lhs).B)) * (((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; }; { { fG = ((((*lhs).G)) * (((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; }; { { fR = ((((*lhs).R)) * (((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*lhs).B)) * (((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; }; { { fG = ((((*lhs).G)) * (((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; }; { { fR = ((((*lhs).R)) * (((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*lhs).B)) * (((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; }; { { fG = ((((*lhs).G)) * (((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; }; { { fR = ((((*lhs).R)) * (((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*lhs).B)) * (((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; }; { { fG = ((((*lhs).G)) * (((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; }; { { fR = ((((*lhs).R)) * (((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*lhs).B)) * (((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; }; { { fG = ((((*lhs).G)) * (((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; }; { { fR = ((((*lhs).R)) * (((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*lhs).B)) * (((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; }; { { fG = ((((*lhs).G)) * (((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; }; { { fR = ((((*lhs).R)) * (((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { { fB = ((((*lhs).B)) * (((*rhs).B)) + 0x80); fB = ((((fB) >> 8) + (fB)) >> 8); }; }; { { fG = ((((*lhs).G)) * (((*rhs).G)) + 0x80); fG = ((((fG) >> 8) + (fG)) >> 8); }; }; { { fR = ((((*lhs).R)) * (((*rhs).R)) + 0x80); fR = ((((fR) >> 8) + (fR)) >> 8); }; }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,MultiplyBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\MultiplyBlendOp.cs,MultiplyBlendOpWithOpacity,The following statement contains a magic number: if (this.opacity < 0 || this.opacity > 255) { throw new ArgumentOutOfRangeException (); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,XorBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\XorBlendOp.cs,Apply,The following statement contains a magic number: { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,XorBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\XorBlendOp.cs,Apply,The following statement contains a magic number: { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,XorBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\XorBlendOp.cs,Apply,The following statement contains a magic number: { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,XorBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\XorBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (((lhs).B) ^ ((rhs).B)); }; { fG = (((lhs).G) ^ ((rhs).G)); }; { fR = (((lhs).R) ^ ((rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,XorBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\XorBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (((lhs).B) ^ ((rhs).B)); }; { fG = (((lhs).G) ^ ((rhs).G)); }; { fR = (((lhs).R) ^ ((rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,XorBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\XorBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (((lhs).B) ^ ((rhs).B)); }; { fG = (((lhs).G) ^ ((rhs).G)); }; { fR = (((lhs).R) ^ ((rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,XorBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\XorBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (((lhs).B) ^ ((rhs).B)); }; { fG = (((lhs).G) ^ ((rhs).G)); }; { fR = (((lhs).R) ^ ((rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,XorBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\XorBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (((lhs).B) ^ ((rhs).B)); }; { fG = (((lhs).G) ^ ((rhs).G)); }; { fR = (((lhs).R) ^ ((rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,XorBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\XorBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (((lhs).B) ^ ((rhs).B)); }; { fG = (((lhs).G) ^ ((rhs).G)); }; { fR = (((lhs).R) ^ ((rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,XorBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\XorBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (((lhs).B) ^ ((rhs).B)); }; { fG = (((lhs).G) ^ ((rhs).G)); }; { fR = (((lhs).R) ^ ((rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,XorBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\XorBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (((lhs).B) ^ ((rhs).B)); }; { fG = (((lhs).G) ^ ((rhs).G)); }; { fR = (((lhs).R) ^ ((rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,XorBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\XorBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (((lhs).B) ^ ((rhs).B)); }; { fG = (((lhs).G) ^ ((rhs).G)); }; { fR = (((lhs).R) ^ ((rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,XorBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\XorBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (((lhs).B) ^ ((rhs).B)); }; { fG = (((lhs).G) ^ ((rhs).G)); }; { fR = (((lhs).R) ^ ((rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,XorBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\XorBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (((*dst).B) ^ ((*src).B)); }; { fG = (((*dst).G) ^ ((*src).G)); }; { fR = (((*dst).R) ^ ((*src).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,XorBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\XorBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (((*dst).B) ^ ((*src).B)); }; { fG = (((*dst).G) ^ ((*src).G)); }; { fR = (((*dst).R) ^ ((*src).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,XorBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\XorBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (((*dst).B) ^ ((*src).B)); }; { fG = (((*dst).G) ^ ((*src).G)); }; { fR = (((*dst).R) ^ ((*src).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,XorBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\XorBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (((*dst).B) ^ ((*src).B)); }; { fG = (((*dst).G) ^ ((*src).G)); }; { fR = (((*dst).R) ^ ((*src).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,XorBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\XorBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (((*dst).B) ^ ((*src).B)); }; { fG = (((*dst).G) ^ ((*src).G)); }; { fR = (((*dst).R) ^ ((*src).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,XorBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\XorBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (((*dst).B) ^ ((*src).B)); }; { fG = (((*dst).G) ^ ((*src).G)); }; { fR = (((*dst).R) ^ ((*src).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,XorBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\XorBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (((*dst).B) ^ ((*src).B)); }; { fG = (((*dst).G) ^ ((*src).G)); }; { fR = (((*dst).R) ^ ((*src).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,XorBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\XorBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (((*dst).B) ^ ((*src).B)); }; { fG = (((*dst).G) ^ ((*src).G)); }; { fR = (((*dst).R) ^ ((*src).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,XorBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\XorBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (((*dst).B) ^ ((*src).B)); }; { fG = (((*dst).G) ^ ((*src).G)); }; { fR = (((*dst).R) ^ ((*src).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,XorBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\XorBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (((*dst).B) ^ ((*src).B)); }; { fG = (((*dst).G) ^ ((*src).G)); }; { fR = (((*dst).R) ^ ((*src).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,XorBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\XorBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (((*dst).B) ^ ((*src).B)); }; { fG = (((*dst).G) ^ ((*src).G)); }; { fR = (((*dst).R) ^ ((*src).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,XorBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\XorBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (((*dst).B) ^ ((*src).B)); }; { fG = (((*dst).G) ^ ((*src).G)); }; { fR = (((*dst).R) ^ ((*src).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,XorBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\XorBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (((*dst).B) ^ ((*src).B)); }; { fG = (((*dst).G) ^ ((*src).G)); }; { fR = (((*dst).R) ^ ((*src).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,XorBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\XorBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (((*lhs).B) ^ ((*rhs).B)); }; { fG = (((*lhs).G) ^ ((*rhs).G)); }; { fR = (((*lhs).R) ^ ((*rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,XorBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\XorBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (((*lhs).B) ^ ((*rhs).B)); }; { fG = (((*lhs).G) ^ ((*rhs).G)); }; { fR = (((*lhs).R) ^ ((*rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,XorBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\XorBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (((*lhs).B) ^ ((*rhs).B)); }; { fG = (((*lhs).G) ^ ((*rhs).G)); }; { fR = (((*lhs).R) ^ ((*rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,XorBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\XorBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (((*lhs).B) ^ ((*rhs).B)); }; { fG = (((*lhs).G) ^ ((*rhs).G)); }; { fR = (((*lhs).R) ^ ((*rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,XorBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\XorBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (((*lhs).B) ^ ((*rhs).B)); }; { fG = (((*lhs).G) ^ ((*rhs).G)); }; { fR = (((*lhs).R) ^ ((*rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,XorBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\XorBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (((*lhs).B) ^ ((*rhs).B)); }; { fG = (((*lhs).G) ^ ((*rhs).G)); }; { fR = (((*lhs).R) ^ ((*rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,XorBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\XorBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (((*lhs).B) ^ ((*rhs).B)); }; { fG = (((*lhs).G) ^ ((*rhs).G)); }; { fR = (((*lhs).R) ^ ((*rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,XorBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\XorBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (((*lhs).B) ^ ((*rhs).B)); }; { fG = (((*lhs).G) ^ ((*rhs).G)); }; { fR = (((*lhs).R) ^ ((*rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,XorBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\XorBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (((*lhs).B) ^ ((*rhs).B)); }; { fG = (((*lhs).G) ^ ((*rhs).G)); }; { fR = (((*lhs).R) ^ ((*rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,XorBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\XorBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (((*lhs).B) ^ ((*rhs).B)); }; { fG = (((*lhs).G) ^ ((*rhs).G)); }; { fR = (((*lhs).R) ^ ((*rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,XorBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\XorBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (((*lhs).B) ^ ((*rhs).B)); }; { fG = (((*lhs).G) ^ ((*rhs).G)); }; { fR = (((*lhs).R) ^ ((*rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,XorBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\XorBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (((*lhs).B) ^ ((*rhs).B)); }; { fG = (((*lhs).G) ^ ((*rhs).G)); }; { fR = (((*lhs).R) ^ ((*rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,XorBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\XorBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (((*lhs).B) ^ ((*rhs).B)); }; { fG = (((*lhs).G) ^ ((*rhs).G)); }; { fR = (((*lhs).R) ^ ((*rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,XorBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\XorBlendOp.cs,ApplyStatic,The following statement contains a magic number: { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,XorBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\XorBlendOp.cs,ApplyStatic,The following statement contains a magic number: { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,XorBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\XorBlendOp.cs,ApplyStatic,The following statement contains a magic number: { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,XorBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\XorBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (((lhs).B) ^ ((rhs).B)); }; { fG = (((lhs).G) ^ ((rhs).G)); }; { fR = (((lhs).R) ^ ((rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,XorBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\XorBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (((lhs).B) ^ ((rhs).B)); }; { fG = (((lhs).G) ^ ((rhs).G)); }; { fR = (((lhs).R) ^ ((rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,XorBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\XorBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (((lhs).B) ^ ((rhs).B)); }; { fG = (((lhs).G) ^ ((rhs).G)); }; { fR = (((lhs).R) ^ ((rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,XorBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\XorBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (((lhs).B) ^ ((rhs).B)); }; { fG = (((lhs).G) ^ ((rhs).G)); }; { fR = (((lhs).R) ^ ((rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,XorBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\XorBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (((lhs).B) ^ ((rhs).B)); }; { fG = (((lhs).G) ^ ((rhs).G)); }; { fR = (((lhs).R) ^ ((rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,XorBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\XorBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (((lhs).B) ^ ((rhs).B)); }; { fG = (((lhs).G) ^ ((rhs).G)); }; { fR = (((lhs).R) ^ ((rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,XorBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\XorBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (((lhs).B) ^ ((rhs).B)); }; { fG = (((lhs).G) ^ ((rhs).G)); }; { fR = (((lhs).R) ^ ((rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,XorBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\XorBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (((lhs).B) ^ ((rhs).B)); }; { fG = (((lhs).G) ^ ((rhs).G)); }; { fR = (((lhs).R) ^ ((rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,XorBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\XorBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (((lhs).B) ^ ((rhs).B)); }; { fG = (((lhs).G) ^ ((rhs).G)); }; { fR = (((lhs).R) ^ ((rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,XorBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\XorBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (((lhs).B) ^ ((rhs).B)); }; { fG = (((lhs).G) ^ ((rhs).G)); }; { fR = (((lhs).R) ^ ((rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,XorBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\XorBlendOp.cs,ApplyOpacity,The following statement contains a magic number: { r = ((r) * (this.opacity) + 0x80); r = ((((r) >> 8) + (r)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,XorBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\XorBlendOp.cs,ApplyOpacity,The following statement contains a magic number: { r = ((r) * (this.opacity) + 0x80); r = ((((r) >> 8) + (r)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,XorBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\XorBlendOp.cs,Apply,The following statement contains a magic number: { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,XorBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\XorBlendOp.cs,Apply,The following statement contains a magic number: { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,XorBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\XorBlendOp.cs,Apply,The following statement contains a magic number: { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,XorBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\XorBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (((lhs).B) ^ ((rhs).B)); }; { fG = (((lhs).G) ^ ((rhs).G)); }; { fR = (((lhs).R) ^ ((rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,XorBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\XorBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (((lhs).B) ^ ((rhs).B)); }; { fG = (((lhs).G) ^ ((rhs).G)); }; { fR = (((lhs).R) ^ ((rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,XorBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\XorBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (((lhs).B) ^ ((rhs).B)); }; { fG = (((lhs).G) ^ ((rhs).G)); }; { fR = (((lhs).R) ^ ((rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,XorBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\XorBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (((lhs).B) ^ ((rhs).B)); }; { fG = (((lhs).G) ^ ((rhs).G)); }; { fR = (((lhs).R) ^ ((rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,XorBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\XorBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (((lhs).B) ^ ((rhs).B)); }; { fG = (((lhs).G) ^ ((rhs).G)); }; { fR = (((lhs).R) ^ ((rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,XorBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\XorBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (((lhs).B) ^ ((rhs).B)); }; { fG = (((lhs).G) ^ ((rhs).G)); }; { fR = (((lhs).R) ^ ((rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,XorBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\XorBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (((lhs).B) ^ ((rhs).B)); }; { fG = (((lhs).G) ^ ((rhs).G)); }; { fR = (((lhs).R) ^ ((rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,XorBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\XorBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (((lhs).B) ^ ((rhs).B)); }; { fG = (((lhs).G) ^ ((rhs).G)); }; { fR = (((lhs).R) ^ ((rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,XorBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\XorBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (((lhs).B) ^ ((rhs).B)); }; { fG = (((lhs).G) ^ ((rhs).G)); }; { fR = (((lhs).R) ^ ((rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,XorBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\XorBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (((lhs).B) ^ ((rhs).B)); }; { fG = (((lhs).G) ^ ((rhs).G)); }; { fR = (((lhs).R) ^ ((rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,XorBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\XorBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (((*dst).B) ^ ((*src).B)); }; { fG = (((*dst).G) ^ ((*src).G)); }; { fR = (((*dst).R) ^ ((*src).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,XorBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\XorBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (((*dst).B) ^ ((*src).B)); }; { fG = (((*dst).G) ^ ((*src).G)); }; { fR = (((*dst).R) ^ ((*src).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,XorBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\XorBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (((*dst).B) ^ ((*src).B)); }; { fG = (((*dst).G) ^ ((*src).G)); }; { fR = (((*dst).R) ^ ((*src).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,XorBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\XorBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (((*dst).B) ^ ((*src).B)); }; { fG = (((*dst).G) ^ ((*src).G)); }; { fR = (((*dst).R) ^ ((*src).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,XorBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\XorBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (((*dst).B) ^ ((*src).B)); }; { fG = (((*dst).G) ^ ((*src).G)); }; { fR = (((*dst).R) ^ ((*src).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,XorBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\XorBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (((*dst).B) ^ ((*src).B)); }; { fG = (((*dst).G) ^ ((*src).G)); }; { fR = (((*dst).R) ^ ((*src).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,XorBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\XorBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (((*dst).B) ^ ((*src).B)); }; { fG = (((*dst).G) ^ ((*src).G)); }; { fR = (((*dst).R) ^ ((*src).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,XorBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\XorBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (((*dst).B) ^ ((*src).B)); }; { fG = (((*dst).G) ^ ((*src).G)); }; { fR = (((*dst).R) ^ ((*src).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,XorBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\XorBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (((*dst).B) ^ ((*src).B)); }; { fG = (((*dst).G) ^ ((*src).G)); }; { fR = (((*dst).R) ^ ((*src).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,XorBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\XorBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (((*dst).B) ^ ((*src).B)); }; { fG = (((*dst).G) ^ ((*src).G)); }; { fR = (((*dst).R) ^ ((*src).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,XorBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\XorBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (((*dst).B) ^ ((*src).B)); }; { fG = (((*dst).G) ^ ((*src).G)); }; { fR = (((*dst).R) ^ ((*src).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,XorBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\XorBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (((*dst).B) ^ ((*src).B)); }; { fG = (((*dst).G) ^ ((*src).G)); }; { fR = (((*dst).R) ^ ((*src).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,XorBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\XorBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (((*dst).B) ^ ((*src).B)); }; { fG = (((*dst).G) ^ ((*src).G)); }; { fR = (((*dst).R) ^ ((*src).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,XorBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\XorBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (((*lhs).B) ^ ((*rhs).B)); }; { fG = (((*lhs).G) ^ ((*rhs).G)); }; { fR = (((*lhs).R) ^ ((*rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,XorBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\XorBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (((*lhs).B) ^ ((*rhs).B)); }; { fG = (((*lhs).G) ^ ((*rhs).G)); }; { fR = (((*lhs).R) ^ ((*rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,XorBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\XorBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (((*lhs).B) ^ ((*rhs).B)); }; { fG = (((*lhs).G) ^ ((*rhs).G)); }; { fR = (((*lhs).R) ^ ((*rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,XorBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\XorBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (((*lhs).B) ^ ((*rhs).B)); }; { fG = (((*lhs).G) ^ ((*rhs).G)); }; { fR = (((*lhs).R) ^ ((*rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,XorBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\XorBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (((*lhs).B) ^ ((*rhs).B)); }; { fG = (((*lhs).G) ^ ((*rhs).G)); }; { fR = (((*lhs).R) ^ ((*rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,XorBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\XorBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (((*lhs).B) ^ ((*rhs).B)); }; { fG = (((*lhs).G) ^ ((*rhs).G)); }; { fR = (((*lhs).R) ^ ((*rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,XorBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\XorBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (((*lhs).B) ^ ((*rhs).B)); }; { fG = (((*lhs).G) ^ ((*rhs).G)); }; { fR = (((*lhs).R) ^ ((*rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,XorBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\XorBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (((*lhs).B) ^ ((*rhs).B)); }; { fG = (((*lhs).G) ^ ((*rhs).G)); }; { fR = (((*lhs).R) ^ ((*rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,XorBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\XorBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (((*lhs).B) ^ ((*rhs).B)); }; { fG = (((*lhs).G) ^ ((*rhs).G)); }; { fR = (((*lhs).R) ^ ((*rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,XorBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\XorBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (((*lhs).B) ^ ((*rhs).B)); }; { fG = (((*lhs).G) ^ ((*rhs).G)); }; { fR = (((*lhs).R) ^ ((*rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,XorBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\XorBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (((*lhs).B) ^ ((*rhs).B)); }; { fG = (((*lhs).G) ^ ((*rhs).G)); }; { fR = (((*lhs).R) ^ ((*rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,XorBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\XorBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (((*lhs).B) ^ ((*rhs).B)); }; { fG = (((*lhs).G) ^ ((*rhs).G)); }; { fR = (((*lhs).R) ^ ((*rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,XorBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\XorBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = (((*lhs).B) ^ ((*rhs).B)); }; { fG = (((*lhs).G) ^ ((*rhs).G)); }; { fR = (((*lhs).R) ^ ((*rhs).R)); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,XorBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\XorBlendOp.cs,XorBlendOpWithOpacity,The following statement contains a magic number: if (this.opacity < 0 || this.opacity > 255) { throw new ArgumentOutOfRangeException (); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NormalBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NormalBlendOp.cs,Apply,The following statement contains a magic number: int y = lhsA * (255 - rhsA) + 0x80;
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NormalBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NormalBlendOp.cs,Apply,The following statement contains a magic number: y = ((y >> 8) + y) >> 8;
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NormalBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NormalBlendOp.cs,Apply,The following statement contains a magic number: y = ((y >> 8) + y) >> 8;
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NormalBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NormalBlendOp.cs,Apply,The following statement contains a magic number: x = ((x >> 8) + x) >> 8;
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NormalBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NormalBlendOp.cs,Apply,The following statement contains a magic number: x = ((x >> 8) + x) >> 8;
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NormalBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NormalBlendOp.cs,Apply,The following statement contains a magic number: int masIndex = totalA * 3;
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NormalBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NormalBlendOp.cs,Apply,The following statement contains a magic number: uint taS = masTable[masIndex + 2];
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NormalBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NormalBlendOp.cs,Apply,The following statement contains a magic number: int a = (lhsA * (255 - rhsA) + 0x80);
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NormalBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NormalBlendOp.cs,Apply,The following statement contains a magic number: a = (((a >> 8) + a) >> 8);
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NormalBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NormalBlendOp.cs,Apply,The following statement contains a magic number: a = (((a >> 8) + a) >> 8);
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NormalBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NormalBlendOp.cs,Apply,The following statement contains a magic number: ret = b + (g << 8) + (r << 16) + ((uint)a << 24);
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NormalBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NormalBlendOp.cs,Apply,The following statement contains a magic number: ret = b + (g << 8) + (r << 16) + ((uint)a << 24);
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NormalBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NormalBlendOp.cs,Apply,The following statement contains a magic number: ret = b + (g << 8) + (r << 16) + ((uint)a << 24);
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NormalBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NormalBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) {  				int lhsA; { lhsA = ((*dst).A); };  				int rhsA; { rhsA = ((*src).A); };  				int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = ((*src).B); }; { fG = ((*src).G); }; { fR = ((*src).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length;  			}
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NormalBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NormalBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) {  				int lhsA; { lhsA = ((*dst).A); };  				int rhsA; { rhsA = ((*src).A); };  				int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = ((*src).B); }; { fG = ((*src).G); }; { fR = ((*src).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length;  			}
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NormalBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NormalBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) {  				int lhsA; { lhsA = ((*dst).A); };  				int rhsA; { rhsA = ((*src).A); };  				int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = ((*src).B); }; { fG = ((*src).G); }; { fR = ((*src).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length;  			}
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NormalBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NormalBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) {  				int lhsA; { lhsA = ((*dst).A); };  				int rhsA; { rhsA = ((*src).A); };  				int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = ((*src).B); }; { fG = ((*src).G); }; { fR = ((*src).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length;  			}
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NormalBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NormalBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) {  				int lhsA; { lhsA = ((*dst).A); };  				int rhsA; { rhsA = ((*src).A); };  				int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = ((*src).B); }; { fG = ((*src).G); }; { fR = ((*src).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length;  			}
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NormalBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NormalBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) {  				int lhsA; { lhsA = ((*dst).A); };  				int rhsA; { rhsA = ((*src).A); };  				int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = ((*src).B); }; { fG = ((*src).G); }; { fR = ((*src).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length;  			}
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NormalBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NormalBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) {  				int lhsA; { lhsA = ((*dst).A); };  				int rhsA; { rhsA = ((*src).A); };  				int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = ((*src).B); }; { fG = ((*src).G); }; { fR = ((*src).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length;  			}
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NormalBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NormalBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) {  				int lhsA; { lhsA = ((*dst).A); };  				int rhsA; { rhsA = ((*src).A); };  				int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = ((*src).B); }; { fG = ((*src).G); }; { fR = ((*src).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length;  			}
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NormalBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NormalBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) {  				int lhsA; { lhsA = ((*dst).A); };  				int rhsA; { rhsA = ((*src).A); };  				int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = ((*src).B); }; { fG = ((*src).G); }; { fR = ((*src).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length;  			}
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NormalBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NormalBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) {  				int lhsA; { lhsA = ((*dst).A); };  				int rhsA; { rhsA = ((*src).A); };  				int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = ((*src).B); }; { fG = ((*src).G); }; { fR = ((*src).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length;  			}
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NormalBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NormalBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) {  				int lhsA; { lhsA = ((*dst).A); };  				int rhsA; { rhsA = ((*src).A); };  				int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = ((*src).B); }; { fG = ((*src).G); }; { fR = ((*src).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length;  			}
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NormalBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NormalBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) {  				int lhsA; { lhsA = ((*dst).A); };  				int rhsA; { rhsA = ((*src).A); };  				int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = ((*src).B); }; { fG = ((*src).G); }; { fR = ((*src).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length;  			}
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NormalBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NormalBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) {  				int lhsA; { lhsA = ((*dst).A); };  				int rhsA; { rhsA = ((*src).A); };  				int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = ((*src).B); }; { fG = ((*src).G); }; { fR = ((*src).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length;  			}
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NormalBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NormalBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = ((*rhs).B); }; { fG = ((*rhs).G); }; { fR = ((*rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NormalBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NormalBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = ((*rhs).B); }; { fG = ((*rhs).G); }; { fR = ((*rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NormalBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NormalBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = ((*rhs).B); }; { fG = ((*rhs).G); }; { fR = ((*rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NormalBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NormalBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = ((*rhs).B); }; { fG = ((*rhs).G); }; { fR = ((*rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NormalBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NormalBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = ((*rhs).B); }; { fG = ((*rhs).G); }; { fR = ((*rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NormalBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NormalBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = ((*rhs).B); }; { fG = ((*rhs).G); }; { fR = ((*rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NormalBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NormalBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = ((*rhs).B); }; { fG = ((*rhs).G); }; { fR = ((*rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NormalBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NormalBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = ((*rhs).B); }; { fG = ((*rhs).G); }; { fR = ((*rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NormalBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NormalBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = ((*rhs).B); }; { fG = ((*rhs).G); }; { fR = ((*rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NormalBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NormalBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = ((*rhs).B); }; { fG = ((*rhs).G); }; { fR = ((*rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NormalBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NormalBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = ((*rhs).B); }; { fG = ((*rhs).G); }; { fR = ((*rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NormalBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NormalBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = ((*rhs).B); }; { fG = ((*rhs).G); }; { fR = ((*rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NormalBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NormalBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = ((*rhs).B); }; { fG = ((*rhs).G); }; { fR = ((*rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NormalBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NormalBlendOp.cs,ApplyStatic,The following statement contains a magic number: { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NormalBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NormalBlendOp.cs,ApplyStatic,The following statement contains a magic number: { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NormalBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NormalBlendOp.cs,ApplyStatic,The following statement contains a magic number: { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NormalBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NormalBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = ((rhs).B); }; { fG = ((rhs).G); }; { fR = ((rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NormalBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NormalBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = ((rhs).B); }; { fG = ((rhs).G); }; { fR = ((rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NormalBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NormalBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = ((rhs).B); }; { fG = ((rhs).G); }; { fR = ((rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NormalBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NormalBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = ((rhs).B); }; { fG = ((rhs).G); }; { fR = ((rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NormalBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NormalBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = ((rhs).B); }; { fG = ((rhs).G); }; { fR = ((rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NormalBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NormalBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = ((rhs).B); }; { fG = ((rhs).G); }; { fR = ((rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NormalBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NormalBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = ((rhs).B); }; { fG = ((rhs).G); }; { fR = ((rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NormalBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NormalBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = ((rhs).B); }; { fG = ((rhs).G); }; { fR = ((rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NormalBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NormalBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = ((rhs).B); }; { fG = ((rhs).G); }; { fR = ((rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NormalBlendOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NormalBlendOp.cs,ApplyStatic,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = ((rhs).B); }; { fG = ((rhs).G); }; { fR = ((rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NormalBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NormalBlendOp.cs,ApplyOpacity,The following statement contains a magic number: { r = ((r) * (this.opacity) + 0x80); r = ((((r) >> 8) + (r)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NormalBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NormalBlendOp.cs,ApplyOpacity,The following statement contains a magic number: { r = ((r) * (this.opacity) + 0x80); r = ((((r) >> 8) + (r)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NormalBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NormalBlendOp.cs,Apply,The following statement contains a magic number: { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NormalBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NormalBlendOp.cs,Apply,The following statement contains a magic number: { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NormalBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NormalBlendOp.cs,Apply,The following statement contains a magic number: { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NormalBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NormalBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = ((rhs).B); }; { fG = ((rhs).G); }; { fR = ((rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NormalBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NormalBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = ((rhs).B); }; { fG = ((rhs).G); }; { fR = ((rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NormalBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NormalBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = ((rhs).B); }; { fG = ((rhs).G); }; { fR = ((rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NormalBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NormalBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = ((rhs).B); }; { fG = ((rhs).G); }; { fR = ((rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NormalBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NormalBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = ((rhs).B); }; { fG = ((rhs).G); }; { fR = ((rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NormalBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NormalBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = ((rhs).B); }; { fG = ((rhs).G); }; { fR = ((rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NormalBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NormalBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = ((rhs).B); }; { fG = ((rhs).G); }; { fR = ((rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NormalBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NormalBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = ((rhs).B); }; { fG = ((rhs).G); }; { fR = ((rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NormalBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NormalBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = ((rhs).B); }; { fG = ((rhs).G); }; { fR = ((rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NormalBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NormalBlendOp.cs,Apply,The following statement contains a magic number: if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = ((rhs).B); }; { fG = ((rhs).G); }; { fR = ((rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((lhs).B * y) + ((rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((lhs).G * y) + ((rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((lhs).R * y) + ((rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NormalBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NormalBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = ((*src).B); }; { fG = ((*src).G); }; { fR = ((*src).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NormalBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NormalBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = ((*src).B); }; { fG = ((*src).G); }; { fR = ((*src).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NormalBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NormalBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = ((*src).B); }; { fG = ((*src).G); }; { fR = ((*src).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NormalBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NormalBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = ((*src).B); }; { fG = ((*src).G); }; { fR = ((*src).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NormalBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NormalBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = ((*src).B); }; { fG = ((*src).G); }; { fR = ((*src).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NormalBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NormalBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = ((*src).B); }; { fG = ((*src).G); }; { fR = ((*src).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NormalBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NormalBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = ((*src).B); }; { fG = ((*src).G); }; { fR = ((*src).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NormalBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NormalBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = ((*src).B); }; { fG = ((*src).G); }; { fR = ((*src).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NormalBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NormalBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = ((*src).B); }; { fG = ((*src).G); }; { fR = ((*src).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NormalBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NormalBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = ((*src).B); }; { fG = ((*src).G); }; { fR = ((*src).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NormalBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NormalBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = ((*src).B); }; { fG = ((*src).G); }; { fR = ((*src).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NormalBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NormalBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = ((*src).B); }; { fG = ((*src).G); }; { fR = ((*src).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NormalBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NormalBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*dst).A); }; int rhsA; { rhsA = ApplyOpacity ((*src).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = ((*src).B); }; { fG = ((*src).G); }; { fR = ((*src).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*dst).B * y) + ((*src).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*dst).G * y) + ((*src).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*dst).R * y) + ((*src).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++src; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NormalBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NormalBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = ((*rhs).B); }; { fG = ((*rhs).G); }; { fR = ((*rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NormalBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NormalBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = ((*rhs).B); }; { fG = ((*rhs).G); }; { fR = ((*rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NormalBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NormalBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = ((*rhs).B); }; { fG = ((*rhs).G); }; { fR = ((*rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NormalBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NormalBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = ((*rhs).B); }; { fG = ((*rhs).G); }; { fR = ((*rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NormalBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NormalBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = ((*rhs).B); }; { fG = ((*rhs).G); }; { fR = ((*rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NormalBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NormalBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = ((*rhs).B); }; { fG = ((*rhs).G); }; { fR = ((*rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NormalBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NormalBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = ((*rhs).B); }; { fG = ((*rhs).G); }; { fR = ((*rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NormalBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NormalBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = ((*rhs).B); }; { fG = ((*rhs).G); }; { fR = ((*rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NormalBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NormalBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = ((*rhs).B); }; { fG = ((*rhs).G); }; { fR = ((*rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NormalBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NormalBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = ((*rhs).B); }; { fG = ((*rhs).G); }; { fR = ((*rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NormalBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NormalBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = ((*rhs).B); }; { fG = ((*rhs).G); }; { fR = ((*rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NormalBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NormalBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = ((*rhs).B); }; { fG = ((*rhs).G); }; { fR = ((*rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NormalBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NormalBlendOp.cs,Apply,The following statement contains a magic number: while (length > 0) { int lhsA; { lhsA = ((*lhs).A); }; int rhsA; { rhsA = ApplyOpacity ((*rhs).A); }; int y; { y = ((lhsA) * (255 - rhsA) + 0x80); y = ((((y) >> 8) + (y)) >> 8); }; int totalA = y + rhsA; uint ret; if (totalA == 0) { ret = 0; } else { int fB; int fG; int fR; { fB = ((*rhs).B); }; { fG = ((*rhs).G); }; { fR = ((*rhs).R); }; int x; { x = ((lhsA) * (rhsA) + 0x80); x = ((((x) >> 8) + (x)) >> 8); }; int z = rhsA - x; int masIndex = totalA * 3; uint taM = masTable[masIndex]; uint taA = masTable[masIndex + 1]; uint taS = masTable[masIndex + 2]; uint b = (uint)(((((long)((((*lhs).B * y) + ((*rhs).B * z) + (fB * x)))) * taM) + taA) >> (int)taS); uint g = (uint)(((((long)((((*lhs).G * y) + ((*rhs).G * z) + (fG * x)))) * taM) + taA) >> (int)taS); uint r = (uint)(((((long)((((*lhs).R * y) + ((*rhs).R * z) + (fR * x)))) * taM) + taA) >> (int)taS); int a; { { a = ((lhsA) * (255 - (rhsA)) + 0x80); a = ((((a) >> 8) + (a)) >> 8); }; a += (rhsA); }; ret = b + (g << 8) + (r << 16) + ((uint)a << 24); }; dst->Bgra = ret; ++dst; ++lhs; ++rhs; --length; }
Magic Number,Pinta.ImageManipulation.PixelBlendOperations,NormalBlendOpWithOpacity,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\PixelBlendOperations\NormalBlendOp.cs,NormalBlendOpWithOpacity,The following statement contains a magic number: if (this.opacity < 0 || this.opacity > 255) { throw new ArgumentOutOfRangeException (); }
Magic Number,Pinta.ImageManipulation.UnaryPixelOperations,BlendConstantOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\UnaryPixelOperations\BlendConstantOp.cs,Apply,The following statement contains a magic number: int invA = 255 - a;
Magic Number,Pinta.ImageManipulation.UnaryPixelOperations,BlendConstantOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\UnaryPixelOperations\BlendConstantOp.cs,Apply,The following statement contains a magic number: int r = ((color.R * invA) + (blend_color.R * a)) / 256;
Magic Number,Pinta.ImageManipulation.UnaryPixelOperations,BlendConstantOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\UnaryPixelOperations\BlendConstantOp.cs,Apply,The following statement contains a magic number: int g = ((color.G * invA) + (blend_color.G * a)) / 256;
Magic Number,Pinta.ImageManipulation.UnaryPixelOperations,BlendConstantOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\UnaryPixelOperations\BlendConstantOp.cs,Apply,The following statement contains a magic number: int b = ((color.B * invA) + (blend_color.B * a)) / 256;
Magic Number,Pinta.ImageManipulation.UnaryPixelOperations,BlendConstantOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\UnaryPixelOperations\BlendConstantOp.cs,ComputeAlpha,The following statement contains a magic number: return (byte)(((la * (256 - (ra + (ra >> 7)))) >> 8) + ra);
Magic Number,Pinta.ImageManipulation.UnaryPixelOperations,BlendConstantOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\UnaryPixelOperations\BlendConstantOp.cs,ComputeAlpha,The following statement contains a magic number: return (byte)(((la * (256 - (ra + (ra >> 7)))) >> 8) + ra);
Magic Number,Pinta.ImageManipulation.UnaryPixelOperations,BlendConstantOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\UnaryPixelOperations\BlendConstantOp.cs,ComputeAlpha,The following statement contains a magic number: return (byte)(((la * (256 - (ra + (ra >> 7)))) >> 8) + ra);
Magic Number,Pinta.ImageManipulation.UnaryPixelOperations,AverageChannelsOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\UnaryPixelOperations\AverageChannelsOp.cs,Apply,The following statement contains a magic number: var average = (byte)(((int)color.R + (int)color.G + (int)color.B) / 3);
Magic Number,Pinta.ImageManipulation.UnaryPixelOperations,ChannelCurveOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\UnaryPixelOperations\ChannelCurveOp.cs,ChannelCurveOp,The following statement contains a magic number: for (int i = 0; i < 256; ++i) {  				CurveB[i] = (byte)i;  				CurveG[i] = (byte)i;  				CurveR[i] = (byte)i;  			}
Magic Number,Pinta.ImageManipulation.UnaryPixelOperations,PosterizePixelOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\UnaryPixelOperations\PosterizePixelOp.cs,CalcLevels,The following statement contains a magic number: for (int i = 1; i < levelCount; i++)  				t1[i] = (byte)((255 * i) / (levelCount - 1));
Magic Number,Pinta.ImageManipulation.UnaryPixelOperations,PosterizePixelOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\UnaryPixelOperations\PosterizePixelOp.cs,CalcLevels,The following statement contains a magic number: var levels = new byte[256];
Magic Number,Pinta.ImageManipulation.UnaryPixelOperations,PosterizePixelOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\UnaryPixelOperations\PosterizePixelOp.cs,CalcLevels,The following statement contains a magic number: for (int i = 0; i < 256; i++) {  				levels[i] = t1[j];    				k += levelCount;    				if (k > 255) {  					k -= 255;  					j++;  				}  			}
Magic Number,Pinta.ImageManipulation.UnaryPixelOperations,PosterizePixelOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\UnaryPixelOperations\PosterizePixelOp.cs,CalcLevels,The following statement contains a magic number: for (int i = 0; i < 256; i++) {  				levels[i] = t1[j];    				k += levelCount;    				if (k > 255) {  					k -= 255;  					j++;  				}  			}
Magic Number,Pinta.ImageManipulation.UnaryPixelOperations,PosterizePixelOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\UnaryPixelOperations\PosterizePixelOp.cs,CalcLevels,The following statement contains a magic number: for (int i = 0; i < 256; i++) {  				levels[i] = t1[j];    				k += levelCount;    				if (k > 255) {  					k -= 255;  					j++;  				}  			}
Magic Number,Pinta.ImageManipulation.UnaryPixelOperations,HueSaturationLightnessOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\UnaryPixelOperations\HueSaturationLightnessOp.cs,HueSaturationLightnessOp,The following statement contains a magic number: sat_factor = (satDelta * 1024) / 100;
Magic Number,Pinta.ImageManipulation.UnaryPixelOperations,HueSaturationLightnessOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\UnaryPixelOperations\HueSaturationLightnessOp.cs,HueSaturationLightnessOp,The following statement contains a magic number: sat_factor = (satDelta * 1024) / 100;
Magic Number,Pinta.ImageManipulation.UnaryPixelOperations,HueSaturationLightnessOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\UnaryPixelOperations\HueSaturationLightnessOp.cs,HueSaturationLightnessOp,The following statement contains a magic number: if (lightness == 0)  				blend_op = new IdentityOp ();  			else if (lightness > 0)  				blend_op = new BlendConstantOp (ColorBgra.FromBgra (255' 255' 255' (byte)((lightness * 255) / 100)));  			else  				blend_op = new BlendConstantOp (ColorBgra.FromBgra (0' 0' 0' (byte)((-lightness * 255) / 100)));
Magic Number,Pinta.ImageManipulation.UnaryPixelOperations,HueSaturationLightnessOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\UnaryPixelOperations\HueSaturationLightnessOp.cs,HueSaturationLightnessOp,The following statement contains a magic number: if (lightness == 0)  				blend_op = new IdentityOp ();  			else if (lightness > 0)  				blend_op = new BlendConstantOp (ColorBgra.FromBgra (255' 255' 255' (byte)((lightness * 255) / 100)));  			else  				blend_op = new BlendConstantOp (ColorBgra.FromBgra (0' 0' 0' (byte)((-lightness * 255) / 100)));
Magic Number,Pinta.ImageManipulation.UnaryPixelOperations,HueSaturationLightnessOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\UnaryPixelOperations\HueSaturationLightnessOp.cs,HueSaturationLightnessOp,The following statement contains a magic number: if (lightness == 0)  				blend_op = new IdentityOp ();  			else if (lightness > 0)  				blend_op = new BlendConstantOp (ColorBgra.FromBgra (255' 255' 255' (byte)((lightness * 255) / 100)));  			else  				blend_op = new BlendConstantOp (ColorBgra.FromBgra (0' 0' 0' (byte)((-lightness * 255) / 100)));
Magic Number,Pinta.ImageManipulation.UnaryPixelOperations,HueSaturationLightnessOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\UnaryPixelOperations\HueSaturationLightnessOp.cs,HueSaturationLightnessOp,The following statement contains a magic number: if (lightness == 0)  				blend_op = new IdentityOp ();  			else if (lightness > 0)  				blend_op = new BlendConstantOp (ColorBgra.FromBgra (255' 255' 255' (byte)((lightness * 255) / 100)));  			else  				blend_op = new BlendConstantOp (ColorBgra.FromBgra (0' 0' 0' (byte)((-lightness * 255) / 100)));
Magic Number,Pinta.ImageManipulation.UnaryPixelOperations,HueSaturationLightnessOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\UnaryPixelOperations\HueSaturationLightnessOp.cs,HueSaturationLightnessOp,The following statement contains a magic number: if (lightness == 0)  				blend_op = new IdentityOp ();  			else if (lightness > 0)  				blend_op = new BlendConstantOp (ColorBgra.FromBgra (255' 255' 255' (byte)((lightness * 255) / 100)));  			else  				blend_op = new BlendConstantOp (ColorBgra.FromBgra (0' 0' 0' (byte)((-lightness * 255) / 100)));
Magic Number,Pinta.ImageManipulation.UnaryPixelOperations,HueSaturationLightnessOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\UnaryPixelOperations\HueSaturationLightnessOp.cs,HueSaturationLightnessOp,The following statement contains a magic number: if (lightness == 0)  				blend_op = new IdentityOp ();  			else if (lightness > 0)  				blend_op = new BlendConstantOp (ColorBgra.FromBgra (255' 255' 255' (byte)((lightness * 255) / 100)));  			else  				blend_op = new BlendConstantOp (ColorBgra.FromBgra (0' 0' 0' (byte)((-lightness * 255) / 100)));
Magic Number,Pinta.ImageManipulation.UnaryPixelOperations,HueSaturationLightnessOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\UnaryPixelOperations\HueSaturationLightnessOp.cs,HueSaturationLightnessOp,The following statement contains a magic number: if (lightness == 0)  				blend_op = new IdentityOp ();  			else if (lightness > 0)  				blend_op = new BlendConstantOp (ColorBgra.FromBgra (255' 255' 255' (byte)((lightness * 255) / 100)));  			else  				blend_op = new BlendConstantOp (ColorBgra.FromBgra (0' 0' 0' (byte)((-lightness * 255) / 100)));
Magic Number,Pinta.ImageManipulation.UnaryPixelOperations,HueSaturationLightnessOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\UnaryPixelOperations\HueSaturationLightnessOp.cs,Apply,The following statement contains a magic number: color.R = Utility.ClampToByte ((intensity * 1024 + (color.R - intensity) * sat_factor) >> 10);
Magic Number,Pinta.ImageManipulation.UnaryPixelOperations,HueSaturationLightnessOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\UnaryPixelOperations\HueSaturationLightnessOp.cs,Apply,The following statement contains a magic number: color.R = Utility.ClampToByte ((intensity * 1024 + (color.R - intensity) * sat_factor) >> 10);
Magic Number,Pinta.ImageManipulation.UnaryPixelOperations,HueSaturationLightnessOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\UnaryPixelOperations\HueSaturationLightnessOp.cs,Apply,The following statement contains a magic number: color.G = Utility.ClampToByte ((intensity * 1024 + (color.G - intensity) * sat_factor) >> 10);
Magic Number,Pinta.ImageManipulation.UnaryPixelOperations,HueSaturationLightnessOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\UnaryPixelOperations\HueSaturationLightnessOp.cs,Apply,The following statement contains a magic number: color.G = Utility.ClampToByte ((intensity * 1024 + (color.G - intensity) * sat_factor) >> 10);
Magic Number,Pinta.ImageManipulation.UnaryPixelOperations,HueSaturationLightnessOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\UnaryPixelOperations\HueSaturationLightnessOp.cs,Apply,The following statement contains a magic number: color.B = Utility.ClampToByte ((intensity * 1024 + (color.B - intensity) * sat_factor) >> 10);
Magic Number,Pinta.ImageManipulation.UnaryPixelOperations,HueSaturationLightnessOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\UnaryPixelOperations\HueSaturationLightnessOp.cs,Apply,The following statement contains a magic number: color.B = Utility.ClampToByte ((intensity * 1024 + (color.B - intensity) * sat_factor) >> 10);
Magic Number,Pinta.ImageManipulation.UnaryPixelOperations,HueSaturationLightnessOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\UnaryPixelOperations\HueSaturationLightnessOp.cs,Apply,The following statement contains a magic number: while (hue < 0)  				hue += 360;
Magic Number,Pinta.ImageManipulation.UnaryPixelOperations,HueSaturationLightnessOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\UnaryPixelOperations\HueSaturationLightnessOp.cs,Apply,The following statement contains a magic number: while (hue > 360)  				hue -= 360;
Magic Number,Pinta.ImageManipulation.UnaryPixelOperations,HueSaturationLightnessOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\UnaryPixelOperations\HueSaturationLightnessOp.cs,Apply,The following statement contains a magic number: while (hue > 360)  				hue -= 360;
Magic Number,Pinta.ImageManipulation.UnaryPixelOperations,LevelOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\UnaryPixelOperations\LevelOp.cs,LevelOp,The following statement contains a magic number: if (gamma.Length != 3)  				throw new ArgumentException ("gamma"' "gamma must be a float[3]");
Magic Number,Pinta.ImageManipulation.UnaryPixelOperations,LevelOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\UnaryPixelOperations\LevelOp.cs,Apply,The following statement contains a magic number: for (int i = 0; i < 3; i++) {  				float v = (input[i] - colorInLow[i]);    				if (v < 0) {  					ret[i] = colorOutLow[i];  				} else if (v + colorInLow[i] >= colorInHigh[i]) {  					ret[i] = colorOutHigh[i];  				} else {  					ret[i] = (byte)Utility.Clamp (  					    colorOutLow[i] + (colorOutHigh[i] - colorOutLow[i]) * Math.Pow (v / (colorInHigh[i] - colorInLow[i])' gamma[i])'  					    0.0f'  					    255.0f);  				}  			}
Magic Number,Pinta.ImageManipulation.UnaryPixelOperations,LevelOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\UnaryPixelOperations\LevelOp.cs,GetGamma,The following statement contains a magic number: if (index < 0 || index >= 3) {  				throw new ArgumentOutOfRangeException ("index"' index' "Index must be between 0 and 2");  			}
Magic Number,Pinta.ImageManipulation.UnaryPixelOperations,LevelOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\UnaryPixelOperations\LevelOp.cs,SetGamma,The following statement contains a magic number: if (index < 0 || index >= 3) {  				throw new ArgumentOutOfRangeException ("index"' index' "Index must be between 0 and 2");  			}
Magic Number,Pinta.ImageManipulation.UnaryPixelOperations,LevelOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\UnaryPixelOperations\LevelOp.cs,AutoFromLoMdHi,The following statement contains a magic number: float[] gamma = new float[3];
Magic Number,Pinta.ImageManipulation.UnaryPixelOperations,LevelOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\UnaryPixelOperations\LevelOp.cs,AutoFromLoMdHi,The following statement contains a magic number: for (int i = 0; i < 3; i++) {  				if (lo[i] < md[i] && md[i] < hi[i]) {  					gamma[i] = (float)Utility.Clamp (Math.Log (0.5' (float)(md[i] - lo[i]) / (float)(hi[i] - lo[i]))' 0.1' 10.0);  				} else {  					gamma[i] = 1.0f;  				}  			}
Magic Number,Pinta.ImageManipulation.UnaryPixelOperations,LevelOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\UnaryPixelOperations\LevelOp.cs,AutoFromLoMdHi,The following statement contains a magic number: for (int i = 0; i < 3; i++) {  				if (lo[i] < md[i] && md[i] < hi[i]) {  					gamma[i] = (float)Utility.Clamp (Math.Log (0.5' (float)(md[i] - lo[i]) / (float)(hi[i] - lo[i]))' 0.1' 10.0);  				} else {  					gamma[i] = 1.0f;  				}  			}
Magic Number,Pinta.ImageManipulation.UnaryPixelOperations,LevelOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\UnaryPixelOperations\LevelOp.cs,AutoFromLoMdHi,The following statement contains a magic number: for (int i = 0; i < 3; i++) {  				if (lo[i] < md[i] && md[i] < hi[i]) {  					gamma[i] = (float)Utility.Clamp (Math.Log (0.5' (float)(md[i] - lo[i]) / (float)(hi[i] - lo[i]))' 0.1' 10.0);  				} else {  					gamma[i] = 1.0f;  				}  			}
Magic Number,Pinta.ImageManipulation.UnaryPixelOperations,LevelOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\UnaryPixelOperations\LevelOp.cs,AutoFromLoMdHi,The following statement contains a magic number: for (int i = 0; i < 3; i++) {  				if (lo[i] < md[i] && md[i] < hi[i]) {  					gamma[i] = (float)Utility.Clamp (Math.Log (0.5' (float)(md[i] - lo[i]) / (float)(hi[i] - lo[i]))' 0.1' 10.0);  				} else {  					gamma[i] = 1.0f;  				}  			}
Magic Number,Pinta.ImageManipulation.UnaryPixelOperations,LevelOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\UnaryPixelOperations\LevelOp.cs,UpdateLookupTable,The following statement contains a magic number: for (int i = 0; i < 3; i++) {  				if (colorOutHigh[i] < colorOutLow[i] ||  				    colorInHigh[i] <= colorInLow[i] ||  				    gamma[i] < 0) {  					isValid = false;  					return;  				}    				for (int j = 0; j < 256; j++) {  					ColorBgra col = Apply (j' j' j);  					CurveB[j] = col.B;  					CurveG[j] = col.G;  					CurveR[j] = col.R;  				}  			}
Magic Number,Pinta.ImageManipulation.UnaryPixelOperations,LevelOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\UnaryPixelOperations\LevelOp.cs,UpdateLookupTable,The following statement contains a magic number: for (int i = 0; i < 3; i++) {  				if (colorOutHigh[i] < colorOutLow[i] ||  				    colorInHigh[i] <= colorInLow[i] ||  				    gamma[i] < 0) {  					isValid = false;  					return;  				}    				for (int j = 0; j < 256; j++) {  					ColorBgra col = Apply (j' j' j);  					CurveB[j] = col.B;  					CurveG[j] = col.G;  					CurveR[j] = col.R;  				}  			}
Magic Number,Pinta.ImageManipulation.UnaryPixelOperations,LevelOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\UnaryPixelOperations\LevelOp.cs,UnApply,The following statement contains a magic number: if (beforeOut.Length != 3) {  				throw new ArgumentException ("before must be a float[3]"' "before");  			}
Magic Number,Pinta.ImageManipulation.UnaryPixelOperations,LevelOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\UnaryPixelOperations\LevelOp.cs,UnApply,The following statement contains a magic number: if (slopesOut.Length != 3) {  				throw new ArgumentException ("slopes must be a float[3]"' "slopes");  			}
Magic Number,Pinta.ImageManipulation.UnaryPixelOperations,LevelOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\UnaryPixelOperations\LevelOp.cs,UnApply,The following statement contains a magic number: for (int i = 0; i < 3; i++) {  				beforeOut[i] = colorInLow[i] + (colorInHigh[i] - colorInLow[i]) *  				    (float)Math.Pow ((float)(after[i] - colorOutLow[i]) / (colorOutHigh[i] - colorOutLow[i])' 1 / gamma[i]);    				slopesOut[i] = (float)(colorInHigh[i] - colorInLow[i]) / ((colorOutHigh[i] - colorOutLow[i]) * gamma[i]) *  				    (float)Math.Pow ((float)(after[i] - colorOutLow[i]) / (colorOutHigh[i] - colorOutLow[i])' 1 / gamma[i] - 1);    				if (float.IsInfinity (slopesOut[i]) || float.IsNaN (slopesOut[i])) {  					slopesOut[i] = 0;  				}  			}
Magic Number,Pinta.ImageManipulation.UnaryPixelOperations,LuminosityCurveOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\UnaryPixelOperations\LuminosityCurveOp.cs,LuminosityCurveOp,The following statement contains a magic number: for (int i = 0; i < 256; ++i)  				Curve[i] = (byte)i;
Magic Number,Pinta.ImageManipulation.UnaryPixelOperations,InvertWithAlphaOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\UnaryPixelOperations\InvertWithAlphaOp.cs,Apply,The following statement contains a magic number: return ColorBgra.FromBgra ((byte)(255 - color.B)' (byte)(255 - color.G)' (byte)(255 - color.R)' (byte)(255 - color.A));
Magic Number,Pinta.ImageManipulation.UnaryPixelOperations,InvertWithAlphaOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\UnaryPixelOperations\InvertWithAlphaOp.cs,Apply,The following statement contains a magic number: return ColorBgra.FromBgra ((byte)(255 - color.B)' (byte)(255 - color.G)' (byte)(255 - color.R)' (byte)(255 - color.A));
Magic Number,Pinta.ImageManipulation.UnaryPixelOperations,InvertWithAlphaOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\UnaryPixelOperations\InvertWithAlphaOp.cs,Apply,The following statement contains a magic number: return ColorBgra.FromBgra ((byte)(255 - color.B)' (byte)(255 - color.G)' (byte)(255 - color.R)' (byte)(255 - color.A));
Magic Number,Pinta.ImageManipulation.UnaryPixelOperations,InvertWithAlphaOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\UnaryPixelOperations\InvertWithAlphaOp.cs,Apply,The following statement contains a magic number: return ColorBgra.FromBgra ((byte)(255 - color.B)' (byte)(255 - color.G)' (byte)(255 - color.R)' (byte)(255 - color.A));
Magic Number,Pinta.ImageManipulation.UnaryPixelOperations,RedEyeRemoveOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\UnaryPixelOperations\RedEyeRemoveOp.cs,RedEyeRemoveOp,The following statement contains a magic number: set_saturation = (double)sat / 100;
Magic Number,Pinta.ImageManipulation.UnaryPixelOperations,RedEyeRemoveOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\UnaryPixelOperations\RedEyeRemoveOp.cs,Apply,The following statement contains a magic number: if ((difference > tolerence) && (saturation > 100)) {  				var i = 255.0 * color.GetIntensity ();  				var ib = (byte)(i * set_saturation); // adjust the red color for user inputted saturation  				return ColorBgra.FromBgra ((byte)color.B' (byte)color.G' ib' color.A);  			} else {  				return color;  			}
Magic Number,Pinta.ImageManipulation.UnaryPixelOperations,RedEyeRemoveOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\UnaryPixelOperations\RedEyeRemoveOp.cs,Apply,The following statement contains a magic number: if ((difference > tolerence) && (saturation > 100)) {  				var i = 255.0 * color.GetIntensity ();  				var ib = (byte)(i * set_saturation); // adjust the red color for user inputted saturation  				return ColorBgra.FromBgra ((byte)color.B' (byte)color.G' ib' color.A);  			} else {  				return color;  			}
Magic Number,Pinta.ImageManipulation.UnaryPixelOperations,RedEyeRemoveOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\UnaryPixelOperations\RedEyeRemoveOp.cs,GetSaturation,The following statement contains a magic number: var r = (double)color.R / 255;
Magic Number,Pinta.ImageManipulation.UnaryPixelOperations,RedEyeRemoveOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\UnaryPixelOperations\RedEyeRemoveOp.cs,GetSaturation,The following statement contains a magic number: var g = (double)color.G / 255;
Magic Number,Pinta.ImageManipulation.UnaryPixelOperations,RedEyeRemoveOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\UnaryPixelOperations\RedEyeRemoveOp.cs,GetSaturation,The following statement contains a magic number: var b = (double)color.B / 255;
Magic Number,Pinta.ImageManipulation.UnaryPixelOperations,RedEyeRemoveOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\UnaryPixelOperations\RedEyeRemoveOp.cs,GetSaturation,The following statement contains a magic number: return (int)(s * 255);
Magic Number,Pinta.ImageManipulation.UnaryPixelOperations,SetAlphaChannelOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\UnaryPixelOperations\SetAlphaChannelOp.cs,SetAlphaChannelOp,The following statement contains a magic number: add_value = (uint)alphaValue << 24;
Magic Number,Pinta.ImageManipulation.UnaryPixelOperations,InvertOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\UnaryPixelOperations\InvertOp.cs,Apply,The following statement contains a magic number: return ColorBgra.FromBgra ((byte)(255 - color.B)' (byte)(255 - color.G)' (byte)(255 - color.R)' color.A);
Magic Number,Pinta.ImageManipulation.UnaryPixelOperations,InvertOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\UnaryPixelOperations\InvertOp.cs,Apply,The following statement contains a magic number: return ColorBgra.FromBgra ((byte)(255 - color.B)' (byte)(255 - color.G)' (byte)(255 - color.R)' color.A);
Magic Number,Pinta.ImageManipulation.UnaryPixelOperations,InvertOp,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\UnaryPixelOperations\InvertOp.cs,Apply,The following statement contains a magic number: return ColorBgra.FromBgra ((byte)(255 - color.B)' (byte)(255 - color.G)' (byte)(255 - color.R)' color.A);
Missing Default,Pinta.ImageManipulation,HsvColor,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Structs\HsvColor.cs,ToRgb,The following switch statement is missing a default case: switch (sectorNumber)                   {                      case 0:                          r = v;                          g = t;                          b = p;                          break;                        case 1:                          r = q;                          g = v;                          b = p;                          break;                        case 2:                          r = p;                          g = v;                          b = t;                          break;                        case 3:                          r = p;                          g = q;                          b = v;                          break;                        case 4:                          r = t;                          g = p;                          b = v;                          break;                        case 5:                          r = v;                          g = p;                          b = q;                          break;                  }
Missing Default,Pinta.ImageManipulation,Utility,C:\repos\PintaProject_Pinta.ImageManipulation\Pinta.ImageManipulation\Utility.cs,GetBlendModeOp,The following switch statement is missing a default case: switch (mode) {  				case BlendMode.Normal:  					return new NormalBlendOp ();  				case BlendMode.Multiply:  					return new MultiplyBlendOp ();  				case BlendMode.Additive:  					return new AdditiveBlendOp ();  				case BlendMode.ColorBurn:  					return new ColorBurnBlendOp ();  				case BlendMode.ColorDodge:  					return new ColorDodgeBlendOp ();  				case BlendMode.Reflect:  					return new ReflectBlendOp ();  				case BlendMode.Glow:  					return new GlowBlendOp ();  				case BlendMode.Overlay:  					return new OverlayBlendOp ();  				case BlendMode.Difference:  					return new DifferenceBlendOp ();  				case BlendMode.Negation:  					return new NegationBlendOp ();  				case BlendMode.Lighten:  					return new LightenBlendOp ();  				case BlendMode.Darken:  					return new DarkenBlendOp ();  				case BlendMode.Screen:  					return new ScreenBlendOp ();  				case BlendMode.Xor:  					return new XorBlendOp ();  			}
