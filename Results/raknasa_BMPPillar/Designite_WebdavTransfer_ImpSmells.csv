Implementation smell,Namespace,Class,File,Method,Description
Long Method,WebdavTransfer,WebDavTest,C:\repos\raknasa_BMPPillar\WebdavTransfer\WebDavTest.cs,Main,The method has 234 lines of code.
Complex Method,WebdavTransfer,Crypto,C:\repos\raknasa_BMPPillar\WebdavTransfer\Crypto.cs,DecodeRsaPrivateKey,Cyclomatic complexity of the method is 11
Complex Method,WebdavTransfer,Helpers,C:\repos\raknasa_BMPPillar\WebdavTransfer\Helpers.cs,GetBytesFromPEM,Cyclomatic complexity of the method is 9
Complex Method,WebdavTransfer,RSAParameterTraits,C:\repos\raknasa_BMPPillar\WebdavTransfer\RSAParameterTraits.cs,RSAParameterTraits,Cyclomatic complexity of the method is 34
Complex Method,WebdavTransfer,WebDavMethods,C:\repos\raknasa_BMPPillar\WebdavTransfer\WebDavMethods.cs,FolderExists,Cyclomatic complexity of the method is 11
Complex Method,WebdavTransfer.Network,NetworkDrive,C:\repos\raknasa_BMPPillar\WebdavTransfer\Network\NetworkDrive.cs,zMapDrive,Cyclomatic complexity of the method is 9
Long Parameter List,WebdavTransfer,WebdavTransferSettings,C:\repos\raknasa_BMPPillar\WebdavTransfer\WebdavTransferSettings.cs,WebdavTransferSettings,The method has 6 parameters.
Long Identifier,WebdavTransfer,WebdavTransferSettings,C:\repos\raknasa_BMPPillar\WebdavTransfer\WebdavTransferSettings.cs,WebdavTransferSettings,The length of the parameter webdavClientCertificateThumbprint is 33.
Long Statement,WebdavTransfer,Crypto,C:\repos\raknasa_BMPPillar\WebdavTransfer\Crypto.cs,DecodeRsaPrivateKey,The length of the statement  "		parms.ProviderType = ((Environment.OSVersion.Version.Major > 5) || ((Environment.OSVersion.Version.Major == 5) && (Environment.OSVersion.Version.Minor >= 1))) ? 0x18 : 1; " is 170.
Long Statement,WebdavTransfer,ExecutorWithWebdav,C:\repos\raknasa_BMPPillar\WebdavTransfer\ExecutorWithWebdav.cs,DeleteFolder,The length of the statement  "		return RetryHelper.Instance.Try (() => DeleteFolderOnce (collectionID' correlationID)).WithMaxTryCount (MaxTryCount).Until (result => result); " is 142.
Long Statement,WebdavTransfer,ExecutorWithWebdav,C:\repos\raknasa_BMPPillar\WebdavTransfer\ExecutorWithWebdav.cs,GetFile,The length of the statement  "		return RetryHelper.Instance.Try (() => GetFileOnce (link2File' location2SaveFile)).WithMaxTryCount (MaxTryCount).Until (result => result); " is 138.
Long Statement,WebdavTransfer,ExecutorWithWebdav,C:\repos\raknasa_BMPPillar\WebdavTransfer\ExecutorWithWebdav.cs,SendFile,The length of the statement  "	if (webResponse || true)//TODO Fix me! This requires that KB webdav allows us to create directories instead of returning "(405) Method Not Allowed." " is 148.
Long Statement,WebdavTransfer,ExecutorWithWebdav,C:\repos\raknasa_BMPPillar\WebdavTransfer\ExecutorWithWebdav.cs,DeleteFolder,The length of the statement  "	var what = RetryHelper.Instance.Try (() => DeleteFolderOnce (link2File)).WithMaxTryCount (MaxTryCount).WithTimeLimit (1000).WithTryInterval (1000).Until (result => result); " is 172.
Long Statement,WebdavTransfer,MainObject,C:\repos\raknasa_BMPPillar\WebdavTransfer\MainObject.cs,UsingWindsor,The length of the statement  "		_container.Register (Classes.FromAssemblyNamed ("WebdavTransfer").Where (type => type.IsPublic).WithService.FirstInterface ()); " is 127.
Long Statement,WebdavTransfer,WebDavMethods,C:\repos\raknasa_BMPPillar\WebdavTransfer\WebDavMethods.cs,CreateDir,The length of the statement  "	//                                            Settings.WEBDAV_HTTP_PORT' Settings.WEBDAV_BASEFOLDERNAME + "/" + newDir); " is 120.
Long Statement,WebdavTransfer,WebDavMethods,C:\repos\raknasa_BMPPillar\WebdavTransfer\WebDavMethods.cs,GetCertificate,The length of the statement  "		X509Certificate2Collection currentCertificates = myStore.Certificates.Find (X509FindType.FindByThumbprint' thumbprint.ToUpper ()' true); " is 136.
Long Statement,WebdavTransfer,WebDavMethods,C:\repos\raknasa_BMPPillar\WebdavTransfer\WebDavMethods.cs,GetCertificate,The length of the statement  "		Log.DebugFormat ("Found {0} certificates in WEBDAV_CERTIFICATE_STORE '{1}' filtered on {2}"' currentCertificates.Count' Settings.WEBDAV_CERTIFICATE_STORE' thumbprint); " is 167.
Long Statement,WebdavTransfer,WebDavMethods,C:\repos\raknasa_BMPPillar\WebdavTransfer\WebDavMethods.cs,CopyStreamToFile,The length of the statement  "	using (var fileStream = new FileStream (location2SaveFile.FullName' FileMode.Create' FileAccess.Write' FileShare.None)) { " is 121.
Long Statement,WebdavTransfer,WebDavMethods,C:\repos\raknasa_BMPPillar\WebdavTransfer\WebDavMethods.cs,PutFile,The length of the statement  "		Path = string.Format (@"/{0}/{1}/{2}/{3}"' Settings.WEBDAV_BASEFOLDERNAME' collectionID' correlationID' currentFile.Name) " is 121.
Long Statement,WebdavTransfer,WebDavMethods,C:\repos\raknasa_BMPPillar\WebdavTransfer\WebDavMethods.cs,PutFile,The length of the statement  "			return (httpPutResponse.StatusCode == HttpStatusCode.OK || httpPutResponse.StatusCode == HttpStatusCode.Created || httpPutResponse.StatusCode == HttpStatusCode.NoContent); " is 171.
Long Statement,WebdavTransfer,WebDavTest,C:\repos\raknasa_BMPPillar\WebdavTransfer\WebDavTest.cs,Main,The length of the statement  "		string szLockXml = "<?xml version=\"1.0\" encoding=\"utf-8\" ?>" + "<D:lockinfo xmlns:D='DAV:'>" + "<D:lockscope><D:exclusive/></D:lockscope>" + "<D:locktype><D:write/></D:locktype>" + "<D:owner><D:href>mailto:someone@example.com</D:href></D:owner>" + "</D:lockinfo>"; " is 268.
Empty Catch Block,WebdavTransfer.Network,NetworkDrive,C:\repos\raknasa_BMPPillar\WebdavTransfer\Network\NetworkDrive.cs,zMapDrive,The method has an empty catch block.
Magic Number,WebdavTransfer,Crypto,C:\repos\raknasa_BMPPillar\WebdavTransfer\Crypto.cs,DecodeRsaPrivateKey,The following statement contains a magic number: try {  	byte byteValue;  	ushort shortValue;  	shortValue = rd.ReadUInt16 ();  	switch (shortValue) {  	case 0x8130:  		// If true' data is little endian since the proper logical seq is 0x30 0x81  		rd.ReadByte ();  		//advance 1 byte  		break;  	case 0x8230:  		rd.ReadInt16 ();  		//advance 2 bytes  		break;  	default:  		Debug.Assert (false);  		// Improper ASN.1 format  		return null;  	}  	shortValue = rd.ReadUInt16 ();  	if (shortValue != 0x0102)// (version number)  	 {  		Debug.Assert (false);  		// Improper ASN.1 format' unexpected version number  		return null;  	}  	byteValue = rd.ReadByte ();  	if (byteValue != 0x00) {  		Debug.Assert (false);  		// Improper ASN.1 format  		return null;  	}  	// The data following the version will be the ASN.1 data itself' which in our case  	// are a sequence of integers.  	// In order to solve a problem with instancing RSACryptoServiceProvider  	// via default constructor on .net 4.0 this is a hack  	CspParameters parms = new CspParameters ();  	parms.Flags = CspProviderFlags.NoFlags;  	parms.KeyContainerName = Guid.NewGuid ().ToString ().ToUpperInvariant ();  	parms.ProviderType = ((Environment.OSVersion.Version.Major > 5) || ((Environment.OSVersion.Version.Major == 5) && (Environment.OSVersion.Version.Minor >= 1))) ? 0x18 : 1;  	RSACryptoServiceProvider rsa = new RSACryptoServiceProvider (parms);  	RSAParameters rsAparams = new RSAParameters ();  	rsAparams.Modulus = rd.ReadBytes (Helpers.DecodeIntegerSize (rd));  	// Argh' this is a pain.  From emperical testing it appears to be that RSAParameters doesn't like byte buffers that  	// have their leading zeros removed.  The RFC doesn't address this area that I can see' so it's hard to say that this  	// is a bug' but it sure would be helpful if it allowed that. So' there's some extra code here that knows what the  	// sizes of the various components are supposed to be.  Using these sizes we can ensure the buffer sizes are exactly  	// what the RSAParameters expect.  Thanks' Microsoft.  	RSAParameterTraits traits = new RSAParameterTraits (rsAparams.Modulus.Length * 8);  	rsAparams.Modulus = Helpers.AlignBytes (rsAparams.Modulus' traits.size_Mod);  	rsAparams.Exponent = Helpers.AlignBytes (rd.ReadBytes (Helpers.DecodeIntegerSize (rd))' traits.size_Exp);  	rsAparams.D = Helpers.AlignBytes (rd.ReadBytes (Helpers.DecodeIntegerSize (rd))' traits.size_D);  	rsAparams.P = Helpers.AlignBytes (rd.ReadBytes (Helpers.DecodeIntegerSize (rd))' traits.size_P);  	rsAparams.Q = Helpers.AlignBytes (rd.ReadBytes (Helpers.DecodeIntegerSize (rd))' traits.size_Q);  	rsAparams.DP = Helpers.AlignBytes (rd.ReadBytes (Helpers.DecodeIntegerSize (rd))' traits.size_DP);  	rsAparams.DQ = Helpers.AlignBytes (rd.ReadBytes (Helpers.DecodeIntegerSize (rd))' traits.size_DQ);  	rsAparams.InverseQ = Helpers.AlignBytes (rd.ReadBytes (Helpers.DecodeIntegerSize (rd))' traits.size_InvQ);  	rsa.ImportParameters (rsAparams);  	return rsa;  }  catch (Exception) {  	Debug.Assert (false);  	return null;  }  finally {  	rd.Close ();  }  
Magic Number,WebdavTransfer,Crypto,C:\repos\raknasa_BMPPillar\WebdavTransfer\Crypto.cs,DecodeRsaPrivateKey,The following statement contains a magic number: try {  	byte byteValue;  	ushort shortValue;  	shortValue = rd.ReadUInt16 ();  	switch (shortValue) {  	case 0x8130:  		// If true' data is little endian since the proper logical seq is 0x30 0x81  		rd.ReadByte ();  		//advance 1 byte  		break;  	case 0x8230:  		rd.ReadInt16 ();  		//advance 2 bytes  		break;  	default:  		Debug.Assert (false);  		// Improper ASN.1 format  		return null;  	}  	shortValue = rd.ReadUInt16 ();  	if (shortValue != 0x0102)// (version number)  	 {  		Debug.Assert (false);  		// Improper ASN.1 format' unexpected version number  		return null;  	}  	byteValue = rd.ReadByte ();  	if (byteValue != 0x00) {  		Debug.Assert (false);  		// Improper ASN.1 format  		return null;  	}  	// The data following the version will be the ASN.1 data itself' which in our case  	// are a sequence of integers.  	// In order to solve a problem with instancing RSACryptoServiceProvider  	// via default constructor on .net 4.0 this is a hack  	CspParameters parms = new CspParameters ();  	parms.Flags = CspProviderFlags.NoFlags;  	parms.KeyContainerName = Guid.NewGuid ().ToString ().ToUpperInvariant ();  	parms.ProviderType = ((Environment.OSVersion.Version.Major > 5) || ((Environment.OSVersion.Version.Major == 5) && (Environment.OSVersion.Version.Minor >= 1))) ? 0x18 : 1;  	RSACryptoServiceProvider rsa = new RSACryptoServiceProvider (parms);  	RSAParameters rsAparams = new RSAParameters ();  	rsAparams.Modulus = rd.ReadBytes (Helpers.DecodeIntegerSize (rd));  	// Argh' this is a pain.  From emperical testing it appears to be that RSAParameters doesn't like byte buffers that  	// have their leading zeros removed.  The RFC doesn't address this area that I can see' so it's hard to say that this  	// is a bug' but it sure would be helpful if it allowed that. So' there's some extra code here that knows what the  	// sizes of the various components are supposed to be.  Using these sizes we can ensure the buffer sizes are exactly  	// what the RSAParameters expect.  Thanks' Microsoft.  	RSAParameterTraits traits = new RSAParameterTraits (rsAparams.Modulus.Length * 8);  	rsAparams.Modulus = Helpers.AlignBytes (rsAparams.Modulus' traits.size_Mod);  	rsAparams.Exponent = Helpers.AlignBytes (rd.ReadBytes (Helpers.DecodeIntegerSize (rd))' traits.size_Exp);  	rsAparams.D = Helpers.AlignBytes (rd.ReadBytes (Helpers.DecodeIntegerSize (rd))' traits.size_D);  	rsAparams.P = Helpers.AlignBytes (rd.ReadBytes (Helpers.DecodeIntegerSize (rd))' traits.size_P);  	rsAparams.Q = Helpers.AlignBytes (rd.ReadBytes (Helpers.DecodeIntegerSize (rd))' traits.size_Q);  	rsAparams.DP = Helpers.AlignBytes (rd.ReadBytes (Helpers.DecodeIntegerSize (rd))' traits.size_DP);  	rsAparams.DQ = Helpers.AlignBytes (rd.ReadBytes (Helpers.DecodeIntegerSize (rd))' traits.size_DQ);  	rsAparams.InverseQ = Helpers.AlignBytes (rd.ReadBytes (Helpers.DecodeIntegerSize (rd))' traits.size_InvQ);  	rsa.ImportParameters (rsAparams);  	return rsa;  }  catch (Exception) {  	Debug.Assert (false);  	return null;  }  finally {  	rd.Close ();  }  
Magic Number,WebdavTransfer,Crypto,C:\repos\raknasa_BMPPillar\WebdavTransfer\Crypto.cs,DecodeRsaPrivateKey,The following statement contains a magic number: try {  	byte byteValue;  	ushort shortValue;  	shortValue = rd.ReadUInt16 ();  	switch (shortValue) {  	case 0x8130:  		// If true' data is little endian since the proper logical seq is 0x30 0x81  		rd.ReadByte ();  		//advance 1 byte  		break;  	case 0x8230:  		rd.ReadInt16 ();  		//advance 2 bytes  		break;  	default:  		Debug.Assert (false);  		// Improper ASN.1 format  		return null;  	}  	shortValue = rd.ReadUInt16 ();  	if (shortValue != 0x0102)// (version number)  	 {  		Debug.Assert (false);  		// Improper ASN.1 format' unexpected version number  		return null;  	}  	byteValue = rd.ReadByte ();  	if (byteValue != 0x00) {  		Debug.Assert (false);  		// Improper ASN.1 format  		return null;  	}  	// The data following the version will be the ASN.1 data itself' which in our case  	// are a sequence of integers.  	// In order to solve a problem with instancing RSACryptoServiceProvider  	// via default constructor on .net 4.0 this is a hack  	CspParameters parms = new CspParameters ();  	parms.Flags = CspProviderFlags.NoFlags;  	parms.KeyContainerName = Guid.NewGuid ().ToString ().ToUpperInvariant ();  	parms.ProviderType = ((Environment.OSVersion.Version.Major > 5) || ((Environment.OSVersion.Version.Major == 5) && (Environment.OSVersion.Version.Minor >= 1))) ? 0x18 : 1;  	RSACryptoServiceProvider rsa = new RSACryptoServiceProvider (parms);  	RSAParameters rsAparams = new RSAParameters ();  	rsAparams.Modulus = rd.ReadBytes (Helpers.DecodeIntegerSize (rd));  	// Argh' this is a pain.  From emperical testing it appears to be that RSAParameters doesn't like byte buffers that  	// have their leading zeros removed.  The RFC doesn't address this area that I can see' so it's hard to say that this  	// is a bug' but it sure would be helpful if it allowed that. So' there's some extra code here that knows what the  	// sizes of the various components are supposed to be.  Using these sizes we can ensure the buffer sizes are exactly  	// what the RSAParameters expect.  Thanks' Microsoft.  	RSAParameterTraits traits = new RSAParameterTraits (rsAparams.Modulus.Length * 8);  	rsAparams.Modulus = Helpers.AlignBytes (rsAparams.Modulus' traits.size_Mod);  	rsAparams.Exponent = Helpers.AlignBytes (rd.ReadBytes (Helpers.DecodeIntegerSize (rd))' traits.size_Exp);  	rsAparams.D = Helpers.AlignBytes (rd.ReadBytes (Helpers.DecodeIntegerSize (rd))' traits.size_D);  	rsAparams.P = Helpers.AlignBytes (rd.ReadBytes (Helpers.DecodeIntegerSize (rd))' traits.size_P);  	rsAparams.Q = Helpers.AlignBytes (rd.ReadBytes (Helpers.DecodeIntegerSize (rd))' traits.size_Q);  	rsAparams.DP = Helpers.AlignBytes (rd.ReadBytes (Helpers.DecodeIntegerSize (rd))' traits.size_DP);  	rsAparams.DQ = Helpers.AlignBytes (rd.ReadBytes (Helpers.DecodeIntegerSize (rd))' traits.size_DQ);  	rsAparams.InverseQ = Helpers.AlignBytes (rd.ReadBytes (Helpers.DecodeIntegerSize (rd))' traits.size_InvQ);  	rsa.ImportParameters (rsAparams);  	return rsa;  }  catch (Exception) {  	Debug.Assert (false);  	return null;  }  finally {  	rd.Close ();  }  
Magic Number,WebdavTransfer,Crypto,C:\repos\raknasa_BMPPillar\WebdavTransfer\Crypto.cs,DecodeRsaPrivateKey,The following statement contains a magic number: parms.ProviderType = ((Environment.OSVersion.Version.Major > 5) || ((Environment.OSVersion.Version.Major == 5) && (Environment.OSVersion.Version.Minor >= 1))) ? 0x18 : 1;  
Magic Number,WebdavTransfer,Crypto,C:\repos\raknasa_BMPPillar\WebdavTransfer\Crypto.cs,DecodeRsaPrivateKey,The following statement contains a magic number: parms.ProviderType = ((Environment.OSVersion.Version.Major > 5) || ((Environment.OSVersion.Version.Major == 5) && (Environment.OSVersion.Version.Minor >= 1))) ? 0x18 : 1;  
Magic Number,WebdavTransfer,RSAParameterTraits,C:\repos\raknasa_BMPPillar\WebdavTransfer\RSAParameterTraits.cs,RSAParameterTraits,The following statement contains a magic number: if (logbase == (int)logbase) {  	assumedLength = modulusLengthInBits;  }  else {  	// It's not an even power of 2' so round it up to the nearest power of 2.  	assumedLength = (int)(logbase + 1.0);  	assumedLength = (int)(Math.Pow (2' assumedLength));  	System.Diagnostics.Debug.Assert (false);  	// Can this really happen in the field?  I've never seen it' so if it happens  	// you should verify that this really does the 'right' thing!  }  
Magic Number,WebdavTransfer,RSAParameterTraits,C:\repos\raknasa_BMPPillar\WebdavTransfer\RSAParameterTraits.cs,RSAParameterTraits,The following statement contains a magic number: assumedLength = (int)(Math.Pow (2' assumedLength));  
Magic Number,WebdavTransfer,RSAParameterTraits,C:\repos\raknasa_BMPPillar\WebdavTransfer\RSAParameterTraits.cs,RSAParameterTraits,The following statement contains a magic number: switch (assumedLength) {  case 1024:  	size_Mod = 0x80;  	size_Exp = -1;  	size_D = 0x80;  	size_P = 0x40;  	size_Q = 0x40;  	size_DP = 0x40;  	size_DQ = 0x40;  	size_InvQ = 0x40;  	break;  case 2048:  	size_Mod = 0x100;  	size_Exp = -1;  	size_D = 0x100;  	size_P = 0x80;  	size_Q = 0x80;  	size_DP = 0x80;  	size_DQ = 0x80;  	size_InvQ = 0x80;  	break;  case 4096:  	size_Mod = 0x200;  	size_Exp = -1;  	size_D = 0x200;  	size_P = 0x100;  	size_Q = 0x100;  	size_DP = 0x100;  	size_DQ = 0x100;  	size_InvQ = 0x100;  	break;  default:  	System.Diagnostics.Debug.Assert (false);  	// Unknown key size?  	break;  }  
Magic Number,WebdavTransfer,RSAParameterTraits,C:\repos\raknasa_BMPPillar\WebdavTransfer\RSAParameterTraits.cs,RSAParameterTraits,The following statement contains a magic number: switch (assumedLength) {  case 1024:  	size_Mod = 0x80;  	size_Exp = -1;  	size_D = 0x80;  	size_P = 0x40;  	size_Q = 0x40;  	size_DP = 0x40;  	size_DQ = 0x40;  	size_InvQ = 0x40;  	break;  case 2048:  	size_Mod = 0x100;  	size_Exp = -1;  	size_D = 0x100;  	size_P = 0x80;  	size_Q = 0x80;  	size_DP = 0x80;  	size_DQ = 0x80;  	size_InvQ = 0x80;  	break;  case 4096:  	size_Mod = 0x200;  	size_Exp = -1;  	size_D = 0x200;  	size_P = 0x100;  	size_Q = 0x100;  	size_DP = 0x100;  	size_DQ = 0x100;  	size_InvQ = 0x100;  	break;  default:  	System.Diagnostics.Debug.Assert (false);  	// Unknown key size?  	break;  }  
Magic Number,WebdavTransfer,RSAParameterTraits,C:\repos\raknasa_BMPPillar\WebdavTransfer\RSAParameterTraits.cs,RSAParameterTraits,The following statement contains a magic number: switch (assumedLength) {  case 1024:  	size_Mod = 0x80;  	size_Exp = -1;  	size_D = 0x80;  	size_P = 0x40;  	size_Q = 0x40;  	size_DP = 0x40;  	size_DQ = 0x40;  	size_InvQ = 0x40;  	break;  case 2048:  	size_Mod = 0x100;  	size_Exp = -1;  	size_D = 0x100;  	size_P = 0x80;  	size_Q = 0x80;  	size_DP = 0x80;  	size_DQ = 0x80;  	size_InvQ = 0x80;  	break;  case 4096:  	size_Mod = 0x200;  	size_Exp = -1;  	size_D = 0x200;  	size_P = 0x100;  	size_Q = 0x100;  	size_DP = 0x100;  	size_DQ = 0x100;  	size_InvQ = 0x100;  	break;  default:  	System.Diagnostics.Debug.Assert (false);  	// Unknown key size?  	break;  }  
Magic Number,WebdavTransfer,WebMethodsBase,C:\repos\raknasa_BMPPillar\WebdavTransfer\WebMethodsBase.cs,SetTimeOut,The following statement contains a magic number: return 30000;  
Magic Number,WebdavTransfer,WebDavMethods,C:\repos\raknasa_BMPPillar\WebdavTransfer\WebDavMethods.cs,CopyStreamToFile,The following statement contains a magic number: using (var fileStream = new FileStream (location2SaveFile.FullName' FileMode.Create' FileAccess.Write' FileShare.None)) {  	getResponseStream.CopyTo (fileStream' 32768);  	fileStream.Close ();  	Log.DebugFormat ("Full lenght of '{0}' is {1} bytes"' location2SaveFile.FullName' location2SaveFile.Length);  }  
Magic Number,WebdavTransfer,WebDavMethods,C:\repos\raknasa_BMPPillar\WebdavTransfer\WebDavMethods.cs,CopyStreamToFile,The following statement contains a magic number: getResponseStream.CopyTo (fileStream' 32768);  
Magic Number,WebdavTransfer.Network,NetworkDrive,C:\repos\raknasa_BMPPillar\WebdavTransfer\Network\NetworkDrive.cs,zMapDrive,The following statement contains a magic number: stNetRes.iScope = 2;  
Magic Number,WebdavTransfer.Network,NetworkDrive,C:\repos\raknasa_BMPPillar\WebdavTransfer\Network\NetworkDrive.cs,zMapDrive,The following statement contains a magic number: stNetRes.iDisplayType = 3;  
