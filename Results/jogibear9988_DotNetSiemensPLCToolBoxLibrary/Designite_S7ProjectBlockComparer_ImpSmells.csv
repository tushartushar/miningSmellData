Implementation smell,Namespace,Class,File,Method,Description
Long Method,DiffMatchPatch,diff_match_patch,C:\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\S7ProjectBlockComparer\DiffMatchPatch.cs,diff_bisect,The method has 133 lines of code.
Long Method,DiffMatchPatch,diff_match_patch,C:\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\S7ProjectBlockComparer\DiffMatchPatch.cs,diff_cleanupSemantic,The method has 113 lines of code.
Long Method,DiffMatchPatch,diff_match_patch,C:\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\S7ProjectBlockComparer\DiffMatchPatch.cs,diff_cleanupMerge,The method has 126 lines of code.
Long Method,DiffMatchPatch,diff_match_patch,C:\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\S7ProjectBlockComparer\DiffMatchPatch.cs,match_bitap,The method has 105 lines of code.
Long Method,DiffMatchPatch,diff_match_patch,C:\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\S7ProjectBlockComparer\DiffMatchPatch.cs,patch_apply,The method has 112 lines of code.
Long Method,DiffMatchPatch,diff_match_patch,C:\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\S7ProjectBlockComparer\DiffMatchPatch.cs,patch_splitMax,The method has 107 lines of code.
Complex Method,DiffMatchPatch,diff_match_patch,C:\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\S7ProjectBlockComparer\DiffMatchPatch.cs,diff_bisect,Cyclomatic complexity of the method is 12
Complex Method,DiffMatchPatch,diff_match_patch,C:\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\S7ProjectBlockComparer\DiffMatchPatch.cs,diff_cleanupSemantic,Cyclomatic complexity of the method is 8
Complex Method,DiffMatchPatch,diff_match_patch,C:\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\S7ProjectBlockComparer\DiffMatchPatch.cs,diff_cleanupSemanticLossless,Cyclomatic complexity of the method is 9
Complex Method,DiffMatchPatch,diff_match_patch,C:\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\S7ProjectBlockComparer\DiffMatchPatch.cs,diff_cleanupMerge,Cyclomatic complexity of the method is 8
Complex Method,DiffMatchPatch,diff_match_patch,C:\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\S7ProjectBlockComparer\DiffMatchPatch.cs,match_bitap,Cyclomatic complexity of the method is 13
Complex Method,DiffMatchPatch,diff_match_patch,C:\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\S7ProjectBlockComparer\DiffMatchPatch.cs,patch_make,Cyclomatic complexity of the method is 8
Complex Method,DiffMatchPatch,diff_match_patch,C:\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\S7ProjectBlockComparer\DiffMatchPatch.cs,patch_splitMax,Cyclomatic complexity of the method is 11
Complex Method,DiffMatchPatch,diff_match_patch,C:\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\S7ProjectBlockComparer\DiffMatchPatch.cs,patch_fromText,Cyclomatic complexity of the method is 8
Long Parameter List,DiffMatchPatch,diff_match_patch,C:\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\S7ProjectBlockComparer\DiffMatchPatch.cs,diff_bisectSplit,The method has 5 parameters. Parameters: text1' text2' x' y' deadline
Long Statement,WPFToolboxForSiemensPLCs.AvalonEdit,TextColorizer,C:\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\S7ProjectBlockComparer\AvalonEdit\TextColorizer.cs,ColorizeLine,The length of the statement  "                base.ChangeLinePart(_start < line.Offset ? line.Offset : _start' _stop > line.Offset + line.Length ? line.Offset + line.Length : _stop' (VisualLineElement element) => " is 166.
Long Statement,S7ProjectBlockComparer,MainWindow,C:\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\S7ProjectBlockComparer\MainWindow.xaml.cs,cmdComp_Click,The length of the statement  "                            if (projectBlockInfo.BlockType == DotNetSiemensPLCToolBoxLibrary.DataTypes.PLCBlockType.FB || projectBlockInfo.BlockType == DotNetSiemensPLCToolBoxLibrary.DataTypes.PLCBlockType.FC || projectBlockInfo.BlockType == DotNetSiemensPLCToolBoxLibrary.DataTypes.PLCBlockType.OB) " is 271.
Long Statement,S7ProjectBlockComparer,MainWindow,C:\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\S7ProjectBlockComparer\MainWindow.xaml.cs,cmdComp_Click,The length of the statement  "                            if (projectBlockInfo.BlockType == DotNetSiemensPLCToolBoxLibrary.DataTypes.PLCBlockType.FB || projectBlockInfo.BlockType == DotNetSiemensPLCToolBoxLibrary.DataTypes.PLCBlockType.FC || projectBlockInfo.BlockType == DotNetSiemensPLCToolBoxLibrary.DataTypes.PLCBlockType.OB) " is 271.
Long Statement,S7ProjectBlockComparer,MainWindow,C:\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\S7ProjectBlockComparer\MainWindow.xaml.cs,InitializeComponent,The length of the statement  "            System.Uri resourceLocater = new System.Uri("/S7ProjectBlockComparer;component/mainwindow.xaml"' System.UriKind.Relative); " is 122.
Long Statement,DiffMatchPatch,diff_match_patch,C:\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\S7ProjectBlockComparer\DiffMatchPatch.cs,diff_cleanupSemantic,The length of the statement  "                    if (lastequality != null && (lastequality.Length <= Math.Max(length_insertions1' length_deletions1)) && (lastequality.Length <= Math.Max(length_insertions2' length_deletions2))) " is 177.
Long Statement,DiffMatchPatch,diff_match_patch,C:\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\S7ProjectBlockComparer\DiffMatchPatch.cs,diff_cleanupEfficiency,The length of the statement  "                    if ((lastequality.Length != 0) && ((pre_ins && pre_del && post_ins && post_del) || ((lastequality.Length < this.Diff_EditCost / 2) && ((pre_ins ? 1 : 0) + (pre_del ? 1 : 0) + (post_ins ? 1 : 0) + (post_del ? 1 : 0)) == 3))) " is 223.
Long Statement,DiffMatchPatch,diff_match_patch,C:\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\S7ProjectBlockComparer\DiffMatchPatch.cs,diff_cleanupMerge,The length of the statement  "                                    if ((pointer - count_delete - count_insert) > 0 && diffs[pointer - count_delete - count_insert - 1].operation == Operation.EQUAL) " is 129.
Long Statement,DiffMatchPatch,diff_match_patch,C:\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\S7ProjectBlockComparer\DiffMatchPatch.cs,diff_cleanupMerge,The length of the statement  "                                diffs.Splice(pointer - count_delete - count_insert' count_delete + count_insert' new Diff(Operation.DELETE' text_delete)' new Diff(Operation.INSERT' text_insert)); " is 163.
Long Statement,DiffMatchPatch,diff_match_patch,C:\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\S7ProjectBlockComparer\DiffMatchPatch.cs,diff_cleanupMerge,The length of the statement  "                        diffs[pointer].text = diffs[pointer - 1].text + diffs[pointer].text.Substring(0' diffs[pointer].text.Length - diffs[pointer - 1].text.Length); " is 142.
Long Statement,DiffMatchPatch,diff_match_patch,C:\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\S7ProjectBlockComparer\DiffMatchPatch.cs,diff_fromDelta,The length of the statement  "                            throw new ArgumentException("Delta length (" + pointer + ") larger than source text length (" + text1.Length + ")."' e); " is 120.
Long Statement,DiffMatchPatch,diff_match_patch,C:\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\S7ProjectBlockComparer\DiffMatchPatch.cs,patch_addContext,The length of the statement  "            while (text.IndexOf(pattern' StringComparison.Ordinal) != text.LastIndexOf(pattern' StringComparison.Ordinal) && pattern.Length < Match_MaxBits - Patch_Margin - Patch_Margin) " is 174.
Long Statement,DiffMatchPatch,diff_match_patch,C:\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\S7ProjectBlockComparer\DiffMatchPatch.cs,patch_addContext,The length of the statement  "                pattern = text.JavaSubstring(Math.Max(0' patch.start2 - padding)' Math.Min(text.Length' patch.start2 + patch.length1 + padding)); " is 129.
Long Statement,DiffMatchPatch,diff_match_patch,C:\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\S7ProjectBlockComparer\DiffMatchPatch.cs,patch_addContext,The length of the statement  "            string suffix = text.JavaSubstring(patch.start2 + patch.length1' Math.Min(text.Length' patch.start2 + patch.length1 + padding)); " is 128.
Long Statement,DiffMatchPatch,diff_match_patch,C:\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\S7ProjectBlockComparer\DiffMatchPatch.cs,patch_apply,The length of the statement  "                        end_loc = match_main(text' text1.Substring(text1.Length - this.Match_MaxBits)' expected_loc + text1.Length - this.Match_MaxBits); " is 129.
Long Statement,DiffMatchPatch,diff_match_patch,C:\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\S7ProjectBlockComparer\DiffMatchPatch.cs,patch_apply,The length of the statement  "                        if (text1.Length > this.Match_MaxBits && this.diff_levenshtein(diffs) / (float)text1.Length > this.Patch_DeleteThreshold) " is 121.
Long Statement,DiffMatchPatch,diff_match_patch,C:\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\S7ProjectBlockComparer\DiffMatchPatch.cs,patch_splitMax,The length of the statement  "                        else if (diff_type == Operation.DELETE && patch.diffs.Count == 1 && patch.diffs.First().operation == Operation.EQUAL && diff_text.Length > 2 * patch_size) " is 154.
Long Statement,DiffMatchPatch,diff_match_patch,C:\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\S7ProjectBlockComparer\DiffMatchPatch.cs,unescapeForEncodeUriCompatability,The length of the statement  "            return str.Replace("%21"' "!").Replace("%7e"' "~").Replace("%27"' "'").Replace("%28"' "(").Replace("%29"' ")").Replace("%3b"' ";").Replace("%2f"' "/").Replace("%3f"' "?").Replace("%3a"' ":").Replace("%40"' "@").Replace("%26"' "&").Replace("%3d"' "=").Replace("%2b"' "+").Replace("%24"' "$").Replace("%2c"' "'").Replace("%23"' "#"); " is 331.
Complex Conditional,WPFToolboxForSiemensPLCs.AvalonEdit,BraceFoldingStrategy,C:\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\S7ProjectBlockComparer\AvalonEdit\BraceFoldingStrategy.cs,CreateNewFoldings,The conditional expression  "(c1 == '(' && (c == 'U' || c == 'O' || c == 'X')) || (c2 == '(' && c1=='N' && (c == 'U' || c == 'O' || c == 'X'))"  is complex.
Complex Conditional,DiffMatchPatch,diff_match_patch,C:\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\S7ProjectBlockComparer\DiffMatchPatch.cs,diff_cleanupEfficiency,The conditional expression  "(lastequality.Length != 0) && ((pre_ins && pre_del && post_ins && post_del) || ((lastequality.Length < this.Diff_EditCost / 2) && ((pre_ins ? 1 : 0) + (pre_del ? 1 : 0) + (post_ins ? 1 : 0) + (post_del ? 1 : 0)) == 3))"  is complex.
Complex Conditional,DiffMatchPatch,diff_match_patch,C:\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\S7ProjectBlockComparer\DiffMatchPatch.cs,patch_splitMax,The conditional expression  "diff_type == Operation.DELETE && patch.diffs.Count == 1 && patch.diffs.First().operation == Operation.EQUAL && diff_text.Length > 2 * patch_size"  is complex.
Magic Number,WPFToolboxForSiemensPLCs.AvalonEdit,BraceFoldingStrategy,C:\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\S7ProjectBlockComparer\AvalonEdit\BraceFoldingStrategy.cs,CreateNewFoldings,The following statement contains a magic number: for (int i = 0; i < document.TextLength-2; i++) {  				char c = document.GetCharAt(i);                  char c1 = document.GetCharAt(i+1);                  char c2 = document.GetCharAt(i+2);                  if ((c1 == '(' && (c == 'U' || c == 'O' || c == 'X')) || (c2 == '(' && c1=='N' && (c == 'U' || c == 'O' || c == 'X')))                  {                      startOffsets.Push(i);  				} else if (c == ')' && startOffsets.Count > 0) {  					int startOffset = startOffsets.Pop();  					// don't fold if opening and closing brace are on the same line  					if (startOffset < lastNewLineOffset) {  						newFoldings.Add(new NewFolding(startOffset' i + 1));  					}  				} else if (c == '\n' || c == '\r') {  					lastNewLineOffset = i + 1;  				}  			}
Magic Number,WPFToolboxForSiemensPLCs.AvalonEdit,BraceFoldingStrategy,C:\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\S7ProjectBlockComparer\AvalonEdit\BraceFoldingStrategy.cs,CreateNewFoldings,The following statement contains a magic number: for (int i = 0; i < document.TextLength-2; i++) {  				char c = document.GetCharAt(i);                  char c1 = document.GetCharAt(i+1);                  char c2 = document.GetCharAt(i+2);                  if ((c1 == '(' && (c == 'U' || c == 'O' || c == 'X')) || (c2 == '(' && c1=='N' && (c == 'U' || c == 'O' || c == 'X')))                  {                      startOffsets.Push(i);  				} else if (c == ')' && startOffsets.Count > 0) {  					int startOffset = startOffsets.Pop();  					// don't fold if opening and closing brace are on the same line  					if (startOffset < lastNewLineOffset) {  						newFoldings.Add(new NewFolding(startOffset' i + 1));  					}  				} else if (c == '\n' || c == '\r') {  					lastNewLineOffset = i + 1;  				}  			}
Magic Number,WPFToolboxForSiemensPLCs.AvalonEdit,BraceFoldingStrategy,C:\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\S7ProjectBlockComparer\AvalonEdit\BraceFoldingStrategy.cs,CreateNewFoldings,The following statement contains a magic number: {                  while (wrt >= 0)                  {                      int old = wrt;                      wrt = document.Text.IndexOf("Netzwerk"' wrt + 1);                      if (wrt > old)                          newFoldings.Add(new NewFolding(old' wrt - 2));                      else                      {                          newFoldings.Add(new NewFolding(old' document.Text.Length));                          break;                                           }                  }              }
Magic Number,S7ProjectBlockComparer,MainWindow,C:\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\S7ProjectBlockComparer\MainWindow.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.busy = ((Xceed.Wpf.Toolkit.BusyIndicator)(target));              return;              case 2:              this.akBlock = ((System.Windows.Controls.TextBlock)(target));              return;              case 3:              this.prj1 = ((System.Windows.Controls.TextBlock)(target));              return;              case 4:              this.cmdPrj1 = ((System.Windows.Controls.Button)(target));                            #line 20 "..\..\MainWindow.xaml"              this.cmdPrj1.Click += new System.Windows.RoutedEventHandler(this.cmdPrj1_Click);                            #line default              #line hidden              return;              case 5:              this.prj2 = ((System.Windows.Controls.TextBlock)(target));              return;              case 6:              this.cmdPrj2 = ((System.Windows.Controls.Button)(target));                            #line 25 "..\..\MainWindow.xaml"              this.cmdPrj2.Click += new System.Windows.RoutedEventHandler(this.cmdPrj2_Click);                            #line default              #line hidden              return;              case 7:              this.cmdComp = ((System.Windows.Controls.Button)(target));                            #line 26 "..\..\MainWindow.xaml"              this.cmdComp.Click += new System.Windows.RoutedEventHandler(this.cmdComp_Click);                            #line default              #line hidden              return;              case 8:              this.lstBlocks = ((System.Windows.Controls.ListBox)(target));                            #line 27 "..\..\MainWindow.xaml"              this.lstBlocks.MouseDoubleClick += new System.Windows.Input.MouseButtonEventHandler(this.lstBlocks_MouseDoubleClick);                            #line default              #line hidden              return;              case 9:              this.txtResult = ((ICSharpCode.AvalonEdit.TextEditor)(target));              return;              }
Magic Number,S7ProjectBlockComparer,MainWindow,C:\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\S7ProjectBlockComparer\MainWindow.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.busy = ((Xceed.Wpf.Toolkit.BusyIndicator)(target));              return;              case 2:              this.akBlock = ((System.Windows.Controls.TextBlock)(target));              return;              case 3:              this.prj1 = ((System.Windows.Controls.TextBlock)(target));              return;              case 4:              this.cmdPrj1 = ((System.Windows.Controls.Button)(target));                            #line 20 "..\..\MainWindow.xaml"              this.cmdPrj1.Click += new System.Windows.RoutedEventHandler(this.cmdPrj1_Click);                            #line default              #line hidden              return;              case 5:              this.prj2 = ((System.Windows.Controls.TextBlock)(target));              return;              case 6:              this.cmdPrj2 = ((System.Windows.Controls.Button)(target));                            #line 25 "..\..\MainWindow.xaml"              this.cmdPrj2.Click += new System.Windows.RoutedEventHandler(this.cmdPrj2_Click);                            #line default              #line hidden              return;              case 7:              this.cmdComp = ((System.Windows.Controls.Button)(target));                            #line 26 "..\..\MainWindow.xaml"              this.cmdComp.Click += new System.Windows.RoutedEventHandler(this.cmdComp_Click);                            #line default              #line hidden              return;              case 8:              this.lstBlocks = ((System.Windows.Controls.ListBox)(target));                            #line 27 "..\..\MainWindow.xaml"              this.lstBlocks.MouseDoubleClick += new System.Windows.Input.MouseButtonEventHandler(this.lstBlocks_MouseDoubleClick);                            #line default              #line hidden              return;              case 9:              this.txtResult = ((ICSharpCode.AvalonEdit.TextEditor)(target));              return;              }
Magic Number,S7ProjectBlockComparer,MainWindow,C:\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\S7ProjectBlockComparer\MainWindow.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.busy = ((Xceed.Wpf.Toolkit.BusyIndicator)(target));              return;              case 2:              this.akBlock = ((System.Windows.Controls.TextBlock)(target));              return;              case 3:              this.prj1 = ((System.Windows.Controls.TextBlock)(target));              return;              case 4:              this.cmdPrj1 = ((System.Windows.Controls.Button)(target));                            #line 20 "..\..\MainWindow.xaml"              this.cmdPrj1.Click += new System.Windows.RoutedEventHandler(this.cmdPrj1_Click);                            #line default              #line hidden              return;              case 5:              this.prj2 = ((System.Windows.Controls.TextBlock)(target));              return;              case 6:              this.cmdPrj2 = ((System.Windows.Controls.Button)(target));                            #line 25 "..\..\MainWindow.xaml"              this.cmdPrj2.Click += new System.Windows.RoutedEventHandler(this.cmdPrj2_Click);                            #line default              #line hidden              return;              case 7:              this.cmdComp = ((System.Windows.Controls.Button)(target));                            #line 26 "..\..\MainWindow.xaml"              this.cmdComp.Click += new System.Windows.RoutedEventHandler(this.cmdComp_Click);                            #line default              #line hidden              return;              case 8:              this.lstBlocks = ((System.Windows.Controls.ListBox)(target));                            #line 27 "..\..\MainWindow.xaml"              this.lstBlocks.MouseDoubleClick += new System.Windows.Input.MouseButtonEventHandler(this.lstBlocks_MouseDoubleClick);                            #line default              #line hidden              return;              case 9:              this.txtResult = ((ICSharpCode.AvalonEdit.TextEditor)(target));              return;              }
Magic Number,S7ProjectBlockComparer,MainWindow,C:\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\S7ProjectBlockComparer\MainWindow.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.busy = ((Xceed.Wpf.Toolkit.BusyIndicator)(target));              return;              case 2:              this.akBlock = ((System.Windows.Controls.TextBlock)(target));              return;              case 3:              this.prj1 = ((System.Windows.Controls.TextBlock)(target));              return;              case 4:              this.cmdPrj1 = ((System.Windows.Controls.Button)(target));                            #line 20 "..\..\MainWindow.xaml"              this.cmdPrj1.Click += new System.Windows.RoutedEventHandler(this.cmdPrj1_Click);                            #line default              #line hidden              return;              case 5:              this.prj2 = ((System.Windows.Controls.TextBlock)(target));              return;              case 6:              this.cmdPrj2 = ((System.Windows.Controls.Button)(target));                            #line 25 "..\..\MainWindow.xaml"              this.cmdPrj2.Click += new System.Windows.RoutedEventHandler(this.cmdPrj2_Click);                            #line default              #line hidden              return;              case 7:              this.cmdComp = ((System.Windows.Controls.Button)(target));                            #line 26 "..\..\MainWindow.xaml"              this.cmdComp.Click += new System.Windows.RoutedEventHandler(this.cmdComp_Click);                            #line default              #line hidden              return;              case 8:              this.lstBlocks = ((System.Windows.Controls.ListBox)(target));                            #line 27 "..\..\MainWindow.xaml"              this.lstBlocks.MouseDoubleClick += new System.Windows.Input.MouseButtonEventHandler(this.lstBlocks_MouseDoubleClick);                            #line default              #line hidden              return;              case 9:              this.txtResult = ((ICSharpCode.AvalonEdit.TextEditor)(target));              return;              }
Magic Number,S7ProjectBlockComparer,MainWindow,C:\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\S7ProjectBlockComparer\MainWindow.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.busy = ((Xceed.Wpf.Toolkit.BusyIndicator)(target));              return;              case 2:              this.akBlock = ((System.Windows.Controls.TextBlock)(target));              return;              case 3:              this.prj1 = ((System.Windows.Controls.TextBlock)(target));              return;              case 4:              this.cmdPrj1 = ((System.Windows.Controls.Button)(target));                            #line 20 "..\..\MainWindow.xaml"              this.cmdPrj1.Click += new System.Windows.RoutedEventHandler(this.cmdPrj1_Click);                            #line default              #line hidden              return;              case 5:              this.prj2 = ((System.Windows.Controls.TextBlock)(target));              return;              case 6:              this.cmdPrj2 = ((System.Windows.Controls.Button)(target));                            #line 25 "..\..\MainWindow.xaml"              this.cmdPrj2.Click += new System.Windows.RoutedEventHandler(this.cmdPrj2_Click);                            #line default              #line hidden              return;              case 7:              this.cmdComp = ((System.Windows.Controls.Button)(target));                            #line 26 "..\..\MainWindow.xaml"              this.cmdComp.Click += new System.Windows.RoutedEventHandler(this.cmdComp_Click);                            #line default              #line hidden              return;              case 8:              this.lstBlocks = ((System.Windows.Controls.ListBox)(target));                            #line 27 "..\..\MainWindow.xaml"              this.lstBlocks.MouseDoubleClick += new System.Windows.Input.MouseButtonEventHandler(this.lstBlocks_MouseDoubleClick);                            #line default              #line hidden              return;              case 9:              this.txtResult = ((ICSharpCode.AvalonEdit.TextEditor)(target));              return;              }
Magic Number,S7ProjectBlockComparer,MainWindow,C:\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\S7ProjectBlockComparer\MainWindow.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.busy = ((Xceed.Wpf.Toolkit.BusyIndicator)(target));              return;              case 2:              this.akBlock = ((System.Windows.Controls.TextBlock)(target));              return;              case 3:              this.prj1 = ((System.Windows.Controls.TextBlock)(target));              return;              case 4:              this.cmdPrj1 = ((System.Windows.Controls.Button)(target));                            #line 20 "..\..\MainWindow.xaml"              this.cmdPrj1.Click += new System.Windows.RoutedEventHandler(this.cmdPrj1_Click);                            #line default              #line hidden              return;              case 5:              this.prj2 = ((System.Windows.Controls.TextBlock)(target));              return;              case 6:              this.cmdPrj2 = ((System.Windows.Controls.Button)(target));                            #line 25 "..\..\MainWindow.xaml"              this.cmdPrj2.Click += new System.Windows.RoutedEventHandler(this.cmdPrj2_Click);                            #line default              #line hidden              return;              case 7:              this.cmdComp = ((System.Windows.Controls.Button)(target));                            #line 26 "..\..\MainWindow.xaml"              this.cmdComp.Click += new System.Windows.RoutedEventHandler(this.cmdComp_Click);                            #line default              #line hidden              return;              case 8:              this.lstBlocks = ((System.Windows.Controls.ListBox)(target));                            #line 27 "..\..\MainWindow.xaml"              this.lstBlocks.MouseDoubleClick += new System.Windows.Input.MouseButtonEventHandler(this.lstBlocks_MouseDoubleClick);                            #line default              #line hidden              return;              case 9:              this.txtResult = ((ICSharpCode.AvalonEdit.TextEditor)(target));              return;              }
Magic Number,S7ProjectBlockComparer,MainWindow,C:\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\S7ProjectBlockComparer\MainWindow.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.busy = ((Xceed.Wpf.Toolkit.BusyIndicator)(target));              return;              case 2:              this.akBlock = ((System.Windows.Controls.TextBlock)(target));              return;              case 3:              this.prj1 = ((System.Windows.Controls.TextBlock)(target));              return;              case 4:              this.cmdPrj1 = ((System.Windows.Controls.Button)(target));                            #line 20 "..\..\MainWindow.xaml"              this.cmdPrj1.Click += new System.Windows.RoutedEventHandler(this.cmdPrj1_Click);                            #line default              #line hidden              return;              case 5:              this.prj2 = ((System.Windows.Controls.TextBlock)(target));              return;              case 6:              this.cmdPrj2 = ((System.Windows.Controls.Button)(target));                            #line 25 "..\..\MainWindow.xaml"              this.cmdPrj2.Click += new System.Windows.RoutedEventHandler(this.cmdPrj2_Click);                            #line default              #line hidden              return;              case 7:              this.cmdComp = ((System.Windows.Controls.Button)(target));                            #line 26 "..\..\MainWindow.xaml"              this.cmdComp.Click += new System.Windows.RoutedEventHandler(this.cmdComp_Click);                            #line default              #line hidden              return;              case 8:              this.lstBlocks = ((System.Windows.Controls.ListBox)(target));                            #line 27 "..\..\MainWindow.xaml"              this.lstBlocks.MouseDoubleClick += new System.Windows.Input.MouseButtonEventHandler(this.lstBlocks_MouseDoubleClick);                            #line default              #line hidden              return;              case 9:              this.txtResult = ((ICSharpCode.AvalonEdit.TextEditor)(target));              return;              }
Magic Number,S7ProjectBlockComparer,MainWindow,C:\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\S7ProjectBlockComparer\MainWindow.xaml.cs,Connect,The following statement contains a magic number: switch (connectionId)              {              case 1:              this.busy = ((Xceed.Wpf.Toolkit.BusyIndicator)(target));              return;              case 2:              this.akBlock = ((System.Windows.Controls.TextBlock)(target));              return;              case 3:              this.prj1 = ((System.Windows.Controls.TextBlock)(target));              return;              case 4:              this.cmdPrj1 = ((System.Windows.Controls.Button)(target));                            #line 20 "..\..\MainWindow.xaml"              this.cmdPrj1.Click += new System.Windows.RoutedEventHandler(this.cmdPrj1_Click);                            #line default              #line hidden              return;              case 5:              this.prj2 = ((System.Windows.Controls.TextBlock)(target));              return;              case 6:              this.cmdPrj2 = ((System.Windows.Controls.Button)(target));                            #line 25 "..\..\MainWindow.xaml"              this.cmdPrj2.Click += new System.Windows.RoutedEventHandler(this.cmdPrj2_Click);                            #line default              #line hidden              return;              case 7:              this.cmdComp = ((System.Windows.Controls.Button)(target));                            #line 26 "..\..\MainWindow.xaml"              this.cmdComp.Click += new System.Windows.RoutedEventHandler(this.cmdComp_Click);                            #line default              #line hidden              return;              case 8:              this.lstBlocks = ((System.Windows.Controls.ListBox)(target));                            #line 27 "..\..\MainWindow.xaml"              this.lstBlocks.MouseDoubleClick += new System.Windows.Input.MouseButtonEventHandler(this.lstBlocks_MouseDoubleClick);                            #line default              #line hidden              return;              case 9:              this.txtResult = ((ICSharpCode.AvalonEdit.TextEditor)(target));              return;              }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\S7ProjectBlockComparer\DiffMatchPatch.cs,diff_main,The following statement contains a magic number: if (this.Diff_Timeout <= 0)              {                  deadline = DateTime.MaxValue;              }              else              {                  deadline = DateTime.Now + new TimeSpan(((long)(Diff_Timeout * 1000)) * 10000);              }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\S7ProjectBlockComparer\DiffMatchPatch.cs,diff_main,The following statement contains a magic number: if (this.Diff_Timeout <= 0)              {                  deadline = DateTime.MaxValue;              }              else              {                  deadline = DateTime.Now + new TimeSpan(((long)(Diff_Timeout * 1000)) * 10000);              }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\S7ProjectBlockComparer\DiffMatchPatch.cs,diff_compute,The following statement contains a magic number: if (hm != null)              {                  // A half-match was found' sort out the return data.                  string text1_a = hm[0];                  string text1_b = hm[1];                  string text2_a = hm[2];                  string text2_b = hm[3];                  string mid_common = hm[4];                  // Send both pairs off for separate processing.                  List<Diff> diffs_a = diff_main(text1_a' text2_a' checklines' deadline);                  List<Diff> diffs_b = diff_main(text1_b' text2_b' checklines' deadline);                  // Merge the results.                  diffs = diffs_a;                  diffs.Add(new Diff(Operation.EQUAL' mid_common));                  diffs.AddRange(diffs_b);                  return diffs;              }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\S7ProjectBlockComparer\DiffMatchPatch.cs,diff_compute,The following statement contains a magic number: if (hm != null)              {                  // A half-match was found' sort out the return data.                  string text1_a = hm[0];                  string text1_b = hm[1];                  string text2_a = hm[2];                  string text2_b = hm[3];                  string mid_common = hm[4];                  // Send both pairs off for separate processing.                  List<Diff> diffs_a = diff_main(text1_a' text2_a' checklines' deadline);                  List<Diff> diffs_b = diff_main(text1_b' text2_b' checklines' deadline);                  // Merge the results.                  diffs = diffs_a;                  diffs.Add(new Diff(Operation.EQUAL' mid_common));                  diffs.AddRange(diffs_b);                  return diffs;              }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\S7ProjectBlockComparer\DiffMatchPatch.cs,diff_compute,The following statement contains a magic number: if (hm != null)              {                  // A half-match was found' sort out the return data.                  string text1_a = hm[0];                  string text1_b = hm[1];                  string text2_a = hm[2];                  string text2_b = hm[3];                  string mid_common = hm[4];                  // Send both pairs off for separate processing.                  List<Diff> diffs_a = diff_main(text1_a' text2_a' checklines' deadline);                  List<Diff> diffs_b = diff_main(text1_b' text2_b' checklines' deadline);                  // Merge the results.                  diffs = diffs_a;                  diffs.Add(new Diff(Operation.EQUAL' mid_common));                  diffs.AddRange(diffs_b);                  return diffs;              }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\S7ProjectBlockComparer\DiffMatchPatch.cs,diff_compute,The following statement contains a magic number: if (checklines && text1.Length > 100 && text2.Length > 100)              {                  return diff_lineMode(text1' text2' deadline);              }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\S7ProjectBlockComparer\DiffMatchPatch.cs,diff_compute,The following statement contains a magic number: if (checklines && text1.Length > 100 && text2.Length > 100)              {                  return diff_lineMode(text1' text2' deadline);              }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\S7ProjectBlockComparer\DiffMatchPatch.cs,diff_lineMode,The following statement contains a magic number: List<string> linearray = (List<string>)b[2];
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\S7ProjectBlockComparer\DiffMatchPatch.cs,diff_bisect,The following statement contains a magic number: int max_d = (text1_length + text2_length + 1) / 2;
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\S7ProjectBlockComparer\DiffMatchPatch.cs,diff_bisect,The following statement contains a magic number: int v_length = 2 * max_d;
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\S7ProjectBlockComparer\DiffMatchPatch.cs,diff_bisect,The following statement contains a magic number: bool front = (delta % 2 != 0);
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\S7ProjectBlockComparer\DiffMatchPatch.cs,diff_bisect,The following statement contains a magic number: for (int d = 0; d < max_d; d++)              {                  // Bail out if deadline is reached.                  if (DateTime.Now > deadline)                  {                      break;                  }                    // Walk the front path one step.                  for (int k1 = -d + k1start; k1 <= d - k1end; k1 += 2)                  {                      int k1_offset = v_offset + k1;                      int x1;                      if (k1 == -d || k1 != d && v1[k1_offset - 1] < v1[k1_offset + 1])                      {                          x1 = v1[k1_offset + 1];                      }                      else                      {                          x1 = v1[k1_offset - 1] + 1;                      }                      int y1 = x1 - k1;                      while (x1 < text1_length && y1 < text2_length && text1[x1] == text2[y1])                      {                          x1++;                          y1++;                      }                      v1[k1_offset] = x1;                      if (x1 > text1_length)                      {                          // Ran off the right of the graph.                          k1end += 2;                      }                      else if (y1 > text2_length)                      {                          // Ran off the bottom of the graph.                          k1start += 2;                      }                      else if (front)                      {                          int k2_offset = v_offset + delta - k1;                          if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] != -1)                          {                              // Mirror x2 onto top-left coordinate system.                              int x2 = text1_length - v2[k2_offset];                              if (x1 >= x2)                              {                                  // Overlap detected.                                  return diff_bisectSplit(text1' text2' x1' y1' deadline);                              }                          }                      }                  }                    // Walk the reverse path one step.                  for (int k2 = -d + k2start; k2 <= d - k2end; k2 += 2)                  {                      int k2_offset = v_offset + k2;                      int x2;                      if (k2 == -d || k2 != d && v2[k2_offset - 1] < v2[k2_offset + 1])                      {                          x2 = v2[k2_offset + 1];                      }                      else                      {                          x2 = v2[k2_offset - 1] + 1;                      }                      int y2 = x2 - k2;                      while (x2 < text1_length && y2 < text2_length && text1[text1_length - x2 - 1] == text2[text2_length - y2 - 1])                      {                          x2++;                          y2++;                      }                      v2[k2_offset] = x2;                      if (x2 > text1_length)                      {                          // Ran off the left of the graph.                          k2end += 2;                      }                      else if (y2 > text2_length)                      {                          // Ran off the top of the graph.                          k2start += 2;                      }                      else if (!front)                      {                          int k1_offset = v_offset + delta - k2;                          if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] != -1)                          {                              int x1 = v1[k1_offset];                              int y1 = v_offset + x1 - k1_offset;                              // Mirror x2 onto top-left coordinate system.                              x2 = text1_length - v2[k2_offset];                              if (x1 >= x2)                              {                                  // Overlap detected.                                  return diff_bisectSplit(text1' text2' x1' y1' deadline);                              }                          }                      }                  }              }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\S7ProjectBlockComparer\DiffMatchPatch.cs,diff_bisect,The following statement contains a magic number: for (int d = 0; d < max_d; d++)              {                  // Bail out if deadline is reached.                  if (DateTime.Now > deadline)                  {                      break;                  }                    // Walk the front path one step.                  for (int k1 = -d + k1start; k1 <= d - k1end; k1 += 2)                  {                      int k1_offset = v_offset + k1;                      int x1;                      if (k1 == -d || k1 != d && v1[k1_offset - 1] < v1[k1_offset + 1])                      {                          x1 = v1[k1_offset + 1];                      }                      else                      {                          x1 = v1[k1_offset - 1] + 1;                      }                      int y1 = x1 - k1;                      while (x1 < text1_length && y1 < text2_length && text1[x1] == text2[y1])                      {                          x1++;                          y1++;                      }                      v1[k1_offset] = x1;                      if (x1 > text1_length)                      {                          // Ran off the right of the graph.                          k1end += 2;                      }                      else if (y1 > text2_length)                      {                          // Ran off the bottom of the graph.                          k1start += 2;                      }                      else if (front)                      {                          int k2_offset = v_offset + delta - k1;                          if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] != -1)                          {                              // Mirror x2 onto top-left coordinate system.                              int x2 = text1_length - v2[k2_offset];                              if (x1 >= x2)                              {                                  // Overlap detected.                                  return diff_bisectSplit(text1' text2' x1' y1' deadline);                              }                          }                      }                  }                    // Walk the reverse path one step.                  for (int k2 = -d + k2start; k2 <= d - k2end; k2 += 2)                  {                      int k2_offset = v_offset + k2;                      int x2;                      if (k2 == -d || k2 != d && v2[k2_offset - 1] < v2[k2_offset + 1])                      {                          x2 = v2[k2_offset + 1];                      }                      else                      {                          x2 = v2[k2_offset - 1] + 1;                      }                      int y2 = x2 - k2;                      while (x2 < text1_length && y2 < text2_length && text1[text1_length - x2 - 1] == text2[text2_length - y2 - 1])                      {                          x2++;                          y2++;                      }                      v2[k2_offset] = x2;                      if (x2 > text1_length)                      {                          // Ran off the left of the graph.                          k2end += 2;                      }                      else if (y2 > text2_length)                      {                          // Ran off the top of the graph.                          k2start += 2;                      }                      else if (!front)                      {                          int k1_offset = v_offset + delta - k2;                          if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] != -1)                          {                              int x1 = v1[k1_offset];                              int y1 = v_offset + x1 - k1_offset;                              // Mirror x2 onto top-left coordinate system.                              x2 = text1_length - v2[k2_offset];                              if (x1 >= x2)                              {                                  // Overlap detected.                                  return diff_bisectSplit(text1' text2' x1' y1' deadline);                              }                          }                      }                  }              }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\S7ProjectBlockComparer\DiffMatchPatch.cs,diff_bisect,The following statement contains a magic number: for (int d = 0; d < max_d; d++)              {                  // Bail out if deadline is reached.                  if (DateTime.Now > deadline)                  {                      break;                  }                    // Walk the front path one step.                  for (int k1 = -d + k1start; k1 <= d - k1end; k1 += 2)                  {                      int k1_offset = v_offset + k1;                      int x1;                      if (k1 == -d || k1 != d && v1[k1_offset - 1] < v1[k1_offset + 1])                      {                          x1 = v1[k1_offset + 1];                      }                      else                      {                          x1 = v1[k1_offset - 1] + 1;                      }                      int y1 = x1 - k1;                      while (x1 < text1_length && y1 < text2_length && text1[x1] == text2[y1])                      {                          x1++;                          y1++;                      }                      v1[k1_offset] = x1;                      if (x1 > text1_length)                      {                          // Ran off the right of the graph.                          k1end += 2;                      }                      else if (y1 > text2_length)                      {                          // Ran off the bottom of the graph.                          k1start += 2;                      }                      else if (front)                      {                          int k2_offset = v_offset + delta - k1;                          if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] != -1)                          {                              // Mirror x2 onto top-left coordinate system.                              int x2 = text1_length - v2[k2_offset];                              if (x1 >= x2)                              {                                  // Overlap detected.                                  return diff_bisectSplit(text1' text2' x1' y1' deadline);                              }                          }                      }                  }                    // Walk the reverse path one step.                  for (int k2 = -d + k2start; k2 <= d - k2end; k2 += 2)                  {                      int k2_offset = v_offset + k2;                      int x2;                      if (k2 == -d || k2 != d && v2[k2_offset - 1] < v2[k2_offset + 1])                      {                          x2 = v2[k2_offset + 1];                      }                      else                      {                          x2 = v2[k2_offset - 1] + 1;                      }                      int y2 = x2 - k2;                      while (x2 < text1_length && y2 < text2_length && text1[text1_length - x2 - 1] == text2[text2_length - y2 - 1])                      {                          x2++;                          y2++;                      }                      v2[k2_offset] = x2;                      if (x2 > text1_length)                      {                          // Ran off the left of the graph.                          k2end += 2;                      }                      else if (y2 > text2_length)                      {                          // Ran off the top of the graph.                          k2start += 2;                      }                      else if (!front)                      {                          int k1_offset = v_offset + delta - k2;                          if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] != -1)                          {                              int x1 = v1[k1_offset];                              int y1 = v_offset + x1 - k1_offset;                              // Mirror x2 onto top-left coordinate system.                              x2 = text1_length - v2[k2_offset];                              if (x1 >= x2)                              {                                  // Overlap detected.                                  return diff_bisectSplit(text1' text2' x1' y1' deadline);                              }                          }                      }                  }              }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\S7ProjectBlockComparer\DiffMatchPatch.cs,diff_bisect,The following statement contains a magic number: for (int d = 0; d < max_d; d++)              {                  // Bail out if deadline is reached.                  if (DateTime.Now > deadline)                  {                      break;                  }                    // Walk the front path one step.                  for (int k1 = -d + k1start; k1 <= d - k1end; k1 += 2)                  {                      int k1_offset = v_offset + k1;                      int x1;                      if (k1 == -d || k1 != d && v1[k1_offset - 1] < v1[k1_offset + 1])                      {                          x1 = v1[k1_offset + 1];                      }                      else                      {                          x1 = v1[k1_offset - 1] + 1;                      }                      int y1 = x1 - k1;                      while (x1 < text1_length && y1 < text2_length && text1[x1] == text2[y1])                      {                          x1++;                          y1++;                      }                      v1[k1_offset] = x1;                      if (x1 > text1_length)                      {                          // Ran off the right of the graph.                          k1end += 2;                      }                      else if (y1 > text2_length)                      {                          // Ran off the bottom of the graph.                          k1start += 2;                      }                      else if (front)                      {                          int k2_offset = v_offset + delta - k1;                          if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] != -1)                          {                              // Mirror x2 onto top-left coordinate system.                              int x2 = text1_length - v2[k2_offset];                              if (x1 >= x2)                              {                                  // Overlap detected.                                  return diff_bisectSplit(text1' text2' x1' y1' deadline);                              }                          }                      }                  }                    // Walk the reverse path one step.                  for (int k2 = -d + k2start; k2 <= d - k2end; k2 += 2)                  {                      int k2_offset = v_offset + k2;                      int x2;                      if (k2 == -d || k2 != d && v2[k2_offset - 1] < v2[k2_offset + 1])                      {                          x2 = v2[k2_offset + 1];                      }                      else                      {                          x2 = v2[k2_offset - 1] + 1;                      }                      int y2 = x2 - k2;                      while (x2 < text1_length && y2 < text2_length && text1[text1_length - x2 - 1] == text2[text2_length - y2 - 1])                      {                          x2++;                          y2++;                      }                      v2[k2_offset] = x2;                      if (x2 > text1_length)                      {                          // Ran off the left of the graph.                          k2end += 2;                      }                      else if (y2 > text2_length)                      {                          // Ran off the top of the graph.                          k2start += 2;                      }                      else if (!front)                      {                          int k1_offset = v_offset + delta - k2;                          if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] != -1)                          {                              int x1 = v1[k1_offset];                              int y1 = v_offset + x1 - k1_offset;                              // Mirror x2 onto top-left coordinate system.                              x2 = text1_length - v2[k2_offset];                              if (x1 >= x2)                              {                                  // Overlap detected.                                  return diff_bisectSplit(text1' text2' x1' y1' deadline);                              }                          }                      }                  }              }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\S7ProjectBlockComparer\DiffMatchPatch.cs,diff_bisect,The following statement contains a magic number: for (int d = 0; d < max_d; d++)              {                  // Bail out if deadline is reached.                  if (DateTime.Now > deadline)                  {                      break;                  }                    // Walk the front path one step.                  for (int k1 = -d + k1start; k1 <= d - k1end; k1 += 2)                  {                      int k1_offset = v_offset + k1;                      int x1;                      if (k1 == -d || k1 != d && v1[k1_offset - 1] < v1[k1_offset + 1])                      {                          x1 = v1[k1_offset + 1];                      }                      else                      {                          x1 = v1[k1_offset - 1] + 1;                      }                      int y1 = x1 - k1;                      while (x1 < text1_length && y1 < text2_length && text1[x1] == text2[y1])                      {                          x1++;                          y1++;                      }                      v1[k1_offset] = x1;                      if (x1 > text1_length)                      {                          // Ran off the right of the graph.                          k1end += 2;                      }                      else if (y1 > text2_length)                      {                          // Ran off the bottom of the graph.                          k1start += 2;                      }                      else if (front)                      {                          int k2_offset = v_offset + delta - k1;                          if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] != -1)                          {                              // Mirror x2 onto top-left coordinate system.                              int x2 = text1_length - v2[k2_offset];                              if (x1 >= x2)                              {                                  // Overlap detected.                                  return diff_bisectSplit(text1' text2' x1' y1' deadline);                              }                          }                      }                  }                    // Walk the reverse path one step.                  for (int k2 = -d + k2start; k2 <= d - k2end; k2 += 2)                  {                      int k2_offset = v_offset + k2;                      int x2;                      if (k2 == -d || k2 != d && v2[k2_offset - 1] < v2[k2_offset + 1])                      {                          x2 = v2[k2_offset + 1];                      }                      else                      {                          x2 = v2[k2_offset - 1] + 1;                      }                      int y2 = x2 - k2;                      while (x2 < text1_length && y2 < text2_length && text1[text1_length - x2 - 1] == text2[text2_length - y2 - 1])                      {                          x2++;                          y2++;                      }                      v2[k2_offset] = x2;                      if (x2 > text1_length)                      {                          // Ran off the left of the graph.                          k2end += 2;                      }                      else if (y2 > text2_length)                      {                          // Ran off the top of the graph.                          k2start += 2;                      }                      else if (!front)                      {                          int k1_offset = v_offset + delta - k2;                          if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] != -1)                          {                              int x1 = v1[k1_offset];                              int y1 = v_offset + x1 - k1_offset;                              // Mirror x2 onto top-left coordinate system.                              x2 = text1_length - v2[k2_offset];                              if (x1 >= x2)                              {                                  // Overlap detected.                                  return diff_bisectSplit(text1' text2' x1' y1' deadline);                              }                          }                      }                  }              }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\S7ProjectBlockComparer\DiffMatchPatch.cs,diff_bisect,The following statement contains a magic number: for (int d = 0; d < max_d; d++)              {                  // Bail out if deadline is reached.                  if (DateTime.Now > deadline)                  {                      break;                  }                    // Walk the front path one step.                  for (int k1 = -d + k1start; k1 <= d - k1end; k1 += 2)                  {                      int k1_offset = v_offset + k1;                      int x1;                      if (k1 == -d || k1 != d && v1[k1_offset - 1] < v1[k1_offset + 1])                      {                          x1 = v1[k1_offset + 1];                      }                      else                      {                          x1 = v1[k1_offset - 1] + 1;                      }                      int y1 = x1 - k1;                      while (x1 < text1_length && y1 < text2_length && text1[x1] == text2[y1])                      {                          x1++;                          y1++;                      }                      v1[k1_offset] = x1;                      if (x1 > text1_length)                      {                          // Ran off the right of the graph.                          k1end += 2;                      }                      else if (y1 > text2_length)                      {                          // Ran off the bottom of the graph.                          k1start += 2;                      }                      else if (front)                      {                          int k2_offset = v_offset + delta - k1;                          if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] != -1)                          {                              // Mirror x2 onto top-left coordinate system.                              int x2 = text1_length - v2[k2_offset];                              if (x1 >= x2)                              {                                  // Overlap detected.                                  return diff_bisectSplit(text1' text2' x1' y1' deadline);                              }                          }                      }                  }                    // Walk the reverse path one step.                  for (int k2 = -d + k2start; k2 <= d - k2end; k2 += 2)                  {                      int k2_offset = v_offset + k2;                      int x2;                      if (k2 == -d || k2 != d && v2[k2_offset - 1] < v2[k2_offset + 1])                      {                          x2 = v2[k2_offset + 1];                      }                      else                      {                          x2 = v2[k2_offset - 1] + 1;                      }                      int y2 = x2 - k2;                      while (x2 < text1_length && y2 < text2_length && text1[text1_length - x2 - 1] == text2[text2_length - y2 - 1])                      {                          x2++;                          y2++;                      }                      v2[k2_offset] = x2;                      if (x2 > text1_length)                      {                          // Ran off the left of the graph.                          k2end += 2;                      }                      else if (y2 > text2_length)                      {                          // Ran off the top of the graph.                          k2start += 2;                      }                      else if (!front)                      {                          int k1_offset = v_offset + delta - k2;                          if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] != -1)                          {                              int x1 = v1[k1_offset];                              int y1 = v_offset + x1 - k1_offset;                              // Mirror x2 onto top-left coordinate system.                              x2 = text1_length - v2[k2_offset];                              if (x1 >= x2)                              {                                  // Overlap detected.                                  return diff_bisectSplit(text1' text2' x1' y1' deadline);                              }                          }                      }                  }              }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\S7ProjectBlockComparer\DiffMatchPatch.cs,diff_halfMatch,The following statement contains a magic number: if (longtext.Length < 4 || shorttext.Length * 2 < longtext.Length)              {                  return null; // Pointless.              }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\S7ProjectBlockComparer\DiffMatchPatch.cs,diff_halfMatch,The following statement contains a magic number: if (longtext.Length < 4 || shorttext.Length * 2 < longtext.Length)              {                  return null; // Pointless.              }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\S7ProjectBlockComparer\DiffMatchPatch.cs,diff_halfMatch,The following statement contains a magic number: string[] hm1 = diff_halfMatchI(longtext' shorttext' (longtext.Length + 3) / 4);
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\S7ProjectBlockComparer\DiffMatchPatch.cs,diff_halfMatch,The following statement contains a magic number: string[] hm1 = diff_halfMatchI(longtext' shorttext' (longtext.Length + 3) / 4);
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\S7ProjectBlockComparer\DiffMatchPatch.cs,diff_halfMatch,The following statement contains a magic number: string[] hm2 = diff_halfMatchI(longtext' shorttext' (longtext.Length + 1) / 2);
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\S7ProjectBlockComparer\DiffMatchPatch.cs,diff_halfMatch,The following statement contains a magic number: if (hm1 == null && hm2 == null)              {                  return null;              }              else if (hm2 == null)              {                  hm = hm1;              }              else if (hm1 == null)              {                  hm = hm2;              }              else              {                  // Both matched.  Select the longest.                  hm = hm1[4].Length > hm2[4].Length ? hm1 : hm2;              }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\S7ProjectBlockComparer\DiffMatchPatch.cs,diff_halfMatch,The following statement contains a magic number: if (hm1 == null && hm2 == null)              {                  return null;              }              else if (hm2 == null)              {                  hm = hm1;              }              else if (hm1 == null)              {                  hm = hm2;              }              else              {                  // Both matched.  Select the longest.                  hm = hm1[4].Length > hm2[4].Length ? hm1 : hm2;              }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\S7ProjectBlockComparer\DiffMatchPatch.cs,diff_halfMatch,The following statement contains a magic number: if (text1.Length > text2.Length)              {                  return hm;                  //return new string[]{hm[0]' hm[1]' hm[2]' hm[3]' hm[4]};              }              else              {                  return new string[] { hm[2]' hm[3]' hm[0]' hm[1]' hm[4] };              }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\S7ProjectBlockComparer\DiffMatchPatch.cs,diff_halfMatch,The following statement contains a magic number: if (text1.Length > text2.Length)              {                  return hm;                  //return new string[]{hm[0]' hm[1]' hm[2]' hm[3]' hm[4]};              }              else              {                  return new string[] { hm[2]' hm[3]' hm[0]' hm[1]' hm[4] };              }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\S7ProjectBlockComparer\DiffMatchPatch.cs,diff_halfMatch,The following statement contains a magic number: if (text1.Length > text2.Length)              {                  return hm;                  //return new string[]{hm[0]' hm[1]' hm[2]' hm[3]' hm[4]};              }              else              {                  return new string[] { hm[2]' hm[3]' hm[0]' hm[1]' hm[4] };              }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\S7ProjectBlockComparer\DiffMatchPatch.cs,diff_halfMatchI,The following statement contains a magic number: string seed = longtext.Substring(i' longtext.Length / 4);
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\S7ProjectBlockComparer\DiffMatchPatch.cs,diff_halfMatchI,The following statement contains a magic number: if (best_common.Length * 2 >= longtext.Length)              {                  return new string[] { best_longtext_a' best_longtext_b' best_shorttext_a' best_shorttext_b' best_common };              }              else              {                  return null;              }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\S7ProjectBlockComparer\DiffMatchPatch.cs,diff_cleanupSemantic,The following statement contains a magic number: while (pointer < diffs.Count)              {                  if (diffs[pointer - 1].operation == Operation.DELETE && diffs[pointer].operation == Operation.INSERT)                  {                      string deletion = diffs[pointer - 1].text;                      string insertion = diffs[pointer].text;                      int overlap_length1 = diff_commonOverlap(deletion' insertion);                      int overlap_length2 = diff_commonOverlap(insertion' deletion);                      if (overlap_length1 >= overlap_length2)                      {                          if (overlap_length1 >= deletion.Length / 2.0 || overlap_length1 >= insertion.Length / 2.0)                          {                              // Overlap found.                              // Insert an equality and trim the surrounding edits.                              diffs.Insert(pointer' new Diff(Operation.EQUAL' insertion.Substring(0' overlap_length1)));                              diffs[pointer - 1].text = deletion.Substring(0' deletion.Length - overlap_length1);                              diffs[pointer + 1].text = insertion.Substring(overlap_length1);                              pointer++;                          }                      }                      else                      {                          if (overlap_length2 >= deletion.Length / 2.0 || overlap_length2 >= insertion.Length / 2.0)                          {                              // Reverse overlap found.                              // Insert an equality and swap and trim the surrounding edits.                              diffs.Insert(pointer' new Diff(Operation.EQUAL' deletion.Substring(0' overlap_length2)));                              diffs[pointer - 1].operation = Operation.INSERT;                              diffs[pointer - 1].text = insertion.Substring(0' insertion.Length - overlap_length2);                              diffs[pointer + 1].operation = Operation.DELETE;                              diffs[pointer + 1].text = deletion.Substring(overlap_length2);                              pointer++;                          }                      }                      pointer++;                  }                  pointer++;              }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\S7ProjectBlockComparer\DiffMatchPatch.cs,diff_cleanupSemantic,The following statement contains a magic number: while (pointer < diffs.Count)              {                  if (diffs[pointer - 1].operation == Operation.DELETE && diffs[pointer].operation == Operation.INSERT)                  {                      string deletion = diffs[pointer - 1].text;                      string insertion = diffs[pointer].text;                      int overlap_length1 = diff_commonOverlap(deletion' insertion);                      int overlap_length2 = diff_commonOverlap(insertion' deletion);                      if (overlap_length1 >= overlap_length2)                      {                          if (overlap_length1 >= deletion.Length / 2.0 || overlap_length1 >= insertion.Length / 2.0)                          {                              // Overlap found.                              // Insert an equality and trim the surrounding edits.                              diffs.Insert(pointer' new Diff(Operation.EQUAL' insertion.Substring(0' overlap_length1)));                              diffs[pointer - 1].text = deletion.Substring(0' deletion.Length - overlap_length1);                              diffs[pointer + 1].text = insertion.Substring(overlap_length1);                              pointer++;                          }                      }                      else                      {                          if (overlap_length2 >= deletion.Length / 2.0 || overlap_length2 >= insertion.Length / 2.0)                          {                              // Reverse overlap found.                              // Insert an equality and swap and trim the surrounding edits.                              diffs.Insert(pointer' new Diff(Operation.EQUAL' deletion.Substring(0' overlap_length2)));                              diffs[pointer - 1].operation = Operation.INSERT;                              diffs[pointer - 1].text = insertion.Substring(0' insertion.Length - overlap_length2);                              diffs[pointer + 1].operation = Operation.DELETE;                              diffs[pointer + 1].text = deletion.Substring(overlap_length2);                              pointer++;                          }                      }                      pointer++;                  }                  pointer++;              }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\S7ProjectBlockComparer\DiffMatchPatch.cs,diff_cleanupSemantic,The following statement contains a magic number: while (pointer < diffs.Count)              {                  if (diffs[pointer - 1].operation == Operation.DELETE && diffs[pointer].operation == Operation.INSERT)                  {                      string deletion = diffs[pointer - 1].text;                      string insertion = diffs[pointer].text;                      int overlap_length1 = diff_commonOverlap(deletion' insertion);                      int overlap_length2 = diff_commonOverlap(insertion' deletion);                      if (overlap_length1 >= overlap_length2)                      {                          if (overlap_length1 >= deletion.Length / 2.0 || overlap_length1 >= insertion.Length / 2.0)                          {                              // Overlap found.                              // Insert an equality and trim the surrounding edits.                              diffs.Insert(pointer' new Diff(Operation.EQUAL' insertion.Substring(0' overlap_length1)));                              diffs[pointer - 1].text = deletion.Substring(0' deletion.Length - overlap_length1);                              diffs[pointer + 1].text = insertion.Substring(overlap_length1);                              pointer++;                          }                      }                      else                      {                          if (overlap_length2 >= deletion.Length / 2.0 || overlap_length2 >= insertion.Length / 2.0)                          {                              // Reverse overlap found.                              // Insert an equality and swap and trim the surrounding edits.                              diffs.Insert(pointer' new Diff(Operation.EQUAL' deletion.Substring(0' overlap_length2)));                              diffs[pointer - 1].operation = Operation.INSERT;                              diffs[pointer - 1].text = insertion.Substring(0' insertion.Length - overlap_length2);                              diffs[pointer + 1].operation = Operation.DELETE;                              diffs[pointer + 1].text = deletion.Substring(overlap_length2);                              pointer++;                          }                      }                      pointer++;                  }                  pointer++;              }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\S7ProjectBlockComparer\DiffMatchPatch.cs,diff_cleanupSemantic,The following statement contains a magic number: while (pointer < diffs.Count)              {                  if (diffs[pointer - 1].operation == Operation.DELETE && diffs[pointer].operation == Operation.INSERT)                  {                      string deletion = diffs[pointer - 1].text;                      string insertion = diffs[pointer].text;                      int overlap_length1 = diff_commonOverlap(deletion' insertion);                      int overlap_length2 = diff_commonOverlap(insertion' deletion);                      if (overlap_length1 >= overlap_length2)                      {                          if (overlap_length1 >= deletion.Length / 2.0 || overlap_length1 >= insertion.Length / 2.0)                          {                              // Overlap found.                              // Insert an equality and trim the surrounding edits.                              diffs.Insert(pointer' new Diff(Operation.EQUAL' insertion.Substring(0' overlap_length1)));                              diffs[pointer - 1].text = deletion.Substring(0' deletion.Length - overlap_length1);                              diffs[pointer + 1].text = insertion.Substring(overlap_length1);                              pointer++;                          }                      }                      else                      {                          if (overlap_length2 >= deletion.Length / 2.0 || overlap_length2 >= insertion.Length / 2.0)                          {                              // Reverse overlap found.                              // Insert an equality and swap and trim the surrounding edits.                              diffs.Insert(pointer' new Diff(Operation.EQUAL' deletion.Substring(0' overlap_length2)));                              diffs[pointer - 1].operation = Operation.INSERT;                              diffs[pointer - 1].text = insertion.Substring(0' insertion.Length - overlap_length2);                              diffs[pointer + 1].operation = Operation.DELETE;                              diffs[pointer + 1].text = deletion.Substring(overlap_length2);                              pointer++;                          }                      }                      pointer++;                  }                  pointer++;              }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\S7ProjectBlockComparer\DiffMatchPatch.cs,diff_cleanupSemanticScore,The following statement contains a magic number: if (one.Length == 0 || two.Length == 0)              {                  // Edges are the best.                  return 6;              }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\S7ProjectBlockComparer\DiffMatchPatch.cs,diff_cleanupSemanticScore,The following statement contains a magic number: if (blankLine1 || blankLine2)              {                  // Five points for blank lines.                  return 5;              }              else if (lineBreak1 || lineBreak2)              {                  // Four points for line breaks.                  return 4;              }              else if (nonAlphaNumeric1 && !whitespace1 && whitespace2)              {                  // Three points for end of sentences.                  return 3;              }              else if (whitespace1 || whitespace2)              {                  // Two points for whitespace.                  return 2;              }              else if (nonAlphaNumeric1 || nonAlphaNumeric2)              {                  // One point for non-alphanumeric.                  return 1;              }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\S7ProjectBlockComparer\DiffMatchPatch.cs,diff_cleanupSemanticScore,The following statement contains a magic number: if (blankLine1 || blankLine2)              {                  // Five points for blank lines.                  return 5;              }              else if (lineBreak1 || lineBreak2)              {                  // Four points for line breaks.                  return 4;              }              else if (nonAlphaNumeric1 && !whitespace1 && whitespace2)              {                  // Three points for end of sentences.                  return 3;              }              else if (whitespace1 || whitespace2)              {                  // Two points for whitespace.                  return 2;              }              else if (nonAlphaNumeric1 || nonAlphaNumeric2)              {                  // One point for non-alphanumeric.                  return 1;              }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\S7ProjectBlockComparer\DiffMatchPatch.cs,diff_cleanupSemanticScore,The following statement contains a magic number: if (blankLine1 || blankLine2)              {                  // Five points for blank lines.                  return 5;              }              else if (lineBreak1 || lineBreak2)              {                  // Four points for line breaks.                  return 4;              }              else if (nonAlphaNumeric1 && !whitespace1 && whitespace2)              {                  // Three points for end of sentences.                  return 3;              }              else if (whitespace1 || whitespace2)              {                  // Two points for whitespace.                  return 2;              }              else if (nonAlphaNumeric1 || nonAlphaNumeric2)              {                  // One point for non-alphanumeric.                  return 1;              }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\S7ProjectBlockComparer\DiffMatchPatch.cs,diff_cleanupSemanticScore,The following statement contains a magic number: if (blankLine1 || blankLine2)              {                  // Five points for blank lines.                  return 5;              }              else if (lineBreak1 || lineBreak2)              {                  // Four points for line breaks.                  return 4;              }              else if (nonAlphaNumeric1 && !whitespace1 && whitespace2)              {                  // Three points for end of sentences.                  return 3;              }              else if (whitespace1 || whitespace2)              {                  // Two points for whitespace.                  return 2;              }              else if (nonAlphaNumeric1 || nonAlphaNumeric2)              {                  // One point for non-alphanumeric.                  return 1;              }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\S7ProjectBlockComparer\DiffMatchPatch.cs,diff_cleanupEfficiency,The following statement contains a magic number: while (pointer < diffs.Count)              {                  if (diffs[pointer].operation == Operation.EQUAL)                  {                      // Equality found.                      if (diffs[pointer].text.Length < this.Diff_EditCost && (post_ins || post_del))                      {                          // Candidate found.                          equalities.Push(pointer);                          pre_ins = post_ins;                          pre_del = post_del;                          lastequality = diffs[pointer].text;                      }                      else                      {                          // Not a candidate' and can never become one.                          equalities.Clear();                          lastequality = string.Empty;                      }                      post_ins = post_del = false;                  }                  else                  {                      // An insertion or deletion.                      if (diffs[pointer].operation == Operation.DELETE)                      {                          post_del = true;                      }                      else                      {                          post_ins = true;                      }                      /*                       * Five types to be split:                       * <ins>A</ins><del>B</del>XY<ins>C</ins><del>D</del>                       * <ins>A</ins>X<ins>C</ins><del>D</del>                       * <ins>A</ins><del>B</del>X<ins>C</ins>                       * <ins>A</del>X<ins>C</ins><del>D</del>                       * <ins>A</ins><del>B</del>X<del>C</del>                       */                      if ((lastequality.Length != 0) && ((pre_ins && pre_del && post_ins && post_del) || ((lastequality.Length < this.Diff_EditCost / 2) && ((pre_ins ? 1 : 0) + (pre_del ? 1 : 0) + (post_ins ? 1 : 0) + (post_del ? 1 : 0)) == 3)))                      {                          // Duplicate record.                          diffs.Insert(equalities.Peek()' new Diff(Operation.DELETE' lastequality));                          // Change second copy to insert.                          diffs[equalities.Peek() + 1].operation = Operation.INSERT;                          equalities.Pop(); // Throw away the equality we just deleted.                          lastequality = string.Empty;                          if (pre_ins && pre_del)                          {                              // No changes made which could affect previous entry' keep going.                              post_ins = post_del = true;                              equalities.Clear();                          }                          else                          {                              if (equalities.Count > 0)                              {                                  equalities.Pop();                              }                                pointer = equalities.Count > 0 ? equalities.Peek() : -1;                              post_ins = post_del = false;                          }                          changes = true;                      }                  }                  pointer++;              }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\S7ProjectBlockComparer\DiffMatchPatch.cs,diff_cleanupEfficiency,The following statement contains a magic number: while (pointer < diffs.Count)              {                  if (diffs[pointer].operation == Operation.EQUAL)                  {                      // Equality found.                      if (diffs[pointer].text.Length < this.Diff_EditCost && (post_ins || post_del))                      {                          // Candidate found.                          equalities.Push(pointer);                          pre_ins = post_ins;                          pre_del = post_del;                          lastequality = diffs[pointer].text;                      }                      else                      {                          // Not a candidate' and can never become one.                          equalities.Clear();                          lastequality = string.Empty;                      }                      post_ins = post_del = false;                  }                  else                  {                      // An insertion or deletion.                      if (diffs[pointer].operation == Operation.DELETE)                      {                          post_del = true;                      }                      else                      {                          post_ins = true;                      }                      /*                       * Five types to be split:                       * <ins>A</ins><del>B</del>XY<ins>C</ins><del>D</del>                       * <ins>A</ins>X<ins>C</ins><del>D</del>                       * <ins>A</ins><del>B</del>X<ins>C</ins>                       * <ins>A</del>X<ins>C</ins><del>D</del>                       * <ins>A</ins><del>B</del>X<del>C</del>                       */                      if ((lastequality.Length != 0) && ((pre_ins && pre_del && post_ins && post_del) || ((lastequality.Length < this.Diff_EditCost / 2) && ((pre_ins ? 1 : 0) + (pre_del ? 1 : 0) + (post_ins ? 1 : 0) + (post_del ? 1 : 0)) == 3)))                      {                          // Duplicate record.                          diffs.Insert(equalities.Peek()' new Diff(Operation.DELETE' lastequality));                          // Change second copy to insert.                          diffs[equalities.Peek() + 1].operation = Operation.INSERT;                          equalities.Pop(); // Throw away the equality we just deleted.                          lastequality = string.Empty;                          if (pre_ins && pre_del)                          {                              // No changes made which could affect previous entry' keep going.                              post_ins = post_del = true;                              equalities.Clear();                          }                          else                          {                              if (equalities.Count > 0)                              {                                  equalities.Pop();                              }                                pointer = equalities.Count > 0 ? equalities.Peek() : -1;                              post_ins = post_del = false;                          }                          changes = true;                      }                  }                  pointer++;              }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\S7ProjectBlockComparer\DiffMatchPatch.cs,match_bitap,The following statement contains a magic number: for (int d = 0; d < pattern.Length; d++)              {                  // Scan for the best match; each iteration allows for one more error.                  // Run a binary search to determine how far from 'loc' we can stray at                  // this error level.                  bin_min = 0;                  bin_mid = bin_max;                  while (bin_min < bin_mid)                  {                      if (match_bitapScore(d' loc + bin_mid' loc' pattern) <= score_threshold)                      {                          bin_min = bin_mid;                      }                      else                      {                          bin_max = bin_mid;                      }                      bin_mid = (bin_max - bin_min) / 2 + bin_min;                  }                  // Use the result from this iteration as the maximum for the next.                  bin_max = bin_mid;                  int start = Math.Max(1' loc - bin_mid + 1);                  int finish = Math.Min(loc + bin_mid' text.Length) + pattern.Length;                    int[] rd = new int[finish + 2];                  rd[finish + 1] = (1 << d) - 1;                  for (int j = finish; j >= start; j--)                  {                      int charMatch;                      if (text.Length <= j - 1 || !s.ContainsKey(text[j - 1]))                      {                          // Out of range.                          charMatch = 0;                      }                      else                      {                          charMatch = s[text[j - 1]];                      }                      if (d == 0)                      {                          // First pass: exact match.                          rd[j] = ((rd[j + 1] << 1) | 1) & charMatch;                      }                      else                      {                          // Subsequent passes: fuzzy match.                          rd[j] = ((rd[j + 1] << 1) | 1) & charMatch | (((last_rd[j + 1] | last_rd[j]) << 1) | 1) | last_rd[j + 1];                      }                      if ((rd[j] & matchmask) != 0)                      {                          double score = match_bitapScore(d' j - 1' loc' pattern);                          // This match will almost certainly be better than any existing                          // match.  But check anyway.                          if (score <= score_threshold)                          {                              // Told you so.                              score_threshold = score;                              best_loc = j - 1;                              if (best_loc > loc)                              {                                  // When passing loc' don't exceed our current distance from loc.                                  start = Math.Max(1' 2 * loc - best_loc);                              }                              else                              {                                  // Already passed loc' downhill from here on in.                                  break;                              }                          }                      }                  }                  if (match_bitapScore(d + 1' loc' loc' pattern) > score_threshold)                  {                      // No hope for a (better) match at greater error levels.                      break;                  }                  last_rd = rd;              }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\S7ProjectBlockComparer\DiffMatchPatch.cs,match_bitap,The following statement contains a magic number: for (int d = 0; d < pattern.Length; d++)              {                  // Scan for the best match; each iteration allows for one more error.                  // Run a binary search to determine how far from 'loc' we can stray at                  // this error level.                  bin_min = 0;                  bin_mid = bin_max;                  while (bin_min < bin_mid)                  {                      if (match_bitapScore(d' loc + bin_mid' loc' pattern) <= score_threshold)                      {                          bin_min = bin_mid;                      }                      else                      {                          bin_max = bin_mid;                      }                      bin_mid = (bin_max - bin_min) / 2 + bin_min;                  }                  // Use the result from this iteration as the maximum for the next.                  bin_max = bin_mid;                  int start = Math.Max(1' loc - bin_mid + 1);                  int finish = Math.Min(loc + bin_mid' text.Length) + pattern.Length;                    int[] rd = new int[finish + 2];                  rd[finish + 1] = (1 << d) - 1;                  for (int j = finish; j >= start; j--)                  {                      int charMatch;                      if (text.Length <= j - 1 || !s.ContainsKey(text[j - 1]))                      {                          // Out of range.                          charMatch = 0;                      }                      else                      {                          charMatch = s[text[j - 1]];                      }                      if (d == 0)                      {                          // First pass: exact match.                          rd[j] = ((rd[j + 1] << 1) | 1) & charMatch;                      }                      else                      {                          // Subsequent passes: fuzzy match.                          rd[j] = ((rd[j + 1] << 1) | 1) & charMatch | (((last_rd[j + 1] | last_rd[j]) << 1) | 1) | last_rd[j + 1];                      }                      if ((rd[j] & matchmask) != 0)                      {                          double score = match_bitapScore(d' j - 1' loc' pattern);                          // This match will almost certainly be better than any existing                          // match.  But check anyway.                          if (score <= score_threshold)                          {                              // Told you so.                              score_threshold = score;                              best_loc = j - 1;                              if (best_loc > loc)                              {                                  // When passing loc' don't exceed our current distance from loc.                                  start = Math.Max(1' 2 * loc - best_loc);                              }                              else                              {                                  // Already passed loc' downhill from here on in.                                  break;                              }                          }                      }                  }                  if (match_bitapScore(d + 1' loc' loc' pattern) > score_threshold)                  {                      // No hope for a (better) match at greater error levels.                      break;                  }                  last_rd = rd;              }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\S7ProjectBlockComparer\DiffMatchPatch.cs,match_bitap,The following statement contains a magic number: for (int d = 0; d < pattern.Length; d++)              {                  // Scan for the best match; each iteration allows for one more error.                  // Run a binary search to determine how far from 'loc' we can stray at                  // this error level.                  bin_min = 0;                  bin_mid = bin_max;                  while (bin_min < bin_mid)                  {                      if (match_bitapScore(d' loc + bin_mid' loc' pattern) <= score_threshold)                      {                          bin_min = bin_mid;                      }                      else                      {                          bin_max = bin_mid;                      }                      bin_mid = (bin_max - bin_min) / 2 + bin_min;                  }                  // Use the result from this iteration as the maximum for the next.                  bin_max = bin_mid;                  int start = Math.Max(1' loc - bin_mid + 1);                  int finish = Math.Min(loc + bin_mid' text.Length) + pattern.Length;                    int[] rd = new int[finish + 2];                  rd[finish + 1] = (1 << d) - 1;                  for (int j = finish; j >= start; j--)                  {                      int charMatch;                      if (text.Length <= j - 1 || !s.ContainsKey(text[j - 1]))                      {                          // Out of range.                          charMatch = 0;                      }                      else                      {                          charMatch = s[text[j - 1]];                      }                      if (d == 0)                      {                          // First pass: exact match.                          rd[j] = ((rd[j + 1] << 1) | 1) & charMatch;                      }                      else                      {                          // Subsequent passes: fuzzy match.                          rd[j] = ((rd[j + 1] << 1) | 1) & charMatch | (((last_rd[j + 1] | last_rd[j]) << 1) | 1) | last_rd[j + 1];                      }                      if ((rd[j] & matchmask) != 0)                      {                          double score = match_bitapScore(d' j - 1' loc' pattern);                          // This match will almost certainly be better than any existing                          // match.  But check anyway.                          if (score <= score_threshold)                          {                              // Told you so.                              score_threshold = score;                              best_loc = j - 1;                              if (best_loc > loc)                              {                                  // When passing loc' don't exceed our current distance from loc.                                  start = Math.Max(1' 2 * loc - best_loc);                              }                              else                              {                                  // Already passed loc' downhill from here on in.                                  break;                              }                          }                      }                  }                  if (match_bitapScore(d + 1' loc' loc' pattern) > score_threshold)                  {                      // No hope for a (better) match at greater error levels.                      break;                  }                  last_rd = rd;              }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\S7ProjectBlockComparer\DiffMatchPatch.cs,patch_make,The following statement contains a magic number: if (diffs.Count > 2)              {                  diff_cleanupSemantic(diffs);                  diff_cleanupEfficiency(diffs);              }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\S7ProjectBlockComparer\DiffMatchPatch.cs,patch_make,The following statement contains a magic number: foreach (Diff aDiff in diffs)              {                  if (patch.diffs.Count == 0 && aDiff.operation != Operation.EQUAL)                  {                      // A new patch starts here.                      patch.start1 = char_count1;                      patch.start2 = char_count2;                  }                    switch (aDiff.operation)                  {                      case Operation.INSERT:                          patch.diffs.Add(aDiff);                          patch.length2 += aDiff.text.Length;                          postpatch_text = postpatch_text.Insert(char_count2' aDiff.text);                          break;                      case Operation.DELETE:                          patch.length1 += aDiff.text.Length;                          patch.diffs.Add(aDiff);                          postpatch_text = postpatch_text.Remove(char_count2' aDiff.text.Length);                          break;                      case Operation.EQUAL:                          if (aDiff.text.Length <= 2 * Patch_Margin && patch.diffs.Count() != 0 && aDiff != diffs.Last())                          {                              // Small equality inside a patch.                              patch.diffs.Add(aDiff);                              patch.length1 += aDiff.text.Length;                              patch.length2 += aDiff.text.Length;                          }                            if (aDiff.text.Length >= 2 * Patch_Margin)                          {                              // Time for a new patch.                              if (patch.diffs.Count != 0)                              {                                  patch_addContext(patch' prepatch_text);                                  patches.Add(patch);                                  patch = new Patch();                                  // Unlike Unidiff' our patch lists have a rolling context.                                  // http://code.google.com/p/google-diff-match-patch/wiki/Unidiff                                  // Update prepatch text & pos to reflect the application of the                                  // just completed patch.                                  prepatch_text = postpatch_text;                                  char_count1 = char_count2;                              }                          }                          break;                  }                    // Update the current character count.                  if (aDiff.operation != Operation.INSERT)                  {                      char_count1 += aDiff.text.Length;                  }                  if (aDiff.operation != Operation.DELETE)                  {                      char_count2 += aDiff.text.Length;                  }              }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\S7ProjectBlockComparer\DiffMatchPatch.cs,patch_make,The following statement contains a magic number: foreach (Diff aDiff in diffs)              {                  if (patch.diffs.Count == 0 && aDiff.operation != Operation.EQUAL)                  {                      // A new patch starts here.                      patch.start1 = char_count1;                      patch.start2 = char_count2;                  }                    switch (aDiff.operation)                  {                      case Operation.INSERT:                          patch.diffs.Add(aDiff);                          patch.length2 += aDiff.text.Length;                          postpatch_text = postpatch_text.Insert(char_count2' aDiff.text);                          break;                      case Operation.DELETE:                          patch.length1 += aDiff.text.Length;                          patch.diffs.Add(aDiff);                          postpatch_text = postpatch_text.Remove(char_count2' aDiff.text.Length);                          break;                      case Operation.EQUAL:                          if (aDiff.text.Length <= 2 * Patch_Margin && patch.diffs.Count() != 0 && aDiff != diffs.Last())                          {                              // Small equality inside a patch.                              patch.diffs.Add(aDiff);                              patch.length1 += aDiff.text.Length;                              patch.length2 += aDiff.text.Length;                          }                            if (aDiff.text.Length >= 2 * Patch_Margin)                          {                              // Time for a new patch.                              if (patch.diffs.Count != 0)                              {                                  patch_addContext(patch' prepatch_text);                                  patches.Add(patch);                                  patch = new Patch();                                  // Unlike Unidiff' our patch lists have a rolling context.                                  // http://code.google.com/p/google-diff-match-patch/wiki/Unidiff                                  // Update prepatch text & pos to reflect the application of the                                  // just completed patch.                                  prepatch_text = postpatch_text;                                  char_count1 = char_count2;                              }                          }                          break;                  }                    // Update the current character count.                  if (aDiff.operation != Operation.INSERT)                  {                      char_count1 += aDiff.text.Length;                  }                  if (aDiff.operation != Operation.DELETE)                  {                      char_count2 += aDiff.text.Length;                  }              }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\S7ProjectBlockComparer\DiffMatchPatch.cs,patch_apply,The following statement contains a magic number: text = text.Substring(nullPadding.Length' text.Length - 2 * nullPadding.Length);
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\S7ProjectBlockComparer\DiffMatchPatch.cs,patch_splitMax,The following statement contains a magic number: for (int x = 0; x < patches.Count; x++)              {                  if (patches[x].length1 <= patch_size)                  {                      continue;                  }                  Patch bigpatch = patches[x];                  // Remove the big old patch.                  patches.Splice(x--' 1);                  int start1 = bigpatch.start1;                  int start2 = bigpatch.start2;                  string precontext = string.Empty;                  while (bigpatch.diffs.Count != 0)                  {                      // Create one of several smaller patches.                      Patch patch = new Patch();                      bool empty = true;                      patch.start1 = start1 - precontext.Length;                      patch.start2 = start2 - precontext.Length;                      if (precontext.Length != 0)                      {                          patch.length1 = patch.length2 = precontext.Length;                          patch.diffs.Add(new Diff(Operation.EQUAL' precontext));                      }                      while (bigpatch.diffs.Count != 0 && patch.length1 < patch_size - this.Patch_Margin)                      {                          Operation diff_type = bigpatch.diffs[0].operation;                          string diff_text = bigpatch.diffs[0].text;                          if (diff_type == Operation.INSERT)                          {                              // Insertions are harmless.                              patch.length2 += diff_text.Length;                              start2 += diff_text.Length;                              patch.diffs.Add(bigpatch.diffs.First());                              bigpatch.diffs.RemoveAt(0);                              empty = false;                          }                          else if (diff_type == Operation.DELETE && patch.diffs.Count == 1 && patch.diffs.First().operation == Operation.EQUAL && diff_text.Length > 2 * patch_size)                          {                              // This is a large deletion.  Let it pass in one chunk.                              patch.length1 += diff_text.Length;                              start1 += diff_text.Length;                              empty = false;                              patch.diffs.Add(new Diff(diff_type' diff_text));                              bigpatch.diffs.RemoveAt(0);                          }                          else                          {                              // Deletion or equality.  Only take as much as we can stomach.                              diff_text = diff_text.Substring(0' Math.Min(diff_text.Length' patch_size - patch.length1 - Patch_Margin));                              patch.length1 += diff_text.Length;                              start1 += diff_text.Length;                              if (diff_type == Operation.EQUAL)                              {                                  patch.length2 += diff_text.Length;                                  start2 += diff_text.Length;                              }                              else                              {                                  empty = false;                              }                              patch.diffs.Add(new Diff(diff_type' diff_text));                              if (diff_text == bigpatch.diffs[0].text)                              {                                  bigpatch.diffs.RemoveAt(0);                              }                              else                              {                                  bigpatch.diffs[0].text = bigpatch.diffs[0].text.Substring(diff_text.Length);                              }                          }                      }                      // Compute the head context for the next patch.                      precontext = this.diff_text2(patch.diffs);                      precontext = precontext.Substring(Math.Max(0' precontext.Length - this.Patch_Margin));                        string postcontext = null;                      // Append the end context for this patch.                      if (diff_text1(bigpatch.diffs).Length > Patch_Margin)                      {                          postcontext = diff_text1(bigpatch.diffs).Substring(0' Patch_Margin);                      }                      else                      {                          postcontext = diff_text1(bigpatch.diffs);                      }                        if (postcontext.Length != 0)                      {                          patch.length1 += postcontext.Length;                          patch.length2 += postcontext.Length;                          if (patch.diffs.Count != 0 && patch.diffs[patch.diffs.Count - 1].operation == Operation.EQUAL)                          {                              patch.diffs[patch.diffs.Count - 1].text += postcontext;                          }                          else                          {                              patch.diffs.Add(new Diff(Operation.EQUAL' postcontext));                          }                      }                      if (!empty)                      {                          patches.Splice(++x' 0' patch);                      }                  }              }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\S7ProjectBlockComparer\DiffMatchPatch.cs,patch_fromText,The following statement contains a magic number: while (textPointer < text.Length)              {                  m = patchHeader.Match(text[textPointer]);                  if (!m.Success)                  {                      throw new ArgumentException("Invalid patch string: " + text[textPointer]);                  }                  patch = new Patch();                  patches.Add(patch);                  patch.start1 = Convert.ToInt32(m.Groups[1].Value);                  if (m.Groups[2].Length == 0)                  {                      patch.start1--;                      patch.length1 = 1;                  }                  else if (m.Groups[2].Value == "0")                  {                      patch.length1 = 0;                  }                  else                  {                      patch.start1--;                      patch.length1 = Convert.ToInt32(m.Groups[2].Value);                  }                    patch.start2 = Convert.ToInt32(m.Groups[3].Value);                  if (m.Groups[4].Length == 0)                  {                      patch.start2--;                      patch.length2 = 1;                  }                  else if (m.Groups[4].Value == "0")                  {                      patch.length2 = 0;                  }                  else                  {                      patch.start2--;                      patch.length2 = Convert.ToInt32(m.Groups[4].Value);                  }                  textPointer++;                    while (textPointer < text.Length)                  {                      try                      {                          sign = text[textPointer][0];                      }                      catch (IndexOutOfRangeException)                      {                          // Blank line?  Whatever.                          textPointer++;                          continue;                      }                      line = text[textPointer].Substring(1);                      line = line.Replace("+"' "%2b");                      line = HttpUtility.UrlDecode(line' new UTF8Encoding(false' true));                      if (sign == '-')                      {                          // Deletion.                          patch.diffs.Add(new Diff(Operation.DELETE' line));                      }                      else if (sign == '+')                      {                          // Insertion.                          patch.diffs.Add(new Diff(Operation.INSERT' line));                      }                      else if (sign == ' ')                      {                          // Minor equality.                          patch.diffs.Add(new Diff(Operation.EQUAL' line));                      }                      else if (sign == '@')                      {                          // Start of next patch.                          break;                      }                      else                      {                          // WTF?                          throw new ArgumentException("Invalid patch mode '" + sign + "' in: " + line);                      }                      textPointer++;                  }              }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\S7ProjectBlockComparer\DiffMatchPatch.cs,patch_fromText,The following statement contains a magic number: while (textPointer < text.Length)              {                  m = patchHeader.Match(text[textPointer]);                  if (!m.Success)                  {                      throw new ArgumentException("Invalid patch string: " + text[textPointer]);                  }                  patch = new Patch();                  patches.Add(patch);                  patch.start1 = Convert.ToInt32(m.Groups[1].Value);                  if (m.Groups[2].Length == 0)                  {                      patch.start1--;                      patch.length1 = 1;                  }                  else if (m.Groups[2].Value == "0")                  {                      patch.length1 = 0;                  }                  else                  {                      patch.start1--;                      patch.length1 = Convert.ToInt32(m.Groups[2].Value);                  }                    patch.start2 = Convert.ToInt32(m.Groups[3].Value);                  if (m.Groups[4].Length == 0)                  {                      patch.start2--;                      patch.length2 = 1;                  }                  else if (m.Groups[4].Value == "0")                  {                      patch.length2 = 0;                  }                  else                  {                      patch.start2--;                      patch.length2 = Convert.ToInt32(m.Groups[4].Value);                  }                  textPointer++;                    while (textPointer < text.Length)                  {                      try                      {                          sign = text[textPointer][0];                      }                      catch (IndexOutOfRangeException)                      {                          // Blank line?  Whatever.                          textPointer++;                          continue;                      }                      line = text[textPointer].Substring(1);                      line = line.Replace("+"' "%2b");                      line = HttpUtility.UrlDecode(line' new UTF8Encoding(false' true));                      if (sign == '-')                      {                          // Deletion.                          patch.diffs.Add(new Diff(Operation.DELETE' line));                      }                      else if (sign == '+')                      {                          // Insertion.                          patch.diffs.Add(new Diff(Operation.INSERT' line));                      }                      else if (sign == ' ')                      {                          // Minor equality.                          patch.diffs.Add(new Diff(Operation.EQUAL' line));                      }                      else if (sign == '@')                      {                          // Start of next patch.                          break;                      }                      else                      {                          // WTF?                          throw new ArgumentException("Invalid patch mode '" + sign + "' in: " + line);                      }                      textPointer++;                  }              }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\S7ProjectBlockComparer\DiffMatchPatch.cs,patch_fromText,The following statement contains a magic number: while (textPointer < text.Length)              {                  m = patchHeader.Match(text[textPointer]);                  if (!m.Success)                  {                      throw new ArgumentException("Invalid patch string: " + text[textPointer]);                  }                  patch = new Patch();                  patches.Add(patch);                  patch.start1 = Convert.ToInt32(m.Groups[1].Value);                  if (m.Groups[2].Length == 0)                  {                      patch.start1--;                      patch.length1 = 1;                  }                  else if (m.Groups[2].Value == "0")                  {                      patch.length1 = 0;                  }                  else                  {                      patch.start1--;                      patch.length1 = Convert.ToInt32(m.Groups[2].Value);                  }                    patch.start2 = Convert.ToInt32(m.Groups[3].Value);                  if (m.Groups[4].Length == 0)                  {                      patch.start2--;                      patch.length2 = 1;                  }                  else if (m.Groups[4].Value == "0")                  {                      patch.length2 = 0;                  }                  else                  {                      patch.start2--;                      patch.length2 = Convert.ToInt32(m.Groups[4].Value);                  }                  textPointer++;                    while (textPointer < text.Length)                  {                      try                      {                          sign = text[textPointer][0];                      }                      catch (IndexOutOfRangeException)                      {                          // Blank line?  Whatever.                          textPointer++;                          continue;                      }                      line = text[textPointer].Substring(1);                      line = line.Replace("+"' "%2b");                      line = HttpUtility.UrlDecode(line' new UTF8Encoding(false' true));                      if (sign == '-')                      {                          // Deletion.                          patch.diffs.Add(new Diff(Operation.DELETE' line));                      }                      else if (sign == '+')                      {                          // Insertion.                          patch.diffs.Add(new Diff(Operation.INSERT' line));                      }                      else if (sign == ' ')                      {                          // Minor equality.                          patch.diffs.Add(new Diff(Operation.EQUAL' line));                      }                      else if (sign == '@')                      {                          // Start of next patch.                          break;                      }                      else                      {                          // WTF?                          throw new ArgumentException("Invalid patch mode '" + sign + "' in: " + line);                      }                      textPointer++;                  }              }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\S7ProjectBlockComparer\DiffMatchPatch.cs,patch_fromText,The following statement contains a magic number: while (textPointer < text.Length)              {                  m = patchHeader.Match(text[textPointer]);                  if (!m.Success)                  {                      throw new ArgumentException("Invalid patch string: " + text[textPointer]);                  }                  patch = new Patch();                  patches.Add(patch);                  patch.start1 = Convert.ToInt32(m.Groups[1].Value);                  if (m.Groups[2].Length == 0)                  {                      patch.start1--;                      patch.length1 = 1;                  }                  else if (m.Groups[2].Value == "0")                  {                      patch.length1 = 0;                  }                  else                  {                      patch.start1--;                      patch.length1 = Convert.ToInt32(m.Groups[2].Value);                  }                    patch.start2 = Convert.ToInt32(m.Groups[3].Value);                  if (m.Groups[4].Length == 0)                  {                      patch.start2--;                      patch.length2 = 1;                  }                  else if (m.Groups[4].Value == "0")                  {                      patch.length2 = 0;                  }                  else                  {                      patch.start2--;                      patch.length2 = Convert.ToInt32(m.Groups[4].Value);                  }                  textPointer++;                    while (textPointer < text.Length)                  {                      try                      {                          sign = text[textPointer][0];                      }                      catch (IndexOutOfRangeException)                      {                          // Blank line?  Whatever.                          textPointer++;                          continue;                      }                      line = text[textPointer].Substring(1);                      line = line.Replace("+"' "%2b");                      line = HttpUtility.UrlDecode(line' new UTF8Encoding(false' true));                      if (sign == '-')                      {                          // Deletion.                          patch.diffs.Add(new Diff(Operation.DELETE' line));                      }                      else if (sign == '+')                      {                          // Insertion.                          patch.diffs.Add(new Diff(Operation.INSERT' line));                      }                      else if (sign == ' ')                      {                          // Minor equality.                          patch.diffs.Add(new Diff(Operation.EQUAL' line));                      }                      else if (sign == '@')                      {                          // Start of next patch.                          break;                      }                      else                      {                          // WTF?                          throw new ArgumentException("Invalid patch mode '" + sign + "' in: " + line);                      }                      textPointer++;                  }              }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\S7ProjectBlockComparer\DiffMatchPatch.cs,patch_fromText,The following statement contains a magic number: while (textPointer < text.Length)              {                  m = patchHeader.Match(text[textPointer]);                  if (!m.Success)                  {                      throw new ArgumentException("Invalid patch string: " + text[textPointer]);                  }                  patch = new Patch();                  patches.Add(patch);                  patch.start1 = Convert.ToInt32(m.Groups[1].Value);                  if (m.Groups[2].Length == 0)                  {                      patch.start1--;                      patch.length1 = 1;                  }                  else if (m.Groups[2].Value == "0")                  {                      patch.length1 = 0;                  }                  else                  {                      patch.start1--;                      patch.length1 = Convert.ToInt32(m.Groups[2].Value);                  }                    patch.start2 = Convert.ToInt32(m.Groups[3].Value);                  if (m.Groups[4].Length == 0)                  {                      patch.start2--;                      patch.length2 = 1;                  }                  else if (m.Groups[4].Value == "0")                  {                      patch.length2 = 0;                  }                  else                  {                      patch.start2--;                      patch.length2 = Convert.ToInt32(m.Groups[4].Value);                  }                  textPointer++;                    while (textPointer < text.Length)                  {                      try                      {                          sign = text[textPointer][0];                      }                      catch (IndexOutOfRangeException)                      {                          // Blank line?  Whatever.                          textPointer++;                          continue;                      }                      line = text[textPointer].Substring(1);                      line = line.Replace("+"' "%2b");                      line = HttpUtility.UrlDecode(line' new UTF8Encoding(false' true));                      if (sign == '-')                      {                          // Deletion.                          patch.diffs.Add(new Diff(Operation.DELETE' line));                      }                      else if (sign == '+')                      {                          // Insertion.                          patch.diffs.Add(new Diff(Operation.INSERT' line));                      }                      else if (sign == ' ')                      {                          // Minor equality.                          patch.diffs.Add(new Diff(Operation.EQUAL' line));                      }                      else if (sign == '@')                      {                          // Start of next patch.                          break;                      }                      else                      {                          // WTF?                          throw new ArgumentException("Invalid patch mode '" + sign + "' in: " + line);                      }                      textPointer++;                  }              }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\S7ProjectBlockComparer\DiffMatchPatch.cs,patch_fromText,The following statement contains a magic number: while (textPointer < text.Length)              {                  m = patchHeader.Match(text[textPointer]);                  if (!m.Success)                  {                      throw new ArgumentException("Invalid patch string: " + text[textPointer]);                  }                  patch = new Patch();                  patches.Add(patch);                  patch.start1 = Convert.ToInt32(m.Groups[1].Value);                  if (m.Groups[2].Length == 0)                  {                      patch.start1--;                      patch.length1 = 1;                  }                  else if (m.Groups[2].Value == "0")                  {                      patch.length1 = 0;                  }                  else                  {                      patch.start1--;                      patch.length1 = Convert.ToInt32(m.Groups[2].Value);                  }                    patch.start2 = Convert.ToInt32(m.Groups[3].Value);                  if (m.Groups[4].Length == 0)                  {                      patch.start2--;                      patch.length2 = 1;                  }                  else if (m.Groups[4].Value == "0")                  {                      patch.length2 = 0;                  }                  else                  {                      patch.start2--;                      patch.length2 = Convert.ToInt32(m.Groups[4].Value);                  }                  textPointer++;                    while (textPointer < text.Length)                  {                      try                      {                          sign = text[textPointer][0];                      }                      catch (IndexOutOfRangeException)                      {                          // Blank line?  Whatever.                          textPointer++;                          continue;                      }                      line = text[textPointer].Substring(1);                      line = line.Replace("+"' "%2b");                      line = HttpUtility.UrlDecode(line' new UTF8Encoding(false' true));                      if (sign == '-')                      {                          // Deletion.                          patch.diffs.Add(new Diff(Operation.DELETE' line));                      }                      else if (sign == '+')                      {                          // Insertion.                          patch.diffs.Add(new Diff(Operation.INSERT' line));                      }                      else if (sign == ' ')                      {                          // Minor equality.                          patch.diffs.Add(new Diff(Operation.EQUAL' line));                      }                      else if (sign == '@')                      {                          // Start of next patch.                          break;                      }                      else                      {                          // WTF?                          throw new ArgumentException("Invalid patch mode '" + sign + "' in: " + line);                      }                      textPointer++;                  }              }
Magic Number,DiffMatchPatch,diff_match_patch,C:\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\S7ProjectBlockComparer\DiffMatchPatch.cs,patch_fromText,The following statement contains a magic number: while (textPointer < text.Length)              {                  m = patchHeader.Match(text[textPointer]);                  if (!m.Success)                  {                      throw new ArgumentException("Invalid patch string: " + text[textPointer]);                  }                  patch = new Patch();                  patches.Add(patch);                  patch.start1 = Convert.ToInt32(m.Groups[1].Value);                  if (m.Groups[2].Length == 0)                  {                      patch.start1--;                      patch.length1 = 1;                  }                  else if (m.Groups[2].Value == "0")                  {                      patch.length1 = 0;                  }                  else                  {                      patch.start1--;                      patch.length1 = Convert.ToInt32(m.Groups[2].Value);                  }                    patch.start2 = Convert.ToInt32(m.Groups[3].Value);                  if (m.Groups[4].Length == 0)                  {                      patch.start2--;                      patch.length2 = 1;                  }                  else if (m.Groups[4].Value == "0")                  {                      patch.length2 = 0;                  }                  else                  {                      patch.start2--;                      patch.length2 = Convert.ToInt32(m.Groups[4].Value);                  }                  textPointer++;                    while (textPointer < text.Length)                  {                      try                      {                          sign = text[textPointer][0];                      }                      catch (IndexOutOfRangeException)                      {                          // Blank line?  Whatever.                          textPointer++;                          continue;                      }                      line = text[textPointer].Substring(1);                      line = line.Replace("+"' "%2b");                      line = HttpUtility.UrlDecode(line' new UTF8Encoding(false' true));                      if (sign == '-')                      {                          // Deletion.                          patch.diffs.Add(new Diff(Operation.DELETE' line));                      }                      else if (sign == '+')                      {                          // Insertion.                          patch.diffs.Add(new Diff(Operation.INSERT' line));                      }                      else if (sign == ' ')                      {                          // Minor equality.                          patch.diffs.Add(new Diff(Operation.EQUAL' line));                      }                      else if (sign == '@')                      {                          // Start of next patch.                          break;                      }                      else                      {                          // WTF?                          throw new ArgumentException("Invalid patch mode '" + sign + "' in: " + line);                      }                      textPointer++;                  }              }
Missing Default,S7ProjectBlockComparer,MainWindow,C:\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\S7ProjectBlockComparer\MainWindow.xaml.cs,Connect,The following switch statement is missing a default case: switch (connectionId)              {              case 1:              this.busy = ((Xceed.Wpf.Toolkit.BusyIndicator)(target));              return;              case 2:              this.akBlock = ((System.Windows.Controls.TextBlock)(target));              return;              case 3:              this.prj1 = ((System.Windows.Controls.TextBlock)(target));              return;              case 4:              this.cmdPrj1 = ((System.Windows.Controls.Button)(target));                            #line 20 "..\..\MainWindow.xaml"              this.cmdPrj1.Click += new System.Windows.RoutedEventHandler(this.cmdPrj1_Click);                            #line default              #line hidden              return;              case 5:              this.prj2 = ((System.Windows.Controls.TextBlock)(target));              return;              case 6:              this.cmdPrj2 = ((System.Windows.Controls.Button)(target));                            #line 25 "..\..\MainWindow.xaml"              this.cmdPrj2.Click += new System.Windows.RoutedEventHandler(this.cmdPrj2_Click);                            #line default              #line hidden              return;              case 7:              this.cmdComp = ((System.Windows.Controls.Button)(target));                            #line 26 "..\..\MainWindow.xaml"              this.cmdComp.Click += new System.Windows.RoutedEventHandler(this.cmdComp_Click);                            #line default              #line hidden              return;              case 8:              this.lstBlocks = ((System.Windows.Controls.ListBox)(target));                            #line 27 "..\..\MainWindow.xaml"              this.lstBlocks.MouseDoubleClick += new System.Windows.Input.MouseButtonEventHandler(this.lstBlocks_MouseDoubleClick);                            #line default              #line hidden              return;              case 9:              this.txtResult = ((ICSharpCode.AvalonEdit.TextEditor)(target));              return;              }
Missing Default,DiffMatchPatch,Patch,C:\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\S7ProjectBlockComparer\DiffMatchPatch.cs,ToString,The following switch statement is missing a default case: switch (aDiff.operation)                  {                      case Operation.INSERT:                          text.Append('+');                          break;                      case Operation.DELETE:                          text.Append('-');                          break;                      case Operation.EQUAL:                          text.Append(' ');                          break;                  }
Missing Default,DiffMatchPatch,diff_match_patch,C:\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\S7ProjectBlockComparer\DiffMatchPatch.cs,diff_lineMode,The following switch statement is missing a default case: switch (diffs[pointer].operation)                  {                      case Operation.INSERT:                          count_insert++;                          text_insert += diffs[pointer].text;                          break;                      case Operation.DELETE:                          count_delete++;                          text_delete += diffs[pointer].text;                          break;                      case Operation.EQUAL:                          // Upon reaching an equality' check for prior redundancies.                          if (count_delete >= 1 && count_insert >= 1)                          {                              // Delete the offending records and add the merged ones.                              diffs.RemoveRange(pointer - count_delete - count_insert' count_delete + count_insert);                              pointer = pointer - count_delete - count_insert;                              List<Diff> a = this.diff_main(text_delete' text_insert' false' deadline);                              diffs.InsertRange(pointer' a);                              pointer = pointer + a.Count;                          }                          count_insert = 0;                          count_delete = 0;                          text_delete = string.Empty;                          text_insert = string.Empty;                          break;                  }
Missing Default,DiffMatchPatch,diff_match_patch,C:\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\S7ProjectBlockComparer\DiffMatchPatch.cs,diff_cleanupMerge,The following switch statement is missing a default case: switch (diffs[pointer].operation)                  {                      case Operation.INSERT:                          count_insert++;                          text_insert += diffs[pointer].text;                          pointer++;                          break;                      case Operation.DELETE:                          count_delete++;                          text_delete += diffs[pointer].text;                          pointer++;                          break;                      case Operation.EQUAL:                          // Upon reaching an equality' check for prior redundancies.                          if (count_delete + count_insert > 1)                          {                              if (count_delete != 0 && count_insert != 0)                              {                                  // Factor out any common prefixies.                                  commonlength = this.diff_commonPrefix(text_insert' text_delete);                                  if (commonlength != 0)                                  {                                      if ((pointer - count_delete - count_insert) > 0 && diffs[pointer - count_delete - count_insert - 1].operation == Operation.EQUAL)                                      {                                          diffs[pointer - count_delete - count_insert - 1].text += text_insert.Substring(0' commonlength);                                      }                                      else                                      {                                          diffs.Insert(0' new Diff(Operation.EQUAL' text_insert.Substring(0' commonlength)));                                          pointer++;                                      }                                      text_insert = text_insert.Substring(commonlength);                                      text_delete = text_delete.Substring(commonlength);                                  }                                  // Factor out any common suffixies.                                  commonlength = this.diff_commonSuffix(text_insert' text_delete);                                  if (commonlength != 0)                                  {                                      diffs[pointer].text = text_insert.Substring(text_insert.Length - commonlength) + diffs[pointer].text;                                      text_insert = text_insert.Substring(0' text_insert.Length - commonlength);                                      text_delete = text_delete.Substring(0' text_delete.Length - commonlength);                                  }                              }                              // Delete the offending records and add the merged ones.                              if (count_delete == 0)                              {                                  diffs.Splice(pointer - count_insert' count_delete + count_insert' new Diff(Operation.INSERT' text_insert));                              }                              else if (count_insert == 0)                              {                                  diffs.Splice(pointer - count_delete' count_delete + count_insert' new Diff(Operation.DELETE' text_delete));                              }                              else                              {                                  diffs.Splice(pointer - count_delete - count_insert' count_delete + count_insert' new Diff(Operation.DELETE' text_delete)' new Diff(Operation.INSERT' text_insert));                              }                              pointer = pointer - count_delete - count_insert + (count_delete != 0 ? 1 : 0) + (count_insert != 0 ? 1 : 0) + 1;                          }                          else if (pointer != 0 && diffs[pointer - 1].operation == Operation.EQUAL)                          {                              // Merge this equality with the previous one.                              diffs[pointer - 1].text += diffs[pointer].text;                              diffs.RemoveAt(pointer);                          }                          else                          {                              pointer++;                          }                          count_insert = 0;                          count_delete = 0;                          text_delete = string.Empty;                          text_insert = string.Empty;                          break;                  }
Missing Default,DiffMatchPatch,diff_match_patch,C:\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\S7ProjectBlockComparer\DiffMatchPatch.cs,diff_prettyHtml,The following switch statement is missing a default case: switch (aDiff.operation)                  {                      case Operation.INSERT:                          html.Append("<ins style=\"background:#e6ffe6;\">").Append(text).Append("</ins>");                          break;                      case Operation.DELETE:                          html.Append("<del style=\"background:#ffe6e6;\">").Append(text).Append("</del>");                          break;                      case Operation.EQUAL:                          html.Append("<span>").Append(text).Append("</span>");                          break;                  }
Missing Default,DiffMatchPatch,diff_match_patch,C:\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\S7ProjectBlockComparer\DiffMatchPatch.cs,diff_levenshtein,The following switch statement is missing a default case: switch (aDiff.operation)                  {                      case Operation.INSERT:                          insertions += aDiff.text.Length;                          break;                      case Operation.DELETE:                          deletions += aDiff.text.Length;                          break;                      case Operation.EQUAL:                          // A deletion and an insertion is one substitution.                          levenshtein += Math.Max(insertions' deletions);                          insertions = 0;                          deletions = 0;                          break;                  }
Missing Default,DiffMatchPatch,diff_match_patch,C:\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\S7ProjectBlockComparer\DiffMatchPatch.cs,diff_toDelta,The following switch statement is missing a default case: switch (aDiff.operation)                  {                      case Operation.INSERT:                          text.Append("+").Append(HttpUtility.UrlEncode(aDiff.text' new UTF8Encoding()).Replace('+'' ' ')).Append("\t");                          break;                      case Operation.DELETE:                          text.Append("-").Append(aDiff.text.Length).Append("\t");                          break;                      case Operation.EQUAL:                          text.Append("=").Append(aDiff.text.Length).Append("\t");                          break;                  }
Missing Default,DiffMatchPatch,diff_match_patch,C:\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\S7ProjectBlockComparer\DiffMatchPatch.cs,patch_make,The following switch statement is missing a default case: switch (aDiff.operation)                  {                      case Operation.INSERT:                          patch.diffs.Add(aDiff);                          patch.length2 += aDiff.text.Length;                          postpatch_text = postpatch_text.Insert(char_count2' aDiff.text);                          break;                      case Operation.DELETE:                          patch.length1 += aDiff.text.Length;                          patch.diffs.Add(aDiff);                          postpatch_text = postpatch_text.Remove(char_count2' aDiff.text.Length);                          break;                      case Operation.EQUAL:                          if (aDiff.text.Length <= 2 * Patch_Margin && patch.diffs.Count() != 0 && aDiff != diffs.Last())                          {                              // Small equality inside a patch.                              patch.diffs.Add(aDiff);                              patch.length1 += aDiff.text.Length;                              patch.length2 += aDiff.text.Length;                          }                            if (aDiff.text.Length >= 2 * Patch_Margin)                          {                              // Time for a new patch.                              if (patch.diffs.Count != 0)                              {                                  patch_addContext(patch' prepatch_text);                                  patches.Add(patch);                                  patch = new Patch();                                  // Unlike Unidiff' our patch lists have a rolling context.                                  // http://code.google.com/p/google-diff-match-patch/wiki/Unidiff                                  // Update prepatch text & pos to reflect the application of the                                  // just completed patch.                                  prepatch_text = postpatch_text;                                  char_count1 = char_count2;                              }                          }                          break;                  }
