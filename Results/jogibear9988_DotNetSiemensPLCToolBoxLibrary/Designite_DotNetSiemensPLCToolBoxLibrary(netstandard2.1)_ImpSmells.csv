Implementation smell,Namespace,Class,File,Method,Description
Long Method,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,connectPLC,The method has 104 lines of code.
Long Method,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,putProgramBlock,The method has 152 lines of code.
Long Method,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,Connect,The method has 180 lines of code.
Long Method,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PLCstartRequestDiagnosticData,The method has 207 lines of code.
Long Method,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PLCGetSZL,The method has 149 lines of code.
Long Method,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,WriteValuesWithVarTabFunctions,The method has 108 lines of code.
Long Method,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,_TestNewReadValues,The method has 274 lines of code.
Long Method,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,ReadValues,The method has 408 lines of code.
Long Method,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,WriteValues,The method has 250 lines of code.
Long Method,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTag.cs,ParseControlValueFromString,The method has 214 lines of code.
Long Method,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTag.cs,GetValueAsStringInternal,The method has 212 lines of code.
Long Method,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTag.cs,ChangeAddressFromString,The method has 256 lines of code.
Long Method,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTag.cs,_putControlValueIntoBuffer,The method has 121 lines of code.
Long Method,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTag.cs,_readValueFromBuffer,The method has 369 lines of code.
Long Method,DotNetSiemensPLCToolBoxLibrary.DataTypes.Blocks.Step7V5,S7FunctionBlockRow,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Blocks\Step7V5\S7FunctionBlockRow.cs,_GetCommandStatusAskValues,The method has 100 lines of code.
Long Method,DotNetSiemensPLCToolBoxLibrary.DataTypes.Blocks.Step7V5,S7FunctionBlockRow,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Blocks\Step7V5\S7FunctionBlockRow.cs,ToString,The method has 104 lines of code.
Long Method,DotNetSiemensPLCToolBoxLibrary.DataTypes.Blocks.Step7V5,S7VATBlock,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Blocks\Step7V5\S7VATBlock.cs,S7VATBlock,The method has 228 lines of code.
Long Method,DotNetSiemensPLCToolBoxLibrary.DataTypes.Projectfolders.Step7V5,BlocksOfflineFolder,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Projectfolders\Step7V5\BlocksOfflineFolder.cs,GetBlockBytes,The method has 120 lines of code.
Long Method,DotNetSiemensPLCToolBoxLibrary.DataTypes.Projectfolders.Step7V5,BlocksOfflineFolder,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Projectfolders\Step7V5\BlocksOfflineFolder.cs,GetBlock,The method has 275 lines of code.
Long Method,DotNetSiemensPLCToolBoxLibrary.DBF,ParseDBF,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DBF\ParseDBF.cs,ReadDBF,The method has 180 lines of code.
Long Method,DotNetSiemensPLCToolBoxLibrary.DBF,ParseDBF,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DBF\ParseDBF.cs,WriteValue,The method has 127 lines of code.
Long Method,DotNetSiemensPLCToolBoxLibrary.PLCs.S5.MC5,MC5toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S5\MC5\MC5toAWL.cs,GetFunctionBlock,The method has 100 lines of code.
Long Method,DotNetSiemensPLCToolBoxLibrary.PLCs.S5.MC5,MC5toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S5\MC5\MC5toAWL.cs,GetMC5Rows,The method has 301 lines of code.
Long Method,DotNetSiemensPLCToolBoxLibrary.PLCs.S5.MC5,MC5toDB,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S5\MC5\MC5toDB.cs,GetDB,The method has 132 lines of code.
Long Method,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,AWLtoMC7,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\AWLtoMC7.cs,GetMC7,The method has 278 lines of code.
Long Method,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,CallConverter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\CallConverter.cs,ConvertUCToCall,The method has 630 lines of code.
Long Method,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7toAWL.cs,GetAWL,The method has 5437 lines of code.
Long Method,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Parameter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Parameter.cs,GetInterfaceOrDBFromStep7ProjectString,The method has 375 lines of code.
Long Method,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Parameter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Parameter.cs,GetInterface,The method has 113 lines of code.
Long Method,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Parameter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Parameter.cs,GetVarTypeEN,The method has 199 lines of code.
Long Method,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Parameter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Parameter.cs,GetVarInitialValue,The method has 105 lines of code.
Long Method,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Projects,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Projects.cs,GetStep7ProjectsFromDirectory,The method has 125 lines of code.
Long Method,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step5Project,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step5Project.cs,LoadProject,The method has 212 lines of code.
Long Method,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The method has 1123 lines of code.
Long Method,DotNetSiemensPLCToolBoxLibrary.Source,AWLSourceParser,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Source\AWLSourceParser.cs,ParseAWL,The method has 130 lines of code.
Complex Method,DotNetSiemensPLCToolBoxLibrary.Communication.FetchWrite,FetchWriteConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\FetchWrite\FetchWriteConnection.cs,ReadValue,Cyclomatic complexity of the method is 11
Complex Method,DotNetSiemensPLCToolBoxLibrary.Communication.FetchWrite,FetchWriteConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\FetchWrite\FetchWriteConnection.cs,WriteValue,Cyclomatic complexity of the method is 13
Complex Method,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,daveStrS7onlineError,Cyclomatic complexity of the method is 22
Complex Method,DotNetSiemensPLCToolBoxLibrary.Communication.Library,Connection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\Connection.cs,daveStrerror,Cyclomatic complexity of the method is 54
Complex Method,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,readSZL,Cyclomatic complexity of the method is 10
Complex Method,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,execReadRequest,Cyclomatic complexity of the method is 13
Complex Method,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,execWriteRequest,Cyclomatic complexity of the method is 9
Complex Method,DotNetSiemensPLCToolBoxLibrary.Communication.Networking,TCPFunctionsAsync,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Networking\TCPFunctionsAsync.cs,beginRead,Cyclomatic complexity of the method is 10
Complex Method,DotNetSiemensPLCToolBoxLibrary.Communication.Networking,TCPFunctionsAsync,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Networking\TCPFunctionsAsync.cs,DoReadCallback,Cyclomatic complexity of the method is 16
Complex Method,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,socket_Thread,Cyclomatic complexity of the method is 9
Complex Method,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,Connect,Cyclomatic complexity of the method is 15
Complex Method,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PLCstartRequestDiagnosticData,Cyclomatic complexity of the method is 20
Complex Method,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PLCGetState,Cyclomatic complexity of the method is 8
Complex Method,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PLCGetBlockInMC7,Cyclomatic complexity of the method is 10
Complex Method,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PLCPutBlockFromMC7toPLC,Cyclomatic complexity of the method is 10
Complex Method,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PLCGetSZL,Cyclomatic complexity of the method is 33
Complex Method,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,ReadValuesWithVarTabFunctions,Cyclomatic complexity of the method is 13
Complex Method,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,WriteValuesWithVarTabFunctions,Cyclomatic complexity of the method is 13
Complex Method,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,_TestNewReadValues,Cyclomatic complexity of the method is 37
Complex Method,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,ReadValues,Cyclomatic complexity of the method is 54
Complex Method,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,ReadValuesFetchWrite,Cyclomatic complexity of the method is 13
Complex Method,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,ReadValue,Cyclomatic complexity of the method is 11
Complex Method,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,WriteValue,Cyclomatic complexity of the method is 10
Complex Method,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,WriteValues,Cyclomatic complexity of the method is 28
Complex Method,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,Dispose,Cyclomatic complexity of the method is 8
Complex Method,DotNetSiemensPLCToolBoxLibrary.Communication,DiagnosticData,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,RequestDiagnosticData,Cyclomatic complexity of the method is 14
Complex Method,DotNetSiemensPLCToolBoxLibrary.Communication,VarTabReadData,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,RequestData,Cyclomatic complexity of the method is 10
Complex Method,DotNetSiemensPLCToolBoxLibrary.Communication,SorterForPLCTags,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,Compare,Cyclomatic complexity of the method is 10
Complex Method,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnectionConfiguration,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnectionConfiguration.cs,ToString,Cyclomatic complexity of the method is 16
Complex Method,DotNetSiemensPLCToolBoxLibrary.Communication,NC_Var,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCNckTag.cs,GetNckTag,Cyclomatic complexity of the method is 13
Complex Method,DotNetSiemensPLCToolBoxLibrary.Communication,NC_Var,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCNckTag.cs,GetNckType,Cyclomatic complexity of the method is 12
Complex Method,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTag.cs,PLCTag,Cyclomatic complexity of the method is 21
Complex Method,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTag.cs,ParseControlValueFromString,Cyclomatic complexity of the method is 42
Complex Method,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTag.cs,GetValueAsString,Cyclomatic complexity of the method is 11
Complex Method,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTag.cs,GetValueAsStringInternal,Cyclomatic complexity of the method is 50
Complex Method,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTag.cs,ChangeAddressFromString,Cyclomatic complexity of the method is 61
Complex Method,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTag.cs,ChangeDataTypeFromString,Cyclomatic complexity of the method is 26
Complex Method,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTag.cs,ChangeDataTypeStringFormatFromString,Cyclomatic complexity of the method is 16
Complex Method,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTag.cs,_putControlValueIntoBuffer,Cyclomatic complexity of the method is 30
Complex Method,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTag.cs,_readValueFromBuffer,Cyclomatic complexity of the method is 75
Complex Method,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag<T>,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTagGeneric.cs,ParseGenericType,Cyclomatic complexity of the method is 13
Complex Method,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag<T>,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTagGeneric.cs,FromBytes,Cyclomatic complexity of the method is 21
Complex Method,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag<T>,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTagGeneric.cs,GetStructSize,Cyclomatic complexity of the method is 12
Complex Method,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag<T>,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTagGeneric.cs,ToBytes,Cyclomatic complexity of the method is 15
Complex Method,DotNetSiemensPLCToolBoxLibrary.DataTypes,PLCBlockName,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\PLCBlockName.cs,PLCBlockName,Cyclomatic complexity of the method is 9
Complex Method,DotNetSiemensPLCToolBoxLibrary.DataTypes.Blocks,TiaAndSTep7DataBlockRow,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Blocks\TiaAndSTep7DataBlockRow.cs,_GetExpandedChlidren,Cyclomatic complexity of the method is 10
Complex Method,DotNetSiemensPLCToolBoxLibrary.DataTypes.Blocks,TiaAndSTep7DataBlockRow,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Blocks\TiaAndSTep7DataBlockRow.cs,GetDataRowWithAddress,Cyclomatic complexity of the method is 8
Complex Method,DotNetSiemensPLCToolBoxLibrary.DataTypes.Blocks.Step5,S5FunctionBlockRow,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Blocks\Step5\S5FunctionBlockRow.cs,ToString,Cyclomatic complexity of the method is 10
Complex Method,DotNetSiemensPLCToolBoxLibrary.DataTypes.Blocks.Step7V11,TIADataRow,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Blocks\Step7V11\TIADataRow.cs,FillBlockAddresses,Cyclomatic complexity of the method is 16
Complex Method,DotNetSiemensPLCToolBoxLibrary.DataTypes.Blocks.Step7V5,S7DataBlock,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Blocks\Step7V5\S7DataBlock.cs,GetSourceBlock,Cyclomatic complexity of the method is 12
Complex Method,DotNetSiemensPLCToolBoxLibrary.DataTypes.Blocks.Step7V5,S7DataRow,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Blocks\Step7V5\S7DataRow.cs,FillBlockAddresses,Cyclomatic complexity of the method is 16
Complex Method,DotNetSiemensPLCToolBoxLibrary.DataTypes.Blocks.Step7V5,S7DataRow,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Blocks\Step7V5\S7DataRow.cs,ToString,Cyclomatic complexity of the method is 10
Complex Method,DotNetSiemensPLCToolBoxLibrary.DataTypes.Blocks.Step7V5,S7FunctionBlock,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Blocks\Step7V5\S7FunctionBlock.cs,GetSourceBlock,Cyclomatic complexity of the method is 18
Complex Method,DotNetSiemensPLCToolBoxLibrary.DataTypes.Blocks.Step7V5,S7FunctionBlockRow,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Blocks\Step7V5\S7FunctionBlockRow.cs,_GetCommandStatusAskSize,Cyclomatic complexity of the method is 13
Complex Method,DotNetSiemensPLCToolBoxLibrary.DataTypes.Blocks.Step7V5,S7FunctionBlockRow,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Blocks\Step7V5\S7FunctionBlockRow.cs,_GetCommandStatusAskValues,Cyclomatic complexity of the method is 17
Complex Method,DotNetSiemensPLCToolBoxLibrary.DataTypes.Blocks.Step7V5,S7FunctionBlockRow,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Blocks\Step7V5\S7FunctionBlockRow.cs,ToString,Cyclomatic complexity of the method is 32
Complex Method,DotNetSiemensPLCToolBoxLibrary.DataTypes.Blocks.Step7V5,BlockStatus,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Blocks\Step7V5\S7FunctionBlockRow.cs,ToString,Cyclomatic complexity of the method is 8
Complex Method,DotNetSiemensPLCToolBoxLibrary.DataTypes.Blocks.Step7V5,S7VATBlock,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Blocks\Step7V5\S7VATBlock.cs,S7VATBlock,Cyclomatic complexity of the method is 34
Complex Method,DotNetSiemensPLCToolBoxLibrary.DataTypes.Projectfolders,OnlineBlocksFolder,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Projectfolders\OnlineBlocksFolder.cs,readPlcBlocksList,Cyclomatic complexity of the method is 10
Complex Method,DotNetSiemensPLCToolBoxLibrary.DataTypes.Projectfolders.Step5,ReferenceData,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Projectfolders\Step5\ReferenceData.cs,LoadReferenceData,Cyclomatic complexity of the method is 16
Complex Method,DotNetSiemensPLCToolBoxLibrary.DataTypes.Projectfolders.Step5,Step5BlocksFolder,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Projectfolders\Step5\Step5BlocksFolder.cs,GetBlock,Cyclomatic complexity of the method is 14
Complex Method,DotNetSiemensPLCToolBoxLibrary.DataTypes.Projectfolders.Step7V5,BlocksOfflineFolder,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Projectfolders\Step7V5\BlocksOfflineFolder.cs,intReadPlcBlocksList,Cyclomatic complexity of the method is 11
Complex Method,DotNetSiemensPLCToolBoxLibrary.DataTypes.Projectfolders.Step7V5,BlocksOfflineFolder,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Projectfolders\Step7V5\BlocksOfflineFolder.cs,GetBlockBytes,Cyclomatic complexity of the method is 25
Complex Method,DotNetSiemensPLCToolBoxLibrary.DataTypes.Projectfolders.Step7V5,BlocksOfflineFolder,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Projectfolders\Step7V5\BlocksOfflineFolder.cs,GetBlock,Cyclomatic complexity of the method is 41
Complex Method,DotNetSiemensPLCToolBoxLibrary.DataTypes.Projectfolders.Step7V5,SymbolTable,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Projectfolders\Step7V5\SymbolTable.cs,GetEntryFromOperand,Cyclomatic complexity of the method is 8
Complex Method,DotNetSiemensPLCToolBoxLibrary.DataTypes.Projectfolders.Step7V5,SymbolTable,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Projectfolders\Step7V5\SymbolTable.cs,LoadSymboltable,Cyclomatic complexity of the method is 8
Complex Method,DotNetSiemensPLCToolBoxLibrary.DBF.Index,Index,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DBF\Index\Index.cs,BuildKey,Cyclomatic complexity of the method is 10
Complex Method,DotNetSiemensPLCToolBoxLibrary.DBF.Index,NodeFloat,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DBF\Index\NodeFloat.cs,NodeFloat,Cyclomatic complexity of the method is 10
Complex Method,DotNetSiemensPLCToolBoxLibrary.DBF.Index,NodeFloat,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DBF\Index\NodeFloat.cs,NodeFloat,Cyclomatic complexity of the method is 15
Complex Method,DotNetSiemensPLCToolBoxLibrary.DBF.Index,NodeFloat,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DBF\Index\NodeFloat.cs,CompareTo,Cyclomatic complexity of the method is 18
Complex Method,DotNetSiemensPLCToolBoxLibrary.DBF.Index.MDX,MNode,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DBF\Index\MDX\MNode.cs,Read,Cyclomatic complexity of the method is 8
Complex Method,DotNetSiemensPLCToolBoxLibrary.DBF,ParseDBF,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DBF\ParseDBF.cs,ReadDBF,Cyclomatic complexity of the method is 25
Complex Method,DotNetSiemensPLCToolBoxLibrary.DBF,ParseDBF,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DBF\ParseDBF.cs,WriteValue,Cyclomatic complexity of the method is 10
Complex Method,DotNetSiemensPLCToolBoxLibrary.DBF,Util,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DBF\Util.cs,DoubleDate,Cyclomatic complexity of the method is 8
Complex Method,DotNetSiemensPLCToolBoxLibrary.General,ChunkedMemoryStream,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\General\ChunkedMemoryStream.cs,Write,Cyclomatic complexity of the method is 8
Complex Method,DotNetSiemensPLCToolBoxLibrary.General,StringLogicalComparer,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\General\StringLogicalComparer.cs,Compare,Cyclomatic complexity of the method is 23
Complex Method,DotNetSiemensPLCToolBoxLibrary.PLCs.S5.MC5,MC5toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S5\MC5\MC5toAWL.cs,GetFunctionBlock,Cyclomatic complexity of the method is 18
Complex Method,DotNetSiemensPLCToolBoxLibrary.PLCs.S5.MC5,MC5toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S5\MC5\MC5toAWL.cs,GetParameters,Cyclomatic complexity of the method is 18
Complex Method,DotNetSiemensPLCToolBoxLibrary.PLCs.S5.MC5,MC5toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S5\MC5\MC5toAWL.cs,GetMC5Rows,Cyclomatic complexity of the method is 50
Complex Method,DotNetSiemensPLCToolBoxLibrary.PLCs.S5.MC5,MC5toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S5\MC5\MC5toAWL.cs,find_mc5_code,Cyclomatic complexity of the method is 8
Complex Method,DotNetSiemensPLCToolBoxLibrary.PLCs.S5.MC5,MC5toDB,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S5\MC5\MC5toDB.cs,GetDB,Cyclomatic complexity of the method is 21
Complex Method,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_1xyy,VariableLengthQuantityHelper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_1xyy\VariableLengthQuantityHelper.cs,EncodeInt,Cyclomatic complexity of the method is 10
Complex Method,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,AWLCodeOptimizer,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\AWLCodeOptimizer.cs,OptimizeAWL,Cyclomatic complexity of the method is 9
Complex Method,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,AWLtoMC7,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\AWLtoMC7.cs,GetMC7,Cyclomatic complexity of the method is 83
Complex Method,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,AWLToSource,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\AWLToSource.cs,DataRowToSource,Cyclomatic complexity of the method is 12
Complex Method,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,CallConverter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\CallConverter.cs,ConvertUCToCall,Cyclomatic complexity of the method is 110
Complex Method,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,FBStaticAccessConverter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\FBStaticAccessConverter.cs,ReplaceStaticAccess,Cyclomatic complexity of the method is 9
Complex Method,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,StringValueToObject,Cyclomatic complexity of the method is 17
Complex Method,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,DefaultValueForType,Cyclomatic complexity of the method is 17
Complex Method,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,ValueToString,Cyclomatic complexity of the method is 33
Complex Method,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetTimespanFromS5TimeorTime,Cyclomatic complexity of the method is 9
Complex Method,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetDaT,Cyclomatic complexity of the method is 10
Complex Method,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetFCPointer,Cyclomatic complexity of the method is 9
Complex Method,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetS5Time,Cyclomatic complexity of the method is 8
Complex Method,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetPointer,Cyclomatic complexity of the method is 10
Complex Method,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetS7String,Cyclomatic complexity of the method is 9
Complex Method,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,JumpMarks,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\JumpMarks.cs,AddJumpmarks,Cyclomatic complexity of the method is 16
Complex Method,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,LocalDataConverter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\LocalDataConverter.cs,ConvertLocaldataToSymbols,Cyclomatic complexity of the method is 13
Complex Method,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7toAWL.cs,GetAWL,Cyclomatic complexity of the method is 614
Complex Method,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Parameter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Parameter.cs,IsInterfaceCompatible,Cyclomatic complexity of the method is 9
Complex Method,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Parameter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Parameter.cs,GetInterfaceOrDBFromStep7ProjectString,Cyclomatic complexity of the method is 69
Complex Method,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Parameter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Parameter.cs,GetInterface,Cyclomatic complexity of the method is 13
Complex Method,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Parameter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Parameter.cs,GetVarTypeEN,Cyclomatic complexity of the method is 15
Complex Method,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Parameter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Parameter.cs,GetVarCurrentValue,Cyclomatic complexity of the method is 17
Complex Method,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Parameter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Parameter.cs,GetVarInitialValue,Cyclomatic complexity of the method is 16
Complex Method,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Projects,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Projects.cs,GetStep7ProjectsFromDirectory,Cyclomatic complexity of the method is 35
Complex Method,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Projects,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Projects.cs,LoadProject,Cyclomatic complexity of the method is 19
Complex Method,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step5Project,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step5Project.cs,LoadProject,Cyclomatic complexity of the method is 13
Complex Method,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step5Project,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step5Project.cs,AddBlockInfo,Cyclomatic complexity of the method is 9
Complex Method,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,Step7ProjectV5,Cyclomatic complexity of the method is 9
Complex Method,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,Cyclomatic complexity of the method is 217
Complex Method,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,_GetSymTabForProject,Cyclomatic complexity of the method is 13
Complex Method,DotNetSiemensPLCToolBoxLibrary.Source,AWLSourceParser,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Source\AWLSourceParser.cs,ParseAWL,Cyclomatic complexity of the method is 20
Long Parameter List,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,IDaveConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\IDaveConnection.cs,readBits,The method has 5 parameters. Parameters: area' DBnumber' start' len' buffer
Long Parameter List,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,IDaveConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\IDaveConnection.cs,readBytes,The method has 5 parameters. Parameters: area' DBnumber' start' len' buffer
Long Parameter List,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,IDaveConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\IDaveConnection.cs,readManyBytes,The method has 5 parameters. Parameters: area' DBnumber' start' len' buffer
Long Parameter List,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,IDaveConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\IDaveConnection.cs,writeBits,The method has 5 parameters. Parameters: area' DBnumber' start' len' buffer
Long Parameter List,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,IDaveConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\IDaveConnection.cs,writeBytes,The method has 5 parameters. Parameters: area' DBnumber' start' len' buffer
Long Parameter List,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,IDaveConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\IDaveConnection.cs,writeManyBytes,The method has 5 parameters. Parameters: area' DBnumber' start' len' buffer
Long Parameter List,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,IDaveConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\IDaveConnection.cs,davePutNCProgram,The method has 5 parameters. Parameters: filename' path' ts' buffer' length
Long Parameter List,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,IPDU,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\IPDU.cs,addBitVarToWriteRequest,The method has 5 parameters. Parameters: area' DBnum' start' bytes' buffer
Long Parameter List,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,IPDU,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\IPDU.cs,addVarToWriteRequest,The method has 5 parameters. Parameters: area' DBnum' start' bytes' buffer
Long Parameter List,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,IPDU,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\IPDU.cs,addNCKToReadRequest,The method has 6 parameters. Parameters: area' unit' column' line' module' linecount
Long Parameter List,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,IPDU,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\IPDU.cs,addNCKToWriteRequest,The method has 8 parameters. Parameters: area' unit' column' line' module' linecount' bytes' buffer
Long Parameter List,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,daveInterface,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,daveNewInterface64,The method has 5 parameters. Parameters: fd' name' localMPI' useProto' speed
Long Parameter List,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,daveInterface,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,daveNewInterface32,The method has 5 parameters. Parameters: fd' name' localMPI' useProto' speed
Long Parameter List,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,daveInterface,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,daveInterface,The method has 5 parameters. Parameters: fd' name' localMPI' useProto' speed
Long Parameter List,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,daveConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,daveNewExtendedConnection64,The method has 14 parameters. Parameters: di' destination' DestinationIsIP' rack' slot' routing' routingSubnetFirst' routingSubnetSecond' routingRack' routingSlot' routingDestination' routingDestinationIsIP' ConnectionType' routingConnectionType
Long Parameter List,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,daveConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,daveNewExtendedConnection32,The method has 14 parameters. Parameters: di' destination' DestinationIsIP' rack' slot' routing' routingSubnetFirst' routingSubnetSecond' routingRack' routingSlot' routingDestination' routingDestinationIsIP' ConnectionType' routingConnectionType
Long Parameter List,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,daveConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,daveConnection,The method has 14 parameters. Parameters: di' MPI' IP' DestinationIsIP' rack' slot' routing' routingSubnetFirst' routingSubnetSecond' routingRack' routingSlot' routingDestination' PLCConnectionType' routingPLCConnectionType
Long Parameter List,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,daveConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,daveReadBytes64,The method has 6 parameters. Parameters: dc' area' DBnumber' start' len' buffer
Long Parameter List,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,daveConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,daveReadBytes32,The method has 6 parameters. Parameters: dc' area' DBnumber' start' len' buffer
Long Parameter List,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,daveConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,readBytes,The method has 5 parameters. Parameters: area' DBnumber' start' len' buffer
Long Parameter List,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,daveConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,readManyBytes,The method has 5 parameters. Parameters: area' DBnumber' start' len' buffer
Long Parameter List,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,daveConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,daveReadBits64,The method has 6 parameters. Parameters: dc' area' DBnumber' start' len' buffer
Long Parameter List,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,daveConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,daveReadBits32,The method has 6 parameters. Parameters: dc' area' DBnumber' start' len' buffer
Long Parameter List,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,daveConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,readBits,The method has 5 parameters. Parameters: area' DBnumber' start' len' buffer
Long Parameter List,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,daveConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,daveWriteBytes64,The method has 6 parameters. Parameters: dc' area' DBnumber' start' len' buffer
Long Parameter List,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,daveConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,daveWriteBytes32,The method has 6 parameters. Parameters: dc' area' DBnumber' start' len' buffer
Long Parameter List,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,daveConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,writeBytes,The method has 5 parameters. Parameters: area' DBnumber' start' len' buffer
Long Parameter List,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,daveConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,daveWriteManyBytes64,The method has 6 parameters. Parameters: dc' area' DBnumber' start' len' buffer
Long Parameter List,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,daveConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,daveWriteManyBytes32,The method has 6 parameters. Parameters: dc' area' DBnumber' start' len' buffer
Long Parameter List,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,daveConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,writeManyBytes,The method has 5 parameters. Parameters: area' DBnumber' start' len' buffer
Long Parameter List,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,daveConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,daveWriteBits64,The method has 6 parameters. Parameters: dc' area' DBnumber' start' len' buffer
Long Parameter List,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,daveConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,daveWriteBits32,The method has 6 parameters. Parameters: dc' area' DBnumber' start' len' buffer
Long Parameter List,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,daveConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,writeBits,The method has 5 parameters. Parameters: area' DBnumber' start' len' buffer
Long Parameter List,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,daveConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,daveBuildAndSendPDU64,The method has 6 parameters. Parameters: dc' p' b1' l1' b2' l2
Long Parameter List,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,daveConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,daveBuildAndSendPDU32,The method has 6 parameters. Parameters: dc' p' b1' l1' b2' l2
Long Parameter List,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,daveConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,daveReadSZL64,The method has 5 parameters. Parameters: dc' id' index' buffer' len
Long Parameter List,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,daveConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,daveReadSZL32,The method has 5 parameters. Parameters: dc' id' index' buffer' len
Long Parameter List,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,daveConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,daveGetProgramBlock64,The method has 5 parameters. Parameters: dc' blockType' number' buffer' length
Long Parameter List,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,daveConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,daveGetProgramBlock32,The method has 5 parameters. Parameters: dc' blockType' number' buffer' length
Long Parameter List,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,daveConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,davePutProgramBlock64,The method has 5 parameters. Parameters: dc' blockType' number' buffer' length
Long Parameter List,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,daveConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,davePutProgramBlock32,The method has 5 parameters. Parameters: dc' blockType' number' buffer' length
Long Parameter List,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,daveConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,daveGetPDUData64,The method has 6 parameters. Parameters: dc' p' data' ldata' param' lparam
Long Parameter List,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,daveConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,daveGetPDUData32,The method has 6 parameters. Parameters: dc' p' data' ldata' param' lparam
Long Parameter List,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,daveConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,davePutNCProgram64,The method has 6 parameters. Parameters: dc' filename' path' ts' buffer' length
Long Parameter List,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,daveConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,davePutNCProgram32,The method has 6 parameters. Parameters: dc' filename' path' ts' buffer' length
Long Parameter List,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,daveConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,davePutNCProgram,The method has 5 parameters. Parameters: filename' path' ts' buffer' length
Long Parameter List,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,daveConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,doUploadNC64,The method has 5 parameters. Parameters: dc' more' buffer' len' uploadID
Long Parameter List,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,daveConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,doUploadNC32,The method has 5 parameters. Parameters: dc' more' buffer' len' uploadID
Long Parameter List,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,PDU,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,daveAddVarToReadRequest64,The method has 5 parameters. Parameters: p' area' DBnum' start' bytes
Long Parameter List,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,PDU,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,daveAddVarToReadRequest32,The method has 5 parameters. Parameters: p' area' DBnum' start' bytes
Long Parameter List,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,PDU,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,daveAddNCKToReadRequest64,The method has 7 parameters. Parameters: p' area' unit' column' line' module' linecount
Long Parameter List,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,PDU,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,daveAddNCKToReadRequest32,The method has 7 parameters. Parameters: p' area' unit' column' line' module' linecount
Long Parameter List,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,PDU,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,addNCKToReadRequest,The method has 6 parameters. Parameters: area' unit' column' line' module' linecount
Long Parameter List,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,PDU,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,daveAddNCKToWriteRequest64,The method has 9 parameters. Parameters: p' area' unit' column' line' module' linecount' bytes' buffer
Long Parameter List,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,PDU,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,daveAddNCKToWriteRequest32,The method has 9 parameters. Parameters: p' area' unit' column' line' module' linecount' bytes' buffer
Long Parameter List,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,PDU,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,addNCKToWriteRequest,The method has 8 parameters. Parameters: area' unit' column' line' module' linecount' bytes' buffer
Long Parameter List,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,PDU,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,daveAddBitVarToReadRequest64,The method has 5 parameters. Parameters: p' area' DBnum' start' bytes
Long Parameter List,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,PDU,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,daveAddBitVarToReadRequest32,The method has 5 parameters. Parameters: p' area' DBnum' start' bytes
Long Parameter List,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,PDU,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,daveAddVarToWriteRequest64,The method has 6 parameters. Parameters: p' area' DBnum' start' bytes' buffer
Long Parameter List,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,PDU,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,daveAddVarToWriteRequest32,The method has 6 parameters. Parameters: p' area' DBnum' start' bytes' buffer
Long Parameter List,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,PDU,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,addVarToWriteRequest,The method has 5 parameters. Parameters: area' DBnum' start' bytes' buffer
Long Parameter List,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,PDU,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,daveAddBitVarToWriteRequest64,The method has 6 parameters. Parameters: p' area' DBnum' start' bytes' buffer
Long Parameter List,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,PDU,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,daveAddBitVarToWriteRequest32,The method has 6 parameters. Parameters: p' area' DBnum' start' bytes' buffer
Long Parameter List,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,PDU,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,addBitVarToWriteRequest,The method has 5 parameters. Parameters: area' DBnum' start' bytes' buffer
Long Parameter List,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,readBits,The method has 5 parameters. Parameters: area' DBnumber' start' len' buffer
Long Parameter List,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,readManyBytes,The method has 5 parameters. Parameters: area' DBnumber' start' len' buffer
Long Parameter List,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,writeBits,The method has 5 parameters. Parameters: area' DB' start' len' buffer
Long Parameter List,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,writeBytes,The method has 5 parameters. Parameters: area' DBnumber' start' len' buffer
Long Parameter List,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,writeManyBytes,The method has 5 parameters. Parameters: area' DBnumber' start' len' buffer
Long Parameter List,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,readBytes,The method has 5 parameters. Parameters: area' DBnum' start' len' buffer
Long Parameter List,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,davePutNCProgram,The method has 5 parameters. Parameters: filename' path' ts' buffer' length
Long Parameter List,DotNetSiemensPLCToolBoxLibrary.Communication.Library.Pdus,Pdu,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\Pdus\Pdu.cs,addToReadRequest,The method has 5 parameters. Parameters: area' DBnumber' startByteAddress' byteCount' isBit
Long Parameter List,DotNetSiemensPLCToolBoxLibrary.Communication.Library.Pdus,Pdu,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\Pdus\Pdu.cs,addNCKToReadRequest,The method has 6 parameters. Parameters: area' unit' column' line' module' linecount
Long Parameter List,DotNetSiemensPLCToolBoxLibrary.Communication.Library.Pdus,Pdu,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\Pdus\Pdu.cs,addNCKToWriteRequest,The method has 8 parameters. Parameters: area' unit' column' line' module' linecount' bytes' buffer
Long Parameter List,DotNetSiemensPLCToolBoxLibrary.Communication.Library.Pdus,Pdu,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\Pdus\Pdu.cs,addBitVarToWriteRequest,The method has 5 parameters. Parameters: area' DBnum' start' byteCount' buffer
Long Parameter List,DotNetSiemensPLCToolBoxLibrary.Communication.Library.Pdus,Pdu,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\Pdus\Pdu.cs,addToWriteRequest,The method has 7 parameters. Parameters: area' DBnum' start' byteCount' buffer' da' pa
Long Parameter List,DotNetSiemensPLCToolBoxLibrary.Communication.Library.Pdus,Pdu,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\Pdus\Pdu.cs,addVarToWriteRequest,The method has 5 parameters. Parameters: area' DBnum' start' byteCount' buffer
Long Parameter List,DotNetSiemensPLCToolBoxLibrary.Communication.Networking,TCPFunctionsAsync,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Networking\TCPFunctionsAsync.cs,TCPFunctionsAsync,The method has 5 parameters. Parameters: context' IP' connection_port' connection_active' FixedLength
Long Parameter List,DotNetSiemensPLCToolBoxLibrary.Communication,NC_Var,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCNckTag.cs,NC_Var,The method has 8 parameters. Parameters: syntaxId' bereich_u_einheit' spalte' zeile' bausteinTyp' zeilenAnzahl' typ' laenge
Long Parameter List,DotNetSiemensPLCToolBoxLibrary.DBF.Index,Node,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DBF\Index\Node.cs,Node,The method has 5 parameters. Parameters: keys_in' key_size' keyType' rn' iBranch
Long Parameter List,DotNetSiemensPLCToolBoxLibrary.DBF.Index.MDX,MNode,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DBF\Index\MDX\MNode.cs,MNode,The method has 5 parameters. Parameters: keys_in' key_size' keyType' rn' iBranch
Long Parameter List,DotNetSiemensPLCToolBoxLibrary.DBF,ParseDBF,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DBF\ParseDBF.cs,WriteValue,The method has 6 parameters. Parameters: dbfFile' column' row' value' _ziphelper' DirSeperator
Long Parameter List,DotNetSiemensPLCToolBoxLibrary.PLCs.S5.MC5,MC5toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S5\MC5\MC5toAWL.cs,GetFunctionBlock,The method has 5 parameters. Parameters: blkInfo' block' preHeader' commentBlock' prjBlkFld
Long Parameter List,DotNetSiemensPLCToolBoxLibrary.PLCs.S5.MC5,MC5toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S5\MC5\MC5toAWL.cs,GetMC5Rows,The method has 5 parameters. Parameters: code' codestart' parameters' blkFld' block
Long Parameter List,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,CallConverter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\CallConverter.cs,ConvertUCToCall,The method has 5 parameters. Parameters: myFct' myFld' myblkFld' myOpt' addInfoFromBlock
Long Parameter List,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetDT,The method has 6 parameters. Parameters: b1' b2' b3' b4' b5' b6
Long Parameter List,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7toAWL.cs,GetAWL,The method has 9 parameters. Parameters: Start' Count' MN' BD' Networks' ParaList' prjBlkFld' block' blockInterface
Long Parameter List,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,NetWork,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\NetWork.cs,NetworkCheck,The method has 6 parameters. Parameters: Networks' myVal' counter' oldpos' pos' NNr
Long Parameter List,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Parameter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Parameter.cs,GetInterfaceOrDBFromStep7ProjectString,The method has 7 parameters. Parameters: txt' ParaList' blkTP' isInstanceDB' myFld' myBlk' actualValues
Long Parameter List,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Parameter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Parameter.cs,GetInterface,The method has 7 parameters. Parameters: interfaceBytes' startValueBytes' actualValueBytes' ParaList' blkTP' isInstanceDB' myBlk
Long Parameter List,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Parameter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Parameter.cs,GetVarTypeEN,The method has 13 parameters. Parameters: currPar' datatype' Struct' Array' VarName' interfaceBytes' InterfacePos' startValueBytes' StartValuePos' ParaList' StackNr' VarNameGen' myBlk
Long Identifier,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,,The length of the parameter daveResMultipleBitsNotSupported is 31.
Long Identifier,DotNetSiemensPLCToolBoxLibrary.Communication.Library,Connection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\Connection.cs,,The length of the parameter daveResMultipleBitsNotSupported is 31.
Long Identifier,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PLCstartRequestDiagnosticData,The length of the parameter ByteAdressNumerPLCFunctionBlocks is 32.
Long Identifier,DotNetSiemensPLCToolBoxLibrary.Communication,DiagnosticData,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,,The length of the parameter ByteAdressNumerPLCFunctionBlocks is 32.
Long Identifier,DotNetSiemensPLCToolBoxLibrary.PLCs.S5.MC5,MC5toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S5\MC5\MC5toAWL.cs,GetMC5Rows,The length of the parameter ByteAdressNumerPLCFunctionBlocks is 32.
Long Identifier,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7Converter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7Converter.cs,ParseBlockHeaderAndFooterFromMC7,The length of the parameter InterfaceLength_or_DBActualValuesLength is 39.
Long Identifier,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7toAWL.cs,GetAWL,The length of the parameter ByteAdressNumerPLCFunctionBlocks is 32.
Long Identifier,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Projects,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Projects.cs,LoadProjectFolder,The length of the parameter projectAndStructuredFolderName is 30.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putS7Stringat,The length of the statement  "            Array.Copy(Encoding.GetEncoding(System.Globalization.CultureInfo.CurrentCulture.TextInfo.ANSICodePage).GetBytes(value)' 0' b' pos + 2' value.Length > length ? length : value.Length); " is 182.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putStringat,The length of the statement  "            Array.Copy(Encoding.GetEncoding(System.Globalization.CultureInfo.CurrentCulture.TextInfo.ANSICodePage).GetBytes(value)' 0' b' pos' value.Length > length ? length : value.Length); " is 178.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Communication.Library,Connection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\Connection.cs,daveStrerror,The length of the statement  "                case 0xd242: return "protection violation while processing F-blocks. F-blocks can only be processed after password input."; " is 123.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Communication.Library,Connection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\Connection.cs,PLCStop,The length of the statement  "            byte[] para = new byte[] {0x29' 0' 0' 0' 0' 0' 9' (byte) 'P'' (byte) '_'' (byte) 'P'' (byte) 'R'' (byte) 'O'' (byte) 'G'' (byte) 'R'' (byte) 'A'' (byte) 'M'}; " is 158.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Communication.Library,Connection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\Connection.cs,PLCStart,The length of the statement  "            byte[] para = new byte[] {0x28' 0' 0' 0' 0' 0' 9' (byte) 'P'' (byte) '_'' (byte) 'P'' (byte) 'R'' (byte) 'O'' (byte) 'G'' (byte) 'R'' (byte) 'A'' (byte) 'M'}; " is 158.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Communication.Library,Connection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\Connection.cs,PLCCompress,The length of the statement  "            byte[] para = new byte[] {0x28' 0' 0' 0' 0' 0' 0' 0xFD' 0' 0' 5' (byte) '_'' (byte) 'G'' (byte) 'A'' (byte) 'R'' (byte) 'B'}; " is 125.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Communication.Library,Connection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\Connection.cs,PLCCopyRamToRom,The length of the statement  "            byte[] para = new byte[] {0x28' 0' 0' 0' 0' 0' 0' 0xFD' 0' 2' (byte) 'E'' (byte) 'P'' 5' (byte) '_'' (byte) 'M'' (byte) 'O'' (byte) 'D'' (byte) 'U'}; " is 149.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,connectPLC,The length of the statement  "           0'//(unsigned char) (dc->routingSubnetFirst >> 8)' (unsigned char) dc->routingSubnetFirst'	// first part of S7-Subnet-ID  " is 120.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,connectPLC,The length of the statement  "           0'//(unsigned char) (dc->routingSubnetSecond >> 8)' (unsigned char) dc->routingSubnetSecond'		// second part of S7-Subnet-ID  " is 124.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,start,The length of the statement  "            byte[] para = new byte[] { 0x28' 0' 0' 0' 0' 0' 0' 0xFD' 0' 0x00' 9' (byte)'P'' (byte)'_'' (byte)'P'' (byte)'R'' (byte)'O'' (byte)'G'' (byte)'R'' (byte)'A'' (byte)'M' }; " is 169.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,stop,The length of the statement  "            byte[] para = new byte[] { 0x29' 0' 0' 0' 0' 0' 9' (byte)'P'' (byte)'_'' (byte)'P'' (byte)'R'' (byte)'O'' (byte)'G'' (byte)'R'' (byte)'A'' (byte)'M' }; " is 151.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,ListBlocksOfType,The length of the statement  "                if (buffer != null) Array.Copy(p2.UData.ToArray()' 0' buffer' len' p2.UData.Count);// memcpy(buffer + len' p2.udata' p2.udlen); " is 127.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,ListBlocksOfType,The length of the statement  "            if (buffer != null) Array.Copy(p2.UData.ToArray()' 0' buffer' len' p2.UData.Count); //memcpy(buffer + len' p2.udata' p2.udlen); " is 127.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,force200,The length of the statement  "            else if ((area == daveConst.daveTimer) || (area == daveConst.daveCounter) || (area == daveConst.daveTimer200) || (area == daveConst.daveCounter200)) " is 148.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Communication.Library.Pdus,Pdu,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\Pdus\Pdu.cs,addToReadRequest,The length of the statement  "            else if ((area == daveConst.daveTimer) || (area == daveConst.daveCounter) || (area == daveConst.daveTimer200) || (area == daveConst.daveCounter200)) " is 148.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Communication.Library.Pdus,Pdu,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\Pdus\Pdu.cs,addToWriteRequest,The length of the statement  "            if ((area == daveConst.daveTimer) || (area == daveConst.daveCounter) || (area == daveConst.daveTimer200) || (area == daveConst.daveCounter200)) " is 143.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Communication.Networking,TCPFunctionsAsync,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Networking\TCPFunctionsAsync.cs,DoBeginnConnectCallback,The length of the statement  "                string sMsg = DateTime.Now.ToString() + " - " + "TCPSocketClientAndServer.DoBeginConnectCallback(IAsyncResult) - error: " + ex.Message; " is 135.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Communication.Networking,TCPFunctionsAsync,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Networking\TCPFunctionsAsync.cs,DoBeginnConnectCallback,The length of the statement  "                if (ex is SocketException)// && (((SocketException)ex).ErrorCode == 10060 || ((SocketException)ex).ErrorCode == 10061 || ((SocketException)ex).ErrorCode == 10065)) " is 163.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Communication.Networking,TCPFunctionsAsync,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Networking\TCPFunctionsAsync.cs,DoAcceptTcpClientCallback,The length of the statement  "                string sMsg = DateTime.Now.ToString() + " - " + "TCPSocketClientAndServer.DoAcceptTcpClientCallback(IAsyncResult) - error: " + ex.Message; " is 138.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Communication.Networking,TCPFunctionsAsync,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Networking\TCPFunctionsAsync.cs,DoReadCallback,The length of the statement  "                            akTcpClient.Client.BeginReceive(readBytes' readPos' readBytes.Length - readPos' SocketFlags.None' new AsyncCallback(DoReadCallback)' akTcpClient); " is 146.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Communication.Networking,TCPFunctionsAsync,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Networking\TCPFunctionsAsync.cs,DoReadCallback,The length of the statement  "                    string sMsg = DateTime.Now.ToString() + " - " + "TCPSocketClientAndServer.DoReadCallback(IAsyncResult) - error: " + ex.Message; " is 127.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,Connect,The length of the statement  "                //    throw new Exception("Error: You can only use the S7Online Connection when you specify the HWND Parameter on the Connect Function"); " is 137.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,Connect,The length of the statement  "                    if ((_configuration.ConnectionType != LibNodaveConnectionTypes.Use_Step7_DLL && _configuration.ConnectionType != LibNodaveConnectionTypes.Use_Step7_DLL_Without_TCP && _fds.rfd.ToInt32() == 0) || _fds.rfd.ToInt32() < 0) " is 218.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,Connect,The length of the statement  "                    _di = new libnodave.daveInterface(_fds' _configuration.ConnectionName' _configuration.LokalMpi' (int)_configuration.ConnectionType' (int)_configuration.BusSpeed); " is 162.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,Connect,The length of the statement  "                        throw new PLCException("Error: (Interface) (Code: " + initret.ToString() + ") " + _errorCodeConverter(initret)' initret); " is 121.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,Connect,The length of the statement  "                if (_configuration.NetLinkReset && !_netlinkReseted && (_configuration.ConnectionType == LibNodaveConnectionTypes.Netlink_lite || _configuration.ConnectionType == LibNodaveConnectionTypes.Netlink_lite_PPI)) " is 206.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PLCstartRequestDiagnosticData,The length of the statement  "                    //if ((((DefaultSZLDataset)szlDatasets[0]).Bytes[4] & 0x08) > 0) //Byte 3 and 4 say as a Bit array wich Status Tele is supported! " is 129.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PLCstartRequestDiagnosticData,The length of the statement  "                    //When in a Row there is no Change for the selected Registers' these Row is added to the previous' so no extra Status for this row is necessary " is 143.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PLCstartRequestDiagnosticData,The length of the statement  "                                        //So when not asked for all Registers' it can be that 2 commands have the same Status values and it's only asked for that one times! " is 132.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PLCGetState,The length of the statement  "                //Dokumentation of SZL can be found here: http://www.google.de/url?sa=t&source=web&cd=3&ved=0CCQQFjAC&url=http%3A%2F%2Fdce.felk.cvut.cz%2Frs%2Fplcs7315%2Fmanualy%2Fsfc_e.pdf&ei=tY8QTJufEYSNOLD_oMoH&usg=AFQjCNEHofHOLDcvGp-4eQBwlboKPu3oxQ " is 236.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PLCPutBlockFromMC7toPLC,The length of the statement  "                    //Es ist eine CRC16 Prüfsumme mit dem Generator Polynom 0x9003 ' Init = 0x0000 ' RefIn = False' RefOut = False' XorOut = 0x0000. " is 128.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PLCCopyRamToRom,The length of the statement  "                byte[] Para = { 0x28' 0' 0' 0' 0' 0' 0' 0xfd' 0' 2' (byte)'E'' (byte)'P'' 5' (byte)'_'' (byte)'M'' (byte)'O'' (byte)'D'' (byte)'U' }; " is 133.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,WriteValuesWithVarTabFunctions,The length of the statement  "                VarTabWriteData retVal = new VarTabWriteData(BitConverter.ToInt16(stid' 0)' General.IEnumerableExtensions.ToArray<PLCTag>(valueList)' this); " is 140.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,_TestNewReadValues,The length of the statement  "                //if it is so' create a replacement value wich reads the bytes and stores at wich tags are in this value and at wich adress " is 123.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,_TestNewReadValues,The length of the statement  "                    int HeaderTagSize = 4; //Todo: If I use the Short Request' the Header in the answer is 5 Bytes' not 4! Look how to do this... " is 125.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,_TestNewReadValues,The length of the statement  "                            int restBytes = Math.Min(maxReadSize - curReadPDU.gesReadSize' readSizeWithHeader) - HeaderTagSize;//len read: or real full len' or remaining free " is 146.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,_TestNewReadValues,The length of the statement  "                            if (restBytes < HeaderTagSize || symbolicTag || (curReadPDU.gesReadSize > 0 && libNoDaveValue.DontSplitValue && curReadPDU.gesReadSize + readSizeWithHeader > maxReadSize)) " is 171.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,_TestNewReadValues,The length of the statement  "                            {//or remaining free < HeaderTagSize' or Simbol' or Value don't split and full value can don't read without split and PDU nit empty (if PDU empty Value DontSplitValue is spliting) " is 179.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,_TestNewReadValues,The length of the statement  "                                curReadPDU.pdu.addVarToReadRequest(Convert.ToInt32(libNoDaveValue.TagDataSource)' libNoDaveValue.DataBlockNumber' akByteAddress' restBytes); " is 140.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,ReadValuesWithCheck,The length of the statement  "            if (Configuration.ConnectionType == LibNodaveConnectionTypes.Fetch_Write_Passive || Configuration.ConnectionType == LibNodaveConnectionTypes.Fetch_Write_Active) " is 160.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,ReadValuesWithCheck,The length of the statement  "                var dbList = tags.Where(x => x.TagDataSource == MemoryArea.Datablock || x.TagDataSource == MemoryArea.InstanceDatablock).Select(x => x.DataBlockNumber).Distinct(); " is 163.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,ReadValuesWithCheck,The length of the statement  "                if ((tag.TagDataSource == MemoryArea.Datablock || tag.TagDataSource == MemoryArea.InstanceDatablock) && _dbSizes[tag.DataBlockNumber] < tag.ByteAddress + tag.ReadByteSize) " is 171.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,ReadValues,The length of the statement  "            if (Configuration.ConnectionType == LibNodaveConnectionTypes.Fetch_Write_Active || Configuration.ConnectionType == LibNodaveConnectionTypes.Fetch_Write_Passive) " is 160.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,ReadValues,The length of the statement  "                //if it is so' create a replacement value wich reads the bytes and stores at wich tags are in this value and at wich adress " is 123.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,ReadValues,The length of the statement  "                    if (maxReadSize > 208 && readTagList.First() is PLCNckTag && ((PLCNckTag)readTagList.First()).NckArea == NCK_Area.AreaFeedDrive) " is 128.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,ReadValues,The length of the statement  "                        const int HeaderTagSize = 4; //Todo: If I use the Short Request' the Header in the answer is 5 Bytes' not 4! Look how to do this... " is 131.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,ReadValues,The length of the statement  "                            if (nckT == null && !symbolicTag && gesAskSize + currentAskSize <= maxReadSize && (!libNoDaveValue.DontSplitValue || readSize > maxReadSize)) " is 141.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,ReadValues,The length of the statement  "                                        currentRead.Add(string.Format("shortDbRequest' db:{0}' byte:{1}' size{2}"' libNoDaveValue.DataBlockNumber' akByteAddress' readSize)); " is 133.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,ReadValues,The length of the statement  "                                        currentRead.Add(string.Format("addVarToReadRequest' source:{0}' db:{1}' byte:{2}' size{3}"' libNoDaveValue.TagDataSource' libNoDaveValue.DataBlockNumber' akByteAddress' readSize)); " is 180.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,ReadValues,The length of the statement  "                                        myPDU.addVarToReadRequest(Convert.ToInt32(libNoDaveValue.TagDataSource)' libNoDaveValue.DataBlockNumber' akByteAddress' restBytes); " is 131.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,ReadValues,The length of the statement  "                            myPDU.addNCKToReadRequest((int)nckT.NckArea' nckT.NckUnit' nckT.NckColumn' nckT.NckLine' nckT.NckModule' nckT.NckLinecount); " is 124.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,ReadValues,The length of the statement  "                            currentRead.Add(string.Format("shortDbRequest' db:{0}' byte:{1}' size{2}"' libNoDaveValue.DataBlockNumber' akByteAddress' readSize)); " is 133.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,ReadValues,The length of the statement  "                            currentRead.Add(string.Format("addVarToReadRequest' source:{0}' db:{1}' byte:{2}' size{3}"' libNoDaveValue.TagDataSource' libNoDaveValue.DataBlockNumber' akByteAddress' readSize)); " is 180.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,ReadValues,The length of the statement  "                            myPDU.addVarToReadRequest(Convert.ToInt32(libNoDaveValue.TagDataSource)' libNoDaveValue.DataBlockNumber' akByteAddress' readSize); " is 130.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,ReadValue,The length of the statement  "            if (Configuration.ConnectionType == LibNodaveConnectionTypes.Fetch_Write_Active || Configuration.ConnectionType == LibNodaveConnectionTypes.Fetch_Write_Passive) " is 160.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,WriteValue,The length of the statement  "                if (Configuration.ConnectionType == LibNodaveConnectionTypes.Fetch_Write_Active || Configuration.ConnectionType == LibNodaveConnectionTypes.Fetch_Write_Passive) " is 160.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,WriteValues,The length of the statement  "                if (Configuration.ConnectionType == LibNodaveConnectionTypes.Fetch_Write_Active || Configuration.ConnectionType == LibNodaveConnectionTypes.Fetch_Write_Passive) " is 160.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,WriteValues,The length of the statement  "                                if (nckT != null && nckT.TagDataType != TagDataType.String && nckT.TagDataType != TagDataType.CharArray && nckT.NckArea != NCK_Area.AreaFeedDrive && nckT.NckArea != NCK_Area.AreaMainDrive) " is 188.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,WriteValues,The length of the statement  "                                myPDU.addNCKToWriteRequest((int)nckT.NckArea' nckT.NckUnit' nckT.NckColumn' nckT.NckLine' nckT.NckModule' nckT.NckLinecount' wrt.Length' wrt); " is 142.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,DownloadToNC,The length of the statement  "            string path = fullFileName.Substring(0' fullFileName.LastIndexOf('/') > 0 ? fullFileName.LastIndexOf('/') : fullFileName.Length); " is 129.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,GetDateTimeFromByteArray,The length of the statement  "                return new DateTime(int.Parse(sAr[0]) >= 90 ? 1900 + int.Parse(sAr[0]) : 2000 + int.Parse(sAr[0])' int.Parse(sAr[1])' int.Parse(sAr[2])' int.Parse(sAr[3])' int.Parse(sAr[4])' int.Parse(sAr[5])' int.Parse(sAr[6] + sAr[7].Substring(0' 1))); " is 238.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Communication,DiagnosticData,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,RequestDiagnosticData,The length of the statement  "                            PLCFunctionBlockRow.SelectedStatusValues akSelRegister = akRow[0]._GetCommandStatusAskValues(selRegister' DiagDataTeletype); " is 124.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnectionConfiguration,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnectionConfiguration.cs,ReloadConfiguration,The length of the statement  "                //    this.ComPortParity = (LibNodaveConnectionBusParity)Convert.ToInt32(myConnectionKey.GetValue("ComPortParity"' "1")); " is 121.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnectionConfiguration,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnectionConfiguration.cs,ReloadConfiguration,The length of the statement  "                //    this.PLCConnectionType = (LibNodaveConnectionResource)Convert.ToInt32(myConnectionKey.GetValue("PLCConnectionType"' "1")); " is 128.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnectionConfiguration,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnectionConfiguration.cs,ReloadConfiguration,The length of the statement  "                //    this.RoutingPLCConnectionType = (LibNodaveConnectionResource)Convert.ToInt32(myConnectionKey.GetValue("RoutingPLCConnectionType"' "1")); " is 142.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnectionConfiguration,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnectionConfiguration.cs,ReloadConfiguration,The length of the statement  "                //    this.TimeoutIPConnect =  TimeSpan.FromMilliseconds( Convert.ToInt32(myConnectionKey.GetValue("TimeoutIPConnect"' "5000"))); " is 129.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnectionConfiguration,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnectionConfiguration.cs,LoadConfigFile,The length of the statement  "            DictionarySerializer<String' PLCConnectionConfiguration> ConnectionsDicSer = new DictionarySerializer<string' PLCConnectionConfiguration>(); " is 140.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnectionConfiguration,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnectionConfiguration.cs,DeleteConfiguration,The length of the statement  "                DictionarySerializer<String' PLCConnectionConfiguration> ConnectionsDicSer = new DictionarySerializer<string' PLCConnectionConfiguration>(); " is 140.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnectionConfiguration,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnectionConfiguration.cs,SaveConfiguration,The length of the statement  "                DictionarySerializer<String' PLCConnectionConfiguration> ConnectionsDicSer = new DictionarySerializer<string' PLCConnectionConfiguration>();                    " is 140.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnectionConfiguration,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnectionConfiguration.cs,ToString,The length of the statement  "                    retVal = "ISO over TCP" + " (IP:" + CpuIP.ToString() + "'Rack:" + CpuRack.ToString() + "'Slot:" + CpuSlot.ToString() + ")"; " is 123.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnectionConfiguration,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnectionConfiguration.cs,ToString,The length of the statement  "                    retVal = "ISO over TCP (CP243)" + " (IP:" + CpuIP.ToString() + "'Rack:" + CpuRack.ToString() + "'Slot:" + CpuSlot.ToString() + ")"; " is 131.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnectionConfiguration,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnectionConfiguration.cs,ToString,The length of the statement  "                    retVal += " (Routing: MPI/PB:" + RoutingDestination + "'Netz:" + RoutingSubnet1.ToString("X") + "-" + RoutingSubnet2.ToString("X") + ")"; " is 137.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnectionConfiguration,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnectionConfiguration.cs,ToString,The length of the statement  "                    retVal += " (Routing: IP:" + RoutingDestination + "'Rack:" + RoutingDestinationRack.ToString() + "'Slot:" + RoutingDestinationSlot.ToString() + "'Netz:" + RoutingSubnet1.ToString("X") + "-" + RoutingSubnet2.ToString("X") + ")"; " is 227.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Communication,PLCNckTag,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCNckTag.cs,ToString,The length of the statement  "            //string s = string.Format("0x{0}'0x{1}'0x{2}'0x{3}'0x{4}'0x{5}'{6}'0x{7}"' NckArea.ToString("X")' NckUnit.ToString("X")' NckColumn.ToString("X")' NckLine.ToString("X")' NckModule.ToString("X")' NckLinecount.ToString("X")' TagDataType' _internalGetSize().ToString("X")); " is 270.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Communication,PLCNckTag,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCNckTag.cs,ToString,The length of the statement  "            string s = string.Format("0x{0}'0x{1}'0x{2}'0x{3}'0x{4}'0x{5}'0x{6}'0x{7}"' ncVar.SYNTAX_ID.ToString("X")' ncVar.Bereich_u_einheit.ToString("X")' ncVar.Spalte.ToString("X")' ncVar.Zeile.ToString("X")' ncVar.Bausteintyp.ToString("X")' ncVar.ZEILENANZAHL.ToString("X")' ncVar.Typ.ToString("X")' ncVar.Laenge.ToString("X")); " is 321.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Communication,PLCNckTagTypeConverter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCNckTag.cs,ConvertFrom,The length of the statement  "                        return new NC_Var(HexParse(sAr[0]' culture)' HexParse(sAr[1]' culture)' HexParse(sAr[2]' culture)' HexParse(sAr[3]' culture)' HexParse(sAr[4]' culture)' HexParse(sAr[5]' culture)' HexParse(sAr[6]' culture)' HexParse(sAr[7]' culture)).GetNckTag(); " is 246.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Communication,NC_Var,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCNckTag.cs,GetNckTag,The length of the statement  "            if (this.syntaxId == 0 && this.bereich_u_einheit == 0 && this.spalte == 0 && this.zeile == 0 && this.bausteintyp == 0 && this.zeilenanzahl == 0 && this.typ == 0 && this.laenge == 0) " is 181.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Communication,NC_Var,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCNckTag.cs,GetNckTag,The length of the statement  "            byte _bereich = (byte)((bereich_u_einheit & 0xE0) >> 5);         // (bereich_u_einheit & 2#11100000) schiebe rechts um 5 Bit " is 124.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Communication,NC_Var,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCNckTag.cs,GetNckTag,The length of the statement  "            return new PLCNckTag() { TagDataType = dataType' NckArea = (NCK_Area)_bereich' NckUnit = _einheit' NckColumn = this.Spalte + columnOffset' NckLine = this.Zeile + rowOffset' NckModule = this.Bausteintyp' NckLinecount = this.ZEILENANZAHL' ArraySize = _ArraySize }; " is 262.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTag.cs,ChangeAddressFromString,The length of the statement  "                    string[] myPlcAddress = plcAddress.ToLower().Replace("p#"' "").Split(new char[] { ' ' }' StringSplitOptions.RemoveEmptyEntries); " is 128.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTag.cs,ChangeAddressFromString,The length of the statement  "                        _ArraySize = Convert.ToInt32(myPlcAddress[1].Replace("dword"' "").Replace("word"' "").Replace("byte"' "").Replace("bool"' "").Trim()); " is 134.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTag.cs,ChangeAddressFromString,The length of the statement  "                    //if (this.TagDataType != TagDataType.ByteArray && this.TagDataType != TagDataType.CharArray && this.TagDataType != TagDataType.String && this.TagDataType != TagDataType.DateTime) " is 179.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTag.cs,ChangeAddressFromString,The length of the statement  "                            if (this.TagDataType == TagDataType.String || this.TagDataType == TagDataType.CharArray || this.TagDataType == TagDataType.ByteArray) " is 133.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTag.cs,ChangeAddressFromString,The length of the statement  "                            if (this.TagDataType == TagDataType.String || this.TagDataType == TagDataType.CharArray || this.TagDataType == TagDataType.ByteArray) " is 133.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTag.cs,ChangeAddressFromString,The length of the statement  "                            if (this.TagDataType == TagDataType.String || this.TagDataType == TagDataType.CharArray || this.TagDataType == TagDataType.ByteArray) " is 133.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTag.cs,ChangeAddressFromString,The length of the statement  "                        this.ByteAddress = Convert.ToInt32(myPlcAddress[1].Replace("DBW"' "").Replace("DBD"' "").Replace("DBR"' "").Replace("DBX"' "").Replace("DBB"' "").Replace("DBL"' "").Trim()); " is 173.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTag.cs,ChangeAddressFromString,The length of the statement  "                            if (this.TagDataType == TagDataType.String || this.TagDataType == TagDataType.CharArray || this.TagDataType == TagDataType.ByteArray) " is 133.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTag.cs,ChangeAddressFromString,The length of the statement  "                            if (this.TagDataType == TagDataType.String || this.TagDataType == TagDataType.CharArray || this.TagDataType == TagDataType.ByteArray) " is 133.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTag.cs,ChangeAddressFromString,The length of the statement  "                            if (this.TagDataType == TagDataType.String || this.TagDataType == TagDataType.CharArray || this.TagDataType == TagDataType.ByteArray) " is 133.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTag.cs,_putControlValueIntoBuffer,The length of the statement  "            if (this.ArraySize == 1 || this.TagDataType == TagDataType.String || this.TagDataType == TagDataType.CharArray || this.TagDataType == TagDataType.ByteArray || this.TagDataType == TagDataType.BCDArray) " is 200.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTag.cs,_readValueFromBuffer,The length of the statement  "            if (this is PLCNckTag && this.TagDataType != DataTypes.TagDataType.String && this.TagDataType != DataTypes.TagDataType.CharArray && this.TagDataType != DataTypes.TagDataType.DateTime) " is 183.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag<T>,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTagGeneric.cs,FromBytes,The length of the statement  "                                throw new Exception("Strings in Structs need to be decorated with \"MarshalAs(UnmanagedType.ByValTStr' SizeConst = xx)\""); " is 123.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag<T>,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTagGeneric.cs,GetStructSize,The length of the statement  "                                throw new Exception("Strings in Structs need to be decorated with \"MarshalAs(UnmanagedType.ByValTStr' SizeConst = xx)\""); " is 123.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag<T>,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTagGeneric.cs,ToBytes,The length of the statement  "                                throw new Exception("Strings in Structs need to be decorated with \"MarshalAs(UnmanagedType.ByValTStr' SizeConst = xx)\""); " is 123.
Long Statement,DotNetSiemensPLCToolBoxLibrary.DataTypes.Blocks,DataBlockRow,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Blocks\DataBlockRow.cs,GetChildrowsAsList,The length of the statement  "            if (akRow != null && akRow.Children != null && (akRow.DataType == S7DataRowType.STRUCT || akRow.DataType == S7DataRowType.UDT || akRow.DataType == S7DataRowType.FB)) " is 165.
Long Statement,DotNetSiemensPLCToolBoxLibrary.DataTypes.Blocks.Step5,S5FunctionBlockRow,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Blocks\Step5\S5FunctionBlockRow.cs,ToString,The length of the statement  "		        par = "-" + SymbolTableEntry.Symbol.PadRight(10' ' ') + ("          (" + SymbolTableEntry.Operand + ")").PadRight(18' ' ') + " is 124.
Long Statement,DotNetSiemensPLCToolBoxLibrary.DataTypes.Blocks.Step7V11,TIADataBlock,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Blocks\Step7V11\TIADataBlock.cs,GetArrayExpandedStructure,The length of the statement  "            //Todo: Vergleich der Expand Options' und beim änderen eines inneren wertes des blocks' diesen löschen (erst bei schreibsup wichtig!) " is 133.
Long Statement,DotNetSiemensPLCToolBoxLibrary.DataTypes.Blocks.Step7V11,TIADataRow,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Blocks\Step7V11\TIADataRow.cs,FillBlockAddresses,The length of the statement  "                        if (akAddr.BitAddress != 0 && plcDataRow._datatype == S7DataRowType.BOOL && plcDataRow.WasArray && !plcDataRow.WasFirstInArray && plcDataRow.WasNextHigherIndex) " is 160.
Long Statement,DotNetSiemensPLCToolBoxLibrary.DataTypes.Blocks.Step7V11,TIADataRow,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Blocks\Step7V11\TIADataRow.cs,FillBlockAddresses,The length of the statement  "                        else if (akAddr.BitAddress != 0 && (plcDataRow._datatype != S7DataRowType.BOOL || plcDataRow.IsArray || plcDataRow.WasFirstInArray || (lastRowWasArrayOrStruct && !plcDataRow.WasArray && !plcDataRow.WasFirstInArray))) " is 216.
Long Statement,DotNetSiemensPLCToolBoxLibrary.DataTypes.Blocks.Step7V11,TIADataRow,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Blocks\Step7V11\TIADataRow.cs,FillBlockAddresses,The length of the statement  "                        if (akAddr.ByteAddress % 2 != 0 && ((plcDataRow._datatype != S7DataRowType.BOOL && plcDataRow._datatype != S7DataRowType.BYTE && plcDataRow._datatype != S7DataRowType.CHAR) || plcDataRow.IsArray || plcDataRow.WasFirstInArray || (lastRowWasArrayOrStruct && !plcDataRow.WasArray && !plcDataRow.WasFirstInArray))) " is 310.
Long Statement,DotNetSiemensPLCToolBoxLibrary.DataTypes.Blocks.Step7V5,S7DataBlock,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Blocks\Step7V5\S7DataBlock.cs,GetArrayExpandedStructure,The length of the statement  "            //Todo: Vergleich der Expand Options' und beim änderen eines inneren wertes des blocks' diesen löschen (erst bei schreibsup wichtig!) " is 133.
Long Statement,DotNetSiemensPLCToolBoxLibrary.DataTypes.Blocks.Step7V5,S7DataRow,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Blocks\Step7V5\S7DataRow.cs,FillBlockAddresses,The length of the statement  "                        if (akAddr.BitAddress != 0 && plcDataRow._datatype == S7DataRowType.BOOL && plcDataRow.WasArray && !plcDataRow.WasFirstInArray && plcDataRow.WasNextHigherIndex) " is 160.
Long Statement,DotNetSiemensPLCToolBoxLibrary.DataTypes.Blocks.Step7V5,S7DataRow,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Blocks\Step7V5\S7DataRow.cs,FillBlockAddresses,The length of the statement  "                        else if (akAddr.BitAddress != 0 && (plcDataRow._datatype != S7DataRowType.BOOL || plcDataRow.IsArray || plcDataRow.WasFirstInArray || (lastRowWasArrayOrStruct && !plcDataRow.WasArray && !plcDataRow.WasFirstInArray))) " is 216.
Long Statement,DotNetSiemensPLCToolBoxLibrary.DataTypes.Blocks.Step7V5,S7DataRow,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Blocks\Step7V5\S7DataRow.cs,FillBlockAddresses,The length of the statement  "                        if (akAddr.ByteAddress % 2 != 0 && ((plcDataRow._datatype != S7DataRowType.BOOL && plcDataRow._datatype != S7DataRowType.BYTE && plcDataRow._datatype != S7DataRowType.CHAR) || plcDataRow.IsArray || plcDataRow.WasFirstInArray || (lastRowWasArrayOrStruct && !plcDataRow.WasArray && !plcDataRow.WasFirstInArray))) " is 310.
Long Statement,DotNetSiemensPLCToolBoxLibrary.DataTypes.Blocks.Step7V5,S7FunctionBlock,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Blocks\Step7V5\S7FunctionBlock.cs,GetSourceBlock,The length of the statement  "                        retVal.Append(AWLToSource.DataRowToSource(s7DataRow' "  "' ((this.BlockType != PLCBlockType.FB && this.BlockType != PLCBlockType.SFB) || parnm == "TEMP"))); " is 156.
Long Statement,DotNetSiemensPLCToolBoxLibrary.DataTypes.Blocks.Step7V5,S7FunctionBlockRow,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Blocks\Step7V5\S7FunctionBlockRow.cs,_GetCommandStatusAskValues,The length of the statement  "            else if (this.Command == "+I" || this.Command == "-I" || this.Command == "*I" || this.Command == "/I" || this.Command == "+D" || this.Command == "-D" || this.Command == "*D" || this.Command == "/D" || this.Command == "+R" || this.Command == "-R" || this.Command == "*R" || this.Command == "/R" || this.Command == "MOD") " is 319.
Long Statement,DotNetSiemensPLCToolBoxLibrary.DataTypes.Blocks.Step7V5,S7FunctionBlockRow,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Blocks\Step7V5\S7FunctionBlockRow.cs,_GetCommandStatusAskValues,The length of the statement  "            else if (this.Command == Mnemonic.opPLU[MN] || this.Command == Mnemonic.opABS[MN] || this.Command == Mnemonic.opBTD[MN] || " is 122.
Long Statement,DotNetSiemensPLCToolBoxLibrary.DataTypes.Blocks.Step7V5,S7FunctionBlockRow,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Blocks\Step7V5\S7FunctionBlockRow.cs,_GetCommandStatusAskValues,The length of the statement  "            else if (this.Command == Mnemonic.opTAK[MN] || this.Command == Mnemonic.opL[MN] || this.Command == Mnemonic.opTAR1[MN] || this.Command == Mnemonic.opTAR2[MN]) " is 158.
Long Statement,DotNetSiemensPLCToolBoxLibrary.DataTypes.Blocks.Step7V5,S7FunctionBlockRow,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Blocks\Step7V5\S7FunctionBlockRow.cs,_GetCommandStatusAskValues,The length of the statement  "            else if ((this.Command == Mnemonic.opU[MN] || this.Command == Mnemonic.opUN[MN] || this.Command == Mnemonic.opO[MN] || this.Command == Mnemonic.opON[MN] || this.Command == Mnemonic.opX[MN] || this.Command == Mnemonic.opXN[MN] || this.Command == Mnemonic.opFN[MN] || this.Command == Mnemonic.opFP[MN] || this.Command == Mnemonic.opZUW[MN] || this.Command == Mnemonic.opS[MN] || this.Command == Mnemonic.opR[MN] || this.Command == Mnemonic.opT[MN]) && isDBcall) " is 459.
Long Statement,DotNetSiemensPLCToolBoxLibrary.DataTypes.Blocks.Step7V5,S7FunctionBlockRow,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Blocks\Step7V5\S7FunctionBlockRow.cs,_GetCommandStatusAskValues,The length of the statement  "            else if (this.Command == Mnemonic.opT[MN] || this.Command == Mnemonic.opBLD[MN] || this.Command == Mnemonic.opNOP[MN] || " is 120.
Long Statement,DotNetSiemensPLCToolBoxLibrary.DataTypes.Blocks.Step7V5,S7FunctionBlockRow,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Blocks\Step7V5\S7FunctionBlockRow.cs,_GetCommandStatusAskValues,The length of the statement  "            if (DiagDataTeletype == 0x01 && ((retVal & SelectedStatusValues.Akku1) > 0) || (retVal & SelectedStatusValues.Akku2) > 0) " is 121.
Long Statement,DotNetSiemensPLCToolBoxLibrary.DataTypes.Blocks.Step7V5,S7FunctionBlockRow,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Blocks\Step7V5\S7FunctionBlockRow.cs,ToString,The length of the statement  "            if (ExtParameter != null && ExtParameter.Count > 0 && (Command == Mnemonic.opUC[(int)MnemonicLanguage] || Command == Mnemonic.opCC[(int)MnemonicLanguage])) " is 155.
Long Statement,DotNetSiemensPLCToolBoxLibrary.DataTypes.Blocks.Step7V5,S7FunctionBlockRow,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Blocks\Step7V5\S7FunctionBlockRow.cs,ToString,The length of the statement  "            else if (useDataBlocksSymbolic && Parameter.StartsWith("DB") && Parameter[2] != '[' && Parameter[2] != 'D' && Parameter[2] != 'W' && Parameter[2] != 'B' && Parameter[2] != 'X' && this.Parent != null) " is 199.
Long Statement,DotNetSiemensPLCToolBoxLibrary.DataTypes.Blocks.Step7V5,S7VATBlock,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Blocks\Step7V5\S7VATBlock.cs,ToString,The length of the statement  "                    retVal += akRow.LibNoDaveValue.ToString() + "; " + akRow.LibNoDaveValue.TagDataType.ToString() + "; " + akRow.LibNoDaveValue.DataTypeStringFormat.ToString(); " is 157.
Long Statement,DotNetSiemensPLCToolBoxLibrary.DataTypes.Network,MpiProfiBusNetworkInterface,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Network\MpiProfiBusNetworkInterface.cs,ToString,The length of the statement  "            return string.Format("{0} ({1}) Address: {2}"' Name' this.NetworkInterfaceType == NetworkType.Profibus ? "ProfiBus" : "MPI"' this.Address); " is 139.
Long Statement,DotNetSiemensPLCToolBoxLibrary.DataTypes.Projectfolders.Step5,ReferenceData,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Projectfolders\Step5\ReferenceData.cs,LoadReferenceData,The length of the statement  "                    if (projectBlockInfo.BlockType == PLCBlockType.S5_PB || projectBlockInfo.BlockType == PLCBlockType.S5_FB || projectBlockInfo.BlockType == PLCBlockType.S5_FX || projectBlockInfo.BlockType == PLCBlockType.S5_OB || projectBlockInfo.BlockType == PLCBlockType.S5_SB) " is 261.
Long Statement,DotNetSiemensPLCToolBoxLibrary.DataTypes.Projectfolders.Step5,ReferenceData,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Projectfolders\Step5\ReferenceData.cs,LoadReferenceData,The length of the statement  "                                if (functionBlockRow.MC5LIB_SYMTAB_Row != null && ((ReferenceDataAccessMode)functionBlockRow.MC5LIB_SYMTAB_Row[9]) != ReferenceDataAccessMode.None) " is 147.
Long Statement,DotNetSiemensPLCToolBoxLibrary.DataTypes.Projectfolders.Step5,ReferenceData,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Projectfolders\Step5\ReferenceData.cs,LoadReferenceData,The length of the statement  "                                    entr.ReferencePoints.Add(new ReferencePoint() { Block = blk' Network = network' NetworkNumber = networkNR' LineNumber = rowNR' BlockRow = functionBlockRow' AccessMode = (ReferenceDataAccessMode)functionBlockRow.MC5LIB_SYMTAB_Row[9] }); " is 235.
Long Statement,DotNetSiemensPLCToolBoxLibrary.DataTypes.Projectfolders.Step5,ReferenceData,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Projectfolders\Step5\ReferenceData.cs,LoadReferenceData,The length of the statement  "                                        if (functionBlockRow.Parameter.StartsWith("D ") || functionBlockRow.Parameter.StartsWith("DW") || functionBlockRow.Parameter.StartsWith("DL") || functionBlockRow.Parameter.StartsWith("DR") || functionBlockRow.Parameter.StartsWith("DX")) " is 236.
Long Statement,DotNetSiemensPLCToolBoxLibrary.DataTypes.Projectfolders.Step5,ReferenceData,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Projectfolders\Step5\ReferenceData.cs,LoadReferenceData,The length of the statement  "                                            entr.ReferencePoints.Add(new ReferencePoint() { Block = blk' Network = network' NetworkNumber = networkNR' LineNumber = rowNR' BlockRow = functionBlockRow' AccessMode = (ReferenceDataAccessMode)functionBlockRow.MC5LIB_SYMTAB_Row[9] }); " is 235.
Long Statement,DotNetSiemensPLCToolBoxLibrary.DataTypes.Projectfolders.Step5,ReferenceData,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Projectfolders\Step5\ReferenceData.cs,LoadReferenceData,The length of the statement  "                MessageBox.Show("There was an error generating the Reference Data! Maybe the Step5 project is broken? \n" + ex.Message); " is 120.
Long Statement,DotNetSiemensPLCToolBoxLibrary.DataTypes.Projectfolders.Step5,Step5BlocksFolder,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Projectfolders\Step5\Step5BlocksFolder.cs,GetBlock,The length of the statement  "            //string bb = System.Text.Encoding.GetEncoding("ISO-8859-1").GetString(((Step5ProjectBlockInfo)blkInfo)._blkHeaderByte); " is 120.
Long Statement,DotNetSiemensPLCToolBoxLibrary.DataTypes.Projectfolders.Step5,Step5BlocksFolder,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Projectfolders\Step5\Step5BlocksFolder.cs,GetBlock,The length of the statement  "                retVal = MC5toDB.GetDB((ProjectPlcBlockInfo)plcblkInfo' ((S5ProjectBlockInfo)blkInfo)._blkByte' GetBlockInByte("S5_DV" + plcblkInfo.BlockNumber.ToString())' GetBlockInByte("S5_DK" + plcblkInfo.BlockNumber.ToString())); " is 218.
Long Statement,DotNetSiemensPLCToolBoxLibrary.DataTypes.Projectfolders.Step5,Step5BlocksFolder,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Projectfolders\Step5\Step5BlocksFolder.cs,GetBlock,The length of the statement  "                retVal = MC5toDB.GetDB((ProjectPlcBlockInfo)plcblkInfo' ((S5ProjectBlockInfo)blkInfo)._blkByte' GetBlockInByte("S5_DVX" + plcblkInfo.BlockNumber.ToString())' GetBlockInByte("S5_DKX" + plcblkInfo.BlockNumber.ToString())); " is 220.
Long Statement,DotNetSiemensPLCToolBoxLibrary.DataTypes.Projectfolders.Step5,Step5BlocksFolder,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Projectfolders\Step5\Step5BlocksFolder.cs,GetBlock,The length of the statement  "                retVal = MC5toAWL.GetFunctionBlock((ProjectPlcBlockInfo)blkInfo' ((S5ProjectBlockInfo)blkInfo)._blkByte' null' GetBlockInByte("S5_PK" + plcblkInfo.BlockNumber.ToString())' (Step5ProgrammFolder)blkInfo.ParentFolder.Parent); " is 222.
Long Statement,DotNetSiemensPLCToolBoxLibrary.DataTypes.Projectfolders.Step5,Step5BlocksFolder,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Projectfolders\Step5\Step5BlocksFolder.cs,GetBlock,The length of the statement  "                retVal = MC5toAWL.GetFunctionBlock(plcblkInfo' ((S5ProjectBlockInfo)blkInfo)._blkByte' GetBlockInByte("S5_FV" + plcblkInfo.BlockNumber.ToString())' GetBlockInByte("S5_FK" + plcblkInfo.BlockNumber.ToString())' (Step5ProgrammFolder)blkInfo.ParentFolder.Parent); " is 259.
Long Statement,DotNetSiemensPLCToolBoxLibrary.DataTypes.Projectfolders.Step5,Step5BlocksFolder,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Projectfolders\Step5\Step5BlocksFolder.cs,GetBlock,The length of the statement  "                retVal = MC5toAWL.GetFunctionBlock(plcblkInfo' ((S5ProjectBlockInfo)blkInfo)._blkByte' null' GetBlockInByte("S5_SK" + plcblkInfo.BlockNumber.ToString())' (Step5ProgrammFolder)blkInfo.ParentFolder.Parent); " is 204.
Long Statement,DotNetSiemensPLCToolBoxLibrary.DataTypes.Projectfolders.Step5,Step5BlocksFolder,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Projectfolders\Step5\Step5BlocksFolder.cs,GetBlock,The length of the statement  "                retVal = MC5toAWL.GetFunctionBlock(plcblkInfo' ((S5ProjectBlockInfo)blkInfo)._blkByte' GetBlockInByte("S5_FVX" + plcblkInfo.BlockNumber.ToString())' GetBlockInByte("S5_FKX" + plcblkInfo.BlockNumber.ToString())' (Step5ProgrammFolder)blkInfo.ParentFolder.Parent); " is 261.
Long Statement,DotNetSiemensPLCToolBoxLibrary.DataTypes.Projectfolders.Step5,Step5BlocksFolder,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Projectfolders\Step5\Step5BlocksFolder.cs,GetBlock,The length of the statement  "                retVal = MC5toAWL.GetFunctionBlock(plcblkInfo' ((S5ProjectBlockInfo)blkInfo)._blkByte' null' GetBlockInByte("S5_OK" + plcblkInfo.BlockNumber.ToString())' (Step5ProgrammFolder)blkInfo.ParentFolder.Parent); " is 204.
Long Statement,DotNetSiemensPLCToolBoxLibrary.DataTypes.Projectfolders.Step7V5,BlocksOfflineFolder,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Projectfolders\Step7V5\BlocksOfflineFolder.cs,intReadPlcBlocksList,The length of the statement  "                        if (tmp.BlockType == PLCBlockType.SFB || tmp.BlockType == PLCBlockType.SFC || tmp.BlockType == PLCBlockType.SDB || tmp.BlockType == PLCBlockType.DB || tmp.BlockType == PLCBlockType.VAT || tmp.BlockType == PLCBlockType.FB || tmp.BlockType == PLCBlockType.FC || tmp.BlockType == PLCBlockType.OB || tmp.BlockType == PLCBlockType.UDT) " is 330.
Long Statement,DotNetSiemensPLCToolBoxLibrary.DataTypes.Projectfolders.Step7V5,BlocksOfflineFolder,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Projectfolders\Step7V5\BlocksOfflineFolder.cs,ChangeKnowHowProtection,The length of the statement  "                            DBF.ParseDBF.WriteValue(Folder + "SUBBLK.DBF"' "PASSWORD"' dbfTbl.Rows.IndexOf(row)' 3' ((Step7ProjectV5)Project)._ziphelper' ((Step7ProjectV5)Project)._DirSeperator); " is 167.
Long Statement,DotNetSiemensPLCToolBoxLibrary.DataTypes.Projectfolders.Step7V5,BlocksOfflineFolder,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Projectfolders\Step7V5\BlocksOfflineFolder.cs,ChangeKnowHowProtection,The length of the statement  "                            DBF.ParseDBF.WriteValue(Folder + "SUBBLK.DBF"' "PASSWORD"' dbfTbl.Rows.IndexOf(row)' 0' ((Step7ProjectV5)Project)._ziphelper' ((Step7ProjectV5)Project)._DirSeperator); " is 167.
Long Statement,DotNetSiemensPLCToolBoxLibrary.DataTypes.Projectfolders.Step7V5,BlocksOfflineFolder,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Projectfolders\Step7V5\BlocksOfflineFolder.cs,UndeleteBlock,The length of the statement  "                var dbfTbl = DBF.ParseDBF.ReadDBF(Folder + "BAUSTEIN.DBF"' ((Step7ProjectV5)Project)._ziphelper' ((Step7ProjectV5)Project)._DirSeperator); " is 138.
Long Statement,DotNetSiemensPLCToolBoxLibrary.DataTypes.Projectfolders.Step7V5,BlocksOfflineFolder,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Projectfolders\Step7V5\BlocksOfflineFolder.cs,UndeleteBlock,The length of the statement  "                        DBF.ParseDBF.WriteValue(Folder + "BAUSTEIN.DBF"' "DELETED_FLAG"' dbfTbl.Rows.IndexOf(row)' false' ((Step7ProjectV5)Project)._ziphelper' ((Step7ProjectV5)Project)._DirSeperator); " is 177.
Long Statement,DotNetSiemensPLCToolBoxLibrary.DataTypes.Projectfolders.Step7V5,BlocksOfflineFolder,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Projectfolders\Step7V5\BlocksOfflineFolder.cs,UndeleteBlock,The length of the statement  "                        DBF.ParseDBF.WriteValue(Folder + "BAUSTEIN.DBF"' "NUMMER"' dbfTbl.Rows.IndexOf(row)' newBlockNumber' ((Step7ProjectV5)Project)._ziphelper' ((Step7ProjectV5)Project)._DirSeperator); " is 180.
Long Statement,DotNetSiemensPLCToolBoxLibrary.DataTypes.Projectfolders.Step7V5,BlocksOfflineFolder,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Projectfolders\Step7V5\BlocksOfflineFolder.cs,UndeleteBlock,The length of the statement  "                var dbfTbl = DBF.ParseDBF.ReadDBF(Folder + "SUBBLK.DBF"' ((Step7ProjectV5)Project)._ziphelper' ((Step7ProjectV5)Project)._DirSeperator); " is 136.
Long Statement,DotNetSiemensPLCToolBoxLibrary.DataTypes.Projectfolders.Step7V5,BlocksOfflineFolder,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Projectfolders\Step7V5\BlocksOfflineFolder.cs,UndeleteBlock,The length of the statement  "                        DBF.ParseDBF.WriteValue(Folder + "SUBBLK.DBF"' "DELETED_FLAG"' dbfTbl.Rows.IndexOf(row)' false' ((Step7ProjectV5)Project)._ziphelper' ((Step7ProjectV5)Project)._DirSeperator); " is 175.
Long Statement,DotNetSiemensPLCToolBoxLibrary.DataTypes.Projectfolders.Step7V5,BlocksOfflineFolder,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Projectfolders\Step7V5\BlocksOfflineFolder.cs,UndeleteBlock,The length of the statement  "                        DBF.ParseDBF.WriteValue(Folder + "SUBBLK.DBF"' "BLKNUMBER"' dbfTbl.Rows.IndexOf(row)' newBlockNumber' ((Step7ProjectV5)Project)._ziphelper' ((Step7ProjectV5)Project)._DirSeperator); " is 181.
Long Statement,DotNetSiemensPLCToolBoxLibrary.DataTypes.Projectfolders.Step7V5,BlocksOfflineFolder,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Projectfolders\Step7V5\BlocksOfflineFolder.cs,GetBlockBytes,The length of the statement  "                        if (subblktype == 12 || subblktype == 8 || subblktype == 14 || subblktype == 13 || subblktype == 15) //FC' OB' FB' SFC' SFB " is 123.
Long Statement,DotNetSiemensPLCToolBoxLibrary.DataTypes.Projectfolders.Step7V5,BlocksOfflineFolder,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Projectfolders\Step7V5\BlocksOfflineFolder.cs,GetBlockBytes,The length of the statement  "                        else if (subblktype == 5 || subblktype == 3 || subblktype == 4 || subblktype == 7 || subblktype == 9) //FC' OB' FB' SFC' SFB " is 124.
Long Statement,DotNetSiemensPLCToolBoxLibrary.DataTypes.Projectfolders.Step7V5,BlocksOfflineFolder,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Projectfolders\Step7V5\BlocksOfflineFolder.cs,GetInterface,The length of the statement  "            return Parameter.GetInterfaceOrDBFromStep7ProjectString(myTmpBlk.blkinterface' ref tmpPar' blkInfo.BlockType' false' this' null); " is 129.
Long Statement,DotNetSiemensPLCToolBoxLibrary.DataTypes.Projectfolders.Step7V5,BlocksOfflineFolder,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Projectfolders\Step7V5\BlocksOfflineFolder.cs,GetBlock,The length of the statement  "                    S7VATBlock retValBlock = new S7VATBlock(myTmpBlk.mc7code' myTmpBlk.comments' plcblkifo.BlockNumber' Project.ProjectEncoding); " is 125.
Long Statement,DotNetSiemensPLCToolBoxLibrary.DataTypes.Projectfolders.Step7V5,BlocksOfflineFolder,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Projectfolders\Step7V5\BlocksOfflineFolder.cs,GetBlock,The length of the statement  "                    retVal.StructureFromString = Parameter.GetInterfaceOrDBFromStep7ProjectString(myTmpBlk.blkinterface' ref tmpList' blkInfo.BlockType' false' this' retVal' myTmpBlk.mc7code); " is 172.
Long Statement,DotNetSiemensPLCToolBoxLibrary.DataTypes.Projectfolders.Step7V5,BlocksOfflineFolder,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Projectfolders\Step7V5\BlocksOfflineFolder.cs,GetBlock,The length of the statement  "                        //retVal.StructureFromMC7 = Parameter.GetInterface(myTmpBlk.blkinterfaceInMC5' myTmpBlk.mc7code' ref tmp' blkInfo.BlockType' myTmpBlk.IsInstanceDB' retVal); " is 156.
Long Statement,DotNetSiemensPLCToolBoxLibrary.DataTypes.Projectfolders.Step7V5,BlocksOfflineFolder,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Projectfolders\Step7V5\BlocksOfflineFolder.cs,GetBlock,The length of the statement  "                else if (blkInfo.BlockType == PLCBlockType.FC || blkInfo.BlockType == PLCBlockType.FB || blkInfo.BlockType == PLCBlockType.OB || blkInfo.BlockType == PLCBlockType.SFB || blkInfo.BlockType == PLCBlockType.SFC) " is 208.
Long Statement,DotNetSiemensPLCToolBoxLibrary.DataTypes.Projectfolders.Step7V5,BlocksOfflineFolder,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Projectfolders\Step7V5\BlocksOfflineFolder.cs,GetBlock,The length of the statement  "                    retVal.Parameter = Parameter.GetInterfaceOrDBFromStep7ProjectString(myTmpBlk.blkinterface' ref ParaList' blkInfo.BlockType' false' this' retVal); " is 145.
Long Statement,DotNetSiemensPLCToolBoxLibrary.DataTypes.Projectfolders.Step7V5,BlocksOfflineFolder,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Projectfolders\Step7V5\BlocksOfflineFolder.cs,GetBlock,The length of the statement  "                        retVal.Description = Project.ProjectEncoding.GetString(myTmpBlk.blockdescription' myTmpBlk.blockdescription[1]' myTmpBlk.blockdescription.Length - myTmpBlk.blockdescription[1] - 1).Replace("\n"' Environment.NewLine); " is 216.
Long Statement,DotNetSiemensPLCToolBoxLibrary.DataTypes.Projectfolders.Step7V5,BlocksOfflineFolder,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Projectfolders\Step7V5\BlocksOfflineFolder.cs,GetBlock,The length of the statement  "                    if (blkInfo.BlockType == PLCBlockType.FC || blkInfo.BlockType == PLCBlockType.FB || blkInfo.BlockType == PLCBlockType.OB) " is 121.
Long Statement,DotNetSiemensPLCToolBoxLibrary.DataTypes.Projectfolders.Step7V5,BlocksOfflineFolder,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Projectfolders\Step7V5\BlocksOfflineFolder.cs,GetBlock,The length of the statement  "                        retVal.AWLCode = MC7toAWL.GetAWL(0' myTmpBlk.mc7code.Length - 2' (int)myConvOpt.Mnemonic' myTmpBlk.mc7code' Networks' ParaList' prgFld' retVal' retVal.Parameter); " is 162.
Long Statement,DotNetSiemensPLCToolBoxLibrary.DataTypes.Projectfolders.Step7V5,BlocksOfflineFolder,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Projectfolders\Step7V5\BlocksOfflineFolder.cs,GetBlock,The length of the statement  "                                        string tx2 = Project.ProjectEncoding.GetString(cmt' n + startNWKomm' lenNWKommZeile - startNWKomm - 1).Replace("\n"' Environment.NewLine); " is 138.
Long Statement,DotNetSiemensPLCToolBoxLibrary.DataTypes.Projectfolders.Step7V5,BlocksOfflineFolder,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Projectfolders\Step7V5\BlocksOfflineFolder.cs,GetSourceBlock,The length of the statement  "            Block blk = GetBlock(blkInfo' new S7ConvertingOptions(Project.ProjectLanguage) { CombineDBOpenAndDBAccess = true' GenerateCallsfromUCs = true' ReplaceDBAccessesWithSymbolNames = useSymbols' ReplaceLokalDataAddressesWithSymbolNames = true' UseComments = true }); " is 261.
Long Statement,DotNetSiemensPLCToolBoxLibrary.DataTypes.Projectfolders.Step7V5,SourceFolder,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Projectfolders\Step7V5\SourceFolder.cs,readPlcBlocksList,The length of the statement  "                var dbfTbl = DBF.ParseDBF.ReadDBF(Folder + "S7CONTAI.DBF"' ((Step7ProjectV5)Project)._ziphelper' ((Step7ProjectV5)Project)._DirSeperator); " is 138.
Long Statement,DotNetSiemensPLCToolBoxLibrary.DataTypes.Projectfolders.Step7V5,SymbolTable,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Projectfolders\Step7V5\SymbolTable.cs,LoadSymboltable,The length of the statement  "                    var dbfTbl = DBF.ParseDBF.ReadDBF(Folder + "SYMLIST.DBF"' ((Step7ProjectV5)Project)._ziphelper' ((Step7ProjectV5)Project)._DirSeperator' Project.ProjectEncoding); " is 162.
Long Statement,DotNetSiemensPLCToolBoxLibrary.DBF,dBaseConverter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DBF\Util.cs,D_FromDateTime,The length of the statement  "            string DateTimeString = DateTimeToConvert.Year.ToString() + DateTimeToConvert.Month.ToString() + DateTimeToConvert.Day.ToString(); " is 130.
Long Statement,DotNetSiemensPLCToolBoxLibrary.DBF.Structures.MDX,MDX4TagTableHeader,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DBF\Structures\MDX\MDX4TagTableHeader.cs,Read,The length of the statement  "            MDX4TagTableHeader TempObject = (MDX4TagTableHeader)Marshal.PtrToStructure(handle.AddrOfPinnedObject()' typeof(MDX4TagTableHeader)); " is 132.
Long Statement,DotNetSiemensPLCToolBoxLibrary.DBF.Structures.MDX,MDX7TagTableHeader,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DBF\Structures\MDX\MDX7TagTableHeader.cs,Read,The length of the statement  "            MDX7TagTableHeader TempObject = (MDX7TagTableHeader)Marshal.PtrToStructure(handle.AddrOfPinnedObject()' typeof(MDX7TagTableHeader)); " is 132.
Long Statement,DotNetSiemensPLCToolBoxLibrary.General,DictionarySerializer<K;V>,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\General\DictionarySerializer.cs,Deserialize,The length of the statement  "            List<SerializableKeyValuePair<K' V>> dictionaryItems = Serializer.Deserialize(serializationStream) as List<SerializableKeyValuePair<K' V>>; " is 139.
Long Statement,DotNetSiemensPLCToolBoxLibrary.General,DictionarySerializer<K;V>,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\General\DictionarySerializer.cs,Deserialize,The length of the statement  "            List<SerializableKeyValuePair<K' V>> dictionaryItems = Serializer.Deserialize(serializationStream) as List<SerializableKeyValuePair<K' V>>; " is 139.
Long Statement,DotNetSiemensPLCToolBoxLibrary.General,DictionarySerializer<K;V>,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\General\DictionarySerializer.cs,Deserialize,The length of the statement  "            List<SerializableKeyValuePair<K' V>> dictionaryItems = Serializer.Deserialize(serializationStream) as List<SerializableKeyValuePair<K' V>>; " is 139.
Long Statement,DotNetSiemensPLCToolBoxLibrary.General,EndianessMarshaler,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\General\EndianAttribute.cs,RespectEndianness,The length of the statement  "            foreach (FieldInfo f in type.GetFields(BindingFlags.Instance | BindingFlags.NonPublic)) //BindingFlags.Instance | BindingFlags.NonPublic)) " is 138.
Long Statement,DotNetSiemensPLCToolBoxLibrary.General,EndianessMarshaler,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\General\EndianAttribute.cs,RespectEndianness,The length of the statement  "                    if ((att.Endianness == Endianness.BigEndian && BitConverter.IsLittleEndian) || (att.Endianness == Endianness.LittleEndian && !BitConverter.IsLittleEndian)) " is 155.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S5.MC5,MC5toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S5\MC5\MC5toAWL.cs,GetFunctionBlock,The length of the statement  "            if (blkInfo.BlockType == PLCBlockType.S5_PB || blkInfo.BlockType == PLCBlockType.S5_SB || blkInfo.BlockType == PLCBlockType.S5_OB) " is 130.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S5.MC5,MC5toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S5\MC5\MC5toAWL.cs,GetFunctionBlock,The length of the statement  "                retVal.AWLCode = GetMC5Rows(block' /*10 + spa*2*/ 10 + ((pars.Count * 3) + 5) * 2' pars' (Step5BlocksFolder)blkInfo.ParentFolder' retVal); " is 138.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S5.MC5,MC5toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S5\MC5\MC5toAWL.cs,GetMC5Rows,The length of the statement  "            retVal.Add(new S5FunctionBlockRow() { Command = "BLD"' Parameter = "255"' Parent = block }); //Command for first Network does not exist! " is 136.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S5.MC5,MC5toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S5\MC5\MC5toAWL.cs,GetMC5Rows,The length of the statement  "                                newRow.Parameter += ((char)(BitConverter.GetBytes((Int16)par)[0])).ToString() + ((char)(BitConverter.GetBytes((Int16)par)[1])); " is 127.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S5.MC5,MC5toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S5\MC5\MC5toAWL.cs,GetMC5Rows,The length of the statement  "                if (tmp.Command == "SPA=" || tmp.Command == "SPB=" || tmp.Command == "SPZ=" || tmp.Command == "SPN=" || tmp.Command == "SPP=" || tmp.Command == "SPM=" || tmp.Command == "SPO=") " is 176.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,AWLCodeOptimizer,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\AWLCodeOptimizer.cs,OptimizeAWL,The length of the statement  "                else if (myAkVal.Label != "" || myAkVal.Command == Mnemonic.opUC[akMemnoic] || myAkVal.Command == Mnemonic.opCC[akMemnoic]) //If there is a Jump or Call' reset the actual DB! " is 174.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,AWLtoMC7,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\AWLtoMC7.cs,GetMC7,The length of the statement  "                                return new byte[] { 0xFB' 0x72' Helper.GetParameterValueBytes(myCmd.Parameter)[1]' Helper.GetParameterValueBytes(myCmd.Parameter)[0] }; " is 135.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,AWLtoMC7,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\AWLtoMC7.cs,GetMC7,The length of the statement  "                                return new byte[] { 0xFB' 0x70' Helper.GetParameterValueBytes(myCmd.Parameter)[1]' Helper.GetParameterValueBytes(myCmd.Parameter)[0]' 0x70' 0x0B' 0x00' 0x02 }; " is 159.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,AWLtoMC7,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\AWLtoMC7.cs,GetMC7,The length of the statement  "                                myAddVal.AddRange(new byte[] { 0xFB' 0x70' 0x00' Helper.GetParameterValueBytes(myCmd.Parameter)[0]' 0x70' 0x0B' 0x00 }); " is 120.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,AWLtoMC7,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\AWLtoMC7.cs,GetMC7,The length of the statement  "                                myAddVal.AddRange(new byte[] { 0xFB' 0x70' Helper.GetParameterValueBytes(myCmd.Parameter)[1]' Helper.GetParameterValueBytes(myCmd.Parameter)[0]' 0x70' 0x0B' 0x00 }); " is 165.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,AWLtoMC7,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\AWLtoMC7.cs,GetMC7,The length of the statement  "                            return new byte[] { 0xFB' Convert.ToByte(Helper.GetIndirectBytesWord(myCmd.Parameter)[2] | 0x02)' Helper.GetIndirectBytesWord(myCmd.Parameter)[1]' Helper.GetIndirectBytesWord(myCmd.Parameter)[0]' 0x70' 0x0B' 0x00' 0x02 }; " is 221.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,AWLtoMC7,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\AWLtoMC7.cs,GetMC7,The length of the statement  "                            return new byte[] { 0xFB' Convert.ToByte(Helper.GetIndirectBytesWord(myCmd.Parameter)[2] | 0x00)' Helper.GetIndirectBytesWord(myCmd.Parameter)[1]' Helper.GetIndirectBytesWord(myCmd.Parameter)[0]' 0x70' 0x0B' 0x00' 0x02 }; " is 221.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,AWLToSource,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\AWLToSource.cs,DataRowToSource,The length of the statement  "                    retval += (s7DataRow.DataTypeBlockNumber != 0 ? s7DataRow.DataTypeBlockNumber.ToString() : "") + " " + val + ";" + cmt + Environment.NewLine; " is 141.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,CallConverter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\CallConverter.cs,ConvertUCToCall,The length of the statement  "                    if (row.Command == Mnemonic.opBLD[(int)myOpt.Mnemonic] && (row.Parameter == "1" || row.Parameter == "7" || row.Parameter == "3" || row.Parameter == "16" || row.Parameter == "14") && inBld == 0) " is 193.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,CallConverter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\CallConverter.cs,ConvertUCToCall,The length of the statement  "                                Array.Copy(((S7FunctionBlockRow) functionBlockRow).MC7' 0' mcges' sz' ((S7FunctionBlockRow) functionBlockRow).ByteSize); " is 120.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,CallConverter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\CallConverter.cs,ConvertUCToCall,The length of the statement  "                                    multiInstanceOffset += (int)double.Parse((((S7FunctionBlockRow)tempList[j]).Parameter.Substring(2))' CultureInfo.InvariantCulture); " is 131.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,CallConverter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\CallConverter.cs,ConvertUCToCall,The length of the statement  "                        else if (row.Command == Mnemonic.opBLD[(int)myOpt.Mnemonic] && (row.Parameter == "4" || row.Parameter == "17" || row.Parameter == "15")) " is 136.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,CallConverter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\CallConverter.cs,ConvertUCToCall,The length of the statement  "                                            var pRow = S7DataRow.GetDataRowWithAddress(myFct.Parameter.Children.Where(itm => itm.Name != "TEMP").Cast<S7DataRow>()' new ByteBitAddress(addr)); " is 146.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,CallConverter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\CallConverter.cs,ConvertUCToCall,The length of the statement  "                                            if (pRow != null) newPar.Value = ((S7DataRow)pRow).StructuredName.Substring(((S7DataRow)pRow).StructuredName.IndexOf('.') + 1); " is 127.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,FBStaticAccessConverter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\FBStaticAccessConverter.cs,ReplaceStaticAccess,The length of the statement  "                        add_adresse += Convert.ToInt32(Convert.ToDouble(((S7FunctionBlockRow) functionBlockRow).Parameter.Substring(2)' new NumberFormatInfo() {NumberDecimalSeparator = "."})); " is 168.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,FBStaticAccessConverter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\FBStaticAccessConverter.cs,ReplaceStaticAccess,The length of the statement  "                    else if (((S7FunctionBlockRow)functionBlockRow).Parameter.Contains("[AR2'P#") && ((S7FunctionBlockRow)functionBlockRow).Parameter.Substring(0' 2) == "DI" && !LargeAccess) " is 170.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,FBStaticAccessConverter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\FBStaticAccessConverter.cs,ReplaceStaticAccess,The length of the statement  "                            ((S7FunctionBlockRow) functionBlockRow).Parameter = "#" + parRow.StructuredName.Substring(parRow.StructuredName.IndexOf('.') + 1); " is 130.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,FBStaticAccessConverter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\FBStaticAccessConverter.cs,ReplaceStaticAccess,The length of the statement  "                    else if (((S7FunctionBlockRow)functionBlockRow).Parameter.Contains("[AR2'P#") && ((S7FunctionBlockRow)functionBlockRow).Parameter.Substring(0' 2) == "DI" && LargeAccess) " is 169.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,ValueToString,The length of the statement  "            if (DataType == S7DataRowType.S5_KY) return ((UInt16)Value / 256).ToString().PadLeft(3' '0') + "'" + ((UInt16)Value % 256).ToString().PadLeft(3' '0'); " is 150.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,ValueToString,The length of the statement  "            else if (DataType == S7DataRowType.S5_KH) return ((UInt16)Value).ToString("X"' NumberFormatInfo.CurrentInfo).PadLeft(4' '0'); " is 125.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,ValueToString,The length of the statement  "            else if (DataType == S7DataRowType.S5_C || DataType == S7DataRowType.S5_KC) return "'" + ((string)Value) + "'"; //.PadLeft(4' ' ')  " is 130.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,ValueToString,The length of the statement  "            else if (DataType == S7DataRowType.DWORD) return "DW#16#" + ((UInt32)Value).ToString("X"' NumberFormatInfo.CurrentInfo); " is 120.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,ValueToString,The length of the statement  "            else if (DataType == S7DataRowType.REAL) return ((Double)Value).ToString("0.000000e+000"' CultureInfo.InvariantCulture); " is 120.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetIntFromHexString,The length of the statement  "            foreach (char tmp in myString.ToLower().Replace("dw#16#"' "").Replace("w#16#"' "").Replace("b#16#"' "").Replace("\t"'"")) " is 121.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetUIntFromHexString,The length of the statement  "            foreach (char tmp in myString.ToLower().Replace("dw#16#"' "").Replace("w#16#"' "").Replace("b#16#"' "").Replace("\t"' "")) " is 122.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GenerateFBParameterUsesFromAR2Calls,The length of the statement  "                    (combineStep == 2 && plcFunctionBlockRow.Command == MC7.Mnemonic.opLAR2[Memnoic] && plcFunctionBlockRow.Parameter == TarLdTarget) || " is 132.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetPointer,The length of the statement  "                        Result = Result + Convert.ToString((BD[pos + 1] * 0x10000 + BD[pos + 2] * 0x100 + BD[pos + 3]) >> 3) + "." + Convert.ToString(BD[pos+3] & 0x07); " is 144.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,TryGetStructuredName,The length of the statement  "             blockAddress.ByteAddress = int.Parse(pointPosition< 0 ? address.Substring(3) : address.Substring(3' pointPosition - 3)); " is 120.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,JumpMarks,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\JumpMarks.cs,GetJumpadresses,The length of the statement  "                    JumpPos[i] = BitConverter.ToUInt16(BD' startJump+2 + (i * 2)); // Helper.GetWord(BD[Start + (i * 2) + 1]' BD[Start + (i * 2)]); " is 127.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,JumpMarks,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\JumpMarks.cs,AddJumpmarks,The length of the statement  "                int anzJ = BitConverter.ToInt16(JumpMarks' NetworkCount * 2);  //Todo: find out why it does not always contain the right amount of JumpNames " is 140.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,LocalDataConverter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\LocalDataConverter.cs,ConvertLocaldataToSymbols,The length of the statement  "                            TiaAndSTep7DataBlockRow tmpRw = ((TiaAndSTep7DataBlockRow)plcDataRow)._GetExpandedChlidren(new S7DataBlockExpandOptions() { ExpandCharArrays = true' ExpandSubChildInINOUT = false })[0]; " is 185.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,LocalDataConverter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\LocalDataConverter.cs,ConvertLocaldataToSymbols,The length of the statement  "                        if (plcDataRow.DataType != S7DataRowType.STRUCT && plcDataRow.DataType != S7DataRowType.UDT && plcDataRow.DataType != S7DataRowType.FB) " is 135.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,LocalDataConverter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\LocalDataConverter.cs,ConvertLocaldataToSymbols,The length of the statement  "                    if (!plcFunctionBlockRow.Parameter.Contains("'") && !plcFunctionBlockRow.Parameter.Contains("[AR")  && plcFunctionBlockRow.Parameter.Contains("[")) " is 147.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7Converter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7Converter.cs,ParseBlockHeaderAndFooterFromMC7,The length of the statement  "                retBlock.BlockVersion = Convert.ToString(MC7Code[2] - 1);  //This is not the Block version from the Simatic Manager. It is unclar what data is stored in MC7Code[2] " is 163.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7Converter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7Converter.cs,ParseBlockHeaderAndFooterFromMC7,The length of the statement  "                retBlock.BlockLanguage = (PLCLanguage)MC7Code[4]; // Enum.Parse(typeof(DataTypes.PLCLanguage)' Helper.GetLang(MC7Code[4])); " is 123.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7Converter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7Converter.cs,ParseBlockHeaderAndFooterFromMC7,The length of the statement  "                retBlock.KnowHowProtection = (MC7Code[12] + MC7Code[13] + MC7Code[14] + MC7Code[15]) != 0; //if any of the Password bytes contains an non Zero value " is 148.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7Converter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7Converter.cs,ParseBlockHeaderAndFooterFromMC7,The length of the statement  "                retBlock.LastInterfaceChange = Helper.GetDT(MC7Code[22]' MC7Code[23]' MC7Code[24]' MC7Code[25]' MC7Code[26]' MC7Code[27]); " is 122.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7Converter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7Converter.cs,ParseBlockHeaderAndFooterFromMC7,The length of the statement  "                retBlock.WorkMemorySize = retBlock.CodeSize + MC7Start_or_DBBodyStart;  //in my tests(about 10 different blocks)' this was alwasy 36 bytes more then the MC7 code size " is 166.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7Converter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7Converter.cs,ParseBlockHeaderAndFooterFromMC7,The length of the statement  "                //Old: int FooterStart = MC7Start_or_DBBodyStart + MC7Length_or_DBBodyLength + InterfaceLength_or_DBActualValuesLength + retBlock.SegmentTableSize; " is 147.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7Converter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7Converter.cs,ParseBlockHeaderAndFooterFromMC7,The length of the statement  "                //so use this version' so that now there is no need for "GetAWLBlockBasicInfoFromBlockHeader" because its actually the same " is 123.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7Converter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7Converter.cs,GetAWLBlock,The length of the statement  "                if (retBlock.BlockType == PLCBlockType.DB || retBlock.BlockType == PLCBlockType.SDB) //Block is an Data block or System Data block " is 130.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7Converter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7Converter.cs,GetAWLBlock,The length of the statement  "                    Array.Copy(MC7Code' IntfStart - 3' interfaceBytes' 0' IntfLength + 3); //-3 because of in the project file in the structere ssbpart is also the same structure with this 4 bytes!! " is 178.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7Converter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7Converter.cs,GetAWLBlock,The length of the statement  "                    ((S7DataBlock)retBlock).StructureFromMC7 = Parameter.GetInterface(interfaceBytes' startValues' actualValues' ref tmp' retBlock.BlockType' ((S7DataBlock)retBlock).IsInstanceDB' retBlock); " is 186.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7Converter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7Converter.cs,GetAWLBlock,The length of the statement  "                    Array.Copy(MC7Code' IntfStart - 3' interfaceBytes' 0' IntfLength + 3); //-3 because of in the project file in the structere ssbpart is also the same structure with this 4 bytes!! " is 178.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7Converter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7Converter.cs,GetAWLBlock,The length of the statement  "                    if (retBlock.BlockType == PLCBlockType.FB && startValueLength > 0) //only FB's my have start values' even then they might not exist if none are defined (length = 0) " is 164.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7Converter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7Converter.cs,GetAWLBlock,The length of the statement  "                    ((S7FunctionBlock)retBlock).Parameter = Parameter.GetInterface(interfaceBytes' startValues' null /*there are never Current values in code blocks*/' ref ParaList' retBlock.BlockType' false' retBlock); " is 199.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7Converter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7Converter.cs,GetAWLBlock,The length of the statement  "                    //Only if there are network descriptions. This generall only happens when the Block is empty and does not contain any code.  " is 123.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7Converter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7Converter.cs,GetAWLBlock,The length of the statement  "                    ((S7FunctionBlock)retBlock).AWLCode = MC7toAWL.GetAWL(MC7Start_or_DBBodyStart' retBlock.CodeSize - 2' (int)MnemoricLanguage' MC7Code' Networks' ParaList' prjBlkFld' (S7FunctionBlock)retBlock' ((S7FunctionBlock)retBlock).Parameter); " is 231.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7toAWL.cs,GetAWL,The length of the statement  "            //bool CombineDBOpenAndCommand = false; // true; // false; //If DB Open and Acess should be One AWL Line (like in Step 7). This should be a Parameter. " is 150.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7toAWL.cs,GetAWL,The length of the statement  "                            if (retVal[retVal.Count - 1].Command == Mnemonic.opAUF[MN] && !((S7FunctionBlockRow)retVal[retVal.Count - 1]).Parameter.Contains("["))// && CombineDBOpenAndCommand) " is 164.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7toAWL.cs,GetAWL,The length of the statement  "                        ((S7FunctionBlockRow)retVal[retVal.Count - 1]).MC7 = Helper.CombineByteArray(DBByte' ((S7FunctionBlockRow)retVal[retVal.Count - 1]).MC7); " is 137.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7toAWL.cs,GetAWL,The length of the statement  "                                retVal.Add(new S7FunctionBlockRow() { Command = Mnemonic.opL[MN]' Parameter = Mnemonic.adT[MN] + Convert.ToString(BD[pos + 1]) }); " is 130.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7toAWL.cs,GetAWL,The length of the statement  "                                retVal.Add(new S7FunctionBlockRow() { Command = Mnemonic.opFR[MN]' Parameter = Mnemonic.adT[MN] + Convert.ToString(BD[pos + 1]) }); " is 131.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7toAWL.cs,GetAWL,The length of the statement  "                                retVal.Add(new S7FunctionBlockRow() { Command = Mnemonic.opL[MN]' Parameter = Mnemonic.adMB[MN] + Convert.ToString(BD[pos + 1]) }); " is 131.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7toAWL.cs,GetAWL,The length of the statement  "                                retVal.Add(new S7FunctionBlockRow() { Command = Mnemonic.opT[MN]' Parameter = Mnemonic.adMB[MN] + Convert.ToString(BD[pos + 1]) }); " is 131.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7toAWL.cs,GetAWL,The length of the statement  "                                retVal.Add(new S7FunctionBlockRow() { Command = Mnemonic.opLC[MN]' Parameter = Mnemonic.adT[MN] + Convert.ToString(BD[pos + 1]) }); " is 131.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7toAWL.cs,GetAWL,The length of the statement  "                                retVal.Add(new S7FunctionBlockRow() { Command = Mnemonic.opL[MN]' Parameter = Mnemonic.adMW[MN] + Convert.ToString(BD[pos + 1]) }); " is 131.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7toAWL.cs,GetAWL,The length of the statement  "                                retVal.Add(new S7FunctionBlockRow() { Command = Mnemonic.opT[MN]' Parameter = Mnemonic.adMW[MN] + Convert.ToString(BD[pos + 1]) }); " is 131.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7toAWL.cs,GetAWL,The length of the statement  "                                retVal.Add(new S7FunctionBlockRow() { Command = Mnemonic.opSA[MN]' Parameter = Mnemonic.adT[MN] + Convert.ToString(BD[pos + 1]) }); " is 131.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7toAWL.cs,GetAWL,The length of the statement  "                                retVal.Add(new S7FunctionBlockRow() { Command = Mnemonic.opL[MN]' Parameter = Mnemonic.adMD[MN] + Convert.ToString(BD[pos + 1]) }); " is 131.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7toAWL.cs,GetAWL,The length of the statement  "                                retVal.Add(new S7FunctionBlockRow() { Command = Mnemonic.opT[MN]' Parameter = Mnemonic.adMD[MN] + Convert.ToString(BD[pos + 1]) }); " is 131.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7toAWL.cs,GetAWL,The length of the statement  "                                retVal.Add(new S7FunctionBlockRow() { Command = Mnemonic.opSV[MN]' Parameter = Mnemonic.adT[MN] + Convert.ToString(BD[pos + 1]) }); " is 131.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7toAWL.cs,GetAWL,The length of the statement  "                                retVal.Add(new S7FunctionBlockRow() { Command = Mnemonic.opCC[MN]' Parameter = Mnemonic.adFC[MN] + Convert.ToString(BD[pos + 1]) }); " is 132.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7toAWL.cs,GetAWL,The length of the statement  "                                ((S7FunctionBlockRow)retVal[retVal.Count - 1]).MC7 = new byte[] { BD[pos]' BD[pos + 1]' BD[pos + 2]' BD[pos + 3]' BD[pos + 4]' BD[pos + 5] }; " is 141.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7toAWL.cs,GetAWL,The length of the statement  "                                retVal.Add(new S7FunctionBlockRow() { Command = Mnemonic.opAUF[MN]' Parameter = Mnemonic.adDB[MN] + Convert.ToString(BD[pos + 1]) }); " is 133.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7toAWL.cs,GetAWL,The length of the statement  "                                retVal.Add(new S7FunctionBlockRow() { Command = Mnemonic.opSE[MN]' Parameter = Mnemonic.adT[MN] + Convert.ToString(BD[pos + 1]) }); " is 131.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7toAWL.cs,GetAWL,The length of the statement  "                                retVal.Add(new S7FunctionBlockRow() { Command = Mnemonic.opSS[MN]' Parameter = Mnemonic.adT[MN] + Convert.ToString(BD[pos + 1]) }); " is 131.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7toAWL.cs,GetAWL,The length of the statement  "                                        par = "W#16#" + libnodave.getU16from(BD' pos + 2).ToString("X"); // Helper.GetWord(BD[pos + 2]' BD[pos + 3]).ToString("X"); " is 123.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7toAWL.cs,GetAWL,The length of the statement  "                                        par = "C#" + libnodave.getU16from(BD' pos + 2).ToString("X"); // Helper.GetWord(BD[pos + 2]' BD[pos + 3]).ToString("X"); " is 120.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7toAWL.cs,GetAWL,The length of the statement  "                                retVal.Add(new S7FunctionBlockRow() { Command = Mnemonic.opSI[MN]' Parameter = Mnemonic.adT[MN] + Convert.ToString(BD[pos + 1]) }); " is 131.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7toAWL.cs,GetAWL,The length of the statement  "                                ((S7FunctionBlockRow)retVal[retVal.Count - 1]).MC7 = new byte[] { BD[pos]' BD[pos + 1]' BD[pos + 2]' BD[pos + 3]' BD[pos + 4]' BD[pos + 5] }; " is 141.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7toAWL.cs,GetAWL,The length of the statement  "                                retVal.Add(new S7FunctionBlockRow() { Command = Mnemonic.opR[MN]' Parameter = Mnemonic.adT[MN] + Convert.ToString(BD[pos + 1]) }); " is 130.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7toAWL.cs,GetAWL,The length of the statement  "                                retVal.Add(new S7FunctionBlockRow() { Command = Mnemonic.opUC[MN]' Parameter = Mnemonic.adFC[MN] + Convert.ToString(BD[pos + 1]) }); " is 132.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7toAWL.cs,GetAWL,The length of the statement  "                                ((S7FunctionBlockRow)retVal[retVal.Count - 1]).MC7 = new byte[] { BD[pos]' BD[pos + 1]' BD[pos + 2]' BD[pos + 3]' BD[pos + 4]' BD[pos + 5] }; " is 141.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7toAWL.cs,GetAWL,The length of the statement  "                                    ((S7FunctionBlockRow)retVal[retVal.Count - 1]).MC7 = Helper.CombineByteArray(((S7FunctionBlockRow)retVal[retVal.Count - 1]).MC7' new byte[] { BD[pos + 6]' BD[pos + 7]' BD[pos + 8]' BD[pos + 9] }); " is 196.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7toAWL.cs,GetAWL,The length of the statement  "                                            if (retVal[retVal.Count - 1].Command == Mnemonic.opAUF[MN] && !((S7FunctionBlockRow)retVal[retVal.Count - 1]).Parameter.Contains("["))// && CombineDBOpenAndCommand) " is 164.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7toAWL.cs,GetAWL,The length of the statement  "                                            retVal.Add(new S7FunctionBlockRow() { Command = Mnemonic.opZUW[MN]' Parameter = par + Mnemonic.adDBX[MN] + Convert.ToString(libnodave.getU16from(BD' pos + 2)) + "." + Convert.ToString(BD[pos + 1] - 0x40) }); " is 207.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7toAWL.cs,GetAWL,The length of the statement  "                                                ((S7FunctionBlockRow)retVal[retVal.Count - 1]).MC7 = Helper.CombineByteArray(DBByte' ((S7FunctionBlockRow)retVal[retVal.Count - 1]).MC7); " is 137.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7toAWL.cs,GetAWL,The length of the statement  "                                            ((S7FunctionBlockRow)retVal[retVal.Count - 1]).MC7 = new byte[] { BD[pos]' BD[pos + 1]' BD[pos + 2]' BD[pos + 3]' BD[pos + 4]' BD[pos + 5] }; " is 141.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7toAWL.cs,GetAWL,The length of the statement  "                                            ((S7FunctionBlockRow)retVal[retVal.Count - 1]).MC7 = new byte[] { BD[pos]' BD[pos + 1]' BD[pos + 2]' BD[pos + 3]' BD[pos + 4]' BD[pos + 5] }; " is 141.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7toAWL.cs,GetAWL,The length of the statement  "                                            ((S7FunctionBlockRow)retVal[retVal.Count - 1]).MC7 = new byte[] { BD[pos]' BD[pos + 1]' BD[pos + 2]' BD[pos + 3]' BD[pos + 4]' BD[pos + 5] }; " is 141.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7toAWL.cs,GetAWL,The length of the statement  "                                            ((S7FunctionBlockRow)retVal[retVal.Count - 1]).MC7 = new byte[] { BD[pos]' BD[pos + 1]' BD[pos + 2]' BD[pos + 3]' BD[pos + 4]' BD[pos + 5] }; " is 141.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7toAWL.cs,GetAWL,The length of the statement  "                                retVal.Add(new S7FunctionBlockRow() { Command = Mnemonic.opZV[MN]' Parameter = Mnemonic.adZ[MN] + Convert.ToString(BD[pos + 1]) }); " is 131.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7toAWL.cs,GetAWL,The length of the statement  "                                retVal.Add(new S7FunctionBlockRow() { Command = Mnemonic.opUC[MN]' Parameter = Mnemonic.adFB[MN] + Convert.ToString(BD[pos + 1]) }); " is 132.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7toAWL.cs,GetAWL,The length of the statement  "                                retVal.Add(new S7FunctionBlockRow() { Command = Mnemonic.opR[MN]' Parameter = Mnemonic.adZ[MN] + Convert.ToString(BD[pos + 1]) }); " is 130.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7toAWL.cs,GetAWL,The length of the statement  "                                    if (retVal[retVal.Count - 1].Command == Mnemonic.opAUF[MN] && par.Substring(0' 2) == "DB")// && CombineDBOpenAndCommand) " is 120.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7toAWL.cs,GetAWL,The length of the statement  "                                        ((S7FunctionBlockRow)retVal[retVal.Count - 1]).MC7 = Helper.CombineByteArray(DBByte' ((S7FunctionBlockRow)retVal[retVal.Count - 1]).MC7); " is 137.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7toAWL.cs,GetAWL,The length of the statement  "                                            retVal.Add(new S7FunctionBlockRow() { Command = Mnemonic.opUC[MN]' Parameter = Mnemonic.adFC[MN] + Convert.ToString(libnodave.getU16from(BD' pos + 2)) }); " is 154.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7toAWL.cs,GetAWL,The length of the statement  "                                            ((S7FunctionBlockRow)retVal[retVal.Count - 1]).MC7 = new byte[] { BD[pos]' BD[pos + 1]' BD[pos + 2]' BD[pos + 3]' BD[pos + 4]' BD[pos + 5]' BD[pos + 6]' BD[pos + 7] }; " is 167.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7toAWL.cs,GetAWL,The length of the statement  "                                                ((S7FunctionBlockRow)retVal[retVal.Count - 1]).MC7 = Helper.CombineByteArray(((S7FunctionBlockRow)retVal[retVal.Count - 1]).MC7' new byte[] { BD[pos + 8]' BD[pos + 9]' BD[pos + 10]' BD[pos + 11] }); " is 198.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7toAWL.cs,GetAWL,The length of the statement  "                                            retVal.Add(new S7FunctionBlockRow() { Command = Mnemonic.opUC[MN]' Parameter = Mnemonic.adFC[MN] + "[" + par + Convert.ToString(libnodave.getU16from(BD' pos + 2)) + "]" }); " is 172.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7toAWL.cs,GetAWL,The length of the statement  "                                            ((S7FunctionBlockRow)retVal[retVal.Count - 1]).MC7 = new byte[] { BD[pos]' BD[pos + 1]' BD[pos + 2]' BD[pos + 3]' BD[pos + 4]' BD[pos + 5]' BD[pos + 6]' BD[pos + 7] }; " is 167.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7toAWL.cs,GetAWL,The length of the statement  "                                                ((S7FunctionBlockRow)retVal[retVal.Count - 1]).MC7 = Helper.CombineByteArray(((S7FunctionBlockRow)retVal[retVal.Count - 1]).MC7' new byte[] { BD[pos + 8]' BD[pos + 9]' BD[pos + 10]' BD[pos + 11] }); " is 198.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7toAWL.cs,GetAWL,The length of the statement  "                                            retVal.Add(new S7FunctionBlockRow() { Command = Mnemonic.opUC[MN]' Parameter = Mnemonic.adFB[MN] + "[" + par + Convert.ToString(libnodave.getU16from(BD' pos + 2)) + "]" }); " is 172.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7toAWL.cs,GetAWL,The length of the statement  "                                            ((S7FunctionBlockRow)retVal[retVal.Count - 1]).MC7 = new byte[] { BD[pos]' BD[pos + 1]' BD[pos + 2]' BD[pos + 3]' BD[pos + 4]' BD[pos + 5]' BD[pos + 6]' BD[pos + 7] }; " is 167.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7toAWL.cs,GetAWL,The length of the statement  "                                            ((S7FunctionBlockRow)retVal[retVal.Count - 1]).MC7 = new byte[] { BD[pos]' BD[pos + 1]' BD[pos + 2]' BD[pos + 3]' BD[pos + 4]' BD[pos + 5]' BD[pos + 6]' BD[pos + 7] }; " is 167.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7toAWL.cs,GetAWL,The length of the statement  "                                            retVal.Add(new S7FunctionBlockRow() { Command = Mnemonic.opUC[MN]' Parameter = Mnemonic.adFB[MN] + Convert.ToString(libnodave.getU16from(BD' pos + 2)) }); " is 154.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7toAWL.cs,GetAWL,The length of the statement  "                                            retVal.Add(new S7FunctionBlockRow() { Command = Mnemonic.opUC[MN]' Parameter = Mnemonic.adSFC[MN] + Convert.ToString(libnodave.getU16from(BD' pos + 2)) }); " is 155.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7toAWL.cs,GetAWL,The length of the statement  "                                            ((S7FunctionBlockRow)retVal[retVal.Count - 1]).MC7 = new byte[] { BD[pos]' BD[pos + 1]' BD[pos + 2]' BD[pos + 3]' BD[pos + 4]' BD[pos + 5]' BD[pos + 6]' BD[pos + 7] }; " is 167.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7toAWL.cs,GetAWL,The length of the statement  "                                                ((S7FunctionBlockRow)retVal[retVal.Count - 1]).MC7 = Helper.CombineByteArray(((S7FunctionBlockRow)retVal[retVal.Count - 1]).MC7' new byte[] { BD[pos + 8]' BD[pos + 9]' BD[pos + 10]' BD[pos + 11] }); " is 198.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7toAWL.cs,GetAWL,The length of the statement  "                                            retVal.Add(new S7FunctionBlockRow() { Command = Mnemonic.opUC[MN]' Parameter = Mnemonic.adSFB[MN] + Convert.ToString(libnodave.getU16from(BD' pos + 2)) }); " is 155.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7toAWL.cs,GetAWL,The length of the statement  "                                            ((S7FunctionBlockRow)retVal[retVal.Count - 1]).MC7 = new byte[] { BD[pos]' BD[pos + 1]' BD[pos + 2]' BD[pos + 3]' BD[pos + 4]' BD[pos + 5]' BD[pos + 6]' BD[pos + 7] }; " is 167.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7toAWL.cs,GetAWL,The length of the statement  "                                            //    ((S7FunctionBlockRow)retVal[retVal.Count - 1]).MC7 = Helper.CombineByteArray(((S7FunctionBlockRow)retVal[retVal.Count - 1]).MC7' new byte[] { BD[pos + 8]' BD[pos + 9]' BD[pos + 10]' BD[pos + 11] }); " is 204.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7toAWL.cs,GetAWL,The length of the statement  "                                            ((S7FunctionBlockRow)retVal[retVal.Count - 1]).MC7 = new byte[] { BD[pos]' BD[pos + 1]' BD[pos + 2]' BD[pos + 3]' BD[pos + 4]' BD[pos + 5] }; " is 141.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7toAWL.cs,GetAWL,The length of the statement  "                                            ((S7FunctionBlockRow)retVal[retVal.Count - 1]).MC7 = new byte[] { BD[pos]' BD[pos + 1]' BD[pos + 2]' BD[pos + 3]' BD[pos + 4]' BD[pos + 5] }; " is 141.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,NetWork,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\NetWork.cs,GetNetworks,The length of the statement  "                    Networks[i] = BitConverter.ToUInt16(BD' Start + (i*2)); // Helper.GetWord(BD[Start + (i * 2) + 1]' BD[Start + (i * 2)]); " is 120.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Parameter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Parameter.cs,IsInterfaceCompatible,The length of the statement  "            if (Childcount1 != Childcount2) return false; //if the blocks have different amounts of children' then they cant be compatible " is 126.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Parameter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Parameter.cs,GetInterfaceOrDBFromStep7ProjectString,The length of the statement  "            //Todo: read the complete DB from mc5 code first' Read the containing UDTs' compare the UDTs with the Structs' if the UDTs and Structs are not Equal' marke the PLCDataRow as TimeStampConflict " is 191.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Parameter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Parameter.cs,GetInterfaceOrDBFromStep7ProjectString,The length of the statement  "                            int parseZustand = 0; //0=ParName' 1=AttributeName' 6=AfterAttributeName' 2=AttributeValue' 3=Type' 4=Value' 7=InnerValue (without ')' 5=Comment " is 144.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Parameter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Parameter.cs,GetInterfaceOrDBFromStep7ProjectString,The length of the statement  "                                else if (parseZustand == 1 && tmpChar != ' ' && tmpChar != ':' && tmpChar != '=' && tmpChar != '}' && tmpChar != '\'' && tmpChar != ';') " is 136.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Parameter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Parameter.cs,GetInterfaceOrDBFromStep7ProjectString,The length of the statement  "                                addRW.DataType = (S7DataRowType)Enum.Parse(typeof(S7DataRowType)' tmpType.Replace("\0"' "").Replace("\t"' "").Replace(";"' "").Trim().ToUpper()); " is 145.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Parameter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Parameter.cs,GetInterface,The length of the statement  "                            GetVarTypeEN(parameterIN' DataType' false' false' VarNameGen.GetNextVarName()' interfaceBytes' ref InterfacePos' startValueBytes' ref StartValuePos' ref ParaList' ref StackNr' VarNameGen' myBlk); " is 195.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Parameter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Parameter.cs,GetInterface,The length of the statement  "                            GetVarTypeEN(parameterOUT' DataType' false' false' VarNameGen.GetNextVarName()' interfaceBytes' ref InterfacePos' startValueBytes' ref StartValuePos' ref ParaList' ref StackNr' VarNameGen' myBlk); " is 196.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Parameter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Parameter.cs,GetInterface,The length of the statement  "                            GetVarTypeEN(parameterINOUT' DataType' false' false' VarNameGen.GetNextVarName()' interfaceBytes' ref InterfacePos' startValueBytes' ref StartValuePos' ref ParaList' ref StackNr' VarNameGen' myBlk); " is 198.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Parameter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Parameter.cs,GetInterface,The length of the statement  "                            GetVarTypeEN(parameterSTAT' DataType' false' false' VarNameGen.GetNextVarName()' interfaceBytes' ref InterfacePos' startValueBytes' ref StartValuePos' ref ParaList' ref StackNr' VarNameGen' myBlk); " is 197.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Parameter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Parameter.cs,GetInterface,The length of the statement  "                            GetVarTypeEN(parameterTEMP' DataType' false' false' VarNameGen.GetNextVarName()' interfaceBytes' ref InterfacePos' startValueBytes' ref StartValuePos' ref ParaList' ref StackNr' VarNameGen' myBlk); " is 197.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Parameter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Parameter.cs,GetInterface,The length of the statement  "                            GetVarTypeEN(parameterRETVAL' DataType' false' false' VarNameGen.GetNextVarName()' interfaceBytes' ref InterfacePos' startValueBytes' ref StartValuePos' ref ParaList' ref StackNr' VarNameGen' myBlk); " is 199.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Parameter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Parameter.cs,GetInterface,The length of the statement  "                                GetVarTypeEN(parameterSTAT' DataType' false' false' VarNameGen.GetNextVarName()' interfaceBytes' ref InterfacePos' startValueBytes' ref StartValuePos' ref ParaList' ref StackNr' VarNameGen' myBlk); " is 197.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Parameter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Parameter.cs,GetInterface,The length of the statement  "                                throw new Exception(string.Format("invalid or unknown interface declarations found while parsing the block interface at pos {0} with Paratype {1} and Datatype {2}"' InterfacePos' interfaceBytes[InterfacePos + 1]' interfaceBytes[InterfacePos])); " is 244.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Parameter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Parameter.cs,GetVarTypeEN,The length of the statement  "                    InterfacePos += 3 + (ArrayDim * 4);  //3 byte array header' and every dimension has an upper and lower bound' each an Uint16 " is 124.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Parameter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Parameter.cs,GetVarTypeEN,The length of the statement  "                    GetVarTypeEN(currPar' (S7DataRowType)interfaceBytes[InterfacePos]' true' true' VarName' interfaceBytes' ref InterfacePos' startValueBytes' ref StartValuePos' ref ParaList' ref StackNr' VarNameGen' myBlk); " is 204.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Parameter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Parameter.cs,GetVarTypeEN,The length of the statement  "                    //Structs are nested datatypes' so go one recursivly. Also UDT get converted to Structs' so they are indistiguishable from them " is 127.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Parameter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Parameter.cs,GetVarTypeEN,The length of the statement  "                    //Structure Interface elements have an fixed length of 3 bytes or fixed length or 5 byte if children count is greater then 255. " is 127.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Parameter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Parameter.cs,GetVarTypeEN,The length of the statement  "                    //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration. NOTE it is never DBInit' which means it never has Initial values " is 137.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Parameter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Parameter.cs,GetVarTypeEN,The length of the statement  "                    //in that case the original childcount on InterfacePos + 2 is set to FF and the next two bytes contain the real Child count " is 123.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Parameter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Parameter.cs,GetVarTypeEN,The length of the statement  "                    //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration. NOTE it is never DBInit' which means it never has Initial values " is 137.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Parameter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Parameter.cs,GetVarTypeEN,The length of the statement  "                    //There is another special case' when the ParameterType is 0x14. In that case the layout is similar to the special case with more than 255 children' " is 148.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Parameter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Parameter.cs,GetVarTypeEN,The length of the statement  "                    //Except that the value InterfacePos + 2 has seemingly random Values. At the moment i do not know what these values mean " is 120.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Parameter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Parameter.cs,GetVarTypeEN,The length of the statement  "                    //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration. NOTE it is never DBInit' which means it never has Initial values " is 137.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Parameter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Parameter.cs,GetVarTypeEN,The length of the statement  "                        InterfacePos += 5; //5 bytes for Structure Element length if more than 255 children' so it points to the next child element " is 123.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Parameter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Parameter.cs,GetVarTypeEN,The length of the statement  "                        GetVarTypeEN(akPar' (S7DataRowType)interfaceBytes[InterfacePos]' true' false' VarNameGen.GetNextVarName()' interfaceBytes' ref InterfacePos' startValueBytes' ref StartValuePos' ref ParaList' ref StackNr' VarNameGen' myBlk); " is 223.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Parameter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Parameter.cs,GetVarTypeEN,The length of the statement  "                    throw new Exception(string.Format("invalid or unknown interface declarations found while parsing the block interface at pos {0} with Paratype {1} and Datatype {2}"' InterfacePos' interfaceBytes[InterfacePos + 1]' interfaceBytes[InterfacePos])); " is 244.
Long Statement,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Parameter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Parameter.cs,GetVarInitialValue,The length of the statement  "                        valpos += ((string)Result).Length + 2 - 2; //+2 because S7 strings have an one byte length filed and one byte used filed' and -2 because this library returns the string single quoted " is 182.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step5Project,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step5Project.cs,LoadProject,The length of the statement  "                /* The len for a Section is not always calculated right' so if the Section does not begin with the filename add 0x80 until it works */ " is 134.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step5Project,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step5Project.cs,LoadProject,The length of the statement  "                //int section_size = ((s5ProjectByteArray[section_start + 21] * 0x100) + s5ProjectByteArray[section_start + 20]) * 0x80; " is 120.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step5Project,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step5Project.cs,LoadProject,The length of the statement  "                            //if (((IList<int>)Enum.GetValues(typeof(PLCBlockType))).Contains((s5ProjectByteArray[n + 2] | 0xf00))) //only for debbuging " is 124.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step5Project,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step5Project.cs,LoadProject,The length of the statement  "            if (_projectfilename.ToLower().Contains("st.s5d") && _ziphelper.FileExists(_projectfilename.ToLower().Replace("st.s5d"' "z0.seq"))) " is 131.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step5Project,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step5Project.cs,AddBlockInfo,The length of the statement  "                var bits = s5ProjectByteArray[pos + 4]; //siehe: https://www.yumpu.com/de/document/view/5702154/3-s5-power-bios-process-informatik-entwicklungsgesellschaft-mbh/26 " is 162.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step5Project,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step5Project.cs,AddBlockInfo,The length of the statement  "                var bibNumber = s5ProjectByteArray[pos + 5] * 0x10000 + s5ProjectByteArray[pos + 6] * 0x100 + s5ProjectByteArray[pos + 7]; " is 122.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProjectHeader,The length of the statement  "            ProjectDescription = System.Text.Encoding.UTF7.GetString(projectFile' 5 + projectFile[4] + 2' projectFile[projectFile[4] + 6]); " is 127.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The length of the statement  "                var dbfTbl = DBF.ParseDBF.ReadDBF(ProjectFolder + "hOmSave7" + _DirSeperator + "s7hstatx" + _DirSeperator + "HOBJECT1.DBF"' _ziphelper' _DirSeperator); " is 151.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The length of the statement  "                        if ((int)row["OBJTYP"] == objectType_Simatic300 || (int)row["OBJTYP"] == objectType_Simatic400 || (int)row["OBJTYP"] == objectType_Simatic400H) " is 143.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The length of the statement  "                var dbfTbl = DBF.ParseDBF.ReadDBF(ProjectFolder + "hOmSave7" + _DirSeperator + "s7hstatx" + _DirSeperator + "HRELATI1.DBF"' _ziphelper' _DirSeperator); " is 151.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The length of the statement  "            if (ZipHelper.FileExists(_zipfile'ProjectFolder + "hOmSave7" + _DirSeperator + "s7hstatx" + _DirSeperator + "HRELATI1.DBF")) " is 124.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The length of the statement  "                var dbfTbl = DBF.ParseDBF.ReadDBF(ProjectFolder + "hOmSave7" + _DirSeperator + "s7hstatx" + _DirSeperator + "HRELATI1.DBF"' _zipfile' _DirSeperator); " is 149.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The length of the statement  "                var dbfTbl = DBF.ParseDBF.ReadDBF(ProjectFolder + "hOmSave7" + _DirSeperator + "s7wb53ax" + _DirSeperator + "HOBJECT1.DBF"' _ziphelper' _DirSeperator); " is 151.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The length of the statement  "                var dbfTbl = DBF.ParseDBF.ReadDBF(ProjectFolder + "hOmSave7" + _DirSeperator + "s7wb53ax" + _DirSeperator + "HRELATI1.DBF"' _ziphelper' _DirSeperator); " is 151.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The length of the statement  "                            var cpu = (StationConfigurationFolder)ProjectStructure.SubItems.FirstOrDefault(x => x.ID == Convert.ToInt32(row["TUNITID"])); " is 125.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The length of the statement  "                var dbfTbl = DBF.ParseDBF.ReadDBF(ProjectFolder + "hOmSave7" + _DirSeperator + "s7hk31ax" + _DirSeperator + "HRELATI1.DBF"' _ziphelper' _DirSeperator); " is 151.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The length of the statement  "                var dbfTbl = DBF.ParseDBF.ReadDBF(ProjectFolder + "hOmSave7" + _DirSeperator + "s7hkcomx" + _DirSeperator + "HRELATI1.DBF"' _ziphelper' _DirSeperator); " is 151.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The length of the statement  "                var dbfTbl = DBF.ParseDBF.ReadDBF(ProjectFolder + "hOmSave7" + _DirSeperator + "s7hk41ax" + _DirSeperator + "HRELATI1.DBF"' _ziphelper' _DirSeperator); " is 151.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The length of the statement  "                                if ((int)row["TUNITID"] == z.ID && ((int)row["TOBJTYP"] == 1314972 || (int)row["TOBJTYP"] == 1315656 /* BackupCPU bei H Sys */)) " is 128.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The length of the statement  "                var dbfTbl = DBF.ParseDBF.ReadDBF(ProjectFolder + "hOmSave7" + _DirSeperator + "s7hkcomx" + _DirSeperator + "HOBJECT1.DBF"' _ziphelper' _DirSeperator); " is 151.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The length of the statement  "                var dbfTbl = DBF.ParseDBF.ReadDBF(ProjectFolder + "hOmSave7" + _DirSeperator + "s7hk31ax" + _DirSeperator + "HOBJECT1.DBF"' _ziphelper' _DirSeperator); " is 151.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The length of the statement  "                var dbfTbl = DBF.ParseDBF.ReadDBF(ProjectFolder + "hOmSave7" + _DirSeperator + "s7hk31ax" + _DirSeperator + "HATTRME1.DBF"' _ziphelper' _DirSeperator); " is 151.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The length of the statement  "                var dbfTbl = DBF.ParseDBF.ReadDBF(ProjectFolder + "hOmSave7" + _DirSeperator + "s7hk41ax" + _DirSeperator + "HOBJECT1.DBF"' _ziphelper' _DirSeperator); " is 151.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The length of the statement  "                var dbfTbl = DBF.ParseDBF.ReadDBF(ProjectFolder + "hOmSave7" + _DirSeperator + "s7hk41ax" + _DirSeperator + "HATTRME1.DBF"' _ziphelper' _DirSeperator); " is 151.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The length of the statement  "                var dbfTbl = DBF.ParseDBF.ReadDBF(ProjectFolder + "hOmSave7" + _DirSeperator + "s7hk31ax" + _DirSeperator + "HRELATI1.DBF"' _ziphelper' _DirSeperator); " is 151.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The length of the statement  "                var dbfTbl = DBF.ParseDBF.ReadDBF(ProjectFolder + "hOmSave7" + _DirSeperator + "s7hkcomx" + _DirSeperator + "HRELATI1.DBF"' _ziphelper' _DirSeperator); " is 151.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The length of the statement  "                var dbfTbl = DBF.ParseDBF.ReadDBF(ProjectFolder + "hOmSave7" + _DirSeperator + "s7hk41ax" + _DirSeperator + "HRELATI1.DBF"' _ziphelper' _DirSeperator); " is 151.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The length of the statement  "                var dbfTbl = DBF.ParseDBF.ReadDBF(ProjectFolder + "ombstx" + _DirSeperator + "offline" + _DirSeperator + "BSTCNTOF.DBF"' _ziphelper' _DirSeperator); " is 148.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The length of the statement  "                        x.Folder = ProjectFolder + "ombstx" + _DirSeperator + "offline" + _DirSeperator + x.ID.ToString("X").PadLeft(8' '0') + _DirSeperator; " is 133.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The length of the statement  "                var dbfTbl = DBF.ParseDBF.ReadDBF(ProjectFolder + "s7asrcom" + _DirSeperator + "S7CNTREF.DBF"' _ziphelper' _DirSeperator); " is 122.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The length of the statement  "                var dbfTbl = DBF.ParseDBF.ReadDBF(ProjectFolder + "hOmSave7" + _DirSeperator + "S7HDPSSX" + _DirSeperator + "HOBJECT1.DBF"' _ziphelper' _DirSeperator); " is 151.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The length of the statement  "                            var x = new ProfibusMasterSystem() { Project = this' Name = row["NAME"].ToString().Replace("\0"' "")' Id = (int)row["ID"] }; " is 124.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The length of the statement  "                var dbfTbl = DBF.ParseDBF.ReadDBF(ProjectFolder + "hOmSave7" + _DirSeperator + "S7HDPSSX" + _DirSeperator + "HRELATI1.DBF"' _ziphelper' _DirSeperator); " is 151.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The length of the statement  "                        lnkLst.Add(new LinkHelp() { SOBJID = (int)row["SOBJID"]' SOBJTYP = (int)row["SOBJTYP"]' RELID = (int)row["RELID"]' TOBJID = (int)row["TOBJID"]' TOBJTYP = (int)row["TOBJTYP"]' TUNITID = (int)row["TUNITID"]' TUNITTYP = (int)row["TUNITTYP"] }); " is 241.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The length of the statement  "                var dbfTbl = DBF.ParseDBF.ReadDBF(ProjectFolder + "hOmSave7" + _DirSeperator + "s7hslntx" + _DirSeperator + "HOBJECT1.DBF"' _ziphelper' _DirSeperator); " is 151.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The length of the statement  "                            var node = new ProfibusNode() { Name = row["NAME"].ToString().Replace("\0"' "")' NodeId = (int)row["SUBSTATN"]' GsdFile = row["CEXTTYPE"].ToString() }; " is 151.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The length of the statement  "                var dbfTbl = DBF.ParseDBF.ReadDBF(ProjectFolder + "hOmSave7" + _DirSeperator + "s7hssiox" + _DirSeperator + "HOBJECT1.DBF"' _ziphelper' _DirSeperator); " is 151.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The length of the statement  "                            var x = new ProfinetMasterSystem() { Project = this' Name = row["NAME"].ToString().Replace("\0"' "")' Id = (int)row["ID"] }; " is 124.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The length of the statement  "                var dbfTbl = DBF.ParseDBF.ReadDBF(ProjectFolder + "hOmSave7" + _DirSeperator + "s7hssiox" + _DirSeperator + "HRELATI1.DBF"' _ziphelper' _DirSeperator); " is 151.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The length of the statement  "                        lnkLst.Add(new LinkHelp() { SOBJID = (int)row["SOBJID"]' SOBJTYP = (int)row["SOBJTYP"]' RELID = (int)row["RELID"]' TOBJID = (int)row["TOBJID"]' TOBJTYP = (int)row["TOBJTYP"]' TUNITID = (int)row["TUNITID"]' TUNITTYP = (int)row["TUNITTYP"] }); " is 241.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The length of the statement  "                    var dbfTbl2 = DBF.ParseDBF.ReadDBF(ProjectFolder + "hOmSave7" + _DirSeperator + "s7hdevnx" + _DirSeperator + "HATTRME1.DBF"' _ziphelper' _DirSeperator); " is 152.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The length of the statement  "                            attLst.Add(new AttrMeHelp() { IDM = (int)row["IDM"]' ATTRIIDM = (int)row["ATTRIIDM"]' ATTFORMATM = (int)row["ATTFORMATM"]' MEMOARRAYM = (byte[])row["MEMOARRAYM"] }); " is 165.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The length of the statement  "                var dbfTbl = DBF.ParseDBF.ReadDBF(ProjectFolder + "hOmSave7" + _DirSeperator + "s7hdevnx" + _DirSeperator + "HOBJECT1.DBF"' _ziphelper' _DirSeperator); " is 151.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The length of the statement  "                            var node = new ProfibusNode() { Name = row["NAME"].ToString().Replace("\0"' "")' NodeId = (int)row["SUBSTATN"]' GsdFile = row["CEXTTYPE"].ToString() }; " is 151.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The length of the statement  "                //FileStream hrsLink = new FileStream(ProjectFolder + "hrs" + _DirSeperator + "linkhrs.lnk"' FileMode.Open' FileAccess.Read' System.IO.FileShare.ReadWrite); " is 156.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The length of the statement  "                byte[] completeBuffer = rd.ReadBytes((int)_ziphelper.GetStreamLength(ProjectFolder + "hrs" + _DirSeperator + "linkhrs.lnk"' hrsLink)); " is 134.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The length of the statement  "                    int pos1 = ASCIIEncoding.ASCII.GetString(tmpLink).IndexOf(ASCIIEncoding.ASCII.GetString(new byte[] { 0x01' 0x60' 0x11 })); " is 122.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The length of the statement  "                    int pos2 = ASCIIEncoding.ASCII.GetString(tmpLink).IndexOf(ASCIIEncoding.ASCII.GetString(new byte[] { 0x04' 0x20' 0x11 })); " is 122.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The length of the statement  "                var dbfTbl = DBF.ParseDBF.ReadDBF(ProjectFolder + "hOmSave7" + _DirSeperator + "s7hkdmax" + _DirSeperator + "HOBJECT1.DBF"' _ziphelper' _DirSeperator); " is 151.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The length of the statement  "                var dbfTbl = DBF.ParseDBF.ReadDBF(ProjectFolder + "hOmSave7" + _DirSeperator + "s7hkdmax" + _DirSeperator + "HRELATI1.DBF"' _ziphelper' _DirSeperator); " is 151.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The length of the statement  "                    byte[] searchName = { (byte)'B'' (byte)'a'' (byte)'u'' (byte)'g'' (byte)'r'' (byte)'u'' (byte)'p'' (byte)'p'' (byte)'e'' (byte)'n'' (byte)'n'' (byte)'a'' (byte)'m'' (byte)'e' }; " is 177.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,_GetSymTabForProject,The length of the statement  "            if (string.IsNullOrEmpty(retVal.Name) && !File.Exists(ProjectFolder + "YDBs" + _DirSeperator + tmpId2.ToString() + _DirSeperator + "SYMLIST.DBF")) " is 146.
Long Statement,DotNetSiemensPLCToolBoxLibrary.Projectfiles.TIA,TiaCompression,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\TIA\TiaCompression.cs,DecompressStream,The length of the statement  "            //    return new ZLibNet.ZLibStream(compressedStream' ZLibNet.CompressionMode.Decompress' CompressionLevel.BestCompression' true); " is 130.
Complex Conditional,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,force200,The conditional expression  "(area == daveConst.daveTimer) || (area == daveConst.daveCounter) || (area == daveConst.daveTimer200) || (area == daveConst.daveCounter200)"  is complex.
Complex Conditional,DotNetSiemensPLCToolBoxLibrary.Communication.Library.Pdus,Pdu,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\Pdus\Pdu.cs,addToReadRequest,The conditional expression  "(area == daveConst.daveTimer) || (area == daveConst.daveCounter) || (area == daveConst.daveTimer200) || (area == daveConst.daveCounter200)"  is complex.
Complex Conditional,DotNetSiemensPLCToolBoxLibrary.Communication.Library.Pdus,Pdu,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\Pdus\Pdu.cs,addToWriteRequest,The conditional expression  "(area == daveConst.daveTimer) || (area == daveConst.daveCounter) || (area == daveConst.daveTimer200) || (area == daveConst.daveCounter200)"  is complex.
Complex Conditional,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,Connect,The conditional expression  "(_configuration.ConnectionType != LibNodaveConnectionTypes.Use_Step7_DLL && _configuration.ConnectionType != LibNodaveConnectionTypes.Use_Step7_DLL_Without_TCP && _fds.rfd.ToInt32() == 0) || _fds.rfd.ToInt32() < 0"  is complex.
Complex Conditional,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,Connect,The conditional expression  "_configuration.NetLinkReset && !_netlinkReseted && (_configuration.ConnectionType == LibNodaveConnectionTypes.Netlink_lite || _configuration.ConnectionType == LibNodaveConnectionTypes.Netlink_lite_PPI)"  is complex.
Complex Conditional,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PLCListBlocks,The conditional expression  "ret < 0 && ret != -53763 && ret != -53774 && ret != -255"  is complex.
Complex Conditional,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PLCListBlocks2,The conditional expression  "ret < 0 && ret != -53763 && ret != -53774 && ret != -255"  is complex.
Complex Conditional,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,_TestNewReadValues,The conditional expression  "oldDataSource == plcTag.TagDataSource &&                                      (oldDataSource != MemoryArea.Datablock || oldDB == plcTag.DataBlockNumber) &&                                      plcTag.ByteAddress <= oldByteAddress + oldLen + 4"  is complex.
Complex Conditional,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,_TestNewReadValues,The conditional expression  "restBytes < HeaderTagSize || symbolicTag || (curReadPDU.gesReadSize > 0 && libNoDaveValue.DontSplitValue && curReadPDU.gesReadSize + readSizeWithHeader > maxReadSize)"  is complex.
Complex Conditional,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,ReadValues,The conditional expression  "oldDataSource == plcTag.TagDataSource &&                                      (oldDataSource != MemoryArea.Datablock || oldDB == plcTag.DataBlockNumber) &&                                      plcTag.ByteAddress <= oldByteAddress + (oldLen % 2 != 0 ? oldLen +1 : oldLen) + 4"  is complex.
Complex Conditional,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,ReadValues,The conditional expression  "nckT == null && !symbolicTag && gesAskSize + currentAskSize <= maxReadSize && (!libNoDaveValue.DontSplitValue || readSize > maxReadSize)"  is complex.
Complex Conditional,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,ReadValuesFetchWrite,The conditional expression  "oldDataSource == plcTag.TagDataSource &&                                      (oldDataSource != MemoryArea.Datablock || oldDB == plcTag.DataBlockNumber) &&                                      plcTag.ByteAddress <= oldByteAddress + oldLen + 14"  is complex.
Complex Conditional,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,WriteValues,The conditional expression  "plcTag.TagDataType != TagDataType.Bool && oldDataSource == plcTag.TagDataSource &&                                      (oldDataSource != MemoryArea.Datablock || oldDB == plcTag.DataBlockNumber) &&                                      plcTag.ByteAddress <= oldByteAddress + oldLen"  is complex.
Complex Conditional,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,WriteValues,The conditional expression  "!(currVal is PLCNckTag) && gesWriteSize < maxWriteSize && //Maximale Byte Anzahl noch nicht erreicht                              /*anzWriteVar < maxWriteVar &&*/                              ( //maximale Variablenanzahl noch nicht erreicht                                                          splitPos != 0 || //Value ist schon gesplitted                                  !currVal.DontSplitValue || //Value Kann gesplitted Werden                                  currValSize + tagHeaderSize > maxWriteSize || //Value ist größer als ein request                                  gesWriteSize + currValSize + tagHeaderSize < maxWriteSize)"  is complex.
Complex Conditional,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,WriteValues,The conditional expression  "nckT != null && nckT.TagDataType != TagDataType.String && nckT.TagDataType != TagDataType.CharArray && nckT.NckArea != NCK_Area.AreaFeedDrive && nckT.NckArea != NCK_Area.AreaMainDrive"  is complex.
Complex Conditional,DotNetSiemensPLCToolBoxLibrary.Communication,NC_Var,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCNckTag.cs,GetNckTag,The conditional expression  "this.syntaxId == 0 && this.bereich_u_einheit == 0 && this.spalte == 0 && this.zeile == 0 && this.bausteintyp == 0 && this.zeilenanzahl == 0 && this.typ == 0 && this.laenge == 0"  is complex.
Complex Conditional,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTag.cs,_putControlValueIntoBuffer,The conditional expression  "this.ArraySize == 1 || this.TagDataType == TagDataType.String || this.TagDataType == TagDataType.CharArray || this.TagDataType == TagDataType.ByteArray || this.TagDataType == TagDataType.BCDArray"  is complex.
Complex Conditional,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTag.cs,_readValueFromBuffer,The conditional expression  "this is PLCNckTag && this.TagDataType != DataTypes.TagDataType.String && this.TagDataType != DataTypes.TagDataType.CharArray && this.TagDataType != DataTypes.TagDataType.DateTime"  is complex.
Complex Conditional,DotNetSiemensPLCToolBoxLibrary.DataTypes.Blocks,DataBlockRow,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Blocks\DataBlockRow.cs,GetChildrowsAsList,The conditional expression  "akRow != null && akRow.Children != null && (akRow.DataType == S7DataRowType.STRUCT || akRow.DataType == S7DataRowType.UDT || akRow.DataType == S7DataRowType.FB)"  is complex.
Complex Conditional,DotNetSiemensPLCToolBoxLibrary.DataTypes.Blocks.Step7V11,TIADataRow,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Blocks\Step7V11\TIADataRow.cs,FillBlockAddresses,The conditional expression  "akAddr.BitAddress != 0 && plcDataRow._datatype == S7DataRowType.BOOL && plcDataRow.WasArray && !plcDataRow.WasFirstInArray && plcDataRow.WasNextHigherIndex"  is complex.
Complex Conditional,DotNetSiemensPLCToolBoxLibrary.DataTypes.Blocks.Step7V11,TIADataRow,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Blocks\Step7V11\TIADataRow.cs,FillBlockAddresses,The conditional expression  "akAddr.BitAddress != 0 && (plcDataRow._datatype != S7DataRowType.BOOL || plcDataRow.IsArray || plcDataRow.WasFirstInArray || (lastRowWasArrayOrStruct && !plcDataRow.WasArray && !plcDataRow.WasFirstInArray))"  is complex.
Complex Conditional,DotNetSiemensPLCToolBoxLibrary.DataTypes.Blocks.Step7V11,TIADataRow,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Blocks\Step7V11\TIADataRow.cs,FillBlockAddresses,The conditional expression  "akAddr.ByteAddress % 2 != 0 && ((plcDataRow._datatype != S7DataRowType.BOOL && plcDataRow._datatype != S7DataRowType.BYTE && plcDataRow._datatype != S7DataRowType.CHAR) || plcDataRow.IsArray || plcDataRow.WasFirstInArray || (lastRowWasArrayOrStruct && !plcDataRow.WasArray && !plcDataRow.WasFirstInArray))"  is complex.
Complex Conditional,DotNetSiemensPLCToolBoxLibrary.DataTypes.Blocks.Step7V5,S7DataRow,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Blocks\Step7V5\S7DataRow.cs,FillBlockAddresses,The conditional expression  "akAddr.BitAddress != 0 && plcDataRow._datatype == S7DataRowType.BOOL && plcDataRow.WasArray && !plcDataRow.WasFirstInArray && plcDataRow.WasNextHigherIndex"  is complex.
Complex Conditional,DotNetSiemensPLCToolBoxLibrary.DataTypes.Blocks.Step7V5,S7DataRow,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Blocks\Step7V5\S7DataRow.cs,FillBlockAddresses,The conditional expression  "akAddr.BitAddress != 0 && (plcDataRow._datatype != S7DataRowType.BOOL || plcDataRow.IsArray || plcDataRow.WasFirstInArray || (lastRowWasArrayOrStruct && !plcDataRow.WasArray && !plcDataRow.WasFirstInArray))"  is complex.
Complex Conditional,DotNetSiemensPLCToolBoxLibrary.DataTypes.Blocks.Step7V5,S7DataRow,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Blocks\Step7V5\S7DataRow.cs,FillBlockAddresses,The conditional expression  "akAddr.ByteAddress % 2 != 0 && ((plcDataRow._datatype != S7DataRowType.BOOL && plcDataRow._datatype != S7DataRowType.BYTE && plcDataRow._datatype != S7DataRowType.CHAR) || plcDataRow.IsArray || plcDataRow.WasFirstInArray || (lastRowWasArrayOrStruct && !plcDataRow.WasArray && !plcDataRow.WasFirstInArray))"  is complex.
Complex Conditional,DotNetSiemensPLCToolBoxLibrary.DataTypes.Blocks.Step7V5,S7FunctionBlockRow,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Blocks\Step7V5\S7FunctionBlockRow.cs,_GetCommandStatusAskValues,The conditional expression  "this.Command == Mnemonic.opCALL[MN] || this.Command == Mnemonic.opCC[MN] ||                  this.Command == Mnemonic.opENT[MN] || this.Command == Mnemonic.opEXP[MN] ||                  this.Command == Mnemonic.opFR[MN] ||                  this.Command == Mnemonic.opINC[MN] || this.Command == Mnemonic.opINVD[MN] ||                  this.Command == Mnemonic.opINVI[MN] || this.Command == Mnemonic.opITB[MN] ||                  this.Command == Mnemonic.opITD[MN] ||                    this.Command == Mnemonic.opLC[MN] || this.Command == Mnemonic.opLEAVE[MN] ||                  this.Command == Mnemonic.opLN[MN] || this.Command == Mnemonic.opLOOP[MN] ||                  this.Command == Mnemonic.opMCRA[MN] || this.Command == Mnemonic.opMCRC[MN] ||                  this.Command == Mnemonic.opMCRD[MN] || this.Command == Mnemonic.opMCRO[MN] ||                  this.Command == Mnemonic.opNEGD[MN] ||                  this.Command == Mnemonic.opNEGI[MN] || this.Command == Mnemonic.opNEGR[MN] ||                  this.Command == Mnemonic.opNOT[MN] ||                  this.Command == Mnemonic.opOD[MN] ||                  this.Command == Mnemonic.opONO[MN] || this.Command == Mnemonic.opOO[MN] ||                  this.Command == Mnemonic.opOW[MN] || this.Command == Mnemonic.opPAR1[MN] ||                  this.Command == Mnemonic.opPAR2[MN] ||                  this.Command == Mnemonic.opPOP[MN] || this.Command == Mnemonic.opPUSH[MN] ||                  this.Command == Mnemonic.opRLD[MN] ||                  this.Command == Mnemonic.opRLDA[MN] || this.Command == Mnemonic.opRND[MN] ||                  this.Command == Mnemonic.opRNDM[MN] || this.Command == Mnemonic.opRNDP[MN] ||                  this.Command == Mnemonic.opRRD[MN] || this.Command == Mnemonic.opRRDA[MN] ||                  this.Command == Mnemonic.opSA[MN] ||                  this.Command == Mnemonic.opSAVE[MN] || this.Command == Mnemonic.opSE[MN] ||                  this.Command == Mnemonic.opSI[MN] ||                  this.Command == Mnemonic.opSS[MN] || this.Command == Mnemonic.opSSD[MN] ||                  this.Command == Mnemonic.opSSI[MN] || this.Command == Mnemonic.opSV[MN] ||                  this.Command == Mnemonic.opTRUNC[MN] ||                  this.Command == Mnemonic.opUO[MN] || this.Command == Mnemonic.opUC[MN] ||                  this.Command == Mnemonic.opUNO[MN] || this.Command == Mnemonic.opUD[MN] ||                  this.Command == Mnemonic.opUW[MN] ||                  this.Command == Mnemonic.opXNO[MN] || this.Command == Mnemonic.opXO[MN] ||                  this.Command == Mnemonic.opXOD[MN] || this.Command == Mnemonic.opXOW[MN] ||                  this.Command == Mnemonic.opZR[MN] || this.Command == Mnemonic.opZV[MN]"  is complex.
Complex Conditional,DotNetSiemensPLCToolBoxLibrary.DataTypes.Blocks.Step7V5,S7FunctionBlockRow,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Blocks\Step7V5\S7FunctionBlockRow.cs,_GetCommandStatusAskValues,The conditional expression  "this.Command == "+I" || this.Command == "-I" || this.Command == "*I" || this.Command == "/I" || this.Command == "+D" || this.Command == "-D" || this.Command == "*D" || this.Command == "/D" || this.Command == "+R" || this.Command == "-R" || this.Command == "*R" || this.Command == "/R" || this.Command == "MOD""  is complex.
Complex Conditional,DotNetSiemensPLCToolBoxLibrary.DataTypes.Blocks.Step7V5,S7FunctionBlockRow,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Blocks\Step7V5\S7FunctionBlockRow.cs,_GetCommandStatusAskValues,The conditional expression  "this.Command == Mnemonic.opPLU[MN] || this.Command == Mnemonic.opABS[MN] || this.Command == Mnemonic.opBTD[MN] ||                  this.Command == Mnemonic.opACOS[MN] || this.Command == Mnemonic.opASIN[MN] || this.Command == Mnemonic.opBTI[MN] ||                  this.Command == Mnemonic.opATAN[MN] || this.Command == Mnemonic.opTAN[MN] || this.Command == Mnemonic.opSIN[MN] ||                  this.Command == Mnemonic.opCOS[MN] || this.Command == Mnemonic.opSQR[MN] || this.Command == Mnemonic.opSQRT[MN] ||                  this.Command == Mnemonic.opDEC[MN] || this.Command == Mnemonic.opTAW[MN] || this.Command == Mnemonic.opTAD[MN] ||                  this.Command == Mnemonic.opDTB[MN] || this.Command == Mnemonic.opDTR[MN] || this.Command == Mnemonic.opSLD[MN] ||                  this.Command == Mnemonic.opSLW[MN] || this.Command == Mnemonic.opSRD[MN] || this.Command == Mnemonic.opSRW[MN]"  is complex.
Complex Conditional,DotNetSiemensPLCToolBoxLibrary.DataTypes.Blocks.Step7V5,S7FunctionBlockRow,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Blocks\Step7V5\S7FunctionBlockRow.cs,_GetCommandStatusAskValues,The conditional expression  "this.Command == Mnemonic.opTAK[MN] || this.Command == Mnemonic.opL[MN] || this.Command == Mnemonic.opTAR1[MN] || this.Command == Mnemonic.opTAR2[MN]"  is complex.
Complex Conditional,DotNetSiemensPLCToolBoxLibrary.DataTypes.Blocks.Step7V5,S7FunctionBlockRow,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Blocks\Step7V5\S7FunctionBlockRow.cs,_GetCommandStatusAskValues,The conditional expression  "(this.Command == Mnemonic.opU[MN] || this.Command == Mnemonic.opUN[MN] || this.Command == Mnemonic.opO[MN] || this.Command == Mnemonic.opON[MN] || this.Command == Mnemonic.opX[MN] || this.Command == Mnemonic.opXN[MN] || this.Command == Mnemonic.opFN[MN] || this.Command == Mnemonic.opFP[MN] || this.Command == Mnemonic.opZUW[MN] || this.Command == Mnemonic.opS[MN] || this.Command == Mnemonic.opR[MN] || this.Command == Mnemonic.opT[MN]) && isDBcall"  is complex.
Complex Conditional,DotNetSiemensPLCToolBoxLibrary.DataTypes.Blocks.Step7V5,S7FunctionBlockRow,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Blocks\Step7V5\S7FunctionBlockRow.cs,_GetCommandStatusAskValues,The conditional expression  "this.Command == Mnemonic.opU[MN] || this.Command == Mnemonic.opUN[MN] || this.Command == Mnemonic.opO[MN] ||                      this.Command == Mnemonic.opON[MN] || this.Command == Mnemonic.opX[MN] || this.Command == Mnemonic.opXN[MN] ||                      this.Command == Mnemonic.opFN[MN] || this.Command == Mnemonic.opFP[MN] || this.Command == Mnemonic.opZUW[MN] ||                      this.Command == Mnemonic.opS[MN] || this.Command == Mnemonic.opR[MN] || this.Command == Mnemonic.opBE[MN] ||                      this.Command == Mnemonic.opBEA[MN] || this.Command == Mnemonic.opBEB[MN] || this.Command == ")""  is complex.
Complex Conditional,DotNetSiemensPLCToolBoxLibrary.DataTypes.Blocks.Step7V5,S7FunctionBlockRow,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Blocks\Step7V5\S7FunctionBlockRow.cs,_GetCommandStatusAskValues,The conditional expression  "this.Command == Mnemonic.opT[MN] || this.Command == Mnemonic.opBLD[MN] || this.Command == Mnemonic.opNOP[MN] ||                       this.Command == Mnemonic.opSPA[MN]"  is complex.
Complex Conditional,DotNetSiemensPLCToolBoxLibrary.DataTypes.Blocks.Step7V5,S7FunctionBlockRow,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Blocks\Step7V5\S7FunctionBlockRow.cs,_GetCommandStatusAskValues,The conditional expression  "this.Command == Mnemonic.opSPB[MN] || this.Command == Mnemonic.opSPBB[MN] ||                       this.Command == Mnemonic.opSPBI[MN] || this.Command == Mnemonic.opSPBIN[MN] ||                       this.Command == Mnemonic.opSPBN[MN] || this.Command == Mnemonic.opSPBNB[MN] ||                       this.Command == Mnemonic.opSPL[MN] || this.Command == Mnemonic.opSPM[MN] ||                       this.Command == Mnemonic.opSPMZ[MN] || this.Command == Mnemonic.opSPN[MN] ||                       this.Command == Mnemonic.opSPO[MN] || this.Command == Mnemonic.opSPP[MN] ||                       this.Command == Mnemonic.opSPPZ[MN] || this.Command == Mnemonic.opSPS[MN] ||                       this.Command == Mnemonic.opSPU[MN] || this.Command == Mnemonic.opSPZ[MN] ||                       this.Command == Mnemonic.opSET[MN] || this.Command == Mnemonic.opCLR[MN]"  is complex.
Complex Conditional,DotNetSiemensPLCToolBoxLibrary.DataTypes.Blocks.Step7V5,S7FunctionBlockRow,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Blocks\Step7V5\S7FunctionBlockRow.cs,ToString,The conditional expression  "ExtParameter != null && ExtParameter.Count > 0 && (Command == Mnemonic.opUC[(int)MnemonicLanguage] || Command == Mnemonic.opCC[(int)MnemonicLanguage])"  is complex.
Complex Conditional,DotNetSiemensPLCToolBoxLibrary.DataTypes.Blocks.Step7V5,S7FunctionBlockRow,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Blocks\Step7V5\S7FunctionBlockRow.cs,ToString,The conditional expression  "useDataBlocksSymbolic && Parameter.StartsWith("DB") && Parameter[2] != '[' && Parameter[2] != 'D' && Parameter[2] != 'W' && Parameter[2] != 'B' && Parameter[2] != 'X' && this.Parent != null"  is complex.
Complex Conditional,DotNetSiemensPLCToolBoxLibrary.DataTypes.Projectfolders.Step5,ReferenceData,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Projectfolders\Step5\ReferenceData.cs,LoadReferenceData,The conditional expression  "projectBlockInfo.BlockType == PLCBlockType.S5_PB || projectBlockInfo.BlockType == PLCBlockType.S5_FB || projectBlockInfo.BlockType == PLCBlockType.S5_FX || projectBlockInfo.BlockType == PLCBlockType.S5_OB || projectBlockInfo.BlockType == PLCBlockType.S5_SB"  is complex.
Complex Conditional,DotNetSiemensPLCToolBoxLibrary.DataTypes.Projectfolders.Step5,ReferenceData,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Projectfolders\Step5\ReferenceData.cs,LoadReferenceData,The conditional expression  "functionBlockRow.Parameter.StartsWith("D ") || functionBlockRow.Parameter.StartsWith("DW") || functionBlockRow.Parameter.StartsWith("DL") || functionBlockRow.Parameter.StartsWith("DR") || functionBlockRow.Parameter.StartsWith("DX")"  is complex.
Complex Conditional,DotNetSiemensPLCToolBoxLibrary.DataTypes.Projectfolders.Step7V5,BlocksOfflineFolder,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Projectfolders\Step7V5\BlocksOfflineFolder.cs,intReadPlcBlocksList,The conditional expression  "tmp.BlockType == PLCBlockType.SFB || tmp.BlockType == PLCBlockType.SFC || tmp.BlockType == PLCBlockType.SDB || tmp.BlockType == PLCBlockType.DB || tmp.BlockType == PLCBlockType.VAT || tmp.BlockType == PLCBlockType.FB || tmp.BlockType == PLCBlockType.FC || tmp.BlockType == PLCBlockType.OB || tmp.BlockType == PLCBlockType.UDT"  is complex.
Complex Conditional,DotNetSiemensPLCToolBoxLibrary.DataTypes.Projectfolders.Step7V5,BlocksOfflineFolder,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Projectfolders\Step7V5\BlocksOfflineFolder.cs,intReadPlcBlocksList,The conditional expression  "(int)row["OBJECTID"] == step7ProjectBlockInfo.id && (subblktyp == 12 || subblktyp == 8 || subblktyp == 14)"  is complex.
Complex Conditional,DotNetSiemensPLCToolBoxLibrary.DataTypes.Projectfolders.Step7V5,BlocksOfflineFolder,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Projectfolders\Step7V5\BlocksOfflineFolder.cs,ChangeKnowHowProtection,The conditional expression  "objid == blkInfo.id && (subblktype == 12 || subblktype == 8 || subblktype == 14)"  is complex.
Complex Conditional,DotNetSiemensPLCToolBoxLibrary.DataTypes.Projectfolders.Step7V5,BlocksOfflineFolder,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Projectfolders\Step7V5\BlocksOfflineFolder.cs,GetBlockBytes,The conditional expression  "subblktype == 12 || subblktype == 8 || subblktype == 14 || subblktype == 13 || subblktype == 15"  is complex.
Complex Conditional,DotNetSiemensPLCToolBoxLibrary.DataTypes.Projectfolders.Step7V5,BlocksOfflineFolder,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Projectfolders\Step7V5\BlocksOfflineFolder.cs,GetBlockBytes,The conditional expression  "subblktype == 5 || subblktype == 3 || subblktype == 4 || subblktype == 7 || subblktype == 9"  is complex.
Complex Conditional,DotNetSiemensPLCToolBoxLibrary.DataTypes.Projectfolders.Step7V5,BlocksOfflineFolder,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Projectfolders\Step7V5\BlocksOfflineFolder.cs,GetBlockBytes,The conditional expression  "subblktype == 19 || subblktype == 17 || subblktype == 18 || subblktype == 22 ||                                   subblktype == 21"  is complex.
Complex Conditional,DotNetSiemensPLCToolBoxLibrary.DataTypes.Projectfolders.Step7V5,BlocksOfflineFolder,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Projectfolders\Step7V5\BlocksOfflineFolder.cs,GetBlockBytes,The conditional expression  "ssbpart != null && ssbpartlen > 2 && (ssbpart[0] == 0x0a || ssbpart[0] == 0x0b)"  is complex.
Complex Conditional,DotNetSiemensPLCToolBoxLibrary.DataTypes.Projectfolders.Step7V5,BlocksOfflineFolder,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Projectfolders\Step7V5\BlocksOfflineFolder.cs,GetBlock,The conditional expression  "blkInfo.BlockType == PLCBlockType.FC || blkInfo.BlockType == PLCBlockType.FB || blkInfo.BlockType == PLCBlockType.OB || blkInfo.BlockType == PLCBlockType.SFB || blkInfo.BlockType == PLCBlockType.SFC"  is complex.
Complex Conditional,DotNetSiemensPLCToolBoxLibrary.DBF,dBaseConverter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DBF\Util.cs,L_ToBool,The conditional expression  "dBaseByte == 'Y' || dBaseByte == 'y' || dBaseByte == 'T' || dBaseByte == 't'"  is complex.
Complex Conditional,DotNetSiemensPLCToolBoxLibrary.General,EndianessMarshaler,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\General\EndianAttribute.cs,RespectEndianness,The conditional expression  "(att.Endianness == Endianness.BigEndian && BitConverter.IsLittleEndian) || (att.Endianness == Endianness.LittleEndian && !BitConverter.IsLittleEndian)"  is complex.
Complex Conditional,DotNetSiemensPLCToolBoxLibrary.General,StringLogicalComparer,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\General\StringLogicalComparer.cs,Compare,The conditional expression  "(letter1 && letter2) || (!letter1 && !letter2)"  is complex.
Complex Conditional,DotNetSiemensPLCToolBoxLibrary.PLCs.S5.MC5,MC5toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S5\MC5\MC5toAWL.cs,IsCall,The conditional expression  "(newRow.Command == "SPA" && newRow.Parameter.Substring(0' 2) == "FB") ||                          (newRow.Command == "SPB" && newRow.Parameter.Substring(0' 2) == "FB") ||                          (newRow.Command == "BA" && newRow.Parameter.Substring(0' 2) == "FX") ||                          (newRow.Command == "BAB" && newRow.Parameter.Substring(0' 2) == "FX")"  is complex.
Complex Conditional,DotNetSiemensPLCToolBoxLibrary.PLCs.S5.MC5,MC5toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S5\MC5\MC5toAWL.cs,GetMC5Rows,The conditional expression  "tmp.Command == "SPA=" || tmp.Command == "SPB=" || tmp.Command == "SPZ=" || tmp.Command == "SPN=" || tmp.Command == "SPP=" || tmp.Command == "SPM=" || tmp.Command == "SPO=""  is complex.
Complex Conditional,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,CallConverter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\CallConverter.cs,ConvertUCToCall,The conditional expression  "row.Command == Mnemonic.opBLD[(int)myOpt.Mnemonic] && (row.Parameter == "1" || row.Parameter == "7" || row.Parameter == "3" || row.Parameter == "16" || row.Parameter == "14") && inBld == 0"  is complex.
Complex Conditional,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,CallConverter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\CallConverter.cs,ConvertUCToCall,The conditional expression  "row.Command == Mnemonic.opU[(int)myOpt.Mnemonic] || row.Command == Mnemonic.opUN[(int)myOpt.Mnemonic] ||                                   row.Command == Mnemonic.opO[(int)myOpt.Mnemonic] || row.Command == Mnemonic.opON[(int)myOpt.Mnemonic] ||                                   row.Command == Mnemonic.opO[(int)myOpt.Mnemonic] || row.Command == Mnemonic.opON[(int)myOpt.Mnemonic] ||                                   row.Command == Mnemonic.opX[(int)myOpt.Mnemonic] || row.Command == Mnemonic.opXN[(int)myOpt.Mnemonic] ||                                   row.Command == Mnemonic.opL[(int)myOpt.Mnemonic]"  is complex.
Complex Conditional,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,CallConverter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\CallConverter.cs,ConvertUCToCall,The conditional expression  "akRow.DataType == S7DataRowType.STRING || akRow.DataType == S7DataRowType.DATE_AND_TIME ||                                          akRow.DataType == S7DataRowType.STRUCT || akRow.DataType == S7DataRowType.UDT ||                                          akRow.DataType == S7DataRowType.POINTER || akRow.IsArray"  is complex.
Complex Conditional,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,CallConverter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\CallConverter.cs,ConvertUCToCall,The conditional expression  "Parameters.ContainsKey("P#V " + (lokaldata_address + 0).ToString() + ".0") &&                                              Parameters.ContainsKey("P#V " + (lokaldata_address + 2).ToString() + ".0") &&                                              Parameters.ContainsKey("P#V " + (lokaldata_address + 4).ToString() + ".0") &&                                              Parameters.ContainsKey("P#V " + (lokaldata_address + 6).ToString() + ".0")"  is complex.
Complex Conditional,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,CallConverter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\CallConverter.cs,ConvertUCToCall,The conditional expression  "row.Command == Mnemonic.opU[(int)myOpt.Mnemonic] || row.Command == Mnemonic.opUN[(int)myOpt.Mnemonic] ||                                   row.Command == Mnemonic.opO[(int)myOpt.Mnemonic] || row.Command == Mnemonic.opON[(int)myOpt.Mnemonic] ||                                   row.Command == Mnemonic.opO[(int)myOpt.Mnemonic] || row.Command == Mnemonic.opON[(int)myOpt.Mnemonic] ||                                   row.Command == Mnemonic.opX[(int)myOpt.Mnemonic] || row.Command == Mnemonic.opXN[(int)myOpt.Mnemonic] ||                                   row.Command == Mnemonic.opL[(int)myOpt.Mnemonic]"  is complex.
Complex Conditional,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,CallConverter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\CallConverter.cs,ConvertUCToCall,The conditional expression  "row.Command == Mnemonic.opBLD[(int)myOpt.Mnemonic] && (row.Parameter == "4" || row.Parameter == "17" || row.Parameter == "15")"  is complex.
Complex Conditional,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GenerateFBParameterUsesFromAR2Calls,The conditional expression  "(combineStep == 2 && plcFunctionBlockRow.Command == MC7.Mnemonic.opLAR2[Memnoic] && plcFunctionBlockRow.Parameter == TarLdTarget) ||                      (combineStep == 0 && plcFunctionBlockRow.Parameter.Contains("[AR2'P#"))"  is complex.
Complex Conditional,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,IsJump,The conditional expression  "myCmd.Command == Mnemonic.opSPA[MN]                 || myCmd.Command == Mnemonic.opSPB[MN]                 || myCmd.Command == Mnemonic.opSPBB[MN]                 || myCmd.Command == Mnemonic.opSPBI[MN]                 || myCmd.Command == Mnemonic.opSPBIN[MN]                 || myCmd.Command == Mnemonic.opSPBN[MN]                 || myCmd.Command == Mnemonic.opSPBNB[MN]                 || myCmd.Command == Mnemonic.opSPL[MN]                 || myCmd.Command == Mnemonic.opSPM[MN]                 || myCmd.Command == Mnemonic.opSPMZ[MN]                 || myCmd.Command == Mnemonic.opSPN[MN]                 || myCmd.Command == Mnemonic.opSPO[MN]                 || myCmd.Command == Mnemonic.opSPP[MN]                 || myCmd.Command == Mnemonic.opSPPZ[MN]                 || myCmd.Command == Mnemonic.opSPS[MN]                 || myCmd.Command == Mnemonic.opSPU[MN]                 || myCmd.Command == Mnemonic.opSPZ[MN]                 || myCmd.Command == Mnemonic.opLOOP[MN]"  is complex.
Complex Conditional,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,steuerZ,The conditional expression  "val < 0x20 || val == 0x7F || val == 0x81 || val == 0x8D || val == 0x8F || val == 0x90 || val == 0x9D"  is complex.
Complex Conditional,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7toAWL.cs,GetAWL,The conditional expression  "BD[pos] == 0x00 || BD[pos] == 0x01 || BD[pos] == 0x05 || BD[pos] == 0x09 || BD[pos] == 0x49"  is complex.
Complex Conditional,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Parameter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Parameter.cs,GetInterfaceOrDBFromStep7ProjectString,The conditional expression  "rows[n].Contains("ARRAY") && rows[n].Contains(" OF ") && (isArray && !rows[n].Contains("\t"))"  is complex.
Complex Conditional,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Parameter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Parameter.cs,GetInterfaceOrDBFromStep7ProjectString,The conditional expression  "parseZustand == 1 && tmpChar != ' ' && tmpChar != ':' && tmpChar != '=' && tmpChar != '}' && tmpChar != '\'' && tmpChar != ';'"  is complex.
Complex Conditional,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Parameter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Parameter.cs,GetInterfaceOrDBFromStep7ProjectString,The conditional expression  "(parseZustand == 3 || parseZustand == 4) && tmpChar == '/' && rowTr[j + 1] == '/'"  is complex.
Complex Conditional,DotNetSiemensPLCToolBoxLibrary.Source,AWLSourceParser,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Source\AWLSourceParser.cs,ParseAWL,The conditional expression  "!startOfQuote && (c == ' ' || c == '\n' || c == '\r' || c == '=' || c == ':') || c == '"'"  is complex.
Virtual Method Call from Constructor,DotNetSiemensPLCToolBoxLibrary.Communication,NC_Var,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCNckTag.cs,NC_Var,The constructor "NC_Var" calls a virtual method "_internalGetSize".
Empty Catch Block,DotNetSiemensPLCToolBoxLibrary.Communication.Discovery,ScannerWorker,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Discovery\IPScanner.cs,DoWork,The method has an empty catch block.
Empty Catch Block,DotNetSiemensPLCToolBoxLibrary.Communication.Discovery,ScannerWorker,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Discovery\IPScanner.cs,DoWork,The method has an empty catch block.
Empty Catch Block,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,daveConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,daveConnection,The method has an empty catch block.
Empty Catch Block,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,Dispose,The method has an empty catch block.
Empty Catch Block,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,Dispose,The method has an empty catch block.
Empty Catch Block,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,Dispose,The method has an empty catch block.
Empty Catch Block,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,socket_Thread,The method has an empty catch block.
Empty Catch Block,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,Connect,The method has an empty catch block.
Empty Catch Block,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,GetAlarmS_IDs,The method has an empty catch block.
Empty Catch Block,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,GetByteArrayFromBuffer,The method has an empty catch block.
Empty Catch Block,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnectionConfiguration,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnectionConfiguration.cs,DeleteConfiguration,The method has an empty catch block.
Empty Catch Block,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTag.cs,ParseControlValueFromString,The method has an empty catch block.
Empty Catch Block,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTag.cs,ParseControlValueFromString,The method has an empty catch block.
Empty Catch Block,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTag.cs,ParseControlValueFromString,The method has an empty catch block.
Empty Catch Block,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTag.cs,ParseControlValueFromString,The method has an empty catch block.
Empty Catch Block,DotNetSiemensPLCToolBoxLibrary.DataTypes.Projectfolders.Step5,SymbolTable,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Projectfolders\Step5\SymbolTable.cs,LoadSymboltable,The method has an empty catch block.
Empty Catch Block,DotNetSiemensPLCToolBoxLibrary.DataTypes.Projectfolders.Step7V5,SymbolTable,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Projectfolders\Step7V5\SymbolTable.cs,LoadSymboltable,The method has an empty catch block.
Empty Catch Block,DotNetSiemensPLCToolBoxLibrary.DBF.Index.MDX,MDXFile,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DBF\Index\MDX\MDXFile.cs,Dispose,The method has an empty catch block.
Empty Catch Block,DotNetSiemensPLCToolBoxLibrary.DBF,ParseDBF,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DBF\ParseDBF.cs,openMemoFile,The method has an empty catch block.
Empty Catch Block,DotNetSiemensPLCToolBoxLibrary.General,ZipHelper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\General\ZipHelper.cs,ZipHelper,The method has an empty catch block.
Empty Catch Block,DotNetSiemensPLCToolBoxLibrary.PLCs.S5.MC5,MC5toDB,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S5\MC5\MC5toDB.cs,GetDB,The method has an empty catch block.
Empty Catch Block,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Projects,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Projects.cs,GetStep7ProjectsFromDirectory,The method has an empty catch block.
Empty Catch Block,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Projects,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Projects.cs,GetStep7ProjectsFromDirectory,The method has an empty catch block.
Empty Catch Block,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Projects,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Projects.cs,GetStep7ProjectsFromDirectory,The method has an empty catch block.
Empty Catch Block,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The method has an empty catch block.
Empty Catch Block,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The method has an empty catch block.
Empty Catch Block,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The method has an empty catch block.
Empty Catch Block,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The method has an empty catch block.
Empty Catch Block,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The method has an empty catch block.
Empty Catch Block,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The method has an empty catch block.
Empty Catch Block,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The method has an empty catch block.
Empty Catch Block,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The method has an empty catch block.
Empty Catch Block,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The method has an empty catch block.
Empty Catch Block,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The method has an empty catch block.
Empty Catch Block,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The method has an empty catch block.
Empty Catch Block,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The method has an empty catch block.
Empty Catch Block,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The method has an empty catch block.
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.FetchWrite,FetchWriteConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\FetchWrite\FetchWriteConnection.cs,ReadValue,The following statement contains a magic number: rqHeader.opcode_length = 3;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.FetchWrite,FetchWriteConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\FetchWrite\FetchWriteConnection.cs,ReadValue,The following statement contains a magic number: rqHeader.org = 3;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.FetchWrite,FetchWriteConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\FetchWrite\FetchWriteConnection.cs,ReadValue,The following statement contains a magic number: rqHeader.org_length = 8;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.FetchWrite,FetchWriteConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\FetchWrite\FetchWriteConnection.cs,ReadValue,The following statement contains a magic number: rqHeader.start_address1 = (byte) (((tag.ByteAddress/2) & 0xff00) >> 8);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.FetchWrite,FetchWriteConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\FetchWrite\FetchWriteConnection.cs,ReadValue,The following statement contains a magic number: rqHeader.start_address1 = (byte) (((tag.ByteAddress/2) & 0xff00) >> 8);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.FetchWrite,FetchWriteConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\FetchWrite\FetchWriteConnection.cs,ReadValue,The following statement contains a magic number: rqHeader.start_address2 = (byte) (((tag.ByteAddress/2) & 0x00ff));
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.FetchWrite,FetchWriteConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\FetchWrite\FetchWriteConnection.cs,ReadValue,The following statement contains a magic number: sz%2 > 0
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.FetchWrite,FetchWriteConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\FetchWrite\FetchWriteConnection.cs,ReadValue,The following statement contains a magic number: rqHeader.length1 = (byte) (((sz/2) & 0xff00) >> 8);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.FetchWrite,FetchWriteConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\FetchWrite\FetchWriteConnection.cs,ReadValue,The following statement contains a magic number: rqHeader.length1 = (byte) (((sz/2) & 0xff00) >> 8);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.FetchWrite,FetchWriteConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\FetchWrite\FetchWriteConnection.cs,ReadValue,The following statement contains a magic number: rqHeader.length2 = (byte) (((sz/2) & 0x00ff));
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.FetchWrite,FetchWriteConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\FetchWrite\FetchWriteConnection.cs,ReadValue,The following statement contains a magic number: rqHeader.req_empty_length = 2;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.FetchWrite,FetchWriteConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\FetchWrite\FetchWriteConnection.cs,ReadValue,The following statement contains a magic number: tag.ParseValueFromByteArray(data' tag.ByteAddress%2 > 0 ? 1 : 0);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.FetchWrite,FetchWriteConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\FetchWrite\FetchWriteConnection.cs,WriteValue,The following statement contains a magic number: rqHeader.opcode_length = 3;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.FetchWrite,FetchWriteConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\FetchWrite\FetchWriteConnection.cs,WriteValue,The following statement contains a magic number: rqHeader.org = 3;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.FetchWrite,FetchWriteConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\FetchWrite\FetchWriteConnection.cs,WriteValue,The following statement contains a magic number: rqHeader.org_length = 8;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.FetchWrite,FetchWriteConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\FetchWrite\FetchWriteConnection.cs,WriteValue,The following statement contains a magic number: rqHeader.start_address1 = (byte) (((tag.ByteAddress/2) & 0xff00) >> 8);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.FetchWrite,FetchWriteConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\FetchWrite\FetchWriteConnection.cs,WriteValue,The following statement contains a magic number: rqHeader.start_address1 = (byte) (((tag.ByteAddress/2) & 0xff00) >> 8);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.FetchWrite,FetchWriteConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\FetchWrite\FetchWriteConnection.cs,WriteValue,The following statement contains a magic number: rqHeader.start_address2 = (byte) (((tag.ByteAddress/2) & 0x00ff));
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.FetchWrite,FetchWriteConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\FetchWrite\FetchWriteConnection.cs,WriteValue,The following statement contains a magic number: sz%2 > 0
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.FetchWrite,FetchWriteConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\FetchWrite\FetchWriteConnection.cs,WriteValue,The following statement contains a magic number: rqHeader.length1 = (byte) (((sz/2) & 0xff00) >> 8);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.FetchWrite,FetchWriteConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\FetchWrite\FetchWriteConnection.cs,WriteValue,The following statement contains a magic number: rqHeader.length1 = (byte) (((sz/2) & 0xff00) >> 8);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.FetchWrite,FetchWriteConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\FetchWrite\FetchWriteConnection.cs,WriteValue,The following statement contains a magic number: rqHeader.length2 = (byte) (((sz/2) & 0x00ff));
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.FetchWrite,FetchWriteConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\FetchWrite\FetchWriteConnection.cs,WriteValue,The following statement contains a magic number: rqHeader.req_empty_length = 2;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.FetchWrite,FetchWriteConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\FetchWrite\FetchWriteConnection.cs,WriteValue,The following statement contains a magic number: tag.ReadByteSize % 2 > 0
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.FetchWrite,FetchWriteConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\FetchWrite\FetchWriteConnection.cs,WriteValue,The following statement contains a magic number: writeByte[putPos] = (byte) (Math.Pow(2'(tag.BitAddress)));
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,daveStrerror,The following statement contains a magic number: IntPtr.Size == 8
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,daveStrS7onlineError,The following statement contains a magic number: switch (err)              {                  case 202:                      return "S7Online: Ressourcenengpaß im Treiber oder in der Library";                  case 203:                      return "S7Online: Konfigurationsfehler";                  case 205:                      return "S7Online: Auftrag zur Zeit nicht erlaubt";                  case 206:                      return "S7Online: Parameterfehler";                  case 207:                      return "S7Online: Gerät bereits/noch nicht geöffnet.";                  case 208:                      return "S7Online: CP reagiert nicht";                  case 209:                      return "S7Online: Fehler in der Firmware";                  case 210:                      return "S7Online: Speicherengpaß im Treiber";                  case 215:                      return "S7Online: Keine Nachricht vorhanden";                  case 216:                      return "S7Online: Fehler bei Zugriff auf Anwendungspuffer";                  case 219:                      return "S7Online: Timeout abgelaufen";                  case 225:                      return "S7Online: Die maximale Anzahl an Anmeldungen ist überschritten";                  case 226:                      return "S7Online: Der Auftrag wurde abgebrochen";                  case 233:                      return "S7Online: Ein Hilfsprogramm konnte nicht gestartet werden";                  case 234:                      return "S7Online: Keine Autorisierung für diese Funktion vorhanden";                  case 304:                      return "S7Online: Initialisierung noch nicht abgeschlossen";                  case 305:                      return "S7Online: Funktion nicht implementiert";                  case 4865:                      return "S7Online: CP-Name nicht vorhanden";                  case 4866:                      return "S7Online: CP-Name nicht konfiguriert";                  case 4867:                      return "S7Online: Kanalname nicht vorhanden";                  case 4868:                      return "S7Online: Kanalname nicht konfiguriert";              }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,daveStrS7onlineError,The following statement contains a magic number: switch (err)              {                  case 202:                      return "S7Online: Ressourcenengpaß im Treiber oder in der Library";                  case 203:                      return "S7Online: Konfigurationsfehler";                  case 205:                      return "S7Online: Auftrag zur Zeit nicht erlaubt";                  case 206:                      return "S7Online: Parameterfehler";                  case 207:                      return "S7Online: Gerät bereits/noch nicht geöffnet.";                  case 208:                      return "S7Online: CP reagiert nicht";                  case 209:                      return "S7Online: Fehler in der Firmware";                  case 210:                      return "S7Online: Speicherengpaß im Treiber";                  case 215:                      return "S7Online: Keine Nachricht vorhanden";                  case 216:                      return "S7Online: Fehler bei Zugriff auf Anwendungspuffer";                  case 219:                      return "S7Online: Timeout abgelaufen";                  case 225:                      return "S7Online: Die maximale Anzahl an Anmeldungen ist überschritten";                  case 226:                      return "S7Online: Der Auftrag wurde abgebrochen";                  case 233:                      return "S7Online: Ein Hilfsprogramm konnte nicht gestartet werden";                  case 234:                      return "S7Online: Keine Autorisierung für diese Funktion vorhanden";                  case 304:                      return "S7Online: Initialisierung noch nicht abgeschlossen";                  case 305:                      return "S7Online: Funktion nicht implementiert";                  case 4865:                      return "S7Online: CP-Name nicht vorhanden";                  case 4866:                      return "S7Online: CP-Name nicht konfiguriert";                  case 4867:                      return "S7Online: Kanalname nicht vorhanden";                  case 4868:                      return "S7Online: Kanalname nicht konfiguriert";              }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,daveStrS7onlineError,The following statement contains a magic number: switch (err)              {                  case 202:                      return "S7Online: Ressourcenengpaß im Treiber oder in der Library";                  case 203:                      return "S7Online: Konfigurationsfehler";                  case 205:                      return "S7Online: Auftrag zur Zeit nicht erlaubt";                  case 206:                      return "S7Online: Parameterfehler";                  case 207:                      return "S7Online: Gerät bereits/noch nicht geöffnet.";                  case 208:                      return "S7Online: CP reagiert nicht";                  case 209:                      return "S7Online: Fehler in der Firmware";                  case 210:                      return "S7Online: Speicherengpaß im Treiber";                  case 215:                      return "S7Online: Keine Nachricht vorhanden";                  case 216:                      return "S7Online: Fehler bei Zugriff auf Anwendungspuffer";                  case 219:                      return "S7Online: Timeout abgelaufen";                  case 225:                      return "S7Online: Die maximale Anzahl an Anmeldungen ist überschritten";                  case 226:                      return "S7Online: Der Auftrag wurde abgebrochen";                  case 233:                      return "S7Online: Ein Hilfsprogramm konnte nicht gestartet werden";                  case 234:                      return "S7Online: Keine Autorisierung für diese Funktion vorhanden";                  case 304:                      return "S7Online: Initialisierung noch nicht abgeschlossen";                  case 305:                      return "S7Online: Funktion nicht implementiert";                  case 4865:                      return "S7Online: CP-Name nicht vorhanden";                  case 4866:                      return "S7Online: CP-Name nicht konfiguriert";                  case 4867:                      return "S7Online: Kanalname nicht vorhanden";                  case 4868:                      return "S7Online: Kanalname nicht konfiguriert";              }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,daveStrS7onlineError,The following statement contains a magic number: switch (err)              {                  case 202:                      return "S7Online: Ressourcenengpaß im Treiber oder in der Library";                  case 203:                      return "S7Online: Konfigurationsfehler";                  case 205:                      return "S7Online: Auftrag zur Zeit nicht erlaubt";                  case 206:                      return "S7Online: Parameterfehler";                  case 207:                      return "S7Online: Gerät bereits/noch nicht geöffnet.";                  case 208:                      return "S7Online: CP reagiert nicht";                  case 209:                      return "S7Online: Fehler in der Firmware";                  case 210:                      return "S7Online: Speicherengpaß im Treiber";                  case 215:                      return "S7Online: Keine Nachricht vorhanden";                  case 216:                      return "S7Online: Fehler bei Zugriff auf Anwendungspuffer";                  case 219:                      return "S7Online: Timeout abgelaufen";                  case 225:                      return "S7Online: Die maximale Anzahl an Anmeldungen ist überschritten";                  case 226:                      return "S7Online: Der Auftrag wurde abgebrochen";                  case 233:                      return "S7Online: Ein Hilfsprogramm konnte nicht gestartet werden";                  case 234:                      return "S7Online: Keine Autorisierung für diese Funktion vorhanden";                  case 304:                      return "S7Online: Initialisierung noch nicht abgeschlossen";                  case 305:                      return "S7Online: Funktion nicht implementiert";                  case 4865:                      return "S7Online: CP-Name nicht vorhanden";                  case 4866:                      return "S7Online: CP-Name nicht konfiguriert";                  case 4867:                      return "S7Online: Kanalname nicht vorhanden";                  case 4868:                      return "S7Online: Kanalname nicht konfiguriert";              }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,daveStrS7onlineError,The following statement contains a magic number: switch (err)              {                  case 202:                      return "S7Online: Ressourcenengpaß im Treiber oder in der Library";                  case 203:                      return "S7Online: Konfigurationsfehler";                  case 205:                      return "S7Online: Auftrag zur Zeit nicht erlaubt";                  case 206:                      return "S7Online: Parameterfehler";                  case 207:                      return "S7Online: Gerät bereits/noch nicht geöffnet.";                  case 208:                      return "S7Online: CP reagiert nicht";                  case 209:                      return "S7Online: Fehler in der Firmware";                  case 210:                      return "S7Online: Speicherengpaß im Treiber";                  case 215:                      return "S7Online: Keine Nachricht vorhanden";                  case 216:                      return "S7Online: Fehler bei Zugriff auf Anwendungspuffer";                  case 219:                      return "S7Online: Timeout abgelaufen";                  case 225:                      return "S7Online: Die maximale Anzahl an Anmeldungen ist überschritten";                  case 226:                      return "S7Online: Der Auftrag wurde abgebrochen";                  case 233:                      return "S7Online: Ein Hilfsprogramm konnte nicht gestartet werden";                  case 234:                      return "S7Online: Keine Autorisierung für diese Funktion vorhanden";                  case 304:                      return "S7Online: Initialisierung noch nicht abgeschlossen";                  case 305:                      return "S7Online: Funktion nicht implementiert";                  case 4865:                      return "S7Online: CP-Name nicht vorhanden";                  case 4866:                      return "S7Online: CP-Name nicht konfiguriert";                  case 4867:                      return "S7Online: Kanalname nicht vorhanden";                  case 4868:                      return "S7Online: Kanalname nicht konfiguriert";              }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,daveStrS7onlineError,The following statement contains a magic number: switch (err)              {                  case 202:                      return "S7Online: Ressourcenengpaß im Treiber oder in der Library";                  case 203:                      return "S7Online: Konfigurationsfehler";                  case 205:                      return "S7Online: Auftrag zur Zeit nicht erlaubt";                  case 206:                      return "S7Online: Parameterfehler";                  case 207:                      return "S7Online: Gerät bereits/noch nicht geöffnet.";                  case 208:                      return "S7Online: CP reagiert nicht";                  case 209:                      return "S7Online: Fehler in der Firmware";                  case 210:                      return "S7Online: Speicherengpaß im Treiber";                  case 215:                      return "S7Online: Keine Nachricht vorhanden";                  case 216:                      return "S7Online: Fehler bei Zugriff auf Anwendungspuffer";                  case 219:                      return "S7Online: Timeout abgelaufen";                  case 225:                      return "S7Online: Die maximale Anzahl an Anmeldungen ist überschritten";                  case 226:                      return "S7Online: Der Auftrag wurde abgebrochen";                  case 233:                      return "S7Online: Ein Hilfsprogramm konnte nicht gestartet werden";                  case 234:                      return "S7Online: Keine Autorisierung für diese Funktion vorhanden";                  case 304:                      return "S7Online: Initialisierung noch nicht abgeschlossen";                  case 305:                      return "S7Online: Funktion nicht implementiert";                  case 4865:                      return "S7Online: CP-Name nicht vorhanden";                  case 4866:                      return "S7Online: CP-Name nicht konfiguriert";                  case 4867:                      return "S7Online: Kanalname nicht vorhanden";                  case 4868:                      return "S7Online: Kanalname nicht konfiguriert";              }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,daveStrS7onlineError,The following statement contains a magic number: switch (err)              {                  case 202:                      return "S7Online: Ressourcenengpaß im Treiber oder in der Library";                  case 203:                      return "S7Online: Konfigurationsfehler";                  case 205:                      return "S7Online: Auftrag zur Zeit nicht erlaubt";                  case 206:                      return "S7Online: Parameterfehler";                  case 207:                      return "S7Online: Gerät bereits/noch nicht geöffnet.";                  case 208:                      return "S7Online: CP reagiert nicht";                  case 209:                      return "S7Online: Fehler in der Firmware";                  case 210:                      return "S7Online: Speicherengpaß im Treiber";                  case 215:                      return "S7Online: Keine Nachricht vorhanden";                  case 216:                      return "S7Online: Fehler bei Zugriff auf Anwendungspuffer";                  case 219:                      return "S7Online: Timeout abgelaufen";                  case 225:                      return "S7Online: Die maximale Anzahl an Anmeldungen ist überschritten";                  case 226:                      return "S7Online: Der Auftrag wurde abgebrochen";                  case 233:                      return "S7Online: Ein Hilfsprogramm konnte nicht gestartet werden";                  case 234:                      return "S7Online: Keine Autorisierung für diese Funktion vorhanden";                  case 304:                      return "S7Online: Initialisierung noch nicht abgeschlossen";                  case 305:                      return "S7Online: Funktion nicht implementiert";                  case 4865:                      return "S7Online: CP-Name nicht vorhanden";                  case 4866:                      return "S7Online: CP-Name nicht konfiguriert";                  case 4867:                      return "S7Online: Kanalname nicht vorhanden";                  case 4868:                      return "S7Online: Kanalname nicht konfiguriert";              }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,daveStrS7onlineError,The following statement contains a magic number: switch (err)              {                  case 202:                      return "S7Online: Ressourcenengpaß im Treiber oder in der Library";                  case 203:                      return "S7Online: Konfigurationsfehler";                  case 205:                      return "S7Online: Auftrag zur Zeit nicht erlaubt";                  case 206:                      return "S7Online: Parameterfehler";                  case 207:                      return "S7Online: Gerät bereits/noch nicht geöffnet.";                  case 208:                      return "S7Online: CP reagiert nicht";                  case 209:                      return "S7Online: Fehler in der Firmware";                  case 210:                      return "S7Online: Speicherengpaß im Treiber";                  case 215:                      return "S7Online: Keine Nachricht vorhanden";                  case 216:                      return "S7Online: Fehler bei Zugriff auf Anwendungspuffer";                  case 219:                      return "S7Online: Timeout abgelaufen";                  case 225:                      return "S7Online: Die maximale Anzahl an Anmeldungen ist überschritten";                  case 226:                      return "S7Online: Der Auftrag wurde abgebrochen";                  case 233:                      return "S7Online: Ein Hilfsprogramm konnte nicht gestartet werden";                  case 234:                      return "S7Online: Keine Autorisierung für diese Funktion vorhanden";                  case 304:                      return "S7Online: Initialisierung noch nicht abgeschlossen";                  case 305:                      return "S7Online: Funktion nicht implementiert";                  case 4865:                      return "S7Online: CP-Name nicht vorhanden";                  case 4866:                      return "S7Online: CP-Name nicht konfiguriert";                  case 4867:                      return "S7Online: Kanalname nicht vorhanden";                  case 4868:                      return "S7Online: Kanalname nicht konfiguriert";              }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,daveStrS7onlineError,The following statement contains a magic number: switch (err)              {                  case 202:                      return "S7Online: Ressourcenengpaß im Treiber oder in der Library";                  case 203:                      return "S7Online: Konfigurationsfehler";                  case 205:                      return "S7Online: Auftrag zur Zeit nicht erlaubt";                  case 206:                      return "S7Online: Parameterfehler";                  case 207:                      return "S7Online: Gerät bereits/noch nicht geöffnet.";                  case 208:                      return "S7Online: CP reagiert nicht";                  case 209:                      return "S7Online: Fehler in der Firmware";                  case 210:                      return "S7Online: Speicherengpaß im Treiber";                  case 215:                      return "S7Online: Keine Nachricht vorhanden";                  case 216:                      return "S7Online: Fehler bei Zugriff auf Anwendungspuffer";                  case 219:                      return "S7Online: Timeout abgelaufen";                  case 225:                      return "S7Online: Die maximale Anzahl an Anmeldungen ist überschritten";                  case 226:                      return "S7Online: Der Auftrag wurde abgebrochen";                  case 233:                      return "S7Online: Ein Hilfsprogramm konnte nicht gestartet werden";                  case 234:                      return "S7Online: Keine Autorisierung für diese Funktion vorhanden";                  case 304:                      return "S7Online: Initialisierung noch nicht abgeschlossen";                  case 305:                      return "S7Online: Funktion nicht implementiert";                  case 4865:                      return "S7Online: CP-Name nicht vorhanden";                  case 4866:                      return "S7Online: CP-Name nicht konfiguriert";                  case 4867:                      return "S7Online: Kanalname nicht vorhanden";                  case 4868:                      return "S7Online: Kanalname nicht konfiguriert";              }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,daveStrS7onlineError,The following statement contains a magic number: switch (err)              {                  case 202:                      return "S7Online: Ressourcenengpaß im Treiber oder in der Library";                  case 203:                      return "S7Online: Konfigurationsfehler";                  case 205:                      return "S7Online: Auftrag zur Zeit nicht erlaubt";                  case 206:                      return "S7Online: Parameterfehler";                  case 207:                      return "S7Online: Gerät bereits/noch nicht geöffnet.";                  case 208:                      return "S7Online: CP reagiert nicht";                  case 209:                      return "S7Online: Fehler in der Firmware";                  case 210:                      return "S7Online: Speicherengpaß im Treiber";                  case 215:                      return "S7Online: Keine Nachricht vorhanden";                  case 216:                      return "S7Online: Fehler bei Zugriff auf Anwendungspuffer";                  case 219:                      return "S7Online: Timeout abgelaufen";                  case 225:                      return "S7Online: Die maximale Anzahl an Anmeldungen ist überschritten";                  case 226:                      return "S7Online: Der Auftrag wurde abgebrochen";                  case 233:                      return "S7Online: Ein Hilfsprogramm konnte nicht gestartet werden";                  case 234:                      return "S7Online: Keine Autorisierung für diese Funktion vorhanden";                  case 304:                      return "S7Online: Initialisierung noch nicht abgeschlossen";                  case 305:                      return "S7Online: Funktion nicht implementiert";                  case 4865:                      return "S7Online: CP-Name nicht vorhanden";                  case 4866:                      return "S7Online: CP-Name nicht konfiguriert";                  case 4867:                      return "S7Online: Kanalname nicht vorhanden";                  case 4868:                      return "S7Online: Kanalname nicht konfiguriert";              }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,daveStrS7onlineError,The following statement contains a magic number: switch (err)              {                  case 202:                      return "S7Online: Ressourcenengpaß im Treiber oder in der Library";                  case 203:                      return "S7Online: Konfigurationsfehler";                  case 205:                      return "S7Online: Auftrag zur Zeit nicht erlaubt";                  case 206:                      return "S7Online: Parameterfehler";                  case 207:                      return "S7Online: Gerät bereits/noch nicht geöffnet.";                  case 208:                      return "S7Online: CP reagiert nicht";                  case 209:                      return "S7Online: Fehler in der Firmware";                  case 210:                      return "S7Online: Speicherengpaß im Treiber";                  case 215:                      return "S7Online: Keine Nachricht vorhanden";                  case 216:                      return "S7Online: Fehler bei Zugriff auf Anwendungspuffer";                  case 219:                      return "S7Online: Timeout abgelaufen";                  case 225:                      return "S7Online: Die maximale Anzahl an Anmeldungen ist überschritten";                  case 226:                      return "S7Online: Der Auftrag wurde abgebrochen";                  case 233:                      return "S7Online: Ein Hilfsprogramm konnte nicht gestartet werden";                  case 234:                      return "S7Online: Keine Autorisierung für diese Funktion vorhanden";                  case 304:                      return "S7Online: Initialisierung noch nicht abgeschlossen";                  case 305:                      return "S7Online: Funktion nicht implementiert";                  case 4865:                      return "S7Online: CP-Name nicht vorhanden";                  case 4866:                      return "S7Online: CP-Name nicht konfiguriert";                  case 4867:                      return "S7Online: Kanalname nicht vorhanden";                  case 4868:                      return "S7Online: Kanalname nicht konfiguriert";              }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,daveStrS7onlineError,The following statement contains a magic number: switch (err)              {                  case 202:                      return "S7Online: Ressourcenengpaß im Treiber oder in der Library";                  case 203:                      return "S7Online: Konfigurationsfehler";                  case 205:                      return "S7Online: Auftrag zur Zeit nicht erlaubt";                  case 206:                      return "S7Online: Parameterfehler";                  case 207:                      return "S7Online: Gerät bereits/noch nicht geöffnet.";                  case 208:                      return "S7Online: CP reagiert nicht";                  case 209:                      return "S7Online: Fehler in der Firmware";                  case 210:                      return "S7Online: Speicherengpaß im Treiber";                  case 215:                      return "S7Online: Keine Nachricht vorhanden";                  case 216:                      return "S7Online: Fehler bei Zugriff auf Anwendungspuffer";                  case 219:                      return "S7Online: Timeout abgelaufen";                  case 225:                      return "S7Online: Die maximale Anzahl an Anmeldungen ist überschritten";                  case 226:                      return "S7Online: Der Auftrag wurde abgebrochen";                  case 233:                      return "S7Online: Ein Hilfsprogramm konnte nicht gestartet werden";                  case 234:                      return "S7Online: Keine Autorisierung für diese Funktion vorhanden";                  case 304:                      return "S7Online: Initialisierung noch nicht abgeschlossen";                  case 305:                      return "S7Online: Funktion nicht implementiert";                  case 4865:                      return "S7Online: CP-Name nicht vorhanden";                  case 4866:                      return "S7Online: CP-Name nicht konfiguriert";                  case 4867:                      return "S7Online: Kanalname nicht vorhanden";                  case 4868:                      return "S7Online: Kanalname nicht konfiguriert";              }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,daveStrS7onlineError,The following statement contains a magic number: switch (err)              {                  case 202:                      return "S7Online: Ressourcenengpaß im Treiber oder in der Library";                  case 203:                      return "S7Online: Konfigurationsfehler";                  case 205:                      return "S7Online: Auftrag zur Zeit nicht erlaubt";                  case 206:                      return "S7Online: Parameterfehler";                  case 207:                      return "S7Online: Gerät bereits/noch nicht geöffnet.";                  case 208:                      return "S7Online: CP reagiert nicht";                  case 209:                      return "S7Online: Fehler in der Firmware";                  case 210:                      return "S7Online: Speicherengpaß im Treiber";                  case 215:                      return "S7Online: Keine Nachricht vorhanden";                  case 216:                      return "S7Online: Fehler bei Zugriff auf Anwendungspuffer";                  case 219:                      return "S7Online: Timeout abgelaufen";                  case 225:                      return "S7Online: Die maximale Anzahl an Anmeldungen ist überschritten";                  case 226:                      return "S7Online: Der Auftrag wurde abgebrochen";                  case 233:                      return "S7Online: Ein Hilfsprogramm konnte nicht gestartet werden";                  case 234:                      return "S7Online: Keine Autorisierung für diese Funktion vorhanden";                  case 304:                      return "S7Online: Initialisierung noch nicht abgeschlossen";                  case 305:                      return "S7Online: Funktion nicht implementiert";                  case 4865:                      return "S7Online: CP-Name nicht vorhanden";                  case 4866:                      return "S7Online: CP-Name nicht konfiguriert";                  case 4867:                      return "S7Online: Kanalname nicht vorhanden";                  case 4868:                      return "S7Online: Kanalname nicht konfiguriert";              }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,daveStrS7onlineError,The following statement contains a magic number: switch (err)              {                  case 202:                      return "S7Online: Ressourcenengpaß im Treiber oder in der Library";                  case 203:                      return "S7Online: Konfigurationsfehler";                  case 205:                      return "S7Online: Auftrag zur Zeit nicht erlaubt";                  case 206:                      return "S7Online: Parameterfehler";                  case 207:                      return "S7Online: Gerät bereits/noch nicht geöffnet.";                  case 208:                      return "S7Online: CP reagiert nicht";                  case 209:                      return "S7Online: Fehler in der Firmware";                  case 210:                      return "S7Online: Speicherengpaß im Treiber";                  case 215:                      return "S7Online: Keine Nachricht vorhanden";                  case 216:                      return "S7Online: Fehler bei Zugriff auf Anwendungspuffer";                  case 219:                      return "S7Online: Timeout abgelaufen";                  case 225:                      return "S7Online: Die maximale Anzahl an Anmeldungen ist überschritten";                  case 226:                      return "S7Online: Der Auftrag wurde abgebrochen";                  case 233:                      return "S7Online: Ein Hilfsprogramm konnte nicht gestartet werden";                  case 234:                      return "S7Online: Keine Autorisierung für diese Funktion vorhanden";                  case 304:                      return "S7Online: Initialisierung noch nicht abgeschlossen";                  case 305:                      return "S7Online: Funktion nicht implementiert";                  case 4865:                      return "S7Online: CP-Name nicht vorhanden";                  case 4866:                      return "S7Online: CP-Name nicht konfiguriert";                  case 4867:                      return "S7Online: Kanalname nicht vorhanden";                  case 4868:                      return "S7Online: Kanalname nicht konfiguriert";              }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,daveStrS7onlineError,The following statement contains a magic number: switch (err)              {                  case 202:                      return "S7Online: Ressourcenengpaß im Treiber oder in der Library";                  case 203:                      return "S7Online: Konfigurationsfehler";                  case 205:                      return "S7Online: Auftrag zur Zeit nicht erlaubt";                  case 206:                      return "S7Online: Parameterfehler";                  case 207:                      return "S7Online: Gerät bereits/noch nicht geöffnet.";                  case 208:                      return "S7Online: CP reagiert nicht";                  case 209:                      return "S7Online: Fehler in der Firmware";                  case 210:                      return "S7Online: Speicherengpaß im Treiber";                  case 215:                      return "S7Online: Keine Nachricht vorhanden";                  case 216:                      return "S7Online: Fehler bei Zugriff auf Anwendungspuffer";                  case 219:                      return "S7Online: Timeout abgelaufen";                  case 225:                      return "S7Online: Die maximale Anzahl an Anmeldungen ist überschritten";                  case 226:                      return "S7Online: Der Auftrag wurde abgebrochen";                  case 233:                      return "S7Online: Ein Hilfsprogramm konnte nicht gestartet werden";                  case 234:                      return "S7Online: Keine Autorisierung für diese Funktion vorhanden";                  case 304:                      return "S7Online: Initialisierung noch nicht abgeschlossen";                  case 305:                      return "S7Online: Funktion nicht implementiert";                  case 4865:                      return "S7Online: CP-Name nicht vorhanden";                  case 4866:                      return "S7Online: CP-Name nicht konfiguriert";                  case 4867:                      return "S7Online: Kanalname nicht vorhanden";                  case 4868:                      return "S7Online: Kanalname nicht konfiguriert";              }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,daveStrS7onlineError,The following statement contains a magic number: switch (err)              {                  case 202:                      return "S7Online: Ressourcenengpaß im Treiber oder in der Library";                  case 203:                      return "S7Online: Konfigurationsfehler";                  case 205:                      return "S7Online: Auftrag zur Zeit nicht erlaubt";                  case 206:                      return "S7Online: Parameterfehler";                  case 207:                      return "S7Online: Gerät bereits/noch nicht geöffnet.";                  case 208:                      return "S7Online: CP reagiert nicht";                  case 209:                      return "S7Online: Fehler in der Firmware";                  case 210:                      return "S7Online: Speicherengpaß im Treiber";                  case 215:                      return "S7Online: Keine Nachricht vorhanden";                  case 216:                      return "S7Online: Fehler bei Zugriff auf Anwendungspuffer";                  case 219:                      return "S7Online: Timeout abgelaufen";                  case 225:                      return "S7Online: Die maximale Anzahl an Anmeldungen ist überschritten";                  case 226:                      return "S7Online: Der Auftrag wurde abgebrochen";                  case 233:                      return "S7Online: Ein Hilfsprogramm konnte nicht gestartet werden";                  case 234:                      return "S7Online: Keine Autorisierung für diese Funktion vorhanden";                  case 304:                      return "S7Online: Initialisierung noch nicht abgeschlossen";                  case 305:                      return "S7Online: Funktion nicht implementiert";                  case 4865:                      return "S7Online: CP-Name nicht vorhanden";                  case 4866:                      return "S7Online: CP-Name nicht konfiguriert";                  case 4867:                      return "S7Online: Kanalname nicht vorhanden";                  case 4868:                      return "S7Online: Kanalname nicht konfiguriert";              }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,daveStrS7onlineError,The following statement contains a magic number: switch (err)              {                  case 202:                      return "S7Online: Ressourcenengpaß im Treiber oder in der Library";                  case 203:                      return "S7Online: Konfigurationsfehler";                  case 205:                      return "S7Online: Auftrag zur Zeit nicht erlaubt";                  case 206:                      return "S7Online: Parameterfehler";                  case 207:                      return "S7Online: Gerät bereits/noch nicht geöffnet.";                  case 208:                      return "S7Online: CP reagiert nicht";                  case 209:                      return "S7Online: Fehler in der Firmware";                  case 210:                      return "S7Online: Speicherengpaß im Treiber";                  case 215:                      return "S7Online: Keine Nachricht vorhanden";                  case 216:                      return "S7Online: Fehler bei Zugriff auf Anwendungspuffer";                  case 219:                      return "S7Online: Timeout abgelaufen";                  case 225:                      return "S7Online: Die maximale Anzahl an Anmeldungen ist überschritten";                  case 226:                      return "S7Online: Der Auftrag wurde abgebrochen";                  case 233:                      return "S7Online: Ein Hilfsprogramm konnte nicht gestartet werden";                  case 234:                      return "S7Online: Keine Autorisierung für diese Funktion vorhanden";                  case 304:                      return "S7Online: Initialisierung noch nicht abgeschlossen";                  case 305:                      return "S7Online: Funktion nicht implementiert";                  case 4865:                      return "S7Online: CP-Name nicht vorhanden";                  case 4866:                      return "S7Online: CP-Name nicht konfiguriert";                  case 4867:                      return "S7Online: Kanalname nicht vorhanden";                  case 4868:                      return "S7Online: Kanalname nicht konfiguriert";              }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,daveStrS7onlineError,The following statement contains a magic number: switch (err)              {                  case 202:                      return "S7Online: Ressourcenengpaß im Treiber oder in der Library";                  case 203:                      return "S7Online: Konfigurationsfehler";                  case 205:                      return "S7Online: Auftrag zur Zeit nicht erlaubt";                  case 206:                      return "S7Online: Parameterfehler";                  case 207:                      return "S7Online: Gerät bereits/noch nicht geöffnet.";                  case 208:                      return "S7Online: CP reagiert nicht";                  case 209:                      return "S7Online: Fehler in der Firmware";                  case 210:                      return "S7Online: Speicherengpaß im Treiber";                  case 215:                      return "S7Online: Keine Nachricht vorhanden";                  case 216:                      return "S7Online: Fehler bei Zugriff auf Anwendungspuffer";                  case 219:                      return "S7Online: Timeout abgelaufen";                  case 225:                      return "S7Online: Die maximale Anzahl an Anmeldungen ist überschritten";                  case 226:                      return "S7Online: Der Auftrag wurde abgebrochen";                  case 233:                      return "S7Online: Ein Hilfsprogramm konnte nicht gestartet werden";                  case 234:                      return "S7Online: Keine Autorisierung für diese Funktion vorhanden";                  case 304:                      return "S7Online: Initialisierung noch nicht abgeschlossen";                  case 305:                      return "S7Online: Funktion nicht implementiert";                  case 4865:                      return "S7Online: CP-Name nicht vorhanden";                  case 4866:                      return "S7Online: CP-Name nicht konfiguriert";                  case 4867:                      return "S7Online: Kanalname nicht vorhanden";                  case 4868:                      return "S7Online: Kanalname nicht konfiguriert";              }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,daveStrS7onlineError,The following statement contains a magic number: switch (err)              {                  case 202:                      return "S7Online: Ressourcenengpaß im Treiber oder in der Library";                  case 203:                      return "S7Online: Konfigurationsfehler";                  case 205:                      return "S7Online: Auftrag zur Zeit nicht erlaubt";                  case 206:                      return "S7Online: Parameterfehler";                  case 207:                      return "S7Online: Gerät bereits/noch nicht geöffnet.";                  case 208:                      return "S7Online: CP reagiert nicht";                  case 209:                      return "S7Online: Fehler in der Firmware";                  case 210:                      return "S7Online: Speicherengpaß im Treiber";                  case 215:                      return "S7Online: Keine Nachricht vorhanden";                  case 216:                      return "S7Online: Fehler bei Zugriff auf Anwendungspuffer";                  case 219:                      return "S7Online: Timeout abgelaufen";                  case 225:                      return "S7Online: Die maximale Anzahl an Anmeldungen ist überschritten";                  case 226:                      return "S7Online: Der Auftrag wurde abgebrochen";                  case 233:                      return "S7Online: Ein Hilfsprogramm konnte nicht gestartet werden";                  case 234:                      return "S7Online: Keine Autorisierung für diese Funktion vorhanden";                  case 304:                      return "S7Online: Initialisierung noch nicht abgeschlossen";                  case 305:                      return "S7Online: Funktion nicht implementiert";                  case 4865:                      return "S7Online: CP-Name nicht vorhanden";                  case 4866:                      return "S7Online: CP-Name nicht konfiguriert";                  case 4867:                      return "S7Online: Kanalname nicht vorhanden";                  case 4868:                      return "S7Online: Kanalname nicht konfiguriert";              }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,daveStrS7onlineError,The following statement contains a magic number: switch (err)              {                  case 202:                      return "S7Online: Ressourcenengpaß im Treiber oder in der Library";                  case 203:                      return "S7Online: Konfigurationsfehler";                  case 205:                      return "S7Online: Auftrag zur Zeit nicht erlaubt";                  case 206:                      return "S7Online: Parameterfehler";                  case 207:                      return "S7Online: Gerät bereits/noch nicht geöffnet.";                  case 208:                      return "S7Online: CP reagiert nicht";                  case 209:                      return "S7Online: Fehler in der Firmware";                  case 210:                      return "S7Online: Speicherengpaß im Treiber";                  case 215:                      return "S7Online: Keine Nachricht vorhanden";                  case 216:                      return "S7Online: Fehler bei Zugriff auf Anwendungspuffer";                  case 219:                      return "S7Online: Timeout abgelaufen";                  case 225:                      return "S7Online: Die maximale Anzahl an Anmeldungen ist überschritten";                  case 226:                      return "S7Online: Der Auftrag wurde abgebrochen";                  case 233:                      return "S7Online: Ein Hilfsprogramm konnte nicht gestartet werden";                  case 234:                      return "S7Online: Keine Autorisierung für diese Funktion vorhanden";                  case 304:                      return "S7Online: Initialisierung noch nicht abgeschlossen";                  case 305:                      return "S7Online: Funktion nicht implementiert";                  case 4865:                      return "S7Online: CP-Name nicht vorhanden";                  case 4866:                      return "S7Online: CP-Name nicht konfiguriert";                  case 4867:                      return "S7Online: Kanalname nicht vorhanden";                  case 4868:                      return "S7Online: Kanalname nicht konfiguriert";              }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,daveStrS7onlineError,The following statement contains a magic number: switch (err)              {                  case 202:                      return "S7Online: Ressourcenengpaß im Treiber oder in der Library";                  case 203:                      return "S7Online: Konfigurationsfehler";                  case 205:                      return "S7Online: Auftrag zur Zeit nicht erlaubt";                  case 206:                      return "S7Online: Parameterfehler";                  case 207:                      return "S7Online: Gerät bereits/noch nicht geöffnet.";                  case 208:                      return "S7Online: CP reagiert nicht";                  case 209:                      return "S7Online: Fehler in der Firmware";                  case 210:                      return "S7Online: Speicherengpaß im Treiber";                  case 215:                      return "S7Online: Keine Nachricht vorhanden";                  case 216:                      return "S7Online: Fehler bei Zugriff auf Anwendungspuffer";                  case 219:                      return "S7Online: Timeout abgelaufen";                  case 225:                      return "S7Online: Die maximale Anzahl an Anmeldungen ist überschritten";                  case 226:                      return "S7Online: Der Auftrag wurde abgebrochen";                  case 233:                      return "S7Online: Ein Hilfsprogramm konnte nicht gestartet werden";                  case 234:                      return "S7Online: Keine Autorisierung für diese Funktion vorhanden";                  case 304:                      return "S7Online: Initialisierung noch nicht abgeschlossen";                  case 305:                      return "S7Online: Funktion nicht implementiert";                  case 4865:                      return "S7Online: CP-Name nicht vorhanden";                  case 4866:                      return "S7Online: CP-Name nicht konfiguriert";                  case 4867:                      return "S7Online: Kanalname nicht vorhanden";                  case 4868:                      return "S7Online: Kanalname nicht konfiguriert";              }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,daveSetDebug,The following statement contains a magic number: IntPtr.Size == 8
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,daveGetDebug,The following statement contains a magic number: IntPtr.Size == 8
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,setPort,The following statement contains a magic number: IntPtr.Size == 8
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,openSocket,The following statement contains a magic number: IntPtr.Size == 8
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,closePort,The following statement contains a magic number: IntPtr.Size == 8
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,closeSocket,The following statement contains a magic number: IntPtr.Size == 8
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getS8from,The following statement contains a magic number: return Convert.ToSByte((256 - b[pos]) * -1);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getS8from,The following statement contains a magic number: b[pos] > 127
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getS16from,The following statement contains a magic number: byte[] b1 = new byte[2];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getU16from,The following statement contains a magic number: byte[] b1 = new byte[2];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getS32from,The following statement contains a magic number: byte[] b1 = new byte[4];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getS32from,The following statement contains a magic number: b1[3] = b[pos];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getS32from,The following statement contains a magic number: b1[2] = b[pos + 1];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getS32from,The following statement contains a magic number: b1[1] = b[pos + 2];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getS32from,The following statement contains a magic number: b1[0] = b[pos + 3];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getS64from,The following statement contains a magic number: byte[] b1 = new byte[8];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getS64from,The following statement contains a magic number: b1[7] = b[pos];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getS64from,The following statement contains a magic number: b1[6] = b[pos + 1];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getS64from,The following statement contains a magic number: b1[5] = b[pos + 2];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getS64from,The following statement contains a magic number: b1[5] = b[pos + 2];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getS64from,The following statement contains a magic number: b1[4] = b[pos + 3];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getS64from,The following statement contains a magic number: b1[4] = b[pos + 3];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getS64from,The following statement contains a magic number: b1[3] = b[pos + 4];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getS64from,The following statement contains a magic number: b1[3] = b[pos + 4];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getS64from,The following statement contains a magic number: b1[2] = b[pos + 5];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getS64from,The following statement contains a magic number: b1[2] = b[pos + 5];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getS64from,The following statement contains a magic number: b1[1] = b[pos + 6];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getS64from,The following statement contains a magic number: b1[0] = b[pos + 7];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putS32at,The following statement contains a magic number: b[pos + 3] = bytes[0];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putS32at,The following statement contains a magic number: b[pos + 2] = bytes[1];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putS32at,The following statement contains a magic number: b[pos + 1] = bytes[2];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putS32at,The following statement contains a magic number: b[pos] = bytes[3];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putS64at,The following statement contains a magic number: b[pos + 7] = bytes[0];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putS64at,The following statement contains a magic number: b[pos + 6] = bytes[1];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putS64at,The following statement contains a magic number: b[pos + 5] = bytes[2];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putS64at,The following statement contains a magic number: b[pos + 5] = bytes[2];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putS64at,The following statement contains a magic number: b[pos + 4] = bytes[3];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putS64at,The following statement contains a magic number: b[pos + 4] = bytes[3];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putS64at,The following statement contains a magic number: b[pos + 3] = bytes[4];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putS64at,The following statement contains a magic number: b[pos + 3] = bytes[4];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putS64at,The following statement contains a magic number: b[pos + 2] = bytes[5];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putS64at,The following statement contains a magic number: b[pos + 2] = bytes[5];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putS64at,The following statement contains a magic number: b[pos + 1] = bytes[6];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putS64at,The following statement contains a magic number: b[pos] = bytes[7];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getU32from,The following statement contains a magic number: byte[] b1 = new byte[4];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getU32from,The following statement contains a magic number: b1[3] = b[pos];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getU32from,The following statement contains a magic number: b1[2] = b[pos + 1];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getU32from,The following statement contains a magic number: b1[1] = b[pos + 2];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getU32from,The following statement contains a magic number: b1[0] = b[pos + 3];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getU64from,The following statement contains a magic number: byte[] b1 = new byte[8];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getU64from,The following statement contains a magic number: b1[7] = b[pos];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getU64from,The following statement contains a magic number: b1[6] = b[pos + 1];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getU64from,The following statement contains a magic number: b1[5] = b[pos + 2];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getU64from,The following statement contains a magic number: b1[5] = b[pos + 2];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getU64from,The following statement contains a magic number: b1[4] = b[pos + 3];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getU64from,The following statement contains a magic number: b1[4] = b[pos + 3];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getU64from,The following statement contains a magic number: b1[3] = b[pos + 4];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getU64from,The following statement contains a magic number: b1[3] = b[pos + 4];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getU64from,The following statement contains a magic number: b1[2] = b[pos + 5];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getU64from,The following statement contains a magic number: b1[2] = b[pos + 5];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getU64from,The following statement contains a magic number: b1[1] = b[pos + 6];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getU64from,The following statement contains a magic number: b1[0] = b[pos + 7];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putU32at,The following statement contains a magic number: b[pos + 3] = bytes[0];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putU32at,The following statement contains a magic number: b[pos + 2] = bytes[1];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putU32at,The following statement contains a magic number: b[pos + 1] = bytes[2];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putU32at,The following statement contains a magic number: b[pos] = bytes[3];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putU64at,The following statement contains a magic number: b[pos + 7] = bytes[0];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putU64at,The following statement contains a magic number: b[pos + 6] = bytes[1];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putU64at,The following statement contains a magic number: b[pos + 5] = bytes[2];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putU64at,The following statement contains a magic number: b[pos + 5] = bytes[2];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putU64at,The following statement contains a magic number: b[pos + 4] = bytes[3];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putU64at,The following statement contains a magic number: b[pos + 4] = bytes[3];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putU64at,The following statement contains a magic number: b[pos + 3] = bytes[4];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putU64at,The following statement contains a magic number: b[pos + 3] = bytes[4];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putU64at,The following statement contains a magic number: b[pos + 2] = bytes[5];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putU64at,The following statement contains a magic number: b[pos + 2] = bytes[5];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putU64at,The following statement contains a magic number: b[pos + 1] = bytes[6];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putU64at,The following statement contains a magic number: b[pos] = bytes[7];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putDateTimeat,The following statement contains a magic number: tmp = mydatetime.Year / 100;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putDateTimeat,The following statement contains a magic number: tmp = tmp * 100;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putDateTimeat,The following statement contains a magic number: b[pos] = Convert.ToByte((tmp / 10) << 4 | tmp % 10);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putDateTimeat,The following statement contains a magic number: b[pos] = Convert.ToByte((tmp / 10) << 4 | tmp % 10);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putDateTimeat,The following statement contains a magic number: b[pos] = Convert.ToByte((tmp / 10) << 4 | tmp % 10);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putDateTimeat,The following statement contains a magic number: b[pos + 1] = Convert.ToByte((tmp / 10) << 4 | tmp % 10);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putDateTimeat,The following statement contains a magic number: b[pos + 1] = Convert.ToByte((tmp / 10) << 4 | tmp % 10);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putDateTimeat,The following statement contains a magic number: b[pos + 1] = Convert.ToByte((tmp / 10) << 4 | tmp % 10);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putDateTimeat,The following statement contains a magic number: b[pos + 2] = Convert.ToByte((tmp / 10) << 4 | tmp % 10);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putDateTimeat,The following statement contains a magic number: b[pos + 2] = Convert.ToByte((tmp / 10) << 4 | tmp % 10);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putDateTimeat,The following statement contains a magic number: b[pos + 2] = Convert.ToByte((tmp / 10) << 4 | tmp % 10);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putDateTimeat,The following statement contains a magic number: b[pos + 2] = Convert.ToByte((tmp / 10) << 4 | tmp % 10);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putDateTimeat,The following statement contains a magic number: b[pos + 3] = Convert.ToByte((tmp / 10) << 4 | tmp % 10);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putDateTimeat,The following statement contains a magic number: b[pos + 3] = Convert.ToByte((tmp / 10) << 4 | tmp % 10);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putDateTimeat,The following statement contains a magic number: b[pos + 3] = Convert.ToByte((tmp / 10) << 4 | tmp % 10);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putDateTimeat,The following statement contains a magic number: b[pos + 3] = Convert.ToByte((tmp / 10) << 4 | tmp % 10);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putDateTimeat,The following statement contains a magic number: b[pos + 4] = Convert.ToByte((tmp / 10) << 4 | tmp % 10);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putDateTimeat,The following statement contains a magic number: b[pos + 4] = Convert.ToByte((tmp / 10) << 4 | tmp % 10);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putDateTimeat,The following statement contains a magic number: b[pos + 4] = Convert.ToByte((tmp / 10) << 4 | tmp % 10);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putDateTimeat,The following statement contains a magic number: b[pos + 4] = Convert.ToByte((tmp / 10) << 4 | tmp % 10);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putDateTimeat,The following statement contains a magic number: b[pos + 5] = Convert.ToByte((tmp / 10) << 4 | tmp % 10);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putDateTimeat,The following statement contains a magic number: b[pos + 5] = Convert.ToByte((tmp / 10) << 4 | tmp % 10);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putDateTimeat,The following statement contains a magic number: b[pos + 5] = Convert.ToByte((tmp / 10) << 4 | tmp % 10);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putDateTimeat,The following statement contains a magic number: b[pos + 5] = Convert.ToByte((tmp / 10) << 4 | tmp % 10);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putDateTimeat,The following statement contains a magic number: b[pos + 6] = Convert.ToByte((tmp / 10) << 4 | tmp % 10);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putDateTimeat,The following statement contains a magic number: b[pos + 6] = Convert.ToByte((tmp / 10) << 4 | tmp % 10);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putDateTimeat,The following statement contains a magic number: b[pos + 6] = Convert.ToByte((tmp / 10) << 4 | tmp % 10);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putDateTimeat,The following statement contains a magic number: b[pos + 6] = Convert.ToByte((tmp / 10) << 4 | tmp % 10);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putDateTimeat,The following statement contains a magic number: tmp = tmp / 10;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putDateTimeat,The following statement contains a magic number: var rem = mydatetime.Millisecond % 10;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putDateTimeat,The following statement contains a magic number: b[pos + 6] = Convert.ToByte((tmp / 10) << 4 | tmp % 10);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putDateTimeat,The following statement contains a magic number: b[pos + 6] = Convert.ToByte((tmp / 10) << 4 | tmp % 10);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putDateTimeat,The following statement contains a magic number: b[pos + 6] = Convert.ToByte((tmp / 10) << 4 | tmp % 10);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putDateTimeat,The following statement contains a magic number: b[pos + 6] = Convert.ToByte((tmp / 10) << 4 | tmp % 10);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putDateTimeat,The following statement contains a magic number: b[pos + 7] = Convert.ToByte((rem) << 4 | tmp % 10);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putDateTimeat,The following statement contains a magic number: b[pos + 7] = Convert.ToByte((rem) << 4 | tmp % 10);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putDateTimeat,The following statement contains a magic number: b[pos + 7] = Convert.ToByte((rem) << 4 | tmp % 10);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putS5Timeat,The following statement contains a magic number: wert = Convert.ToInt32(value.TotalMilliseconds) / 10;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putS5Timeat,The following statement contains a magic number: value.TotalMilliseconds <= 999 * 10
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putS5Timeat,The following statement contains a magic number: value.TotalMilliseconds <= 999 * 10
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putS5Timeat,The following statement contains a magic number: p3 = (wert / 100);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putS5Timeat,The following statement contains a magic number: p2 = ((wert - p3 * 100) / 10);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putS5Timeat,The following statement contains a magic number: p2 = ((wert - p3 * 100) / 10);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putS5Timeat,The following statement contains a magic number: p1 = (wert - p3 * 100 - p2 * 10);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putS5Timeat,The following statement contains a magic number: p1 = (wert - p3 * 100 - p2 * 10);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putS5Timeat,The following statement contains a magic number: b[pos] = Convert.ToByte(basis << 4 | p3);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putS5Timeat,The following statement contains a magic number: b[pos + 1] = Convert.ToByte((p2 << 4 | p1));
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putLTimeat,The following statement contains a magic number: putS64at(b' pos' Convert.ToInt64(value.Ticks * 100));
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putLTimeOfDayat,The following statement contains a magic number: putU64at(b' pos' Convert.ToUInt64(value.Ticks * 100));
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putDateat,The following statement contains a magic number: DateTime tmp = new DateTime(1990' 1' 1);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getDatefrom,The following statement contains a magic number: DateTime tmp = new DateTime(1990' 1' 1);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getS5Floatfrom,The following statement contains a magic number: byte[] b1 = new byte[4];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getS5Floatfrom,The following statement contains a magic number: b1[3] = 0;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getS5Floatfrom,The following statement contains a magic number: b1[2] = (byte)(b[pos + 1] & 0x7f);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getS5Floatfrom,The following statement contains a magic number: b1[1] = (byte)(b[pos + 2]);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getS5Floatfrom,The following statement contains a magic number: b1[0] = (byte)(b[pos + 3]);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getS5Floatfrom,The following statement contains a magic number: long mantissa = b1[2] * 256 * 256 + b1[1] * 256 + b1[0];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getS5Floatfrom,The following statement contains a magic number: long mantissa = b1[2] * 256 * 256 + b1[1] * 256 + b1[0];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getS5Floatfrom,The following statement contains a magic number: long mantissa = b1[2] * 256 * 256 + b1[1] * 256 + b1[0];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getS5Floatfrom,The following statement contains a magic number: long mantissa = b1[2] * 256 * 256 + b1[1] * 256 + b1[0];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getS5Floatfrom,The following statement contains a magic number: wrt = wrt * 2.0f;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getS5Floatfrom,The following statement contains a magic number: exp > 23
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getS5Floatfrom,The following statement contains a magic number: wrt = wrt / 2.0f;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getS5Floatfrom,The following statement contains a magic number: exp < 23
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getFloatfrom,The following statement contains a magic number: byte[] b1 = new byte[4];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getFloatfrom,The following statement contains a magic number: b1[3] = b[pos];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getFloatfrom,The following statement contains a magic number: b1[2] = b[pos + 1];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getFloatfrom,The following statement contains a magic number: b1[1] = b[pos + 2];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getFloatfrom,The following statement contains a magic number: b1[0] = b[pos + 3];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getDoublefrom,The following statement contains a magic number: byte[] b1 = new byte[8];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getDoublefrom,The following statement contains a magic number: b1[7] = b[pos];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getDoublefrom,The following statement contains a magic number: b1[6] = b[pos + 1];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getDoublefrom,The following statement contains a magic number: b1[5] = b[pos + 2];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getDoublefrom,The following statement contains a magic number: b1[5] = b[pos + 2];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getDoublefrom,The following statement contains a magic number: b1[4] = b[pos + 3];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getDoublefrom,The following statement contains a magic number: b1[4] = b[pos + 3];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getDoublefrom,The following statement contains a magic number: b1[3] = b[pos + 4];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getDoublefrom,The following statement contains a magic number: b1[3] = b[pos + 4];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getDoublefrom,The following statement contains a magic number: b1[2] = b[pos + 5];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getDoublefrom,The following statement contains a magic number: b1[2] = b[pos + 5];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getDoublefrom,The following statement contains a magic number: b1[1] = b[pos + 6];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getDoublefrom,The following statement contains a magic number: b1[0] = b[pos + 7];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putS7Stringat,The following statement contains a magic number: Array.Copy(Encoding.GetEncoding(System.Globalization.CultureInfo.CurrentCulture.TextInfo.ANSICodePage).GetBytes(value)' 0' b' pos + 2' value.Length > length ? length : value.Length);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putFloatat,The following statement contains a magic number: b[pos + 3] = bytes[0];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putFloatat,The following statement contains a magic number: b[pos + 2] = bytes[1];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putFloatat,The following statement contains a magic number: b[pos + 1] = bytes[2];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putFloatat,The following statement contains a magic number: b[pos] = bytes[3];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putDoubleat,The following statement contains a magic number: b[pos + 7] = bytes[0];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putDoubleat,The following statement contains a magic number: b[pos + 6] = bytes[1];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putDoubleat,The following statement contains a magic number: b[pos + 5] = bytes[2];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putDoubleat,The following statement contains a magic number: b[pos + 5] = bytes[2];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putDoubleat,The following statement contains a magic number: b[pos + 4] = bytes[3];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putDoubleat,The following statement contains a magic number: b[pos + 4] = bytes[3];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putDoubleat,The following statement contains a magic number: b[pos + 3] = bytes[4];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putDoubleat,The following statement contains a magic number: b[pos + 3] = bytes[4];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putDoubleat,The following statement contains a magic number: b[pos + 2] = bytes[5];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putDoubleat,The following statement contains a magic number: b[pos + 2] = bytes[5];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putDoubleat,The following statement contains a magic number: b[pos + 1] = bytes[6];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putDoubleat,The following statement contains a magic number: b[pos] = bytes[7];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putBCD8at,The following statement contains a magic number: b1 = (value % 100 / 10);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putBCD8at,The following statement contains a magic number: b1 = (value % 100 / 10);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putBCD8at,The following statement contains a magic number: b0 = value % 10;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putBCD8at,The following statement contains a magic number: b[pos] = (byte)((b1 << 4) + b0);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putBCD16at,The following statement contains a magic number: b2 = (value % 1000 / 100);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putBCD16at,The following statement contains a magic number: b2 = (value % 1000 / 100);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putBCD16at,The following statement contains a magic number: b1 = (value % 100 / 10);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putBCD16at,The following statement contains a magic number: b1 = (value % 100 / 10);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putBCD16at,The following statement contains a magic number: b0 = (value % 10);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putBCD16at,The following statement contains a magic number: b[pos] = (byte)((b3 << 4) + b2);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putBCD16at,The following statement contains a magic number: b[pos + 1] = (byte)((b1 << 4) + b0);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putBCD32at,The following statement contains a magic number: b6 = (value % 10000000 / 1000000);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putBCD32at,The following statement contains a magic number: b6 = (value % 10000000 / 1000000);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putBCD32at,The following statement contains a magic number: b5 = (value % 1000000 / 100000);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putBCD32at,The following statement contains a magic number: b5 = (value % 1000000 / 100000);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putBCD32at,The following statement contains a magic number: b4 = (value % 100000 / 10000);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putBCD32at,The following statement contains a magic number: b4 = (value % 100000 / 10000);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putBCD32at,The following statement contains a magic number: b3 = (value % 10000 / 1000);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putBCD32at,The following statement contains a magic number: b3 = (value % 10000 / 1000);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putBCD32at,The following statement contains a magic number: b2 = (value % 1000 / 100);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putBCD32at,The following statement contains a magic number: b2 = (value % 1000 / 100);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putBCD32at,The following statement contains a magic number: b1 = (value % 100 / 10);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putBCD32at,The following statement contains a magic number: b1 = (value % 100 / 10);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putBCD32at,The following statement contains a magic number: b0 = (value % 10);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putBCD32at,The following statement contains a magic number: b[pos] = (byte)((b7 << 4) + b6);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putBCD32at,The following statement contains a magic number: b[pos + 1] = (byte)((b5 << 4) + b4);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putBCD32at,The following statement contains a magic number: b[pos + 2] = (byte)((b3 << 4) + b2);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putBCD32at,The following statement contains a magic number: b[pos + 2] = (byte)((b3 << 4) + b2);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putBCD32at,The following statement contains a magic number: b[pos + 3] = (byte)((b1 << 4) + b0);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putBCD32at,The following statement contains a magic number: b[pos + 3] = (byte)((b1 << 4) + b0);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getBCD16from,The following statement contains a magic number: bt2 = (bt2 / 0x10) * 10 + (bt2 & 0x0f % 0x10);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getBCD16from,The following statement contains a magic number: return neg ? (bt1 * 100 + bt2) * -1 : bt1 * 100 + bt2;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getBCD16from,The following statement contains a magic number: return neg ? (bt1 * 100 + bt2) * -1 : bt1 * 100 + bt2;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getBCD32from,The following statement contains a magic number: int bt3 = b[pos + 2];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getBCD32from,The following statement contains a magic number: int bt4 = b[pos + 3];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getBCD32from,The following statement contains a magic number: bt2 = (bt2 / 0x10) * 10 + (bt2 % 0x10);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getBCD32from,The following statement contains a magic number: bt3 = (bt3 / 0x10) * 10 + (bt3 % 0x10);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getBCD32from,The following statement contains a magic number: bt4 = (bt4 / 0x10) * 10 + (bt4 % 0x10);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getBCD32from,The following statement contains a magic number: return neg ? (bt1 * 1000000 + bt2 * 10000 + bt3 * 100 + bt4) * -1 : bt1 * 1000000 + bt2 * 10000 + bt3 * 100 + bt4;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getBCD32from,The following statement contains a magic number: return neg ? (bt1 * 1000000 + bt2 * 10000 + bt3 * 100 + bt4) * -1 : bt1 * 1000000 + bt2 * 10000 + bt3 * 100 + bt4;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getBCD32from,The following statement contains a magic number: return neg ? (bt1 * 1000000 + bt2 * 10000 + bt3 * 100 + bt4) * -1 : bt1 * 1000000 + bt2 * 10000 + bt3 * 100 + bt4;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getBCD32from,The following statement contains a magic number: return neg ? (bt1 * 1000000 + bt2 * 10000 + bt3 * 100 + bt4) * -1 : bt1 * 1000000 + bt2 * 10000 + bt3 * 100 + bt4;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getBCD32from,The following statement contains a magic number: return neg ? (bt1 * 1000000 + bt2 * 10000 + bt3 * 100 + bt4) * -1 : bt1 * 1000000 + bt2 * 10000 + bt3 * 100 + bt4;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getBCD32from,The following statement contains a magic number: return neg ? (bt1 * 1000000 + bt2 * 10000 + bt3 * 100 + bt4) * -1 : bt1 * 1000000 + bt2 * 10000 + bt3 * 100 + bt4;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getDateTimefrom,The following statement contains a magic number: bt = (((bt >> 4)) * 10) + ((bt & 0x0f));
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getDateTimefrom,The following statement contains a magic number: bt = (((bt >> 4)) * 10) + ((bt & 0x0f));
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getDateTimefrom,The following statement contains a magic number: jahr = 2000;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getDateTimefrom,The following statement contains a magic number: bt < 90
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getDateTimefrom,The following statement contains a magic number: monat = (((bt >> 4)) * 10) + ((bt & 0x0f));
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getDateTimefrom,The following statement contains a magic number: monat = (((bt >> 4)) * 10) + ((bt & 0x0f));
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getDateTimefrom,The following statement contains a magic number: bt = b[pos + 2];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getDateTimefrom,The following statement contains a magic number: tag = (((bt >> 4)) * 10) + ((bt & 0x0f));
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getDateTimefrom,The following statement contains a magic number: tag = (((bt >> 4)) * 10) + ((bt & 0x0f));
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getDateTimefrom,The following statement contains a magic number: bt = b[pos + 3];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getDateTimefrom,The following statement contains a magic number: stunde = (((bt >> 4)) * 10) + ((bt & 0x0f));
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getDateTimefrom,The following statement contains a magic number: stunde = (((bt >> 4)) * 10) + ((bt & 0x0f));
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getDateTimefrom,The following statement contains a magic number: bt = b[pos + 4];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getDateTimefrom,The following statement contains a magic number: minute = (((bt >> 4)) * 10) + ((bt & 0x0f));
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getDateTimefrom,The following statement contains a magic number: minute = (((bt >> 4)) * 10) + ((bt & 0x0f));
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getDateTimefrom,The following statement contains a magic number: bt = b[pos + 5];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getDateTimefrom,The following statement contains a magic number: sekunde = (((bt >> 4)) * 10) + ((bt & 0x0f));
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getDateTimefrom,The following statement contains a magic number: sekunde = (((bt >> 4)) * 10) + ((bt & 0x0f));
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getDateTimefrom,The following statement contains a magic number: bt = b[pos + 6];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getDateTimefrom,The following statement contains a magic number: int bt1 = b[pos + 7];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getDateTimefrom,The following statement contains a magic number: mili = (((bt >> 4)) * 10) + ((bt & 0x0f));
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getDateTimefrom,The following statement contains a magic number: mili = (((bt >> 4)) * 10) + ((bt & 0x0f));
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getDateTimefrom,The following statement contains a magic number: mili = mili * 10 + (bt1 >> 4);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getDateTimefrom,The following statement contains a magic number: mili = mili * 10 + (bt1 >> 4);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getTimeOfDayfrom,The following statement contains a magic number: return new DateTime(msval * 10000);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getLTimeOfDayfrom,The following statement contains a magic number: return new DateTime((long)msval / 100);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getTimefrom,The following statement contains a magic number: return new TimeSpan(msval * 10000);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getLTimefrom,The following statement contains a magic number: return new TimeSpan(msval / 100);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getS5Timefrom,The following statement contains a magic number: long zahl = w2 * 100 + w1;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getS5Timefrom,The following statement contains a magic number: int basis = (b[pos] >> 4) & 0x03;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getS5Timefrom,The following statement contains a magic number: switch (basis)              {                  case 0:                      zahl = zahl * 100000;                      break;                  case 1:                      zahl = zahl * 1000000;                      break;                  case 2:                      zahl = zahl * 10000000;                      break;                  case 3:                      zahl = zahl * 100000000;                      break;                }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getS5Timefrom,The following statement contains a magic number: switch (basis)              {                  case 0:                      zahl = zahl * 100000;                      break;                  case 1:                      zahl = zahl * 1000000;                      break;                  case 2:                      zahl = zahl * 10000000;                      break;                  case 3:                      zahl = zahl * 100000000;                      break;                }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getS5Timefrom,The following statement contains a magic number: switch (basis)              {                  case 0:                      zahl = zahl * 100000;                      break;                  case 1:                      zahl = zahl * 1000000;                      break;                  case 2:                      zahl = zahl * 10000000;                      break;                  case 3:                      zahl = zahl * 100000000;                      break;                }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getS5Timefrom,The following statement contains a magic number: switch (basis)              {                  case 0:                      zahl = zahl * 100000;                      break;                  case 1:                      zahl = zahl * 1000000;                      break;                  case 2:                      zahl = zahl * 10000000;                      break;                  case 3:                      zahl = zahl * 100000000;                      break;                }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getS5Timefrom,The following statement contains a magic number: switch (basis)              {                  case 0:                      zahl = zahl * 100000;                      break;                  case 1:                      zahl = zahl * 1000000;                      break;                  case 2:                      zahl = zahl * 10000000;                      break;                  case 3:                      zahl = zahl * 100000000;                      break;                }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getS5Timefrom,The following statement contains a magic number: switch (basis)              {                  case 0:                      zahl = zahl * 100000;                      break;                  case 1:                      zahl = zahl * 1000000;                      break;                  case 2:                      zahl = zahl * 10000000;                      break;                  case 3:                      zahl = zahl * 100000000;                      break;                }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getBit,The following statement contains a magic number: int wrt = System.Convert.ToInt32(System.Math.Pow(2' Bit));
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,dec2bin,The following statement contains a magic number: byte[] bitwert = { 128' 64' 32' 16' 8' 4' 2' 1 };
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,dec2bin,The following statement contains a magic number: byte[] bitwert = { 128' 64' 32' 16' 8' 4' 2' 1 };
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,dec2bin,The following statement contains a magic number: byte[] bitwert = { 128' 64' 32' 16' 8' 4' 2' 1 };
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,dec2bin,The following statement contains a magic number: byte[] bitwert = { 128' 64' 32' 16' 8' 4' 2' 1 };
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,dec2bin,The following statement contains a magic number: byte[] bitwert = { 128' 64' 32' 16' 8' 4' 2' 1 };
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,dec2bin,The following statement contains a magic number: byte[] bitwert = { 128' 64' 32' 16' 8' 4' 2' 1 };
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,dec2bin,The following statement contains a magic number: byte[] bitwert = { 128' 64' 32' 16' 8' 4' 2' 1 };
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,dec2bin,The following statement contains a magic number: byte[] bits = new byte[8];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,dec2bin,The following statement contains a magic number: Counter < 8
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,daveInterface,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,daveInterface,The following statement contains a magic number: IntPtr.Size == 8
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,daveInterface,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,initAdapter,The following statement contains a magic number: IntPtr.Size == 8
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,daveInterface,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,listReachablePartners,The following statement contains a magic number: IntPtr.Size == 8
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,daveInterface,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,setTimeout,The following statement contains a magic number: IntPtr.Size == 8
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,daveInterface,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getTimeout,The following statement contains a magic number: IntPtr.Size == 8
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,daveInterface,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,disconnectAdapter,The following statement contains a magic number: IntPtr.Size == 8
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,daveInterface,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getName,The following statement contains a magic number: IntPtr.Size == 8
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,daveConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,daveConnection,The following statement contains a magic number: IntPtr.Size == 8
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,daveConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,daveConnection,The following statement contains a magic number: ip.Length < 4 || !DestinationIsIP
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,daveConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,daveConnection,The following statement contains a magic number: byte[] myRoutingDestination = new byte[4];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,daveConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,daveConnection,The following statement contains a magic number: ip.Length < 4 && !string.IsNullOrEmpty(routingDestination)
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,daveConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,daveConnection,The following statement contains a magic number: IntPtr.Size == 8
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,daveConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,connectPLC,The following statement contains a magic number: IntPtr.Size == 8
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,daveConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,disconnectPLC,The following statement contains a magic number: IntPtr.Size == 8
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,daveConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,readBytes,The following statement contains a magic number: IntPtr.Size == 8
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,daveConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,readManyBytes,The following statement contains a magic number: readLen = pdulen - 18;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,daveConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,readManyBytes,The following statement contains a magic number: len > pdulen - 18
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,daveConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,readBits,The following statement contains a magic number: IntPtr.Size == 8
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,daveConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,writeBytes,The following statement contains a magic number: IntPtr.Size == 8
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,daveConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,writeManyBytes,The following statement contains a magic number: IntPtr.Size == 8
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,daveConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,writeBits,The following statement contains a magic number: IntPtr.Size == 8
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,daveConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,daveBuildAndSendPDU,The following statement contains a magic number: IntPtr.Size == 8
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,daveConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getU8,The following statement contains a magic number: IntPtr.Size == 8
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,daveConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getAnswLen,The following statement contains a magic number: IntPtr.Size == 8
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,daveConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getMaxPDULen,The following statement contains a magic number: IntPtr.Size == 8
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,daveConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,prepareReadRequest,The following statement contains a magic number: IntPtr.Size == 8
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,daveConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,prepareWriteRequest,The following statement contains a magic number: IntPtr.Size == 8
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,daveConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,execReadRequest,The following statement contains a magic number: IntPtr.Size == 8
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,daveConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,execWriteRequest,The following statement contains a magic number: IntPtr.Size == 8
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,daveConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,useResult,The following statement contains a magic number: IntPtr.Size == 8
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,daveConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,useResultBuffer,The following statement contains a magic number: IntPtr.Size == 8
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,daveConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,readSZL,The following statement contains a magic number: IntPtr.Size == 8
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,daveConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,start,The following statement contains a magic number: IntPtr.Size == 8
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,daveConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,stop,The following statement contains a magic number: IntPtr.Size == 8
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,daveConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,force200,The following statement contains a magic number: IntPtr.Size == 8
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,daveConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,forceDisconnectIBH,The following statement contains a magic number: IntPtr.Size == 8
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,daveConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,resetIBH,The following statement contains a magic number: IntPtr.Size == 8
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,daveConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getGetResponse,The following statement contains a magic number: IntPtr.Size == 8
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,daveConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getMessage,The following statement contains a magic number: IntPtr.Size == 8
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,daveConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getProgramBlock,The following statement contains a magic number: IntPtr.Size == 8
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,daveConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,putProgramBlock,The following statement contains a magic number: IntPtr.Size == 8
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,daveConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,deleteProgramBlock,The following statement contains a magic number: IntPtr.Size == 8
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,daveConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,ListBlocksOfType,The following statement contains a magic number: IntPtr.Size == 8
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,daveConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,daveSetPLCTime,The following statement contains a magic number: putBCD8at(buffer' 2' tm.Year % 100);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,daveConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,daveSetPLCTime,The following statement contains a magic number: putBCD8at(buffer' 2' tm.Year % 100);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,daveConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,daveSetPLCTime,The following statement contains a magic number: putBCD8at(buffer' 3' tm.Month);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,daveConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,daveSetPLCTime,The following statement contains a magic number: putBCD8at(buffer' 4' tm.Day);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,daveConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,daveSetPLCTime,The following statement contains a magic number: putBCD8at(buffer' 5' tm.Hour);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,daveConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,daveSetPLCTime,The following statement contains a magic number: putBCD8at(buffer' 6' tm.Minute);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,daveConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,daveSetPLCTime,The following statement contains a magic number: putBCD8at(buffer' 7' tm.Second);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,daveConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,daveSetPLCTime,The following statement contains a magic number: putBCD8at(buffer' 8' tm.Millisecond / 10);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,daveConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,daveSetPLCTime,The following statement contains a magic number: putBCD8at(buffer' 8' tm.Millisecond / 10);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,daveConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,daveSetPLCTime,The following statement contains a magic number: putBCD8at(buffer' 9' (tm.Millisecond % 10) << 4);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,daveConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,daveSetPLCTime,The following statement contains a magic number: putBCD8at(buffer' 9' (tm.Millisecond % 10) << 4);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,daveConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,daveSetPLCTime,The following statement contains a magic number: putBCD8at(buffer' 9' (tm.Millisecond % 10) << 4);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,daveConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,daveSetPLCTime,The following statement contains a magic number: IntPtr.Size == 8
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,daveConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,daveReadPLCTime,The following statement contains a magic number: IntPtr.Size == 8
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,daveConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,daveReadPLCTime,The following statement contains a magic number: year += year >= 90 ? 1900 : 2000;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,daveConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,daveReadPLCTime,The following statement contains a magic number: year += year >= 90 ? 1900 : 2000;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,daveConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,daveReadPLCTime,The following statement contains a magic number: year += year >= 90 ? 1900 : 2000;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,daveConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,daveReadPLCTime,The following statement contains a magic number: millisecond = getBCD8from(tmp' 0) * 10;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,daveConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,daveReadPLCTime,The following statement contains a magic number: tmp[0] = Convert.ToByte(tmp[0] >> 4);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,daveConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,daveGetPDUData,The following statement contains a magic number: byte[] tmp1 = new byte[65536];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,daveConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,daveGetPDUData,The following statement contains a magic number: byte[] tmp2 = new byte[65536];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,daveConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,daveGetPDUData,The following statement contains a magic number: IntPtr.Size == 8
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,daveConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,daveRecieveData,The following statement contains a magic number: IntPtr.Size == 8
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,daveConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,daveRecieveData,The following statement contains a magic number: IntPtr.Size == 8
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,daveConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,daveRecieveData,The following statement contains a magic number: byte[] tmp1 = new byte[65536];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,daveConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,daveRecieveData,The following statement contains a magic number: byte[] tmp2 = new byte[65536];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,daveConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,daveRecieveData,The following statement contains a magic number: IntPtr.Size == 8
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,daveConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,PI_StartNC,The following statement contains a magic number: IntPtr.Size == 8
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,daveConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,daveGetNCProgram,The following statement contains a magic number: IntPtr.Size == 8
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,daveConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,daveGetNcFile,The following statement contains a magic number: IntPtr.Size == 8
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,daveConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,daveGetNcFileSize,The following statement contains a magic number: IntPtr.Size == 8
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,daveConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,davePutNCProgram,The following statement contains a magic number: IntPtr.Size == 8
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,daveConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,initUploadNC,The following statement contains a magic number: IntPtr.Size == 8
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,daveConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,doUploadNC,The following statement contains a magic number: IntPtr.Size == 8
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,daveConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,endUploadNC,The following statement contains a magic number: IntPtr.Size == 8
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,daveConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,alarmQueryAlarm_S,The following statement contains a magic number: IntPtr.Size == 8
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,PDU,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,PDU,The following statement contains a magic number: IntPtr.Size == 8
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,PDU,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,addVarToReadRequest,The following statement contains a magic number: IntPtr.Size == 8
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,PDU,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,addNCKToReadRequest,The following statement contains a magic number: IntPtr.Size == 8
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,PDU,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,addNCKToWriteRequest,The following statement contains a magic number: IntPtr.Size == 8
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,PDU,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,addSymbolVarToReadRequest,The following statement contains a magic number: IntPtr.Size == 8
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,PDU,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,daveAddFillByteToReadRequest,The following statement contains a magic number: IntPtr.Size == 8
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,PDU,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,addDbRead400ToReadRequest,The following statement contains a magic number: IntPtr.Size == 8
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,PDU,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,addBitVarToReadRequest,The following statement contains a magic number: IntPtr.Size == 8
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,PDU,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,addVarToWriteRequest,The following statement contains a magic number: IntPtr.Size == 8
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,PDU,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,addBitVarToWriteRequest,The following statement contains a magic number: IntPtr.Size == 8
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,resultSet,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,resultSet,The following statement contains a magic number: IntPtr.Size == 8
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,resultSet,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getErrorOfResult,The following statement contains a magic number: IntPtr.Size == 8
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,getS8from,The following statement contains a magic number: return Convert.ToSByte((256 - b[pos])*-1);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,getS8from,The following statement contains a magic number: b[pos] > 127
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,getS16from,The following statement contains a magic number: byte[] b1 = new byte[2];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,getU16from,The following statement contains a magic number: byte[] b1 = new byte[2];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,getS32from,The following statement contains a magic number: byte[] b1 = new byte[4];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,getS32from,The following statement contains a magic number: b1[3] = b[pos];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,getS32from,The following statement contains a magic number: b1[2] = b[pos + 1];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,getS32from,The following statement contains a magic number: b1[1] = b[pos + 2];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,getS32from,The following statement contains a magic number: b1[0] = b[pos + 3];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,putS32at,The following statement contains a magic number: b[pos + 3] = bytes[0];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,putS32at,The following statement contains a magic number: b[pos + 2] = bytes[1];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,putS32at,The following statement contains a magic number: b[pos + 1] = bytes[2];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,putS32at,The following statement contains a magic number: b[pos] = bytes[3];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,getU32from,The following statement contains a magic number: byte[] b1 = new byte[4];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,getU32from,The following statement contains a magic number: b1[3] = b[pos];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,getU32from,The following statement contains a magic number: b1[2] = b[pos + 1];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,getU32from,The following statement contains a magic number: b1[1] = b[pos + 2];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,getU32from,The following statement contains a magic number: b1[0] = b[pos + 3];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,putU32at,The following statement contains a magic number: b[pos + 3] = bytes[0];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,putU32at,The following statement contains a magic number: b[pos + 2] = bytes[1];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,putU32at,The following statement contains a magic number: b[pos + 1] = bytes[2];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,putU32at,The following statement contains a magic number: b[pos] = bytes[3];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,putDateTimeat,The following statement contains a magic number: tmp = mydatetime.Year/100;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,putDateTimeat,The following statement contains a magic number: tmp = tmp*100;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,putDateTimeat,The following statement contains a magic number: b[pos] = Convert.ToByte((tmp/10) << 4 | tmp%10);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,putDateTimeat,The following statement contains a magic number: b[pos] = Convert.ToByte((tmp/10) << 4 | tmp%10);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,putDateTimeat,The following statement contains a magic number: b[pos] = Convert.ToByte((tmp/10) << 4 | tmp%10);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,putDateTimeat,The following statement contains a magic number: b[pos + 1] = Convert.ToByte((tmp/10) << 4 | tmp%10);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,putDateTimeat,The following statement contains a magic number: b[pos + 1] = Convert.ToByte((tmp/10) << 4 | tmp%10);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,putDateTimeat,The following statement contains a magic number: b[pos + 1] = Convert.ToByte((tmp/10) << 4 | tmp%10);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,putDateTimeat,The following statement contains a magic number: b[pos + 2] = Convert.ToByte((tmp/10) << 4 | tmp%10);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,putDateTimeat,The following statement contains a magic number: b[pos + 2] = Convert.ToByte((tmp/10) << 4 | tmp%10);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,putDateTimeat,The following statement contains a magic number: b[pos + 2] = Convert.ToByte((tmp/10) << 4 | tmp%10);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,putDateTimeat,The following statement contains a magic number: b[pos + 2] = Convert.ToByte((tmp/10) << 4 | tmp%10);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,putDateTimeat,The following statement contains a magic number: b[pos + 3] = Convert.ToByte((tmp/10) << 4 | tmp%10);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,putDateTimeat,The following statement contains a magic number: b[pos + 3] = Convert.ToByte((tmp/10) << 4 | tmp%10);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,putDateTimeat,The following statement contains a magic number: b[pos + 3] = Convert.ToByte((tmp/10) << 4 | tmp%10);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,putDateTimeat,The following statement contains a magic number: b[pos + 3] = Convert.ToByte((tmp/10) << 4 | tmp%10);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,putDateTimeat,The following statement contains a magic number: b[pos + 4] = Convert.ToByte((tmp/10) << 4 | tmp%10);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,putDateTimeat,The following statement contains a magic number: b[pos + 4] = Convert.ToByte((tmp/10) << 4 | tmp%10);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,putDateTimeat,The following statement contains a magic number: b[pos + 4] = Convert.ToByte((tmp/10) << 4 | tmp%10);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,putDateTimeat,The following statement contains a magic number: b[pos + 4] = Convert.ToByte((tmp/10) << 4 | tmp%10);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,putDateTimeat,The following statement contains a magic number: b[pos + 5] = Convert.ToByte((tmp/10) << 4 | tmp%10);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,putDateTimeat,The following statement contains a magic number: b[pos + 5] = Convert.ToByte((tmp/10) << 4 | tmp%10);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,putDateTimeat,The following statement contains a magic number: b[pos + 5] = Convert.ToByte((tmp/10) << 4 | tmp%10);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,putDateTimeat,The following statement contains a magic number: b[pos + 5] = Convert.ToByte((tmp/10) << 4 | tmp%10);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,putDateTimeat,The following statement contains a magic number: b[pos + 6] = Convert.ToByte((tmp/10) << 4 | tmp%10);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,putDateTimeat,The following statement contains a magic number: b[pos + 6] = Convert.ToByte((tmp/10) << 4 | tmp%10);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,putDateTimeat,The following statement contains a magic number: b[pos + 6] = Convert.ToByte((tmp/10) << 4 | tmp%10);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,putDateTimeat,The following statement contains a magic number: b[pos + 6] = Convert.ToByte((tmp/10) << 4 | tmp%10);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,putDateTimeat,The following statement contains a magic number: b[pos + 7] = Convert.ToByte((tmp/10) << 4 | tmp%10);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,putDateTimeat,The following statement contains a magic number: b[pos + 7] = Convert.ToByte((tmp/10) << 4 | tmp%10);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,putDateTimeat,The following statement contains a magic number: b[pos + 7] = Convert.ToByte((tmp/10) << 4 | tmp%10);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,putDateTimeat,The following statement contains a magic number: b[pos + 7] = Convert.ToByte((tmp/10) << 4 | tmp%10);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,putS5Timeat,The following statement contains a magic number: wert = Convert.ToInt32(value.TotalMilliseconds)/10;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,putS5Timeat,The following statement contains a magic number: value.TotalMilliseconds <= 999*10
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,putS5Timeat,The following statement contains a magic number: value.TotalMilliseconds <= 999*10
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,putS5Timeat,The following statement contains a magic number: p3 = (wert/100);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,putS5Timeat,The following statement contains a magic number: p2 = ((wert - p3*100)/10);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,putS5Timeat,The following statement contains a magic number: p2 = ((wert - p3*100)/10);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,putS5Timeat,The following statement contains a magic number: p1 = (wert - p3*100 - p2*10);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,putS5Timeat,The following statement contains a magic number: p1 = (wert - p3*100 - p2*10);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,putS5Timeat,The following statement contains a magic number: b[pos] = Convert.ToByte(basis << 4 | p3);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,putS5Timeat,The following statement contains a magic number: b[pos + 1] = Convert.ToByte((p2 << 4 | p1));
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,putDateat,The following statement contains a magic number: DateTime tmp = new DateTime(1990' 1' 1);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,getDatefrom,The following statement contains a magic number: DateTime tmp = new DateTime(1990' 1' 1);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,getFloatfrom,The following statement contains a magic number: byte[] b1 = new byte[4];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,getFloatfrom,The following statement contains a magic number: b1[3] = b[pos];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,getFloatfrom,The following statement contains a magic number: b1[2] = b[pos + 1];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,getFloatfrom,The following statement contains a magic number: b1[1] = b[pos + 2];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,getFloatfrom,The following statement contains a magic number: b1[0] = b[pos + 3];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,putS7Stringat,The following statement contains a magic number: Array.Copy(Encoding.ASCII.GetBytes(value)' 0' b' pos + 2' value.Length > length ? length : value.Length);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,putFloatat,The following statement contains a magic number: b[pos + 3] = bytes[0];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,putFloatat,The following statement contains a magic number: b[pos + 2] = bytes[1];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,putFloatat,The following statement contains a magic number: b[pos + 1] = bytes[2];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,putFloatat,The following statement contains a magic number: b[pos] = bytes[3];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,putBCD8at,The following statement contains a magic number: b1 = (value%100/10);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,putBCD8at,The following statement contains a magic number: b1 = (value%100/10);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,putBCD8at,The following statement contains a magic number: b0 = value%10;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,putBCD8at,The following statement contains a magic number: b[pos] = (byte) ((b1 << 4) + b0);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,putBCD16at,The following statement contains a magic number: b2 = (value%1000/100);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,putBCD16at,The following statement contains a magic number: b2 = (value%1000/100);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,putBCD16at,The following statement contains a magic number: b1 = (value%100/10);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,putBCD16at,The following statement contains a magic number: b1 = (value%100/10);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,putBCD16at,The following statement contains a magic number: b0 = (value%10);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,putBCD16at,The following statement contains a magic number: b[pos] = (byte) ((b3 << 4) + b2);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,putBCD16at,The following statement contains a magic number: b[pos + 1] = (byte) ((b1 << 4) + b0);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,putBCD32at,The following statement contains a magic number: b6 = (value%10000000/1000000);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,putBCD32at,The following statement contains a magic number: b6 = (value%10000000/1000000);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,putBCD32at,The following statement contains a magic number: b5 = (value%1000000/100000);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,putBCD32at,The following statement contains a magic number: b5 = (value%1000000/100000);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,putBCD32at,The following statement contains a magic number: b4 = (value%100000/10000);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,putBCD32at,The following statement contains a magic number: b4 = (value%100000/10000);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,putBCD32at,The following statement contains a magic number: b3 = (value%10000/1000);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,putBCD32at,The following statement contains a magic number: b3 = (value%10000/1000);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,putBCD32at,The following statement contains a magic number: b2 = (value%1000/100);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,putBCD32at,The following statement contains a magic number: b2 = (value%1000/100);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,putBCD32at,The following statement contains a magic number: b1 = (value%100/10);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,putBCD32at,The following statement contains a magic number: b1 = (value%100/10);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,putBCD32at,The following statement contains a magic number: b0 = (value%10);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,putBCD32at,The following statement contains a magic number: b[pos] = (byte) ((b7 << 4) + b6);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,putBCD32at,The following statement contains a magic number: b[pos + 1] = (byte) ((b5 << 4) + b4);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,putBCD32at,The following statement contains a magic number: b[pos + 2] = (byte) ((b3 << 4) + b2);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,putBCD32at,The following statement contains a magic number: b[pos + 2] = (byte) ((b3 << 4) + b2);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,putBCD32at,The following statement contains a magic number: b[pos + 3] = (byte) ((b1 << 4) + b0);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,putBCD32at,The following statement contains a magic number: b[pos + 3] = (byte) ((b1 << 4) + b0);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,getBCD16from,The following statement contains a magic number: bt2 = (bt2/0x10)*10 + (bt2 & 0x0f%0x10);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,getBCD16from,The following statement contains a magic number: return neg ? (bt1*100 + bt2)*-1 : bt1*100 + bt2;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,getBCD16from,The following statement contains a magic number: return neg ? (bt1*100 + bt2)*-1 : bt1*100 + bt2;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,getBCD32from,The following statement contains a magic number: int bt3 = b[pos + 2];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,getBCD32from,The following statement contains a magic number: int bt4 = b[pos + 3];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,getBCD32from,The following statement contains a magic number: bt2 = (bt2/0x10)*10 + (bt2%0x10);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,getBCD32from,The following statement contains a magic number: bt3 = (bt3/0x10)*10 + (bt3%0x10);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,getBCD32from,The following statement contains a magic number: bt4 = (bt4/0x10)*10 + (bt4%0x10);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,getBCD32from,The following statement contains a magic number: return neg ? (bt1*1000000 + bt2*10000 + bt3*100 + bt4)*-1 : bt1*1000000 + bt2*10000 + bt3*100 + bt4;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,getBCD32from,The following statement contains a magic number: return neg ? (bt1*1000000 + bt2*10000 + bt3*100 + bt4)*-1 : bt1*1000000 + bt2*10000 + bt3*100 + bt4;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,getBCD32from,The following statement contains a magic number: return neg ? (bt1*1000000 + bt2*10000 + bt3*100 + bt4)*-1 : bt1*1000000 + bt2*10000 + bt3*100 + bt4;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,getBCD32from,The following statement contains a magic number: return neg ? (bt1*1000000 + bt2*10000 + bt3*100 + bt4)*-1 : bt1*1000000 + bt2*10000 + bt3*100 + bt4;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,getBCD32from,The following statement contains a magic number: return neg ? (bt1*1000000 + bt2*10000 + bt3*100 + bt4)*-1 : bt1*1000000 + bt2*10000 + bt3*100 + bt4;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,getBCD32from,The following statement contains a magic number: return neg ? (bt1*1000000 + bt2*10000 + bt3*100 + bt4)*-1 : bt1*1000000 + bt2*10000 + bt3*100 + bt4;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,getDateTimefrom,The following statement contains a magic number: bt = (((bt >> 4))*10) + ((bt & 0x0f));
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,getDateTimefrom,The following statement contains a magic number: bt = (((bt >> 4))*10) + ((bt & 0x0f));
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,getDateTimefrom,The following statement contains a magic number: jahr = 2000;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,getDateTimefrom,The following statement contains a magic number: bt < 90
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,getDateTimefrom,The following statement contains a magic number: monat = (((bt >> 4))*10) + ((bt & 0x0f));
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,getDateTimefrom,The following statement contains a magic number: monat = (((bt >> 4))*10) + ((bt & 0x0f));
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,getDateTimefrom,The following statement contains a magic number: bt = b[pos + 2];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,getDateTimefrom,The following statement contains a magic number: tag = (((bt >> 4))*10) + ((bt & 0x0f));
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,getDateTimefrom,The following statement contains a magic number: tag = (((bt >> 4))*10) + ((bt & 0x0f));
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,getDateTimefrom,The following statement contains a magic number: bt = b[pos + 3];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,getDateTimefrom,The following statement contains a magic number: stunde = (((bt >> 4))*10) + ((bt & 0x0f));
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,getDateTimefrom,The following statement contains a magic number: stunde = (((bt >> 4))*10) + ((bt & 0x0f));
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,getDateTimefrom,The following statement contains a magic number: bt = b[pos + 4];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,getDateTimefrom,The following statement contains a magic number: minute = (((bt >> 4))*10) + ((bt & 0x0f));
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,getDateTimefrom,The following statement contains a magic number: minute = (((bt >> 4))*10) + ((bt & 0x0f));
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,getDateTimefrom,The following statement contains a magic number: bt = b[pos + 5];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,getDateTimefrom,The following statement contains a magic number: sekunde = (((bt >> 4))*10) + ((bt & 0x0f));
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,getDateTimefrom,The following statement contains a magic number: sekunde = (((bt >> 4))*10) + ((bt & 0x0f));
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,getDateTimefrom,The following statement contains a magic number: bt = b[pos + 6];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,getDateTimefrom,The following statement contains a magic number: int bt1 = b[pos + 7];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,getDateTimefrom,The following statement contains a magic number: mili = (((bt >> 4))*10) + ((bt & 0x0f));
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,getDateTimefrom,The following statement contains a magic number: mili = (((bt >> 4))*10) + ((bt & 0x0f));
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,getDateTimefrom,The following statement contains a magic number: mili = mili*10 + (bt1 >> 4);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,getDateTimefrom,The following statement contains a magic number: mili = mili*10 + (bt1 >> 4);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,getTimeOfDayfrom,The following statement contains a magic number: return new DateTime(msval*10000);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,getTimefrom,The following statement contains a magic number: return new TimeSpan(msval*10000);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,getS5Timefrom,The following statement contains a magic number: long zahl = w2*100 + w1;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,getS5Timefrom,The following statement contains a magic number: int basis = (b[pos] >> 4) & 0x03;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,getS5Timefrom,The following statement contains a magic number: switch (basis)              {                  case 0:                      zahl = zahl*100000;                      break;                  case 1:                      zahl = zahl*1000000;                      break;                  case 2:                      zahl = zahl*10000000;                      break;                  case 3:                      zahl = zahl*100000000;                      break;                }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,getS5Timefrom,The following statement contains a magic number: switch (basis)              {                  case 0:                      zahl = zahl*100000;                      break;                  case 1:                      zahl = zahl*1000000;                      break;                  case 2:                      zahl = zahl*10000000;                      break;                  case 3:                      zahl = zahl*100000000;                      break;                }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,getS5Timefrom,The following statement contains a magic number: switch (basis)              {                  case 0:                      zahl = zahl*100000;                      break;                  case 1:                      zahl = zahl*1000000;                      break;                  case 2:                      zahl = zahl*10000000;                      break;                  case 3:                      zahl = zahl*100000000;                      break;                }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,getS5Timefrom,The following statement contains a magic number: switch (basis)              {                  case 0:                      zahl = zahl*100000;                      break;                  case 1:                      zahl = zahl*1000000;                      break;                  case 2:                      zahl = zahl*10000000;                      break;                  case 3:                      zahl = zahl*100000000;                      break;                }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,getS5Timefrom,The following statement contains a magic number: switch (basis)              {                  case 0:                      zahl = zahl*100000;                      break;                  case 1:                      zahl = zahl*1000000;                      break;                  case 2:                      zahl = zahl*10000000;                      break;                  case 3:                      zahl = zahl*100000000;                      break;                }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,getS5Timefrom,The following statement contains a magic number: switch (basis)              {                  case 0:                      zahl = zahl*100000;                      break;                  case 1:                      zahl = zahl*1000000;                      break;                  case 2:                      zahl = zahl*10000000;                      break;                  case 3:                      zahl = zahl*100000000;                      break;                }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,getBit,The following statement contains a magic number: int wrt = System.Convert.ToInt32(System.Math.Pow(2' Bit));
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,dec2bin,The following statement contains a magic number: byte[] bitwert = {128' 64' 32' 16' 8' 4' 2' 1};
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,dec2bin,The following statement contains a magic number: byte[] bitwert = {128' 64' 32' 16' 8' 4' 2' 1};
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,dec2bin,The following statement contains a magic number: byte[] bitwert = {128' 64' 32' 16' 8' 4' 2' 1};
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,dec2bin,The following statement contains a magic number: byte[] bitwert = {128' 64' 32' 16' 8' 4' 2' 1};
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,dec2bin,The following statement contains a magic number: byte[] bitwert = {128' 64' 32' 16' 8' 4' 2' 1};
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,dec2bin,The following statement contains a magic number: byte[] bitwert = {128' 64' 32' 16' 8' 4' 2' 1};
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,dec2bin,The following statement contains a magic number: byte[] bitwert = {128' 64' 32' 16' 8' 4' 2' 1};
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,dec2bin,The following statement contains a magic number: byte[] bits = new byte[8];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,dec2bin,The following statement contains a magic number: Counter < 8
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,Connection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\Connection.cs,PLCStop,The following statement contains a magic number: byte[] para = new byte[] {0x29' 0' 0' 0' 0' 0' 9' (byte) 'P'' (byte) '_'' (byte) 'P'' (byte) 'R'' (byte) 'O'' (byte) 'G'' (byte) 'R'' (byte) 'A'' (byte) 'M'};
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,Connection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\Connection.cs,PLCStart,The following statement contains a magic number: byte[] para = new byte[] {0x28' 0' 0' 0' 0' 0' 9' (byte) 'P'' (byte) '_'' (byte) 'P'' (byte) 'R'' (byte) 'O'' (byte) 'G'' (byte) 'R'' (byte) 'A'' (byte) 'M'};
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,Connection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\Connection.cs,PLCCompress,The following statement contains a magic number: byte[] para = new byte[] {0x28' 0' 0' 0' 0' 0' 0' 0xFD' 0' 0' 5' (byte) '_'' (byte) 'G'' (byte) 'A'' (byte) 'R'' (byte) 'B'};
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,Connection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\Connection.cs,PLCCopyRamToRom,The following statement contains a magic number: byte[] para = new byte[] {0x28' 0' 0' 0' 0' 0' 0' 0xFD' 0' 2' (byte) 'E'' (byte) 'P'' 5' (byte) '_'' (byte) 'M'' (byte) 'O'' (byte) 'D'' (byte) 'U'};
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,Connection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\Connection.cs,PLCCopyRamToRom,The following statement contains a magic number: byte[] para = new byte[] {0x28' 0' 0' 0' 0' 0' 0' 0xFD' 0' 2' (byte) 'E'' (byte) 'P'' 5' (byte) '_'' (byte) 'M'' (byte) 'O'' (byte) 'D'' (byte) 'U'};
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,Connection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\Connection.cs,ReadSZL,The following statement contains a magic number: byte[] para_1 = new byte[] {0' 1' 18' 4' 17' 68' 1' 0};
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,Connection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\Connection.cs,ReadSZL,The following statement contains a magic number: byte[] para_1 = new byte[] {0' 1' 18' 4' 17' 68' 1' 0};
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,Connection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\Connection.cs,ReadSZL,The following statement contains a magic number: byte[] para_1 = new byte[] {0' 1' 18' 4' 17' 68' 1' 0};
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,Connection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\Connection.cs,ReadSZL,The following statement contains a magic number: byte[] para_1 = new byte[] {0' 1' 18' 4' 17' 68' 1' 0};
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,Connection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\Connection.cs,ReadSZL,The following statement contains a magic number: byte[] user = new byte[4];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,Connection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\Connection.cs,ReadSZL,The following statement contains a magic number: user[2] = (byte) (SZL_Index/0x100);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,Connection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\Connection.cs,ReadSZL,The following statement contains a magic number: user[3] = (byte) (SZL_Index%0x100);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,Connection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\Connection.cs,ReadSZL,The following statement contains a magic number: byte[] para_2 = {0' 1' 18' 8' 18' 68' 1' 1' 0' 0' 0' 0};
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,Connection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\Connection.cs,ReadSZL,The following statement contains a magic number: byte[] para_2 = {0' 1' 18' 8' 18' 68' 1' 1' 0' 0' 0' 0};
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,Connection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\Connection.cs,ReadSZL,The following statement contains a magic number: byte[] para_2 = {0' 1' 18' 8' 18' 68' 1' 1' 0' 0' 0' 0};
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,Connection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\Connection.cs,ReadSZL,The following statement contains a magic number: byte[] para_2 = {0' 1' 18' 8' 18' 68' 1' 1' 0' 0' 0' 0};
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,Connection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\Connection.cs,ReadSZL,The following statement contains a magic number: para_2[7] = rec.Param[7];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,Connection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\Connection.cs,ReadSZL,The following statement contains a magic number: para_2[7] = rec.Param[7];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,Connection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\Connection.cs,ReadSZL,The following statement contains a magic number: rec.Param[9] != 0
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TCPConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\internal\TCPConnection.cs,initClient,The following statement contains a magic number: Thread.Sleep(1000);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TCPConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\internal\TCPConnection.cs,ReceiveData,The following statement contains a magic number: Byte[] bytes = new Byte[4];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TCPConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\internal\TCPConnection.cs,ReceiveData,The following statement contains a magic number: int len = stream.Read(bytes' 0' 4);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TCPConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\internal\TCPConnection.cs,ReceiveData,The following statement contains a magic number: int size = bytes[3] + 0x100 * bytes[2];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TCPConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\internal\TCPConnection.cs,ReceiveData,The following statement contains a magic number: int size = bytes[3] + 0x100 * bytes[2];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TCPConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\internal\TCPConnection.cs,ReceiveData,The following statement contains a magic number: len = stream.Read(gesbytes' 4' size);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TCPConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\internal\TCPConnection.cs,ReceiveData,The following statement contains a magic number: Array.Copy(bytes' 0' gesbytes' 0' 4);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TCPConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\internal\TCPConnection.cs,ReceiveData,The following statement contains a magic number: len > 3
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ResultSet,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ResultSet.cs,ResultSet,The following statement contains a magic number: pos += (buffer[pos + 2]*0x100 + buffer[pos + 3])/8;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ResultSet,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ResultSet.cs,ResultSet,The following statement contains a magic number: pos += (buffer[pos + 2]*0x100 + buffer[pos + 3])/8;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ResultSet,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ResultSet.cs,ResultSet,The following statement contains a magic number: pos += (buffer[pos + 2]*0x100 + buffer[pos + 3])/8;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ResultSet,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ResultSet.cs,ResultSet,The following statement contains a magic number: buffer[pos + 1] == 4
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ResultSet,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ResultSet.cs,ResultSet,The following statement contains a magic number: pos += 4;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,connectPLC,The following statement contains a magic number: tcpClient.SendTimeout = 5000;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,connectPLC,The following statement contains a magic number: tcpClient.ReceiveTimeout = 5000;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,connectPLC,The following statement contains a magic number: byte[] b4 ={          		0x11'		//Length          		0xE0'		// TDPU Type CR = Connection Request (see RFC1006/ISO8073)          		0x00' 0x00' // TPDU Destination Reference (unknown)          		0x00' 0x01' // TPDU Source-Reference (my own reference' should not be zero)          		0x00'		// TPDU Class 0 and no Option           		0xC1'		// Parameter Source-TSAP          		2'			// Length of this parameter           		1' 			// Function (1=PG'2=OP'3=Step7Basic)          		0'			// Rack (Bit 7-5) and Slot (Bit 4-0)          		0xC2'		// Parameter Destination-TSAP          		2'			// Length of this parameter           		1'//dc->ConnectionType' 			// Function (1=PG'2=OP'3=Step7Basic)          		(byte)(slot + rack * 32)'			// Rack (Bit 7-5) and Slot (Bit 4-0)          		0xC0'		// Parameter requested TPDU-Size          		1'			// Length of this parameter           		9			// requested TPDU-Size 8=256 Bytes' 9=512 Bytes ' a=1024 Bytes  	        };
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,connectPLC,The following statement contains a magic number: byte[] b4 ={          		0x11'		//Length          		0xE0'		// TDPU Type CR = Connection Request (see RFC1006/ISO8073)          		0x00' 0x00' // TPDU Destination Reference (unknown)          		0x00' 0x01' // TPDU Source-Reference (my own reference' should not be zero)          		0x00'		// TPDU Class 0 and no Option           		0xC1'		// Parameter Source-TSAP          		2'			// Length of this parameter           		1' 			// Function (1=PG'2=OP'3=Step7Basic)          		0'			// Rack (Bit 7-5) and Slot (Bit 4-0)          		0xC2'		// Parameter Destination-TSAP          		2'			// Length of this parameter           		1'//dc->ConnectionType' 			// Function (1=PG'2=OP'3=Step7Basic)          		(byte)(slot + rack * 32)'			// Rack (Bit 7-5) and Slot (Bit 4-0)          		0xC0'		// Parameter requested TPDU-Size          		1'			// Length of this parameter           		9			// requested TPDU-Size 8=256 Bytes' 9=512 Bytes ' a=1024 Bytes  	        };
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,connectPLC,The following statement contains a magic number: byte[] b4 ={          		0x11'		//Length          		0xE0'		// TDPU Type CR = Connection Request (see RFC1006/ISO8073)          		0x00' 0x00' // TPDU Destination Reference (unknown)          		0x00' 0x01' // TPDU Source-Reference (my own reference' should not be zero)          		0x00'		// TPDU Class 0 and no Option           		0xC1'		// Parameter Source-TSAP          		2'			// Length of this parameter           		1' 			// Function (1=PG'2=OP'3=Step7Basic)          		0'			// Rack (Bit 7-5) and Slot (Bit 4-0)          		0xC2'		// Parameter Destination-TSAP          		2'			// Length of this parameter           		1'//dc->ConnectionType' 			// Function (1=PG'2=OP'3=Step7Basic)          		(byte)(slot + rack * 32)'			// Rack (Bit 7-5) and Slot (Bit 4-0)          		0xC0'		// Parameter requested TPDU-Size          		1'			// Length of this parameter           		9			// requested TPDU-Size 8=256 Bytes' 9=512 Bytes ' a=1024 Bytes  	        };
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,connectPLC,The following statement contains a magic number: byte[] b4 ={          		0x11'		//Length          		0xE0'		// TDPU Type CR = Connection Request (see RFC1006/ISO8073)          		0x00' 0x00' // TPDU Destination Reference (unknown)          		0x00' 0x01' // TPDU Source-Reference (my own reference' should not be zero)          		0x00'		// TPDU Class 0 and no Option           		0xC1'		// Parameter Source-TSAP          		2'			// Length of this parameter           		1' 			// Function (1=PG'2=OP'3=Step7Basic)          		0'			// Rack (Bit 7-5) and Slot (Bit 4-0)          		0xC2'		// Parameter Destination-TSAP          		2'			// Length of this parameter           		1'//dc->ConnectionType' 			// Function (1=PG'2=OP'3=Step7Basic)          		(byte)(slot + rack * 32)'			// Rack (Bit 7-5) and Slot (Bit 4-0)          		0xC0'		// Parameter requested TPDU-Size          		1'			// Length of this parameter           		9			// requested TPDU-Size 8=256 Bytes' 9=512 Bytes ' a=1024 Bytes  	        };
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,connectPLC,The following statement contains a magic number: ret != null && ret.Length == 22
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,ReceiveData,The following statement contains a magic number: byte[] bytes = new byte[4];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,ReceiveData,The following statement contains a magic number: len = stream.Read(bytes' 0' 4);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,ReceiveData,The following statement contains a magic number: int size = bytes[3] + 0x100 * bytes[2];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,ReceiveData,The following statement contains a magic number: int size = bytes[3] + 0x100 * bytes[2];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,ReceiveData,The following statement contains a magic number: len = stream.Read(gesbytes' 4' size - 4);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,ReceiveData,The following statement contains a magic number: len = stream.Read(gesbytes' 4' size - 4);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,ReceiveData,The following statement contains a magic number: Array.Copy(bytes' 0' gesbytes' 0' 4);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,ReceiveData,The following statement contains a magic number: len > 3
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,ExchangePdu,The following statement contains a magic number: byte[] _message = new byte[pdu_b.Length + 3];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,ExchangePdu,The following statement contains a magic number: _message[2] = 0x80;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,ExchangePdu,The following statement contains a magic number: Array.Copy(pdu_b' 0' _message' 3' pdu_b.Length);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,ExchangePdu,The following statement contains a magic number: ret != null && ret.Length == 7
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,ExchangePdu,The following statement contains a magic number: byte[] res = new byte[ret.Length - 7];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,ExchangePdu,The following statement contains a magic number: Array.Copy(ret' 7' res' 0' ret.Length - 7);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,ExchangePdu,The following statement contains a magic number: Array.Copy(ret' 7' res' 0' ret.Length - 7);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,sendISOPacket,The following statement contains a magic number: byte[] _message = new byte[message.Length + 4];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,sendISOPacket,The following statement contains a magic number: _message[2] = (byte)(_message.Length / 0x100);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,sendISOPacket,The following statement contains a magic number: _message[3] = (byte)(_message.Length % 0x100);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,sendISOPacket,The following statement contains a magic number: Array.Copy(message' 0' _message' 4' message.Length);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,start,The following statement contains a magic number: byte[] para = new byte[] { 0x28' 0' 0' 0' 0' 0' 0' 0xFD' 0' 0x00' 9' (byte)'P'' (byte)'_'' (byte)'P'' (byte)'R'' (byte)'O'' (byte)'G'' (byte)'R'' (byte)'A'' (byte)'M' };
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,stop,The following statement contains a magic number: byte[] para = new byte[] { 0x29' 0' 0' 0' 0' 0' 9' (byte)'P'' (byte)'_'' (byte)'P'' (byte)'R'' (byte)'O'' (byte)'G'' (byte)'R'' (byte)'A'' (byte)'M' };
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,NegPDUlengthRequest,The following statement contains a magic number: byte[] pa = { 0xF0' 0' 0' 1' 0' 1' 3' 0xC0 };
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,NegPDUlengthRequest,The following statement contains a magic number: CpuPduLimit = ByteFunctions.getU16from(p2.Param.ToArray()' 6);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,daveReadPLCTime,The following statement contains a magic number: Pdu p2 = new Pdu(7);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,daveReadPLCTime,The following statement contains a magic number: byte[] pa = { 0' 1' 18' 4' 17' (byte)'G'' 1' 0 };
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,daveReadPLCTime,The following statement contains a magic number: byte[] pa = { 0' 1' 18' 4' 17' (byte)'G'' 1' 0 };
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,daveReadPLCTime,The following statement contains a magic number: byte[] pa = { 0' 1' 18' 4' 17' (byte)'G'' 1' 0 };
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,daveReadPLCTime,The following statement contains a magic number: AnswLen = p2.Data.Count - 4;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,daveReadPLCTime,The following statement contains a magic number: year = ByteFunctions.getBCD8from(res' 2);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,daveReadPLCTime,The following statement contains a magic number: year += year >= 90 ? 1900 : 2000;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,daveReadPLCTime,The following statement contains a magic number: year += year >= 90 ? 1900 : 2000;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,daveReadPLCTime,The following statement contains a magic number: year += year >= 90 ? 1900 : 2000;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,daveReadPLCTime,The following statement contains a magic number: month = ByteFunctions.getBCD8from(res' 3);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,daveReadPLCTime,The following statement contains a magic number: day = ByteFunctions.getBCD8from(res' 4);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,daveReadPLCTime,The following statement contains a magic number: hour = ByteFunctions.getBCD8from(res' 5);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,daveReadPLCTime,The following statement contains a magic number: minute = ByteFunctions.getBCD8from(res' 6);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,daveReadPLCTime,The following statement contains a magic number: second = ByteFunctions.getBCD8from(res' 7);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,daveReadPLCTime,The following statement contains a magic number: millisecond = ByteFunctions.getBCD8from(res' 8);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,daveReadPLCTime,The following statement contains a magic number: millisecond += ByteFunctions.getBCD8from(res' 9) >> 4;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,daveReadPLCTime,The following statement contains a magic number: millisecond += ByteFunctions.getBCD8from(res' 9) >> 4;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,daveSetPLCTime,The following statement contains a magic number: ByteFunctions.putBCD8at(buffer' 2' tm.Year % 100);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,daveSetPLCTime,The following statement contains a magic number: ByteFunctions.putBCD8at(buffer' 2' tm.Year % 100);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,daveSetPLCTime,The following statement contains a magic number: ByteFunctions.putBCD8at(buffer' 3' tm.Month);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,daveSetPLCTime,The following statement contains a magic number: ByteFunctions.putBCD8at(buffer' 4' tm.Day);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,daveSetPLCTime,The following statement contains a magic number: ByteFunctions.putBCD8at(buffer' 5' tm.Hour);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,daveSetPLCTime,The following statement contains a magic number: ByteFunctions.putBCD8at(buffer' 6' tm.Minute);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,daveSetPLCTime,The following statement contains a magic number: ByteFunctions.putBCD8at(buffer' 7' tm.Second);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,daveSetPLCTime,The following statement contains a magic number: ByteFunctions.putBCD8at(buffer' 8' tm.Millisecond / 10);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,daveSetPLCTime,The following statement contains a magic number: ByteFunctions.putBCD8at(buffer' 8' tm.Millisecond / 10);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,daveSetPLCTime,The following statement contains a magic number: ByteFunctions.putBCD8at(buffer' 9' (tm.Millisecond % 10) << 4);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,daveSetPLCTime,The following statement contains a magic number: ByteFunctions.putBCD8at(buffer' 9' (tm.Millisecond % 10) << 4);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,daveSetPLCTime,The following statement contains a magic number: ByteFunctions.putBCD8at(buffer' 9' (tm.Millisecond % 10) << 4);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,daveSetPLCTime,The following statement contains a magic number: byte[] pa = { 0' 1' 18' 4' 17' (byte)'G'' 2' 0 };
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,daveSetPLCTime,The following statement contains a magic number: byte[] pa = { 0' 1' 18' 4' 17' (byte)'G'' 2' 0 };
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,daveSetPLCTime,The following statement contains a magic number: byte[] pa = { 0' 1' 18' 4' 17' (byte)'G'' 2' 0 };
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,daveSetPLCTime,The following statement contains a magic number: byte[] pa = { 0' 1' 18' 4' 17' (byte)'G'' 2' 0 };
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,_daveBuildAndSendPDU,The following statement contains a magic number: Pdu p = new Pdu(7);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,BuildAndSendPDU,The following statement contains a magic number: Pdu p = new Pdu(7);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,getGetResponse,The following statement contains a magic number: buffer = new byte[10];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,getGetResponse,The following statement contains a magic number: msgIn != null && msgIn.Length == 7
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,readSZL,The following statement contains a magic number: byte[] pa = { 0' 1' 18' 4' 17' 68' 1' 0 };
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,readSZL,The following statement contains a magic number: byte[] pa = { 0' 1' 18' 4' 17' 68' 1' 0 };
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,readSZL,The following statement contains a magic number: byte[] pa = { 0' 1' 18' 4' 17' 68' 1' 0 };
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,readSZL,The following statement contains a magic number: byte[] pa = { 0' 1' 18' 4' 17' 68' 1' 0 };
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,readSZL,The following statement contains a magic number: byte[] da = { 1' 17' 0' 1 };
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,readSZL,The following statement contains a magic number: byte[] pam = { 0' 1' 18' 8' 18' 68' 1' 1' 0' 0' 0' 0 };
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,readSZL,The following statement contains a magic number: byte[] pam = { 0' 1' 18' 8' 18' 68' 1' 1' 0' 0' 0' 0 };
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,readSZL,The following statement contains a magic number: byte[] pam = { 0' 1' 18' 8' 18' 68' 1' 1' 0' 0' 0' 0 };
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,readSZL,The following statement contains a magic number: byte[] pam = { 0' 1' 18' 8' 18' 68' 1' 1' 0' 0' 0' 0 };
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,readSZL,The following statement contains a magic number: da[2] = (byte)(index / 0x100);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,readSZL,The following statement contains a magic number: da[3] = (byte)(index % 0x100);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,readSZL,The following statement contains a magic number: pa7 = p2.Param[7];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,readSZL,The following statement contains a magic number: pam[7] = pa7;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,readSZL,The following statement contains a magic number: p2.Param[9] != 0
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,ListBlocksOfType,The following statement contains a magic number: byte[] pa = { 0' 1' 18' 4' 17' 67' 2' 0 };
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,ListBlocksOfType,The following statement contains a magic number: byte[] pa = { 0' 1' 18' 4' 17' 67' 2' 0 };
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,ListBlocksOfType,The following statement contains a magic number: byte[] pa = { 0' 1' 18' 4' 17' 67' 2' 0 };
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,ListBlocksOfType,The following statement contains a magic number: byte[] pa = { 0' 1' 18' 4' 17' 67' 2' 0 };
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,ListBlocksOfType,The following statement contains a magic number: byte[] pa = { 0' 1' 18' 4' 17' 67' 2' 0 };
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,ListBlocksOfType,The following statement contains a magic number: byte[] pam = { 0' 1' 18' 8' 0x12' 0x43' 2' 1' 0' 0' 0' 0 };
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,ListBlocksOfType,The following statement contains a magic number: byte[] pam = { 0' 1' 18' 8' 0x12' 0x43' 2' 1' 0' 0' 0' 0 };
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,ListBlocksOfType,The following statement contains a magic number: byte[] pam = { 0' 1' 18' 8' 0x12' 0x43' 2' 1' 0' 0' 0' 0 };
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,ListBlocksOfType,The following statement contains a magic number: pam[7] = p2.Param[7];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,ListBlocksOfType,The following statement contains a magic number: pam[7] = p2.Param[7];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,ListBlocksOfType,The following statement contains a magic number: p2.Param[9] != 0
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,initUpload,The following statement contains a magic number: uploadID = ret.Param[7];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,_daveConstructUpload,The following statement contains a magic number: byte[] pa =	{0x1d'                   0'0'0'0'0'0'0'9'0x5f'0x30'0x41'48'48'48'48'49'65};
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,_daveConstructUpload,The following statement contains a magic number: byte[] pa =	{0x1d'                   0'0'0'0'0'0'0'9'0x5f'0x30'0x41'48'48'48'48'49'65};
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,_daveConstructUpload,The following statement contains a magic number: byte[] pa =	{0x1d'                   0'0'0'0'0'0'0'9'0x5f'0x30'0x41'48'48'48'48'49'65};
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,_daveConstructUpload,The following statement contains a magic number: byte[] pa =	{0x1d'                   0'0'0'0'0'0'0'9'0x5f'0x30'0x41'48'48'48'48'49'65};
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,_daveConstructUpload,The following statement contains a magic number: byte[] pa =	{0x1d'                   0'0'0'0'0'0'0'9'0x5f'0x30'0x41'48'48'48'48'49'65};
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,_daveConstructUpload,The following statement contains a magic number: byte[] pa =	{0x1d'                   0'0'0'0'0'0'0'9'0x5f'0x30'0x41'48'48'48'48'49'65};
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,_daveConstructUpload,The following statement contains a magic number: byte[] pa =	{0x1d'                   0'0'0'0'0'0'0'9'0x5f'0x30'0x41'48'48'48'48'49'65};
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,_daveConstructUpload,The following statement contains a magic number: pa[11] = blockType;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,_daveConstructUpload,The following statement contains a magic number: sprintf(pa' 12' 5' blockNr);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,_daveConstructUpload,The following statement contains a magic number: sprintf(pa' 12' 5' blockNr);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,_daveConstructUpload,The following statement contains a magic number: pa[17] = (byte)'A';
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,_daveConstructDoUpload,The following statement contains a magic number: pa[7] = (byte)uploadID;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,_daveConstructEndUpload,The following statement contains a magic number: pa[7] = (byte)uploadID;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,doUpload,The following statement contains a magic number: netLen = ret.Data[1] + 256 * ret.Data[0];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,daveGetPDUerror,The following statement contains a magic number: p.header.type == 2 || p.header.type == 3
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,daveGetPDUerror,The following statement contains a magic number: p.header.type == 2 || p.header.type == 3
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,putProgramBlock,The following statement contains a magic number: byte[] pup = {			// Load request              		0x1A'0'1'0'0'0'0'0'9'              		0x5F'0x30'0x42'0x30'0x30'0x30'0x30'0x34'0x50' // block type code and number              		//     _    0    B   0     0    0    0    4    P              		//		SDB		              		0x0D'              		0x31'0x30'0x30'0x30'0x32'0x30'0x38'0x30'0x30'0x30'0x31'0x31'0x30'0	// file length and netto length              		//     1   0     0    0    2    0    8    0    0    0    1    1    0              	};
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,putProgramBlock,The following statement contains a magic number: byte[] progBlock = new byte[maxPBlockLen + 4];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,putProgramBlock,The following statement contains a magic number: progBlock[2] = 0;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,putProgramBlock,The following statement contains a magic number: progBlock[3] = 0xFB;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,putProgramBlock,The following statement contains a magic number: pup[11] = (byte)blockType;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,putProgramBlock,The following statement contains a magic number: paInsert[13] = (byte)blockType;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,putProgramBlock,The following statement contains a magic number: Array.Copy(buffer' 0' progBlock' 4' maxPBlockLen);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,putProgramBlock,The following statement contains a magic number: progBlock[9] = (byte)(blockType + 0x0A - 'A');
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,putProgramBlock,The following statement contains a magic number: progBlock[9] = 0x08;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,putProgramBlock,The following statement contains a magic number: progBlock[10] = (byte)(blknumber / 0x100);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,putProgramBlock,The following statement contains a magic number: progBlock[11] = (byte)(blknumber - (progBlock[10] * 0x100));
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,putProgramBlock,The following statement contains a magic number: progBlock[11] = (byte)(blknumber - (progBlock[10] * 0x100));
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,putProgramBlock,The following statement contains a magic number: rawLen = ByteFunctions.getU16from(progBlock' 14);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,putProgramBlock,The following statement contains a magic number: netLen = ByteFunctions.getU16from(progBlock' 38);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,putProgramBlock,The following statement contains a magic number: pup[19] = (byte)'1';
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,putProgramBlock,The following statement contains a magic number: sprintf(pup' 20' 6' rawLen);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,putProgramBlock,The following statement contains a magic number: sprintf(pup' 20' 6' rawLen);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,putProgramBlock,The following statement contains a magic number: sprintf(pup' 26' 6' netLen);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,putProgramBlock,The following statement contains a magic number: sprintf(pup' 26' 6' netLen);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,putProgramBlock,The following statement contains a magic number: sprintf(pup' 12' 5' blknumber);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,putProgramBlock,The following statement contains a magic number: sprintf(pup' 12' 5' blknumber);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,putProgramBlock,The following statement contains a magic number: sprintf(paInsert' 14' 5' blknumber);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,putProgramBlock,The following statement contains a magic number: sprintf(paInsert' 14' 5' blknumber);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,putProgramBlock,The following statement contains a magic number: pup[17] = (byte)'P';
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,putProgramBlock,The following statement contains a magic number: paInsert[19] = (byte)'P';
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,putProgramBlock,The following statement contains a magic number: Array.Copy(buffer' cnt * maxPBlockLen' progBlock' 4' maxPBlockLen);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,putProgramBlock,The following statement contains a magic number: progBlock[9] = (byte)(blockType + 0x0A - 'A');
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,putProgramBlock,The following statement contains a magic number: progBlock[9] = 0x08;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,putProgramBlock,The following statement contains a magic number: progBlock[10] = (byte)(blknumber / 0x100);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,putProgramBlock,The following statement contains a magic number: progBlock[11] = (byte)(blknumber - (progBlock[10] * 0x100));
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,putProgramBlock,The following statement contains a magic number: progBlock[11] = (byte)(blknumber - (progBlock[10] * 0x100));
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,putProgramBlock,The following statement contains a magic number: p = new Pdu(3);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,putProgramBlock,The following statement contains a magic number: byte[] dataA = new byte[size + 4];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,putProgramBlock,The following statement contains a magic number: Array.Copy(progBlock' dataA' size + 4);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,putProgramBlock,The following statement contains a magic number: p = new Pdu(3);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,deleteProgramBlock,The following statement contains a magic number: paDelete[13] = (byte)blockType;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,deleteProgramBlock,The following statement contains a magic number: sprintf(paDelete' 14' 5' number);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,deleteProgramBlock,The following statement contains a magic number: sprintf(paDelete' 14' 5' number);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,deleteProgramBlock,The following statement contains a magic number: paDelete[19] = (byte)'B';
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,execReadRequest,The following statement contains a magic number: len = q[countQ + 2] * 0x100 + q[countQ + 3];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,execReadRequest,The following statement contains a magic number: len = q[countQ + 2] * 0x100 + q[countQ + 3];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,execReadRequest,The following statement contains a magic number: len >>= 3;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,execReadRequest,The following statement contains a magic number: q[countQ + 1] == 4
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,execReadRequest,The following statement contains a magic number: (q[countQ] == 255) && (rlen > 4)
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,execReadRequest,The following statement contains a magic number: (q[countQ] == 255) && (rlen > 4)
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,execReadRequest,The following statement contains a magic number: Array.Copy(q' countQ + 4' cr.bytes' 0' len);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,execReadRequest,The following statement contains a magic number: countQ += len + 4;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,execReadRequest,The following statement contains a magic number: (len % 2) == 1
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,readManyBytes,The following statement contains a magic number: readLen = pdulen - 18;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,readManyBytes,The following statement contains a magic number: len > pdulen - 18
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,writeManyBytes,The following statement contains a magic number: writeLen = maxPDUlength - 28;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,writeManyBytes,The following statement contains a magic number: len > maxPDUlength - 28
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,force200,The following statement contains a magic number: byte[] pa = { 0' 1' 18' 8' 18' 72' 14' 0' 0' 0' 0' 0 };
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,force200,The following statement contains a magic number: byte[] pa = { 0' 1' 18' 8' 18' 72' 14' 0' 0' 0' 0' 0 };
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,force200,The following statement contains a magic number: byte[] pa = { 0' 1' 18' 8' 18' 72' 14' 0' 0' 0' 0' 0 };
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,force200,The following statement contains a magic number: byte[] pa = { 0' 1' 18' 8' 18' 72' 14' 0' 0' 0' 0' 0 };
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,force200,The following statement contains a magic number: byte[] pa = { 0' 1' 18' 8' 18' 72' 14' 0' 0' 0' 0' 0 };
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,force200,The following statement contains a magic number: byte[] da ={0'1'0x10'2'                  		0'1'                  		0'0'                          0'		// area                  		0'0'0'		// start                      	};
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,force200,The following statement contains a magic number: byte[] da2 = { 0' 4' 0' 8' 0' 0' };
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,force200,The following statement contains a magic number: byte[] da2 = { 0' 4' 0' 8' 0' 0' };
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,force200,The following statement contains a magic number: da[3] = 4;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,force200,The following statement contains a magic number: da[3] = 4;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,force200,The following statement contains a magic number: start *= 8;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,force200,The following statement contains a magic number: da[8] = (byte)area;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,force200,The following statement contains a magic number: da[9] = (byte)(start / 0x10000);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,force200,The following statement contains a magic number: da[10] = (byte)((start / 0x100) & 0xff);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,force200,The following statement contains a magic number: da[11] = (byte)(start & 0xff);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,force200,The following statement contains a magic number: da2[4] = (byte)(val % 0x100);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,force200,The following statement contains a magic number: da2[5] = (byte)(val / 0x100);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,forceDisconnectIBH,The following statement contains a magic number: chal31[8] = (byte)src;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,forceDisconnectIBH,The following statement contains a magic number: chal31[9] = (byte)dest;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,forceDisconnectIBH,The following statement contains a magic number: chal31[10] = (byte)mpi;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,initUploadNC,The following statement contains a magic number: uploadID[0] = ret.Param[4];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,initUploadNC,The following statement contains a magic number: uploadID[1] = ret.Param[5];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,initUploadNC,The following statement contains a magic number: uploadID[2] = ret.Param[6];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,initUploadNC,The following statement contains a magic number: uploadID[2] = ret.Param[6];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,initUploadNC,The following statement contains a magic number: uploadID[3] = ret.Param[7];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library,TcpNETdave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\TcpNETdave.cs,initUploadNC,The following statement contains a magic number: uploadID[3] = ret.Param[7];
Magic Number,System.Net.Sockets,SocketExtensions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\internal\SocketExtensions.cs,SetKeepAlive,The following statement contains a magic number: byte[] inValue = new byte[3 * BytesPerLong];
Magic Number,System.Net.Sockets,SocketExtensions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\internal\SocketExtensions.cs,SetKeepAlive,The following statement contains a magic number: inValue[i * BytesPerLong + 3] = (byte)(input[i] >> ((BytesPerLong - 1) * BitsPerByte) & 0xff);
Magic Number,System.Net.Sockets,SocketExtensions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\internal\SocketExtensions.cs,SetKeepAlive,The following statement contains a magic number: inValue[i * BytesPerLong + 2] = (byte)(input[i] >> ((BytesPerLong - 2) * BitsPerByte) & 0xff);
Magic Number,System.Net.Sockets,SocketExtensions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\internal\SocketExtensions.cs,SetKeepAlive,The following statement contains a magic number: inValue[i * BytesPerLong + 2] = (byte)(input[i] >> ((BytesPerLong - 2) * BitsPerByte) & 0xff);
Magic Number,System.Net.Sockets,SocketExtensions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\internal\SocketExtensions.cs,SetKeepAlive,The following statement contains a magic number: inValue[i * BytesPerLong + 1] = (byte)(input[i] >> ((BytesPerLong - 3) * BitsPerByte) & 0xff);
Magic Number,System.Net.Sockets,SocketExtensions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\internal\SocketExtensions.cs,SetKeepAlive,The following statement contains a magic number: inValue[i * BytesPerLong + 0] = (byte)(input[i] >> ((BytesPerLong - 4) * BitsPerByte) & 0xff);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library.Pdus,Pdu,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\Pdus\Pdu.cs,Pdu,The following statement contains a magic number: pduHeaderLen = (Type == 2 || Type == 3) ? 12 : 10;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library.Pdus,Pdu,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\Pdus\Pdu.cs,Pdu,The following statement contains a magic number: pduHeaderLen = (Type == 2 || Type == 3) ? 12 : 10;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library.Pdus,Pdu,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\Pdus\Pdu.cs,Pdu,The following statement contains a magic number: pduHeaderLen = (Type == 2 || Type == 3) ? 12 : 10;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library.Pdus,Pdu,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\Pdus\Pdu.cs,Pdu,The following statement contains a magic number: pduHeaderLen = (Type == 2 || Type == 3) ? 12 : 10;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library.Pdus,Pdu,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\Pdus\Pdu.cs,initUData,The following statement contains a magic number: UData.RemoveRange(0' 4);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library.Pdus,Pdu,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\Pdus\Pdu.cs,initUData,The following statement contains a magic number: Data != null && Data.Count > 4
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library.Pdus,Pdu,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\Pdus\Pdu.cs,Pdu,The following statement contains a magic number: pduHeaderLen = (Type == 2 || Type == 3) ? 12 : 10;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library.Pdus,Pdu,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\Pdus\Pdu.cs,Pdu,The following statement contains a magic number: pduHeaderLen = (Type == 2 || Type == 3) ? 12 : 10;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library.Pdus,Pdu,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\Pdus\Pdu.cs,Pdu,The following statement contains a magic number: pduHeaderLen = (Type == 2 || Type == 3) ? 12 : 10;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library.Pdus,Pdu,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\Pdus\Pdu.cs,Pdu,The following statement contains a magic number: pduHeaderLen = (Type == 2 || Type == 3) ? 12 : 10;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library.Pdus,Pdu,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\Pdus\Pdu.cs,addValue,The following statement contains a magic number: dtype = Data[Data.Count - 4 + 1];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library.Pdus,Pdu,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\Pdus\Pdu.cs,addValue,The following statement contains a magic number: dCount = BitConverter.ToUInt16(Data.ToArray()' Data.Count - 4 + 2);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library.Pdus,Pdu,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\Pdus\Pdu.cs,addValue,The following statement contains a magic number: dCount = BitConverter.ToUInt16(Data.ToArray()' Data.Count - 4 + 2);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library.Pdus,Pdu,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\Pdus\Pdu.cs,addValue,The following statement contains a magic number: dCount += (ushort)(8 * len);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library.Pdus,Pdu,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\Pdus\Pdu.cs,addValue,The following statement contains a magic number: dtype == 4
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library.Pdus,Pdu,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\Pdus\Pdu.cs,addValue,The following statement contains a magic number: Data[Data.Count - 4 + 2] = bCount[1];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library.Pdus,Pdu,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\Pdus\Pdu.cs,addValue,The following statement contains a magic number: Data[Data.Count - 4 + 2] = bCount[1];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library.Pdus,Pdu,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\Pdus\Pdu.cs,addValue,The following statement contains a magic number: Data[Data.Count - 4 + 3] = bCount[0];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library.Pdus,Pdu,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\Pdus\Pdu.cs,addValue,The following statement contains a magic number: Data[Data.Count - 4 + 3] = bCount[0];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library.Pdus,Pdu,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\Pdus\Pdu.cs,addToReadRequest,The following statement contains a magic number: byte readSize = 2;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library.Pdus,Pdu,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\Pdus\Pdu.cs,addToReadRequest,The following statement contains a magic number: readSize = 4;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library.Pdus,Pdu,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\Pdus\Pdu.cs,addToReadRequest,The following statement contains a magic number: startByte *= 8;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library.Pdus,Pdu,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\Pdus\Pdu.cs,addToReadRequest,The following statement contains a magic number: byte[] tag = {0x12' 0x0a' 0x10' /* Header */                            readSize' /* 1=single bit' 2=byte' 4=word */                            (byte) (byteCount/256)' (byte) (byteCount & 0xff)' /* length in bytes */                            (byte) (DBnumber/256)' (byte) (DBnumber & 0xff)' /* DB number */                            (byte) area' /* area code */                            (byte) (startByte/0x10000)' (byte) ((startByte/0x100) & 0xff)' (byte) (startByte & 0xFF) /* start address in bits */};
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library.Pdus,Pdu,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\Pdus\Pdu.cs,addToReadRequest,The following statement contains a magic number: byte[] tag = {0x12' 0x0a' 0x10' /* Header */                            readSize' /* 1=single bit' 2=byte' 4=word */                            (byte) (byteCount/256)' (byte) (byteCount & 0xff)' /* length in bytes */                            (byte) (DBnumber/256)' (byte) (DBnumber & 0xff)' /* DB number */                            (byte) area' /* area code */                            (byte) (startByte/0x10000)' (byte) ((startByte/0x100) & 0xff)' (byte) (startByte & 0xFF) /* start address in bits */};
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library.Pdus,Pdu,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\Pdus\Pdu.cs,addBitVarToReadRequest,The following statement contains a magic number: addToReadRequest(area' DBnumber' startByteAddress * 8 + bitNumber' 1' true);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library.Pdus,Pdu,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\Pdus\Pdu.cs,addDbRead400ToReadRequest,The following statement contains a magic number: pa[4] = (byte)byteCount;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library.Pdus,Pdu,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\Pdus\Pdu.cs,addDbRead400ToReadRequest,The following statement contains a magic number: pa[5] = (byte)(DBnum / 256);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library.Pdus,Pdu,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\Pdus\Pdu.cs,addDbRead400ToReadRequest,The following statement contains a magic number: pa[5] = (byte)(DBnum / 256);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library.Pdus,Pdu,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\Pdus\Pdu.cs,addDbRead400ToReadRequest,The following statement contains a magic number: pa[6] = (byte)(DBnum & 0xff);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library.Pdus,Pdu,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\Pdus\Pdu.cs,addDbRead400ToReadRequest,The following statement contains a magic number: pa[7] = (byte)(offset / 256);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library.Pdus,Pdu,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\Pdus\Pdu.cs,addDbRead400ToReadRequest,The following statement contains a magic number: pa[7] = (byte)(offset / 256);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library.Pdus,Pdu,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\Pdus\Pdu.cs,addDbRead400ToReadRequest,The following statement contains a magic number: pa[8] = (byte)(offset & 0xff);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library.Pdus,Pdu,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\Pdus\Pdu.cs,addSymbolToReadRequest,The following statement contains a magic number: pa[1] = (byte)(completeSymbol.Length + 4);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library.Pdus,Pdu,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\Pdus\Pdu.cs,addBitVarToWriteRequest,The following statement contains a magic number: byte[] da = { 0' 3' 0' 0' };
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library.Pdus,Pdu,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\Pdus\Pdu.cs,addToWriteRequest,The following statement contains a magic number: pa[3] = (byte)area;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library.Pdus,Pdu,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\Pdus\Pdu.cs,addToWriteRequest,The following statement contains a magic number: pa[4] = (byte)(((byteCount + 1) / 2) / 0x100);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library.Pdus,Pdu,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\Pdus\Pdu.cs,addToWriteRequest,The following statement contains a magic number: pa[4] = (byte)(((byteCount + 1) / 2) / 0x100);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library.Pdus,Pdu,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\Pdus\Pdu.cs,addToWriteRequest,The following statement contains a magic number: pa[5] = (byte)(((byteCount + 1) / 2) & 0xff);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library.Pdus,Pdu,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\Pdus\Pdu.cs,addToWriteRequest,The following statement contains a magic number: pa[5] = (byte)(((byteCount + 1) / 2) & 0xff);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library.Pdus,Pdu,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\Pdus\Pdu.cs,addToWriteRequest,The following statement contains a magic number: pa[6] = (byte)(DBnum / 256);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library.Pdus,Pdu,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\Pdus\Pdu.cs,addToWriteRequest,The following statement contains a magic number: pa[6] = (byte)(DBnum / 256);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library.Pdus,Pdu,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\Pdus\Pdu.cs,addToWriteRequest,The following statement contains a magic number: pa[7] = (byte)(DBnum & 0xff);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library.Pdus,Pdu,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\Pdus\Pdu.cs,addToWriteRequest,The following statement contains a magic number: pa[8] = (byte)area;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library.Pdus,Pdu,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\Pdus\Pdu.cs,addToWriteRequest,The following statement contains a magic number: pa[11] = (byte)(start & 0xff);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library.Pdus,Pdu,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\Pdus\Pdu.cs,addToWriteRequest,The following statement contains a magic number: pa[10] = (byte)((start / 0x100) & 0xff);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library.Pdus,Pdu,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\Pdus\Pdu.cs,addToWriteRequest,The following statement contains a magic number: pa[9] = (byte)(start / 0x10000);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library.Pdus,Pdu,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\Pdus\Pdu.cs,addToWriteRequest,The following statement contains a magic number: Data.Count % 2 == 1
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library.Pdus,Pdu,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\Pdus\Pdu.cs,addVarToWriteRequest,The following statement contains a magic number: byte[] da = {0' //Return Value                  4' //Transport-Size                  0' //Count of the following Data                  0' //Count of the following Data              };
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library.Pdus,Pdu,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\Pdus\Pdu.cs,addVarToWriteRequest,The following statement contains a magic number: addToWriteRequest(area' DBnum' 8 * start' byteCount' buffer' da' pa);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library.Pdus,Pdu,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\Pdus\Pdu.cs,testWriteResult,The following statement contains a magic number: (Data[0] == 255)
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library.Pdus,Pdu,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\Pdus\Pdu.cs,testPGReadResult,The following statement contains a magic number: pres = (256 * Param[10] + Param[11]);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library.Pdus,Pdu,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\Pdus\Pdu.cs,testPGReadResult,The following statement contains a magic number: pres = (256 * Param[10] + Param[11]);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library.Pdus,Pdu,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\Pdus\Pdu.cs,testPGReadResult,The following statement contains a magic number: pres = (256 * Param[10] + Param[11]);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library.Pdus,Pdu,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\Pdus\Pdu.cs,testPGReadResult,The following statement contains a magic number: Param.Count == 12
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library.Pdus,Pdu,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\Pdus\Pdu.cs,testResultDataMulti,The following statement contains a magic number: Data[1] == 4
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library.Pdus,Pdu,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\Pdus\Pdu.cs,testResultDataMulti,The following statement contains a magic number: (Data[0] == 255) && (Data.Count > 4)
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library.Pdus,Pdu,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\Pdus\Pdu.cs,testResultDataMulti,The following statement contains a magic number: (Data[0] == 255) && (Data.Count > 4)
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library.Pdus,Pdu,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\Pdus\Pdu.cs,testResultData,The following statement contains a magic number: Data[1] == 4
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library.Pdus,Pdu,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\Pdus\Pdu.cs,testResultData,The following statement contains a magic number: (Data[0] == 255) && (Data.Count > 4)
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Library.Pdus,Pdu,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\Pdus\Pdu.cs,testResultData,The following statement contains a magic number: (Data[0] == 255) && (Data.Count > 4)
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Networking,SocketExtensions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Networking\SocketExtensions.cs,SetKeepAlive,The following statement contains a magic number: byte[] inValue = new byte[3 * BytesPerLong];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Networking,SocketExtensions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Networking\SocketExtensions.cs,SetKeepAlive,The following statement contains a magic number: inValue[i * BytesPerLong + 3] = (byte)(input[i] >> ((BytesPerLong - 1) * BitsPerByte) & 0xff);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Networking,SocketExtensions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Networking\SocketExtensions.cs,SetKeepAlive,The following statement contains a magic number: inValue[i * BytesPerLong + 2] = (byte)(input[i] >> ((BytesPerLong - 2) * BitsPerByte) & 0xff);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Networking,SocketExtensions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Networking\SocketExtensions.cs,SetKeepAlive,The following statement contains a magic number: inValue[i * BytesPerLong + 2] = (byte)(input[i] >> ((BytesPerLong - 2) * BitsPerByte) & 0xff);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Networking,SocketExtensions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Networking\SocketExtensions.cs,SetKeepAlive,The following statement contains a magic number: inValue[i * BytesPerLong + 1] = (byte)(input[i] >> ((BytesPerLong - 3) * BitsPerByte) & 0xff);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Networking,SocketExtensions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Networking\SocketExtensions.cs,SetKeepAlive,The following statement contains a magic number: inValue[i * BytesPerLong + 0] = (byte)(input[i] >> ((BytesPerLong - 4) * BitsPerByte) & 0xff);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Networking,TCPFunctionsAsync,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Networking\TCPFunctionsAsync.cs,DoBeginnConnectCallback,The following statement contains a magic number: tcpc.Client.SetKeepAlive(1000' 2000);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Networking,TCPFunctionsAsync,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Networking\TCPFunctionsAsync.cs,DoBeginnConnectCallback,The following statement contains a magic number: tcpc.Client.SetKeepAlive(1000' 2000);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Networking,TCPFunctionsAsync,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Networking\TCPFunctionsAsync.cs,DoAcceptTcpClientCallback,The following statement contains a magic number: akTcpClient.Client.SetKeepAlive(50' 100);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Networking,TCPFunctionsAsync,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Networking\TCPFunctionsAsync.cs,DoAcceptTcpClientCallback,The following statement contains a magic number: akTcpClient.Client.SetKeepAlive(50' 100);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication.Networking,TCPFunctionsAsync,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Networking\TCPFunctionsAsync.cs,beginRead,The following statement contains a magic number: readBytes = new Byte[65536];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,socket_Thread,The following statement contains a magic number: _fds.rfd = new IntPtr(-999);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,Connect,The following statement contains a magic number: _fds.rfd.ToInt32() == -999
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,Connect,The following statement contains a magic number: (int)_configuration.ConnectionType < 9000
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,Connect,The following statement contains a magic number: (int)_configuration.ConnectionType < 9000
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,Connect,The following statement contains a magic number: System.Threading.Thread.Sleep(1000);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PLCstartRequestDiagnosticData,The following statement contains a magic number: SZLData szlData = PLCGetSZL(0x0131' 2);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PLCstartRequestDiagnosticData,The following statement contains a magic number: short answSize =                          (short)(S7FunctionBlockRow._GetCommandStatusAskSize(selRegister' DiagDataTeletype) + 2);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PLCstartRequestDiagnosticData,The following statement contains a magic number: int askHeaderSize = 28;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PLCstartRequestDiagnosticData,The following statement contains a magic number: answSize += (short)(akAskSize + 2);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PLCstartRequestDiagnosticData,The following statement contains a magic number: (answSize + akAskSize) < 182
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PLCstartRequestDiagnosticData,The following statement contains a magic number: int askSize = LinesSelectedRegisters.Count + 2;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PLCstartRequestDiagnosticData,The following statement contains a magic number: askSize += 2;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PLCstartRequestDiagnosticData,The following statement contains a magic number: byte[] stid = new byte[] { rparam[6]' rparam[7] };
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PLCstartRequestDiagnosticData,The following statement contains a magic number: byte[] stid = new byte[] { rparam[6]' rparam[7] };
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PLCstartRequestDiagnosticData,The following statement contains a magic number: throw new Exception("Error Requesting Block Status' Error Code: 0x" +                              rparam[10].ToString("X").PadLeft(2' '0') + rparam[11].ToString("X").PadLeft(2' '0'));
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PLCstartRequestDiagnosticData,The following statement contains a magic number: throw new Exception("Error Requesting Block Status' Error Code: 0x" +                              rparam[10].ToString("X").PadLeft(2' '0') + rparam[11].ToString("X").PadLeft(2' '0'));
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PLCstartRequestDiagnosticData,The following statement contains a magic number: throw new Exception("Error Requesting Block Status' Error Code: 0x" +                              rparam[10].ToString("X").PadLeft(2' '0') + rparam[11].ToString("X").PadLeft(2' '0'));
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PLCstartRequestDiagnosticData,The following statement contains a magic number: throw new Exception("Error Requesting Block Status' Error Code: 0x" +                              rparam[10].ToString("X").PadLeft(2' '0') + rparam[11].ToString("X").PadLeft(2' '0'));
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PLCstartRequestDiagnosticData,The following statement contains a magic number: rparam[10] != 0x00 && rparam[11] != 0x00
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PLCstartRequestDiagnosticData,The following statement contains a magic number: rparam[10] != 0x00 && rparam[11] != 0x00
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PLCGetSafetyStep,The following statement contains a magic number: byte[] buffer = new byte[40];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PLCGetSafetyStep,The following statement contains a magic number: int ret = _dc.readSZL(0x232' 4' buffer);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PLCSendPassword,The following statement contains a magic number: rparam[10] == 0xd6 && rparam[11] == 0x02
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PLCSendPassword,The following statement contains a magic number: rparam[10] == 0xd6 && rparam[11] == 0x02
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PLCGetState,The following statement contains a magic number: byte[] buffer = new byte[64];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PLCGetState,The following statement contains a magic number: int ret = _dc.readSZL(0x174' 4' buffer);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PLCGetState,The following statement contains a magic number: AutoDisconnect && (ret == -1025 || ret == -128)
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PLCGetState,The following statement contains a magic number: AutoDisconnect && (ret == -1025 || ret == -128)
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PLCGetState,The following statement contains a magic number: ret == 54273
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PLCGetState,The following statement contains a magic number: buffer[10] == 1 && buffer[11] == 1
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PLCGetState,The following statement contains a magic number: buffer[10] == 1 && buffer[11] == 1
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PLCListBlocks,The following statement contains a magic number: byte[] blocks = new byte[2048 * 16];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PLCListBlocks,The following statement contains a magic number: byte[] blocks = new byte[2048 * 16];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PLCListBlocks2,The following statement contains a magic number: byte[] blocks = new byte[2048 * 16];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PLCListBlocks2,The following statement contains a magic number: byte[] blocks = new byte[2048 * 16];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PLCGetBlockCount,The following statement contains a magic number: byte[] Para = { 0' 1' 18' 4' 17' 67' 1' 0 };
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PLCGetBlockCount,The following statement contains a magic number: byte[] Para = { 0' 1' 18' 4' 17' 67' 1' 0 };
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PLCGetBlockCount,The following statement contains a magic number: byte[] Para = { 0' 1' 18' 4' 17' 67' 1' 0 };
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PLCGetBlockCount,The following statement contains a magic number: byte[] Para = { 0' 1' 18' 4' 17' 67' 1' 0 };
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PLCGetBlockCount,The following statement contains a magic number: int count = RecData[i + 3] + RecData[i + 2] * 256;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PLCGetBlockCount,The following statement contains a magic number: int count = RecData[i + 3] + RecData[i + 2] * 256;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PLCGetBlockCount,The following statement contains a magic number: int count = RecData[i + 3] + RecData[i + 2] * 256;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PLCGetBlockHeader,The following statement contains a magic number: byte[] Para = { 0' 1' 18' 4' 17' 67' 3' 0 };
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PLCGetBlockHeader,The following statement contains a magic number: byte[] Para = { 0' 1' 18' 4' 17' 67' 3' 0 };
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PLCGetBlockHeader,The following statement contains a magic number: byte[] Para = { 0' 1' 18' 4' 17' 67' 3' 0 };
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PLCGetBlockHeader,The following statement contains a magic number: byte[] Para = { 0' 1' 18' 4' 17' 67' 3' 0 };
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PLCGetBlockHeader,The following statement contains a magic number: byte[] Para = { 0' 1' 18' 4' 17' 67' 3' 0 };
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PLCGetBlockHeader,The following statement contains a magic number: byte[] Data = { 48' 48' 48' 48' 48' 49' 48' 65 };
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PLCGetBlockHeader,The following statement contains a magic number: byte[] Data = { 48' 48' 48' 48' 48' 49' 48' 65 };
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PLCGetBlockHeader,The following statement contains a magic number: byte[] Data = { 48' 48' 48' 48' 48' 49' 48' 65 };
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PLCGetBlockHeader,The following statement contains a magic number: byte[] Data = { 48' 48' 48' 48' 48' 49' 48' 65 };
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PLCGetBlockHeader,The following statement contains a magic number: byte[] Data = { 48' 48' 48' 48' 48' 49' 48' 65 };
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PLCGetBlockHeader,The following statement contains a magic number: byte[] Data = { 48' 48' 48' 48' 48' 49' 48' 65 };
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PLCGetBlockHeader,The following statement contains a magic number: byte[] Data = { 48' 48' 48' 48' 48' 49' 48' 65 };
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PLCGetBlockHeader,The following statement contains a magic number: byte[] Data = { 48' 48' 48' 48' 48' 49' 48' 65 };
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PLCGetBlockHeader,The following statement contains a magic number: string NumberStr = number.ToString().PadLeft(5' '0');
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PLCGetBlockHeader,The following statement contains a magic number: NumberBytes.CopyTo(Data' 2);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PLCGetBlockHeader,The following statement contains a magic number: Data[7] = (byte)'A';
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PLCGetBlockHeader,The following statement contains a magic number: byte[] MC7Code = new byte[RecData.Length - 10];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PLCGetBlockHeader,The following statement contains a magic number: Array.Copy(RecData' 10' MC7Code' 0' MC7Code.Length);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PLCGetBlockInMC7,The following statement contains a magic number: byte[] buffer = new byte[65536 * 3];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PLCGetBlockInMC7,The following statement contains a magic number: byte[] buffer = new byte[65536 * 3];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PLCGetBlockInMC7,The following statement contains a magic number: block = tmp.Substring(0' 3);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PLCGetBlockInMC7,The following statement contains a magic number: nr = Int32.Parse(tmp.Substring(3));
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PLCPutBlockFromMC7toPLC,The following statement contains a magic number: block = tmp.Substring(0' 3);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PLCPutBlockFromMC7toPLC,The following statement contains a magic number: nr = Int32.Parse(tmp.Substring(3));
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PLCPutBlockFromMC7toPLC,The following statement contains a magic number: tmp.Length > 3 && tmp.Substring(0' 3) == "SDB"
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PLCPutBlockFromMC7toPLC,The following statement contains a magic number: tmp.Length > 3 && tmp.Substring(0' 3) == "SDB"
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PLCPutBlockFromMC7toPLC,The following statement contains a magic number: var sizeHighByte = (buffer.Length - 36) / 256;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PLCPutBlockFromMC7toPLC,The following statement contains a magic number: var sizeHighByte = (buffer.Length - 36) / 256;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PLCPutBlockFromMC7toPLC,The following statement contains a magic number: var sizeLowByte = ((buffer.Length - 36) - 256 * sizeHighByte);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PLCPutBlockFromMC7toPLC,The following statement contains a magic number: var sizeLowByte = ((buffer.Length - 36) - 256 * sizeHighByte);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PLCPutBlockFromMC7toPLC,The following statement contains a magic number: var crcBytes = new byte[buffer.Length - 36 + 3];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PLCPutBlockFromMC7toPLC,The following statement contains a magic number: var crcBytes = new byte[buffer.Length - 36 + 3];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PLCPutBlockFromMC7toPLC,The following statement contains a magic number: Array.Copy(crcHeader' 0' crcBytes' 0' 3);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PLCPutBlockFromMC7toPLC,The following statement contains a magic number: Array.Copy(buffer' 36' crcBytes' 3' buffer.Length - 36);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PLCPutBlockFromMC7toPLC,The following statement contains a magic number: Array.Copy(buffer' 36' crcBytes' 3' buffer.Length - 36);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PLCPutBlockFromMC7toPLC,The following statement contains a magic number: Array.Copy(buffer' 36' crcBytes' 3' buffer.Length - 36);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PLCDeleteBlock,The following statement contains a magic number: byte[] buffer = new byte[65536];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PLCDeleteBlock,The following statement contains a magic number: string block = tmp.Substring(0' 2);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PLCDeleteBlock,The following statement contains a magic number: int nr = Int32.Parse(tmp.Substring(2));
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PLCGetSZL,The following statement contains a magic number: byte[] buffer = new byte[65536];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PLCGetSZL,The following statement contains a magic number: retVal.SzlId = (short)(buffer[1] + buffer[0] * 256);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PLCGetSZL,The following statement contains a magic number: retVal.Index = (short)(buffer[3] + buffer[2] * 256);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PLCGetSZL,The following statement contains a magic number: retVal.Index = (short)(buffer[3] + buffer[2] * 256);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PLCGetSZL,The following statement contains a magic number: retVal.Index = (short)(buffer[3] + buffer[2] * 256);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PLCGetSZL,The following statement contains a magic number: retVal.Size = (short)(buffer[5] + buffer[4] * 256);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PLCGetSZL,The following statement contains a magic number: retVal.Size = (short)(buffer[5] + buffer[4] * 256);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PLCGetSZL,The following statement contains a magic number: retVal.Size = (short)(buffer[5] + buffer[4] * 256);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PLCGetSZL,The following statement contains a magic number: retVal.Count = (short)(buffer[7] + buffer[6] * 256);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PLCGetSZL,The following statement contains a magic number: retVal.Count = (short)(buffer[7] + buffer[6] * 256);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PLCGetSZL,The following statement contains a magic number: retVal.Count = (short)(buffer[7] + buffer[6] * 256);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PLCGetSZL,The following statement contains a magic number: Array.Copy(buffer' (n * retVal.Size) + 8' objBuffer' 0' retVal.Size);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PLCGetSZL,The following statement contains a magic number: switch (retVal.SzlId & 0x00ff)                          {                              case 0x0000:                                  datsets.Add(EndianessMarshaler.BytesToStruct<xy00Dataset>(objBuffer));                                  break;                              case 0x0011:                                  datsets.Add(EndianessMarshaler.BytesToStruct<xy11Dataset>(objBuffer));                                  break;                              case 0x0012:                                  datsets.Add(EndianessMarshaler.BytesToStruct<xy12Dataset>(objBuffer));                                  break;                              case 0x0013:                                  datsets.Add(EndianessMarshaler.BytesToStruct<xy13Dataset>(objBuffer));                                  break;                              case 0x0014:                                  datsets.Add(EndianessMarshaler.BytesToStruct<xy14Dataset>(objBuffer));                                  break;                              case 0x0015:                                  datsets.Add(EndianessMarshaler.BytesToStruct<xy15Dataset>(objBuffer));                                  break;                              case 0x0016:                                  datsets.Add(EndianessMarshaler.BytesToStruct<xy16Dataset>(objBuffer));                                  break;                              case 0x0017:                                  datsets.Add(EndianessMarshaler.BytesToStruct<xy17Dataset>(objBuffer));                                  break;                              case 0x0018:                                  datsets.Add(EndianessMarshaler.BytesToStruct<xy18Dataset>(objBuffer));                                  break;                              case 0x0019:                                  datsets.Add(EndianessMarshaler.BytesToStruct<xy19Dataset>(objBuffer));                                  break;                              case 0x0021:                                  datsets.Add(EndianessMarshaler.BytesToStruct<xy21Dataset>(objBuffer));                                  break;                              case 0x001C:                                  datsets.Add(EndianessMarshaler.BytesToStruct<xy1CDataset>(objBuffer));                                  break;                              case 0x0022:                                  datsets.Add(EndianessMarshaler.BytesToStruct<xy22Dataset>(objBuffer));                                  break;                              case 0x0023:                                  datsets.Add(EndianessMarshaler.BytesToStruct<xy23Dataset>(objBuffer));                                  break;                              case 0x0024:                                  datsets.Add(EndianessMarshaler.BytesToStruct<xy24Dataset>(objBuffer));                                  break;                              case 0x0025:                                  datsets.Add(EndianessMarshaler.BytesToStruct<xy25Dataset>(objBuffer));                                  break;                              case 0x0031:                                  switch (retVal.Index)                                  {                                      case 1:                                          datsets.Add(EndianessMarshaler.BytesToStruct<xy31_1Dataset>(objBuffer));                                          break;                                      case 2:                                          datsets.Add(EndianessMarshaler.BytesToStruct<xy31_2Dataset>(objBuffer));                                          break;                                      case 3:                                          datsets.Add(EndianessMarshaler.BytesToStruct<xy31_3Dataset>(objBuffer));                                          break;                                      case 4:                                          datsets.Add(EndianessMarshaler.BytesToStruct<xy31_4Dataset>(objBuffer));                                          break;                                      case 5:                                          datsets.Add(EndianessMarshaler.BytesToStruct<xy31_5Dataset>(objBuffer));                                          break;                                      case 6:                                          datsets.Add(EndianessMarshaler.BytesToStruct<xy31_6Dataset>(objBuffer));                                          break;                                      default:                                          {                                              DefaultSZLDataset tmp = new DefaultSZLDataset();                                              tmp.Bytes = objBuffer;                                              datsets.Add(tmp);                                          }                                          break;                                  }                                  break;                              case 0x0032:                                  switch (retVal.Index)                                  {                                      case 1:                                          datsets.Add(EndianessMarshaler.BytesToStruct<xy32_1Dataset>(objBuffer));                                          break;                                      case 4:                                          datsets.Add(EndianessMarshaler.BytesToStruct<xy32_4Dataset>(objBuffer));                                          break;                                      case 8:                                          datsets.Add(EndianessMarshaler.BytesToStruct<xy32_8Dataset>(objBuffer));                                          break;                                      default:                                          {                                              DefaultSZLDataset tmp = new DefaultSZLDataset();                                              tmp.Bytes = objBuffer;                                              datsets.Add(tmp);                                          }                                          break;                                  }                                  break;                              case 0x0071:                                  datsets.Add(EndianessMarshaler.BytesToStruct<xy71Dataset>(objBuffer));                                  break;                              case 0x0074:                                  datsets.Add(EndianessMarshaler.BytesToStruct<xy74Dataset>(objBuffer));                                  break;                              default:                                  {                                      DefaultSZLDataset tmp = new DefaultSZLDataset();                                      tmp.Bytes = objBuffer;                                      datsets.Add(tmp);                                  }                                  break;                          }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PLCGetSZL,The following statement contains a magic number: switch (retVal.SzlId & 0x00ff)                          {                              case 0x0000:                                  datsets.Add(EndianessMarshaler.BytesToStruct<xy00Dataset>(objBuffer));                                  break;                              case 0x0011:                                  datsets.Add(EndianessMarshaler.BytesToStruct<xy11Dataset>(objBuffer));                                  break;                              case 0x0012:                                  datsets.Add(EndianessMarshaler.BytesToStruct<xy12Dataset>(objBuffer));                                  break;                              case 0x0013:                                  datsets.Add(EndianessMarshaler.BytesToStruct<xy13Dataset>(objBuffer));                                  break;                              case 0x0014:                                  datsets.Add(EndianessMarshaler.BytesToStruct<xy14Dataset>(objBuffer));                                  break;                              case 0x0015:                                  datsets.Add(EndianessMarshaler.BytesToStruct<xy15Dataset>(objBuffer));                                  break;                              case 0x0016:                                  datsets.Add(EndianessMarshaler.BytesToStruct<xy16Dataset>(objBuffer));                                  break;                              case 0x0017:                                  datsets.Add(EndianessMarshaler.BytesToStruct<xy17Dataset>(objBuffer));                                  break;                              case 0x0018:                                  datsets.Add(EndianessMarshaler.BytesToStruct<xy18Dataset>(objBuffer));                                  break;                              case 0x0019:                                  datsets.Add(EndianessMarshaler.BytesToStruct<xy19Dataset>(objBuffer));                                  break;                              case 0x0021:                                  datsets.Add(EndianessMarshaler.BytesToStruct<xy21Dataset>(objBuffer));                                  break;                              case 0x001C:                                  datsets.Add(EndianessMarshaler.BytesToStruct<xy1CDataset>(objBuffer));                                  break;                              case 0x0022:                                  datsets.Add(EndianessMarshaler.BytesToStruct<xy22Dataset>(objBuffer));                                  break;                              case 0x0023:                                  datsets.Add(EndianessMarshaler.BytesToStruct<xy23Dataset>(objBuffer));                                  break;                              case 0x0024:                                  datsets.Add(EndianessMarshaler.BytesToStruct<xy24Dataset>(objBuffer));                                  break;                              case 0x0025:                                  datsets.Add(EndianessMarshaler.BytesToStruct<xy25Dataset>(objBuffer));                                  break;                              case 0x0031:                                  switch (retVal.Index)                                  {                                      case 1:                                          datsets.Add(EndianessMarshaler.BytesToStruct<xy31_1Dataset>(objBuffer));                                          break;                                      case 2:                                          datsets.Add(EndianessMarshaler.BytesToStruct<xy31_2Dataset>(objBuffer));                                          break;                                      case 3:                                          datsets.Add(EndianessMarshaler.BytesToStruct<xy31_3Dataset>(objBuffer));                                          break;                                      case 4:                                          datsets.Add(EndianessMarshaler.BytesToStruct<xy31_4Dataset>(objBuffer));                                          break;                                      case 5:                                          datsets.Add(EndianessMarshaler.BytesToStruct<xy31_5Dataset>(objBuffer));                                          break;                                      case 6:                                          datsets.Add(EndianessMarshaler.BytesToStruct<xy31_6Dataset>(objBuffer));                                          break;                                      default:                                          {                                              DefaultSZLDataset tmp = new DefaultSZLDataset();                                              tmp.Bytes = objBuffer;                                              datsets.Add(tmp);                                          }                                          break;                                  }                                  break;                              case 0x0032:                                  switch (retVal.Index)                                  {                                      case 1:                                          datsets.Add(EndianessMarshaler.BytesToStruct<xy32_1Dataset>(objBuffer));                                          break;                                      case 4:                                          datsets.Add(EndianessMarshaler.BytesToStruct<xy32_4Dataset>(objBuffer));                                          break;                                      case 8:                                          datsets.Add(EndianessMarshaler.BytesToStruct<xy32_8Dataset>(objBuffer));                                          break;                                      default:                                          {                                              DefaultSZLDataset tmp = new DefaultSZLDataset();                                              tmp.Bytes = objBuffer;                                              datsets.Add(tmp);                                          }                                          break;                                  }                                  break;                              case 0x0071:                                  datsets.Add(EndianessMarshaler.BytesToStruct<xy71Dataset>(objBuffer));                                  break;                              case 0x0074:                                  datsets.Add(EndianessMarshaler.BytesToStruct<xy74Dataset>(objBuffer));                                  break;                              default:                                  {                                      DefaultSZLDataset tmp = new DefaultSZLDataset();                                      tmp.Bytes = objBuffer;                                      datsets.Add(tmp);                                  }                                  break;                          }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PLCGetSZL,The following statement contains a magic number: switch (retVal.SzlId & 0x00ff)                          {                              case 0x0000:                                  datsets.Add(EndianessMarshaler.BytesToStruct<xy00Dataset>(objBuffer));                                  break;                              case 0x0011:                                  datsets.Add(EndianessMarshaler.BytesToStruct<xy11Dataset>(objBuffer));                                  break;                              case 0x0012:                                  datsets.Add(EndianessMarshaler.BytesToStruct<xy12Dataset>(objBuffer));                                  break;                              case 0x0013:                                  datsets.Add(EndianessMarshaler.BytesToStruct<xy13Dataset>(objBuffer));                                  break;                              case 0x0014:                                  datsets.Add(EndianessMarshaler.BytesToStruct<xy14Dataset>(objBuffer));                                  break;                              case 0x0015:                                  datsets.Add(EndianessMarshaler.BytesToStruct<xy15Dataset>(objBuffer));                                  break;                              case 0x0016:                                  datsets.Add(EndianessMarshaler.BytesToStruct<xy16Dataset>(objBuffer));                                  break;                              case 0x0017:                                  datsets.Add(EndianessMarshaler.BytesToStruct<xy17Dataset>(objBuffer));                                  break;                              case 0x0018:                                  datsets.Add(EndianessMarshaler.BytesToStruct<xy18Dataset>(objBuffer));                                  break;                              case 0x0019:                                  datsets.Add(EndianessMarshaler.BytesToStruct<xy19Dataset>(objBuffer));                                  break;                              case 0x0021:                                  datsets.Add(EndianessMarshaler.BytesToStruct<xy21Dataset>(objBuffer));                                  break;                              case 0x001C:                                  datsets.Add(EndianessMarshaler.BytesToStruct<xy1CDataset>(objBuffer));                                  break;                              case 0x0022:                                  datsets.Add(EndianessMarshaler.BytesToStruct<xy22Dataset>(objBuffer));                                  break;                              case 0x0023:                                  datsets.Add(EndianessMarshaler.BytesToStruct<xy23Dataset>(objBuffer));                                  break;                              case 0x0024:                                  datsets.Add(EndianessMarshaler.BytesToStruct<xy24Dataset>(objBuffer));                                  break;                              case 0x0025:                                  datsets.Add(EndianessMarshaler.BytesToStruct<xy25Dataset>(objBuffer));                                  break;                              case 0x0031:                                  switch (retVal.Index)                                  {                                      case 1:                                          datsets.Add(EndianessMarshaler.BytesToStruct<xy31_1Dataset>(objBuffer));                                          break;                                      case 2:                                          datsets.Add(EndianessMarshaler.BytesToStruct<xy31_2Dataset>(objBuffer));                                          break;                                      case 3:                                          datsets.Add(EndianessMarshaler.BytesToStruct<xy31_3Dataset>(objBuffer));                                          break;                                      case 4:                                          datsets.Add(EndianessMarshaler.BytesToStruct<xy31_4Dataset>(objBuffer));                                          break;                                      case 5:                                          datsets.Add(EndianessMarshaler.BytesToStruct<xy31_5Dataset>(objBuffer));                                          break;                                      case 6:                                          datsets.Add(EndianessMarshaler.BytesToStruct<xy31_6Dataset>(objBuffer));                                          break;                                      default:                                          {                                              DefaultSZLDataset tmp = new DefaultSZLDataset();                                              tmp.Bytes = objBuffer;                                              datsets.Add(tmp);                                          }                                          break;                                  }                                  break;                              case 0x0032:                                  switch (retVal.Index)                                  {                                      case 1:                                          datsets.Add(EndianessMarshaler.BytesToStruct<xy32_1Dataset>(objBuffer));                                          break;                                      case 4:                                          datsets.Add(EndianessMarshaler.BytesToStruct<xy32_4Dataset>(objBuffer));                                          break;                                      case 8:                                          datsets.Add(EndianessMarshaler.BytesToStruct<xy32_8Dataset>(objBuffer));                                          break;                                      default:                                          {                                              DefaultSZLDataset tmp = new DefaultSZLDataset();                                              tmp.Bytes = objBuffer;                                              datsets.Add(tmp);                                          }                                          break;                                  }                                  break;                              case 0x0071:                                  datsets.Add(EndianessMarshaler.BytesToStruct<xy71Dataset>(objBuffer));                                  break;                              case 0x0074:                                  datsets.Add(EndianessMarshaler.BytesToStruct<xy74Dataset>(objBuffer));                                  break;                              default:                                  {                                      DefaultSZLDataset tmp = new DefaultSZLDataset();                                      tmp.Bytes = objBuffer;                                      datsets.Add(tmp);                                  }                                  break;                          }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PLCGetSZL,The following statement contains a magic number: switch (retVal.SzlId & 0x00ff)                          {                              case 0x0000:                                  datsets.Add(EndianessMarshaler.BytesToStruct<xy00Dataset>(objBuffer));                                  break;                              case 0x0011:                                  datsets.Add(EndianessMarshaler.BytesToStruct<xy11Dataset>(objBuffer));                                  break;                              case 0x0012:                                  datsets.Add(EndianessMarshaler.BytesToStruct<xy12Dataset>(objBuffer));                                  break;                              case 0x0013:                                  datsets.Add(EndianessMarshaler.BytesToStruct<xy13Dataset>(objBuffer));                                  break;                              case 0x0014:                                  datsets.Add(EndianessMarshaler.BytesToStruct<xy14Dataset>(objBuffer));                                  break;                              case 0x0015:                                  datsets.Add(EndianessMarshaler.BytesToStruct<xy15Dataset>(objBuffer));                                  break;                              case 0x0016:                                  datsets.Add(EndianessMarshaler.BytesToStruct<xy16Dataset>(objBuffer));                                  break;                              case 0x0017:                                  datsets.Add(EndianessMarshaler.BytesToStruct<xy17Dataset>(objBuffer));                                  break;                              case 0x0018:                                  datsets.Add(EndianessMarshaler.BytesToStruct<xy18Dataset>(objBuffer));                                  break;                              case 0x0019:                                  datsets.Add(EndianessMarshaler.BytesToStruct<xy19Dataset>(objBuffer));                                  break;                              case 0x0021:                                  datsets.Add(EndianessMarshaler.BytesToStruct<xy21Dataset>(objBuffer));                                  break;                              case 0x001C:                                  datsets.Add(EndianessMarshaler.BytesToStruct<xy1CDataset>(objBuffer));                                  break;                              case 0x0022:                                  datsets.Add(EndianessMarshaler.BytesToStruct<xy22Dataset>(objBuffer));                                  break;                              case 0x0023:                                  datsets.Add(EndianessMarshaler.BytesToStruct<xy23Dataset>(objBuffer));                                  break;                              case 0x0024:                                  datsets.Add(EndianessMarshaler.BytesToStruct<xy24Dataset>(objBuffer));                                  break;                              case 0x0025:                                  datsets.Add(EndianessMarshaler.BytesToStruct<xy25Dataset>(objBuffer));                                  break;                              case 0x0031:                                  switch (retVal.Index)                                  {                                      case 1:                                          datsets.Add(EndianessMarshaler.BytesToStruct<xy31_1Dataset>(objBuffer));                                          break;                                      case 2:                                          datsets.Add(EndianessMarshaler.BytesToStruct<xy31_2Dataset>(objBuffer));                                          break;                                      case 3:                                          datsets.Add(EndianessMarshaler.BytesToStruct<xy31_3Dataset>(objBuffer));                                          break;                                      case 4:                                          datsets.Add(EndianessMarshaler.BytesToStruct<xy31_4Dataset>(objBuffer));                                          break;                                      case 5:                                          datsets.Add(EndianessMarshaler.BytesToStruct<xy31_5Dataset>(objBuffer));                                          break;                                      case 6:                                          datsets.Add(EndianessMarshaler.BytesToStruct<xy31_6Dataset>(objBuffer));                                          break;                                      default:                                          {                                              DefaultSZLDataset tmp = new DefaultSZLDataset();                                              tmp.Bytes = objBuffer;                                              datsets.Add(tmp);                                          }                                          break;                                  }                                  break;                              case 0x0032:                                  switch (retVal.Index)                                  {                                      case 1:                                          datsets.Add(EndianessMarshaler.BytesToStruct<xy32_1Dataset>(objBuffer));                                          break;                                      case 4:                                          datsets.Add(EndianessMarshaler.BytesToStruct<xy32_4Dataset>(objBuffer));                                          break;                                      case 8:                                          datsets.Add(EndianessMarshaler.BytesToStruct<xy32_8Dataset>(objBuffer));                                          break;                                      default:                                          {                                              DefaultSZLDataset tmp = new DefaultSZLDataset();                                              tmp.Bytes = objBuffer;                                              datsets.Add(tmp);                                          }                                          break;                                  }                                  break;                              case 0x0071:                                  datsets.Add(EndianessMarshaler.BytesToStruct<xy71Dataset>(objBuffer));                                  break;                              case 0x0074:                                  datsets.Add(EndianessMarshaler.BytesToStruct<xy74Dataset>(objBuffer));                                  break;                              default:                                  {                                      DefaultSZLDataset tmp = new DefaultSZLDataset();                                      tmp.Bytes = objBuffer;                                      datsets.Add(tmp);                                  }                                  break;                          }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PLCGetSZL,The following statement contains a magic number: switch (retVal.SzlId & 0x00ff)                          {                              case 0x0000:                                  datsets.Add(EndianessMarshaler.BytesToStruct<xy00Dataset>(objBuffer));                                  break;                              case 0x0011:                                  datsets.Add(EndianessMarshaler.BytesToStruct<xy11Dataset>(objBuffer));                                  break;                              case 0x0012:                                  datsets.Add(EndianessMarshaler.BytesToStruct<xy12Dataset>(objBuffer));                                  break;                              case 0x0013:                                  datsets.Add(EndianessMarshaler.BytesToStruct<xy13Dataset>(objBuffer));                                  break;                              case 0x0014:                                  datsets.Add(EndianessMarshaler.BytesToStruct<xy14Dataset>(objBuffer));                                  break;                              case 0x0015:                                  datsets.Add(EndianessMarshaler.BytesToStruct<xy15Dataset>(objBuffer));                                  break;                              case 0x0016:                                  datsets.Add(EndianessMarshaler.BytesToStruct<xy16Dataset>(objBuffer));                                  break;                              case 0x0017:                                  datsets.Add(EndianessMarshaler.BytesToStruct<xy17Dataset>(objBuffer));                                  break;                              case 0x0018:                                  datsets.Add(EndianessMarshaler.BytesToStruct<xy18Dataset>(objBuffer));                                  break;                              case 0x0019:                                  datsets.Add(EndianessMarshaler.BytesToStruct<xy19Dataset>(objBuffer));                                  break;                              case 0x0021:                                  datsets.Add(EndianessMarshaler.BytesToStruct<xy21Dataset>(objBuffer));                                  break;                              case 0x001C:                                  datsets.Add(EndianessMarshaler.BytesToStruct<xy1CDataset>(objBuffer));                                  break;                              case 0x0022:                                  datsets.Add(EndianessMarshaler.BytesToStruct<xy22Dataset>(objBuffer));                                  break;                              case 0x0023:                                  datsets.Add(EndianessMarshaler.BytesToStruct<xy23Dataset>(objBuffer));                                  break;                              case 0x0024:                                  datsets.Add(EndianessMarshaler.BytesToStruct<xy24Dataset>(objBuffer));                                  break;                              case 0x0025:                                  datsets.Add(EndianessMarshaler.BytesToStruct<xy25Dataset>(objBuffer));                                  break;                              case 0x0031:                                  switch (retVal.Index)                                  {                                      case 1:                                          datsets.Add(EndianessMarshaler.BytesToStruct<xy31_1Dataset>(objBuffer));                                          break;                                      case 2:                                          datsets.Add(EndianessMarshaler.BytesToStruct<xy31_2Dataset>(objBuffer));                                          break;                                      case 3:                                          datsets.Add(EndianessMarshaler.BytesToStruct<xy31_3Dataset>(objBuffer));                                          break;                                      case 4:                                          datsets.Add(EndianessMarshaler.BytesToStruct<xy31_4Dataset>(objBuffer));                                          break;                                      case 5:                                          datsets.Add(EndianessMarshaler.BytesToStruct<xy31_5Dataset>(objBuffer));                                          break;                                      case 6:                                          datsets.Add(EndianessMarshaler.BytesToStruct<xy31_6Dataset>(objBuffer));                                          break;                                      default:                                          {                                              DefaultSZLDataset tmp = new DefaultSZLDataset();                                              tmp.Bytes = objBuffer;                                              datsets.Add(tmp);                                          }                                          break;                                  }                                  break;                              case 0x0032:                                  switch (retVal.Index)                                  {                                      case 1:                                          datsets.Add(EndianessMarshaler.BytesToStruct<xy32_1Dataset>(objBuffer));                                          break;                                      case 4:                                          datsets.Add(EndianessMarshaler.BytesToStruct<xy32_4Dataset>(objBuffer));                                          break;                                      case 8:                                          datsets.Add(EndianessMarshaler.BytesToStruct<xy32_8Dataset>(objBuffer));                                          break;                                      default:                                          {                                              DefaultSZLDataset tmp = new DefaultSZLDataset();                                              tmp.Bytes = objBuffer;                                              datsets.Add(tmp);                                          }                                          break;                                  }                                  break;                              case 0x0071:                                  datsets.Add(EndianessMarshaler.BytesToStruct<xy71Dataset>(objBuffer));                                  break;                              case 0x0074:                                  datsets.Add(EndianessMarshaler.BytesToStruct<xy74Dataset>(objBuffer));                                  break;                              default:                                  {                                      DefaultSZLDataset tmp = new DefaultSZLDataset();                                      tmp.Bytes = objBuffer;                                      datsets.Add(tmp);                                  }                                  break;                          }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PLCGetSZL,The following statement contains a magic number: switch (retVal.SzlId & 0x00ff)                          {                              case 0x0000:                                  datsets.Add(EndianessMarshaler.BytesToStruct<xy00Dataset>(objBuffer));                                  break;                              case 0x0011:                                  datsets.Add(EndianessMarshaler.BytesToStruct<xy11Dataset>(objBuffer));                                  break;                              case 0x0012:                                  datsets.Add(EndianessMarshaler.BytesToStruct<xy12Dataset>(objBuffer));                                  break;                              case 0x0013:                                  datsets.Add(EndianessMarshaler.BytesToStruct<xy13Dataset>(objBuffer));                                  break;                              case 0x0014:                                  datsets.Add(EndianessMarshaler.BytesToStruct<xy14Dataset>(objBuffer));                                  break;                              case 0x0015:                                  datsets.Add(EndianessMarshaler.BytesToStruct<xy15Dataset>(objBuffer));                                  break;                              case 0x0016:                                  datsets.Add(EndianessMarshaler.BytesToStruct<xy16Dataset>(objBuffer));                                  break;                              case 0x0017:                                  datsets.Add(EndianessMarshaler.BytesToStruct<xy17Dataset>(objBuffer));                                  break;                              case 0x0018:                                  datsets.Add(EndianessMarshaler.BytesToStruct<xy18Dataset>(objBuffer));                                  break;                              case 0x0019:                                  datsets.Add(EndianessMarshaler.BytesToStruct<xy19Dataset>(objBuffer));                                  break;                              case 0x0021:                                  datsets.Add(EndianessMarshaler.BytesToStruct<xy21Dataset>(objBuffer));                                  break;                              case 0x001C:                                  datsets.Add(EndianessMarshaler.BytesToStruct<xy1CDataset>(objBuffer));                                  break;                              case 0x0022:                                  datsets.Add(EndianessMarshaler.BytesToStruct<xy22Dataset>(objBuffer));                                  break;                              case 0x0023:                                  datsets.Add(EndianessMarshaler.BytesToStruct<xy23Dataset>(objBuffer));                                  break;                              case 0x0024:                                  datsets.Add(EndianessMarshaler.BytesToStruct<xy24Dataset>(objBuffer));                                  break;                              case 0x0025:                                  datsets.Add(EndianessMarshaler.BytesToStruct<xy25Dataset>(objBuffer));                                  break;                              case 0x0031:                                  switch (retVal.Index)                                  {                                      case 1:                                          datsets.Add(EndianessMarshaler.BytesToStruct<xy31_1Dataset>(objBuffer));                                          break;                                      case 2:                                          datsets.Add(EndianessMarshaler.BytesToStruct<xy31_2Dataset>(objBuffer));                                          break;                                      case 3:                                          datsets.Add(EndianessMarshaler.BytesToStruct<xy31_3Dataset>(objBuffer));                                          break;                                      case 4:                                          datsets.Add(EndianessMarshaler.BytesToStruct<xy31_4Dataset>(objBuffer));                                          break;                                      case 5:                                          datsets.Add(EndianessMarshaler.BytesToStruct<xy31_5Dataset>(objBuffer));                                          break;                                      case 6:                                          datsets.Add(EndianessMarshaler.BytesToStruct<xy31_6Dataset>(objBuffer));                                          break;                                      default:                                          {                                              DefaultSZLDataset tmp = new DefaultSZLDataset();                                              tmp.Bytes = objBuffer;                                              datsets.Add(tmp);                                          }                                          break;                                  }                                  break;                              case 0x0032:                                  switch (retVal.Index)                                  {                                      case 1:                                          datsets.Add(EndianessMarshaler.BytesToStruct<xy32_1Dataset>(objBuffer));                                          break;                                      case 4:                                          datsets.Add(EndianessMarshaler.BytesToStruct<xy32_4Dataset>(objBuffer));                                          break;                                      case 8:                                          datsets.Add(EndianessMarshaler.BytesToStruct<xy32_8Dataset>(objBuffer));                                          break;                                      default:                                          {                                              DefaultSZLDataset tmp = new DefaultSZLDataset();                                              tmp.Bytes = objBuffer;                                              datsets.Add(tmp);                                          }                                          break;                                  }                                  break;                              case 0x0071:                                  datsets.Add(EndianessMarshaler.BytesToStruct<xy71Dataset>(objBuffer));                                  break;                              case 0x0074:                                  datsets.Add(EndianessMarshaler.BytesToStruct<xy74Dataset>(objBuffer));                                  break;                              default:                                  {                                      DefaultSZLDataset tmp = new DefaultSZLDataset();                                      tmp.Bytes = objBuffer;                                      datsets.Add(tmp);                                  }                                  break;                          }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PLCGetSZL,The following statement contains a magic number: switch (retVal.SzlId & 0x00ff)                          {                              case 0x0000:                                  datsets.Add(EndianessMarshaler.BytesToStruct<xy00Dataset>(objBuffer));                                  break;                              case 0x0011:                                  datsets.Add(EndianessMarshaler.BytesToStruct<xy11Dataset>(objBuffer));                                  break;                              case 0x0012:                                  datsets.Add(EndianessMarshaler.BytesToStruct<xy12Dataset>(objBuffer));                                  break;                              case 0x0013:                                  datsets.Add(EndianessMarshaler.BytesToStruct<xy13Dataset>(objBuffer));                                  break;                              case 0x0014:                                  datsets.Add(EndianessMarshaler.BytesToStruct<xy14Dataset>(objBuffer));                                  break;                              case 0x0015:                                  datsets.Add(EndianessMarshaler.BytesToStruct<xy15Dataset>(objBuffer));                                  break;                              case 0x0016:                                  datsets.Add(EndianessMarshaler.BytesToStruct<xy16Dataset>(objBuffer));                                  break;                              case 0x0017:                                  datsets.Add(EndianessMarshaler.BytesToStruct<xy17Dataset>(objBuffer));                                  break;                              case 0x0018:                                  datsets.Add(EndianessMarshaler.BytesToStruct<xy18Dataset>(objBuffer));                                  break;                              case 0x0019:                                  datsets.Add(EndianessMarshaler.BytesToStruct<xy19Dataset>(objBuffer));                                  break;                              case 0x0021:                                  datsets.Add(EndianessMarshaler.BytesToStruct<xy21Dataset>(objBuffer));                                  break;                              case 0x001C:                                  datsets.Add(EndianessMarshaler.BytesToStruct<xy1CDataset>(objBuffer));                                  break;                              case 0x0022:                                  datsets.Add(EndianessMarshaler.BytesToStruct<xy22Dataset>(objBuffer));                                  break;                              case 0x0023:                                  datsets.Add(EndianessMarshaler.BytesToStruct<xy23Dataset>(objBuffer));                                  break;                              case 0x0024:                                  datsets.Add(EndianessMarshaler.BytesToStruct<xy24Dataset>(objBuffer));                                  break;                              case 0x0025:                                  datsets.Add(EndianessMarshaler.BytesToStruct<xy25Dataset>(objBuffer));                                  break;                              case 0x0031:                                  switch (retVal.Index)                                  {                                      case 1:                                          datsets.Add(EndianessMarshaler.BytesToStruct<xy31_1Dataset>(objBuffer));                                          break;                                      case 2:                                          datsets.Add(EndianessMarshaler.BytesToStruct<xy31_2Dataset>(objBuffer));                                          break;                                      case 3:                                          datsets.Add(EndianessMarshaler.BytesToStruct<xy31_3Dataset>(objBuffer));                                          break;                                      case 4:                                          datsets.Add(EndianessMarshaler.BytesToStruct<xy31_4Dataset>(objBuffer));                                          break;                                      case 5:                                          datsets.Add(EndianessMarshaler.BytesToStruct<xy31_5Dataset>(objBuffer));                                          break;                                      case 6:                                          datsets.Add(EndianessMarshaler.BytesToStruct<xy31_6Dataset>(objBuffer));                                          break;                                      default:                                          {                                              DefaultSZLDataset tmp = new DefaultSZLDataset();                                              tmp.Bytes = objBuffer;                                              datsets.Add(tmp);                                          }                                          break;                                  }                                  break;                              case 0x0032:                                  switch (retVal.Index)                                  {                                      case 1:                                          datsets.Add(EndianessMarshaler.BytesToStruct<xy32_1Dataset>(objBuffer));                                          break;                                      case 4:                                          datsets.Add(EndianessMarshaler.BytesToStruct<xy32_4Dataset>(objBuffer));                                          break;                                      case 8:                                          datsets.Add(EndianessMarshaler.BytesToStruct<xy32_8Dataset>(objBuffer));                                          break;                                      default:                                          {                                              DefaultSZLDataset tmp = new DefaultSZLDataset();                                              tmp.Bytes = objBuffer;                                              datsets.Add(tmp);                                          }                                          break;                                  }                                  break;                              case 0x0071:                                  datsets.Add(EndianessMarshaler.BytesToStruct<xy71Dataset>(objBuffer));                                  break;                              case 0x0074:                                  datsets.Add(EndianessMarshaler.BytesToStruct<xy74Dataset>(objBuffer));                                  break;                              default:                                  {                                      DefaultSZLDataset tmp = new DefaultSZLDataset();                                      tmp.Bytes = objBuffer;                                      datsets.Add(tmp);                                  }                                  break;                          }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PLCGetDiagnosticBuffer,The following statement contains a magic number: byte[] buffer = new byte[65536];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PLCGetDiagnosticBuffer,The following statement contains a magic number: int cnt = buffer[7] + buffer[6] * 256;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PLCGetDiagnosticBuffer,The following statement contains a magic number: int cnt = buffer[7] + buffer[6] * 256;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PLCGetDiagnosticBuffer,The following statement contains a magic number: int cnt = buffer[7] + buffer[6] * 256;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PLCGetDiagnosticBuffer,The following statement contains a magic number: cnt = 100;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PLCGetDiagnosticBuffer,The following statement contains a magic number: cnt > 10000
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PLCGetDiagnosticBuffer,The following statement contains a magic number: byte[] diagData = new byte[20];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PLCGetDiagnosticBuffer,The following statement contains a magic number: Array.Copy(buffer' n * 20 + 8' diagData' 0' 20);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PLCGetDiagnosticBuffer,The following statement contains a magic number: Array.Copy(buffer' n * 20 + 8' diagData' 0' 20);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PLCGetDiagnosticBuffer,The following statement contains a magic number: Array.Copy(buffer' n * 20 + 8' diagData' 0' 20);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PLCCompressMemory,The following statement contains a magic number: _di.setTimeout(Timeout * 10);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PLCCompressMemory,The following statement contains a magic number: byte[] Para = { 0x28' 0' 0' 0' 0' 0' 0' 0xFD' 0' 0x00' 5' (byte)'_'' (byte)'G'' (byte)'A'' (byte)'R'' (byte)'B' };
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PLCCompressMemory,The following statement contains a magic number: _di.setTimeout(Timeout * 10);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PLCCopyRamToRom,The following statement contains a magic number: _di.setTimeout(Timeout * 10);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PLCCopyRamToRom,The following statement contains a magic number: byte[] Para = { 0x28' 0' 0' 0' 0' 0' 0' 0xfd' 0' 2' (byte)'E'' (byte)'P'' 5' (byte)'_'' (byte)'M'' (byte)'O'' (byte)'D'' (byte)'U' };
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PLCCopyRamToRom,The following statement contains a magic number: byte[] Para = { 0x28' 0' 0' 0' 0' 0' 0' 0xfd' 0' 2' (byte)'E'' (byte)'P'' 5' (byte)'_'' (byte)'M'' (byte)'O'' (byte)'D'' (byte)'U' };
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PLCCopyRamToRom,The following statement contains a magic number: _di.setTimeout(Timeout * 10);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,ReadValuesWithVarTabFunctions,The following statement contains a magic number: byte[] akAsk = new byte[6];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,ReadValuesWithVarTabFunctions,The following statement contains a magic number: switch (plcTag.TagDataSource)                      {                          case MemoryArea.Flags:                              dtaTyp = 0;                              break;                          case MemoryArea.Inputs:                              dtaTyp = 1;                              break;                          case MemoryArea.Outputs:                              dtaTyp = 2;                              break;                          case MemoryArea.Datablock:                              dtaTyp = 0x07;                              dbNo = plcTag.DataBlockNumber;                              break;                          case MemoryArea.Timer:                              dtaTyp = 5;                              break;                          case MemoryArea.Counter:                              dtaTyp = 6;                              break;                          case MemoryArea.LocalData:                              dtaTyp = 0x0c;                              break;                      }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,ReadValuesWithVarTabFunctions,The following statement contains a magic number: switch (plcTag.TagDataSource)                      {                          case MemoryArea.Flags:                              dtaTyp = 0;                              break;                          case MemoryArea.Inputs:                              dtaTyp = 1;                              break;                          case MemoryArea.Outputs:                              dtaTyp = 2;                              break;                          case MemoryArea.Datablock:                              dtaTyp = 0x07;                              dbNo = plcTag.DataBlockNumber;                              break;                          case MemoryArea.Timer:                              dtaTyp = 5;                              break;                          case MemoryArea.Counter:                              dtaTyp = 6;                              break;                          case MemoryArea.LocalData:                              dtaTyp = 0x0c;                              break;                      }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,ReadValuesWithVarTabFunctions,The following statement contains a magic number: switch (plcTag.TagDataSource)                      {                          case MemoryArea.Flags:                              dtaTyp = 0;                              break;                          case MemoryArea.Inputs:                              dtaTyp = 1;                              break;                          case MemoryArea.Outputs:                              dtaTyp = 2;                              break;                          case MemoryArea.Datablock:                              dtaTyp = 0x07;                              dbNo = plcTag.DataBlockNumber;                              break;                          case MemoryArea.Timer:                              dtaTyp = 5;                              break;                          case MemoryArea.Counter:                              dtaTyp = 6;                              break;                          case MemoryArea.LocalData:                              dtaTyp = 0x0c;                              break;                      }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,ReadValuesWithVarTabFunctions,The following statement contains a magic number: switch (plcTag.ReadByteSize)                      {                          case 1:                              dtaSize = 1;                              break;                          case 2:                              dtaSize = 2;                              break;                          case 4:                              dtaSize = 3;                              break;                          default:                              if (plcTag.TagDataSource == MemoryArea.Timer || plcTag.TagDataSource == MemoryArea.Counter)                              {                                  dtaSize = 4;                                  dbNo = 1;                              }                              else                              {                                  dtaArrSize = plcTag.ReadByteSize;                                  dtaSize = 1;                              }                                break;                      }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,ReadValuesWithVarTabFunctions,The following statement contains a magic number: switch (plcTag.ReadByteSize)                      {                          case 1:                              dtaSize = 1;                              break;                          case 2:                              dtaSize = 2;                              break;                          case 4:                              dtaSize = 3;                              break;                          default:                              if (plcTag.TagDataSource == MemoryArea.Timer || plcTag.TagDataSource == MemoryArea.Counter)                              {                                  dtaSize = 4;                                  dbNo = 1;                              }                              else                              {                                  dtaArrSize = plcTag.ReadByteSize;                                  dtaSize = 1;                              }                                break;                      }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,ReadValuesWithVarTabFunctions,The following statement contains a magic number: switch (plcTag.ReadByteSize)                      {                          case 1:                              dtaSize = 1;                              break;                          case 2:                              dtaSize = 2;                              break;                          case 4:                              dtaSize = 3;                              break;                          default:                              if (plcTag.TagDataSource == MemoryArea.Timer || plcTag.TagDataSource == MemoryArea.Counter)                              {                                  dtaSize = 4;                                  dbNo = 1;                              }                              else                              {                                  dtaArrSize = plcTag.ReadByteSize;                                  dtaSize = 1;                              }                                break;                      }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,ReadValuesWithVarTabFunctions,The following statement contains a magic number: switch (plcTag.ReadByteSize)                      {                          case 1:                              dtaSize = 1;                              break;                          case 2:                              dtaSize = 2;                              break;                          case 4:                              dtaSize = 3;                              break;                          default:                              if (plcTag.TagDataSource == MemoryArea.Timer || plcTag.TagDataSource == MemoryArea.Counter)                              {                                  dtaSize = 4;                                  dbNo = 1;                              }                              else                              {                                  dtaArrSize = plcTag.ReadByteSize;                                  dtaSize = 1;                              }                                break;                      }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,ReadValuesWithVarTabFunctions,The following statement contains a magic number: switch (plcTag.ReadByteSize)                      {                          case 1:                              dtaSize = 1;                              break;                          case 2:                              dtaSize = 2;                              break;                          case 4:                              dtaSize = 3;                              break;                          default:                              if (plcTag.TagDataSource == MemoryArea.Timer || plcTag.TagDataSource == MemoryArea.Counter)                              {                                  dtaSize = 4;                                  dbNo = 1;                              }                              else                              {                                  dtaArrSize = plcTag.ReadByteSize;                                  dtaSize = 1;                              }                                break;                      }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,ReadValuesWithVarTabFunctions,The following statement contains a magic number: akAsk[2] = (byte) (dbNo / 0x100);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,ReadValuesWithVarTabFunctions,The following statement contains a magic number: akAsk[3] = (byte) (dbNo % 0x100);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,ReadValuesWithVarTabFunctions,The following statement contains a magic number: akAsk[4] = (byte) (plcTag.ByteAddress / 0x100);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,ReadValuesWithVarTabFunctions,The following statement contains a magic number: akAsk[5] = (byte) (plcTag.ByteAddress % 0x100);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,ReadValuesWithVarTabFunctions,The following statement contains a magic number: int len1 = anzZeilen * 6 + 2;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,ReadValuesWithVarTabFunctions,The following statement contains a magic number: int len1 = anzZeilen * 6 + 2;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,ReadValuesWithVarTabFunctions,The following statement contains a magic number: byte[] stid = new byte[] {rparam[6]' rparam[7]};
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,ReadValuesWithVarTabFunctions,The following statement contains a magic number: byte[] stid = new byte[] {rparam[6]' rparam[7]};
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,ReadValuesWithVarTabFunctions,The following statement contains a magic number: throw new Exception("Error Reading Tags with Var Tab Functions' Error Code: 0x" +                                          rparam[10].ToString("X").PadLeft(2' '0') +                                          rparam[11].ToString("X").PadLeft(2' '0'));
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,ReadValuesWithVarTabFunctions,The following statement contains a magic number: throw new Exception("Error Reading Tags with Var Tab Functions' Error Code: 0x" +                                          rparam[10].ToString("X").PadLeft(2' '0') +                                          rparam[11].ToString("X").PadLeft(2' '0'));
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,ReadValuesWithVarTabFunctions,The following statement contains a magic number: throw new Exception("Error Reading Tags with Var Tab Functions' Error Code: 0x" +                                          rparam[10].ToString("X").PadLeft(2' '0') +                                          rparam[11].ToString("X").PadLeft(2' '0'));
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,ReadValuesWithVarTabFunctions,The following statement contains a magic number: throw new Exception("Error Reading Tags with Var Tab Functions' Error Code: 0x" +                                          rparam[10].ToString("X").PadLeft(2' '0') +                                          rparam[11].ToString("X").PadLeft(2' '0'));
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,ReadValuesWithVarTabFunctions,The following statement contains a magic number: rparam[10] != 0x00 && rparam[11] != 0x00
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,ReadValuesWithVarTabFunctions,The following statement contains a magic number: rparam[10] != 0x00 && rparam[11] != 0x00
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,WriteValuesWithVarTabFunctions,The following statement contains a magic number: byte[] akAsk = new byte[6];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,WriteValuesWithVarTabFunctions,The following statement contains a magic number: switch (plcTag.TagDataSource)                      {                          case MemoryArea.Flags:                              dtaTyp = 0;                              break;                          case MemoryArea.Inputs:                              dtaTyp = 1;                              break;                          case MemoryArea.Outputs:                              dtaTyp = 2;                              break;                          case MemoryArea.Datablock:                              dtaTyp = 0x07;                              dbNo = plcTag.DataBlockNumber;                              break;                          case MemoryArea.Timer:                              dtaTyp = 5;                              break;                          case MemoryArea.Counter:                              dtaTyp = 6;                              break;                          case MemoryArea.LocalData:                              dtaTyp = 0x0c;                              break;                      }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,WriteValuesWithVarTabFunctions,The following statement contains a magic number: switch (plcTag.TagDataSource)                      {                          case MemoryArea.Flags:                              dtaTyp = 0;                              break;                          case MemoryArea.Inputs:                              dtaTyp = 1;                              break;                          case MemoryArea.Outputs:                              dtaTyp = 2;                              break;                          case MemoryArea.Datablock:                              dtaTyp = 0x07;                              dbNo = plcTag.DataBlockNumber;                              break;                          case MemoryArea.Timer:                              dtaTyp = 5;                              break;                          case MemoryArea.Counter:                              dtaTyp = 6;                              break;                          case MemoryArea.LocalData:                              dtaTyp = 0x0c;                              break;                      }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,WriteValuesWithVarTabFunctions,The following statement contains a magic number: switch (plcTag.TagDataSource)                      {                          case MemoryArea.Flags:                              dtaTyp = 0;                              break;                          case MemoryArea.Inputs:                              dtaTyp = 1;                              break;                          case MemoryArea.Outputs:                              dtaTyp = 2;                              break;                          case MemoryArea.Datablock:                              dtaTyp = 0x07;                              dbNo = plcTag.DataBlockNumber;                              break;                          case MemoryArea.Timer:                              dtaTyp = 5;                              break;                          case MemoryArea.Counter:                              dtaTyp = 6;                              break;                          case MemoryArea.LocalData:                              dtaTyp = 0x0c;                              break;                      }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,WriteValuesWithVarTabFunctions,The following statement contains a magic number: switch (plcTag.ReadByteSize)                      {                          case 1:                              dtaSize = 1;                              break;                          case 2:                              dtaSize = 2;                              break;                          case 4:                              dtaSize = 3;                              break;                          default:                              if (plcTag.TagDataSource == MemoryArea.Timer || plcTag.TagDataSource == MemoryArea.Counter)                              {                                  dtaSize = 4;                                  dbNo = 1;                              }                              else                              {                                  dtaArrSize = plcTag.ReadByteSize;                                  dtaSize = 1;                              }                                break;                      }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,WriteValuesWithVarTabFunctions,The following statement contains a magic number: switch (plcTag.ReadByteSize)                      {                          case 1:                              dtaSize = 1;                              break;                          case 2:                              dtaSize = 2;                              break;                          case 4:                              dtaSize = 3;                              break;                          default:                              if (plcTag.TagDataSource == MemoryArea.Timer || plcTag.TagDataSource == MemoryArea.Counter)                              {                                  dtaSize = 4;                                  dbNo = 1;                              }                              else                              {                                  dtaArrSize = plcTag.ReadByteSize;                                  dtaSize = 1;                              }                                break;                      }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,WriteValuesWithVarTabFunctions,The following statement contains a magic number: switch (plcTag.ReadByteSize)                      {                          case 1:                              dtaSize = 1;                              break;                          case 2:                              dtaSize = 2;                              break;                          case 4:                              dtaSize = 3;                              break;                          default:                              if (plcTag.TagDataSource == MemoryArea.Timer || plcTag.TagDataSource == MemoryArea.Counter)                              {                                  dtaSize = 4;                                  dbNo = 1;                              }                              else                              {                                  dtaArrSize = plcTag.ReadByteSize;                                  dtaSize = 1;                              }                                break;                      }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,WriteValuesWithVarTabFunctions,The following statement contains a magic number: switch (plcTag.ReadByteSize)                      {                          case 1:                              dtaSize = 1;                              break;                          case 2:                              dtaSize = 2;                              break;                          case 4:                              dtaSize = 3;                              break;                          default:                              if (plcTag.TagDataSource == MemoryArea.Timer || plcTag.TagDataSource == MemoryArea.Counter)                              {                                  dtaSize = 4;                                  dbNo = 1;                              }                              else                              {                                  dtaArrSize = plcTag.ReadByteSize;                                  dtaSize = 1;                              }                                break;                      }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,WriteValuesWithVarTabFunctions,The following statement contains a magic number: switch (plcTag.ReadByteSize)                      {                          case 1:                              dtaSize = 1;                              break;                          case 2:                              dtaSize = 2;                              break;                          case 4:                              dtaSize = 3;                              break;                          default:                              if (plcTag.TagDataSource == MemoryArea.Timer || plcTag.TagDataSource == MemoryArea.Counter)                              {                                  dtaSize = 4;                                  dbNo = 1;                              }                              else                              {                                  dtaArrSize = plcTag.ReadByteSize;                                  dtaSize = 1;                              }                                break;                      }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,WriteValuesWithVarTabFunctions,The following statement contains a magic number: akAsk[2] = (byte) (dbNo / 0x100);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,WriteValuesWithVarTabFunctions,The following statement contains a magic number: akAsk[3] = (byte) (dbNo % 0x100);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,WriteValuesWithVarTabFunctions,The following statement contains a magic number: akAsk[4] = (byte) (plcTag.ByteAddress / 0x100);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,WriteValuesWithVarTabFunctions,The following statement contains a magic number: akAsk[5] = (byte) (plcTag.ByteAddress % 0x100);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,WriteValuesWithVarTabFunctions,The following statement contains a magic number: int len1 = anzZeilen * 6 + 2 + controlValues.Count;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,WriteValuesWithVarTabFunctions,The following statement contains a magic number: int len1 = anzZeilen * 6 + 2 + controlValues.Count;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,WriteValuesWithVarTabFunctions,The following statement contains a magic number: byte[] stid = new byte[] {rparam[6]' rparam[7]};
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,WriteValuesWithVarTabFunctions,The following statement contains a magic number: byte[] stid = new byte[] {rparam[6]' rparam[7]};
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,WriteValuesWithVarTabFunctions,The following statement contains a magic number: throw new Exception("Error Wrting Tags with VarTab Functions' Error Code: 0x" +                                          rparam[10].ToString("X").PadLeft(2' '0') +                                          rparam[11].ToString("X").PadLeft(2' '0'));
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,WriteValuesWithVarTabFunctions,The following statement contains a magic number: throw new Exception("Error Wrting Tags with VarTab Functions' Error Code: 0x" +                                          rparam[10].ToString("X").PadLeft(2' '0') +                                          rparam[11].ToString("X").PadLeft(2' '0'));
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,WriteValuesWithVarTabFunctions,The following statement contains a magic number: throw new Exception("Error Wrting Tags with VarTab Functions' Error Code: 0x" +                                          rparam[10].ToString("X").PadLeft(2' '0') +                                          rparam[11].ToString("X").PadLeft(2' '0'));
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,WriteValuesWithVarTabFunctions,The following statement contains a magic number: throw new Exception("Error Wrting Tags with VarTab Functions' Error Code: 0x" +                                          rparam[10].ToString("X").PadLeft(2' '0') +                                          rparam[11].ToString("X").PadLeft(2' '0'));
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,WriteValuesWithVarTabFunctions,The following statement contains a magic number: rparam[10] != 0x00 && rparam[11] != 0x00
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,WriteValuesWithVarTabFunctions,The following statement contains a magic number: rparam[10] != 0x00 && rparam[11] != 0x00
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,_TestNewReadValues,The following statement contains a magic number: int maxReadSize = GetPduSize() - 32;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,_TestNewReadValues,The following statement contains a magic number: int HeaderTagSize = 4;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,_TestNewReadValues,The following statement contains a magic number: int askSize = 12;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,_TestNewReadValues,The following statement contains a magic number: HeaderTagSize = 4;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,_TestNewReadValues,The following statement contains a magic number: askSize = 7;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,_TestNewReadValues,The following statement contains a magic number: HeaderTagSize = 5;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,_TestNewReadValues,The following statement contains a magic number: readSizeWithHeader += readSizeWithHeader % 2;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,_TestNewReadValues,The following statement contains a magic number: AutoDisconnect && (res == -1025 || res == -128)
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,_TestNewReadValues,The following statement contains a magic number: AutoDisconnect && (res == -1025 || res == -128)
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,_TestNewReadValues,The following statement contains a magic number: res == 10 || res == 5
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,_TestNewReadValues,The following statement contains a magic number: res == 10 || res == 5
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,ReadValues,The following statement contains a magic number: int maxReadSize = GetPduSize() - 32;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,ReadValues,The following statement contains a magic number: maxReadSize = 208;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,ReadValues,The following statement contains a magic number: maxReadSize > 208 && readTagList.First() is PLCNckTag && ((PLCNckTag)readTagList.First()).NckArea == NCK_Area.AreaFeedDrive
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,ReadValues,The following statement contains a magic number: List<int> readenSizes = new List<int>(50);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,ReadValues,The following statement contains a magic number: List<bool> usedShortRequest = new List<bool>(50);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,ReadValues,The following statement contains a magic number: List<bool> tagWasSplitted = new List<bool>(50);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,ReadValues,The following statement contains a magic number: int askSize = 12;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,ReadValues,The following statement contains a magic number: askSize = 7;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,ReadValues,The following statement contains a magic number: askSize = 4 + libNoDaveValue.SymbolicAccessKey.Length;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,ReadValues,The following statement contains a magic number: const int HeaderTagSize = 4;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,ReadValues,The following statement contains a magic number: readSizeWithHeader % 2 != 0
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,ReadValues,The following statement contains a magic number: AutoDisconnect && (res == -1025 || res == -128)
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,ReadValues,The following statement contains a magic number: AutoDisconnect && (res == -1025 || res == -128)
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,ReadValues,The following statement contains a magic number: res == 10 || res == 5
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,ReadValues,The following statement contains a magic number: res == 10 || res == 5
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,ReadValues,The following statement contains a magic number: AutoDisconnect && (res == -1025 || res == -128)
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,ReadValues,The following statement contains a magic number: AutoDisconnect && (res == -1025 || res == -128)
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,ReadValues,The following statement contains a magic number: res == 10 || res == 5
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,ReadValues,The following statement contains a magic number: res == 10 || res == 5
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,WriteValue,The following statement contains a magic number: res = _dc.writeBits(Convert.ToInt32(value.TagDataSource)' value.DataBlockNumber'                                  value.ByteAddress * 8 + value.BitAddress' readSize' myBuff);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,WriteValue,The following statement contains a magic number: AutoDisconnect && (res == -1025 || res == -128)
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,WriteValue,The following statement contains a magic number: AutoDisconnect && (res == -1025 || res == -128)
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,WriteValues,The following statement contains a magic number: int maxWriteSize = GetPduSize() - 32;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,WriteValues,The following statement contains a magic number: int tagHeaderSize = 12 + 4;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,WriteValues,The following statement contains a magic number: int tagHeaderSize = 12 + 4;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,WriteValues,The following statement contains a magic number: myPDU.addBitVarToWriteRequest(Convert.ToInt32(currVal.TagDataSource)'                                              currVal.DataBlockNumber'                                              (currVal.ByteAddress + splitPos) * 8 + currVal.BitAddress' 1' wrt);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,WriteValues,The following statement contains a magic number: AutoDisconnect && (res == -1025 || res == -128)
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,WriteValues,The following statement contains a magic number: AutoDisconnect && (res == -1025 || res == -128)
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PI_Service,The following statement contains a magic number: AutoDisconnect && res == -1025
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,BinaryUploadFromNC,The following statement contains a magic number: byte[] id = new byte[4];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,BinaryUploadFromNC,The following statement contains a magic number: byte[] buffer = new byte[1024];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,UploadFromNC,The following statement contains a magic number: byte[] id = new byte[4];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,UploadFromNC,The following statement contains a magic number: byte[] buffer = new byte[1024];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,GetAlarmS_IDs,The following statement contains a magic number: int size = 32767;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,GetDateTimeFromByteArray,The following statement contains a magic number: return new DateTime(int.Parse(sAr[0]) >= 90 ? 1900 + int.Parse(sAr[0]) : 2000 + int.Parse(sAr[0])' int.Parse(sAr[1])' int.Parse(sAr[2])' int.Parse(sAr[3])' int.Parse(sAr[4])' int.Parse(sAr[5])' int.Parse(sAr[6] + sAr[7].Substring(0' 1)));
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,GetDateTimeFromByteArray,The following statement contains a magic number: return new DateTime(int.Parse(sAr[0]) >= 90 ? 1900 + int.Parse(sAr[0]) : 2000 + int.Parse(sAr[0])' int.Parse(sAr[1])' int.Parse(sAr[2])' int.Parse(sAr[3])' int.Parse(sAr[4])' int.Parse(sAr[5])' int.Parse(sAr[6] + sAr[7].Substring(0' 1)));
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,GetDateTimeFromByteArray,The following statement contains a magic number: return new DateTime(int.Parse(sAr[0]) >= 90 ? 1900 + int.Parse(sAr[0]) : 2000 + int.Parse(sAr[0])' int.Parse(sAr[1])' int.Parse(sAr[2])' int.Parse(sAr[3])' int.Parse(sAr[4])' int.Parse(sAr[5])' int.Parse(sAr[6] + sAr[7].Substring(0' 1)));
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,GetDateTimeFromByteArray,The following statement contains a magic number: return new DateTime(int.Parse(sAr[0]) >= 90 ? 1900 + int.Parse(sAr[0]) : 2000 + int.Parse(sAr[0])' int.Parse(sAr[1])' int.Parse(sAr[2])' int.Parse(sAr[3])' int.Parse(sAr[4])' int.Parse(sAr[5])' int.Parse(sAr[6] + sAr[7].Substring(0' 1)));
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,GetDateTimeFromByteArray,The following statement contains a magic number: return new DateTime(int.Parse(sAr[0]) >= 90 ? 1900 + int.Parse(sAr[0]) : 2000 + int.Parse(sAr[0])' int.Parse(sAr[1])' int.Parse(sAr[2])' int.Parse(sAr[3])' int.Parse(sAr[4])' int.Parse(sAr[5])' int.Parse(sAr[6] + sAr[7].Substring(0' 1)));
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,GetDateTimeFromByteArray,The following statement contains a magic number: return new DateTime(int.Parse(sAr[0]) >= 90 ? 1900 + int.Parse(sAr[0]) : 2000 + int.Parse(sAr[0])' int.Parse(sAr[1])' int.Parse(sAr[2])' int.Parse(sAr[3])' int.Parse(sAr[4])' int.Parse(sAr[5])' int.Parse(sAr[6] + sAr[7].Substring(0' 1)));
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,GetDateTimeFromByteArray,The following statement contains a magic number: return new DateTime(int.Parse(sAr[0]) >= 90 ? 1900 + int.Parse(sAr[0]) : 2000 + int.Parse(sAr[0])' int.Parse(sAr[1])' int.Parse(sAr[2])' int.Parse(sAr[3])' int.Parse(sAr[4])' int.Parse(sAr[5])' int.Parse(sAr[6] + sAr[7].Substring(0' 1)));
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,GetDateTimeFromByteArray,The following statement contains a magic number: return new DateTime(int.Parse(sAr[0]) >= 90 ? 1900 + int.Parse(sAr[0]) : 2000 + int.Parse(sAr[0])' int.Parse(sAr[1])' int.Parse(sAr[2])' int.Parse(sAr[3])' int.Parse(sAr[4])' int.Parse(sAr[5])' int.Parse(sAr[6] + sAr[7].Substring(0' 1)));
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,GetDateTimeFromByteArray,The following statement contains a magic number: return new DateTime(int.Parse(sAr[0]) >= 90 ? 1900 + int.Parse(sAr[0]) : 2000 + int.Parse(sAr[0])' int.Parse(sAr[1])' int.Parse(sAr[2])' int.Parse(sAr[3])' int.Parse(sAr[4])' int.Parse(sAr[5])' int.Parse(sAr[6] + sAr[7].Substring(0' 1)));
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,GetByteArrayFromBuffer,The following statement contains a magic number: byte[] ret = new byte[8];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,GetByteArrayFromBuffer,The following statement contains a magic number: return new byte[8];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,GetByteArrayFromBuffer,The following statement contains a magic number: ret[0] = Convert.ToByte((dt.Year > 2000 ? dt.Year - 2000 : dt.Year - 1900).ToString()' 16);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,GetByteArrayFromBuffer,The following statement contains a magic number: ret[0] = Convert.ToByte((dt.Year > 2000 ? dt.Year - 2000 : dt.Year - 1900).ToString()' 16);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,GetByteArrayFromBuffer,The following statement contains a magic number: ret[0] = Convert.ToByte((dt.Year > 2000 ? dt.Year - 2000 : dt.Year - 1900).ToString()' 16);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,GetByteArrayFromBuffer,The following statement contains a magic number: ret[0] = Convert.ToByte((dt.Year > 2000 ? dt.Year - 2000 : dt.Year - 1900).ToString()' 16);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,GetByteArrayFromBuffer,The following statement contains a magic number: ret[1] = Convert.ToByte(dt.Month.ToString()' 16);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,GetByteArrayFromBuffer,The following statement contains a magic number: ret[2] = Convert.ToByte(dt.Day.ToString()' 16);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,GetByteArrayFromBuffer,The following statement contains a magic number: ret[2] = Convert.ToByte(dt.Day.ToString()' 16);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,GetByteArrayFromBuffer,The following statement contains a magic number: ret[3] = Convert.ToByte(dt.Hour.ToString()' 16);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,GetByteArrayFromBuffer,The following statement contains a magic number: ret[3] = Convert.ToByte(dt.Hour.ToString()' 16);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,GetByteArrayFromBuffer,The following statement contains a magic number: ret[4] = Convert.ToByte(dt.Minute.ToString()' 16);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,GetByteArrayFromBuffer,The following statement contains a magic number: ret[4] = Convert.ToByte(dt.Minute.ToString()' 16);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,GetByteArrayFromBuffer,The following statement contains a magic number: ret[5] = Convert.ToByte(dt.Second.ToString()' 16);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,GetByteArrayFromBuffer,The following statement contains a magic number: ret[5] = Convert.ToByte(dt.Second.ToString()' 16);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,GetByteArrayFromBuffer,The following statement contains a magic number: ret[6] = Convert.ToByte(dt.Millisecond.ToString("000").Substring(0' 2)' 16);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,GetByteArrayFromBuffer,The following statement contains a magic number: ret[6] = Convert.ToByte(dt.Millisecond.ToString("000").Substring(0' 2)' 16);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,GetByteArrayFromBuffer,The following statement contains a magic number: ret[6] = Convert.ToByte(dt.Millisecond.ToString("000").Substring(0' 2)' 16);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,GetByteArrayFromBuffer,The following statement contains a magic number: ret[7] = Convert.ToByte(dt.Millisecond.ToString("000").Substring(2) + ((byte)dt.DayOfWeek + 1)' 16);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,GetByteArrayFromBuffer,The following statement contains a magic number: ret[7] = Convert.ToByte(dt.Millisecond.ToString("000").Substring(2) + ((byte)dt.DayOfWeek + 1)' 16);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,GetByteArrayFromBuffer,The following statement contains a magic number: ret[7] = Convert.ToByte(dt.Millisecond.ToString("000").Substring(2) + ((byte)dt.DayOfWeek + 1)' 16);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,DiagnosticData,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,RequestDiagnosticData,The following statement contains a magic number: rparam[10] == 0xd0 && rparam[11] == 0xa5
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,DiagnosticData,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,RequestDiagnosticData,The following statement contains a magic number: rparam[10] == 0xd0 && rparam[11] == 0xa5
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,DiagnosticData,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,RequestDiagnosticData,The following statement contains a magic number: int answLen = rdata[6] * 0x100 + rdata[7];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,DiagnosticData,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,RequestDiagnosticData,The following statement contains a magic number: int answLen = rdata[6] * 0x100 + rdata[7];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,DiagnosticData,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,RequestDiagnosticData,The following statement contains a magic number: int linenr = 14;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,DiagnosticData,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,RequestDiagnosticData,The following statement contains a magic number: linenr + akAskSize - 14 > answLen
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,DiagnosticData,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,RequestDiagnosticData,The following statement contains a magic number: prev = S7FunctionBlockRow.BlockStatus.ReadBlockStatus(rdata' linenr + 2' akSelRegister'                                  prev);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,DiagnosticData,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,RequestDiagnosticData,The following statement contains a magic number: linenr += akAskSize + 2;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,VarTabReadData,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,RequestData,The following statement contains a magic number: rparam[10] == 0xd0 && rparam[11] == 0xa5
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,VarTabReadData,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,RequestData,The following statement contains a magic number: rparam[10] == 0xd0 && rparam[11] == 0xa5
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,VarTabReadData,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,RequestData,The following statement contains a magic number: int answLen = rdata[6] * 0x100 + rdata[7];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,VarTabReadData,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,RequestData,The following statement contains a magic number: int answLen = rdata[6] * 0x100 + rdata[7];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,VarTabReadData,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,RequestData,The following statement contains a magic number: int pos = 14;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,VarTabReadData,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,RequestData,The following statement contains a magic number: len = rdata[pos + 2] * 0x100 + rdata[pos + 3];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,VarTabReadData,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,RequestData,The following statement contains a magic number: len = rdata[pos + 2] * 0x100 + rdata[pos + 3];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,VarTabReadData,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,RequestData,The following statement contains a magic number: len % 2 != 0
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,VarTabReadData,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,RequestData,The following statement contains a magic number: PLCTags[i]._readValueFromBuffer(rdata' pos + 4);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,VarTabReadData,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,RequestData,The following statement contains a magic number: pos += 4 + len;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnectionConfiguration,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnectionConfiguration.cs,fixEnum,The following statement contains a magic number: idx = idx + PropertyName.Length + 2;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCNckTagTypeConverter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCNckTag.cs,ConvertFrom,The following statement contains a magic number: return new NC_Var(HexParse(sAr[0]' culture)' HexParse(sAr[1]' culture)' HexParse(sAr[2]' culture)' HexParse(sAr[3]' culture)' HexParse(sAr[4]' culture)' HexParse(sAr[5]' culture)' HexParse(sAr[6]' culture)' HexParse(sAr[7]' culture)).GetNckTag();
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCNckTagTypeConverter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCNckTag.cs,ConvertFrom,The following statement contains a magic number: return new NC_Var(HexParse(sAr[0]' culture)' HexParse(sAr[1]' culture)' HexParse(sAr[2]' culture)' HexParse(sAr[3]' culture)' HexParse(sAr[4]' culture)' HexParse(sAr[5]' culture)' HexParse(sAr[6]' culture)' HexParse(sAr[7]' culture)).GetNckTag();
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCNckTagTypeConverter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCNckTag.cs,ConvertFrom,The following statement contains a magic number: return new NC_Var(HexParse(sAr[0]' culture)' HexParse(sAr[1]' culture)' HexParse(sAr[2]' culture)' HexParse(sAr[3]' culture)' HexParse(sAr[4]' culture)' HexParse(sAr[5]' culture)' HexParse(sAr[6]' culture)' HexParse(sAr[7]' culture)).GetNckTag();
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCNckTagTypeConverter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCNckTag.cs,ConvertFrom,The following statement contains a magic number: return new NC_Var(HexParse(sAr[0]' culture)' HexParse(sAr[1]' culture)' HexParse(sAr[2]' culture)' HexParse(sAr[3]' culture)' HexParse(sAr[4]' culture)' HexParse(sAr[5]' culture)' HexParse(sAr[6]' culture)' HexParse(sAr[7]' culture)).GetNckTag();
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCNckTagTypeConverter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCNckTag.cs,ConvertFrom,The following statement contains a magic number: return new NC_Var(HexParse(sAr[0]' culture)' HexParse(sAr[1]' culture)' HexParse(sAr[2]' culture)' HexParse(sAr[3]' culture)' HexParse(sAr[4]' culture)' HexParse(sAr[5]' culture)' HexParse(sAr[6]' culture)' HexParse(sAr[7]' culture)).GetNckTag();
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCNckTagTypeConverter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCNckTag.cs,ConvertFrom,The following statement contains a magic number: return new NC_Var(HexParse(sAr[0]' culture)' HexParse(sAr[1]' culture)' HexParse(sAr[2]' culture)' HexParse(sAr[3]' culture)' HexParse(sAr[4]' culture)' HexParse(sAr[5]' culture)' HexParse(sAr[6]' culture)' HexParse(sAr[7]' culture)).GetNckTag();
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCNckTagTypeConverter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCNckTag.cs,ConvertFrom,The following statement contains a magic number: sAr.Length == 8
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCNckTagTypeConverter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCNckTag.cs,HexParse,The following statement contains a magic number: s = s.Substring(2);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,NC_Var,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCNckTag.cs,NC_Var,The following statement contains a magic number: this.Bereich_u_einheit = (byte)((byte)nckTag.NckArea << 5 | nckTag.NckUnit);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,NC_Var,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCNckTag.cs,GetNckTag,The following statement contains a magic number: byte _bereich = (byte)((bereich_u_einheit & 0xE0) >> 5);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,NC_Var,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCNckTag.cs,GetNckTag,The following statement contains a magic number: switch (this.Typ)              {                  case 1:                      dataType = TagDataType.Bool;                      break;                  case 3:                      dataType = TagDataType.Byte; //eNCK_LE_Int8;                      break;                  case 4:                      dataType = TagDataType.Word;                      break;                  case 5:                      dataType = TagDataType.Int; //eNCK_LE_Int16;                      break;                  case 6:                      dataType = TagDataType.Dword; //eNCK_LE_Uint32;                      break;                  case 7:                      dataType = TagDataType.Dint; //eNCK_LE_Int32;                      break;                  case 8:                      dataType = TagDataType.Float; //eNCK_LE_Float32;                      break;                  case 14:                      dataType = TagDataType.DateTime;                      break;                  case 15:                      dataType = TagDataType.LReal; //eNCK_LE_Float64;                      break;                  case 18:                      dataType = TagDataType.LInt; //eNCK_LE_Int64;                      break;                  case 19:                      //if (_bereich == 2)// && NC_Var.bausteintyp == 0x7f)                      //    dataType = TagDataType.String; //eNCK_LE_String;                      //else                      dataType = TagDataType.CharArray; //eNCK_LE_String;                        _ArraySize = this.Laenge;                      break;                  default:                      throw new Exception(string.Format("Unknown Type: {0}"' this.Typ));              }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,NC_Var,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCNckTag.cs,GetNckTag,The following statement contains a magic number: switch (this.Typ)              {                  case 1:                      dataType = TagDataType.Bool;                      break;                  case 3:                      dataType = TagDataType.Byte; //eNCK_LE_Int8;                      break;                  case 4:                      dataType = TagDataType.Word;                      break;                  case 5:                      dataType = TagDataType.Int; //eNCK_LE_Int16;                      break;                  case 6:                      dataType = TagDataType.Dword; //eNCK_LE_Uint32;                      break;                  case 7:                      dataType = TagDataType.Dint; //eNCK_LE_Int32;                      break;                  case 8:                      dataType = TagDataType.Float; //eNCK_LE_Float32;                      break;                  case 14:                      dataType = TagDataType.DateTime;                      break;                  case 15:                      dataType = TagDataType.LReal; //eNCK_LE_Float64;                      break;                  case 18:                      dataType = TagDataType.LInt; //eNCK_LE_Int64;                      break;                  case 19:                      //if (_bereich == 2)// && NC_Var.bausteintyp == 0x7f)                      //    dataType = TagDataType.String; //eNCK_LE_String;                      //else                      dataType = TagDataType.CharArray; //eNCK_LE_String;                        _ArraySize = this.Laenge;                      break;                  default:                      throw new Exception(string.Format("Unknown Type: {0}"' this.Typ));              }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,NC_Var,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCNckTag.cs,GetNckTag,The following statement contains a magic number: switch (this.Typ)              {                  case 1:                      dataType = TagDataType.Bool;                      break;                  case 3:                      dataType = TagDataType.Byte; //eNCK_LE_Int8;                      break;                  case 4:                      dataType = TagDataType.Word;                      break;                  case 5:                      dataType = TagDataType.Int; //eNCK_LE_Int16;                      break;                  case 6:                      dataType = TagDataType.Dword; //eNCK_LE_Uint32;                      break;                  case 7:                      dataType = TagDataType.Dint; //eNCK_LE_Int32;                      break;                  case 8:                      dataType = TagDataType.Float; //eNCK_LE_Float32;                      break;                  case 14:                      dataType = TagDataType.DateTime;                      break;                  case 15:                      dataType = TagDataType.LReal; //eNCK_LE_Float64;                      break;                  case 18:                      dataType = TagDataType.LInt; //eNCK_LE_Int64;                      break;                  case 19:                      //if (_bereich == 2)// && NC_Var.bausteintyp == 0x7f)                      //    dataType = TagDataType.String; //eNCK_LE_String;                      //else                      dataType = TagDataType.CharArray; //eNCK_LE_String;                        _ArraySize = this.Laenge;                      break;                  default:                      throw new Exception(string.Format("Unknown Type: {0}"' this.Typ));              }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,NC_Var,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCNckTag.cs,GetNckTag,The following statement contains a magic number: switch (this.Typ)              {                  case 1:                      dataType = TagDataType.Bool;                      break;                  case 3:                      dataType = TagDataType.Byte; //eNCK_LE_Int8;                      break;                  case 4:                      dataType = TagDataType.Word;                      break;                  case 5:                      dataType = TagDataType.Int; //eNCK_LE_Int16;                      break;                  case 6:                      dataType = TagDataType.Dword; //eNCK_LE_Uint32;                      break;                  case 7:                      dataType = TagDataType.Dint; //eNCK_LE_Int32;                      break;                  case 8:                      dataType = TagDataType.Float; //eNCK_LE_Float32;                      break;                  case 14:                      dataType = TagDataType.DateTime;                      break;                  case 15:                      dataType = TagDataType.LReal; //eNCK_LE_Float64;                      break;                  case 18:                      dataType = TagDataType.LInt; //eNCK_LE_Int64;                      break;                  case 19:                      //if (_bereich == 2)// && NC_Var.bausteintyp == 0x7f)                      //    dataType = TagDataType.String; //eNCK_LE_String;                      //else                      dataType = TagDataType.CharArray; //eNCK_LE_String;                        _ArraySize = this.Laenge;                      break;                  default:                      throw new Exception(string.Format("Unknown Type: {0}"' this.Typ));              }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,NC_Var,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCNckTag.cs,GetNckTag,The following statement contains a magic number: switch (this.Typ)              {                  case 1:                      dataType = TagDataType.Bool;                      break;                  case 3:                      dataType = TagDataType.Byte; //eNCK_LE_Int8;                      break;                  case 4:                      dataType = TagDataType.Word;                      break;                  case 5:                      dataType = TagDataType.Int; //eNCK_LE_Int16;                      break;                  case 6:                      dataType = TagDataType.Dword; //eNCK_LE_Uint32;                      break;                  case 7:                      dataType = TagDataType.Dint; //eNCK_LE_Int32;                      break;                  case 8:                      dataType = TagDataType.Float; //eNCK_LE_Float32;                      break;                  case 14:                      dataType = TagDataType.DateTime;                      break;                  case 15:                      dataType = TagDataType.LReal; //eNCK_LE_Float64;                      break;                  case 18:                      dataType = TagDataType.LInt; //eNCK_LE_Int64;                      break;                  case 19:                      //if (_bereich == 2)// && NC_Var.bausteintyp == 0x7f)                      //    dataType = TagDataType.String; //eNCK_LE_String;                      //else                      dataType = TagDataType.CharArray; //eNCK_LE_String;                        _ArraySize = this.Laenge;                      break;                  default:                      throw new Exception(string.Format("Unknown Type: {0}"' this.Typ));              }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,NC_Var,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCNckTag.cs,GetNckTag,The following statement contains a magic number: switch (this.Typ)              {                  case 1:                      dataType = TagDataType.Bool;                      break;                  case 3:                      dataType = TagDataType.Byte; //eNCK_LE_Int8;                      break;                  case 4:                      dataType = TagDataType.Word;                      break;                  case 5:                      dataType = TagDataType.Int; //eNCK_LE_Int16;                      break;                  case 6:                      dataType = TagDataType.Dword; //eNCK_LE_Uint32;                      break;                  case 7:                      dataType = TagDataType.Dint; //eNCK_LE_Int32;                      break;                  case 8:                      dataType = TagDataType.Float; //eNCK_LE_Float32;                      break;                  case 14:                      dataType = TagDataType.DateTime;                      break;                  case 15:                      dataType = TagDataType.LReal; //eNCK_LE_Float64;                      break;                  case 18:                      dataType = TagDataType.LInt; //eNCK_LE_Int64;                      break;                  case 19:                      //if (_bereich == 2)// && NC_Var.bausteintyp == 0x7f)                      //    dataType = TagDataType.String; //eNCK_LE_String;                      //else                      dataType = TagDataType.CharArray; //eNCK_LE_String;                        _ArraySize = this.Laenge;                      break;                  default:                      throw new Exception(string.Format("Unknown Type: {0}"' this.Typ));              }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,NC_Var,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCNckTag.cs,GetNckTag,The following statement contains a magic number: switch (this.Typ)              {                  case 1:                      dataType = TagDataType.Bool;                      break;                  case 3:                      dataType = TagDataType.Byte; //eNCK_LE_Int8;                      break;                  case 4:                      dataType = TagDataType.Word;                      break;                  case 5:                      dataType = TagDataType.Int; //eNCK_LE_Int16;                      break;                  case 6:                      dataType = TagDataType.Dword; //eNCK_LE_Uint32;                      break;                  case 7:                      dataType = TagDataType.Dint; //eNCK_LE_Int32;                      break;                  case 8:                      dataType = TagDataType.Float; //eNCK_LE_Float32;                      break;                  case 14:                      dataType = TagDataType.DateTime;                      break;                  case 15:                      dataType = TagDataType.LReal; //eNCK_LE_Float64;                      break;                  case 18:                      dataType = TagDataType.LInt; //eNCK_LE_Int64;                      break;                  case 19:                      //if (_bereich == 2)// && NC_Var.bausteintyp == 0x7f)                      //    dataType = TagDataType.String; //eNCK_LE_String;                      //else                      dataType = TagDataType.CharArray; //eNCK_LE_String;                        _ArraySize = this.Laenge;                      break;                  default:                      throw new Exception(string.Format("Unknown Type: {0}"' this.Typ));              }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,NC_Var,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCNckTag.cs,GetNckTag,The following statement contains a magic number: switch (this.Typ)              {                  case 1:                      dataType = TagDataType.Bool;                      break;                  case 3:                      dataType = TagDataType.Byte; //eNCK_LE_Int8;                      break;                  case 4:                      dataType = TagDataType.Word;                      break;                  case 5:                      dataType = TagDataType.Int; //eNCK_LE_Int16;                      break;                  case 6:                      dataType = TagDataType.Dword; //eNCK_LE_Uint32;                      break;                  case 7:                      dataType = TagDataType.Dint; //eNCK_LE_Int32;                      break;                  case 8:                      dataType = TagDataType.Float; //eNCK_LE_Float32;                      break;                  case 14:                      dataType = TagDataType.DateTime;                      break;                  case 15:                      dataType = TagDataType.LReal; //eNCK_LE_Float64;                      break;                  case 18:                      dataType = TagDataType.LInt; //eNCK_LE_Int64;                      break;                  case 19:                      //if (_bereich == 2)// && NC_Var.bausteintyp == 0x7f)                      //    dataType = TagDataType.String; //eNCK_LE_String;                      //else                      dataType = TagDataType.CharArray; //eNCK_LE_String;                        _ArraySize = this.Laenge;                      break;                  default:                      throw new Exception(string.Format("Unknown Type: {0}"' this.Typ));              }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,NC_Var,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCNckTag.cs,GetNckTag,The following statement contains a magic number: switch (this.Typ)              {                  case 1:                      dataType = TagDataType.Bool;                      break;                  case 3:                      dataType = TagDataType.Byte; //eNCK_LE_Int8;                      break;                  case 4:                      dataType = TagDataType.Word;                      break;                  case 5:                      dataType = TagDataType.Int; //eNCK_LE_Int16;                      break;                  case 6:                      dataType = TagDataType.Dword; //eNCK_LE_Uint32;                      break;                  case 7:                      dataType = TagDataType.Dint; //eNCK_LE_Int32;                      break;                  case 8:                      dataType = TagDataType.Float; //eNCK_LE_Float32;                      break;                  case 14:                      dataType = TagDataType.DateTime;                      break;                  case 15:                      dataType = TagDataType.LReal; //eNCK_LE_Float64;                      break;                  case 18:                      dataType = TagDataType.LInt; //eNCK_LE_Int64;                      break;                  case 19:                      //if (_bereich == 2)// && NC_Var.bausteintyp == 0x7f)                      //    dataType = TagDataType.String; //eNCK_LE_String;                      //else                      dataType = TagDataType.CharArray; //eNCK_LE_String;                        _ArraySize = this.Laenge;                      break;                  default:                      throw new Exception(string.Format("Unknown Type: {0}"' this.Typ));              }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,NC_Var,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCNckTag.cs,GetNckTag,The following statement contains a magic number: switch (this.Typ)              {                  case 1:                      dataType = TagDataType.Bool;                      break;                  case 3:                      dataType = TagDataType.Byte; //eNCK_LE_Int8;                      break;                  case 4:                      dataType = TagDataType.Word;                      break;                  case 5:                      dataType = TagDataType.Int; //eNCK_LE_Int16;                      break;                  case 6:                      dataType = TagDataType.Dword; //eNCK_LE_Uint32;                      break;                  case 7:                      dataType = TagDataType.Dint; //eNCK_LE_Int32;                      break;                  case 8:                      dataType = TagDataType.Float; //eNCK_LE_Float32;                      break;                  case 14:                      dataType = TagDataType.DateTime;                      break;                  case 15:                      dataType = TagDataType.LReal; //eNCK_LE_Float64;                      break;                  case 18:                      dataType = TagDataType.LInt; //eNCK_LE_Int64;                      break;                  case 19:                      //if (_bereich == 2)// && NC_Var.bausteintyp == 0x7f)                      //    dataType = TagDataType.String; //eNCK_LE_String;                      //else                      dataType = TagDataType.CharArray; //eNCK_LE_String;                        _ArraySize = this.Laenge;                      break;                  default:                      throw new Exception(string.Format("Unknown Type: {0}"' this.Typ));              }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,NC_Var,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCNckTag.cs,GetNC_Var,The following statement contains a magic number: ret.Bereich_u_einheit = (byte)((byte)nckTag.NckArea << 5 | nckTag.NckUnit);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,NC_Var,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCNckTag.cs,GetNckType,The following statement contains a magic number: switch (type)              {                  case TagDataType.Bool:                      return 1;                  case TagDataType.Byte:                      return 3;                  case TagDataType.Word:                      return 4;                  case TagDataType.Int:                      return 5;                  case TagDataType.Dword:                      return 6;                  case TagDataType.Dint:                      return 7;                  case TagDataType.Float:                      return 8;                  case TagDataType.DateTime:                      return 14;                  case TagDataType.LReal:                      return 15;                  case TagDataType.LInt:                      return 18;                  case TagDataType.String:                  case TagDataType.CharArray:                      return 19;                  default:                      return 0;              }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,NC_Var,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCNckTag.cs,GetNckType,The following statement contains a magic number: switch (type)              {                  case TagDataType.Bool:                      return 1;                  case TagDataType.Byte:                      return 3;                  case TagDataType.Word:                      return 4;                  case TagDataType.Int:                      return 5;                  case TagDataType.Dword:                      return 6;                  case TagDataType.Dint:                      return 7;                  case TagDataType.Float:                      return 8;                  case TagDataType.DateTime:                      return 14;                  case TagDataType.LReal:                      return 15;                  case TagDataType.LInt:                      return 18;                  case TagDataType.String:                  case TagDataType.CharArray:                      return 19;                  default:                      return 0;              }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,NC_Var,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCNckTag.cs,GetNckType,The following statement contains a magic number: switch (type)              {                  case TagDataType.Bool:                      return 1;                  case TagDataType.Byte:                      return 3;                  case TagDataType.Word:                      return 4;                  case TagDataType.Int:                      return 5;                  case TagDataType.Dword:                      return 6;                  case TagDataType.Dint:                      return 7;                  case TagDataType.Float:                      return 8;                  case TagDataType.DateTime:                      return 14;                  case TagDataType.LReal:                      return 15;                  case TagDataType.LInt:                      return 18;                  case TagDataType.String:                  case TagDataType.CharArray:                      return 19;                  default:                      return 0;              }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,NC_Var,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCNckTag.cs,GetNckType,The following statement contains a magic number: switch (type)              {                  case TagDataType.Bool:                      return 1;                  case TagDataType.Byte:                      return 3;                  case TagDataType.Word:                      return 4;                  case TagDataType.Int:                      return 5;                  case TagDataType.Dword:                      return 6;                  case TagDataType.Dint:                      return 7;                  case TagDataType.Float:                      return 8;                  case TagDataType.DateTime:                      return 14;                  case TagDataType.LReal:                      return 15;                  case TagDataType.LInt:                      return 18;                  case TagDataType.String:                  case TagDataType.CharArray:                      return 19;                  default:                      return 0;              }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,NC_Var,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCNckTag.cs,GetNckType,The following statement contains a magic number: switch (type)              {                  case TagDataType.Bool:                      return 1;                  case TagDataType.Byte:                      return 3;                  case TagDataType.Word:                      return 4;                  case TagDataType.Int:                      return 5;                  case TagDataType.Dword:                      return 6;                  case TagDataType.Dint:                      return 7;                  case TagDataType.Float:                      return 8;                  case TagDataType.DateTime:                      return 14;                  case TagDataType.LReal:                      return 15;                  case TagDataType.LInt:                      return 18;                  case TagDataType.String:                  case TagDataType.CharArray:                      return 19;                  default:                      return 0;              }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,NC_Var,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCNckTag.cs,GetNckType,The following statement contains a magic number: switch (type)              {                  case TagDataType.Bool:                      return 1;                  case TagDataType.Byte:                      return 3;                  case TagDataType.Word:                      return 4;                  case TagDataType.Int:                      return 5;                  case TagDataType.Dword:                      return 6;                  case TagDataType.Dint:                      return 7;                  case TagDataType.Float:                      return 8;                  case TagDataType.DateTime:                      return 14;                  case TagDataType.LReal:                      return 15;                  case TagDataType.LInt:                      return 18;                  case TagDataType.String:                  case TagDataType.CharArray:                      return 19;                  default:                      return 0;              }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,NC_Var,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCNckTag.cs,GetNckType,The following statement contains a magic number: switch (type)              {                  case TagDataType.Bool:                      return 1;                  case TagDataType.Byte:                      return 3;                  case TagDataType.Word:                      return 4;                  case TagDataType.Int:                      return 5;                  case TagDataType.Dword:                      return 6;                  case TagDataType.Dint:                      return 7;                  case TagDataType.Float:                      return 8;                  case TagDataType.DateTime:                      return 14;                  case TagDataType.LReal:                      return 15;                  case TagDataType.LInt:                      return 18;                  case TagDataType.String:                  case TagDataType.CharArray:                      return 19;                  default:                      return 0;              }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,NC_Var,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCNckTag.cs,GetNckType,The following statement contains a magic number: switch (type)              {                  case TagDataType.Bool:                      return 1;                  case TagDataType.Byte:                      return 3;                  case TagDataType.Word:                      return 4;                  case TagDataType.Int:                      return 5;                  case TagDataType.Dword:                      return 6;                  case TagDataType.Dint:                      return 7;                  case TagDataType.Float:                      return 8;                  case TagDataType.DateTime:                      return 14;                  case TagDataType.LReal:                      return 15;                  case TagDataType.LInt:                      return 18;                  case TagDataType.String:                  case TagDataType.CharArray:                      return 19;                  default:                      return 0;              }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,NC_Var,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCNckTag.cs,GetNckType,The following statement contains a magic number: switch (type)              {                  case TagDataType.Bool:                      return 1;                  case TagDataType.Byte:                      return 3;                  case TagDataType.Word:                      return 4;                  case TagDataType.Int:                      return 5;                  case TagDataType.Dword:                      return 6;                  case TagDataType.Dint:                      return 7;                  case TagDataType.Float:                      return 8;                  case TagDataType.DateTime:                      return 14;                  case TagDataType.LReal:                      return 15;                  case TagDataType.LInt:                      return 18;                  case TagDataType.String:                  case TagDataType.CharArray:                      return 19;                  default:                      return 0;              }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,NC_Var,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCNckTag.cs,GetNckType,The following statement contains a magic number: switch (type)              {                  case TagDataType.Bool:                      return 1;                  case TagDataType.Byte:                      return 3;                  case TagDataType.Word:                      return 4;                  case TagDataType.Int:                      return 5;                  case TagDataType.Dword:                      return 6;                  case TagDataType.Dint:                      return 7;                  case TagDataType.Float:                      return 8;                  case TagDataType.DateTime:                      return 14;                  case TagDataType.LReal:                      return 15;                  case TagDataType.LInt:                      return 18;                  case TagDataType.String:                  case TagDataType.CharArray:                      return 19;                  default:                      return 0;              }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,ByteHexTypeConverter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCNckTag.cs,ConvertFrom,The following statement contains a magic number: s = s.Substring(2);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,UInt16HexTypeConverter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCNckTag.cs,ConvertFrom,The following statement contains a magic number: s = s.Substring(2);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTag.cs,PLCTag,The following statement contains a magic number: this.ChangeDataTypeFromString(values[2]);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTag.cs,PLCTag,The following statement contains a magic number: values.Length > 2
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTag.cs,PLCTag,The following statement contains a magic number: this.ChangeDataTypeStringFormatFromString(values[3]);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTag.cs,PLCTag,The following statement contains a magic number: values.Length > 3
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTag.cs,ParseControlValueFromString,The following statement contains a magic number: switch (this.TagDataType)              {                  case TagDataType.S5Time:                  case TagDataType.Time:                  case TagDataType.LTime:                      if (myValueStrip.Contains("t#") || myValueStrip.Contains("s5t#"))                      {                          Controlvalue = Helper.GetTimespanFromS5TimeorTime(myValue);                      }                      else                      {                          TimeSpan ret;                          TimeSpan.TryParse(myValue' out ret);                          Controlvalue = ret;                      }                      break;                  case TagDataType.BCDWord:                  case TagDataType.Int:                      if (myValueStrip.Contains("w#16#") || myValueStrip.Contains("dw#16#"))                      {                          Controlvalue = Convert.ToInt16(Helper.GetIntFromHexString(myValue));                      }                      else if (myValue.StartsWith("2#"))                      {                          Controlvalue = Convert.ToInt16(Helper.GetIntFromBinString(myValue));                      }                      else                      {                          Int16 ret;                          Int16.TryParse(myValue' out ret);                          Controlvalue = ret;                      }                      break;                  case TagDataType.BCDDWord:                  case TagDataType.Dint:                      if (myValueStrip.Contains("w#16#") || myValueStrip.Contains("dw#16#"))                          Controlvalue = Convert.ToInt32(Helper.GetIntFromHexString(myValue));                      else if (myValue.StartsWith("2#"))                          Controlvalue = Convert.ToInt32(Helper.GetIntFromBinString(myValue));                      else                          try                          {                              if (!string.IsNullOrEmpty(myValue))                                  Controlvalue = Int32.Parse(myValue);                          }                          catch (Exception) { }                      break;                  case TagDataType.BCDArray:                      if (myValueStrip.Contains("w#16#") || myValueStrip.Contains("dw#16#"))                          Controlvalue = Convert.ToUInt64(Helper.GetIntFromHexString(myValue));                      else if (myValue.StartsWith("2#"))                          Controlvalue = Convert.ToUInt64(Helper.GetIntFromBinString(myValue));                      else                          try                          {                              if (!string.IsNullOrEmpty(myValue))                                  Controlvalue = UInt64.Parse(myValue);                          }                          catch (Exception) { }                      break;                  case TagDataType.Byte:                      if (myValueStrip.Contains("w#16#") || myValueStrip.Contains("dw#16#"))                      {                          Controlvalue = Convert.ToByte(Helper.GetUIntFromHexString(myValue));                      }                      else if (myValue.StartsWith("2#"))                      {                          Controlvalue = Convert.ToByte(Helper.GetIntFromBinString(myValue));                      }                      else                      {                          Byte ret;                          Byte.TryParse(myValue' out ret);                          Controlvalue = ret;                      }                      break;                  case TagDataType.BCDByte:                  case TagDataType.SByte:                      if (myValueStrip.Contains("w#16#") || myValueStrip.Contains("dw#16#"))                      {                          Controlvalue = Convert.ToSByte(Helper.GetIntFromHexString(myValue));                      }                      else if (myValue.StartsWith("2#"))                      {                          Controlvalue = Convert.ToSByte(Helper.GetIntFromBinString(myValue));                      }                      else                      {                          SByte ret;                          SByte.TryParse(myValue' out ret);                          Controlvalue = ret;                      }                      break;                  case TagDataType.Word:                      if (myValueStrip.Contains("w#16#") || myValueStrip.Contains("dw#16#"))                      {                          Controlvalue = Convert.ToUInt16(Helper.GetUIntFromHexString(myValue));                      }                      else if (myValue.StartsWith("2#"))                      {                          Controlvalue = Convert.ToUInt16(Helper.GetIntFromBinString(myValue));                      }                      else                      {                          UInt16 ret;                          UInt16.TryParse(myValue' out ret);                          Controlvalue = ret;                      }                      break;                  case TagDataType.Dword:                      if (myValueStrip.Contains("w#16#") || myValueStrip.Contains("dw#16#"))                      {                          Controlvalue = Convert.ToUInt32(Helper.GetUIntFromHexString(myValue));                      }                      else if (myValue.StartsWith("2#"))                      {                          Controlvalue = Convert.ToUInt32(Helper.GetIntFromBinString(myValue));                      }                      else                      {                          UInt32 ret;                          UInt32.TryParse(myValue' out ret);                          Controlvalue = ret;                      }                      break;                  case TagDataType.LInt:                      {                          Int64 ret;                          Int64.TryParse(myValue' out ret);                          Controlvalue = ret;                      }                      break;                  case TagDataType.LWord:                      {                          UInt64 ret;                          UInt64.TryParse(myValue' out ret);                          Controlvalue = ret;                      }                      break;                  case TagDataType.LReal:                      {                          double ret;                          double.TryParse(myValue' out ret);                          Controlvalue = ret;                      }                      break;                  case TagDataType.Bool:                      if (myValue == "1")                          Controlvalue = true;                      else if (myValue == "0")                          Controlvalue = false;                      else                      {                          bool bvalue;                          bool.TryParse(myValue' out bvalue);                          Controlvalue = bvalue;                      }                      break;                  case TagDataType.String:                  case TagDataType.CharArray:                      Controlvalue = myValue;                      break;                  case TagDataType.DateTime:                  case TagDataType.Date:                  case TagDataType.TimeOfDay:                  case TagDataType.LTimeOfDay:                      if (myValueStrip.StartsWith("d#"))                          Controlvalue = Helper.GetDateTimeFromDateString(myValue);                      else if (myValueStrip.StartsWith("tod#"))                          Controlvalue = Helper.GetDateTimeFromTimeOfDayString(myValue);                      else if (myValueStrip.StartsWith("dt#"))                          Controlvalue = Helper.GetDateTimeFromDateAndTimeString(myValue);                      else if (!string.IsNullOrEmpty(myValue))                          try                          {                              if (!string.IsNullOrEmpty(myValue))                                  Controlvalue = DateTime.Parse(myValue);                          }                          catch (Exception) { }                      break;                  case TagDataType.ByteArray:                      {                          if (myValueStrip.Length > 2 && myValueStrip[0] == '{' && myValueStrip[myValueStrip.Length - 1] == '}')                              myValueStrip = myValueStrip.Substring(1' myValueStrip.Length - 2);                          string[] vals = myValueStrip.Split(''');                          byte[] wrt = new byte[vals.Length];                          int i = 0;                            foreach (string val in vals)                          {                              try                              {                                  wrt[i++] = Convert.ToByte(val);                              }                              catch (Exception)                              { }                          }                          Controlvalue = wrt;                      }                      break;                  case TagDataType.Float:                      {                          Single val;                          Controlvalue = Single.TryParse(myValue' out val);                          Controlvalue = val;                      }                      break;                      /*                        *  case TagDataType.TimeOfDay:                              case TagDataType.Float:                          */              }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTag.cs,ParseControlValueFromString,The following statement contains a magic number: switch (this.TagDataType)              {                  case TagDataType.S5Time:                  case TagDataType.Time:                  case TagDataType.LTime:                      if (myValueStrip.Contains("t#") || myValueStrip.Contains("s5t#"))                      {                          Controlvalue = Helper.GetTimespanFromS5TimeorTime(myValue);                      }                      else                      {                          TimeSpan ret;                          TimeSpan.TryParse(myValue' out ret);                          Controlvalue = ret;                      }                      break;                  case TagDataType.BCDWord:                  case TagDataType.Int:                      if (myValueStrip.Contains("w#16#") || myValueStrip.Contains("dw#16#"))                      {                          Controlvalue = Convert.ToInt16(Helper.GetIntFromHexString(myValue));                      }                      else if (myValue.StartsWith("2#"))                      {                          Controlvalue = Convert.ToInt16(Helper.GetIntFromBinString(myValue));                      }                      else                      {                          Int16 ret;                          Int16.TryParse(myValue' out ret);                          Controlvalue = ret;                      }                      break;                  case TagDataType.BCDDWord:                  case TagDataType.Dint:                      if (myValueStrip.Contains("w#16#") || myValueStrip.Contains("dw#16#"))                          Controlvalue = Convert.ToInt32(Helper.GetIntFromHexString(myValue));                      else if (myValue.StartsWith("2#"))                          Controlvalue = Convert.ToInt32(Helper.GetIntFromBinString(myValue));                      else                          try                          {                              if (!string.IsNullOrEmpty(myValue))                                  Controlvalue = Int32.Parse(myValue);                          }                          catch (Exception) { }                      break;                  case TagDataType.BCDArray:                      if (myValueStrip.Contains("w#16#") || myValueStrip.Contains("dw#16#"))                          Controlvalue = Convert.ToUInt64(Helper.GetIntFromHexString(myValue));                      else if (myValue.StartsWith("2#"))                          Controlvalue = Convert.ToUInt64(Helper.GetIntFromBinString(myValue));                      else                          try                          {                              if (!string.IsNullOrEmpty(myValue))                                  Controlvalue = UInt64.Parse(myValue);                          }                          catch (Exception) { }                      break;                  case TagDataType.Byte:                      if (myValueStrip.Contains("w#16#") || myValueStrip.Contains("dw#16#"))                      {                          Controlvalue = Convert.ToByte(Helper.GetUIntFromHexString(myValue));                      }                      else if (myValue.StartsWith("2#"))                      {                          Controlvalue = Convert.ToByte(Helper.GetIntFromBinString(myValue));                      }                      else                      {                          Byte ret;                          Byte.TryParse(myValue' out ret);                          Controlvalue = ret;                      }                      break;                  case TagDataType.BCDByte:                  case TagDataType.SByte:                      if (myValueStrip.Contains("w#16#") || myValueStrip.Contains("dw#16#"))                      {                          Controlvalue = Convert.ToSByte(Helper.GetIntFromHexString(myValue));                      }                      else if (myValue.StartsWith("2#"))                      {                          Controlvalue = Convert.ToSByte(Helper.GetIntFromBinString(myValue));                      }                      else                      {                          SByte ret;                          SByte.TryParse(myValue' out ret);                          Controlvalue = ret;                      }                      break;                  case TagDataType.Word:                      if (myValueStrip.Contains("w#16#") || myValueStrip.Contains("dw#16#"))                      {                          Controlvalue = Convert.ToUInt16(Helper.GetUIntFromHexString(myValue));                      }                      else if (myValue.StartsWith("2#"))                      {                          Controlvalue = Convert.ToUInt16(Helper.GetIntFromBinString(myValue));                      }                      else                      {                          UInt16 ret;                          UInt16.TryParse(myValue' out ret);                          Controlvalue = ret;                      }                      break;                  case TagDataType.Dword:                      if (myValueStrip.Contains("w#16#") || myValueStrip.Contains("dw#16#"))                      {                          Controlvalue = Convert.ToUInt32(Helper.GetUIntFromHexString(myValue));                      }                      else if (myValue.StartsWith("2#"))                      {                          Controlvalue = Convert.ToUInt32(Helper.GetIntFromBinString(myValue));                      }                      else                      {                          UInt32 ret;                          UInt32.TryParse(myValue' out ret);                          Controlvalue = ret;                      }                      break;                  case TagDataType.LInt:                      {                          Int64 ret;                          Int64.TryParse(myValue' out ret);                          Controlvalue = ret;                      }                      break;                  case TagDataType.LWord:                      {                          UInt64 ret;                          UInt64.TryParse(myValue' out ret);                          Controlvalue = ret;                      }                      break;                  case TagDataType.LReal:                      {                          double ret;                          double.TryParse(myValue' out ret);                          Controlvalue = ret;                      }                      break;                  case TagDataType.Bool:                      if (myValue == "1")                          Controlvalue = true;                      else if (myValue == "0")                          Controlvalue = false;                      else                      {                          bool bvalue;                          bool.TryParse(myValue' out bvalue);                          Controlvalue = bvalue;                      }                      break;                  case TagDataType.String:                  case TagDataType.CharArray:                      Controlvalue = myValue;                      break;                  case TagDataType.DateTime:                  case TagDataType.Date:                  case TagDataType.TimeOfDay:                  case TagDataType.LTimeOfDay:                      if (myValueStrip.StartsWith("d#"))                          Controlvalue = Helper.GetDateTimeFromDateString(myValue);                      else if (myValueStrip.StartsWith("tod#"))                          Controlvalue = Helper.GetDateTimeFromTimeOfDayString(myValue);                      else if (myValueStrip.StartsWith("dt#"))                          Controlvalue = Helper.GetDateTimeFromDateAndTimeString(myValue);                      else if (!string.IsNullOrEmpty(myValue))                          try                          {                              if (!string.IsNullOrEmpty(myValue))                                  Controlvalue = DateTime.Parse(myValue);                          }                          catch (Exception) { }                      break;                  case TagDataType.ByteArray:                      {                          if (myValueStrip.Length > 2 && myValueStrip[0] == '{' && myValueStrip[myValueStrip.Length - 1] == '}')                              myValueStrip = myValueStrip.Substring(1' myValueStrip.Length - 2);                          string[] vals = myValueStrip.Split(''');                          byte[] wrt = new byte[vals.Length];                          int i = 0;                            foreach (string val in vals)                          {                              try                              {                                  wrt[i++] = Convert.ToByte(val);                              }                              catch (Exception)                              { }                          }                          Controlvalue = wrt;                      }                      break;                  case TagDataType.Float:                      {                          Single val;                          Controlvalue = Single.TryParse(myValue' out val);                          Controlvalue = val;                      }                      break;                      /*                        *  case TagDataType.TimeOfDay:                              case TagDataType.Float:                          */              }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTag.cs,GetValueAsStringInternal,The following statement contains a magic number: switch (this.TagDataType)                  {                      case TagDataType.S5Time:                          {                              if (DataTypeStringFormat == TagDisplayDataType.S5Time)                              {                                  var bt = new byte[2];                                  libnodave.putS5Timeat(bt' 0' (TimeSpan)myValue);                                  return Helper.GetS5Time(bt[0]' bt[1]);                              }                              return ((TimeSpan)myValue).ToString();                          }                      case TagDataType.Time:                      case TagDataType.LTime:                          {                              var tm = (TimeSpan)myValue;                              var ret = new StringBuilder("T#");                              if (tm.TotalMilliseconds < 0) ret.Append("-");                              if (tm.Days != 0) ret.Append(tm.Days + "D");                              if (tm.Hours != 0) ret.Append(tm.Hours + "H");                              if (tm.Minutes != 0) ret.Append(tm.Minutes + "M");                              if (tm.Seconds != 0) ret.Append(tm.Seconds + "S");                              if (tm.Milliseconds != 0) ret.Append(tm.Milliseconds + "MS");                              return ret.ToString();                          }                      case TagDataType.Bool:                          if (DataTypeStringFormat == TagDisplayDataType.Binary)                          {                              if (((bool)myValue) == true)                                  return "1";                              return "0";                          }                          return myValue.ToString();                      case TagDataType.DateTime:                      case TagDataType.Date:                      case TagDataType.TimeOfDay:                      case TagDataType.LTimeOfDay:                          if (DataTypeStringFormat == TagDisplayDataType.S7DateTime)                          {                              DateTime ak = (DateTime)myValue;                              StringBuilder sb = new StringBuilder();                              sb.Append("DT#");                              sb.Append(ak.Year.ToString().Substring(2));                              sb.Append("-");                              sb.Append(ak.Month);                              sb.Append("-");                              sb.Append(ak.Day);                              sb.Append("-");                              sb.Append(ak.Hour);                              sb.Append(":");                              sb.Append(ak.Minute);                              sb.Append(":");                              sb.Append(ak.Second);                              sb.Append(".");                              sb.Append(ak.Millisecond.ToString().PadRight(3' '0'));                              return sb.ToString();                          }                          else if (DataTypeStringFormat == TagDisplayDataType.S7Date)                          {                              DateTime ak = (DateTime)myValue;                              StringBuilder sb = new StringBuilder();                              sb.Append("D#");                              sb.Append(ak.Year);                              sb.Append("-");                              sb.Append(ak.Month);                              sb.Append("-");                              sb.Append(ak.Day);                              return sb.ToString();                          }                          else if (DataTypeStringFormat == TagDisplayDataType.S7TimeOfDay)                          {                              DateTime ak = (DateTime)myValue;                              StringBuilder sb = new StringBuilder();                              sb.Append("TOD#");                              sb.Append(ak.Hour);                              sb.Append(":");                              sb.Append(ak.Minute);                              sb.Append(":");                              sb.Append(ak.Second);                              sb.Append(".");                              sb.Append(ak.Millisecond.ToString().PadRight(3' '0'));                              return sb.ToString();                          }                          return myValue.ToString();                        case TagDataType.Int:                      case TagDataType.Dint:                      case TagDataType.LWord:                      case TagDataType.LInt:                      case TagDataType.LReal:                      case TagDataType.Byte:                      case TagDataType.SByte:                      case TagDataType.Word:                      case TagDataType.Dword:                      case TagDataType.Float:                      case TagDataType.BCDByte:                      case TagDataType.BCDWord:                      case TagDataType.BCDDWord:                          IFormattable val = myValue as IFormattable ?? 0;                          switch (DataTypeStringFormat)                          {                              case TagDisplayDataType.String:                                  switch (this.TagDataType)                                  {                                      case TagDataType.Int:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((Int16)myValue));                                      case TagDataType.Dint:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((Int32)myValue));                                      case TagDataType.LInt:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((Int64)myValue));                                      case TagDataType.Byte:                                          return Encoding.ASCII.GetString(new[] { (Byte)myValue });                                      case TagDataType.SByte:                                          return Encoding.ASCII.GetString(new[] { BitConverter.GetBytes((SByte)myValue)[0] });                                      case TagDataType.Word:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((UInt16)myValue));                                      case TagDataType.Dword:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((UInt32)myValue));                                      case TagDataType.LWord:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((UInt64)myValue));                                      case TagDataType.Float:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((Single)myValue));                                      case TagDataType.LReal:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((Double)myValue));                                      case TagDataType.BCDByte:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((Byte)myValue));                                      case TagDataType.BCDWord:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((UInt16)myValue));                                      case TagDataType.BCDDWord:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((UInt32)myValue));                                  }                                  break;                              case TagDisplayDataType.Pointer:                                  return "P#" + (Convert.ToInt32(myValue) / 8).ToString() + "." + (Convert.ToInt32(myValue) % 8).ToString();                                  break;                              case TagDisplayDataType.Hexadecimal:                                  string ad = "";                                  switch (_internalGetSize())                                  {                                      case 1:                                          ad = "B#16#";                                          break;                                      case 2:                                          ad = "W#16#";                                          break;                                      case 4:                                          ad = "DW#16#";                                          break;                                      case 8:                                          ad = "L#16#";                                          break;                                  }                                  return ad + val.ToString("X"' NumberFormatInfo.CurrentInfo).PadLeft(_internalGetSize() * 2' '0');                              case TagDisplayDataType.Binary:                                  byte[] bt = new byte[] { };                                  switch (this.TagDataType)                                  {                                      case TagDataType.Int:                                          bt = BitConverter.GetBytes((Int16)myValue);                                          break;                                      case TagDataType.Dint:                                          bt = BitConverter.GetBytes((Int32)myValue);                                          break;                                      case TagDataType.LInt:                                          bt = BitConverter.GetBytes((Int64)myValue);                                          break;                                      case TagDataType.Byte:                                          bt = new byte[] { (byte)myValue };                                          break;                                      case TagDataType.SByte:                                          bt = new byte[] { (byte)myValue };                                          break;                                      case TagDataType.Word:                                          bt = BitConverter.GetBytes((UInt16)myValue);                                          break;                                      case TagDataType.Dword:                                          bt = BitConverter.GetBytes((UInt32)myValue);                                          break;                                      case TagDataType.LWord:                                          bt = BitConverter.GetBytes((UInt64)myValue);                                          break;                                      case TagDataType.Float:                                          bt = BitConverter.GetBytes((float)myValue);                                          break;                                      case TagDataType.LReal:                                          bt = BitConverter.GetBytes((double)myValue);                                          break;                                      case TagDataType.BCDByte:                                          bt = BitConverter.GetBytes((byte)myValue);                                          break;                                      case TagDataType.BCDWord:                                          bt = BitConverter.GetBytes((Int16)myValue);                                          break;                                      case TagDataType.BCDDWord:                                          bt = BitConverter.GetBytes((Int32)myValue);                                          break;                                  }                                  string ret = "";                                  foreach (byte b in bt)                                  {                                      if (ret != "") ret = "_" + ret;                                      ret = libnodave.dec2bin(b).Substring(0' 4) + "_" + libnodave.dec2bin(b).Substring(4' 4) + ret;                                    }                                  return "2#" + ret;                            }                          return val.ToString();                  }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTag.cs,GetValueAsStringInternal,The following statement contains a magic number: switch (this.TagDataType)                  {                      case TagDataType.S5Time:                          {                              if (DataTypeStringFormat == TagDisplayDataType.S5Time)                              {                                  var bt = new byte[2];                                  libnodave.putS5Timeat(bt' 0' (TimeSpan)myValue);                                  return Helper.GetS5Time(bt[0]' bt[1]);                              }                              return ((TimeSpan)myValue).ToString();                          }                      case TagDataType.Time:                      case TagDataType.LTime:                          {                              var tm = (TimeSpan)myValue;                              var ret = new StringBuilder("T#");                              if (tm.TotalMilliseconds < 0) ret.Append("-");                              if (tm.Days != 0) ret.Append(tm.Days + "D");                              if (tm.Hours != 0) ret.Append(tm.Hours + "H");                              if (tm.Minutes != 0) ret.Append(tm.Minutes + "M");                              if (tm.Seconds != 0) ret.Append(tm.Seconds + "S");                              if (tm.Milliseconds != 0) ret.Append(tm.Milliseconds + "MS");                              return ret.ToString();                          }                      case TagDataType.Bool:                          if (DataTypeStringFormat == TagDisplayDataType.Binary)                          {                              if (((bool)myValue) == true)                                  return "1";                              return "0";                          }                          return myValue.ToString();                      case TagDataType.DateTime:                      case TagDataType.Date:                      case TagDataType.TimeOfDay:                      case TagDataType.LTimeOfDay:                          if (DataTypeStringFormat == TagDisplayDataType.S7DateTime)                          {                              DateTime ak = (DateTime)myValue;                              StringBuilder sb = new StringBuilder();                              sb.Append("DT#");                              sb.Append(ak.Year.ToString().Substring(2));                              sb.Append("-");                              sb.Append(ak.Month);                              sb.Append("-");                              sb.Append(ak.Day);                              sb.Append("-");                              sb.Append(ak.Hour);                              sb.Append(":");                              sb.Append(ak.Minute);                              sb.Append(":");                              sb.Append(ak.Second);                              sb.Append(".");                              sb.Append(ak.Millisecond.ToString().PadRight(3' '0'));                              return sb.ToString();                          }                          else if (DataTypeStringFormat == TagDisplayDataType.S7Date)                          {                              DateTime ak = (DateTime)myValue;                              StringBuilder sb = new StringBuilder();                              sb.Append("D#");                              sb.Append(ak.Year);                              sb.Append("-");                              sb.Append(ak.Month);                              sb.Append("-");                              sb.Append(ak.Day);                              return sb.ToString();                          }                          else if (DataTypeStringFormat == TagDisplayDataType.S7TimeOfDay)                          {                              DateTime ak = (DateTime)myValue;                              StringBuilder sb = new StringBuilder();                              sb.Append("TOD#");                              sb.Append(ak.Hour);                              sb.Append(":");                              sb.Append(ak.Minute);                              sb.Append(":");                              sb.Append(ak.Second);                              sb.Append(".");                              sb.Append(ak.Millisecond.ToString().PadRight(3' '0'));                              return sb.ToString();                          }                          return myValue.ToString();                        case TagDataType.Int:                      case TagDataType.Dint:                      case TagDataType.LWord:                      case TagDataType.LInt:                      case TagDataType.LReal:                      case TagDataType.Byte:                      case TagDataType.SByte:                      case TagDataType.Word:                      case TagDataType.Dword:                      case TagDataType.Float:                      case TagDataType.BCDByte:                      case TagDataType.BCDWord:                      case TagDataType.BCDDWord:                          IFormattable val = myValue as IFormattable ?? 0;                          switch (DataTypeStringFormat)                          {                              case TagDisplayDataType.String:                                  switch (this.TagDataType)                                  {                                      case TagDataType.Int:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((Int16)myValue));                                      case TagDataType.Dint:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((Int32)myValue));                                      case TagDataType.LInt:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((Int64)myValue));                                      case TagDataType.Byte:                                          return Encoding.ASCII.GetString(new[] { (Byte)myValue });                                      case TagDataType.SByte:                                          return Encoding.ASCII.GetString(new[] { BitConverter.GetBytes((SByte)myValue)[0] });                                      case TagDataType.Word:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((UInt16)myValue));                                      case TagDataType.Dword:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((UInt32)myValue));                                      case TagDataType.LWord:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((UInt64)myValue));                                      case TagDataType.Float:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((Single)myValue));                                      case TagDataType.LReal:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((Double)myValue));                                      case TagDataType.BCDByte:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((Byte)myValue));                                      case TagDataType.BCDWord:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((UInt16)myValue));                                      case TagDataType.BCDDWord:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((UInt32)myValue));                                  }                                  break;                              case TagDisplayDataType.Pointer:                                  return "P#" + (Convert.ToInt32(myValue) / 8).ToString() + "." + (Convert.ToInt32(myValue) % 8).ToString();                                  break;                              case TagDisplayDataType.Hexadecimal:                                  string ad = "";                                  switch (_internalGetSize())                                  {                                      case 1:                                          ad = "B#16#";                                          break;                                      case 2:                                          ad = "W#16#";                                          break;                                      case 4:                                          ad = "DW#16#";                                          break;                                      case 8:                                          ad = "L#16#";                                          break;                                  }                                  return ad + val.ToString("X"' NumberFormatInfo.CurrentInfo).PadLeft(_internalGetSize() * 2' '0');                              case TagDisplayDataType.Binary:                                  byte[] bt = new byte[] { };                                  switch (this.TagDataType)                                  {                                      case TagDataType.Int:                                          bt = BitConverter.GetBytes((Int16)myValue);                                          break;                                      case TagDataType.Dint:                                          bt = BitConverter.GetBytes((Int32)myValue);                                          break;                                      case TagDataType.LInt:                                          bt = BitConverter.GetBytes((Int64)myValue);                                          break;                                      case TagDataType.Byte:                                          bt = new byte[] { (byte)myValue };                                          break;                                      case TagDataType.SByte:                                          bt = new byte[] { (byte)myValue };                                          break;                                      case TagDataType.Word:                                          bt = BitConverter.GetBytes((UInt16)myValue);                                          break;                                      case TagDataType.Dword:                                          bt = BitConverter.GetBytes((UInt32)myValue);                                          break;                                      case TagDataType.LWord:                                          bt = BitConverter.GetBytes((UInt64)myValue);                                          break;                                      case TagDataType.Float:                                          bt = BitConverter.GetBytes((float)myValue);                                          break;                                      case TagDataType.LReal:                                          bt = BitConverter.GetBytes((double)myValue);                                          break;                                      case TagDataType.BCDByte:                                          bt = BitConverter.GetBytes((byte)myValue);                                          break;                                      case TagDataType.BCDWord:                                          bt = BitConverter.GetBytes((Int16)myValue);                                          break;                                      case TagDataType.BCDDWord:                                          bt = BitConverter.GetBytes((Int32)myValue);                                          break;                                  }                                  string ret = "";                                  foreach (byte b in bt)                                  {                                      if (ret != "") ret = "_" + ret;                                      ret = libnodave.dec2bin(b).Substring(0' 4) + "_" + libnodave.dec2bin(b).Substring(4' 4) + ret;                                    }                                  return "2#" + ret;                            }                          return val.ToString();                  }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTag.cs,GetValueAsStringInternal,The following statement contains a magic number: switch (this.TagDataType)                  {                      case TagDataType.S5Time:                          {                              if (DataTypeStringFormat == TagDisplayDataType.S5Time)                              {                                  var bt = new byte[2];                                  libnodave.putS5Timeat(bt' 0' (TimeSpan)myValue);                                  return Helper.GetS5Time(bt[0]' bt[1]);                              }                              return ((TimeSpan)myValue).ToString();                          }                      case TagDataType.Time:                      case TagDataType.LTime:                          {                              var tm = (TimeSpan)myValue;                              var ret = new StringBuilder("T#");                              if (tm.TotalMilliseconds < 0) ret.Append("-");                              if (tm.Days != 0) ret.Append(tm.Days + "D");                              if (tm.Hours != 0) ret.Append(tm.Hours + "H");                              if (tm.Minutes != 0) ret.Append(tm.Minutes + "M");                              if (tm.Seconds != 0) ret.Append(tm.Seconds + "S");                              if (tm.Milliseconds != 0) ret.Append(tm.Milliseconds + "MS");                              return ret.ToString();                          }                      case TagDataType.Bool:                          if (DataTypeStringFormat == TagDisplayDataType.Binary)                          {                              if (((bool)myValue) == true)                                  return "1";                              return "0";                          }                          return myValue.ToString();                      case TagDataType.DateTime:                      case TagDataType.Date:                      case TagDataType.TimeOfDay:                      case TagDataType.LTimeOfDay:                          if (DataTypeStringFormat == TagDisplayDataType.S7DateTime)                          {                              DateTime ak = (DateTime)myValue;                              StringBuilder sb = new StringBuilder();                              sb.Append("DT#");                              sb.Append(ak.Year.ToString().Substring(2));                              sb.Append("-");                              sb.Append(ak.Month);                              sb.Append("-");                              sb.Append(ak.Day);                              sb.Append("-");                              sb.Append(ak.Hour);                              sb.Append(":");                              sb.Append(ak.Minute);                              sb.Append(":");                              sb.Append(ak.Second);                              sb.Append(".");                              sb.Append(ak.Millisecond.ToString().PadRight(3' '0'));                              return sb.ToString();                          }                          else if (DataTypeStringFormat == TagDisplayDataType.S7Date)                          {                              DateTime ak = (DateTime)myValue;                              StringBuilder sb = new StringBuilder();                              sb.Append("D#");                              sb.Append(ak.Year);                              sb.Append("-");                              sb.Append(ak.Month);                              sb.Append("-");                              sb.Append(ak.Day);                              return sb.ToString();                          }                          else if (DataTypeStringFormat == TagDisplayDataType.S7TimeOfDay)                          {                              DateTime ak = (DateTime)myValue;                              StringBuilder sb = new StringBuilder();                              sb.Append("TOD#");                              sb.Append(ak.Hour);                              sb.Append(":");                              sb.Append(ak.Minute);                              sb.Append(":");                              sb.Append(ak.Second);                              sb.Append(".");                              sb.Append(ak.Millisecond.ToString().PadRight(3' '0'));                              return sb.ToString();                          }                          return myValue.ToString();                        case TagDataType.Int:                      case TagDataType.Dint:                      case TagDataType.LWord:                      case TagDataType.LInt:                      case TagDataType.LReal:                      case TagDataType.Byte:                      case TagDataType.SByte:                      case TagDataType.Word:                      case TagDataType.Dword:                      case TagDataType.Float:                      case TagDataType.BCDByte:                      case TagDataType.BCDWord:                      case TagDataType.BCDDWord:                          IFormattable val = myValue as IFormattable ?? 0;                          switch (DataTypeStringFormat)                          {                              case TagDisplayDataType.String:                                  switch (this.TagDataType)                                  {                                      case TagDataType.Int:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((Int16)myValue));                                      case TagDataType.Dint:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((Int32)myValue));                                      case TagDataType.LInt:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((Int64)myValue));                                      case TagDataType.Byte:                                          return Encoding.ASCII.GetString(new[] { (Byte)myValue });                                      case TagDataType.SByte:                                          return Encoding.ASCII.GetString(new[] { BitConverter.GetBytes((SByte)myValue)[0] });                                      case TagDataType.Word:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((UInt16)myValue));                                      case TagDataType.Dword:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((UInt32)myValue));                                      case TagDataType.LWord:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((UInt64)myValue));                                      case TagDataType.Float:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((Single)myValue));                                      case TagDataType.LReal:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((Double)myValue));                                      case TagDataType.BCDByte:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((Byte)myValue));                                      case TagDataType.BCDWord:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((UInt16)myValue));                                      case TagDataType.BCDDWord:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((UInt32)myValue));                                  }                                  break;                              case TagDisplayDataType.Pointer:                                  return "P#" + (Convert.ToInt32(myValue) / 8).ToString() + "." + (Convert.ToInt32(myValue) % 8).ToString();                                  break;                              case TagDisplayDataType.Hexadecimal:                                  string ad = "";                                  switch (_internalGetSize())                                  {                                      case 1:                                          ad = "B#16#";                                          break;                                      case 2:                                          ad = "W#16#";                                          break;                                      case 4:                                          ad = "DW#16#";                                          break;                                      case 8:                                          ad = "L#16#";                                          break;                                  }                                  return ad + val.ToString("X"' NumberFormatInfo.CurrentInfo).PadLeft(_internalGetSize() * 2' '0');                              case TagDisplayDataType.Binary:                                  byte[] bt = new byte[] { };                                  switch (this.TagDataType)                                  {                                      case TagDataType.Int:                                          bt = BitConverter.GetBytes((Int16)myValue);                                          break;                                      case TagDataType.Dint:                                          bt = BitConverter.GetBytes((Int32)myValue);                                          break;                                      case TagDataType.LInt:                                          bt = BitConverter.GetBytes((Int64)myValue);                                          break;                                      case TagDataType.Byte:                                          bt = new byte[] { (byte)myValue };                                          break;                                      case TagDataType.SByte:                                          bt = new byte[] { (byte)myValue };                                          break;                                      case TagDataType.Word:                                          bt = BitConverter.GetBytes((UInt16)myValue);                                          break;                                      case TagDataType.Dword:                                          bt = BitConverter.GetBytes((UInt32)myValue);                                          break;                                      case TagDataType.LWord:                                          bt = BitConverter.GetBytes((UInt64)myValue);                                          break;                                      case TagDataType.Float:                                          bt = BitConverter.GetBytes((float)myValue);                                          break;                                      case TagDataType.LReal:                                          bt = BitConverter.GetBytes((double)myValue);                                          break;                                      case TagDataType.BCDByte:                                          bt = BitConverter.GetBytes((byte)myValue);                                          break;                                      case TagDataType.BCDWord:                                          bt = BitConverter.GetBytes((Int16)myValue);                                          break;                                      case TagDataType.BCDDWord:                                          bt = BitConverter.GetBytes((Int32)myValue);                                          break;                                  }                                  string ret = "";                                  foreach (byte b in bt)                                  {                                      if (ret != "") ret = "_" + ret;                                      ret = libnodave.dec2bin(b).Substring(0' 4) + "_" + libnodave.dec2bin(b).Substring(4' 4) + ret;                                    }                                  return "2#" + ret;                            }                          return val.ToString();                  }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTag.cs,GetValueAsStringInternal,The following statement contains a magic number: switch (this.TagDataType)                  {                      case TagDataType.S5Time:                          {                              if (DataTypeStringFormat == TagDisplayDataType.S5Time)                              {                                  var bt = new byte[2];                                  libnodave.putS5Timeat(bt' 0' (TimeSpan)myValue);                                  return Helper.GetS5Time(bt[0]' bt[1]);                              }                              return ((TimeSpan)myValue).ToString();                          }                      case TagDataType.Time:                      case TagDataType.LTime:                          {                              var tm = (TimeSpan)myValue;                              var ret = new StringBuilder("T#");                              if (tm.TotalMilliseconds < 0) ret.Append("-");                              if (tm.Days != 0) ret.Append(tm.Days + "D");                              if (tm.Hours != 0) ret.Append(tm.Hours + "H");                              if (tm.Minutes != 0) ret.Append(tm.Minutes + "M");                              if (tm.Seconds != 0) ret.Append(tm.Seconds + "S");                              if (tm.Milliseconds != 0) ret.Append(tm.Milliseconds + "MS");                              return ret.ToString();                          }                      case TagDataType.Bool:                          if (DataTypeStringFormat == TagDisplayDataType.Binary)                          {                              if (((bool)myValue) == true)                                  return "1";                              return "0";                          }                          return myValue.ToString();                      case TagDataType.DateTime:                      case TagDataType.Date:                      case TagDataType.TimeOfDay:                      case TagDataType.LTimeOfDay:                          if (DataTypeStringFormat == TagDisplayDataType.S7DateTime)                          {                              DateTime ak = (DateTime)myValue;                              StringBuilder sb = new StringBuilder();                              sb.Append("DT#");                              sb.Append(ak.Year.ToString().Substring(2));                              sb.Append("-");                              sb.Append(ak.Month);                              sb.Append("-");                              sb.Append(ak.Day);                              sb.Append("-");                              sb.Append(ak.Hour);                              sb.Append(":");                              sb.Append(ak.Minute);                              sb.Append(":");                              sb.Append(ak.Second);                              sb.Append(".");                              sb.Append(ak.Millisecond.ToString().PadRight(3' '0'));                              return sb.ToString();                          }                          else if (DataTypeStringFormat == TagDisplayDataType.S7Date)                          {                              DateTime ak = (DateTime)myValue;                              StringBuilder sb = new StringBuilder();                              sb.Append("D#");                              sb.Append(ak.Year);                              sb.Append("-");                              sb.Append(ak.Month);                              sb.Append("-");                              sb.Append(ak.Day);                              return sb.ToString();                          }                          else if (DataTypeStringFormat == TagDisplayDataType.S7TimeOfDay)                          {                              DateTime ak = (DateTime)myValue;                              StringBuilder sb = new StringBuilder();                              sb.Append("TOD#");                              sb.Append(ak.Hour);                              sb.Append(":");                              sb.Append(ak.Minute);                              sb.Append(":");                              sb.Append(ak.Second);                              sb.Append(".");                              sb.Append(ak.Millisecond.ToString().PadRight(3' '0'));                              return sb.ToString();                          }                          return myValue.ToString();                        case TagDataType.Int:                      case TagDataType.Dint:                      case TagDataType.LWord:                      case TagDataType.LInt:                      case TagDataType.LReal:                      case TagDataType.Byte:                      case TagDataType.SByte:                      case TagDataType.Word:                      case TagDataType.Dword:                      case TagDataType.Float:                      case TagDataType.BCDByte:                      case TagDataType.BCDWord:                      case TagDataType.BCDDWord:                          IFormattable val = myValue as IFormattable ?? 0;                          switch (DataTypeStringFormat)                          {                              case TagDisplayDataType.String:                                  switch (this.TagDataType)                                  {                                      case TagDataType.Int:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((Int16)myValue));                                      case TagDataType.Dint:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((Int32)myValue));                                      case TagDataType.LInt:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((Int64)myValue));                                      case TagDataType.Byte:                                          return Encoding.ASCII.GetString(new[] { (Byte)myValue });                                      case TagDataType.SByte:                                          return Encoding.ASCII.GetString(new[] { BitConverter.GetBytes((SByte)myValue)[0] });                                      case TagDataType.Word:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((UInt16)myValue));                                      case TagDataType.Dword:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((UInt32)myValue));                                      case TagDataType.LWord:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((UInt64)myValue));                                      case TagDataType.Float:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((Single)myValue));                                      case TagDataType.LReal:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((Double)myValue));                                      case TagDataType.BCDByte:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((Byte)myValue));                                      case TagDataType.BCDWord:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((UInt16)myValue));                                      case TagDataType.BCDDWord:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((UInt32)myValue));                                  }                                  break;                              case TagDisplayDataType.Pointer:                                  return "P#" + (Convert.ToInt32(myValue) / 8).ToString() + "." + (Convert.ToInt32(myValue) % 8).ToString();                                  break;                              case TagDisplayDataType.Hexadecimal:                                  string ad = "";                                  switch (_internalGetSize())                                  {                                      case 1:                                          ad = "B#16#";                                          break;                                      case 2:                                          ad = "W#16#";                                          break;                                      case 4:                                          ad = "DW#16#";                                          break;                                      case 8:                                          ad = "L#16#";                                          break;                                  }                                  return ad + val.ToString("X"' NumberFormatInfo.CurrentInfo).PadLeft(_internalGetSize() * 2' '0');                              case TagDisplayDataType.Binary:                                  byte[] bt = new byte[] { };                                  switch (this.TagDataType)                                  {                                      case TagDataType.Int:                                          bt = BitConverter.GetBytes((Int16)myValue);                                          break;                                      case TagDataType.Dint:                                          bt = BitConverter.GetBytes((Int32)myValue);                                          break;                                      case TagDataType.LInt:                                          bt = BitConverter.GetBytes((Int64)myValue);                                          break;                                      case TagDataType.Byte:                                          bt = new byte[] { (byte)myValue };                                          break;                                      case TagDataType.SByte:                                          bt = new byte[] { (byte)myValue };                                          break;                                      case TagDataType.Word:                                          bt = BitConverter.GetBytes((UInt16)myValue);                                          break;                                      case TagDataType.Dword:                                          bt = BitConverter.GetBytes((UInt32)myValue);                                          break;                                      case TagDataType.LWord:                                          bt = BitConverter.GetBytes((UInt64)myValue);                                          break;                                      case TagDataType.Float:                                          bt = BitConverter.GetBytes((float)myValue);                                          break;                                      case TagDataType.LReal:                                          bt = BitConverter.GetBytes((double)myValue);                                          break;                                      case TagDataType.BCDByte:                                          bt = BitConverter.GetBytes((byte)myValue);                                          break;                                      case TagDataType.BCDWord:                                          bt = BitConverter.GetBytes((Int16)myValue);                                          break;                                      case TagDataType.BCDDWord:                                          bt = BitConverter.GetBytes((Int32)myValue);                                          break;                                  }                                  string ret = "";                                  foreach (byte b in bt)                                  {                                      if (ret != "") ret = "_" + ret;                                      ret = libnodave.dec2bin(b).Substring(0' 4) + "_" + libnodave.dec2bin(b).Substring(4' 4) + ret;                                    }                                  return "2#" + ret;                            }                          return val.ToString();                  }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTag.cs,GetValueAsStringInternal,The following statement contains a magic number: switch (this.TagDataType)                  {                      case TagDataType.S5Time:                          {                              if (DataTypeStringFormat == TagDisplayDataType.S5Time)                              {                                  var bt = new byte[2];                                  libnodave.putS5Timeat(bt' 0' (TimeSpan)myValue);                                  return Helper.GetS5Time(bt[0]' bt[1]);                              }                              return ((TimeSpan)myValue).ToString();                          }                      case TagDataType.Time:                      case TagDataType.LTime:                          {                              var tm = (TimeSpan)myValue;                              var ret = new StringBuilder("T#");                              if (tm.TotalMilliseconds < 0) ret.Append("-");                              if (tm.Days != 0) ret.Append(tm.Days + "D");                              if (tm.Hours != 0) ret.Append(tm.Hours + "H");                              if (tm.Minutes != 0) ret.Append(tm.Minutes + "M");                              if (tm.Seconds != 0) ret.Append(tm.Seconds + "S");                              if (tm.Milliseconds != 0) ret.Append(tm.Milliseconds + "MS");                              return ret.ToString();                          }                      case TagDataType.Bool:                          if (DataTypeStringFormat == TagDisplayDataType.Binary)                          {                              if (((bool)myValue) == true)                                  return "1";                              return "0";                          }                          return myValue.ToString();                      case TagDataType.DateTime:                      case TagDataType.Date:                      case TagDataType.TimeOfDay:                      case TagDataType.LTimeOfDay:                          if (DataTypeStringFormat == TagDisplayDataType.S7DateTime)                          {                              DateTime ak = (DateTime)myValue;                              StringBuilder sb = new StringBuilder();                              sb.Append("DT#");                              sb.Append(ak.Year.ToString().Substring(2));                              sb.Append("-");                              sb.Append(ak.Month);                              sb.Append("-");                              sb.Append(ak.Day);                              sb.Append("-");                              sb.Append(ak.Hour);                              sb.Append(":");                              sb.Append(ak.Minute);                              sb.Append(":");                              sb.Append(ak.Second);                              sb.Append(".");                              sb.Append(ak.Millisecond.ToString().PadRight(3' '0'));                              return sb.ToString();                          }                          else if (DataTypeStringFormat == TagDisplayDataType.S7Date)                          {                              DateTime ak = (DateTime)myValue;                              StringBuilder sb = new StringBuilder();                              sb.Append("D#");                              sb.Append(ak.Year);                              sb.Append("-");                              sb.Append(ak.Month);                              sb.Append("-");                              sb.Append(ak.Day);                              return sb.ToString();                          }                          else if (DataTypeStringFormat == TagDisplayDataType.S7TimeOfDay)                          {                              DateTime ak = (DateTime)myValue;                              StringBuilder sb = new StringBuilder();                              sb.Append("TOD#");                              sb.Append(ak.Hour);                              sb.Append(":");                              sb.Append(ak.Minute);                              sb.Append(":");                              sb.Append(ak.Second);                              sb.Append(".");                              sb.Append(ak.Millisecond.ToString().PadRight(3' '0'));                              return sb.ToString();                          }                          return myValue.ToString();                        case TagDataType.Int:                      case TagDataType.Dint:                      case TagDataType.LWord:                      case TagDataType.LInt:                      case TagDataType.LReal:                      case TagDataType.Byte:                      case TagDataType.SByte:                      case TagDataType.Word:                      case TagDataType.Dword:                      case TagDataType.Float:                      case TagDataType.BCDByte:                      case TagDataType.BCDWord:                      case TagDataType.BCDDWord:                          IFormattable val = myValue as IFormattable ?? 0;                          switch (DataTypeStringFormat)                          {                              case TagDisplayDataType.String:                                  switch (this.TagDataType)                                  {                                      case TagDataType.Int:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((Int16)myValue));                                      case TagDataType.Dint:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((Int32)myValue));                                      case TagDataType.LInt:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((Int64)myValue));                                      case TagDataType.Byte:                                          return Encoding.ASCII.GetString(new[] { (Byte)myValue });                                      case TagDataType.SByte:                                          return Encoding.ASCII.GetString(new[] { BitConverter.GetBytes((SByte)myValue)[0] });                                      case TagDataType.Word:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((UInt16)myValue));                                      case TagDataType.Dword:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((UInt32)myValue));                                      case TagDataType.LWord:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((UInt64)myValue));                                      case TagDataType.Float:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((Single)myValue));                                      case TagDataType.LReal:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((Double)myValue));                                      case TagDataType.BCDByte:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((Byte)myValue));                                      case TagDataType.BCDWord:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((UInt16)myValue));                                      case TagDataType.BCDDWord:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((UInt32)myValue));                                  }                                  break;                              case TagDisplayDataType.Pointer:                                  return "P#" + (Convert.ToInt32(myValue) / 8).ToString() + "." + (Convert.ToInt32(myValue) % 8).ToString();                                  break;                              case TagDisplayDataType.Hexadecimal:                                  string ad = "";                                  switch (_internalGetSize())                                  {                                      case 1:                                          ad = "B#16#";                                          break;                                      case 2:                                          ad = "W#16#";                                          break;                                      case 4:                                          ad = "DW#16#";                                          break;                                      case 8:                                          ad = "L#16#";                                          break;                                  }                                  return ad + val.ToString("X"' NumberFormatInfo.CurrentInfo).PadLeft(_internalGetSize() * 2' '0');                              case TagDisplayDataType.Binary:                                  byte[] bt = new byte[] { };                                  switch (this.TagDataType)                                  {                                      case TagDataType.Int:                                          bt = BitConverter.GetBytes((Int16)myValue);                                          break;                                      case TagDataType.Dint:                                          bt = BitConverter.GetBytes((Int32)myValue);                                          break;                                      case TagDataType.LInt:                                          bt = BitConverter.GetBytes((Int64)myValue);                                          break;                                      case TagDataType.Byte:                                          bt = new byte[] { (byte)myValue };                                          break;                                      case TagDataType.SByte:                                          bt = new byte[] { (byte)myValue };                                          break;                                      case TagDataType.Word:                                          bt = BitConverter.GetBytes((UInt16)myValue);                                          break;                                      case TagDataType.Dword:                                          bt = BitConverter.GetBytes((UInt32)myValue);                                          break;                                      case TagDataType.LWord:                                          bt = BitConverter.GetBytes((UInt64)myValue);                                          break;                                      case TagDataType.Float:                                          bt = BitConverter.GetBytes((float)myValue);                                          break;                                      case TagDataType.LReal:                                          bt = BitConverter.GetBytes((double)myValue);                                          break;                                      case TagDataType.BCDByte:                                          bt = BitConverter.GetBytes((byte)myValue);                                          break;                                      case TagDataType.BCDWord:                                          bt = BitConverter.GetBytes((Int16)myValue);                                          break;                                      case TagDataType.BCDDWord:                                          bt = BitConverter.GetBytes((Int32)myValue);                                          break;                                  }                                  string ret = "";                                  foreach (byte b in bt)                                  {                                      if (ret != "") ret = "_" + ret;                                      ret = libnodave.dec2bin(b).Substring(0' 4) + "_" + libnodave.dec2bin(b).Substring(4' 4) + ret;                                    }                                  return "2#" + ret;                            }                          return val.ToString();                  }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTag.cs,GetValueAsStringInternal,The following statement contains a magic number: switch (this.TagDataType)                  {                      case TagDataType.S5Time:                          {                              if (DataTypeStringFormat == TagDisplayDataType.S5Time)                              {                                  var bt = new byte[2];                                  libnodave.putS5Timeat(bt' 0' (TimeSpan)myValue);                                  return Helper.GetS5Time(bt[0]' bt[1]);                              }                              return ((TimeSpan)myValue).ToString();                          }                      case TagDataType.Time:                      case TagDataType.LTime:                          {                              var tm = (TimeSpan)myValue;                              var ret = new StringBuilder("T#");                              if (tm.TotalMilliseconds < 0) ret.Append("-");                              if (tm.Days != 0) ret.Append(tm.Days + "D");                              if (tm.Hours != 0) ret.Append(tm.Hours + "H");                              if (tm.Minutes != 0) ret.Append(tm.Minutes + "M");                              if (tm.Seconds != 0) ret.Append(tm.Seconds + "S");                              if (tm.Milliseconds != 0) ret.Append(tm.Milliseconds + "MS");                              return ret.ToString();                          }                      case TagDataType.Bool:                          if (DataTypeStringFormat == TagDisplayDataType.Binary)                          {                              if (((bool)myValue) == true)                                  return "1";                              return "0";                          }                          return myValue.ToString();                      case TagDataType.DateTime:                      case TagDataType.Date:                      case TagDataType.TimeOfDay:                      case TagDataType.LTimeOfDay:                          if (DataTypeStringFormat == TagDisplayDataType.S7DateTime)                          {                              DateTime ak = (DateTime)myValue;                              StringBuilder sb = new StringBuilder();                              sb.Append("DT#");                              sb.Append(ak.Year.ToString().Substring(2));                              sb.Append("-");                              sb.Append(ak.Month);                              sb.Append("-");                              sb.Append(ak.Day);                              sb.Append("-");                              sb.Append(ak.Hour);                              sb.Append(":");                              sb.Append(ak.Minute);                              sb.Append(":");                              sb.Append(ak.Second);                              sb.Append(".");                              sb.Append(ak.Millisecond.ToString().PadRight(3' '0'));                              return sb.ToString();                          }                          else if (DataTypeStringFormat == TagDisplayDataType.S7Date)                          {                              DateTime ak = (DateTime)myValue;                              StringBuilder sb = new StringBuilder();                              sb.Append("D#");                              sb.Append(ak.Year);                              sb.Append("-");                              sb.Append(ak.Month);                              sb.Append("-");                              sb.Append(ak.Day);                              return sb.ToString();                          }                          else if (DataTypeStringFormat == TagDisplayDataType.S7TimeOfDay)                          {                              DateTime ak = (DateTime)myValue;                              StringBuilder sb = new StringBuilder();                              sb.Append("TOD#");                              sb.Append(ak.Hour);                              sb.Append(":");                              sb.Append(ak.Minute);                              sb.Append(":");                              sb.Append(ak.Second);                              sb.Append(".");                              sb.Append(ak.Millisecond.ToString().PadRight(3' '0'));                              return sb.ToString();                          }                          return myValue.ToString();                        case TagDataType.Int:                      case TagDataType.Dint:                      case TagDataType.LWord:                      case TagDataType.LInt:                      case TagDataType.LReal:                      case TagDataType.Byte:                      case TagDataType.SByte:                      case TagDataType.Word:                      case TagDataType.Dword:                      case TagDataType.Float:                      case TagDataType.BCDByte:                      case TagDataType.BCDWord:                      case TagDataType.BCDDWord:                          IFormattable val = myValue as IFormattable ?? 0;                          switch (DataTypeStringFormat)                          {                              case TagDisplayDataType.String:                                  switch (this.TagDataType)                                  {                                      case TagDataType.Int:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((Int16)myValue));                                      case TagDataType.Dint:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((Int32)myValue));                                      case TagDataType.LInt:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((Int64)myValue));                                      case TagDataType.Byte:                                          return Encoding.ASCII.GetString(new[] { (Byte)myValue });                                      case TagDataType.SByte:                                          return Encoding.ASCII.GetString(new[] { BitConverter.GetBytes((SByte)myValue)[0] });                                      case TagDataType.Word:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((UInt16)myValue));                                      case TagDataType.Dword:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((UInt32)myValue));                                      case TagDataType.LWord:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((UInt64)myValue));                                      case TagDataType.Float:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((Single)myValue));                                      case TagDataType.LReal:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((Double)myValue));                                      case TagDataType.BCDByte:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((Byte)myValue));                                      case TagDataType.BCDWord:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((UInt16)myValue));                                      case TagDataType.BCDDWord:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((UInt32)myValue));                                  }                                  break;                              case TagDisplayDataType.Pointer:                                  return "P#" + (Convert.ToInt32(myValue) / 8).ToString() + "." + (Convert.ToInt32(myValue) % 8).ToString();                                  break;                              case TagDisplayDataType.Hexadecimal:                                  string ad = "";                                  switch (_internalGetSize())                                  {                                      case 1:                                          ad = "B#16#";                                          break;                                      case 2:                                          ad = "W#16#";                                          break;                                      case 4:                                          ad = "DW#16#";                                          break;                                      case 8:                                          ad = "L#16#";                                          break;                                  }                                  return ad + val.ToString("X"' NumberFormatInfo.CurrentInfo).PadLeft(_internalGetSize() * 2' '0');                              case TagDisplayDataType.Binary:                                  byte[] bt = new byte[] { };                                  switch (this.TagDataType)                                  {                                      case TagDataType.Int:                                          bt = BitConverter.GetBytes((Int16)myValue);                                          break;                                      case TagDataType.Dint:                                          bt = BitConverter.GetBytes((Int32)myValue);                                          break;                                      case TagDataType.LInt:                                          bt = BitConverter.GetBytes((Int64)myValue);                                          break;                                      case TagDataType.Byte:                                          bt = new byte[] { (byte)myValue };                                          break;                                      case TagDataType.SByte:                                          bt = new byte[] { (byte)myValue };                                          break;                                      case TagDataType.Word:                                          bt = BitConverter.GetBytes((UInt16)myValue);                                          break;                                      case TagDataType.Dword:                                          bt = BitConverter.GetBytes((UInt32)myValue);                                          break;                                      case TagDataType.LWord:                                          bt = BitConverter.GetBytes((UInt64)myValue);                                          break;                                      case TagDataType.Float:                                          bt = BitConverter.GetBytes((float)myValue);                                          break;                                      case TagDataType.LReal:                                          bt = BitConverter.GetBytes((double)myValue);                                          break;                                      case TagDataType.BCDByte:                                          bt = BitConverter.GetBytes((byte)myValue);                                          break;                                      case TagDataType.BCDWord:                                          bt = BitConverter.GetBytes((Int16)myValue);                                          break;                                      case TagDataType.BCDDWord:                                          bt = BitConverter.GetBytes((Int32)myValue);                                          break;                                  }                                  string ret = "";                                  foreach (byte b in bt)                                  {                                      if (ret != "") ret = "_" + ret;                                      ret = libnodave.dec2bin(b).Substring(0' 4) + "_" + libnodave.dec2bin(b).Substring(4' 4) + ret;                                    }                                  return "2#" + ret;                            }                          return val.ToString();                  }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTag.cs,GetValueAsStringInternal,The following statement contains a magic number: switch (this.TagDataType)                  {                      case TagDataType.S5Time:                          {                              if (DataTypeStringFormat == TagDisplayDataType.S5Time)                              {                                  var bt = new byte[2];                                  libnodave.putS5Timeat(bt' 0' (TimeSpan)myValue);                                  return Helper.GetS5Time(bt[0]' bt[1]);                              }                              return ((TimeSpan)myValue).ToString();                          }                      case TagDataType.Time:                      case TagDataType.LTime:                          {                              var tm = (TimeSpan)myValue;                              var ret = new StringBuilder("T#");                              if (tm.TotalMilliseconds < 0) ret.Append("-");                              if (tm.Days != 0) ret.Append(tm.Days + "D");                              if (tm.Hours != 0) ret.Append(tm.Hours + "H");                              if (tm.Minutes != 0) ret.Append(tm.Minutes + "M");                              if (tm.Seconds != 0) ret.Append(tm.Seconds + "S");                              if (tm.Milliseconds != 0) ret.Append(tm.Milliseconds + "MS");                              return ret.ToString();                          }                      case TagDataType.Bool:                          if (DataTypeStringFormat == TagDisplayDataType.Binary)                          {                              if (((bool)myValue) == true)                                  return "1";                              return "0";                          }                          return myValue.ToString();                      case TagDataType.DateTime:                      case TagDataType.Date:                      case TagDataType.TimeOfDay:                      case TagDataType.LTimeOfDay:                          if (DataTypeStringFormat == TagDisplayDataType.S7DateTime)                          {                              DateTime ak = (DateTime)myValue;                              StringBuilder sb = new StringBuilder();                              sb.Append("DT#");                              sb.Append(ak.Year.ToString().Substring(2));                              sb.Append("-");                              sb.Append(ak.Month);                              sb.Append("-");                              sb.Append(ak.Day);                              sb.Append("-");                              sb.Append(ak.Hour);                              sb.Append(":");                              sb.Append(ak.Minute);                              sb.Append(":");                              sb.Append(ak.Second);                              sb.Append(".");                              sb.Append(ak.Millisecond.ToString().PadRight(3' '0'));                              return sb.ToString();                          }                          else if (DataTypeStringFormat == TagDisplayDataType.S7Date)                          {                              DateTime ak = (DateTime)myValue;                              StringBuilder sb = new StringBuilder();                              sb.Append("D#");                              sb.Append(ak.Year);                              sb.Append("-");                              sb.Append(ak.Month);                              sb.Append("-");                              sb.Append(ak.Day);                              return sb.ToString();                          }                          else if (DataTypeStringFormat == TagDisplayDataType.S7TimeOfDay)                          {                              DateTime ak = (DateTime)myValue;                              StringBuilder sb = new StringBuilder();                              sb.Append("TOD#");                              sb.Append(ak.Hour);                              sb.Append(":");                              sb.Append(ak.Minute);                              sb.Append(":");                              sb.Append(ak.Second);                              sb.Append(".");                              sb.Append(ak.Millisecond.ToString().PadRight(3' '0'));                              return sb.ToString();                          }                          return myValue.ToString();                        case TagDataType.Int:                      case TagDataType.Dint:                      case TagDataType.LWord:                      case TagDataType.LInt:                      case TagDataType.LReal:                      case TagDataType.Byte:                      case TagDataType.SByte:                      case TagDataType.Word:                      case TagDataType.Dword:                      case TagDataType.Float:                      case TagDataType.BCDByte:                      case TagDataType.BCDWord:                      case TagDataType.BCDDWord:                          IFormattable val = myValue as IFormattable ?? 0;                          switch (DataTypeStringFormat)                          {                              case TagDisplayDataType.String:                                  switch (this.TagDataType)                                  {                                      case TagDataType.Int:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((Int16)myValue));                                      case TagDataType.Dint:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((Int32)myValue));                                      case TagDataType.LInt:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((Int64)myValue));                                      case TagDataType.Byte:                                          return Encoding.ASCII.GetString(new[] { (Byte)myValue });                                      case TagDataType.SByte:                                          return Encoding.ASCII.GetString(new[] { BitConverter.GetBytes((SByte)myValue)[0] });                                      case TagDataType.Word:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((UInt16)myValue));                                      case TagDataType.Dword:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((UInt32)myValue));                                      case TagDataType.LWord:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((UInt64)myValue));                                      case TagDataType.Float:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((Single)myValue));                                      case TagDataType.LReal:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((Double)myValue));                                      case TagDataType.BCDByte:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((Byte)myValue));                                      case TagDataType.BCDWord:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((UInt16)myValue));                                      case TagDataType.BCDDWord:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((UInt32)myValue));                                  }                                  break;                              case TagDisplayDataType.Pointer:                                  return "P#" + (Convert.ToInt32(myValue) / 8).ToString() + "." + (Convert.ToInt32(myValue) % 8).ToString();                                  break;                              case TagDisplayDataType.Hexadecimal:                                  string ad = "";                                  switch (_internalGetSize())                                  {                                      case 1:                                          ad = "B#16#";                                          break;                                      case 2:                                          ad = "W#16#";                                          break;                                      case 4:                                          ad = "DW#16#";                                          break;                                      case 8:                                          ad = "L#16#";                                          break;                                  }                                  return ad + val.ToString("X"' NumberFormatInfo.CurrentInfo).PadLeft(_internalGetSize() * 2' '0');                              case TagDisplayDataType.Binary:                                  byte[] bt = new byte[] { };                                  switch (this.TagDataType)                                  {                                      case TagDataType.Int:                                          bt = BitConverter.GetBytes((Int16)myValue);                                          break;                                      case TagDataType.Dint:                                          bt = BitConverter.GetBytes((Int32)myValue);                                          break;                                      case TagDataType.LInt:                                          bt = BitConverter.GetBytes((Int64)myValue);                                          break;                                      case TagDataType.Byte:                                          bt = new byte[] { (byte)myValue };                                          break;                                      case TagDataType.SByte:                                          bt = new byte[] { (byte)myValue };                                          break;                                      case TagDataType.Word:                                          bt = BitConverter.GetBytes((UInt16)myValue);                                          break;                                      case TagDataType.Dword:                                          bt = BitConverter.GetBytes((UInt32)myValue);                                          break;                                      case TagDataType.LWord:                                          bt = BitConverter.GetBytes((UInt64)myValue);                                          break;                                      case TagDataType.Float:                                          bt = BitConverter.GetBytes((float)myValue);                                          break;                                      case TagDataType.LReal:                                          bt = BitConverter.GetBytes((double)myValue);                                          break;                                      case TagDataType.BCDByte:                                          bt = BitConverter.GetBytes((byte)myValue);                                          break;                                      case TagDataType.BCDWord:                                          bt = BitConverter.GetBytes((Int16)myValue);                                          break;                                      case TagDataType.BCDDWord:                                          bt = BitConverter.GetBytes((Int32)myValue);                                          break;                                  }                                  string ret = "";                                  foreach (byte b in bt)                                  {                                      if (ret != "") ret = "_" + ret;                                      ret = libnodave.dec2bin(b).Substring(0' 4) + "_" + libnodave.dec2bin(b).Substring(4' 4) + ret;                                    }                                  return "2#" + ret;                            }                          return val.ToString();                  }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTag.cs,GetValueAsStringInternal,The following statement contains a magic number: switch (this.TagDataType)                  {                      case TagDataType.S5Time:                          {                              if (DataTypeStringFormat == TagDisplayDataType.S5Time)                              {                                  var bt = new byte[2];                                  libnodave.putS5Timeat(bt' 0' (TimeSpan)myValue);                                  return Helper.GetS5Time(bt[0]' bt[1]);                              }                              return ((TimeSpan)myValue).ToString();                          }                      case TagDataType.Time:                      case TagDataType.LTime:                          {                              var tm = (TimeSpan)myValue;                              var ret = new StringBuilder("T#");                              if (tm.TotalMilliseconds < 0) ret.Append("-");                              if (tm.Days != 0) ret.Append(tm.Days + "D");                              if (tm.Hours != 0) ret.Append(tm.Hours + "H");                              if (tm.Minutes != 0) ret.Append(tm.Minutes + "M");                              if (tm.Seconds != 0) ret.Append(tm.Seconds + "S");                              if (tm.Milliseconds != 0) ret.Append(tm.Milliseconds + "MS");                              return ret.ToString();                          }                      case TagDataType.Bool:                          if (DataTypeStringFormat == TagDisplayDataType.Binary)                          {                              if (((bool)myValue) == true)                                  return "1";                              return "0";                          }                          return myValue.ToString();                      case TagDataType.DateTime:                      case TagDataType.Date:                      case TagDataType.TimeOfDay:                      case TagDataType.LTimeOfDay:                          if (DataTypeStringFormat == TagDisplayDataType.S7DateTime)                          {                              DateTime ak = (DateTime)myValue;                              StringBuilder sb = new StringBuilder();                              sb.Append("DT#");                              sb.Append(ak.Year.ToString().Substring(2));                              sb.Append("-");                              sb.Append(ak.Month);                              sb.Append("-");                              sb.Append(ak.Day);                              sb.Append("-");                              sb.Append(ak.Hour);                              sb.Append(":");                              sb.Append(ak.Minute);                              sb.Append(":");                              sb.Append(ak.Second);                              sb.Append(".");                              sb.Append(ak.Millisecond.ToString().PadRight(3' '0'));                              return sb.ToString();                          }                          else if (DataTypeStringFormat == TagDisplayDataType.S7Date)                          {                              DateTime ak = (DateTime)myValue;                              StringBuilder sb = new StringBuilder();                              sb.Append("D#");                              sb.Append(ak.Year);                              sb.Append("-");                              sb.Append(ak.Month);                              sb.Append("-");                              sb.Append(ak.Day);                              return sb.ToString();                          }                          else if (DataTypeStringFormat == TagDisplayDataType.S7TimeOfDay)                          {                              DateTime ak = (DateTime)myValue;                              StringBuilder sb = new StringBuilder();                              sb.Append("TOD#");                              sb.Append(ak.Hour);                              sb.Append(":");                              sb.Append(ak.Minute);                              sb.Append(":");                              sb.Append(ak.Second);                              sb.Append(".");                              sb.Append(ak.Millisecond.ToString().PadRight(3' '0'));                              return sb.ToString();                          }                          return myValue.ToString();                        case TagDataType.Int:                      case TagDataType.Dint:                      case TagDataType.LWord:                      case TagDataType.LInt:                      case TagDataType.LReal:                      case TagDataType.Byte:                      case TagDataType.SByte:                      case TagDataType.Word:                      case TagDataType.Dword:                      case TagDataType.Float:                      case TagDataType.BCDByte:                      case TagDataType.BCDWord:                      case TagDataType.BCDDWord:                          IFormattable val = myValue as IFormattable ?? 0;                          switch (DataTypeStringFormat)                          {                              case TagDisplayDataType.String:                                  switch (this.TagDataType)                                  {                                      case TagDataType.Int:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((Int16)myValue));                                      case TagDataType.Dint:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((Int32)myValue));                                      case TagDataType.LInt:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((Int64)myValue));                                      case TagDataType.Byte:                                          return Encoding.ASCII.GetString(new[] { (Byte)myValue });                                      case TagDataType.SByte:                                          return Encoding.ASCII.GetString(new[] { BitConverter.GetBytes((SByte)myValue)[0] });                                      case TagDataType.Word:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((UInt16)myValue));                                      case TagDataType.Dword:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((UInt32)myValue));                                      case TagDataType.LWord:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((UInt64)myValue));                                      case TagDataType.Float:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((Single)myValue));                                      case TagDataType.LReal:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((Double)myValue));                                      case TagDataType.BCDByte:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((Byte)myValue));                                      case TagDataType.BCDWord:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((UInt16)myValue));                                      case TagDataType.BCDDWord:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((UInt32)myValue));                                  }                                  break;                              case TagDisplayDataType.Pointer:                                  return "P#" + (Convert.ToInt32(myValue) / 8).ToString() + "." + (Convert.ToInt32(myValue) % 8).ToString();                                  break;                              case TagDisplayDataType.Hexadecimal:                                  string ad = "";                                  switch (_internalGetSize())                                  {                                      case 1:                                          ad = "B#16#";                                          break;                                      case 2:                                          ad = "W#16#";                                          break;                                      case 4:                                          ad = "DW#16#";                                          break;                                      case 8:                                          ad = "L#16#";                                          break;                                  }                                  return ad + val.ToString("X"' NumberFormatInfo.CurrentInfo).PadLeft(_internalGetSize() * 2' '0');                              case TagDisplayDataType.Binary:                                  byte[] bt = new byte[] { };                                  switch (this.TagDataType)                                  {                                      case TagDataType.Int:                                          bt = BitConverter.GetBytes((Int16)myValue);                                          break;                                      case TagDataType.Dint:                                          bt = BitConverter.GetBytes((Int32)myValue);                                          break;                                      case TagDataType.LInt:                                          bt = BitConverter.GetBytes((Int64)myValue);                                          break;                                      case TagDataType.Byte:                                          bt = new byte[] { (byte)myValue };                                          break;                                      case TagDataType.SByte:                                          bt = new byte[] { (byte)myValue };                                          break;                                      case TagDataType.Word:                                          bt = BitConverter.GetBytes((UInt16)myValue);                                          break;                                      case TagDataType.Dword:                                          bt = BitConverter.GetBytes((UInt32)myValue);                                          break;                                      case TagDataType.LWord:                                          bt = BitConverter.GetBytes((UInt64)myValue);                                          break;                                      case TagDataType.Float:                                          bt = BitConverter.GetBytes((float)myValue);                                          break;                                      case TagDataType.LReal:                                          bt = BitConverter.GetBytes((double)myValue);                                          break;                                      case TagDataType.BCDByte:                                          bt = BitConverter.GetBytes((byte)myValue);                                          break;                                      case TagDataType.BCDWord:                                          bt = BitConverter.GetBytes((Int16)myValue);                                          break;                                      case TagDataType.BCDDWord:                                          bt = BitConverter.GetBytes((Int32)myValue);                                          break;                                  }                                  string ret = "";                                  foreach (byte b in bt)                                  {                                      if (ret != "") ret = "_" + ret;                                      ret = libnodave.dec2bin(b).Substring(0' 4) + "_" + libnodave.dec2bin(b).Substring(4' 4) + ret;                                    }                                  return "2#" + ret;                            }                          return val.ToString();                  }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTag.cs,GetValueAsStringInternal,The following statement contains a magic number: switch (this.TagDataType)                  {                      case TagDataType.S5Time:                          {                              if (DataTypeStringFormat == TagDisplayDataType.S5Time)                              {                                  var bt = new byte[2];                                  libnodave.putS5Timeat(bt' 0' (TimeSpan)myValue);                                  return Helper.GetS5Time(bt[0]' bt[1]);                              }                              return ((TimeSpan)myValue).ToString();                          }                      case TagDataType.Time:                      case TagDataType.LTime:                          {                              var tm = (TimeSpan)myValue;                              var ret = new StringBuilder("T#");                              if (tm.TotalMilliseconds < 0) ret.Append("-");                              if (tm.Days != 0) ret.Append(tm.Days + "D");                              if (tm.Hours != 0) ret.Append(tm.Hours + "H");                              if (tm.Minutes != 0) ret.Append(tm.Minutes + "M");                              if (tm.Seconds != 0) ret.Append(tm.Seconds + "S");                              if (tm.Milliseconds != 0) ret.Append(tm.Milliseconds + "MS");                              return ret.ToString();                          }                      case TagDataType.Bool:                          if (DataTypeStringFormat == TagDisplayDataType.Binary)                          {                              if (((bool)myValue) == true)                                  return "1";                              return "0";                          }                          return myValue.ToString();                      case TagDataType.DateTime:                      case TagDataType.Date:                      case TagDataType.TimeOfDay:                      case TagDataType.LTimeOfDay:                          if (DataTypeStringFormat == TagDisplayDataType.S7DateTime)                          {                              DateTime ak = (DateTime)myValue;                              StringBuilder sb = new StringBuilder();                              sb.Append("DT#");                              sb.Append(ak.Year.ToString().Substring(2));                              sb.Append("-");                              sb.Append(ak.Month);                              sb.Append("-");                              sb.Append(ak.Day);                              sb.Append("-");                              sb.Append(ak.Hour);                              sb.Append(":");                              sb.Append(ak.Minute);                              sb.Append(":");                              sb.Append(ak.Second);                              sb.Append(".");                              sb.Append(ak.Millisecond.ToString().PadRight(3' '0'));                              return sb.ToString();                          }                          else if (DataTypeStringFormat == TagDisplayDataType.S7Date)                          {                              DateTime ak = (DateTime)myValue;                              StringBuilder sb = new StringBuilder();                              sb.Append("D#");                              sb.Append(ak.Year);                              sb.Append("-");                              sb.Append(ak.Month);                              sb.Append("-");                              sb.Append(ak.Day);                              return sb.ToString();                          }                          else if (DataTypeStringFormat == TagDisplayDataType.S7TimeOfDay)                          {                              DateTime ak = (DateTime)myValue;                              StringBuilder sb = new StringBuilder();                              sb.Append("TOD#");                              sb.Append(ak.Hour);                              sb.Append(":");                              sb.Append(ak.Minute);                              sb.Append(":");                              sb.Append(ak.Second);                              sb.Append(".");                              sb.Append(ak.Millisecond.ToString().PadRight(3' '0'));                              return sb.ToString();                          }                          return myValue.ToString();                        case TagDataType.Int:                      case TagDataType.Dint:                      case TagDataType.LWord:                      case TagDataType.LInt:                      case TagDataType.LReal:                      case TagDataType.Byte:                      case TagDataType.SByte:                      case TagDataType.Word:                      case TagDataType.Dword:                      case TagDataType.Float:                      case TagDataType.BCDByte:                      case TagDataType.BCDWord:                      case TagDataType.BCDDWord:                          IFormattable val = myValue as IFormattable ?? 0;                          switch (DataTypeStringFormat)                          {                              case TagDisplayDataType.String:                                  switch (this.TagDataType)                                  {                                      case TagDataType.Int:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((Int16)myValue));                                      case TagDataType.Dint:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((Int32)myValue));                                      case TagDataType.LInt:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((Int64)myValue));                                      case TagDataType.Byte:                                          return Encoding.ASCII.GetString(new[] { (Byte)myValue });                                      case TagDataType.SByte:                                          return Encoding.ASCII.GetString(new[] { BitConverter.GetBytes((SByte)myValue)[0] });                                      case TagDataType.Word:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((UInt16)myValue));                                      case TagDataType.Dword:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((UInt32)myValue));                                      case TagDataType.LWord:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((UInt64)myValue));                                      case TagDataType.Float:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((Single)myValue));                                      case TagDataType.LReal:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((Double)myValue));                                      case TagDataType.BCDByte:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((Byte)myValue));                                      case TagDataType.BCDWord:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((UInt16)myValue));                                      case TagDataType.BCDDWord:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((UInt32)myValue));                                  }                                  break;                              case TagDisplayDataType.Pointer:                                  return "P#" + (Convert.ToInt32(myValue) / 8).ToString() + "." + (Convert.ToInt32(myValue) % 8).ToString();                                  break;                              case TagDisplayDataType.Hexadecimal:                                  string ad = "";                                  switch (_internalGetSize())                                  {                                      case 1:                                          ad = "B#16#";                                          break;                                      case 2:                                          ad = "W#16#";                                          break;                                      case 4:                                          ad = "DW#16#";                                          break;                                      case 8:                                          ad = "L#16#";                                          break;                                  }                                  return ad + val.ToString("X"' NumberFormatInfo.CurrentInfo).PadLeft(_internalGetSize() * 2' '0');                              case TagDisplayDataType.Binary:                                  byte[] bt = new byte[] { };                                  switch (this.TagDataType)                                  {                                      case TagDataType.Int:                                          bt = BitConverter.GetBytes((Int16)myValue);                                          break;                                      case TagDataType.Dint:                                          bt = BitConverter.GetBytes((Int32)myValue);                                          break;                                      case TagDataType.LInt:                                          bt = BitConverter.GetBytes((Int64)myValue);                                          break;                                      case TagDataType.Byte:                                          bt = new byte[] { (byte)myValue };                                          break;                                      case TagDataType.SByte:                                          bt = new byte[] { (byte)myValue };                                          break;                                      case TagDataType.Word:                                          bt = BitConverter.GetBytes((UInt16)myValue);                                          break;                                      case TagDataType.Dword:                                          bt = BitConverter.GetBytes((UInt32)myValue);                                          break;                                      case TagDataType.LWord:                                          bt = BitConverter.GetBytes((UInt64)myValue);                                          break;                                      case TagDataType.Float:                                          bt = BitConverter.GetBytes((float)myValue);                                          break;                                      case TagDataType.LReal:                                          bt = BitConverter.GetBytes((double)myValue);                                          break;                                      case TagDataType.BCDByte:                                          bt = BitConverter.GetBytes((byte)myValue);                                          break;                                      case TagDataType.BCDWord:                                          bt = BitConverter.GetBytes((Int16)myValue);                                          break;                                      case TagDataType.BCDDWord:                                          bt = BitConverter.GetBytes((Int32)myValue);                                          break;                                  }                                  string ret = "";                                  foreach (byte b in bt)                                  {                                      if (ret != "") ret = "_" + ret;                                      ret = libnodave.dec2bin(b).Substring(0' 4) + "_" + libnodave.dec2bin(b).Substring(4' 4) + ret;                                    }                                  return "2#" + ret;                            }                          return val.ToString();                  }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTag.cs,GetValueAsStringInternal,The following statement contains a magic number: switch (this.TagDataType)                  {                      case TagDataType.S5Time:                          {                              if (DataTypeStringFormat == TagDisplayDataType.S5Time)                              {                                  var bt = new byte[2];                                  libnodave.putS5Timeat(bt' 0' (TimeSpan)myValue);                                  return Helper.GetS5Time(bt[0]' bt[1]);                              }                              return ((TimeSpan)myValue).ToString();                          }                      case TagDataType.Time:                      case TagDataType.LTime:                          {                              var tm = (TimeSpan)myValue;                              var ret = new StringBuilder("T#");                              if (tm.TotalMilliseconds < 0) ret.Append("-");                              if (tm.Days != 0) ret.Append(tm.Days + "D");                              if (tm.Hours != 0) ret.Append(tm.Hours + "H");                              if (tm.Minutes != 0) ret.Append(tm.Minutes + "M");                              if (tm.Seconds != 0) ret.Append(tm.Seconds + "S");                              if (tm.Milliseconds != 0) ret.Append(tm.Milliseconds + "MS");                              return ret.ToString();                          }                      case TagDataType.Bool:                          if (DataTypeStringFormat == TagDisplayDataType.Binary)                          {                              if (((bool)myValue) == true)                                  return "1";                              return "0";                          }                          return myValue.ToString();                      case TagDataType.DateTime:                      case TagDataType.Date:                      case TagDataType.TimeOfDay:                      case TagDataType.LTimeOfDay:                          if (DataTypeStringFormat == TagDisplayDataType.S7DateTime)                          {                              DateTime ak = (DateTime)myValue;                              StringBuilder sb = new StringBuilder();                              sb.Append("DT#");                              sb.Append(ak.Year.ToString().Substring(2));                              sb.Append("-");                              sb.Append(ak.Month);                              sb.Append("-");                              sb.Append(ak.Day);                              sb.Append("-");                              sb.Append(ak.Hour);                              sb.Append(":");                              sb.Append(ak.Minute);                              sb.Append(":");                              sb.Append(ak.Second);                              sb.Append(".");                              sb.Append(ak.Millisecond.ToString().PadRight(3' '0'));                              return sb.ToString();                          }                          else if (DataTypeStringFormat == TagDisplayDataType.S7Date)                          {                              DateTime ak = (DateTime)myValue;                              StringBuilder sb = new StringBuilder();                              sb.Append("D#");                              sb.Append(ak.Year);                              sb.Append("-");                              sb.Append(ak.Month);                              sb.Append("-");                              sb.Append(ak.Day);                              return sb.ToString();                          }                          else if (DataTypeStringFormat == TagDisplayDataType.S7TimeOfDay)                          {                              DateTime ak = (DateTime)myValue;                              StringBuilder sb = new StringBuilder();                              sb.Append("TOD#");                              sb.Append(ak.Hour);                              sb.Append(":");                              sb.Append(ak.Minute);                              sb.Append(":");                              sb.Append(ak.Second);                              sb.Append(".");                              sb.Append(ak.Millisecond.ToString().PadRight(3' '0'));                              return sb.ToString();                          }                          return myValue.ToString();                        case TagDataType.Int:                      case TagDataType.Dint:                      case TagDataType.LWord:                      case TagDataType.LInt:                      case TagDataType.LReal:                      case TagDataType.Byte:                      case TagDataType.SByte:                      case TagDataType.Word:                      case TagDataType.Dword:                      case TagDataType.Float:                      case TagDataType.BCDByte:                      case TagDataType.BCDWord:                      case TagDataType.BCDDWord:                          IFormattable val = myValue as IFormattable ?? 0;                          switch (DataTypeStringFormat)                          {                              case TagDisplayDataType.String:                                  switch (this.TagDataType)                                  {                                      case TagDataType.Int:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((Int16)myValue));                                      case TagDataType.Dint:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((Int32)myValue));                                      case TagDataType.LInt:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((Int64)myValue));                                      case TagDataType.Byte:                                          return Encoding.ASCII.GetString(new[] { (Byte)myValue });                                      case TagDataType.SByte:                                          return Encoding.ASCII.GetString(new[] { BitConverter.GetBytes((SByte)myValue)[0] });                                      case TagDataType.Word:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((UInt16)myValue));                                      case TagDataType.Dword:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((UInt32)myValue));                                      case TagDataType.LWord:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((UInt64)myValue));                                      case TagDataType.Float:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((Single)myValue));                                      case TagDataType.LReal:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((Double)myValue));                                      case TagDataType.BCDByte:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((Byte)myValue));                                      case TagDataType.BCDWord:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((UInt16)myValue));                                      case TagDataType.BCDDWord:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((UInt32)myValue));                                  }                                  break;                              case TagDisplayDataType.Pointer:                                  return "P#" + (Convert.ToInt32(myValue) / 8).ToString() + "." + (Convert.ToInt32(myValue) % 8).ToString();                                  break;                              case TagDisplayDataType.Hexadecimal:                                  string ad = "";                                  switch (_internalGetSize())                                  {                                      case 1:                                          ad = "B#16#";                                          break;                                      case 2:                                          ad = "W#16#";                                          break;                                      case 4:                                          ad = "DW#16#";                                          break;                                      case 8:                                          ad = "L#16#";                                          break;                                  }                                  return ad + val.ToString("X"' NumberFormatInfo.CurrentInfo).PadLeft(_internalGetSize() * 2' '0');                              case TagDisplayDataType.Binary:                                  byte[] bt = new byte[] { };                                  switch (this.TagDataType)                                  {                                      case TagDataType.Int:                                          bt = BitConverter.GetBytes((Int16)myValue);                                          break;                                      case TagDataType.Dint:                                          bt = BitConverter.GetBytes((Int32)myValue);                                          break;                                      case TagDataType.LInt:                                          bt = BitConverter.GetBytes((Int64)myValue);                                          break;                                      case TagDataType.Byte:                                          bt = new byte[] { (byte)myValue };                                          break;                                      case TagDataType.SByte:                                          bt = new byte[] { (byte)myValue };                                          break;                                      case TagDataType.Word:                                          bt = BitConverter.GetBytes((UInt16)myValue);                                          break;                                      case TagDataType.Dword:                                          bt = BitConverter.GetBytes((UInt32)myValue);                                          break;                                      case TagDataType.LWord:                                          bt = BitConverter.GetBytes((UInt64)myValue);                                          break;                                      case TagDataType.Float:                                          bt = BitConverter.GetBytes((float)myValue);                                          break;                                      case TagDataType.LReal:                                          bt = BitConverter.GetBytes((double)myValue);                                          break;                                      case TagDataType.BCDByte:                                          bt = BitConverter.GetBytes((byte)myValue);                                          break;                                      case TagDataType.BCDWord:                                          bt = BitConverter.GetBytes((Int16)myValue);                                          break;                                      case TagDataType.BCDDWord:                                          bt = BitConverter.GetBytes((Int32)myValue);                                          break;                                  }                                  string ret = "";                                  foreach (byte b in bt)                                  {                                      if (ret != "") ret = "_" + ret;                                      ret = libnodave.dec2bin(b).Substring(0' 4) + "_" + libnodave.dec2bin(b).Substring(4' 4) + ret;                                    }                                  return "2#" + ret;                            }                          return val.ToString();                  }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTag.cs,GetValueAsStringInternal,The following statement contains a magic number: switch (this.TagDataType)                  {                      case TagDataType.S5Time:                          {                              if (DataTypeStringFormat == TagDisplayDataType.S5Time)                              {                                  var bt = new byte[2];                                  libnodave.putS5Timeat(bt' 0' (TimeSpan)myValue);                                  return Helper.GetS5Time(bt[0]' bt[1]);                              }                              return ((TimeSpan)myValue).ToString();                          }                      case TagDataType.Time:                      case TagDataType.LTime:                          {                              var tm = (TimeSpan)myValue;                              var ret = new StringBuilder("T#");                              if (tm.TotalMilliseconds < 0) ret.Append("-");                              if (tm.Days != 0) ret.Append(tm.Days + "D");                              if (tm.Hours != 0) ret.Append(tm.Hours + "H");                              if (tm.Minutes != 0) ret.Append(tm.Minutes + "M");                              if (tm.Seconds != 0) ret.Append(tm.Seconds + "S");                              if (tm.Milliseconds != 0) ret.Append(tm.Milliseconds + "MS");                              return ret.ToString();                          }                      case TagDataType.Bool:                          if (DataTypeStringFormat == TagDisplayDataType.Binary)                          {                              if (((bool)myValue) == true)                                  return "1";                              return "0";                          }                          return myValue.ToString();                      case TagDataType.DateTime:                      case TagDataType.Date:                      case TagDataType.TimeOfDay:                      case TagDataType.LTimeOfDay:                          if (DataTypeStringFormat == TagDisplayDataType.S7DateTime)                          {                              DateTime ak = (DateTime)myValue;                              StringBuilder sb = new StringBuilder();                              sb.Append("DT#");                              sb.Append(ak.Year.ToString().Substring(2));                              sb.Append("-");                              sb.Append(ak.Month);                              sb.Append("-");                              sb.Append(ak.Day);                              sb.Append("-");                              sb.Append(ak.Hour);                              sb.Append(":");                              sb.Append(ak.Minute);                              sb.Append(":");                              sb.Append(ak.Second);                              sb.Append(".");                              sb.Append(ak.Millisecond.ToString().PadRight(3' '0'));                              return sb.ToString();                          }                          else if (DataTypeStringFormat == TagDisplayDataType.S7Date)                          {                              DateTime ak = (DateTime)myValue;                              StringBuilder sb = new StringBuilder();                              sb.Append("D#");                              sb.Append(ak.Year);                              sb.Append("-");                              sb.Append(ak.Month);                              sb.Append("-");                              sb.Append(ak.Day);                              return sb.ToString();                          }                          else if (DataTypeStringFormat == TagDisplayDataType.S7TimeOfDay)                          {                              DateTime ak = (DateTime)myValue;                              StringBuilder sb = new StringBuilder();                              sb.Append("TOD#");                              sb.Append(ak.Hour);                              sb.Append(":");                              sb.Append(ak.Minute);                              sb.Append(":");                              sb.Append(ak.Second);                              sb.Append(".");                              sb.Append(ak.Millisecond.ToString().PadRight(3' '0'));                              return sb.ToString();                          }                          return myValue.ToString();                        case TagDataType.Int:                      case TagDataType.Dint:                      case TagDataType.LWord:                      case TagDataType.LInt:                      case TagDataType.LReal:                      case TagDataType.Byte:                      case TagDataType.SByte:                      case TagDataType.Word:                      case TagDataType.Dword:                      case TagDataType.Float:                      case TagDataType.BCDByte:                      case TagDataType.BCDWord:                      case TagDataType.BCDDWord:                          IFormattable val = myValue as IFormattable ?? 0;                          switch (DataTypeStringFormat)                          {                              case TagDisplayDataType.String:                                  switch (this.TagDataType)                                  {                                      case TagDataType.Int:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((Int16)myValue));                                      case TagDataType.Dint:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((Int32)myValue));                                      case TagDataType.LInt:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((Int64)myValue));                                      case TagDataType.Byte:                                          return Encoding.ASCII.GetString(new[] { (Byte)myValue });                                      case TagDataType.SByte:                                          return Encoding.ASCII.GetString(new[] { BitConverter.GetBytes((SByte)myValue)[0] });                                      case TagDataType.Word:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((UInt16)myValue));                                      case TagDataType.Dword:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((UInt32)myValue));                                      case TagDataType.LWord:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((UInt64)myValue));                                      case TagDataType.Float:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((Single)myValue));                                      case TagDataType.LReal:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((Double)myValue));                                      case TagDataType.BCDByte:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((Byte)myValue));                                      case TagDataType.BCDWord:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((UInt16)myValue));                                      case TagDataType.BCDDWord:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((UInt32)myValue));                                  }                                  break;                              case TagDisplayDataType.Pointer:                                  return "P#" + (Convert.ToInt32(myValue) / 8).ToString() + "." + (Convert.ToInt32(myValue) % 8).ToString();                                  break;                              case TagDisplayDataType.Hexadecimal:                                  string ad = "";                                  switch (_internalGetSize())                                  {                                      case 1:                                          ad = "B#16#";                                          break;                                      case 2:                                          ad = "W#16#";                                          break;                                      case 4:                                          ad = "DW#16#";                                          break;                                      case 8:                                          ad = "L#16#";                                          break;                                  }                                  return ad + val.ToString("X"' NumberFormatInfo.CurrentInfo).PadLeft(_internalGetSize() * 2' '0');                              case TagDisplayDataType.Binary:                                  byte[] bt = new byte[] { };                                  switch (this.TagDataType)                                  {                                      case TagDataType.Int:                                          bt = BitConverter.GetBytes((Int16)myValue);                                          break;                                      case TagDataType.Dint:                                          bt = BitConverter.GetBytes((Int32)myValue);                                          break;                                      case TagDataType.LInt:                                          bt = BitConverter.GetBytes((Int64)myValue);                                          break;                                      case TagDataType.Byte:                                          bt = new byte[] { (byte)myValue };                                          break;                                      case TagDataType.SByte:                                          bt = new byte[] { (byte)myValue };                                          break;                                      case TagDataType.Word:                                          bt = BitConverter.GetBytes((UInt16)myValue);                                          break;                                      case TagDataType.Dword:                                          bt = BitConverter.GetBytes((UInt32)myValue);                                          break;                                      case TagDataType.LWord:                                          bt = BitConverter.GetBytes((UInt64)myValue);                                          break;                                      case TagDataType.Float:                                          bt = BitConverter.GetBytes((float)myValue);                                          break;                                      case TagDataType.LReal:                                          bt = BitConverter.GetBytes((double)myValue);                                          break;                                      case TagDataType.BCDByte:                                          bt = BitConverter.GetBytes((byte)myValue);                                          break;                                      case TagDataType.BCDWord:                                          bt = BitConverter.GetBytes((Int16)myValue);                                          break;                                      case TagDataType.BCDDWord:                                          bt = BitConverter.GetBytes((Int32)myValue);                                          break;                                  }                                  string ret = "";                                  foreach (byte b in bt)                                  {                                      if (ret != "") ret = "_" + ret;                                      ret = libnodave.dec2bin(b).Substring(0' 4) + "_" + libnodave.dec2bin(b).Substring(4' 4) + ret;                                    }                                  return "2#" + ret;                            }                          return val.ToString();                  }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTag.cs,GetValueAsStringInternal,The following statement contains a magic number: switch (this.TagDataType)                  {                      case TagDataType.S5Time:                          {                              if (DataTypeStringFormat == TagDisplayDataType.S5Time)                              {                                  var bt = new byte[2];                                  libnodave.putS5Timeat(bt' 0' (TimeSpan)myValue);                                  return Helper.GetS5Time(bt[0]' bt[1]);                              }                              return ((TimeSpan)myValue).ToString();                          }                      case TagDataType.Time:                      case TagDataType.LTime:                          {                              var tm = (TimeSpan)myValue;                              var ret = new StringBuilder("T#");                              if (tm.TotalMilliseconds < 0) ret.Append("-");                              if (tm.Days != 0) ret.Append(tm.Days + "D");                              if (tm.Hours != 0) ret.Append(tm.Hours + "H");                              if (tm.Minutes != 0) ret.Append(tm.Minutes + "M");                              if (tm.Seconds != 0) ret.Append(tm.Seconds + "S");                              if (tm.Milliseconds != 0) ret.Append(tm.Milliseconds + "MS");                              return ret.ToString();                          }                      case TagDataType.Bool:                          if (DataTypeStringFormat == TagDisplayDataType.Binary)                          {                              if (((bool)myValue) == true)                                  return "1";                              return "0";                          }                          return myValue.ToString();                      case TagDataType.DateTime:                      case TagDataType.Date:                      case TagDataType.TimeOfDay:                      case TagDataType.LTimeOfDay:                          if (DataTypeStringFormat == TagDisplayDataType.S7DateTime)                          {                              DateTime ak = (DateTime)myValue;                              StringBuilder sb = new StringBuilder();                              sb.Append("DT#");                              sb.Append(ak.Year.ToString().Substring(2));                              sb.Append("-");                              sb.Append(ak.Month);                              sb.Append("-");                              sb.Append(ak.Day);                              sb.Append("-");                              sb.Append(ak.Hour);                              sb.Append(":");                              sb.Append(ak.Minute);                              sb.Append(":");                              sb.Append(ak.Second);                              sb.Append(".");                              sb.Append(ak.Millisecond.ToString().PadRight(3' '0'));                              return sb.ToString();                          }                          else if (DataTypeStringFormat == TagDisplayDataType.S7Date)                          {                              DateTime ak = (DateTime)myValue;                              StringBuilder sb = new StringBuilder();                              sb.Append("D#");                              sb.Append(ak.Year);                              sb.Append("-");                              sb.Append(ak.Month);                              sb.Append("-");                              sb.Append(ak.Day);                              return sb.ToString();                          }                          else if (DataTypeStringFormat == TagDisplayDataType.S7TimeOfDay)                          {                              DateTime ak = (DateTime)myValue;                              StringBuilder sb = new StringBuilder();                              sb.Append("TOD#");                              sb.Append(ak.Hour);                              sb.Append(":");                              sb.Append(ak.Minute);                              sb.Append(":");                              sb.Append(ak.Second);                              sb.Append(".");                              sb.Append(ak.Millisecond.ToString().PadRight(3' '0'));                              return sb.ToString();                          }                          return myValue.ToString();                        case TagDataType.Int:                      case TagDataType.Dint:                      case TagDataType.LWord:                      case TagDataType.LInt:                      case TagDataType.LReal:                      case TagDataType.Byte:                      case TagDataType.SByte:                      case TagDataType.Word:                      case TagDataType.Dword:                      case TagDataType.Float:                      case TagDataType.BCDByte:                      case TagDataType.BCDWord:                      case TagDataType.BCDDWord:                          IFormattable val = myValue as IFormattable ?? 0;                          switch (DataTypeStringFormat)                          {                              case TagDisplayDataType.String:                                  switch (this.TagDataType)                                  {                                      case TagDataType.Int:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((Int16)myValue));                                      case TagDataType.Dint:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((Int32)myValue));                                      case TagDataType.LInt:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((Int64)myValue));                                      case TagDataType.Byte:                                          return Encoding.ASCII.GetString(new[] { (Byte)myValue });                                      case TagDataType.SByte:                                          return Encoding.ASCII.GetString(new[] { BitConverter.GetBytes((SByte)myValue)[0] });                                      case TagDataType.Word:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((UInt16)myValue));                                      case TagDataType.Dword:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((UInt32)myValue));                                      case TagDataType.LWord:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((UInt64)myValue));                                      case TagDataType.Float:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((Single)myValue));                                      case TagDataType.LReal:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((Double)myValue));                                      case TagDataType.BCDByte:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((Byte)myValue));                                      case TagDataType.BCDWord:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((UInt16)myValue));                                      case TagDataType.BCDDWord:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((UInt32)myValue));                                  }                                  break;                              case TagDisplayDataType.Pointer:                                  return "P#" + (Convert.ToInt32(myValue) / 8).ToString() + "." + (Convert.ToInt32(myValue) % 8).ToString();                                  break;                              case TagDisplayDataType.Hexadecimal:                                  string ad = "";                                  switch (_internalGetSize())                                  {                                      case 1:                                          ad = "B#16#";                                          break;                                      case 2:                                          ad = "W#16#";                                          break;                                      case 4:                                          ad = "DW#16#";                                          break;                                      case 8:                                          ad = "L#16#";                                          break;                                  }                                  return ad + val.ToString("X"' NumberFormatInfo.CurrentInfo).PadLeft(_internalGetSize() * 2' '0');                              case TagDisplayDataType.Binary:                                  byte[] bt = new byte[] { };                                  switch (this.TagDataType)                                  {                                      case TagDataType.Int:                                          bt = BitConverter.GetBytes((Int16)myValue);                                          break;                                      case TagDataType.Dint:                                          bt = BitConverter.GetBytes((Int32)myValue);                                          break;                                      case TagDataType.LInt:                                          bt = BitConverter.GetBytes((Int64)myValue);                                          break;                                      case TagDataType.Byte:                                          bt = new byte[] { (byte)myValue };                                          break;                                      case TagDataType.SByte:                                          bt = new byte[] { (byte)myValue };                                          break;                                      case TagDataType.Word:                                          bt = BitConverter.GetBytes((UInt16)myValue);                                          break;                                      case TagDataType.Dword:                                          bt = BitConverter.GetBytes((UInt32)myValue);                                          break;                                      case TagDataType.LWord:                                          bt = BitConverter.GetBytes((UInt64)myValue);                                          break;                                      case TagDataType.Float:                                          bt = BitConverter.GetBytes((float)myValue);                                          break;                                      case TagDataType.LReal:                                          bt = BitConverter.GetBytes((double)myValue);                                          break;                                      case TagDataType.BCDByte:                                          bt = BitConverter.GetBytes((byte)myValue);                                          break;                                      case TagDataType.BCDWord:                                          bt = BitConverter.GetBytes((Int16)myValue);                                          break;                                      case TagDataType.BCDDWord:                                          bt = BitConverter.GetBytes((Int32)myValue);                                          break;                                  }                                  string ret = "";                                  foreach (byte b in bt)                                  {                                      if (ret != "") ret = "_" + ret;                                      ret = libnodave.dec2bin(b).Substring(0' 4) + "_" + libnodave.dec2bin(b).Substring(4' 4) + ret;                                    }                                  return "2#" + ret;                            }                          return val.ToString();                  }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTag.cs,GetValueAsStringInternal,The following statement contains a magic number: switch (this.TagDataType)                  {                      case TagDataType.S5Time:                          {                              if (DataTypeStringFormat == TagDisplayDataType.S5Time)                              {                                  var bt = new byte[2];                                  libnodave.putS5Timeat(bt' 0' (TimeSpan)myValue);                                  return Helper.GetS5Time(bt[0]' bt[1]);                              }                              return ((TimeSpan)myValue).ToString();                          }                      case TagDataType.Time:                      case TagDataType.LTime:                          {                              var tm = (TimeSpan)myValue;                              var ret = new StringBuilder("T#");                              if (tm.TotalMilliseconds < 0) ret.Append("-");                              if (tm.Days != 0) ret.Append(tm.Days + "D");                              if (tm.Hours != 0) ret.Append(tm.Hours + "H");                              if (tm.Minutes != 0) ret.Append(tm.Minutes + "M");                              if (tm.Seconds != 0) ret.Append(tm.Seconds + "S");                              if (tm.Milliseconds != 0) ret.Append(tm.Milliseconds + "MS");                              return ret.ToString();                          }                      case TagDataType.Bool:                          if (DataTypeStringFormat == TagDisplayDataType.Binary)                          {                              if (((bool)myValue) == true)                                  return "1";                              return "0";                          }                          return myValue.ToString();                      case TagDataType.DateTime:                      case TagDataType.Date:                      case TagDataType.TimeOfDay:                      case TagDataType.LTimeOfDay:                          if (DataTypeStringFormat == TagDisplayDataType.S7DateTime)                          {                              DateTime ak = (DateTime)myValue;                              StringBuilder sb = new StringBuilder();                              sb.Append("DT#");                              sb.Append(ak.Year.ToString().Substring(2));                              sb.Append("-");                              sb.Append(ak.Month);                              sb.Append("-");                              sb.Append(ak.Day);                              sb.Append("-");                              sb.Append(ak.Hour);                              sb.Append(":");                              sb.Append(ak.Minute);                              sb.Append(":");                              sb.Append(ak.Second);                              sb.Append(".");                              sb.Append(ak.Millisecond.ToString().PadRight(3' '0'));                              return sb.ToString();                          }                          else if (DataTypeStringFormat == TagDisplayDataType.S7Date)                          {                              DateTime ak = (DateTime)myValue;                              StringBuilder sb = new StringBuilder();                              sb.Append("D#");                              sb.Append(ak.Year);                              sb.Append("-");                              sb.Append(ak.Month);                              sb.Append("-");                              sb.Append(ak.Day);                              return sb.ToString();                          }                          else if (DataTypeStringFormat == TagDisplayDataType.S7TimeOfDay)                          {                              DateTime ak = (DateTime)myValue;                              StringBuilder sb = new StringBuilder();                              sb.Append("TOD#");                              sb.Append(ak.Hour);                              sb.Append(":");                              sb.Append(ak.Minute);                              sb.Append(":");                              sb.Append(ak.Second);                              sb.Append(".");                              sb.Append(ak.Millisecond.ToString().PadRight(3' '0'));                              return sb.ToString();                          }                          return myValue.ToString();                        case TagDataType.Int:                      case TagDataType.Dint:                      case TagDataType.LWord:                      case TagDataType.LInt:                      case TagDataType.LReal:                      case TagDataType.Byte:                      case TagDataType.SByte:                      case TagDataType.Word:                      case TagDataType.Dword:                      case TagDataType.Float:                      case TagDataType.BCDByte:                      case TagDataType.BCDWord:                      case TagDataType.BCDDWord:                          IFormattable val = myValue as IFormattable ?? 0;                          switch (DataTypeStringFormat)                          {                              case TagDisplayDataType.String:                                  switch (this.TagDataType)                                  {                                      case TagDataType.Int:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((Int16)myValue));                                      case TagDataType.Dint:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((Int32)myValue));                                      case TagDataType.LInt:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((Int64)myValue));                                      case TagDataType.Byte:                                          return Encoding.ASCII.GetString(new[] { (Byte)myValue });                                      case TagDataType.SByte:                                          return Encoding.ASCII.GetString(new[] { BitConverter.GetBytes((SByte)myValue)[0] });                                      case TagDataType.Word:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((UInt16)myValue));                                      case TagDataType.Dword:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((UInt32)myValue));                                      case TagDataType.LWord:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((UInt64)myValue));                                      case TagDataType.Float:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((Single)myValue));                                      case TagDataType.LReal:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((Double)myValue));                                      case TagDataType.BCDByte:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((Byte)myValue));                                      case TagDataType.BCDWord:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((UInt16)myValue));                                      case TagDataType.BCDDWord:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((UInt32)myValue));                                  }                                  break;                              case TagDisplayDataType.Pointer:                                  return "P#" + (Convert.ToInt32(myValue) / 8).ToString() + "." + (Convert.ToInt32(myValue) % 8).ToString();                                  break;                              case TagDisplayDataType.Hexadecimal:                                  string ad = "";                                  switch (_internalGetSize())                                  {                                      case 1:                                          ad = "B#16#";                                          break;                                      case 2:                                          ad = "W#16#";                                          break;                                      case 4:                                          ad = "DW#16#";                                          break;                                      case 8:                                          ad = "L#16#";                                          break;                                  }                                  return ad + val.ToString("X"' NumberFormatInfo.CurrentInfo).PadLeft(_internalGetSize() * 2' '0');                              case TagDisplayDataType.Binary:                                  byte[] bt = new byte[] { };                                  switch (this.TagDataType)                                  {                                      case TagDataType.Int:                                          bt = BitConverter.GetBytes((Int16)myValue);                                          break;                                      case TagDataType.Dint:                                          bt = BitConverter.GetBytes((Int32)myValue);                                          break;                                      case TagDataType.LInt:                                          bt = BitConverter.GetBytes((Int64)myValue);                                          break;                                      case TagDataType.Byte:                                          bt = new byte[] { (byte)myValue };                                          break;                                      case TagDataType.SByte:                                          bt = new byte[] { (byte)myValue };                                          break;                                      case TagDataType.Word:                                          bt = BitConverter.GetBytes((UInt16)myValue);                                          break;                                      case TagDataType.Dword:                                          bt = BitConverter.GetBytes((UInt32)myValue);                                          break;                                      case TagDataType.LWord:                                          bt = BitConverter.GetBytes((UInt64)myValue);                                          break;                                      case TagDataType.Float:                                          bt = BitConverter.GetBytes((float)myValue);                                          break;                                      case TagDataType.LReal:                                          bt = BitConverter.GetBytes((double)myValue);                                          break;                                      case TagDataType.BCDByte:                                          bt = BitConverter.GetBytes((byte)myValue);                                          break;                                      case TagDataType.BCDWord:                                          bt = BitConverter.GetBytes((Int16)myValue);                                          break;                                      case TagDataType.BCDDWord:                                          bt = BitConverter.GetBytes((Int32)myValue);                                          break;                                  }                                  string ret = "";                                  foreach (byte b in bt)                                  {                                      if (ret != "") ret = "_" + ret;                                      ret = libnodave.dec2bin(b).Substring(0' 4) + "_" + libnodave.dec2bin(b).Substring(4' 4) + ret;                                    }                                  return "2#" + ret;                            }                          return val.ToString();                  }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTag.cs,getNumberFromString,The following statement contains a magic number: val *= 10;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTag.cs,ChangeAddressFromString,The following statement contains a magic number: symbolicAccessKey = newPlcAddress.Substring(pos + 1' newPlcAddress.Length - pos - 2);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTag.cs,ChangeAddressFromString,The following statement contains a magic number: plcAddress.Substring(2' 3).Contains(" ")
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTag.cs,ChangeAddressFromString,The following statement contains a magic number: plcAddress.Substring(2' 3).Contains(" ")
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTag.cs,ChangeAddressFromString,The following statement contains a magic number: _ArraySize = Convert.ToInt32(myPlcAddress[2]);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTag.cs,ChangeAddressFromString,The following statement contains a magic number: myPlcAddress.Length >= 3
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTag.cs,ChangeAddressFromString,The following statement contains a magic number: switch (myPlcAddress[1])                      {                          case "word":                          case "int":                          case "date":                          case "s5time":                              tsize = 2;                              break;                          case "real":                          case "dword":                          case "dint":                          case "time":                          case "time_of_day":                              tsize = 4;                              break;                          case "lreal":                          case "lword":                          case "lint":                          case "ltime":                          case "ltime_of_day":                              tsize = 8;                              break;                      }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTag.cs,ChangeAddressFromString,The following statement contains a magic number: switch (myPlcAddress[1])                      {                          case "word":                          case "int":                          case "date":                          case "s5time":                              tsize = 2;                              break;                          case "real":                          case "dword":                          case "dint":                          case "time":                          case "time_of_day":                              tsize = 4;                              break;                          case "lreal":                          case "lword":                          case "lint":                          case "ltime":                          case "ltime_of_day":                              tsize = 8;                              break;                      }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTag.cs,ChangeAddressFromString,The following statement contains a magic number: switch (myPlcAddress[1])                      {                          case "word":                          case "int":                          case "date":                          case "s5time":                              tsize = 2;                              break;                          case "real":                          case "dword":                          case "dint":                          case "time":                          case "time_of_day":                              tsize = 4;                              break;                          case "lreal":                          case "lword":                          case "lint":                          case "ltime":                          case "ltime_of_day":                              tsize = 8;                              break;                      }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTag.cs,ChangeAddressFromString,The following statement contains a magic number: _ArraySize *= 8;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTag.cs,ChangeAddressFromString,The following statement contains a magic number: ArraySize -= 2;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTag.cs,ChangeAddressFromString,The following statement contains a magic number: plcAddress.Length > 1 && plcAddress.Substring(0' 2).ToLower() == "p#"
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTag.cs,_readValueFromBuffer,The following statement contains a magic number: switch (this.TagDataType)                  {                      case TagDataType.String:                          {                              if (!(this is PLCNckTag))                              {                                  int maxsize = (int)buff[startpos];                                  int size = (int)buff[startpos + 1];                                    if (size > maxsize)                                      size = maxsize;                                  if (size > ArraySize)                                      size = ArraySize;                                    _setValueProp = Encoding.Default.GetString(buff' startpos + 2' size);                              }                              else                                  _setValueProp = Encoding.Default.GetString(buff' startpos' Math.Min(buff.Length - startpos' ArraySize)).Split('\0')[0];                          }                          break;                      case TagDataType.CharArray:                          {                              //var sb = new StringBuilder();                              //for (var n = 0; n < ((buff.Length - startpos) < ArraySize ? buff.Length - startpos : ArraySize); n++)                              //    sb.Append((char)buff[n + startpos]);                              //_setValueProp = sb.ToString();                                if (this is PLCNckTag) //BugFix für NCK v2.6                                  _setValueProp = Encoding.Default.GetString(buff' startpos' Math.Min(buff.Length - startpos' ArraySize)).Split('\0')[0];                              else                                  _setValueProp = Encoding.Default.GetString(buff' startpos' Math.Min(buff.Length - startpos' ArraySize)).Trim('\0');                          }                          break;                      case TagDataType.ByteArray:                          {                              var val = new Byte[ArraySize];                              Array.Copy(buff' startpos' val' 0' ArraySize);                                /*                              for (var n = 0; n < ArraySize; n++)                                  val[n] = buff[n + startpos];                              */                              _setValueProp = val;                          }                          break;                      case TagDataType.BCDArray:                          {                              ulong wrt = 0;                                for (int i = 0; i < ArraySize; i++)                              {                                  wrt *= 10;                                  wrt += (ulong)libnodave.getBCD8from(buff' startpos + i);                              }                                _setValueProp = wrt;                          }                          break;                        case TagDataType.Bool:                      case TagDataType.Byte:                      case TagDataType.SByte:                      case TagDataType.Time:                      case TagDataType.LTime:                      case TagDataType.Date:                      case TagDataType.TimeOfDay:                      case TagDataType.LTimeOfDay:                      case TagDataType.Word:                      case TagDataType.BCDByte:                      case TagDataType.Int:                      case TagDataType.S5Time:                      case TagDataType.BCDWord:                      case TagDataType.BCDDWord:                      case TagDataType.Dint:                      case TagDataType.Dword:                      case TagDataType.Float:                      case TagDataType.LInt:                      case TagDataType.LWord:                      case TagDataType.LReal:                      case TagDataType.DateTime:                          {                              if (ArraySize < 2)                              {                                  switch (this.TagDataType)                                  {                                      case TagDataType.Bool:                                          _setValueProp = libnodave.getBit(buff[startpos]' BitAddress);                                          break;                                      case TagDataType.Byte:                                          _setValueProp = buff[startpos];                                          break;                                      case TagDataType.SByte:                                          _setValueProp = libnodave.getS8from(buff' startpos);                                          break;                                      case TagDataType.Time:                                          _setValueProp = libnodave.getTimefrom(buff' startpos);                                          break;                                      case TagDataType.LTime:                                          _setValueProp = libnodave.getLTimefrom(buff' startpos);                                          break;                                      case TagDataType.Date:                                          _setValueProp = libnodave.getDatefrom(buff' startpos);                                          break;                                      case TagDataType.TimeOfDay:                                          _setValueProp = libnodave.getTimeOfDayfrom(buff' startpos);                                          break;                                      case TagDataType.LTimeOfDay:                                          _setValueProp = libnodave.getLTimeOfDayfrom(buff' startpos);                                          break;                                      case TagDataType.Word:                                          _setValueProp = libnodave.getU16from(buff' startpos);                                          break;                                      case TagDataType.BCDByte:                                          _setValueProp = libnodave.getBCD8from(buff' startpos);                                          break;                                      case TagDataType.Int:                                          _setValueProp = libnodave.getS16from(buff' startpos);                                          break;                                      case TagDataType.S5Time:                                          _setValueProp = libnodave.getS5Timefrom(buff' startpos);                                          break;                                      case TagDataType.BCDWord:                                          _setValueProp = libnodave.getBCD16from(buff' startpos);                                          break;                                      case TagDataType.BCDDWord:                                          _setValueProp = libnodave.getBCD32from(buff' startpos);                                          break;                                      case TagDataType.Dint:                                          _setValueProp = libnodave.getS32from(buff' startpos);                                          break;                                      case TagDataType.Dword:                                          _setValueProp = libnodave.getU32from(buff' startpos);                                          break;                                      case TagDataType.LWord:                                          _setValueProp = libnodave.getU64from(buff' startpos);                                          break;                                      case TagDataType.LInt:                                          _setValueProp = libnodave.getS64from(buff' startpos);                                          break;                                      case TagDataType.Float:                                          _setValueProp = libnodave.getFloatfrom(buff' startpos);                                          break;                                      case TagDataType.LReal:                                          _setValueProp = libnodave.getDoublefrom(buff' startpos);                                          break;                                      case TagDataType.DateTime:                                          _setValueProp = libnodave.getDateTimefrom(buff' startpos);                                          break;                                  }                              }                              else                              {                                  switch (this.TagDataType)                                  {                                      case TagDataType.Bool:                                          {                                              var values = new List<bool>();                                              var akBit = BitAddress;                                              var akbyte = startpos;                                              for (int n = 0; n < ArraySize; n++)                                              {                                                  values.Add(libnodave.getBit(buff[akbyte]' akBit));                                                  akBit++;                                                  if (akBit > 7)                                                  {                                                      akBit = 0;                                                      akbyte++;                                                  }                                              }                                                _setValueProp = values.ToArray();                                              break;                                          }                                      case TagDataType.Byte:                                          {                                              var values = new List<Byte>();                                              var mSize = _internalGetBaseTypeSize();                                              for (int n = 0; n < ArraySize; n++)                                                  values.Add(buff[startpos + n * mSize]);                                              _setValueProp = values.ToArray();                                              break;                                          }                                      case TagDataType.SByte:                                          {                                              var values = new List<SByte>();                                              var mSize = _internalGetBaseTypeSize();                                              for (int n = 0; n < ArraySize; n++)                                                  values.Add(libnodave.getS8from(buff' startpos + n * mSize));                                              _setValueProp = values.ToArray();                                              break;                                          }                                      case TagDataType.Time:                                          {                                              var values = new List<TimeSpan>();                                              var mSize = _internalGetBaseTypeSize();                                              for (int n = 0; n < ArraySize; n++)                                                  values.Add(libnodave.getTimefrom(buff' startpos + n * mSize));                                              _setValueProp = values.ToArray();                                              break;                                          }                                      case TagDataType.LTime:                                          {                                              var values = new List<TimeSpan>();                                              var mSize = _internalGetBaseTypeSize();                                              for (int n = 0; n < ArraySize; n++)                                                  values.Add(libnodave.getLTimefrom(buff' startpos + n * mSize));                                              _setValueProp = values.ToArray();                                              break;                                          }                                      case TagDataType.Date:                                          {                                              var values = new List<DateTime>();                                              var mSize = _internalGetBaseTypeSize();                                              for (int n = 0; n < ArraySize; n++)                                                  values.Add(libnodave.getDatefrom(buff' startpos + n * mSize));                                              _setValueProp = values.ToArray();                                              break;                                          }                                      case TagDataType.TimeOfDay:                                          {                                              var values = new List<DateTime>();                                              var mSize = _internalGetBaseTypeSize();                                              for (int n = 0; n < ArraySize; n++)                                                  values.Add(libnodave.getTimeOfDayfrom(buff' startpos + n * mSize));                                              _setValueProp = values.ToArray();                                              break;                                          }                                      case TagDataType.LTimeOfDay:                                          {                                              var values = new List<DateTime>();                                              var mSize = _internalGetBaseTypeSize();                                              for (int n = 0; n < ArraySize; n++)                                                  values.Add(libnodave.getLTimeOfDayfrom(buff' startpos + n * mSize));                                              _setValueProp = values.ToArray();                                              break;                                          }                                      case TagDataType.Word:                                          {                                              var values = new List<UInt16>();                                              var mSize = _internalGetBaseTypeSize();                                              for (int n = 0; n < ArraySize; n++)                                                  values.Add(libnodave.getU16from(buff' startpos + n * mSize));                                              _setValueProp = values.ToArray();                                              break;                                          }                                      case TagDataType.BCDByte:                                          {                                              var values = new List<int>();                                              var mSize = _internalGetBaseTypeSize();                                              for (int n = 0; n < ArraySize; n++)                                                  values.Add(libnodave.getBCD8from(buff' startpos + n * mSize));                                              _setValueProp = values.ToArray();                                              break;                                          }                                      case TagDataType.Int:                                          {                                              var values = new List<Int16>();                                              var mSize = _internalGetBaseTypeSize();                                              for (int n = 0; n < ArraySize; n++)                                                  values.Add(libnodave.getS16from(buff' startpos + n * mSize));                                              _setValueProp = values.ToArray();                                              break;                                          }                                      case TagDataType.S5Time:                                          {                                              var values = new List<TimeSpan>();                                              var mSize = _internalGetBaseTypeSize();                                              for (int n = 0; n < ArraySize; n++)                                                  values.Add(libnodave.getS5Timefrom(buff' startpos + n * mSize));                                              _setValueProp = values.ToArray();                                              break;                                          }                                      case TagDataType.BCDWord:                                          {                                              var values = new List<Int32>();                                              var mSize = _internalGetBaseTypeSize();                                              for (int n = 0; n < ArraySize; n++)                                                  values.Add(libnodave.getBCD16from(buff' startpos + n * mSize));                                              _setValueProp = values.ToArray();                                              break;                                          }                                      case TagDataType.BCDDWord:                                          {                                              var values = new List<Int32>();                                              var mSize = _internalGetBaseTypeSize();                                              for (int n = 0; n < ArraySize; n++)                                                  values.Add(libnodave.getBCD32from(buff' startpos + n * mSize));                                              _setValueProp = values.ToArray();                                              break;                                          }                                      case TagDataType.Dint:                                          {                                              var values = new List<Int32>();                                              var mSize = _internalGetBaseTypeSize();                                              for (int n = 0; n < ArraySize; n++)                                                  values.Add(libnodave.getS32from(buff' startpos + n * mSize));                                              _setValueProp = values.ToArray();                                              break;                                          }                                      case TagDataType.Dword:                                          {                                              var values = new List<UInt32>();                                              var mSize = _internalGetBaseTypeSize();                                              for (int n = 0; n < ArraySize; n++)                                                  values.Add(libnodave.getU32from(buff' startpos + n * mSize));                                              _setValueProp = values.ToArray();                                              break;                                          }                                      case TagDataType.Float:                                          {                                              var values = new List<float>();                                              var mSize = _internalGetBaseTypeSize();                                              for (int n = 0; n < ArraySize; n++)                                                  values.Add(libnodave.getFloatfrom(buff' startpos + n * mSize));                                              _setValueProp = values.ToArray();                                              break;                                          }                                      case TagDataType.LInt:                                          {                                              var values = new List<Int64>();                                              var mSize = _internalGetBaseTypeSize();                                              for (int n = 0; n < ArraySize; n++)                                                  values.Add(libnodave.getS64from(buff' startpos + n * mSize));                                              _setValueProp = values.ToArray();                                              break;                                          }                                      case TagDataType.LWord:                                          {                                              var values = new List<UInt64>();                                              var mSize = _internalGetBaseTypeSize();                                              for (int n = 0; n < ArraySize; n++)                                                  values.Add(libnodave.getU64from(buff' startpos + n * mSize));                                              _setValueProp = values.ToArray();                                              break;                                          }                                      case TagDataType.LReal:                                          {                                              var values = new List<double>();                                              var mSize = _internalGetBaseTypeSize();                                              for (int n = 0; n < ArraySize; n++)                                                  values.Add(libnodave.getDoublefrom(buff' startpos + n * mSize));                                              _setValueProp = values.ToArray();                                              break;                                          }                                      case TagDataType.DateTime:                                          {                                              var values = new List<DateTime>();                                              var mSize = _internalGetBaseTypeSize();                                              for (int n = 0; n < ArraySize; n++)                                                  values.Add(libnodave.getDateTimefrom(buff' startpos + n * mSize));                                              _setValueProp = values.ToArray();                                              break;                                          }                                  }                              }                          }                          break;                  }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTag.cs,_readValueFromBuffer,The following statement contains a magic number: switch (this.TagDataType)                  {                      case TagDataType.String:                          {                              if (!(this is PLCNckTag))                              {                                  int maxsize = (int)buff[startpos];                                  int size = (int)buff[startpos + 1];                                    if (size > maxsize)                                      size = maxsize;                                  if (size > ArraySize)                                      size = ArraySize;                                    _setValueProp = Encoding.Default.GetString(buff' startpos + 2' size);                              }                              else                                  _setValueProp = Encoding.Default.GetString(buff' startpos' Math.Min(buff.Length - startpos' ArraySize)).Split('\0')[0];                          }                          break;                      case TagDataType.CharArray:                          {                              //var sb = new StringBuilder();                              //for (var n = 0; n < ((buff.Length - startpos) < ArraySize ? buff.Length - startpos : ArraySize); n++)                              //    sb.Append((char)buff[n + startpos]);                              //_setValueProp = sb.ToString();                                if (this is PLCNckTag) //BugFix für NCK v2.6                                  _setValueProp = Encoding.Default.GetString(buff' startpos' Math.Min(buff.Length - startpos' ArraySize)).Split('\0')[0];                              else                                  _setValueProp = Encoding.Default.GetString(buff' startpos' Math.Min(buff.Length - startpos' ArraySize)).Trim('\0');                          }                          break;                      case TagDataType.ByteArray:                          {                              var val = new Byte[ArraySize];                              Array.Copy(buff' startpos' val' 0' ArraySize);                                /*                              for (var n = 0; n < ArraySize; n++)                                  val[n] = buff[n + startpos];                              */                              _setValueProp = val;                          }                          break;                      case TagDataType.BCDArray:                          {                              ulong wrt = 0;                                for (int i = 0; i < ArraySize; i++)                              {                                  wrt *= 10;                                  wrt += (ulong)libnodave.getBCD8from(buff' startpos + i);                              }                                _setValueProp = wrt;                          }                          break;                        case TagDataType.Bool:                      case TagDataType.Byte:                      case TagDataType.SByte:                      case TagDataType.Time:                      case TagDataType.LTime:                      case TagDataType.Date:                      case TagDataType.TimeOfDay:                      case TagDataType.LTimeOfDay:                      case TagDataType.Word:                      case TagDataType.BCDByte:                      case TagDataType.Int:                      case TagDataType.S5Time:                      case TagDataType.BCDWord:                      case TagDataType.BCDDWord:                      case TagDataType.Dint:                      case TagDataType.Dword:                      case TagDataType.Float:                      case TagDataType.LInt:                      case TagDataType.LWord:                      case TagDataType.LReal:                      case TagDataType.DateTime:                          {                              if (ArraySize < 2)                              {                                  switch (this.TagDataType)                                  {                                      case TagDataType.Bool:                                          _setValueProp = libnodave.getBit(buff[startpos]' BitAddress);                                          break;                                      case TagDataType.Byte:                                          _setValueProp = buff[startpos];                                          break;                                      case TagDataType.SByte:                                          _setValueProp = libnodave.getS8from(buff' startpos);                                          break;                                      case TagDataType.Time:                                          _setValueProp = libnodave.getTimefrom(buff' startpos);                                          break;                                      case TagDataType.LTime:                                          _setValueProp = libnodave.getLTimefrom(buff' startpos);                                          break;                                      case TagDataType.Date:                                          _setValueProp = libnodave.getDatefrom(buff' startpos);                                          break;                                      case TagDataType.TimeOfDay:                                          _setValueProp = libnodave.getTimeOfDayfrom(buff' startpos);                                          break;                                      case TagDataType.LTimeOfDay:                                          _setValueProp = libnodave.getLTimeOfDayfrom(buff' startpos);                                          break;                                      case TagDataType.Word:                                          _setValueProp = libnodave.getU16from(buff' startpos);                                          break;                                      case TagDataType.BCDByte:                                          _setValueProp = libnodave.getBCD8from(buff' startpos);                                          break;                                      case TagDataType.Int:                                          _setValueProp = libnodave.getS16from(buff' startpos);                                          break;                                      case TagDataType.S5Time:                                          _setValueProp = libnodave.getS5Timefrom(buff' startpos);                                          break;                                      case TagDataType.BCDWord:                                          _setValueProp = libnodave.getBCD16from(buff' startpos);                                          break;                                      case TagDataType.BCDDWord:                                          _setValueProp = libnodave.getBCD32from(buff' startpos);                                          break;                                      case TagDataType.Dint:                                          _setValueProp = libnodave.getS32from(buff' startpos);                                          break;                                      case TagDataType.Dword:                                          _setValueProp = libnodave.getU32from(buff' startpos);                                          break;                                      case TagDataType.LWord:                                          _setValueProp = libnodave.getU64from(buff' startpos);                                          break;                                      case TagDataType.LInt:                                          _setValueProp = libnodave.getS64from(buff' startpos);                                          break;                                      case TagDataType.Float:                                          _setValueProp = libnodave.getFloatfrom(buff' startpos);                                          break;                                      case TagDataType.LReal:                                          _setValueProp = libnodave.getDoublefrom(buff' startpos);                                          break;                                      case TagDataType.DateTime:                                          _setValueProp = libnodave.getDateTimefrom(buff' startpos);                                          break;                                  }                              }                              else                              {                                  switch (this.TagDataType)                                  {                                      case TagDataType.Bool:                                          {                                              var values = new List<bool>();                                              var akBit = BitAddress;                                              var akbyte = startpos;                                              for (int n = 0; n < ArraySize; n++)                                              {                                                  values.Add(libnodave.getBit(buff[akbyte]' akBit));                                                  akBit++;                                                  if (akBit > 7)                                                  {                                                      akBit = 0;                                                      akbyte++;                                                  }                                              }                                                _setValueProp = values.ToArray();                                              break;                                          }                                      case TagDataType.Byte:                                          {                                              var values = new List<Byte>();                                              var mSize = _internalGetBaseTypeSize();                                              for (int n = 0; n < ArraySize; n++)                                                  values.Add(buff[startpos + n * mSize]);                                              _setValueProp = values.ToArray();                                              break;                                          }                                      case TagDataType.SByte:                                          {                                              var values = new List<SByte>();                                              var mSize = _internalGetBaseTypeSize();                                              for (int n = 0; n < ArraySize; n++)                                                  values.Add(libnodave.getS8from(buff' startpos + n * mSize));                                              _setValueProp = values.ToArray();                                              break;                                          }                                      case TagDataType.Time:                                          {                                              var values = new List<TimeSpan>();                                              var mSize = _internalGetBaseTypeSize();                                              for (int n = 0; n < ArraySize; n++)                                                  values.Add(libnodave.getTimefrom(buff' startpos + n * mSize));                                              _setValueProp = values.ToArray();                                              break;                                          }                                      case TagDataType.LTime:                                          {                                              var values = new List<TimeSpan>();                                              var mSize = _internalGetBaseTypeSize();                                              for (int n = 0; n < ArraySize; n++)                                                  values.Add(libnodave.getLTimefrom(buff' startpos + n * mSize));                                              _setValueProp = values.ToArray();                                              break;                                          }                                      case TagDataType.Date:                                          {                                              var values = new List<DateTime>();                                              var mSize = _internalGetBaseTypeSize();                                              for (int n = 0; n < ArraySize; n++)                                                  values.Add(libnodave.getDatefrom(buff' startpos + n * mSize));                                              _setValueProp = values.ToArray();                                              break;                                          }                                      case TagDataType.TimeOfDay:                                          {                                              var values = new List<DateTime>();                                              var mSize = _internalGetBaseTypeSize();                                              for (int n = 0; n < ArraySize; n++)                                                  values.Add(libnodave.getTimeOfDayfrom(buff' startpos + n * mSize));                                              _setValueProp = values.ToArray();                                              break;                                          }                                      case TagDataType.LTimeOfDay:                                          {                                              var values = new List<DateTime>();                                              var mSize = _internalGetBaseTypeSize();                                              for (int n = 0; n < ArraySize; n++)                                                  values.Add(libnodave.getLTimeOfDayfrom(buff' startpos + n * mSize));                                              _setValueProp = values.ToArray();                                              break;                                          }                                      case TagDataType.Word:                                          {                                              var values = new List<UInt16>();                                              var mSize = _internalGetBaseTypeSize();                                              for (int n = 0; n < ArraySize; n++)                                                  values.Add(libnodave.getU16from(buff' startpos + n * mSize));                                              _setValueProp = values.ToArray();                                              break;                                          }                                      case TagDataType.BCDByte:                                          {                                              var values = new List<int>();                                              var mSize = _internalGetBaseTypeSize();                                              for (int n = 0; n < ArraySize; n++)                                                  values.Add(libnodave.getBCD8from(buff' startpos + n * mSize));                                              _setValueProp = values.ToArray();                                              break;                                          }                                      case TagDataType.Int:                                          {                                              var values = new List<Int16>();                                              var mSize = _internalGetBaseTypeSize();                                              for (int n = 0; n < ArraySize; n++)                                                  values.Add(libnodave.getS16from(buff' startpos + n * mSize));                                              _setValueProp = values.ToArray();                                              break;                                          }                                      case TagDataType.S5Time:                                          {                                              var values = new List<TimeSpan>();                                              var mSize = _internalGetBaseTypeSize();                                              for (int n = 0; n < ArraySize; n++)                                                  values.Add(libnodave.getS5Timefrom(buff' startpos + n * mSize));                                              _setValueProp = values.ToArray();                                              break;                                          }                                      case TagDataType.BCDWord:                                          {                                              var values = new List<Int32>();                                              var mSize = _internalGetBaseTypeSize();                                              for (int n = 0; n < ArraySize; n++)                                                  values.Add(libnodave.getBCD16from(buff' startpos + n * mSize));                                              _setValueProp = values.ToArray();                                              break;                                          }                                      case TagDataType.BCDDWord:                                          {                                              var values = new List<Int32>();                                              var mSize = _internalGetBaseTypeSize();                                              for (int n = 0; n < ArraySize; n++)                                                  values.Add(libnodave.getBCD32from(buff' startpos + n * mSize));                                              _setValueProp = values.ToArray();                                              break;                                          }                                      case TagDataType.Dint:                                          {                                              var values = new List<Int32>();                                              var mSize = _internalGetBaseTypeSize();                                              for (int n = 0; n < ArraySize; n++)                                                  values.Add(libnodave.getS32from(buff' startpos + n * mSize));                                              _setValueProp = values.ToArray();                                              break;                                          }                                      case TagDataType.Dword:                                          {                                              var values = new List<UInt32>();                                              var mSize = _internalGetBaseTypeSize();                                              for (int n = 0; n < ArraySize; n++)                                                  values.Add(libnodave.getU32from(buff' startpos + n * mSize));                                              _setValueProp = values.ToArray();                                              break;                                          }                                      case TagDataType.Float:                                          {                                              var values = new List<float>();                                              var mSize = _internalGetBaseTypeSize();                                              for (int n = 0; n < ArraySize; n++)                                                  values.Add(libnodave.getFloatfrom(buff' startpos + n * mSize));                                              _setValueProp = values.ToArray();                                              break;                                          }                                      case TagDataType.LInt:                                          {                                              var values = new List<Int64>();                                              var mSize = _internalGetBaseTypeSize();                                              for (int n = 0; n < ArraySize; n++)                                                  values.Add(libnodave.getS64from(buff' startpos + n * mSize));                                              _setValueProp = values.ToArray();                                              break;                                          }                                      case TagDataType.LWord:                                          {                                              var values = new List<UInt64>();                                              var mSize = _internalGetBaseTypeSize();                                              for (int n = 0; n < ArraySize; n++)                                                  values.Add(libnodave.getU64from(buff' startpos + n * mSize));                                              _setValueProp = values.ToArray();                                              break;                                          }                                      case TagDataType.LReal:                                          {                                              var values = new List<double>();                                              var mSize = _internalGetBaseTypeSize();                                              for (int n = 0; n < ArraySize; n++)                                                  values.Add(libnodave.getDoublefrom(buff' startpos + n * mSize));                                              _setValueProp = values.ToArray();                                              break;                                          }                                      case TagDataType.DateTime:                                          {                                              var values = new List<DateTime>();                                              var mSize = _internalGetBaseTypeSize();                                              for (int n = 0; n < ArraySize; n++)                                                  values.Add(libnodave.getDateTimefrom(buff' startpos + n * mSize));                                              _setValueProp = values.ToArray();                                              break;                                          }                                  }                              }                          }                          break;                  }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTag.cs,_readValueFromBuffer,The following statement contains a magic number: switch (this.TagDataType)                  {                      case TagDataType.String:                          {                              if (!(this is PLCNckTag))                              {                                  int maxsize = (int)buff[startpos];                                  int size = (int)buff[startpos + 1];                                    if (size > maxsize)                                      size = maxsize;                                  if (size > ArraySize)                                      size = ArraySize;                                    _setValueProp = Encoding.Default.GetString(buff' startpos + 2' size);                              }                              else                                  _setValueProp = Encoding.Default.GetString(buff' startpos' Math.Min(buff.Length - startpos' ArraySize)).Split('\0')[0];                          }                          break;                      case TagDataType.CharArray:                          {                              //var sb = new StringBuilder();                              //for (var n = 0; n < ((buff.Length - startpos) < ArraySize ? buff.Length - startpos : ArraySize); n++)                              //    sb.Append((char)buff[n + startpos]);                              //_setValueProp = sb.ToString();                                if (this is PLCNckTag) //BugFix für NCK v2.6                                  _setValueProp = Encoding.Default.GetString(buff' startpos' Math.Min(buff.Length - startpos' ArraySize)).Split('\0')[0];                              else                                  _setValueProp = Encoding.Default.GetString(buff' startpos' Math.Min(buff.Length - startpos' ArraySize)).Trim('\0');                          }                          break;                      case TagDataType.ByteArray:                          {                              var val = new Byte[ArraySize];                              Array.Copy(buff' startpos' val' 0' ArraySize);                                /*                              for (var n = 0; n < ArraySize; n++)                                  val[n] = buff[n + startpos];                              */                              _setValueProp = val;                          }                          break;                      case TagDataType.BCDArray:                          {                              ulong wrt = 0;                                for (int i = 0; i < ArraySize; i++)                              {                                  wrt *= 10;                                  wrt += (ulong)libnodave.getBCD8from(buff' startpos + i);                              }                                _setValueProp = wrt;                          }                          break;                        case TagDataType.Bool:                      case TagDataType.Byte:                      case TagDataType.SByte:                      case TagDataType.Time:                      case TagDataType.LTime:                      case TagDataType.Date:                      case TagDataType.TimeOfDay:                      case TagDataType.LTimeOfDay:                      case TagDataType.Word:                      case TagDataType.BCDByte:                      case TagDataType.Int:                      case TagDataType.S5Time:                      case TagDataType.BCDWord:                      case TagDataType.BCDDWord:                      case TagDataType.Dint:                      case TagDataType.Dword:                      case TagDataType.Float:                      case TagDataType.LInt:                      case TagDataType.LWord:                      case TagDataType.LReal:                      case TagDataType.DateTime:                          {                              if (ArraySize < 2)                              {                                  switch (this.TagDataType)                                  {                                      case TagDataType.Bool:                                          _setValueProp = libnodave.getBit(buff[startpos]' BitAddress);                                          break;                                      case TagDataType.Byte:                                          _setValueProp = buff[startpos];                                          break;                                      case TagDataType.SByte:                                          _setValueProp = libnodave.getS8from(buff' startpos);                                          break;                                      case TagDataType.Time:                                          _setValueProp = libnodave.getTimefrom(buff' startpos);                                          break;                                      case TagDataType.LTime:                                          _setValueProp = libnodave.getLTimefrom(buff' startpos);                                          break;                                      case TagDataType.Date:                                          _setValueProp = libnodave.getDatefrom(buff' startpos);                                          break;                                      case TagDataType.TimeOfDay:                                          _setValueProp = libnodave.getTimeOfDayfrom(buff' startpos);                                          break;                                      case TagDataType.LTimeOfDay:                                          _setValueProp = libnodave.getLTimeOfDayfrom(buff' startpos);                                          break;                                      case TagDataType.Word:                                          _setValueProp = libnodave.getU16from(buff' startpos);                                          break;                                      case TagDataType.BCDByte:                                          _setValueProp = libnodave.getBCD8from(buff' startpos);                                          break;                                      case TagDataType.Int:                                          _setValueProp = libnodave.getS16from(buff' startpos);                                          break;                                      case TagDataType.S5Time:                                          _setValueProp = libnodave.getS5Timefrom(buff' startpos);                                          break;                                      case TagDataType.BCDWord:                                          _setValueProp = libnodave.getBCD16from(buff' startpos);                                          break;                                      case TagDataType.BCDDWord:                                          _setValueProp = libnodave.getBCD32from(buff' startpos);                                          break;                                      case TagDataType.Dint:                                          _setValueProp = libnodave.getS32from(buff' startpos);                                          break;                                      case TagDataType.Dword:                                          _setValueProp = libnodave.getU32from(buff' startpos);                                          break;                                      case TagDataType.LWord:                                          _setValueProp = libnodave.getU64from(buff' startpos);                                          break;                                      case TagDataType.LInt:                                          _setValueProp = libnodave.getS64from(buff' startpos);                                          break;                                      case TagDataType.Float:                                          _setValueProp = libnodave.getFloatfrom(buff' startpos);                                          break;                                      case TagDataType.LReal:                                          _setValueProp = libnodave.getDoublefrom(buff' startpos);                                          break;                                      case TagDataType.DateTime:                                          _setValueProp = libnodave.getDateTimefrom(buff' startpos);                                          break;                                  }                              }                              else                              {                                  switch (this.TagDataType)                                  {                                      case TagDataType.Bool:                                          {                                              var values = new List<bool>();                                              var akBit = BitAddress;                                              var akbyte = startpos;                                              for (int n = 0; n < ArraySize; n++)                                              {                                                  values.Add(libnodave.getBit(buff[akbyte]' akBit));                                                  akBit++;                                                  if (akBit > 7)                                                  {                                                      akBit = 0;                                                      akbyte++;                                                  }                                              }                                                _setValueProp = values.ToArray();                                              break;                                          }                                      case TagDataType.Byte:                                          {                                              var values = new List<Byte>();                                              var mSize = _internalGetBaseTypeSize();                                              for (int n = 0; n < ArraySize; n++)                                                  values.Add(buff[startpos + n * mSize]);                                              _setValueProp = values.ToArray();                                              break;                                          }                                      case TagDataType.SByte:                                          {                                              var values = new List<SByte>();                                              var mSize = _internalGetBaseTypeSize();                                              for (int n = 0; n < ArraySize; n++)                                                  values.Add(libnodave.getS8from(buff' startpos + n * mSize));                                              _setValueProp = values.ToArray();                                              break;                                          }                                      case TagDataType.Time:                                          {                                              var values = new List<TimeSpan>();                                              var mSize = _internalGetBaseTypeSize();                                              for (int n = 0; n < ArraySize; n++)                                                  values.Add(libnodave.getTimefrom(buff' startpos + n * mSize));                                              _setValueProp = values.ToArray();                                              break;                                          }                                      case TagDataType.LTime:                                          {                                              var values = new List<TimeSpan>();                                              var mSize = _internalGetBaseTypeSize();                                              for (int n = 0; n < ArraySize; n++)                                                  values.Add(libnodave.getLTimefrom(buff' startpos + n * mSize));                                              _setValueProp = values.ToArray();                                              break;                                          }                                      case TagDataType.Date:                                          {                                              var values = new List<DateTime>();                                              var mSize = _internalGetBaseTypeSize();                                              for (int n = 0; n < ArraySize; n++)                                                  values.Add(libnodave.getDatefrom(buff' startpos + n * mSize));                                              _setValueProp = values.ToArray();                                              break;                                          }                                      case TagDataType.TimeOfDay:                                          {                                              var values = new List<DateTime>();                                              var mSize = _internalGetBaseTypeSize();                                              for (int n = 0; n < ArraySize; n++)                                                  values.Add(libnodave.getTimeOfDayfrom(buff' startpos + n * mSize));                                              _setValueProp = values.ToArray();                                              break;                                          }                                      case TagDataType.LTimeOfDay:                                          {                                              var values = new List<DateTime>();                                              var mSize = _internalGetBaseTypeSize();                                              for (int n = 0; n < ArraySize; n++)                                                  values.Add(libnodave.getLTimeOfDayfrom(buff' startpos + n * mSize));                                              _setValueProp = values.ToArray();                                              break;                                          }                                      case TagDataType.Word:                                          {                                              var values = new List<UInt16>();                                              var mSize = _internalGetBaseTypeSize();                                              for (int n = 0; n < ArraySize; n++)                                                  values.Add(libnodave.getU16from(buff' startpos + n * mSize));                                              _setValueProp = values.ToArray();                                              break;                                          }                                      case TagDataType.BCDByte:                                          {                                              var values = new List<int>();                                              var mSize = _internalGetBaseTypeSize();                                              for (int n = 0; n < ArraySize; n++)                                                  values.Add(libnodave.getBCD8from(buff' startpos + n * mSize));                                              _setValueProp = values.ToArray();                                              break;                                          }                                      case TagDataType.Int:                                          {                                              var values = new List<Int16>();                                              var mSize = _internalGetBaseTypeSize();                                              for (int n = 0; n < ArraySize; n++)                                                  values.Add(libnodave.getS16from(buff' startpos + n * mSize));                                              _setValueProp = values.ToArray();                                              break;                                          }                                      case TagDataType.S5Time:                                          {                                              var values = new List<TimeSpan>();                                              var mSize = _internalGetBaseTypeSize();                                              for (int n = 0; n < ArraySize; n++)                                                  values.Add(libnodave.getS5Timefrom(buff' startpos + n * mSize));                                              _setValueProp = values.ToArray();                                              break;                                          }                                      case TagDataType.BCDWord:                                          {                                              var values = new List<Int32>();                                              var mSize = _internalGetBaseTypeSize();                                              for (int n = 0; n < ArraySize; n++)                                                  values.Add(libnodave.getBCD16from(buff' startpos + n * mSize));                                              _setValueProp = values.ToArray();                                              break;                                          }                                      case TagDataType.BCDDWord:                                          {                                              var values = new List<Int32>();                                              var mSize = _internalGetBaseTypeSize();                                              for (int n = 0; n < ArraySize; n++)                                                  values.Add(libnodave.getBCD32from(buff' startpos + n * mSize));                                              _setValueProp = values.ToArray();                                              break;                                          }                                      case TagDataType.Dint:                                          {                                              var values = new List<Int32>();                                              var mSize = _internalGetBaseTypeSize();                                              for (int n = 0; n < ArraySize; n++)                                                  values.Add(libnodave.getS32from(buff' startpos + n * mSize));                                              _setValueProp = values.ToArray();                                              break;                                          }                                      case TagDataType.Dword:                                          {                                              var values = new List<UInt32>();                                              var mSize = _internalGetBaseTypeSize();                                              for (int n = 0; n < ArraySize; n++)                                                  values.Add(libnodave.getU32from(buff' startpos + n * mSize));                                              _setValueProp = values.ToArray();                                              break;                                          }                                      case TagDataType.Float:                                          {                                              var values = new List<float>();                                              var mSize = _internalGetBaseTypeSize();                                              for (int n = 0; n < ArraySize; n++)                                                  values.Add(libnodave.getFloatfrom(buff' startpos + n * mSize));                                              _setValueProp = values.ToArray();                                              break;                                          }                                      case TagDataType.LInt:                                          {                                              var values = new List<Int64>();                                              var mSize = _internalGetBaseTypeSize();                                              for (int n = 0; n < ArraySize; n++)                                                  values.Add(libnodave.getS64from(buff' startpos + n * mSize));                                              _setValueProp = values.ToArray();                                              break;                                          }                                      case TagDataType.LWord:                                          {                                              var values = new List<UInt64>();                                              var mSize = _internalGetBaseTypeSize();                                              for (int n = 0; n < ArraySize; n++)                                                  values.Add(libnodave.getU64from(buff' startpos + n * mSize));                                              _setValueProp = values.ToArray();                                              break;                                          }                                      case TagDataType.LReal:                                          {                                              var values = new List<double>();                                              var mSize = _internalGetBaseTypeSize();                                              for (int n = 0; n < ArraySize; n++)                                                  values.Add(libnodave.getDoublefrom(buff' startpos + n * mSize));                                              _setValueProp = values.ToArray();                                              break;                                          }                                      case TagDataType.DateTime:                                          {                                              var values = new List<DateTime>();                                              var mSize = _internalGetBaseTypeSize();                                              for (int n = 0; n < ArraySize; n++)                                                  values.Add(libnodave.getDateTimefrom(buff' startpos + n * mSize));                                              _setValueProp = values.ToArray();                                              break;                                          }                                  }                              }                          }                          break;                  }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTag.cs,_readValueFromBuffer,The following statement contains a magic number: switch (this.TagDataType)                  {                      case TagDataType.String:                          {                              if (!(this is PLCNckTag))                              {                                  int maxsize = (int)buff[startpos];                                  int size = (int)buff[startpos + 1];                                    if (size > maxsize)                                      size = maxsize;                                  if (size > ArraySize)                                      size = ArraySize;                                    _setValueProp = Encoding.Default.GetString(buff' startpos + 2' size);                              }                              else                                  _setValueProp = Encoding.Default.GetString(buff' startpos' Math.Min(buff.Length - startpos' ArraySize)).Split('\0')[0];                          }                          break;                      case TagDataType.CharArray:                          {                              //var sb = new StringBuilder();                              //for (var n = 0; n < ((buff.Length - startpos) < ArraySize ? buff.Length - startpos : ArraySize); n++)                              //    sb.Append((char)buff[n + startpos]);                              //_setValueProp = sb.ToString();                                if (this is PLCNckTag) //BugFix für NCK v2.6                                  _setValueProp = Encoding.Default.GetString(buff' startpos' Math.Min(buff.Length - startpos' ArraySize)).Split('\0')[0];                              else                                  _setValueProp = Encoding.Default.GetString(buff' startpos' Math.Min(buff.Length - startpos' ArraySize)).Trim('\0');                          }                          break;                      case TagDataType.ByteArray:                          {                              var val = new Byte[ArraySize];                              Array.Copy(buff' startpos' val' 0' ArraySize);                                /*                              for (var n = 0; n < ArraySize; n++)                                  val[n] = buff[n + startpos];                              */                              _setValueProp = val;                          }                          break;                      case TagDataType.BCDArray:                          {                              ulong wrt = 0;                                for (int i = 0; i < ArraySize; i++)                              {                                  wrt *= 10;                                  wrt += (ulong)libnodave.getBCD8from(buff' startpos + i);                              }                                _setValueProp = wrt;                          }                          break;                        case TagDataType.Bool:                      case TagDataType.Byte:                      case TagDataType.SByte:                      case TagDataType.Time:                      case TagDataType.LTime:                      case TagDataType.Date:                      case TagDataType.TimeOfDay:                      case TagDataType.LTimeOfDay:                      case TagDataType.Word:                      case TagDataType.BCDByte:                      case TagDataType.Int:                      case TagDataType.S5Time:                      case TagDataType.BCDWord:                      case TagDataType.BCDDWord:                      case TagDataType.Dint:                      case TagDataType.Dword:                      case TagDataType.Float:                      case TagDataType.LInt:                      case TagDataType.LWord:                      case TagDataType.LReal:                      case TagDataType.DateTime:                          {                              if (ArraySize < 2)                              {                                  switch (this.TagDataType)                                  {                                      case TagDataType.Bool:                                          _setValueProp = libnodave.getBit(buff[startpos]' BitAddress);                                          break;                                      case TagDataType.Byte:                                          _setValueProp = buff[startpos];                                          break;                                      case TagDataType.SByte:                                          _setValueProp = libnodave.getS8from(buff' startpos);                                          break;                                      case TagDataType.Time:                                          _setValueProp = libnodave.getTimefrom(buff' startpos);                                          break;                                      case TagDataType.LTime:                                          _setValueProp = libnodave.getLTimefrom(buff' startpos);                                          break;                                      case TagDataType.Date:                                          _setValueProp = libnodave.getDatefrom(buff' startpos);                                          break;                                      case TagDataType.TimeOfDay:                                          _setValueProp = libnodave.getTimeOfDayfrom(buff' startpos);                                          break;                                      case TagDataType.LTimeOfDay:                                          _setValueProp = libnodave.getLTimeOfDayfrom(buff' startpos);                                          break;                                      case TagDataType.Word:                                          _setValueProp = libnodave.getU16from(buff' startpos);                                          break;                                      case TagDataType.BCDByte:                                          _setValueProp = libnodave.getBCD8from(buff' startpos);                                          break;                                      case TagDataType.Int:                                          _setValueProp = libnodave.getS16from(buff' startpos);                                          break;                                      case TagDataType.S5Time:                                          _setValueProp = libnodave.getS5Timefrom(buff' startpos);                                          break;                                      case TagDataType.BCDWord:                                          _setValueProp = libnodave.getBCD16from(buff' startpos);                                          break;                                      case TagDataType.BCDDWord:                                          _setValueProp = libnodave.getBCD32from(buff' startpos);                                          break;                                      case TagDataType.Dint:                                          _setValueProp = libnodave.getS32from(buff' startpos);                                          break;                                      case TagDataType.Dword:                                          _setValueProp = libnodave.getU32from(buff' startpos);                                          break;                                      case TagDataType.LWord:                                          _setValueProp = libnodave.getU64from(buff' startpos);                                          break;                                      case TagDataType.LInt:                                          _setValueProp = libnodave.getS64from(buff' startpos);                                          break;                                      case TagDataType.Float:                                          _setValueProp = libnodave.getFloatfrom(buff' startpos);                                          break;                                      case TagDataType.LReal:                                          _setValueProp = libnodave.getDoublefrom(buff' startpos);                                          break;                                      case TagDataType.DateTime:                                          _setValueProp = libnodave.getDateTimefrom(buff' startpos);                                          break;                                  }                              }                              else                              {                                  switch (this.TagDataType)                                  {                                      case TagDataType.Bool:                                          {                                              var values = new List<bool>();                                              var akBit = BitAddress;                                              var akbyte = startpos;                                              for (int n = 0; n < ArraySize; n++)                                              {                                                  values.Add(libnodave.getBit(buff[akbyte]' akBit));                                                  akBit++;                                                  if (akBit > 7)                                                  {                                                      akBit = 0;                                                      akbyte++;                                                  }                                              }                                                _setValueProp = values.ToArray();                                              break;                                          }                                      case TagDataType.Byte:                                          {                                              var values = new List<Byte>();                                              var mSize = _internalGetBaseTypeSize();                                              for (int n = 0; n < ArraySize; n++)                                                  values.Add(buff[startpos + n * mSize]);                                              _setValueProp = values.ToArray();                                              break;                                          }                                      case TagDataType.SByte:                                          {                                              var values = new List<SByte>();                                              var mSize = _internalGetBaseTypeSize();                                              for (int n = 0; n < ArraySize; n++)                                                  values.Add(libnodave.getS8from(buff' startpos + n * mSize));                                              _setValueProp = values.ToArray();                                              break;                                          }                                      case TagDataType.Time:                                          {                                              var values = new List<TimeSpan>();                                              var mSize = _internalGetBaseTypeSize();                                              for (int n = 0; n < ArraySize; n++)                                                  values.Add(libnodave.getTimefrom(buff' startpos + n * mSize));                                              _setValueProp = values.ToArray();                                              break;                                          }                                      case TagDataType.LTime:                                          {                                              var values = new List<TimeSpan>();                                              var mSize = _internalGetBaseTypeSize();                                              for (int n = 0; n < ArraySize; n++)                                                  values.Add(libnodave.getLTimefrom(buff' startpos + n * mSize));                                              _setValueProp = values.ToArray();                                              break;                                          }                                      case TagDataType.Date:                                          {                                              var values = new List<DateTime>();                                              var mSize = _internalGetBaseTypeSize();                                              for (int n = 0; n < ArraySize; n++)                                                  values.Add(libnodave.getDatefrom(buff' startpos + n * mSize));                                              _setValueProp = values.ToArray();                                              break;                                          }                                      case TagDataType.TimeOfDay:                                          {                                              var values = new List<DateTime>();                                              var mSize = _internalGetBaseTypeSize();                                              for (int n = 0; n < ArraySize; n++)                                                  values.Add(libnodave.getTimeOfDayfrom(buff' startpos + n * mSize));                                              _setValueProp = values.ToArray();                                              break;                                          }                                      case TagDataType.LTimeOfDay:                                          {                                              var values = new List<DateTime>();                                              var mSize = _internalGetBaseTypeSize();                                              for (int n = 0; n < ArraySize; n++)                                                  values.Add(libnodave.getLTimeOfDayfrom(buff' startpos + n * mSize));                                              _setValueProp = values.ToArray();                                              break;                                          }                                      case TagDataType.Word:                                          {                                              var values = new List<UInt16>();                                              var mSize = _internalGetBaseTypeSize();                                              for (int n = 0; n < ArraySize; n++)                                                  values.Add(libnodave.getU16from(buff' startpos + n * mSize));                                              _setValueProp = values.ToArray();                                              break;                                          }                                      case TagDataType.BCDByte:                                          {                                              var values = new List<int>();                                              var mSize = _internalGetBaseTypeSize();                                              for (int n = 0; n < ArraySize; n++)                                                  values.Add(libnodave.getBCD8from(buff' startpos + n * mSize));                                              _setValueProp = values.ToArray();                                              break;                                          }                                      case TagDataType.Int:                                          {                                              var values = new List<Int16>();                                              var mSize = _internalGetBaseTypeSize();                                              for (int n = 0; n < ArraySize; n++)                                                  values.Add(libnodave.getS16from(buff' startpos + n * mSize));                                              _setValueProp = values.ToArray();                                              break;                                          }                                      case TagDataType.S5Time:                                          {                                              var values = new List<TimeSpan>();                                              var mSize = _internalGetBaseTypeSize();                                              for (int n = 0; n < ArraySize; n++)                                                  values.Add(libnodave.getS5Timefrom(buff' startpos + n * mSize));                                              _setValueProp = values.ToArray();                                              break;                                          }                                      case TagDataType.BCDWord:                                          {                                              var values = new List<Int32>();                                              var mSize = _internalGetBaseTypeSize();                                              for (int n = 0; n < ArraySize; n++)                                                  values.Add(libnodave.getBCD16from(buff' startpos + n * mSize));                                              _setValueProp = values.ToArray();                                              break;                                          }                                      case TagDataType.BCDDWord:                                          {                                              var values = new List<Int32>();                                              var mSize = _internalGetBaseTypeSize();                                              for (int n = 0; n < ArraySize; n++)                                                  values.Add(libnodave.getBCD32from(buff' startpos + n * mSize));                                              _setValueProp = values.ToArray();                                              break;                                          }                                      case TagDataType.Dint:                                          {                                              var values = new List<Int32>();                                              var mSize = _internalGetBaseTypeSize();                                              for (int n = 0; n < ArraySize; n++)                                                  values.Add(libnodave.getS32from(buff' startpos + n * mSize));                                              _setValueProp = values.ToArray();                                              break;                                          }                                      case TagDataType.Dword:                                          {                                              var values = new List<UInt32>();                                              var mSize = _internalGetBaseTypeSize();                                              for (int n = 0; n < ArraySize; n++)                                                  values.Add(libnodave.getU32from(buff' startpos + n * mSize));                                              _setValueProp = values.ToArray();                                              break;                                          }                                      case TagDataType.Float:                                          {                                              var values = new List<float>();                                              var mSize = _internalGetBaseTypeSize();                                              for (int n = 0; n < ArraySize; n++)                                                  values.Add(libnodave.getFloatfrom(buff' startpos + n * mSize));                                              _setValueProp = values.ToArray();                                              break;                                          }                                      case TagDataType.LInt:                                          {                                              var values = new List<Int64>();                                              var mSize = _internalGetBaseTypeSize();                                              for (int n = 0; n < ArraySize; n++)                                                  values.Add(libnodave.getS64from(buff' startpos + n * mSize));                                              _setValueProp = values.ToArray();                                              break;                                          }                                      case TagDataType.LWord:                                          {                                              var values = new List<UInt64>();                                              var mSize = _internalGetBaseTypeSize();                                              for (int n = 0; n < ArraySize; n++)                                                  values.Add(libnodave.getU64from(buff' startpos + n * mSize));                                              _setValueProp = values.ToArray();                                              break;                                          }                                      case TagDataType.LReal:                                          {                                              var values = new List<double>();                                              var mSize = _internalGetBaseTypeSize();                                              for (int n = 0; n < ArraySize; n++)                                                  values.Add(libnodave.getDoublefrom(buff' startpos + n * mSize));                                              _setValueProp = values.ToArray();                                              break;                                          }                                      case TagDataType.DateTime:                                          {                                              var values = new List<DateTime>();                                              var mSize = _internalGetBaseTypeSize();                                              for (int n = 0; n < ArraySize; n++)                                                  values.Add(libnodave.getDateTimefrom(buff' startpos + n * mSize));                                              _setValueProp = values.ToArray();                                              break;                                          }                                  }                              }                          }                          break;                  }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTag.cs,_internalGetSize,The following statement contains a magic number: switch (this.TagDataType)              {                  case TagDataType.String:                      return ArraySize + 2;                  case TagDataType.CharArray:                  case TagDataType.ByteArray:                  case TagDataType.BCDArray:                      return ArraySize;                  case TagDataType.Byte:                  case TagDataType.SByte:                  case TagDataType.BCDByte:                  case TagDataType.Word:                  case TagDataType.BCDWord:                  case TagDataType.Int:                  case TagDataType.S5Time:                  case TagDataType.Date:                  case TagDataType.Dint:                  case TagDataType.LInt:                  case TagDataType.LReal:                  case TagDataType.LWord:                  case TagDataType.LTime:                  case TagDataType.LTimeOfDay:                  case TagDataType.Dword:                  case TagDataType.Time:                  case TagDataType.TimeOfDay:                  case TagDataType.Float:                  case TagDataType.BCDDWord:                  case TagDataType.DateTime:                      return _internalGetBaseTypeSize() * ArraySize;                  case TagDataType.Bool:                      {                          var akbyte = 1;                          var akBit = BitAddress;                          for (int i = 0; i < ArraySize; i++)                          {                              if (akBit > 7)                              {                                  akbyte++;                                  akBit = 0;                              }                              akBit++;                          }                          return akbyte;                      }              }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTag.cs,_internalGetSize,The following statement contains a magic number: switch (this.TagDataType)              {                  case TagDataType.String:                      return ArraySize + 2;                  case TagDataType.CharArray:                  case TagDataType.ByteArray:                  case TagDataType.BCDArray:                      return ArraySize;                  case TagDataType.Byte:                  case TagDataType.SByte:                  case TagDataType.BCDByte:                  case TagDataType.Word:                  case TagDataType.BCDWord:                  case TagDataType.Int:                  case TagDataType.S5Time:                  case TagDataType.Date:                  case TagDataType.Dint:                  case TagDataType.LInt:                  case TagDataType.LReal:                  case TagDataType.LWord:                  case TagDataType.LTime:                  case TagDataType.LTimeOfDay:                  case TagDataType.Dword:                  case TagDataType.Time:                  case TagDataType.TimeOfDay:                  case TagDataType.Float:                  case TagDataType.BCDDWord:                  case TagDataType.DateTime:                      return _internalGetBaseTypeSize() * ArraySize;                  case TagDataType.Bool:                      {                          var akbyte = 1;                          var akBit = BitAddress;                          for (int i = 0; i < ArraySize; i++)                          {                              if (akBit > 7)                              {                                  akbyte++;                                  akBit = 0;                              }                              akBit++;                          }                          return akbyte;                      }              }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTag.cs,_internalGetBaseTypeSize,The following statement contains a magic number: switch (this.TagDataType)              {                  case TagDataType.Bool:                  case TagDataType.Byte:                  case TagDataType.SByte:                  case TagDataType.BCDByte:                  case TagDataType.BCDArray:                  case TagDataType.CharArray:                  case TagDataType.ByteArray:                      return 1;                  case TagDataType.Word:                  case TagDataType.BCDWord:                  case TagDataType.Int:                  case TagDataType.S5Time:                  case TagDataType.Date:                      return 2;                  case TagDataType.Dint:                  case TagDataType.Dword:                  case TagDataType.Time:                  case TagDataType.TimeOfDay:                  case TagDataType.Float:                  case TagDataType.BCDDWord:                      return 4;                  case TagDataType.LInt:                  case TagDataType.LWord:                  case TagDataType.LReal:                  case TagDataType.LTime:                  case TagDataType.LTimeOfDay:                  case TagDataType.DateTime:                      return 8;              }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTag.cs,_internalGetBaseTypeSize,The following statement contains a magic number: switch (this.TagDataType)              {                  case TagDataType.Bool:                  case TagDataType.Byte:                  case TagDataType.SByte:                  case TagDataType.BCDByte:                  case TagDataType.BCDArray:                  case TagDataType.CharArray:                  case TagDataType.ByteArray:                      return 1;                  case TagDataType.Word:                  case TagDataType.BCDWord:                  case TagDataType.Int:                  case TagDataType.S5Time:                  case TagDataType.Date:                      return 2;                  case TagDataType.Dint:                  case TagDataType.Dword:                  case TagDataType.Time:                  case TagDataType.TimeOfDay:                  case TagDataType.Float:                  case TagDataType.BCDDWord:                      return 4;                  case TagDataType.LInt:                  case TagDataType.LWord:                  case TagDataType.LReal:                  case TagDataType.LTime:                  case TagDataType.LTimeOfDay:                  case TagDataType.DateTime:                      return 8;              }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTag.cs,_internalGetBaseTypeSize,The following statement contains a magic number: switch (this.TagDataType)              {                  case TagDataType.Bool:                  case TagDataType.Byte:                  case TagDataType.SByte:                  case TagDataType.BCDByte:                  case TagDataType.BCDArray:                  case TagDataType.CharArray:                  case TagDataType.ByteArray:                      return 1;                  case TagDataType.Word:                  case TagDataType.BCDWord:                  case TagDataType.Int:                  case TagDataType.S5Time:                  case TagDataType.Date:                      return 2;                  case TagDataType.Dint:                  case TagDataType.Dword:                  case TagDataType.Time:                  case TagDataType.TimeOfDay:                  case TagDataType.Float:                  case TagDataType.BCDDWord:                      return 4;                  case TagDataType.LInt:                  case TagDataType.LWord:                  case TagDataType.LReal:                  case TagDataType.LTime:                  case TagDataType.LTimeOfDay:                  case TagDataType.DateTime:                      return 8;              }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag<T>,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTagGeneric.cs,FromBytes,The following statement contains a magic number: switch (info.FieldType.Name)                  {                      case "Boolean":                          // get the value                          bytePos = (int)Math.Floor(numBytes);                          bitPos = (int)((numBytes - (double)bytePos) / 0.125);                          if ((bytes[bytePos] & (int)Math.Pow(2' bitPos)) != 0)                              info.SetValue(structValue' true);                          else                              info.SetValue(structValue' false);                          numBytes += 0.125;                          break;                      case "Byte":                          numBytes = Math.Ceiling(numBytes);                          info.SetValue(structValue' (byte)(bytes[(int)numBytes]));                          numBytes++;                          break;                      case "String":                          {                              numBytes = Math.Ceiling(numBytes);                              if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                                  numBytes++;                                MarshalAsAttribute mAttr = null;                              object[] attr = info.GetCustomAttributes(typeof (MarshalAsAttribute)' false);                              if (attr.Length > 0)                                  mAttr = (MarshalAsAttribute) attr[0];                              if (mAttr == null || mAttr.Value != UnmanagedType.ByValTStr || mAttr.SizeConst <= 0)                                  throw new Exception("Strings in Structs need to be decorated with \"MarshalAs(UnmanagedType.ByValTStr' SizeConst = xx)\"");                                var sb = new StringBuilder();                              int size = mAttr.SizeConst > bytes[((int) numBytes) + 1] ? bytes[((int) numBytes) + 1] : mAttr.SizeConst;                              for (var n = 2; n < size+2; n++)                                  sb.Append((char) bytes[n + (int) numBytes]);                              info.SetValue(structValue' (String) sb.ToString());                                numBytes += 2 + mAttr.SizeConst;                          }                          break;                      case "Int16":                           numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' libnodave.getS16from(bytes' (int) numBytes));                          numBytes += 2;                          break;                      case "UInt16":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' libnodave.getU16from(bytes' (int) numBytes));                          numBytes += 2;                          break;                      case "Int32":                           numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' libnodave.getS32from(bytes' (int)numBytes));                          numBytes += 4;                          break;                      case "UInt32":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' libnodave.getU32from(bytes' (int)numBytes));                          numBytes += 4;                          break;                      case "Double":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' libnodave.getFloatfrom(bytes' (int)numBytes));                          numBytes += 4;                          break;                  }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag<T>,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTagGeneric.cs,FromBytes,The following statement contains a magic number: switch (info.FieldType.Name)                  {                      case "Boolean":                          // get the value                          bytePos = (int)Math.Floor(numBytes);                          bitPos = (int)((numBytes - (double)bytePos) / 0.125);                          if ((bytes[bytePos] & (int)Math.Pow(2' bitPos)) != 0)                              info.SetValue(structValue' true);                          else                              info.SetValue(structValue' false);                          numBytes += 0.125;                          break;                      case "Byte":                          numBytes = Math.Ceiling(numBytes);                          info.SetValue(structValue' (byte)(bytes[(int)numBytes]));                          numBytes++;                          break;                      case "String":                          {                              numBytes = Math.Ceiling(numBytes);                              if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                                  numBytes++;                                MarshalAsAttribute mAttr = null;                              object[] attr = info.GetCustomAttributes(typeof (MarshalAsAttribute)' false);                              if (attr.Length > 0)                                  mAttr = (MarshalAsAttribute) attr[0];                              if (mAttr == null || mAttr.Value != UnmanagedType.ByValTStr || mAttr.SizeConst <= 0)                                  throw new Exception("Strings in Structs need to be decorated with \"MarshalAs(UnmanagedType.ByValTStr' SizeConst = xx)\"");                                var sb = new StringBuilder();                              int size = mAttr.SizeConst > bytes[((int) numBytes) + 1] ? bytes[((int) numBytes) + 1] : mAttr.SizeConst;                              for (var n = 2; n < size+2; n++)                                  sb.Append((char) bytes[n + (int) numBytes]);                              info.SetValue(structValue' (String) sb.ToString());                                numBytes += 2 + mAttr.SizeConst;                          }                          break;                      case "Int16":                           numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' libnodave.getS16from(bytes' (int) numBytes));                          numBytes += 2;                          break;                      case "UInt16":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' libnodave.getU16from(bytes' (int) numBytes));                          numBytes += 2;                          break;                      case "Int32":                           numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' libnodave.getS32from(bytes' (int)numBytes));                          numBytes += 4;                          break;                      case "UInt32":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' libnodave.getU32from(bytes' (int)numBytes));                          numBytes += 4;                          break;                      case "Double":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' libnodave.getFloatfrom(bytes' (int)numBytes));                          numBytes += 4;                          break;                  }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag<T>,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTagGeneric.cs,FromBytes,The following statement contains a magic number: switch (info.FieldType.Name)                  {                      case "Boolean":                          // get the value                          bytePos = (int)Math.Floor(numBytes);                          bitPos = (int)((numBytes - (double)bytePos) / 0.125);                          if ((bytes[bytePos] & (int)Math.Pow(2' bitPos)) != 0)                              info.SetValue(structValue' true);                          else                              info.SetValue(structValue' false);                          numBytes += 0.125;                          break;                      case "Byte":                          numBytes = Math.Ceiling(numBytes);                          info.SetValue(structValue' (byte)(bytes[(int)numBytes]));                          numBytes++;                          break;                      case "String":                          {                              numBytes = Math.Ceiling(numBytes);                              if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                                  numBytes++;                                MarshalAsAttribute mAttr = null;                              object[] attr = info.GetCustomAttributes(typeof (MarshalAsAttribute)' false);                              if (attr.Length > 0)                                  mAttr = (MarshalAsAttribute) attr[0];                              if (mAttr == null || mAttr.Value != UnmanagedType.ByValTStr || mAttr.SizeConst <= 0)                                  throw new Exception("Strings in Structs need to be decorated with \"MarshalAs(UnmanagedType.ByValTStr' SizeConst = xx)\"");                                var sb = new StringBuilder();                              int size = mAttr.SizeConst > bytes[((int) numBytes) + 1] ? bytes[((int) numBytes) + 1] : mAttr.SizeConst;                              for (var n = 2; n < size+2; n++)                                  sb.Append((char) bytes[n + (int) numBytes]);                              info.SetValue(structValue' (String) sb.ToString());                                numBytes += 2 + mAttr.SizeConst;                          }                          break;                      case "Int16":                           numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' libnodave.getS16from(bytes' (int) numBytes));                          numBytes += 2;                          break;                      case "UInt16":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' libnodave.getU16from(bytes' (int) numBytes));                          numBytes += 2;                          break;                      case "Int32":                           numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' libnodave.getS32from(bytes' (int)numBytes));                          numBytes += 4;                          break;                      case "UInt32":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' libnodave.getU32from(bytes' (int)numBytes));                          numBytes += 4;                          break;                      case "Double":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' libnodave.getFloatfrom(bytes' (int)numBytes));                          numBytes += 4;                          break;                  }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag<T>,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTagGeneric.cs,FromBytes,The following statement contains a magic number: switch (info.FieldType.Name)                  {                      case "Boolean":                          // get the value                          bytePos = (int)Math.Floor(numBytes);                          bitPos = (int)((numBytes - (double)bytePos) / 0.125);                          if ((bytes[bytePos] & (int)Math.Pow(2' bitPos)) != 0)                              info.SetValue(structValue' true);                          else                              info.SetValue(structValue' false);                          numBytes += 0.125;                          break;                      case "Byte":                          numBytes = Math.Ceiling(numBytes);                          info.SetValue(structValue' (byte)(bytes[(int)numBytes]));                          numBytes++;                          break;                      case "String":                          {                              numBytes = Math.Ceiling(numBytes);                              if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                                  numBytes++;                                MarshalAsAttribute mAttr = null;                              object[] attr = info.GetCustomAttributes(typeof (MarshalAsAttribute)' false);                              if (attr.Length > 0)                                  mAttr = (MarshalAsAttribute) attr[0];                              if (mAttr == null || mAttr.Value != UnmanagedType.ByValTStr || mAttr.SizeConst <= 0)                                  throw new Exception("Strings in Structs need to be decorated with \"MarshalAs(UnmanagedType.ByValTStr' SizeConst = xx)\"");                                var sb = new StringBuilder();                              int size = mAttr.SizeConst > bytes[((int) numBytes) + 1] ? bytes[((int) numBytes) + 1] : mAttr.SizeConst;                              for (var n = 2; n < size+2; n++)                                  sb.Append((char) bytes[n + (int) numBytes]);                              info.SetValue(structValue' (String) sb.ToString());                                numBytes += 2 + mAttr.SizeConst;                          }                          break;                      case "Int16":                           numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' libnodave.getS16from(bytes' (int) numBytes));                          numBytes += 2;                          break;                      case "UInt16":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' libnodave.getU16from(bytes' (int) numBytes));                          numBytes += 2;                          break;                      case "Int32":                           numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' libnodave.getS32from(bytes' (int)numBytes));                          numBytes += 4;                          break;                      case "UInt32":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' libnodave.getU32from(bytes' (int)numBytes));                          numBytes += 4;                          break;                      case "Double":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' libnodave.getFloatfrom(bytes' (int)numBytes));                          numBytes += 4;                          break;                  }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag<T>,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTagGeneric.cs,FromBytes,The following statement contains a magic number: switch (info.FieldType.Name)                  {                      case "Boolean":                          // get the value                          bytePos = (int)Math.Floor(numBytes);                          bitPos = (int)((numBytes - (double)bytePos) / 0.125);                          if ((bytes[bytePos] & (int)Math.Pow(2' bitPos)) != 0)                              info.SetValue(structValue' true);                          else                              info.SetValue(structValue' false);                          numBytes += 0.125;                          break;                      case "Byte":                          numBytes = Math.Ceiling(numBytes);                          info.SetValue(structValue' (byte)(bytes[(int)numBytes]));                          numBytes++;                          break;                      case "String":                          {                              numBytes = Math.Ceiling(numBytes);                              if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                                  numBytes++;                                MarshalAsAttribute mAttr = null;                              object[] attr = info.GetCustomAttributes(typeof (MarshalAsAttribute)' false);                              if (attr.Length > 0)                                  mAttr = (MarshalAsAttribute) attr[0];                              if (mAttr == null || mAttr.Value != UnmanagedType.ByValTStr || mAttr.SizeConst <= 0)                                  throw new Exception("Strings in Structs need to be decorated with \"MarshalAs(UnmanagedType.ByValTStr' SizeConst = xx)\"");                                var sb = new StringBuilder();                              int size = mAttr.SizeConst > bytes[((int) numBytes) + 1] ? bytes[((int) numBytes) + 1] : mAttr.SizeConst;                              for (var n = 2; n < size+2; n++)                                  sb.Append((char) bytes[n + (int) numBytes]);                              info.SetValue(structValue' (String) sb.ToString());                                numBytes += 2 + mAttr.SizeConst;                          }                          break;                      case "Int16":                           numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' libnodave.getS16from(bytes' (int) numBytes));                          numBytes += 2;                          break;                      case "UInt16":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' libnodave.getU16from(bytes' (int) numBytes));                          numBytes += 2;                          break;                      case "Int32":                           numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' libnodave.getS32from(bytes' (int)numBytes));                          numBytes += 4;                          break;                      case "UInt32":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' libnodave.getU32from(bytes' (int)numBytes));                          numBytes += 4;                          break;                      case "Double":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' libnodave.getFloatfrom(bytes' (int)numBytes));                          numBytes += 4;                          break;                  }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag<T>,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTagGeneric.cs,FromBytes,The following statement contains a magic number: switch (info.FieldType.Name)                  {                      case "Boolean":                          // get the value                          bytePos = (int)Math.Floor(numBytes);                          bitPos = (int)((numBytes - (double)bytePos) / 0.125);                          if ((bytes[bytePos] & (int)Math.Pow(2' bitPos)) != 0)                              info.SetValue(structValue' true);                          else                              info.SetValue(structValue' false);                          numBytes += 0.125;                          break;                      case "Byte":                          numBytes = Math.Ceiling(numBytes);                          info.SetValue(structValue' (byte)(bytes[(int)numBytes]));                          numBytes++;                          break;                      case "String":                          {                              numBytes = Math.Ceiling(numBytes);                              if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                                  numBytes++;                                MarshalAsAttribute mAttr = null;                              object[] attr = info.GetCustomAttributes(typeof (MarshalAsAttribute)' false);                              if (attr.Length > 0)                                  mAttr = (MarshalAsAttribute) attr[0];                              if (mAttr == null || mAttr.Value != UnmanagedType.ByValTStr || mAttr.SizeConst <= 0)                                  throw new Exception("Strings in Structs need to be decorated with \"MarshalAs(UnmanagedType.ByValTStr' SizeConst = xx)\"");                                var sb = new StringBuilder();                              int size = mAttr.SizeConst > bytes[((int) numBytes) + 1] ? bytes[((int) numBytes) + 1] : mAttr.SizeConst;                              for (var n = 2; n < size+2; n++)                                  sb.Append((char) bytes[n + (int) numBytes]);                              info.SetValue(structValue' (String) sb.ToString());                                numBytes += 2 + mAttr.SizeConst;                          }                          break;                      case "Int16":                           numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' libnodave.getS16from(bytes' (int) numBytes));                          numBytes += 2;                          break;                      case "UInt16":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' libnodave.getU16from(bytes' (int) numBytes));                          numBytes += 2;                          break;                      case "Int32":                           numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' libnodave.getS32from(bytes' (int)numBytes));                          numBytes += 4;                          break;                      case "UInt32":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' libnodave.getU32from(bytes' (int)numBytes));                          numBytes += 4;                          break;                      case "Double":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' libnodave.getFloatfrom(bytes' (int)numBytes));                          numBytes += 4;                          break;                  }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag<T>,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTagGeneric.cs,FromBytes,The following statement contains a magic number: switch (info.FieldType.Name)                  {                      case "Boolean":                          // get the value                          bytePos = (int)Math.Floor(numBytes);                          bitPos = (int)((numBytes - (double)bytePos) / 0.125);                          if ((bytes[bytePos] & (int)Math.Pow(2' bitPos)) != 0)                              info.SetValue(structValue' true);                          else                              info.SetValue(structValue' false);                          numBytes += 0.125;                          break;                      case "Byte":                          numBytes = Math.Ceiling(numBytes);                          info.SetValue(structValue' (byte)(bytes[(int)numBytes]));                          numBytes++;                          break;                      case "String":                          {                              numBytes = Math.Ceiling(numBytes);                              if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                                  numBytes++;                                MarshalAsAttribute mAttr = null;                              object[] attr = info.GetCustomAttributes(typeof (MarshalAsAttribute)' false);                              if (attr.Length > 0)                                  mAttr = (MarshalAsAttribute) attr[0];                              if (mAttr == null || mAttr.Value != UnmanagedType.ByValTStr || mAttr.SizeConst <= 0)                                  throw new Exception("Strings in Structs need to be decorated with \"MarshalAs(UnmanagedType.ByValTStr' SizeConst = xx)\"");                                var sb = new StringBuilder();                              int size = mAttr.SizeConst > bytes[((int) numBytes) + 1] ? bytes[((int) numBytes) + 1] : mAttr.SizeConst;                              for (var n = 2; n < size+2; n++)                                  sb.Append((char) bytes[n + (int) numBytes]);                              info.SetValue(structValue' (String) sb.ToString());                                numBytes += 2 + mAttr.SizeConst;                          }                          break;                      case "Int16":                           numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' libnodave.getS16from(bytes' (int) numBytes));                          numBytes += 2;                          break;                      case "UInt16":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' libnodave.getU16from(bytes' (int) numBytes));                          numBytes += 2;                          break;                      case "Int32":                           numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' libnodave.getS32from(bytes' (int)numBytes));                          numBytes += 4;                          break;                      case "UInt32":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' libnodave.getU32from(bytes' (int)numBytes));                          numBytes += 4;                          break;                      case "Double":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' libnodave.getFloatfrom(bytes' (int)numBytes));                          numBytes += 4;                          break;                  }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag<T>,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTagGeneric.cs,FromBytes,The following statement contains a magic number: switch (info.FieldType.Name)                  {                      case "Boolean":                          // get the value                          bytePos = (int)Math.Floor(numBytes);                          bitPos = (int)((numBytes - (double)bytePos) / 0.125);                          if ((bytes[bytePos] & (int)Math.Pow(2' bitPos)) != 0)                              info.SetValue(structValue' true);                          else                              info.SetValue(structValue' false);                          numBytes += 0.125;                          break;                      case "Byte":                          numBytes = Math.Ceiling(numBytes);                          info.SetValue(structValue' (byte)(bytes[(int)numBytes]));                          numBytes++;                          break;                      case "String":                          {                              numBytes = Math.Ceiling(numBytes);                              if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                                  numBytes++;                                MarshalAsAttribute mAttr = null;                              object[] attr = info.GetCustomAttributes(typeof (MarshalAsAttribute)' false);                              if (attr.Length > 0)                                  mAttr = (MarshalAsAttribute) attr[0];                              if (mAttr == null || mAttr.Value != UnmanagedType.ByValTStr || mAttr.SizeConst <= 0)                                  throw new Exception("Strings in Structs need to be decorated with \"MarshalAs(UnmanagedType.ByValTStr' SizeConst = xx)\"");                                var sb = new StringBuilder();                              int size = mAttr.SizeConst > bytes[((int) numBytes) + 1] ? bytes[((int) numBytes) + 1] : mAttr.SizeConst;                              for (var n = 2; n < size+2; n++)                                  sb.Append((char) bytes[n + (int) numBytes]);                              info.SetValue(structValue' (String) sb.ToString());                                numBytes += 2 + mAttr.SizeConst;                          }                          break;                      case "Int16":                           numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' libnodave.getS16from(bytes' (int) numBytes));                          numBytes += 2;                          break;                      case "UInt16":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' libnodave.getU16from(bytes' (int) numBytes));                          numBytes += 2;                          break;                      case "Int32":                           numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' libnodave.getS32from(bytes' (int)numBytes));                          numBytes += 4;                          break;                      case "UInt32":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' libnodave.getU32from(bytes' (int)numBytes));                          numBytes += 4;                          break;                      case "Double":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' libnodave.getFloatfrom(bytes' (int)numBytes));                          numBytes += 4;                          break;                  }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag<T>,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTagGeneric.cs,FromBytes,The following statement contains a magic number: switch (info.FieldType.Name)                  {                      case "Boolean":                          // get the value                          bytePos = (int)Math.Floor(numBytes);                          bitPos = (int)((numBytes - (double)bytePos) / 0.125);                          if ((bytes[bytePos] & (int)Math.Pow(2' bitPos)) != 0)                              info.SetValue(structValue' true);                          else                              info.SetValue(structValue' false);                          numBytes += 0.125;                          break;                      case "Byte":                          numBytes = Math.Ceiling(numBytes);                          info.SetValue(structValue' (byte)(bytes[(int)numBytes]));                          numBytes++;                          break;                      case "String":                          {                              numBytes = Math.Ceiling(numBytes);                              if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                                  numBytes++;                                MarshalAsAttribute mAttr = null;                              object[] attr = info.GetCustomAttributes(typeof (MarshalAsAttribute)' false);                              if (attr.Length > 0)                                  mAttr = (MarshalAsAttribute) attr[0];                              if (mAttr == null || mAttr.Value != UnmanagedType.ByValTStr || mAttr.SizeConst <= 0)                                  throw new Exception("Strings in Structs need to be decorated with \"MarshalAs(UnmanagedType.ByValTStr' SizeConst = xx)\"");                                var sb = new StringBuilder();                              int size = mAttr.SizeConst > bytes[((int) numBytes) + 1] ? bytes[((int) numBytes) + 1] : mAttr.SizeConst;                              for (var n = 2; n < size+2; n++)                                  sb.Append((char) bytes[n + (int) numBytes]);                              info.SetValue(structValue' (String) sb.ToString());                                numBytes += 2 + mAttr.SizeConst;                          }                          break;                      case "Int16":                           numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' libnodave.getS16from(bytes' (int) numBytes));                          numBytes += 2;                          break;                      case "UInt16":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' libnodave.getU16from(bytes' (int) numBytes));                          numBytes += 2;                          break;                      case "Int32":                           numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' libnodave.getS32from(bytes' (int)numBytes));                          numBytes += 4;                          break;                      case "UInt32":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' libnodave.getU32from(bytes' (int)numBytes));                          numBytes += 4;                          break;                      case "Double":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' libnodave.getFloatfrom(bytes' (int)numBytes));                          numBytes += 4;                          break;                  }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag<T>,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTagGeneric.cs,FromBytes,The following statement contains a magic number: switch (info.FieldType.Name)                  {                      case "Boolean":                          // get the value                          bytePos = (int)Math.Floor(numBytes);                          bitPos = (int)((numBytes - (double)bytePos) / 0.125);                          if ((bytes[bytePos] & (int)Math.Pow(2' bitPos)) != 0)                              info.SetValue(structValue' true);                          else                              info.SetValue(structValue' false);                          numBytes += 0.125;                          break;                      case "Byte":                          numBytes = Math.Ceiling(numBytes);                          info.SetValue(structValue' (byte)(bytes[(int)numBytes]));                          numBytes++;                          break;                      case "String":                          {                              numBytes = Math.Ceiling(numBytes);                              if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                                  numBytes++;                                MarshalAsAttribute mAttr = null;                              object[] attr = info.GetCustomAttributes(typeof (MarshalAsAttribute)' false);                              if (attr.Length > 0)                                  mAttr = (MarshalAsAttribute) attr[0];                              if (mAttr == null || mAttr.Value != UnmanagedType.ByValTStr || mAttr.SizeConst <= 0)                                  throw new Exception("Strings in Structs need to be decorated with \"MarshalAs(UnmanagedType.ByValTStr' SizeConst = xx)\"");                                var sb = new StringBuilder();                              int size = mAttr.SizeConst > bytes[((int) numBytes) + 1] ? bytes[((int) numBytes) + 1] : mAttr.SizeConst;                              for (var n = 2; n < size+2; n++)                                  sb.Append((char) bytes[n + (int) numBytes]);                              info.SetValue(structValue' (String) sb.ToString());                                numBytes += 2 + mAttr.SizeConst;                          }                          break;                      case "Int16":                           numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' libnodave.getS16from(bytes' (int) numBytes));                          numBytes += 2;                          break;                      case "UInt16":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' libnodave.getU16from(bytes' (int) numBytes));                          numBytes += 2;                          break;                      case "Int32":                           numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' libnodave.getS32from(bytes' (int)numBytes));                          numBytes += 4;                          break;                      case "UInt32":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' libnodave.getU32from(bytes' (int)numBytes));                          numBytes += 4;                          break;                      case "Double":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' libnodave.getFloatfrom(bytes' (int)numBytes));                          numBytes += 4;                          break;                  }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag<T>,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTagGeneric.cs,FromBytes,The following statement contains a magic number: switch (info.FieldType.Name)                  {                      case "Boolean":                          // get the value                          bytePos = (int)Math.Floor(numBytes);                          bitPos = (int)((numBytes - (double)bytePos) / 0.125);                          if ((bytes[bytePos] & (int)Math.Pow(2' bitPos)) != 0)                              info.SetValue(structValue' true);                          else                              info.SetValue(structValue' false);                          numBytes += 0.125;                          break;                      case "Byte":                          numBytes = Math.Ceiling(numBytes);                          info.SetValue(structValue' (byte)(bytes[(int)numBytes]));                          numBytes++;                          break;                      case "String":                          {                              numBytes = Math.Ceiling(numBytes);                              if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                                  numBytes++;                                MarshalAsAttribute mAttr = null;                              object[] attr = info.GetCustomAttributes(typeof (MarshalAsAttribute)' false);                              if (attr.Length > 0)                                  mAttr = (MarshalAsAttribute) attr[0];                              if (mAttr == null || mAttr.Value != UnmanagedType.ByValTStr || mAttr.SizeConst <= 0)                                  throw new Exception("Strings in Structs need to be decorated with \"MarshalAs(UnmanagedType.ByValTStr' SizeConst = xx)\"");                                var sb = new StringBuilder();                              int size = mAttr.SizeConst > bytes[((int) numBytes) + 1] ? bytes[((int) numBytes) + 1] : mAttr.SizeConst;                              for (var n = 2; n < size+2; n++)                                  sb.Append((char) bytes[n + (int) numBytes]);                              info.SetValue(structValue' (String) sb.ToString());                                numBytes += 2 + mAttr.SizeConst;                          }                          break;                      case "Int16":                           numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' libnodave.getS16from(bytes' (int) numBytes));                          numBytes += 2;                          break;                      case "UInt16":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' libnodave.getU16from(bytes' (int) numBytes));                          numBytes += 2;                          break;                      case "Int32":                           numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' libnodave.getS32from(bytes' (int)numBytes));                          numBytes += 4;                          break;                      case "UInt32":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' libnodave.getU32from(bytes' (int)numBytes));                          numBytes += 4;                          break;                      case "Double":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' libnodave.getFloatfrom(bytes' (int)numBytes));                          numBytes += 4;                          break;                  }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag<T>,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTagGeneric.cs,FromBytes,The following statement contains a magic number: switch (info.FieldType.Name)                  {                      case "Boolean":                          // get the value                          bytePos = (int)Math.Floor(numBytes);                          bitPos = (int)((numBytes - (double)bytePos) / 0.125);                          if ((bytes[bytePos] & (int)Math.Pow(2' bitPos)) != 0)                              info.SetValue(structValue' true);                          else                              info.SetValue(structValue' false);                          numBytes += 0.125;                          break;                      case "Byte":                          numBytes = Math.Ceiling(numBytes);                          info.SetValue(structValue' (byte)(bytes[(int)numBytes]));                          numBytes++;                          break;                      case "String":                          {                              numBytes = Math.Ceiling(numBytes);                              if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                                  numBytes++;                                MarshalAsAttribute mAttr = null;                              object[] attr = info.GetCustomAttributes(typeof (MarshalAsAttribute)' false);                              if (attr.Length > 0)                                  mAttr = (MarshalAsAttribute) attr[0];                              if (mAttr == null || mAttr.Value != UnmanagedType.ByValTStr || mAttr.SizeConst <= 0)                                  throw new Exception("Strings in Structs need to be decorated with \"MarshalAs(UnmanagedType.ByValTStr' SizeConst = xx)\"");                                var sb = new StringBuilder();                              int size = mAttr.SizeConst > bytes[((int) numBytes) + 1] ? bytes[((int) numBytes) + 1] : mAttr.SizeConst;                              for (var n = 2; n < size+2; n++)                                  sb.Append((char) bytes[n + (int) numBytes]);                              info.SetValue(structValue' (String) sb.ToString());                                numBytes += 2 + mAttr.SizeConst;                          }                          break;                      case "Int16":                           numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' libnodave.getS16from(bytes' (int) numBytes));                          numBytes += 2;                          break;                      case "UInt16":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' libnodave.getU16from(bytes' (int) numBytes));                          numBytes += 2;                          break;                      case "Int32":                           numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' libnodave.getS32from(bytes' (int)numBytes));                          numBytes += 4;                          break;                      case "UInt32":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' libnodave.getU32from(bytes' (int)numBytes));                          numBytes += 4;                          break;                      case "Double":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' libnodave.getFloatfrom(bytes' (int)numBytes));                          numBytes += 4;                          break;                  }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag<T>,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTagGeneric.cs,FromBytes,The following statement contains a magic number: switch (info.FieldType.Name)                  {                      case "Boolean":                          // get the value                          bytePos = (int)Math.Floor(numBytes);                          bitPos = (int)((numBytes - (double)bytePos) / 0.125);                          if ((bytes[bytePos] & (int)Math.Pow(2' bitPos)) != 0)                              info.SetValue(structValue' true);                          else                              info.SetValue(structValue' false);                          numBytes += 0.125;                          break;                      case "Byte":                          numBytes = Math.Ceiling(numBytes);                          info.SetValue(structValue' (byte)(bytes[(int)numBytes]));                          numBytes++;                          break;                      case "String":                          {                              numBytes = Math.Ceiling(numBytes);                              if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                                  numBytes++;                                MarshalAsAttribute mAttr = null;                              object[] attr = info.GetCustomAttributes(typeof (MarshalAsAttribute)' false);                              if (attr.Length > 0)                                  mAttr = (MarshalAsAttribute) attr[0];                              if (mAttr == null || mAttr.Value != UnmanagedType.ByValTStr || mAttr.SizeConst <= 0)                                  throw new Exception("Strings in Structs need to be decorated with \"MarshalAs(UnmanagedType.ByValTStr' SizeConst = xx)\"");                                var sb = new StringBuilder();                              int size = mAttr.SizeConst > bytes[((int) numBytes) + 1] ? bytes[((int) numBytes) + 1] : mAttr.SizeConst;                              for (var n = 2; n < size+2; n++)                                  sb.Append((char) bytes[n + (int) numBytes]);                              info.SetValue(structValue' (String) sb.ToString());                                numBytes += 2 + mAttr.SizeConst;                          }                          break;                      case "Int16":                           numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' libnodave.getS16from(bytes' (int) numBytes));                          numBytes += 2;                          break;                      case "UInt16":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' libnodave.getU16from(bytes' (int) numBytes));                          numBytes += 2;                          break;                      case "Int32":                           numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' libnodave.getS32from(bytes' (int)numBytes));                          numBytes += 4;                          break;                      case "UInt32":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' libnodave.getU32from(bytes' (int)numBytes));                          numBytes += 4;                          break;                      case "Double":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' libnodave.getFloatfrom(bytes' (int)numBytes));                          numBytes += 4;                          break;                  }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag<T>,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTagGeneric.cs,FromBytes,The following statement contains a magic number: switch (info.FieldType.Name)                  {                      case "Boolean":                          // get the value                          bytePos = (int)Math.Floor(numBytes);                          bitPos = (int)((numBytes - (double)bytePos) / 0.125);                          if ((bytes[bytePos] & (int)Math.Pow(2' bitPos)) != 0)                              info.SetValue(structValue' true);                          else                              info.SetValue(structValue' false);                          numBytes += 0.125;                          break;                      case "Byte":                          numBytes = Math.Ceiling(numBytes);                          info.SetValue(structValue' (byte)(bytes[(int)numBytes]));                          numBytes++;                          break;                      case "String":                          {                              numBytes = Math.Ceiling(numBytes);                              if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                                  numBytes++;                                MarshalAsAttribute mAttr = null;                              object[] attr = info.GetCustomAttributes(typeof (MarshalAsAttribute)' false);                              if (attr.Length > 0)                                  mAttr = (MarshalAsAttribute) attr[0];                              if (mAttr == null || mAttr.Value != UnmanagedType.ByValTStr || mAttr.SizeConst <= 0)                                  throw new Exception("Strings in Structs need to be decorated with \"MarshalAs(UnmanagedType.ByValTStr' SizeConst = xx)\"");                                var sb = new StringBuilder();                              int size = mAttr.SizeConst > bytes[((int) numBytes) + 1] ? bytes[((int) numBytes) + 1] : mAttr.SizeConst;                              for (var n = 2; n < size+2; n++)                                  sb.Append((char) bytes[n + (int) numBytes]);                              info.SetValue(structValue' (String) sb.ToString());                                numBytes += 2 + mAttr.SizeConst;                          }                          break;                      case "Int16":                           numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' libnodave.getS16from(bytes' (int) numBytes));                          numBytes += 2;                          break;                      case "UInt16":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' libnodave.getU16from(bytes' (int) numBytes));                          numBytes += 2;                          break;                      case "Int32":                           numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' libnodave.getS32from(bytes' (int)numBytes));                          numBytes += 4;                          break;                      case "UInt32":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' libnodave.getU32from(bytes' (int)numBytes));                          numBytes += 4;                          break;                      case "Double":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' libnodave.getFloatfrom(bytes' (int)numBytes));                          numBytes += 4;                          break;                  }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag<T>,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTagGeneric.cs,FromBytes,The following statement contains a magic number: switch (info.FieldType.Name)                  {                      case "Boolean":                          // get the value                          bytePos = (int)Math.Floor(numBytes);                          bitPos = (int)((numBytes - (double)bytePos) / 0.125);                          if ((bytes[bytePos] & (int)Math.Pow(2' bitPos)) != 0)                              info.SetValue(structValue' true);                          else                              info.SetValue(structValue' false);                          numBytes += 0.125;                          break;                      case "Byte":                          numBytes = Math.Ceiling(numBytes);                          info.SetValue(structValue' (byte)(bytes[(int)numBytes]));                          numBytes++;                          break;                      case "String":                          {                              numBytes = Math.Ceiling(numBytes);                              if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                                  numBytes++;                                MarshalAsAttribute mAttr = null;                              object[] attr = info.GetCustomAttributes(typeof (MarshalAsAttribute)' false);                              if (attr.Length > 0)                                  mAttr = (MarshalAsAttribute) attr[0];                              if (mAttr == null || mAttr.Value != UnmanagedType.ByValTStr || mAttr.SizeConst <= 0)                                  throw new Exception("Strings in Structs need to be decorated with \"MarshalAs(UnmanagedType.ByValTStr' SizeConst = xx)\"");                                var sb = new StringBuilder();                              int size = mAttr.SizeConst > bytes[((int) numBytes) + 1] ? bytes[((int) numBytes) + 1] : mAttr.SizeConst;                              for (var n = 2; n < size+2; n++)                                  sb.Append((char) bytes[n + (int) numBytes]);                              info.SetValue(structValue' (String) sb.ToString());                                numBytes += 2 + mAttr.SizeConst;                          }                          break;                      case "Int16":                           numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' libnodave.getS16from(bytes' (int) numBytes));                          numBytes += 2;                          break;                      case "UInt16":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' libnodave.getU16from(bytes' (int) numBytes));                          numBytes += 2;                          break;                      case "Int32":                           numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' libnodave.getS32from(bytes' (int)numBytes));                          numBytes += 4;                          break;                      case "UInt32":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' libnodave.getU32from(bytes' (int)numBytes));                          numBytes += 4;                          break;                      case "Double":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' libnodave.getFloatfrom(bytes' (int)numBytes));                          numBytes += 4;                          break;                  }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag<T>,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTagGeneric.cs,FromBytes,The following statement contains a magic number: switch (info.FieldType.Name)                  {                      case "Boolean":                          // get the value                          bytePos = (int)Math.Floor(numBytes);                          bitPos = (int)((numBytes - (double)bytePos) / 0.125);                          if ((bytes[bytePos] & (int)Math.Pow(2' bitPos)) != 0)                              info.SetValue(structValue' true);                          else                              info.SetValue(structValue' false);                          numBytes += 0.125;                          break;                      case "Byte":                          numBytes = Math.Ceiling(numBytes);                          info.SetValue(structValue' (byte)(bytes[(int)numBytes]));                          numBytes++;                          break;                      case "String":                          {                              numBytes = Math.Ceiling(numBytes);                              if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                                  numBytes++;                                MarshalAsAttribute mAttr = null;                              object[] attr = info.GetCustomAttributes(typeof (MarshalAsAttribute)' false);                              if (attr.Length > 0)                                  mAttr = (MarshalAsAttribute) attr[0];                              if (mAttr == null || mAttr.Value != UnmanagedType.ByValTStr || mAttr.SizeConst <= 0)                                  throw new Exception("Strings in Structs need to be decorated with \"MarshalAs(UnmanagedType.ByValTStr' SizeConst = xx)\"");                                var sb = new StringBuilder();                              int size = mAttr.SizeConst > bytes[((int) numBytes) + 1] ? bytes[((int) numBytes) + 1] : mAttr.SizeConst;                              for (var n = 2; n < size+2; n++)                                  sb.Append((char) bytes[n + (int) numBytes]);                              info.SetValue(structValue' (String) sb.ToString());                                numBytes += 2 + mAttr.SizeConst;                          }                          break;                      case "Int16":                           numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' libnodave.getS16from(bytes' (int) numBytes));                          numBytes += 2;                          break;                      case "UInt16":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' libnodave.getU16from(bytes' (int) numBytes));                          numBytes += 2;                          break;                      case "Int32":                           numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' libnodave.getS32from(bytes' (int)numBytes));                          numBytes += 4;                          break;                      case "UInt32":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' libnodave.getU32from(bytes' (int)numBytes));                          numBytes += 4;                          break;                      case "Double":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' libnodave.getFloatfrom(bytes' (int)numBytes));                          numBytes += 4;                          break;                  }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag<T>,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTagGeneric.cs,FromBytes,The following statement contains a magic number: switch (info.FieldType.Name)                  {                      case "Boolean":                          // get the value                          bytePos = (int)Math.Floor(numBytes);                          bitPos = (int)((numBytes - (double)bytePos) / 0.125);                          if ((bytes[bytePos] & (int)Math.Pow(2' bitPos)) != 0)                              info.SetValue(structValue' true);                          else                              info.SetValue(structValue' false);                          numBytes += 0.125;                          break;                      case "Byte":                          numBytes = Math.Ceiling(numBytes);                          info.SetValue(structValue' (byte)(bytes[(int)numBytes]));                          numBytes++;                          break;                      case "String":                          {                              numBytes = Math.Ceiling(numBytes);                              if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                                  numBytes++;                                MarshalAsAttribute mAttr = null;                              object[] attr = info.GetCustomAttributes(typeof (MarshalAsAttribute)' false);                              if (attr.Length > 0)                                  mAttr = (MarshalAsAttribute) attr[0];                              if (mAttr == null || mAttr.Value != UnmanagedType.ByValTStr || mAttr.SizeConst <= 0)                                  throw new Exception("Strings in Structs need to be decorated with \"MarshalAs(UnmanagedType.ByValTStr' SizeConst = xx)\"");                                var sb = new StringBuilder();                              int size = mAttr.SizeConst > bytes[((int) numBytes) + 1] ? bytes[((int) numBytes) + 1] : mAttr.SizeConst;                              for (var n = 2; n < size+2; n++)                                  sb.Append((char) bytes[n + (int) numBytes]);                              info.SetValue(structValue' (String) sb.ToString());                                numBytes += 2 + mAttr.SizeConst;                          }                          break;                      case "Int16":                           numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' libnodave.getS16from(bytes' (int) numBytes));                          numBytes += 2;                          break;                      case "UInt16":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' libnodave.getU16from(bytes' (int) numBytes));                          numBytes += 2;                          break;                      case "Int32":                           numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' libnodave.getS32from(bytes' (int)numBytes));                          numBytes += 4;                          break;                      case "UInt32":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' libnodave.getU32from(bytes' (int)numBytes));                          numBytes += 4;                          break;                      case "Double":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' libnodave.getFloatfrom(bytes' (int)numBytes));                          numBytes += 4;                          break;                  }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag<T>,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTagGeneric.cs,FromBytes,The following statement contains a magic number: switch (info.FieldType.Name)                  {                      case "Boolean":                          // get the value                          bytePos = (int)Math.Floor(numBytes);                          bitPos = (int)((numBytes - (double)bytePos) / 0.125);                          if ((bytes[bytePos] & (int)Math.Pow(2' bitPos)) != 0)                              info.SetValue(structValue' true);                          else                              info.SetValue(structValue' false);                          numBytes += 0.125;                          break;                      case "Byte":                          numBytes = Math.Ceiling(numBytes);                          info.SetValue(structValue' (byte)(bytes[(int)numBytes]));                          numBytes++;                          break;                      case "String":                          {                              numBytes = Math.Ceiling(numBytes);                              if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                                  numBytes++;                                MarshalAsAttribute mAttr = null;                              object[] attr = info.GetCustomAttributes(typeof (MarshalAsAttribute)' false);                              if (attr.Length > 0)                                  mAttr = (MarshalAsAttribute) attr[0];                              if (mAttr == null || mAttr.Value != UnmanagedType.ByValTStr || mAttr.SizeConst <= 0)                                  throw new Exception("Strings in Structs need to be decorated with \"MarshalAs(UnmanagedType.ByValTStr' SizeConst = xx)\"");                                var sb = new StringBuilder();                              int size = mAttr.SizeConst > bytes[((int) numBytes) + 1] ? bytes[((int) numBytes) + 1] : mAttr.SizeConst;                              for (var n = 2; n < size+2; n++)                                  sb.Append((char) bytes[n + (int) numBytes]);                              info.SetValue(structValue' (String) sb.ToString());                                numBytes += 2 + mAttr.SizeConst;                          }                          break;                      case "Int16":                           numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' libnodave.getS16from(bytes' (int) numBytes));                          numBytes += 2;                          break;                      case "UInt16":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' libnodave.getU16from(bytes' (int) numBytes));                          numBytes += 2;                          break;                      case "Int32":                           numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' libnodave.getS32from(bytes' (int)numBytes));                          numBytes += 4;                          break;                      case "UInt32":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' libnodave.getU32from(bytes' (int)numBytes));                          numBytes += 4;                          break;                      case "Double":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' libnodave.getFloatfrom(bytes' (int)numBytes));                          numBytes += 4;                          break;                  }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag<T>,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTagGeneric.cs,FromBytes,The following statement contains a magic number: switch (info.FieldType.Name)                  {                      case "Boolean":                          // get the value                          bytePos = (int)Math.Floor(numBytes);                          bitPos = (int)((numBytes - (double)bytePos) / 0.125);                          if ((bytes[bytePos] & (int)Math.Pow(2' bitPos)) != 0)                              info.SetValue(structValue' true);                          else                              info.SetValue(structValue' false);                          numBytes += 0.125;                          break;                      case "Byte":                          numBytes = Math.Ceiling(numBytes);                          info.SetValue(structValue' (byte)(bytes[(int)numBytes]));                          numBytes++;                          break;                      case "String":                          {                              numBytes = Math.Ceiling(numBytes);                              if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                                  numBytes++;                                MarshalAsAttribute mAttr = null;                              object[] attr = info.GetCustomAttributes(typeof (MarshalAsAttribute)' false);                              if (attr.Length > 0)                                  mAttr = (MarshalAsAttribute) attr[0];                              if (mAttr == null || mAttr.Value != UnmanagedType.ByValTStr || mAttr.SizeConst <= 0)                                  throw new Exception("Strings in Structs need to be decorated with \"MarshalAs(UnmanagedType.ByValTStr' SizeConst = xx)\"");                                var sb = new StringBuilder();                              int size = mAttr.SizeConst > bytes[((int) numBytes) + 1] ? bytes[((int) numBytes) + 1] : mAttr.SizeConst;                              for (var n = 2; n < size+2; n++)                                  sb.Append((char) bytes[n + (int) numBytes]);                              info.SetValue(structValue' (String) sb.ToString());                                numBytes += 2 + mAttr.SizeConst;                          }                          break;                      case "Int16":                           numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' libnodave.getS16from(bytes' (int) numBytes));                          numBytes += 2;                          break;                      case "UInt16":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' libnodave.getU16from(bytes' (int) numBytes));                          numBytes += 2;                          break;                      case "Int32":                           numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' libnodave.getS32from(bytes' (int)numBytes));                          numBytes += 4;                          break;                      case "UInt32":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' libnodave.getU32from(bytes' (int)numBytes));                          numBytes += 4;                          break;                      case "Double":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' libnodave.getFloatfrom(bytes' (int)numBytes));                          numBytes += 4;                          break;                  }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag<T>,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTagGeneric.cs,FromBytes,The following statement contains a magic number: switch (info.FieldType.Name)                  {                      case "Boolean":                          // get the value                          bytePos = (int)Math.Floor(numBytes);                          bitPos = (int)((numBytes - (double)bytePos) / 0.125);                          if ((bytes[bytePos] & (int)Math.Pow(2' bitPos)) != 0)                              info.SetValue(structValue' true);                          else                              info.SetValue(structValue' false);                          numBytes += 0.125;                          break;                      case "Byte":                          numBytes = Math.Ceiling(numBytes);                          info.SetValue(structValue' (byte)(bytes[(int)numBytes]));                          numBytes++;                          break;                      case "String":                          {                              numBytes = Math.Ceiling(numBytes);                              if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                                  numBytes++;                                MarshalAsAttribute mAttr = null;                              object[] attr = info.GetCustomAttributes(typeof (MarshalAsAttribute)' false);                              if (attr.Length > 0)                                  mAttr = (MarshalAsAttribute) attr[0];                              if (mAttr == null || mAttr.Value != UnmanagedType.ByValTStr || mAttr.SizeConst <= 0)                                  throw new Exception("Strings in Structs need to be decorated with \"MarshalAs(UnmanagedType.ByValTStr' SizeConst = xx)\"");                                var sb = new StringBuilder();                              int size = mAttr.SizeConst > bytes[((int) numBytes) + 1] ? bytes[((int) numBytes) + 1] : mAttr.SizeConst;                              for (var n = 2; n < size+2; n++)                                  sb.Append((char) bytes[n + (int) numBytes]);                              info.SetValue(structValue' (String) sb.ToString());                                numBytes += 2 + mAttr.SizeConst;                          }                          break;                      case "Int16":                           numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' libnodave.getS16from(bytes' (int) numBytes));                          numBytes += 2;                          break;                      case "UInt16":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' libnodave.getU16from(bytes' (int) numBytes));                          numBytes += 2;                          break;                      case "Int32":                           numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' libnodave.getS32from(bytes' (int)numBytes));                          numBytes += 4;                          break;                      case "UInt32":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' libnodave.getU32from(bytes' (int)numBytes));                          numBytes += 4;                          break;                      case "Double":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' libnodave.getFloatfrom(bytes' (int)numBytes));                          numBytes += 4;                          break;                  }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag<T>,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTagGeneric.cs,FromBytes,The following statement contains a magic number: switch (info.FieldType.Name)                  {                      case "Boolean":                          // get the value                          bytePos = (int)Math.Floor(numBytes);                          bitPos = (int)((numBytes - (double)bytePos) / 0.125);                          if ((bytes[bytePos] & (int)Math.Pow(2' bitPos)) != 0)                              info.SetValue(structValue' true);                          else                              info.SetValue(structValue' false);                          numBytes += 0.125;                          break;                      case "Byte":                          numBytes = Math.Ceiling(numBytes);                          info.SetValue(structValue' (byte)(bytes[(int)numBytes]));                          numBytes++;                          break;                      case "String":                          {                              numBytes = Math.Ceiling(numBytes);                              if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                                  numBytes++;                                MarshalAsAttribute mAttr = null;                              object[] attr = info.GetCustomAttributes(typeof (MarshalAsAttribute)' false);                              if (attr.Length > 0)                                  mAttr = (MarshalAsAttribute) attr[0];                              if (mAttr == null || mAttr.Value != UnmanagedType.ByValTStr || mAttr.SizeConst <= 0)                                  throw new Exception("Strings in Structs need to be decorated with \"MarshalAs(UnmanagedType.ByValTStr' SizeConst = xx)\"");                                var sb = new StringBuilder();                              int size = mAttr.SizeConst > bytes[((int) numBytes) + 1] ? bytes[((int) numBytes) + 1] : mAttr.SizeConst;                              for (var n = 2; n < size+2; n++)                                  sb.Append((char) bytes[n + (int) numBytes]);                              info.SetValue(structValue' (String) sb.ToString());                                numBytes += 2 + mAttr.SizeConst;                          }                          break;                      case "Int16":                           numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' libnodave.getS16from(bytes' (int) numBytes));                          numBytes += 2;                          break;                      case "UInt16":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' libnodave.getU16from(bytes' (int) numBytes));                          numBytes += 2;                          break;                      case "Int32":                           numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' libnodave.getS32from(bytes' (int)numBytes));                          numBytes += 4;                          break;                      case "UInt32":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' libnodave.getU32from(bytes' (int)numBytes));                          numBytes += 4;                          break;                      case "Double":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' libnodave.getFloatfrom(bytes' (int)numBytes));                          numBytes += 4;                          break;                  }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag<T>,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTagGeneric.cs,FromBytes,The following statement contains a magic number: switch (info.FieldType.Name)                  {                      case "Boolean":                          // get the value                          bytePos = (int)Math.Floor(numBytes);                          bitPos = (int)((numBytes - (double)bytePos) / 0.125);                          if ((bytes[bytePos] & (int)Math.Pow(2' bitPos)) != 0)                              info.SetValue(structValue' true);                          else                              info.SetValue(structValue' false);                          numBytes += 0.125;                          break;                      case "Byte":                          numBytes = Math.Ceiling(numBytes);                          info.SetValue(structValue' (byte)(bytes[(int)numBytes]));                          numBytes++;                          break;                      case "String":                          {                              numBytes = Math.Ceiling(numBytes);                              if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                                  numBytes++;                                MarshalAsAttribute mAttr = null;                              object[] attr = info.GetCustomAttributes(typeof (MarshalAsAttribute)' false);                              if (attr.Length > 0)                                  mAttr = (MarshalAsAttribute) attr[0];                              if (mAttr == null || mAttr.Value != UnmanagedType.ByValTStr || mAttr.SizeConst <= 0)                                  throw new Exception("Strings in Structs need to be decorated with \"MarshalAs(UnmanagedType.ByValTStr' SizeConst = xx)\"");                                var sb = new StringBuilder();                              int size = mAttr.SizeConst > bytes[((int) numBytes) + 1] ? bytes[((int) numBytes) + 1] : mAttr.SizeConst;                              for (var n = 2; n < size+2; n++)                                  sb.Append((char) bytes[n + (int) numBytes]);                              info.SetValue(structValue' (String) sb.ToString());                                numBytes += 2 + mAttr.SizeConst;                          }                          break;                      case "Int16":                           numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' libnodave.getS16from(bytes' (int) numBytes));                          numBytes += 2;                          break;                      case "UInt16":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' libnodave.getU16from(bytes' (int) numBytes));                          numBytes += 2;                          break;                      case "Int32":                           numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' libnodave.getS32from(bytes' (int)numBytes));                          numBytes += 4;                          break;                      case "UInt32":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' libnodave.getU32from(bytes' (int)numBytes));                          numBytes += 4;                          break;                      case "Double":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' libnodave.getFloatfrom(bytes' (int)numBytes));                          numBytes += 4;                          break;                  }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag<T>,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTagGeneric.cs,FromBytes,The following statement contains a magic number: switch (info.FieldType.Name)                  {                      case "Boolean":                          // get the value                          bytePos = (int)Math.Floor(numBytes);                          bitPos = (int)((numBytes - (double)bytePos) / 0.125);                          if ((bytes[bytePos] & (int)Math.Pow(2' bitPos)) != 0)                              info.SetValue(structValue' true);                          else                              info.SetValue(structValue' false);                          numBytes += 0.125;                          break;                      case "Byte":                          numBytes = Math.Ceiling(numBytes);                          info.SetValue(structValue' (byte)(bytes[(int)numBytes]));                          numBytes++;                          break;                      case "String":                          {                              numBytes = Math.Ceiling(numBytes);                              if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                                  numBytes++;                                MarshalAsAttribute mAttr = null;                              object[] attr = info.GetCustomAttributes(typeof (MarshalAsAttribute)' false);                              if (attr.Length > 0)                                  mAttr = (MarshalAsAttribute) attr[0];                              if (mAttr == null || mAttr.Value != UnmanagedType.ByValTStr || mAttr.SizeConst <= 0)                                  throw new Exception("Strings in Structs need to be decorated with \"MarshalAs(UnmanagedType.ByValTStr' SizeConst = xx)\"");                                var sb = new StringBuilder();                              int size = mAttr.SizeConst > bytes[((int) numBytes) + 1] ? bytes[((int) numBytes) + 1] : mAttr.SizeConst;                              for (var n = 2; n < size+2; n++)                                  sb.Append((char) bytes[n + (int) numBytes]);                              info.SetValue(structValue' (String) sb.ToString());                                numBytes += 2 + mAttr.SizeConst;                          }                          break;                      case "Int16":                           numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' libnodave.getS16from(bytes' (int) numBytes));                          numBytes += 2;                          break;                      case "UInt16":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' libnodave.getU16from(bytes' (int) numBytes));                          numBytes += 2;                          break;                      case "Int32":                           numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' libnodave.getS32from(bytes' (int)numBytes));                          numBytes += 4;                          break;                      case "UInt32":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' libnodave.getU32from(bytes' (int)numBytes));                          numBytes += 4;                          break;                      case "Double":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' libnodave.getFloatfrom(bytes' (int)numBytes));                          numBytes += 4;                          break;                  }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag<T>,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTagGeneric.cs,GetStructSize,The following statement contains a magic number: switch (info.FieldType.Name)                  {                      case "Boolean":                          numBytes += 0.125;                          break;                      case "Byte":                          numBytes = Math.Ceiling(numBytes);                          numBytes++;                          break;                      case "Int16":                      case "UInt16":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          numBytes += 2;                          break;                      case "Int32":                      case "UInt32":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          numBytes += 4;                          break;                      case "Float":                      case "Double":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          numBytes += 4;                          break;                      case "String":                          {                              MarshalAsAttribute mAttr=null;                              object[] attr = info.GetCustomAttributes(typeof (MarshalAsAttribute)' false);                              if (attr.Length > 0)                                  mAttr = (MarshalAsAttribute) attr[0];                              if (mAttr == null || mAttr.Value != UnmanagedType.ByValTStr || mAttr.SizeConst <= 0)                                  throw new Exception("Strings in Structs need to be decorated with \"MarshalAs(UnmanagedType.ByValTStr' SizeConst = xx)\"");                                numBytes += mAttr.SizeConst + 2;                          }                          break;                          /*                       * Typen welche noch fehlen                       *                        *                       case Arrays von jedem Datentyp!                      struct of struct                      TimeSpan                       *                       case "DateTime":                      case "String": //   Look for: [MarshalAs(UnmanagedType.ByValTStr ' SizeConst = 7)]                          break;                            */                  }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag<T>,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTagGeneric.cs,GetStructSize,The following statement contains a magic number: switch (info.FieldType.Name)                  {                      case "Boolean":                          numBytes += 0.125;                          break;                      case "Byte":                          numBytes = Math.Ceiling(numBytes);                          numBytes++;                          break;                      case "Int16":                      case "UInt16":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          numBytes += 2;                          break;                      case "Int32":                      case "UInt32":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          numBytes += 4;                          break;                      case "Float":                      case "Double":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          numBytes += 4;                          break;                      case "String":                          {                              MarshalAsAttribute mAttr=null;                              object[] attr = info.GetCustomAttributes(typeof (MarshalAsAttribute)' false);                              if (attr.Length > 0)                                  mAttr = (MarshalAsAttribute) attr[0];                              if (mAttr == null || mAttr.Value != UnmanagedType.ByValTStr || mAttr.SizeConst <= 0)                                  throw new Exception("Strings in Structs need to be decorated with \"MarshalAs(UnmanagedType.ByValTStr' SizeConst = xx)\"");                                numBytes += mAttr.SizeConst + 2;                          }                          break;                          /*                       * Typen welche noch fehlen                       *                        *                       case Arrays von jedem Datentyp!                      struct of struct                      TimeSpan                       *                       case "DateTime":                      case "String": //   Look for: [MarshalAs(UnmanagedType.ByValTStr ' SizeConst = 7)]                          break;                            */                  }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag<T>,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTagGeneric.cs,GetStructSize,The following statement contains a magic number: switch (info.FieldType.Name)                  {                      case "Boolean":                          numBytes += 0.125;                          break;                      case "Byte":                          numBytes = Math.Ceiling(numBytes);                          numBytes++;                          break;                      case "Int16":                      case "UInt16":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          numBytes += 2;                          break;                      case "Int32":                      case "UInt32":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          numBytes += 4;                          break;                      case "Float":                      case "Double":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          numBytes += 4;                          break;                      case "String":                          {                              MarshalAsAttribute mAttr=null;                              object[] attr = info.GetCustomAttributes(typeof (MarshalAsAttribute)' false);                              if (attr.Length > 0)                                  mAttr = (MarshalAsAttribute) attr[0];                              if (mAttr == null || mAttr.Value != UnmanagedType.ByValTStr || mAttr.SizeConst <= 0)                                  throw new Exception("Strings in Structs need to be decorated with \"MarshalAs(UnmanagedType.ByValTStr' SizeConst = xx)\"");                                numBytes += mAttr.SizeConst + 2;                          }                          break;                          /*                       * Typen welche noch fehlen                       *                        *                       case Arrays von jedem Datentyp!                      struct of struct                      TimeSpan                       *                       case "DateTime":                      case "String": //   Look for: [MarshalAs(UnmanagedType.ByValTStr ' SizeConst = 7)]                          break;                            */                  }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag<T>,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTagGeneric.cs,GetStructSize,The following statement contains a magic number: switch (info.FieldType.Name)                  {                      case "Boolean":                          numBytes += 0.125;                          break;                      case "Byte":                          numBytes = Math.Ceiling(numBytes);                          numBytes++;                          break;                      case "Int16":                      case "UInt16":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          numBytes += 2;                          break;                      case "Int32":                      case "UInt32":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          numBytes += 4;                          break;                      case "Float":                      case "Double":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          numBytes += 4;                          break;                      case "String":                          {                              MarshalAsAttribute mAttr=null;                              object[] attr = info.GetCustomAttributes(typeof (MarshalAsAttribute)' false);                              if (attr.Length > 0)                                  mAttr = (MarshalAsAttribute) attr[0];                              if (mAttr == null || mAttr.Value != UnmanagedType.ByValTStr || mAttr.SizeConst <= 0)                                  throw new Exception("Strings in Structs need to be decorated with \"MarshalAs(UnmanagedType.ByValTStr' SizeConst = xx)\"");                                numBytes += mAttr.SizeConst + 2;                          }                          break;                          /*                       * Typen welche noch fehlen                       *                        *                       case Arrays von jedem Datentyp!                      struct of struct                      TimeSpan                       *                       case "DateTime":                      case "String": //   Look for: [MarshalAs(UnmanagedType.ByValTStr ' SizeConst = 7)]                          break;                            */                  }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag<T>,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTagGeneric.cs,GetStructSize,The following statement contains a magic number: switch (info.FieldType.Name)                  {                      case "Boolean":                          numBytes += 0.125;                          break;                      case "Byte":                          numBytes = Math.Ceiling(numBytes);                          numBytes++;                          break;                      case "Int16":                      case "UInt16":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          numBytes += 2;                          break;                      case "Int32":                      case "UInt32":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          numBytes += 4;                          break;                      case "Float":                      case "Double":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          numBytes += 4;                          break;                      case "String":                          {                              MarshalAsAttribute mAttr=null;                              object[] attr = info.GetCustomAttributes(typeof (MarshalAsAttribute)' false);                              if (attr.Length > 0)                                  mAttr = (MarshalAsAttribute) attr[0];                              if (mAttr == null || mAttr.Value != UnmanagedType.ByValTStr || mAttr.SizeConst <= 0)                                  throw new Exception("Strings in Structs need to be decorated with \"MarshalAs(UnmanagedType.ByValTStr' SizeConst = xx)\"");                                numBytes += mAttr.SizeConst + 2;                          }                          break;                          /*                       * Typen welche noch fehlen                       *                        *                       case Arrays von jedem Datentyp!                      struct of struct                      TimeSpan                       *                       case "DateTime":                      case "String": //   Look for: [MarshalAs(UnmanagedType.ByValTStr ' SizeConst = 7)]                          break;                            */                  }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag<T>,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTagGeneric.cs,GetStructSize,The following statement contains a magic number: switch (info.FieldType.Name)                  {                      case "Boolean":                          numBytes += 0.125;                          break;                      case "Byte":                          numBytes = Math.Ceiling(numBytes);                          numBytes++;                          break;                      case "Int16":                      case "UInt16":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          numBytes += 2;                          break;                      case "Int32":                      case "UInt32":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          numBytes += 4;                          break;                      case "Float":                      case "Double":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          numBytes += 4;                          break;                      case "String":                          {                              MarshalAsAttribute mAttr=null;                              object[] attr = info.GetCustomAttributes(typeof (MarshalAsAttribute)' false);                              if (attr.Length > 0)                                  mAttr = (MarshalAsAttribute) attr[0];                              if (mAttr == null || mAttr.Value != UnmanagedType.ByValTStr || mAttr.SizeConst <= 0)                                  throw new Exception("Strings in Structs need to be decorated with \"MarshalAs(UnmanagedType.ByValTStr' SizeConst = xx)\"");                                numBytes += mAttr.SizeConst + 2;                          }                          break;                          /*                       * Typen welche noch fehlen                       *                        *                       case Arrays von jedem Datentyp!                      struct of struct                      TimeSpan                       *                       case "DateTime":                      case "String": //   Look for: [MarshalAs(UnmanagedType.ByValTStr ' SizeConst = 7)]                          break;                            */                  }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag<T>,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTagGeneric.cs,GetStructSize,The following statement contains a magic number: switch (info.FieldType.Name)                  {                      case "Boolean":                          numBytes += 0.125;                          break;                      case "Byte":                          numBytes = Math.Ceiling(numBytes);                          numBytes++;                          break;                      case "Int16":                      case "UInt16":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          numBytes += 2;                          break;                      case "Int32":                      case "UInt32":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          numBytes += 4;                          break;                      case "Float":                      case "Double":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          numBytes += 4;                          break;                      case "String":                          {                              MarshalAsAttribute mAttr=null;                              object[] attr = info.GetCustomAttributes(typeof (MarshalAsAttribute)' false);                              if (attr.Length > 0)                                  mAttr = (MarshalAsAttribute) attr[0];                              if (mAttr == null || mAttr.Value != UnmanagedType.ByValTStr || mAttr.SizeConst <= 0)                                  throw new Exception("Strings in Structs need to be decorated with \"MarshalAs(UnmanagedType.ByValTStr' SizeConst = xx)\"");                                numBytes += mAttr.SizeConst + 2;                          }                          break;                          /*                       * Typen welche noch fehlen                       *                        *                       case Arrays von jedem Datentyp!                      struct of struct                      TimeSpan                       *                       case "DateTime":                      case "String": //   Look for: [MarshalAs(UnmanagedType.ByValTStr ' SizeConst = 7)]                          break;                            */                  }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag<T>,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTagGeneric.cs,GetStructSize,The following statement contains a magic number: switch (info.FieldType.Name)                  {                      case "Boolean":                          numBytes += 0.125;                          break;                      case "Byte":                          numBytes = Math.Ceiling(numBytes);                          numBytes++;                          break;                      case "Int16":                      case "UInt16":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          numBytes += 2;                          break;                      case "Int32":                      case "UInt32":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          numBytes += 4;                          break;                      case "Float":                      case "Double":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          numBytes += 4;                          break;                      case "String":                          {                              MarshalAsAttribute mAttr=null;                              object[] attr = info.GetCustomAttributes(typeof (MarshalAsAttribute)' false);                              if (attr.Length > 0)                                  mAttr = (MarshalAsAttribute) attr[0];                              if (mAttr == null || mAttr.Value != UnmanagedType.ByValTStr || mAttr.SizeConst <= 0)                                  throw new Exception("Strings in Structs need to be decorated with \"MarshalAs(UnmanagedType.ByValTStr' SizeConst = xx)\"");                                numBytes += mAttr.SizeConst + 2;                          }                          break;                          /*                       * Typen welche noch fehlen                       *                        *                       case Arrays von jedem Datentyp!                      struct of struct                      TimeSpan                       *                       case "DateTime":                      case "String": //   Look for: [MarshalAs(UnmanagedType.ByValTStr ' SizeConst = 7)]                          break;                            */                  }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag<T>,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTagGeneric.cs,GetStructSize,The following statement contains a magic number: switch (info.FieldType.Name)                  {                      case "Boolean":                          numBytes += 0.125;                          break;                      case "Byte":                          numBytes = Math.Ceiling(numBytes);                          numBytes++;                          break;                      case "Int16":                      case "UInt16":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          numBytes += 2;                          break;                      case "Int32":                      case "UInt32":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          numBytes += 4;                          break;                      case "Float":                      case "Double":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          numBytes += 4;                          break;                      case "String":                          {                              MarshalAsAttribute mAttr=null;                              object[] attr = info.GetCustomAttributes(typeof (MarshalAsAttribute)' false);                              if (attr.Length > 0)                                  mAttr = (MarshalAsAttribute) attr[0];                              if (mAttr == null || mAttr.Value != UnmanagedType.ByValTStr || mAttr.SizeConst <= 0)                                  throw new Exception("Strings in Structs need to be decorated with \"MarshalAs(UnmanagedType.ByValTStr' SizeConst = xx)\"");                                numBytes += mAttr.SizeConst + 2;                          }                          break;                          /*                       * Typen welche noch fehlen                       *                        *                       case Arrays von jedem Datentyp!                      struct of struct                      TimeSpan                       *                       case "DateTime":                      case "String": //   Look for: [MarshalAs(UnmanagedType.ByValTStr ' SizeConst = 7)]                          break;                            */                  }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag<T>,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTagGeneric.cs,GetStructSize,The following statement contains a magic number: switch (info.FieldType.Name)                  {                      case "Boolean":                          numBytes += 0.125;                          break;                      case "Byte":                          numBytes = Math.Ceiling(numBytes);                          numBytes++;                          break;                      case "Int16":                      case "UInt16":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          numBytes += 2;                          break;                      case "Int32":                      case "UInt32":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          numBytes += 4;                          break;                      case "Float":                      case "Double":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          numBytes += 4;                          break;                      case "String":                          {                              MarshalAsAttribute mAttr=null;                              object[] attr = info.GetCustomAttributes(typeof (MarshalAsAttribute)' false);                              if (attr.Length > 0)                                  mAttr = (MarshalAsAttribute) attr[0];                              if (mAttr == null || mAttr.Value != UnmanagedType.ByValTStr || mAttr.SizeConst <= 0)                                  throw new Exception("Strings in Structs need to be decorated with \"MarshalAs(UnmanagedType.ByValTStr' SizeConst = xx)\"");                                numBytes += mAttr.SizeConst + 2;                          }                          break;                          /*                       * Typen welche noch fehlen                       *                        *                       case Arrays von jedem Datentyp!                      struct of struct                      TimeSpan                       *                       case "DateTime":                      case "String": //   Look for: [MarshalAs(UnmanagedType.ByValTStr ' SizeConst = 7)]                          break;                            */                  }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag<T>,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTagGeneric.cs,GetStructSize,The following statement contains a magic number: switch (info.FieldType.Name)                  {                      case "Boolean":                          numBytes += 0.125;                          break;                      case "Byte":                          numBytes = Math.Ceiling(numBytes);                          numBytes++;                          break;                      case "Int16":                      case "UInt16":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          numBytes += 2;                          break;                      case "Int32":                      case "UInt32":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          numBytes += 4;                          break;                      case "Float":                      case "Double":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          numBytes += 4;                          break;                      case "String":                          {                              MarshalAsAttribute mAttr=null;                              object[] attr = info.GetCustomAttributes(typeof (MarshalAsAttribute)' false);                              if (attr.Length > 0)                                  mAttr = (MarshalAsAttribute) attr[0];                              if (mAttr == null || mAttr.Value != UnmanagedType.ByValTStr || mAttr.SizeConst <= 0)                                  throw new Exception("Strings in Structs need to be decorated with \"MarshalAs(UnmanagedType.ByValTStr' SizeConst = xx)\"");                                numBytes += mAttr.SizeConst + 2;                          }                          break;                          /*                       * Typen welche noch fehlen                       *                        *                       case Arrays von jedem Datentyp!                      struct of struct                      TimeSpan                       *                       case "DateTime":                      case "String": //   Look for: [MarshalAs(UnmanagedType.ByValTStr ' SizeConst = 7)]                          break;                            */                  }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag<T>,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTagGeneric.cs,ToBytes,The following statement contains a magic number: switch (info.FieldType.Name)                  {                      case "Boolean":                          // get the value                          bytePos = (int)Math.Floor(numBytes);                          bitPos = (int)((numBytes - (double)bytePos) / 0.125);                          if ((bool)info.GetValue(structValue))                              bytes[bytePos] |= (byte)Math.Pow(2' bitPos);            // is true                          else                              bytes[bytePos] &= (byte)(~(byte)Math.Pow(2' bitPos));   // is false                          numBytes += 0.125;                          break;                      case "Byte":                          numBytes = (int)Math.Ceiling(numBytes);                          bytePos = (int)numBytes;                          bytes[bytePos] = (byte)info.GetValue(structValue);                          numBytes++;                          break;                      case "String":                          {                              MarshalAsAttribute mAttr = null;                              object[] attr = info.GetCustomAttributes(typeof (MarshalAsAttribute)' false);                              if (attr.Length > 0)                                  mAttr = (MarshalAsAttribute) attr[0];                              if (mAttr == null || mAttr.Value != UnmanagedType.ByValTStr || mAttr.SizeConst <= 0)                                  throw new Exception("Strings in Structs need to be decorated with \"MarshalAs(UnmanagedType.ByValTStr' SizeConst = xx)\"");                                bytes2 = new byte[mAttr.SizeConst + 2];                              libnodave.putS7Stringat(bytes2' 0' (string)info.GetValue(structValue)' bytes2.Length);                              bytePos = (int)numBytes;                          }                          break;                      case "Int16":                          bytes2 = new byte[2];                          libnodave.putS16at(bytes2' 0' (Int16) info.GetValue(structValue));                          bytePos = (int)numBytes;                          break;                      case "UInt16":                          bytes2 = new byte[2];                          libnodave.putU16at(bytes2' 0' (UInt16) info.GetValue(structValue));                          bytePos = (int)numBytes;                          break;                      case "Int32":                          bytes2 = new byte[4];                          libnodave.putS32at(bytes2' 0' (Int32) info.GetValue(structValue));                          bytePos = (int)numBytes;                          break;                      case "UInt32":                          bytes2 = new byte[4];                          libnodave.putU32at(bytes2' 0' (UInt32) info.GetValue(structValue));                          bytePos = (int)numBytes;                          break;                      case "Double":                          bytes2 = new byte[4];                          libnodave.putFloatat(bytes2' 0' Convert.ToSingle((double)info.GetValue(structValue)));                          bytePos = (int)numBytes;                          break;                      case "Single":                          bytes2 = new byte[4];                          libnodave.putFloatat(bytes2' 0' (Single)info.GetValue(structValue));                          bytePos = (int)numBytes;                          break;                  }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag<T>,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTagGeneric.cs,ToBytes,The following statement contains a magic number: switch (info.FieldType.Name)                  {                      case "Boolean":                          // get the value                          bytePos = (int)Math.Floor(numBytes);                          bitPos = (int)((numBytes - (double)bytePos) / 0.125);                          if ((bool)info.GetValue(structValue))                              bytes[bytePos] |= (byte)Math.Pow(2' bitPos);            // is true                          else                              bytes[bytePos] &= (byte)(~(byte)Math.Pow(2' bitPos));   // is false                          numBytes += 0.125;                          break;                      case "Byte":                          numBytes = (int)Math.Ceiling(numBytes);                          bytePos = (int)numBytes;                          bytes[bytePos] = (byte)info.GetValue(structValue);                          numBytes++;                          break;                      case "String":                          {                              MarshalAsAttribute mAttr = null;                              object[] attr = info.GetCustomAttributes(typeof (MarshalAsAttribute)' false);                              if (attr.Length > 0)                                  mAttr = (MarshalAsAttribute) attr[0];                              if (mAttr == null || mAttr.Value != UnmanagedType.ByValTStr || mAttr.SizeConst <= 0)                                  throw new Exception("Strings in Structs need to be decorated with \"MarshalAs(UnmanagedType.ByValTStr' SizeConst = xx)\"");                                bytes2 = new byte[mAttr.SizeConst + 2];                              libnodave.putS7Stringat(bytes2' 0' (string)info.GetValue(structValue)' bytes2.Length);                              bytePos = (int)numBytes;                          }                          break;                      case "Int16":                          bytes2 = new byte[2];                          libnodave.putS16at(bytes2' 0' (Int16) info.GetValue(structValue));                          bytePos = (int)numBytes;                          break;                      case "UInt16":                          bytes2 = new byte[2];                          libnodave.putU16at(bytes2' 0' (UInt16) info.GetValue(structValue));                          bytePos = (int)numBytes;                          break;                      case "Int32":                          bytes2 = new byte[4];                          libnodave.putS32at(bytes2' 0' (Int32) info.GetValue(structValue));                          bytePos = (int)numBytes;                          break;                      case "UInt32":                          bytes2 = new byte[4];                          libnodave.putU32at(bytes2' 0' (UInt32) info.GetValue(structValue));                          bytePos = (int)numBytes;                          break;                      case "Double":                          bytes2 = new byte[4];                          libnodave.putFloatat(bytes2' 0' Convert.ToSingle((double)info.GetValue(structValue)));                          bytePos = (int)numBytes;                          break;                      case "Single":                          bytes2 = new byte[4];                          libnodave.putFloatat(bytes2' 0' (Single)info.GetValue(structValue));                          bytePos = (int)numBytes;                          break;                  }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag<T>,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTagGeneric.cs,ToBytes,The following statement contains a magic number: switch (info.FieldType.Name)                  {                      case "Boolean":                          // get the value                          bytePos = (int)Math.Floor(numBytes);                          bitPos = (int)((numBytes - (double)bytePos) / 0.125);                          if ((bool)info.GetValue(structValue))                              bytes[bytePos] |= (byte)Math.Pow(2' bitPos);            // is true                          else                              bytes[bytePos] &= (byte)(~(byte)Math.Pow(2' bitPos));   // is false                          numBytes += 0.125;                          break;                      case "Byte":                          numBytes = (int)Math.Ceiling(numBytes);                          bytePos = (int)numBytes;                          bytes[bytePos] = (byte)info.GetValue(structValue);                          numBytes++;                          break;                      case "String":                          {                              MarshalAsAttribute mAttr = null;                              object[] attr = info.GetCustomAttributes(typeof (MarshalAsAttribute)' false);                              if (attr.Length > 0)                                  mAttr = (MarshalAsAttribute) attr[0];                              if (mAttr == null || mAttr.Value != UnmanagedType.ByValTStr || mAttr.SizeConst <= 0)                                  throw new Exception("Strings in Structs need to be decorated with \"MarshalAs(UnmanagedType.ByValTStr' SizeConst = xx)\"");                                bytes2 = new byte[mAttr.SizeConst + 2];                              libnodave.putS7Stringat(bytes2' 0' (string)info.GetValue(structValue)' bytes2.Length);                              bytePos = (int)numBytes;                          }                          break;                      case "Int16":                          bytes2 = new byte[2];                          libnodave.putS16at(bytes2' 0' (Int16) info.GetValue(structValue));                          bytePos = (int)numBytes;                          break;                      case "UInt16":                          bytes2 = new byte[2];                          libnodave.putU16at(bytes2' 0' (UInt16) info.GetValue(structValue));                          bytePos = (int)numBytes;                          break;                      case "Int32":                          bytes2 = new byte[4];                          libnodave.putS32at(bytes2' 0' (Int32) info.GetValue(structValue));                          bytePos = (int)numBytes;                          break;                      case "UInt32":                          bytes2 = new byte[4];                          libnodave.putU32at(bytes2' 0' (UInt32) info.GetValue(structValue));                          bytePos = (int)numBytes;                          break;                      case "Double":                          bytes2 = new byte[4];                          libnodave.putFloatat(bytes2' 0' Convert.ToSingle((double)info.GetValue(structValue)));                          bytePos = (int)numBytes;                          break;                      case "Single":                          bytes2 = new byte[4];                          libnodave.putFloatat(bytes2' 0' (Single)info.GetValue(structValue));                          bytePos = (int)numBytes;                          break;                  }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag<T>,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTagGeneric.cs,ToBytes,The following statement contains a magic number: switch (info.FieldType.Name)                  {                      case "Boolean":                          // get the value                          bytePos = (int)Math.Floor(numBytes);                          bitPos = (int)((numBytes - (double)bytePos) / 0.125);                          if ((bool)info.GetValue(structValue))                              bytes[bytePos] |= (byte)Math.Pow(2' bitPos);            // is true                          else                              bytes[bytePos] &= (byte)(~(byte)Math.Pow(2' bitPos));   // is false                          numBytes += 0.125;                          break;                      case "Byte":                          numBytes = (int)Math.Ceiling(numBytes);                          bytePos = (int)numBytes;                          bytes[bytePos] = (byte)info.GetValue(structValue);                          numBytes++;                          break;                      case "String":                          {                              MarshalAsAttribute mAttr = null;                              object[] attr = info.GetCustomAttributes(typeof (MarshalAsAttribute)' false);                              if (attr.Length > 0)                                  mAttr = (MarshalAsAttribute) attr[0];                              if (mAttr == null || mAttr.Value != UnmanagedType.ByValTStr || mAttr.SizeConst <= 0)                                  throw new Exception("Strings in Structs need to be decorated with \"MarshalAs(UnmanagedType.ByValTStr' SizeConst = xx)\"");                                bytes2 = new byte[mAttr.SizeConst + 2];                              libnodave.putS7Stringat(bytes2' 0' (string)info.GetValue(structValue)' bytes2.Length);                              bytePos = (int)numBytes;                          }                          break;                      case "Int16":                          bytes2 = new byte[2];                          libnodave.putS16at(bytes2' 0' (Int16) info.GetValue(structValue));                          bytePos = (int)numBytes;                          break;                      case "UInt16":                          bytes2 = new byte[2];                          libnodave.putU16at(bytes2' 0' (UInt16) info.GetValue(structValue));                          bytePos = (int)numBytes;                          break;                      case "Int32":                          bytes2 = new byte[4];                          libnodave.putS32at(bytes2' 0' (Int32) info.GetValue(structValue));                          bytePos = (int)numBytes;                          break;                      case "UInt32":                          bytes2 = new byte[4];                          libnodave.putU32at(bytes2' 0' (UInt32) info.GetValue(structValue));                          bytePos = (int)numBytes;                          break;                      case "Double":                          bytes2 = new byte[4];                          libnodave.putFloatat(bytes2' 0' Convert.ToSingle((double)info.GetValue(structValue)));                          bytePos = (int)numBytes;                          break;                      case "Single":                          bytes2 = new byte[4];                          libnodave.putFloatat(bytes2' 0' (Single)info.GetValue(structValue));                          bytePos = (int)numBytes;                          break;                  }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag<T>,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTagGeneric.cs,ToBytes,The following statement contains a magic number: switch (info.FieldType.Name)                  {                      case "Boolean":                          // get the value                          bytePos = (int)Math.Floor(numBytes);                          bitPos = (int)((numBytes - (double)bytePos) / 0.125);                          if ((bool)info.GetValue(structValue))                              bytes[bytePos] |= (byte)Math.Pow(2' bitPos);            // is true                          else                              bytes[bytePos] &= (byte)(~(byte)Math.Pow(2' bitPos));   // is false                          numBytes += 0.125;                          break;                      case "Byte":                          numBytes = (int)Math.Ceiling(numBytes);                          bytePos = (int)numBytes;                          bytes[bytePos] = (byte)info.GetValue(structValue);                          numBytes++;                          break;                      case "String":                          {                              MarshalAsAttribute mAttr = null;                              object[] attr = info.GetCustomAttributes(typeof (MarshalAsAttribute)' false);                              if (attr.Length > 0)                                  mAttr = (MarshalAsAttribute) attr[0];                              if (mAttr == null || mAttr.Value != UnmanagedType.ByValTStr || mAttr.SizeConst <= 0)                                  throw new Exception("Strings in Structs need to be decorated with \"MarshalAs(UnmanagedType.ByValTStr' SizeConst = xx)\"");                                bytes2 = new byte[mAttr.SizeConst + 2];                              libnodave.putS7Stringat(bytes2' 0' (string)info.GetValue(structValue)' bytes2.Length);                              bytePos = (int)numBytes;                          }                          break;                      case "Int16":                          bytes2 = new byte[2];                          libnodave.putS16at(bytes2' 0' (Int16) info.GetValue(structValue));                          bytePos = (int)numBytes;                          break;                      case "UInt16":                          bytes2 = new byte[2];                          libnodave.putU16at(bytes2' 0' (UInt16) info.GetValue(structValue));                          bytePos = (int)numBytes;                          break;                      case "Int32":                          bytes2 = new byte[4];                          libnodave.putS32at(bytes2' 0' (Int32) info.GetValue(structValue));                          bytePos = (int)numBytes;                          break;                      case "UInt32":                          bytes2 = new byte[4];                          libnodave.putU32at(bytes2' 0' (UInt32) info.GetValue(structValue));                          bytePos = (int)numBytes;                          break;                      case "Double":                          bytes2 = new byte[4];                          libnodave.putFloatat(bytes2' 0' Convert.ToSingle((double)info.GetValue(structValue)));                          bytePos = (int)numBytes;                          break;                      case "Single":                          bytes2 = new byte[4];                          libnodave.putFloatat(bytes2' 0' (Single)info.GetValue(structValue));                          bytePos = (int)numBytes;                          break;                  }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag<T>,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTagGeneric.cs,ToBytes,The following statement contains a magic number: switch (info.FieldType.Name)                  {                      case "Boolean":                          // get the value                          bytePos = (int)Math.Floor(numBytes);                          bitPos = (int)((numBytes - (double)bytePos) / 0.125);                          if ((bool)info.GetValue(structValue))                              bytes[bytePos] |= (byte)Math.Pow(2' bitPos);            // is true                          else                              bytes[bytePos] &= (byte)(~(byte)Math.Pow(2' bitPos));   // is false                          numBytes += 0.125;                          break;                      case "Byte":                          numBytes = (int)Math.Ceiling(numBytes);                          bytePos = (int)numBytes;                          bytes[bytePos] = (byte)info.GetValue(structValue);                          numBytes++;                          break;                      case "String":                          {                              MarshalAsAttribute mAttr = null;                              object[] attr = info.GetCustomAttributes(typeof (MarshalAsAttribute)' false);                              if (attr.Length > 0)                                  mAttr = (MarshalAsAttribute) attr[0];                              if (mAttr == null || mAttr.Value != UnmanagedType.ByValTStr || mAttr.SizeConst <= 0)                                  throw new Exception("Strings in Structs need to be decorated with \"MarshalAs(UnmanagedType.ByValTStr' SizeConst = xx)\"");                                bytes2 = new byte[mAttr.SizeConst + 2];                              libnodave.putS7Stringat(bytes2' 0' (string)info.GetValue(structValue)' bytes2.Length);                              bytePos = (int)numBytes;                          }                          break;                      case "Int16":                          bytes2 = new byte[2];                          libnodave.putS16at(bytes2' 0' (Int16) info.GetValue(structValue));                          bytePos = (int)numBytes;                          break;                      case "UInt16":                          bytes2 = new byte[2];                          libnodave.putU16at(bytes2' 0' (UInt16) info.GetValue(structValue));                          bytePos = (int)numBytes;                          break;                      case "Int32":                          bytes2 = new byte[4];                          libnodave.putS32at(bytes2' 0' (Int32) info.GetValue(structValue));                          bytePos = (int)numBytes;                          break;                      case "UInt32":                          bytes2 = new byte[4];                          libnodave.putU32at(bytes2' 0' (UInt32) info.GetValue(structValue));                          bytePos = (int)numBytes;                          break;                      case "Double":                          bytes2 = new byte[4];                          libnodave.putFloatat(bytes2' 0' Convert.ToSingle((double)info.GetValue(structValue)));                          bytePos = (int)numBytes;                          break;                      case "Single":                          bytes2 = new byte[4];                          libnodave.putFloatat(bytes2' 0' (Single)info.GetValue(structValue));                          bytePos = (int)numBytes;                          break;                  }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag<T>,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTagGeneric.cs,ToBytes,The following statement contains a magic number: switch (info.FieldType.Name)                  {                      case "Boolean":                          // get the value                          bytePos = (int)Math.Floor(numBytes);                          bitPos = (int)((numBytes - (double)bytePos) / 0.125);                          if ((bool)info.GetValue(structValue))                              bytes[bytePos] |= (byte)Math.Pow(2' bitPos);            // is true                          else                              bytes[bytePos] &= (byte)(~(byte)Math.Pow(2' bitPos));   // is false                          numBytes += 0.125;                          break;                      case "Byte":                          numBytes = (int)Math.Ceiling(numBytes);                          bytePos = (int)numBytes;                          bytes[bytePos] = (byte)info.GetValue(structValue);                          numBytes++;                          break;                      case "String":                          {                              MarshalAsAttribute mAttr = null;                              object[] attr = info.GetCustomAttributes(typeof (MarshalAsAttribute)' false);                              if (attr.Length > 0)                                  mAttr = (MarshalAsAttribute) attr[0];                              if (mAttr == null || mAttr.Value != UnmanagedType.ByValTStr || mAttr.SizeConst <= 0)                                  throw new Exception("Strings in Structs need to be decorated with \"MarshalAs(UnmanagedType.ByValTStr' SizeConst = xx)\"");                                bytes2 = new byte[mAttr.SizeConst + 2];                              libnodave.putS7Stringat(bytes2' 0' (string)info.GetValue(structValue)' bytes2.Length);                              bytePos = (int)numBytes;                          }                          break;                      case "Int16":                          bytes2 = new byte[2];                          libnodave.putS16at(bytes2' 0' (Int16) info.GetValue(structValue));                          bytePos = (int)numBytes;                          break;                      case "UInt16":                          bytes2 = new byte[2];                          libnodave.putU16at(bytes2' 0' (UInt16) info.GetValue(structValue));                          bytePos = (int)numBytes;                          break;                      case "Int32":                          bytes2 = new byte[4];                          libnodave.putS32at(bytes2' 0' (Int32) info.GetValue(structValue));                          bytePos = (int)numBytes;                          break;                      case "UInt32":                          bytes2 = new byte[4];                          libnodave.putU32at(bytes2' 0' (UInt32) info.GetValue(structValue));                          bytePos = (int)numBytes;                          break;                      case "Double":                          bytes2 = new byte[4];                          libnodave.putFloatat(bytes2' 0' Convert.ToSingle((double)info.GetValue(structValue)));                          bytePos = (int)numBytes;                          break;                      case "Single":                          bytes2 = new byte[4];                          libnodave.putFloatat(bytes2' 0' (Single)info.GetValue(structValue));                          bytePos = (int)numBytes;                          break;                  }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag<T>,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTagGeneric.cs,ToBytes,The following statement contains a magic number: switch (info.FieldType.Name)                  {                      case "Boolean":                          // get the value                          bytePos = (int)Math.Floor(numBytes);                          bitPos = (int)((numBytes - (double)bytePos) / 0.125);                          if ((bool)info.GetValue(structValue))                              bytes[bytePos] |= (byte)Math.Pow(2' bitPos);            // is true                          else                              bytes[bytePos] &= (byte)(~(byte)Math.Pow(2' bitPos));   // is false                          numBytes += 0.125;                          break;                      case "Byte":                          numBytes = (int)Math.Ceiling(numBytes);                          bytePos = (int)numBytes;                          bytes[bytePos] = (byte)info.GetValue(structValue);                          numBytes++;                          break;                      case "String":                          {                              MarshalAsAttribute mAttr = null;                              object[] attr = info.GetCustomAttributes(typeof (MarshalAsAttribute)' false);                              if (attr.Length > 0)                                  mAttr = (MarshalAsAttribute) attr[0];                              if (mAttr == null || mAttr.Value != UnmanagedType.ByValTStr || mAttr.SizeConst <= 0)                                  throw new Exception("Strings in Structs need to be decorated with \"MarshalAs(UnmanagedType.ByValTStr' SizeConst = xx)\"");                                bytes2 = new byte[mAttr.SizeConst + 2];                              libnodave.putS7Stringat(bytes2' 0' (string)info.GetValue(structValue)' bytes2.Length);                              bytePos = (int)numBytes;                          }                          break;                      case "Int16":                          bytes2 = new byte[2];                          libnodave.putS16at(bytes2' 0' (Int16) info.GetValue(structValue));                          bytePos = (int)numBytes;                          break;                      case "UInt16":                          bytes2 = new byte[2];                          libnodave.putU16at(bytes2' 0' (UInt16) info.GetValue(structValue));                          bytePos = (int)numBytes;                          break;                      case "Int32":                          bytes2 = new byte[4];                          libnodave.putS32at(bytes2' 0' (Int32) info.GetValue(structValue));                          bytePos = (int)numBytes;                          break;                      case "UInt32":                          bytes2 = new byte[4];                          libnodave.putU32at(bytes2' 0' (UInt32) info.GetValue(structValue));                          bytePos = (int)numBytes;                          break;                      case "Double":                          bytes2 = new byte[4];                          libnodave.putFloatat(bytes2' 0' Convert.ToSingle((double)info.GetValue(structValue)));                          bytePos = (int)numBytes;                          break;                      case "Single":                          bytes2 = new byte[4];                          libnodave.putFloatat(bytes2' 0' (Single)info.GetValue(structValue));                          bytePos = (int)numBytes;                          break;                  }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag<T>,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTagGeneric.cs,ToBytes,The following statement contains a magic number: switch (info.FieldType.Name)                  {                      case "Boolean":                          // get the value                          bytePos = (int)Math.Floor(numBytes);                          bitPos = (int)((numBytes - (double)bytePos) / 0.125);                          if ((bool)info.GetValue(structValue))                              bytes[bytePos] |= (byte)Math.Pow(2' bitPos);            // is true                          else                              bytes[bytePos] &= (byte)(~(byte)Math.Pow(2' bitPos));   // is false                          numBytes += 0.125;                          break;                      case "Byte":                          numBytes = (int)Math.Ceiling(numBytes);                          bytePos = (int)numBytes;                          bytes[bytePos] = (byte)info.GetValue(structValue);                          numBytes++;                          break;                      case "String":                          {                              MarshalAsAttribute mAttr = null;                              object[] attr = info.GetCustomAttributes(typeof (MarshalAsAttribute)' false);                              if (attr.Length > 0)                                  mAttr = (MarshalAsAttribute) attr[0];                              if (mAttr == null || mAttr.Value != UnmanagedType.ByValTStr || mAttr.SizeConst <= 0)                                  throw new Exception("Strings in Structs need to be decorated with \"MarshalAs(UnmanagedType.ByValTStr' SizeConst = xx)\"");                                bytes2 = new byte[mAttr.SizeConst + 2];                              libnodave.putS7Stringat(bytes2' 0' (string)info.GetValue(structValue)' bytes2.Length);                              bytePos = (int)numBytes;                          }                          break;                      case "Int16":                          bytes2 = new byte[2];                          libnodave.putS16at(bytes2' 0' (Int16) info.GetValue(structValue));                          bytePos = (int)numBytes;                          break;                      case "UInt16":                          bytes2 = new byte[2];                          libnodave.putU16at(bytes2' 0' (UInt16) info.GetValue(structValue));                          bytePos = (int)numBytes;                          break;                      case "Int32":                          bytes2 = new byte[4];                          libnodave.putS32at(bytes2' 0' (Int32) info.GetValue(structValue));                          bytePos = (int)numBytes;                          break;                      case "UInt32":                          bytes2 = new byte[4];                          libnodave.putU32at(bytes2' 0' (UInt32) info.GetValue(structValue));                          bytePos = (int)numBytes;                          break;                      case "Double":                          bytes2 = new byte[4];                          libnodave.putFloatat(bytes2' 0' Convert.ToSingle((double)info.GetValue(structValue)));                          bytePos = (int)numBytes;                          break;                      case "Single":                          bytes2 = new byte[4];                          libnodave.putFloatat(bytes2' 0' (Single)info.GetValue(structValue));                          bytePos = (int)numBytes;                          break;                  }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag<T>,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTagGeneric.cs,ToBytes,The following statement contains a magic number: switch (info.FieldType.Name)                  {                      case "Boolean":                          // get the value                          bytePos = (int)Math.Floor(numBytes);                          bitPos = (int)((numBytes - (double)bytePos) / 0.125);                          if ((bool)info.GetValue(structValue))                              bytes[bytePos] |= (byte)Math.Pow(2' bitPos);            // is true                          else                              bytes[bytePos] &= (byte)(~(byte)Math.Pow(2' bitPos));   // is false                          numBytes += 0.125;                          break;                      case "Byte":                          numBytes = (int)Math.Ceiling(numBytes);                          bytePos = (int)numBytes;                          bytes[bytePos] = (byte)info.GetValue(structValue);                          numBytes++;                          break;                      case "String":                          {                              MarshalAsAttribute mAttr = null;                              object[] attr = info.GetCustomAttributes(typeof (MarshalAsAttribute)' false);                              if (attr.Length > 0)                                  mAttr = (MarshalAsAttribute) attr[0];                              if (mAttr == null || mAttr.Value != UnmanagedType.ByValTStr || mAttr.SizeConst <= 0)                                  throw new Exception("Strings in Structs need to be decorated with \"MarshalAs(UnmanagedType.ByValTStr' SizeConst = xx)\"");                                bytes2 = new byte[mAttr.SizeConst + 2];                              libnodave.putS7Stringat(bytes2' 0' (string)info.GetValue(structValue)' bytes2.Length);                              bytePos = (int)numBytes;                          }                          break;                      case "Int16":                          bytes2 = new byte[2];                          libnodave.putS16at(bytes2' 0' (Int16) info.GetValue(structValue));                          bytePos = (int)numBytes;                          break;                      case "UInt16":                          bytes2 = new byte[2];                          libnodave.putU16at(bytes2' 0' (UInt16) info.GetValue(structValue));                          bytePos = (int)numBytes;                          break;                      case "Int32":                          bytes2 = new byte[4];                          libnodave.putS32at(bytes2' 0' (Int32) info.GetValue(structValue));                          bytePos = (int)numBytes;                          break;                      case "UInt32":                          bytes2 = new byte[4];                          libnodave.putU32at(bytes2' 0' (UInt32) info.GetValue(structValue));                          bytePos = (int)numBytes;                          break;                      case "Double":                          bytes2 = new byte[4];                          libnodave.putFloatat(bytes2' 0' Convert.ToSingle((double)info.GetValue(structValue)));                          bytePos = (int)numBytes;                          break;                      case "Single":                          bytes2 = new byte[4];                          libnodave.putFloatat(bytes2' 0' (Single)info.GetValue(structValue));                          bytePos = (int)numBytes;                          break;                  }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag<T>,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTagGeneric.cs,ToBytes,The following statement contains a magic number: switch (info.FieldType.Name)                  {                      case "Boolean":                          // get the value                          bytePos = (int)Math.Floor(numBytes);                          bitPos = (int)((numBytes - (double)bytePos) / 0.125);                          if ((bool)info.GetValue(structValue))                              bytes[bytePos] |= (byte)Math.Pow(2' bitPos);            // is true                          else                              bytes[bytePos] &= (byte)(~(byte)Math.Pow(2' bitPos));   // is false                          numBytes += 0.125;                          break;                      case "Byte":                          numBytes = (int)Math.Ceiling(numBytes);                          bytePos = (int)numBytes;                          bytes[bytePos] = (byte)info.GetValue(structValue);                          numBytes++;                          break;                      case "String":                          {                              MarshalAsAttribute mAttr = null;                              object[] attr = info.GetCustomAttributes(typeof (MarshalAsAttribute)' false);                              if (attr.Length > 0)                                  mAttr = (MarshalAsAttribute) attr[0];                              if (mAttr == null || mAttr.Value != UnmanagedType.ByValTStr || mAttr.SizeConst <= 0)                                  throw new Exception("Strings in Structs need to be decorated with \"MarshalAs(UnmanagedType.ByValTStr' SizeConst = xx)\"");                                bytes2 = new byte[mAttr.SizeConst + 2];                              libnodave.putS7Stringat(bytes2' 0' (string)info.GetValue(structValue)' bytes2.Length);                              bytePos = (int)numBytes;                          }                          break;                      case "Int16":                          bytes2 = new byte[2];                          libnodave.putS16at(bytes2' 0' (Int16) info.GetValue(structValue));                          bytePos = (int)numBytes;                          break;                      case "UInt16":                          bytes2 = new byte[2];                          libnodave.putU16at(bytes2' 0' (UInt16) info.GetValue(structValue));                          bytePos = (int)numBytes;                          break;                      case "Int32":                          bytes2 = new byte[4];                          libnodave.putS32at(bytes2' 0' (Int32) info.GetValue(structValue));                          bytePos = (int)numBytes;                          break;                      case "UInt32":                          bytes2 = new byte[4];                          libnodave.putU32at(bytes2' 0' (UInt32) info.GetValue(structValue));                          bytePos = (int)numBytes;                          break;                      case "Double":                          bytes2 = new byte[4];                          libnodave.putFloatat(bytes2' 0' Convert.ToSingle((double)info.GetValue(structValue)));                          bytePos = (int)numBytes;                          break;                      case "Single":                          bytes2 = new byte[4];                          libnodave.putFloatat(bytes2' 0' (Single)info.GetValue(structValue));                          bytePos = (int)numBytes;                          break;                  }
Magic Number,DotNetSiemensPLCToolBoxLibrary.DataTypes.AWL.Step7V5,S7ConvertingOptions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\AWL\Step7V5\S7ConvertingOptions.cs,GetHashCode,The following statement contains a magic number: hashCode = (hashCode * 397) ^ (int)this.Mnemonic;
Magic Number,DotNetSiemensPLCToolBoxLibrary.DataTypes.AWL.Step7V5,S7ConvertingOptions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\AWL\Step7V5\S7ConvertingOptions.cs,GetHashCode,The following statement contains a magic number: hashCode = (hashCode * 397) ^ this.CombineDBOpenAndDBAccess.GetHashCode();
Magic Number,DotNetSiemensPLCToolBoxLibrary.DataTypes.AWL.Step7V5,S7ConvertingOptions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\AWL\Step7V5\S7ConvertingOptions.cs,GetHashCode,The following statement contains a magic number: hashCode = (hashCode * 397) ^ this.ReplaceDBAccessesWithSymbolNames.GetHashCode();
Magic Number,DotNetSiemensPLCToolBoxLibrary.DataTypes.AWL.Step7V5,S7ConvertingOptions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\AWL\Step7V5\S7ConvertingOptions.cs,GetHashCode,The following statement contains a magic number: hashCode = (hashCode * 397) ^ this.ReplaceLokalDataAddressesWithSymbolNames.GetHashCode();
Magic Number,DotNetSiemensPLCToolBoxLibrary.DataTypes.AWL.Step7V5,S7ConvertingOptions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\AWL\Step7V5\S7ConvertingOptions.cs,GetHashCode,The following statement contains a magic number: hashCode = (hashCode * 397) ^ this.ReplaceDIAccessesWithSymbolNames.GetHashCode();
Magic Number,DotNetSiemensPLCToolBoxLibrary.DataTypes.AWL.Step7V5,S7ConvertingOptions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\AWL\Step7V5\S7ConvertingOptions.cs,GetHashCode,The following statement contains a magic number: hashCode = (hashCode * 397) ^ this.GenerateCallsfromUCs.GetHashCode();
Magic Number,DotNetSiemensPLCToolBoxLibrary.DataTypes.AWL.Step7V5,S7ConvertingOptions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\AWL\Step7V5\S7ConvertingOptions.cs,GetHashCode,The following statement contains a magic number: hashCode = (hashCode * 397) ^ this.UseInFCStoredFCsForCalls.GetHashCode();
Magic Number,DotNetSiemensPLCToolBoxLibrary.DataTypes.AWL.Step7V5,S7ConvertingOptions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\AWL\Step7V5\S7ConvertingOptions.cs,GetHashCode,The following statement contains a magic number: hashCode = (hashCode * 397) ^ this.UseFBDeclarationForInstanceDB.GetHashCode();
Magic Number,DotNetSiemensPLCToolBoxLibrary.DataTypes,ByteBitAddress,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\BitByteAddress.cs,ByteBitAddress,The following statement contains a magic number: address = address.Substring(2);
Magic Number,DotNetSiemensPLCToolBoxLibrary.DataTypes,DiagnosticEntry,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\DiagnosticEntry.cs,DiagnosticEntry,The following statement contains a magic number: _TimeStamp = libnodave.getDateTimefrom(data' 12);
Magic Number,DotNetSiemensPLCToolBoxLibrary.DataTypes,DiagnosticEntry,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\DiagnosticEntry.cs,DiagnosticEntry,The following statement contains a magic number: _id = data[0] * 256 + data[1];
Magic Number,DotNetSiemensPLCToolBoxLibrary.DataTypes,PLCBlockName,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\PLCBlockName.cs,PLCBlockName,The following statement contains a magic number: block = tmp.Substring(0' 3);
Magic Number,DotNetSiemensPLCToolBoxLibrary.DataTypes,PLCBlockName,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\PLCBlockName.cs,PLCBlockName,The following statement contains a magic number: nr = Int32.Parse(tmp.Substring(3));
Magic Number,DotNetSiemensPLCToolBoxLibrary.DataTypes,PLCBlockName,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\PLCBlockName.cs,PLCBlockName,The following statement contains a magic number: nr > 99999
Magic Number,DotNetSiemensPLCToolBoxLibrary.DataTypes,Pointer,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Pointer.cs,Pointer,The following statement contains a magic number: address = address.Substring(2);
Magic Number,DotNetSiemensPLCToolBoxLibrary.DataTypes,Pointer,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Pointer.cs,Pointer,The following statement contains a magic number: address = address.Substring(3);
Magic Number,DotNetSiemensPLCToolBoxLibrary.DataTypes.Blocks.Step5,S5FunctionBlockRow,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Blocks\Step5\S5FunctionBlockRow.cs,ToString,The following statement contains a magic number: return Label.PadRight(4) + ": ";
Magic Number,DotNetSiemensPLCToolBoxLibrary.DataTypes.Blocks.Step5,S5FunctionBlockRow,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Blocks\Step5\S5FunctionBlockRow.cs,ToString,The following statement contains a magic number: retVal += new string(' '' 6);
Magic Number,DotNetSiemensPLCToolBoxLibrary.DataTypes.Blocks.Step5,S5FunctionBlockRow,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Blocks\Step5\S5FunctionBlockRow.cs,ToString,The following statement contains a magic number: ext += "\r\n" + (" ".PadLeft(12) + myStr.Name.PadRight(5' ' ') + ": " + (myStr.Value ?? "")).PadRight(35) + akcmt;
Magic Number,DotNetSiemensPLCToolBoxLibrary.DataTypes.Blocks.Step5,S5FunctionBlockRow,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Blocks\Step5\S5FunctionBlockRow.cs,ToString,The following statement contains a magic number: ext += "\r\n" + (" ".PadLeft(12) + myStr.Name.PadRight(5' ' ') + ": " + (myStr.Value ?? "")).PadRight(35) + akcmt;
Magic Number,DotNetSiemensPLCToolBoxLibrary.DataTypes.Blocks.Step5,S5FunctionBlockRow,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Blocks\Step5\S5FunctionBlockRow.cs,ToString,The following statement contains a magic number: ext += "\r\n" + (" ".PadLeft(12) + myStr.Name.PadRight(5' ' ') + ": " + (myStr.Value ?? "")).PadRight(35) + akcmt;
Magic Number,DotNetSiemensPLCToolBoxLibrary.DataTypes.Blocks.Step5,S5FunctionBlockRow,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Blocks\Step5\S5FunctionBlockRow.cs,ToString,The following statement contains a magic number: par = "-" + SymbolTableEntry.Symbol.PadRight(10' ' ') + ("          (" + SymbolTableEntry.Operand + ")").PadRight(18' ' ') +  		              (string.IsNullOrEmpty(SymbolTableEntry.Comment) ? "" : "     //" + SymbolTableEntry.Comment);
Magic Number,DotNetSiemensPLCToolBoxLibrary.DataTypes.Blocks.Step5,S5FunctionBlockRow,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Blocks\Step5\S5FunctionBlockRow.cs,ToString,The following statement contains a magic number: par = "-" + SymbolTableEntry.Symbol.PadRight(10' ' ') + ("          (" + SymbolTableEntry.Operand + ")").PadRight(18' ' ') +  		              (string.IsNullOrEmpty(SymbolTableEntry.Comment) ? "" : "     //" + SymbolTableEntry.Comment);
Magic Number,DotNetSiemensPLCToolBoxLibrary.DataTypes.Blocks.Step5,S5FunctionBlockRow,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Blocks\Step5\S5FunctionBlockRow.cs,ToString,The following statement contains a magic number: return (retVal + Command.PadRight(6) + par).PadRight(35) + cmt + ext;
Magic Number,DotNetSiemensPLCToolBoxLibrary.DataTypes.Blocks.Step5,S5FunctionBlockRow,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Blocks\Step5\S5FunctionBlockRow.cs,ToString,The following statement contains a magic number: return (retVal + Command.PadRight(6) + par).PadRight(35) + cmt + ext;
Magic Number,DotNetSiemensPLCToolBoxLibrary.DataTypes.Blocks.Step7V5,S7DataRow,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Blocks\Step7V5\S7DataRow.cs,S7DataRow,The following statement contains a magic number: StringSize = 2;
Magic Number,DotNetSiemensPLCToolBoxLibrary.DataTypes.Blocks.Step7V5,S7DataRow,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Blocks\Step7V5\S7DataRow.cs,ToString,The following statement contains a magic number: retVal += BlockAddress.ToString().PadLeft(5' '0') + ": ";
Magic Number,DotNetSiemensPLCToolBoxLibrary.DataTypes.Blocks.Step7V5,S7FunctionBlockRow,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Blocks\Step7V5\S7FunctionBlockRow.cs,_GetCommandStatusAskSize,The following statement contains a magic number: size += 2;
Magic Number,DotNetSiemensPLCToolBoxLibrary.DataTypes.Blocks.Step7V5,S7FunctionBlockRow,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Blocks\Step7V5\S7FunctionBlockRow.cs,_GetCommandStatusAskSize,The following statement contains a magic number: size += 4;
Magic Number,DotNetSiemensPLCToolBoxLibrary.DataTypes.Blocks.Step7V5,S7FunctionBlockRow,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Blocks\Step7V5\S7FunctionBlockRow.cs,_GetCommandStatusAskSize,The following statement contains a magic number: size += 4;
Magic Number,DotNetSiemensPLCToolBoxLibrary.DataTypes.Blocks.Step7V5,S7FunctionBlockRow,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Blocks\Step7V5\S7FunctionBlockRow.cs,_GetCommandStatusAskSize,The following statement contains a magic number: size += 4;
Magic Number,DotNetSiemensPLCToolBoxLibrary.DataTypes.Blocks.Step7V5,S7FunctionBlockRow,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Blocks\Step7V5\S7FunctionBlockRow.cs,_GetCommandStatusAskSize,The following statement contains a magic number: size += 4;
Magic Number,DotNetSiemensPLCToolBoxLibrary.DataTypes.Blocks.Step7V5,S7FunctionBlockRow,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Blocks\Step7V5\S7FunctionBlockRow.cs,_GetCommandStatusAskSize,The following statement contains a magic number: size += 6;
Magic Number,DotNetSiemensPLCToolBoxLibrary.DataTypes.Blocks.Step7V5,S7FunctionBlockRow,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Blocks\Step7V5\S7FunctionBlockRow.cs,ToString,The following statement contains a magic number: retVal += new string(' '' 6);
Magic Number,DotNetSiemensPLCToolBoxLibrary.DataTypes.Blocks.Step7V5,S7FunctionBlockRow,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Blocks\Step7V5\S7FunctionBlockRow.cs,ToString,The following statement contains a magic number: ext += "\r\n" + " ".PadLeft(12) + myStr;
Magic Number,DotNetSiemensPLCToolBoxLibrary.DataTypes.Blocks.Step7V5,S7FunctionBlockRow,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Blocks\Step7V5\S7FunctionBlockRow.cs,ToString,The following statement contains a magic number: ext += "\r\n" + " ".PadLeft(12) + cpar.Name.PadRight(len) + " := " + cpar.GetValue(useSymbol);
Magic Number,DotNetSiemensPLCToolBoxLibrary.DataTypes.Blocks.Step7V5,S7FunctionBlockRow,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Blocks\Step7V5\S7FunctionBlockRow.cs,ToString,The following statement contains a magic number: par = par.PadRight(14);
Magic Number,DotNetSiemensPLCToolBoxLibrary.DataTypes.Blocks.Step7V5,S7FunctionBlockRow,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Blocks\Step7V5\S7FunctionBlockRow.cs,ToString,The following statement contains a magic number: return retVal + Command.PadRight(6) + par + (ext == "" && addSemicolonAfterCommand == true ? ";" : "") + cmt +                     ext + (ext != "" && addSemicolonAfterCommand == true ? ";" : "");
Magic Number,DotNetSiemensPLCToolBoxLibrary.DataTypes.Blocks.Step7V5,BlockStatus,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Blocks\Step7V5\S7FunctionBlockRow.cs,ReadBlockStatus,The following statement contains a magic number: pos += 2;
Magic Number,DotNetSiemensPLCToolBoxLibrary.DataTypes.Blocks.Step7V5,BlockStatus,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Blocks\Step7V5\S7FunctionBlockRow.cs,ReadBlockStatus,The following statement contains a magic number: pos += 4;
Magic Number,DotNetSiemensPLCToolBoxLibrary.DataTypes.Blocks.Step7V5,BlockStatus,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Blocks\Step7V5\S7FunctionBlockRow.cs,ReadBlockStatus,The following statement contains a magic number: pos += 4;
Magic Number,DotNetSiemensPLCToolBoxLibrary.DataTypes.Blocks.Step7V5,BlockStatus,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Blocks\Step7V5\S7FunctionBlockRow.cs,ReadBlockStatus,The following statement contains a magic number: pos += 4;
Magic Number,DotNetSiemensPLCToolBoxLibrary.DataTypes.Blocks.Step7V5,BlockStatus,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Blocks\Step7V5\S7FunctionBlockRow.cs,ReadBlockStatus,The following statement contains a magic number: pos += 4;
Magic Number,DotNetSiemensPLCToolBoxLibrary.DataTypes.Blocks.Step7V5,BlockStatus,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Blocks\Step7V5\S7FunctionBlockRow.cs,ReadBlockStatus,The following statement contains a magic number: ret.DB = libnodave.getU16from(daten' pos + 2);
Magic Number,DotNetSiemensPLCToolBoxLibrary.DataTypes.Blocks.Step7V5,BlockStatus,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Blocks\Step7V5\S7FunctionBlockRow.cs,ReadBlockStatus,The following statement contains a magic number: ret.DI = libnodave.getU16from(daten' pos + 4);
Magic Number,DotNetSiemensPLCToolBoxLibrary.DataTypes.Blocks.Step7V5,BlockStatus,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Blocks\Step7V5\S7FunctionBlockRow.cs,ReadBlockStatus,The following statement contains a magic number: pos += 6;
Magic Number,DotNetSiemensPLCToolBoxLibrary.DataTypes.Blocks.Step7V5,S7VATBlock,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Blocks\Step7V5\S7VATBlock.cs,S7VATBlock,The following statement contains a magic number: int akAddr = 36;
Magic Number,DotNetSiemensPLCToolBoxLibrary.DataTypes.Blocks.Step7V5,S7VATBlock,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Blocks\Step7V5\S7VATBlock.cs,S7VATBlock,The following statement contains a magic number: int commentsRow = 12;
Magic Number,DotNetSiemensPLCToolBoxLibrary.DataTypes.Blocks.Step7V5,S7VATBlock,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Blocks\Step7V5\S7VATBlock.cs,S7VATBlock,The following statement contains a magic number: int akLinePlus = comments[commentsRow + 2] + comments[commentsRow + 3]*0x100;
Magic Number,DotNetSiemensPLCToolBoxLibrary.DataTypes.Blocks.Step7V5,S7VATBlock,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Blocks\Step7V5\S7VATBlock.cs,S7VATBlock,The following statement contains a magic number: int akLinePlus = comments[commentsRow + 2] + comments[commentsRow + 3]*0x100;
Magic Number,DotNetSiemensPLCToolBoxLibrary.DataTypes.Blocks.Step7V5,S7VATBlock,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Blocks\Step7V5\S7VATBlock.cs,S7VATBlock,The following statement contains a magic number: akLen = comments.Length - commentsRow - 6;
Magic Number,DotNetSiemensPLCToolBoxLibrary.DataTypes.Blocks.Step7V5,S7VATBlock,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Blocks\Step7V5\S7VATBlock.cs,S7VATBlock,The following statement contains a magic number: commentsRow + 6 + akLen > comments.Length
Magic Number,DotNetSiemensPLCToolBoxLibrary.DataTypes.Blocks.Step7V5,S7VATBlock,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Blocks\Step7V5\S7VATBlock.cs,S7VATBlock,The following statement contains a magic number: VATRows[akLine].Comment = projEncoding.GetString(comments' commentsRow + 6' akLen);
Magic Number,DotNetSiemensPLCToolBoxLibrary.DataTypes.Blocks.Step7V5,S7VATBlock,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Blocks\Step7V5\S7VATBlock.cs,S7VATBlock,The following statement contains a magic number: commentsRow += 6 + akLen;
Magic Number,DotNetSiemensPLCToolBoxLibrary.DataTypes.Projectfolders,OnlineBlocksFolder,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Projectfolders\OnlineBlocksFolder.cs,readPlcBlocksList,The following statement contains a magic number: tmp.BlockNumber = Convert.ToInt32(blk.Substring(2));
Magic Number,DotNetSiemensPLCToolBoxLibrary.DataTypes.Projectfolders,OnlineBlocksFolder,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Projectfolders\OnlineBlocksFolder.cs,readPlcBlocksList,The following statement contains a magic number: blk.Substring(0' 2) == "DB"
Magic Number,DotNetSiemensPLCToolBoxLibrary.DataTypes.Projectfolders.Step5,ReferenceData,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Projectfolders\Step5\ReferenceData.cs,GetEntryFromOperand,The following statement contains a magic number: Thread.Sleep(500);
Magic Number,DotNetSiemensPLCToolBoxLibrary.DataTypes.Projectfolders.Step5,ReferenceData,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Projectfolders\Step5\ReferenceData.cs,LoadReferenceData,The following statement contains a magic number: entr.ReferencePoints.Add(new ReferencePoint() { Block = blk' Network = network' NetworkNumber = networkNR' LineNumber = rowNR' BlockRow = functionBlockRow' AccessMode = (ReferenceDataAccessMode)functionBlockRow.MC5LIB_SYMTAB_Row[9] });
Magic Number,DotNetSiemensPLCToolBoxLibrary.DataTypes.Projectfolders.Step5,ReferenceData,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Projectfolders\Step5\ReferenceData.cs,LoadReferenceData,The following statement contains a magic number: entr.ReferencePoints.Add(new ReferencePoint() { Block = blk' Network = network' NetworkNumber = networkNR' LineNumber = rowNR' BlockRow = functionBlockRow' AccessMode = (ReferenceDataAccessMode)functionBlockRow.MC5LIB_SYMTAB_Row[9] });
Magic Number,DotNetSiemensPLCToolBoxLibrary.DataTypes.Projectfolders.Step5,Step5BlocksFolder,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Projectfolders\Step5\Step5BlocksFolder.cs,GetBlockInfo,The following statement contains a magic number: nm == projectBlockInfo.BlockType.ToString().Substring(3) + projectBlockInfo.BlockNumber.ToString()
Magic Number,DotNetSiemensPLCToolBoxLibrary.DataTypes.Projectfolders.Step5,SymbolTable,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Projectfolders\Step5\SymbolTable.cs,LoadSymboltable,The following statement contains a magic number: sym.Symbol = wrt[2];
Magic Number,DotNetSiemensPLCToolBoxLibrary.DataTypes.Projectfolders.Step5,SymbolTable,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Projectfolders\Step5\SymbolTable.cs,LoadSymboltable,The following statement contains a magic number: sym.Comment = wrt[3];
Magic Number,DotNetSiemensPLCToolBoxLibrary.DataTypes.Projectfolders.Step5,SymbolTable,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Projectfolders\Step5\SymbolTable.cs,LoadSymboltable,The following statement contains a magic number: wrt.Length > 3
Magic Number,DotNetSiemensPLCToolBoxLibrary.DataTypes.Projectfolders.Step5,SymbolTable,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Projectfolders\Step5\SymbolTable.cs,LoadSymboltable,The following statement contains a magic number: wrt.Length > 2
Magic Number,DotNetSiemensPLCToolBoxLibrary.DataTypes.Projectfolders.Step7V5,BlocksOfflineFolder,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Projectfolders\Step7V5\BlocksOfflineFolder.cs,intReadPlcBlocksList,The following statement contains a magic number: (int)row["PASSWORD"] == 3
Magic Number,DotNetSiemensPLCToolBoxLibrary.DataTypes.Projectfolders.Step7V5,BlocksOfflineFolder,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Projectfolders\Step7V5\BlocksOfflineFolder.cs,intReadPlcBlocksList,The following statement contains a magic number: (int)row["OBJECTID"] == step7ProjectBlockInfo.id && (subblktyp == 12 || subblktyp == 8 || subblktyp == 14)
Magic Number,DotNetSiemensPLCToolBoxLibrary.DataTypes.Projectfolders.Step7V5,BlocksOfflineFolder,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Projectfolders\Step7V5\BlocksOfflineFolder.cs,intReadPlcBlocksList,The following statement contains a magic number: (int)row["OBJECTID"] == step7ProjectBlockInfo.id && (subblktyp == 12 || subblktyp == 8 || subblktyp == 14)
Magic Number,DotNetSiemensPLCToolBoxLibrary.DataTypes.Projectfolders.Step7V5,BlocksOfflineFolder,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Projectfolders\Step7V5\BlocksOfflineFolder.cs,intReadPlcBlocksList,The following statement contains a magic number: (int)row["OBJECTID"] == step7ProjectBlockInfo.id && (subblktyp == 12 || subblktyp == 8 || subblktyp == 14)
Magic Number,DotNetSiemensPLCToolBoxLibrary.DataTypes.Projectfolders.Step7V5,BlocksOfflineFolder,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Projectfolders\Step7V5\BlocksOfflineFolder.cs,ChangeKnowHowProtection,The following statement contains a magic number: DBF.ParseDBF.WriteValue(Folder + "SUBBLK.DBF"' "PASSWORD"' dbfTbl.Rows.IndexOf(row)' 3' ((Step7ProjectV5)Project)._ziphelper' ((Step7ProjectV5)Project)._DirSeperator);
Magic Number,DotNetSiemensPLCToolBoxLibrary.DataTypes.Projectfolders.Step7V5,BlocksOfflineFolder,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Projectfolders\Step7V5\BlocksOfflineFolder.cs,ChangeKnowHowProtection,The following statement contains a magic number: objid == blkInfo.id && (subblktype == 12 || subblktype == 8 || subblktype == 14)
Magic Number,DotNetSiemensPLCToolBoxLibrary.DataTypes.Projectfolders.Step7V5,BlocksOfflineFolder,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Projectfolders\Step7V5\BlocksOfflineFolder.cs,ChangeKnowHowProtection,The following statement contains a magic number: objid == blkInfo.id && (subblktype == 12 || subblktype == 8 || subblktype == 14)
Magic Number,DotNetSiemensPLCToolBoxLibrary.DataTypes.Projectfolders.Step7V5,BlocksOfflineFolder,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Projectfolders\Step7V5\BlocksOfflineFolder.cs,ChangeKnowHowProtection,The following statement contains a magic number: objid == blkInfo.id && (subblktype == 12 || subblktype == 8 || subblktype == 14)
Magic Number,DotNetSiemensPLCToolBoxLibrary.DataTypes.Projectfolders.Step7V5,BlocksOfflineFolder,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Projectfolders\Step7V5\BlocksOfflineFolder.cs,GetBlockBytes,The following statement contains a magic number: row["PASSWORD"] != DBNull.Value && (int)row["PASSWORD"] == 3
Magic Number,DotNetSiemensPLCToolBoxLibrary.DataTypes.Projectfolders.Step7V5,BlocksOfflineFolder,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Projectfolders\Step7V5\BlocksOfflineFolder.cs,GetBlockBytes,The following statement contains a magic number: myTmpBlk.version = (ver / 15).ToString() + "." + (ver % 15).ToString();
Magic Number,DotNetSiemensPLCToolBoxLibrary.DataTypes.Projectfolders.Step7V5,BlocksOfflineFolder,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Projectfolders\Step7V5\BlocksOfflineFolder.cs,GetBlockBytes,The following statement contains a magic number: myTmpBlk.version = (ver / 15).ToString() + "." + (ver % 15).ToString();
Magic Number,DotNetSiemensPLCToolBoxLibrary.DataTypes.Projectfolders.Step7V5,BlocksOfflineFolder,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Projectfolders\Step7V5\BlocksOfflineFolder.cs,GetBlockBytes,The following statement contains a magic number: subblktype == 12 || subblktype == 8 || subblktype == 14 || subblktype == 13 || subblktype == 15
Magic Number,DotNetSiemensPLCToolBoxLibrary.DataTypes.Projectfolders.Step7V5,BlocksOfflineFolder,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Projectfolders\Step7V5\BlocksOfflineFolder.cs,GetBlockBytes,The following statement contains a magic number: subblktype == 12 || subblktype == 8 || subblktype == 14 || subblktype == 13 || subblktype == 15
Magic Number,DotNetSiemensPLCToolBoxLibrary.DataTypes.Projectfolders.Step7V5,BlocksOfflineFolder,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Projectfolders\Step7V5\BlocksOfflineFolder.cs,GetBlockBytes,The following statement contains a magic number: subblktype == 12 || subblktype == 8 || subblktype == 14 || subblktype == 13 || subblktype == 15
Magic Number,DotNetSiemensPLCToolBoxLibrary.DataTypes.Projectfolders.Step7V5,BlocksOfflineFolder,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Projectfolders\Step7V5\BlocksOfflineFolder.cs,GetBlockBytes,The following statement contains a magic number: subblktype == 12 || subblktype == 8 || subblktype == 14 || subblktype == 13 || subblktype == 15
Magic Number,DotNetSiemensPLCToolBoxLibrary.DataTypes.Projectfolders.Step7V5,BlocksOfflineFolder,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Projectfolders\Step7V5\BlocksOfflineFolder.cs,GetBlockBytes,The following statement contains a magic number: subblktype == 12 || subblktype == 8 || subblktype == 14 || subblktype == 13 || subblktype == 15
Magic Number,DotNetSiemensPLCToolBoxLibrary.DataTypes.Projectfolders.Step7V5,BlocksOfflineFolder,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Projectfolders\Step7V5\BlocksOfflineFolder.cs,GetBlock,The following statement contains a magic number: int uPos = 2;
Magic Number,DotNetSiemensPLCToolBoxLibrary.DataTypes.Projectfolders.Step7V5,BlocksOfflineFolder,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Projectfolders\Step7V5\BlocksOfflineFolder.cs,GetTimeStamp,The following statement contains a magic number: return bytes.Length == 5                      ? Helper.GetDT((byte)bytes[0]' (byte)bytes[1]' (byte)bytes[2]' (byte)bytes[3]' (byte)bytes[4]' (byte)0)                      : Helper.GetDT((byte)bytes[0]' (byte)bytes[1]' (byte)bytes[2]' (byte)bytes[3]' (byte)bytes[4]' (byte)bytes[5]);
Magic Number,DotNetSiemensPLCToolBoxLibrary.DataTypes.Projectfolders.Step7V5,BlocksOfflineFolder,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Projectfolders\Step7V5\BlocksOfflineFolder.cs,GetTimeStamp,The following statement contains a magic number: return bytes.Length == 5                      ? Helper.GetDT((byte)bytes[0]' (byte)bytes[1]' (byte)bytes[2]' (byte)bytes[3]' (byte)bytes[4]' (byte)0)                      : Helper.GetDT((byte)bytes[0]' (byte)bytes[1]' (byte)bytes[2]' (byte)bytes[3]' (byte)bytes[4]' (byte)bytes[5]);
Magic Number,DotNetSiemensPLCToolBoxLibrary.DataTypes.Projectfolders.Step7V5,BlocksOfflineFolder,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Projectfolders\Step7V5\BlocksOfflineFolder.cs,GetTimeStamp,The following statement contains a magic number: return bytes.Length == 5                      ? Helper.GetDT((byte)bytes[0]' (byte)bytes[1]' (byte)bytes[2]' (byte)bytes[3]' (byte)bytes[4]' (byte)0)                      : Helper.GetDT((byte)bytes[0]' (byte)bytes[1]' (byte)bytes[2]' (byte)bytes[3]' (byte)bytes[4]' (byte)bytes[5]);
Magic Number,DotNetSiemensPLCToolBoxLibrary.DataTypes.Projectfolders.Step7V5,BlocksOfflineFolder,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Projectfolders\Step7V5\BlocksOfflineFolder.cs,GetTimeStamp,The following statement contains a magic number: return bytes.Length == 5                      ? Helper.GetDT((byte)bytes[0]' (byte)bytes[1]' (byte)bytes[2]' (byte)bytes[3]' (byte)bytes[4]' (byte)0)                      : Helper.GetDT((byte)bytes[0]' (byte)bytes[1]' (byte)bytes[2]' (byte)bytes[3]' (byte)bytes[4]' (byte)bytes[5]);
Magic Number,DotNetSiemensPLCToolBoxLibrary.DataTypes.Projectfolders.Step7V5,BlocksOfflineFolder,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Projectfolders\Step7V5\BlocksOfflineFolder.cs,GetTimeStamp,The following statement contains a magic number: return bytes.Length == 5                      ? Helper.GetDT((byte)bytes[0]' (byte)bytes[1]' (byte)bytes[2]' (byte)bytes[3]' (byte)bytes[4]' (byte)0)                      : Helper.GetDT((byte)bytes[0]' (byte)bytes[1]' (byte)bytes[2]' (byte)bytes[3]' (byte)bytes[4]' (byte)bytes[5]);
Magic Number,DotNetSiemensPLCToolBoxLibrary.DataTypes.Projectfolders.Step7V5,BlocksOfflineFolder,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Projectfolders\Step7V5\BlocksOfflineFolder.cs,GetTimeStamp,The following statement contains a magic number: return bytes.Length == 5                      ? Helper.GetDT((byte)bytes[0]' (byte)bytes[1]' (byte)bytes[2]' (byte)bytes[3]' (byte)bytes[4]' (byte)0)                      : Helper.GetDT((byte)bytes[0]' (byte)bytes[1]' (byte)bytes[2]' (byte)bytes[3]' (byte)bytes[4]' (byte)bytes[5]);
Magic Number,DotNetSiemensPLCToolBoxLibrary.DataTypes.Projectfolders.Step7V5,BlocksOfflineFolder,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Projectfolders\Step7V5\BlocksOfflineFolder.cs,GetTimeStamp,The following statement contains a magic number: return bytes.Length == 5                      ? Helper.GetDT((byte)bytes[0]' (byte)bytes[1]' (byte)bytes[2]' (byte)bytes[3]' (byte)bytes[4]' (byte)0)                      : Helper.GetDT((byte)bytes[0]' (byte)bytes[1]' (byte)bytes[2]' (byte)bytes[3]' (byte)bytes[4]' (byte)bytes[5]);
Magic Number,DotNetSiemensPLCToolBoxLibrary.DataTypes.Projectfolders.Step7V5,BlocksOfflineFolder,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\Projectfolders\Step7V5\BlocksOfflineFolder.cs,GetTimeStamp,The following statement contains a magic number: return bytes.Length == 5                      ? Helper.GetDT((byte)bytes[0]' (byte)bytes[1]' (byte)bytes[2]' (byte)bytes[3]' (byte)bytes[4]' (byte)0)                      : Helper.GetDT((byte)bytes[0]' (byte)bytes[1]' (byte)bytes[2]' (byte)bytes[3]' (byte)bytes[4]' (byte)bytes[5]);
Magic Number,DotNetSiemensPLCToolBoxLibrary.DBF.Index,Node,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DBF\Index\Node.cs,Node,The following statement contains a magic number: key_expression = new NodeKey[keys_in + 2];
Magic Number,DotNetSiemensPLCToolBoxLibrary.DBF.Index,Node,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DBF\Index\Node.cs,Node,The following statement contains a magic number: key_record_number = new int[keys_in + 2];
Magic Number,DotNetSiemensPLCToolBoxLibrary.DBF.Index,Node,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DBF\Index\Node.cs,Node,The following statement contains a magic number: lower_level = new int[keys_in + 2];
Magic Number,DotNetSiemensPLCToolBoxLibrary.DBF.Index,Node,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DBF\Index\Node.cs,Read,The following statement contains a magic number: nfile.BaseStream.Position = (longrecn*512);
Magic Number,DotNetSiemensPLCToolBoxLibrary.DBF.Index,Node,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DBF\Index\Node.cs,Read,The following statement contains a magic number: j = intKeyExpressionSize%4;
Magic Number,DotNetSiemensPLCToolBoxLibrary.DBF.Index,Node,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DBF\Index\Node.cs,Read,The following statement contains a magic number: j = 4 - j;
Magic Number,DotNetSiemensPLCToolBoxLibrary.DBF.Index,NodeFloat,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DBF\Index\NodeFloat.cs,NodeFloat,The following statement contains a magic number: StringBuilder sb = new StringBuilder(15);
Magic Number,DotNetSiemensPLCToolBoxLibrary.DBF.Index,NodeFloat,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DBF\Index\NodeFloat.cs,NodeFloat,The following statement contains a magic number: bValue = new byte[10];
Magic Number,DotNetSiemensPLCToolBoxLibrary.DBF.Index,NodeFloat,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DBF\Index\NodeFloat.cs,NodeFloat,The following statement contains a magic number: bValue[i] = ByteValue[i + 2];
Magic Number,DotNetSiemensPLCToolBoxLibrary.DBF.Index,NodeFloat,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DBF\Index\NodeFloat.cs,NodeFloat,The following statement contains a magic number: i < 10
Magic Number,DotNetSiemensPLCToolBoxLibrary.DBF.Index,NodeFloat,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DBF\Index\NodeFloat.cs,NodeFloat,The following statement contains a magic number: i2 >>= 4;
Magic Number,DotNetSiemensPLCToolBoxLibrary.DBF.Index,NodeFloat,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DBF\Index\NodeFloat.cs,NodeFloat,The following statement contains a magic number: i2 += 8;
Magic Number,DotNetSiemensPLCToolBoxLibrary.DBF.Index,NodeFloat,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DBF\Index\NodeFloat.cs,NodeFloat,The following statement contains a magic number: i == 2
Magic Number,DotNetSiemensPLCToolBoxLibrary.DBF.Index,NodeFloat,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DBF\Index\NodeFloat.cs,NodeFloat,The following statement contains a magic number: this.bValue = new byte[10];
Magic Number,DotNetSiemensPLCToolBoxLibrary.DBF.Index,NodeFloat,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DBF\Index\NodeFloat.cs,NodeFloat,The following statement contains a magic number: i < 10
Magic Number,DotNetSiemensPLCToolBoxLibrary.DBF.Index,NodeFloat,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DBF\Index\NodeFloat.cs,NodeFloat,The following statement contains a magic number: i < s.Length && j < 10
Magic Number,DotNetSiemensPLCToolBoxLibrary.DBF.Index,NodeFloat,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DBF\Index\NodeFloat.cs,CompareTo,The following statement contains a magic number: i < 10
Magic Number,DotNetSiemensPLCToolBoxLibrary.DBF.Index,NodeKey,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DBF\Index\NodeKey.cs,RebuildString,The following statement contains a magic number: a[i] = (char) 31;
Magic Number,DotNetSiemensPLCToolBoxLibrary.DBF.Index.MDX,MDX,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DBF\Index\MDX\MDX.cs,Read,The following statement contains a magic number: this.objTagHeader = MDXTagHeader.Read(Reader' this.objTagDescription.tagHeaderPageNumber*512);
Magic Number,DotNetSiemensPLCToolBoxLibrary.DBF.Index.MDX,MNode,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DBF\Index\MDX\MNode.cs,Read,The following statement contains a magic number: Reader.BaseStream.Position = (longrecn*512);
Magic Number,DotNetSiemensPLCToolBoxLibrary.DBF.Index.MDX,MNode,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DBF\Index\MDX\MNode.cs,Read,The following statement contains a magic number: byte[] b = new byte[12];
Magic Number,DotNetSiemensPLCToolBoxLibrary.DBF.Index.MDX,MNode,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DBF\Index\MDX\MNode.cs,Read,The following statement contains a magic number: j = intKeyExpressionSize%4;
Magic Number,DotNetSiemensPLCToolBoxLibrary.DBF.Index.MDX,MNode,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DBF\Index\MDX\MNode.cs,Read,The following statement contains a magic number: j = 4 - j;
Magic Number,DotNetSiemensPLCToolBoxLibrary.DBF,ParseDBF,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DBF\ParseDBF.cs,ReadDBF,The following statement contains a magic number: (13 != br.PeekChar())
Magic Number,DotNetSiemensPLCToolBoxLibrary.DBF,ParseDBF,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DBF\ParseDBF.cs,ReadDBF,The following statement contains a magic number: switch (field.fieldType)                          {                              case dBaseType.N:  // Number                                  byte[] NumberBytes = recReader.ReadBytes(field.fieldLen);                                  if (dBaseConverter.N_IsDecimal(NumberBytes)) {                                      row[fieldIndex + 1] = dBaseConverter.N_ToDecimal(NumberBytes);                                  } else {                                      row[fieldIndex + 1] = dBaseConverter.N_ToInt(NumberBytes);                                  }                                  break;                                case dBaseType.C: // String  							    row[fieldIndex + 1] = dBaseConverter.C_ToString( recReader.ReadBytes(field.fieldLen)' encoding);  								break;                                case dBaseType.M: // Memo                                  row[fieldIndex + 1] = ReadMemoBlock(dBaseConverter.N_ToInt(recReader.ReadBytes(field.fieldLen)));                                  break;                                case dBaseType.D: // Date (YYYYMMDD)                                  DateTime DTFromFile = dBaseConverter.D_ToDateTime(recReader.ReadBytes(8));                                  if (DTFromFile == DateTime.MinValue) {                                      row[fieldIndex + 1] = System.DBNull.Value;                                  } else {                                      row[fieldIndex] = DTFromFile;                                  }                                  break;                                case dBaseType.T:                                  row[fieldIndex + 1] = dBaseConverter.T_ToDateTime(recReader.ReadBytes(8));                                  break;                                case dBaseType.L: // Boolean (Y/N)                                  row[fieldIndex + 1] = dBaseConverter.L_ToBool(recReader.ReadByte());                                  break;                                case dBaseType.F:                                  row[fieldIndex + 1] = dBaseConverter.F_ToDouble(recReader.ReadBytes(field.fieldLen));                                  break;                          }
Magic Number,DotNetSiemensPLCToolBoxLibrary.DBF,ParseDBF,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DBF\ParseDBF.cs,ReadDBF,The following statement contains a magic number: switch (field.fieldType)                          {                              case dBaseType.N:  // Number                                  byte[] NumberBytes = recReader.ReadBytes(field.fieldLen);                                  if (dBaseConverter.N_IsDecimal(NumberBytes)) {                                      row[fieldIndex + 1] = dBaseConverter.N_ToDecimal(NumberBytes);                                  } else {                                      row[fieldIndex + 1] = dBaseConverter.N_ToInt(NumberBytes);                                  }                                  break;                                case dBaseType.C: // String  							    row[fieldIndex + 1] = dBaseConverter.C_ToString( recReader.ReadBytes(field.fieldLen)' encoding);  								break;                                case dBaseType.M: // Memo                                  row[fieldIndex + 1] = ReadMemoBlock(dBaseConverter.N_ToInt(recReader.ReadBytes(field.fieldLen)));                                  break;                                case dBaseType.D: // Date (YYYYMMDD)                                  DateTime DTFromFile = dBaseConverter.D_ToDateTime(recReader.ReadBytes(8));                                  if (DTFromFile == DateTime.MinValue) {                                      row[fieldIndex + 1] = System.DBNull.Value;                                  } else {                                      row[fieldIndex] = DTFromFile;                                  }                                  break;                                case dBaseType.T:                                  row[fieldIndex + 1] = dBaseConverter.T_ToDateTime(recReader.ReadBytes(8));                                  break;                                case dBaseType.L: // Boolean (Y/N)                                  row[fieldIndex + 1] = dBaseConverter.L_ToBool(recReader.ReadByte());                                  break;                                case dBaseType.F:                                  row[fieldIndex + 1] = dBaseConverter.F_ToDouble(recReader.ReadBytes(field.fieldLen));                                  break;                          }
Magic Number,DotNetSiemensPLCToolBoxLibrary.DBF,ParseDBF,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DBF\ParseDBF.cs,WriteValue,The following statement contains a magic number: (13 != br.PeekChar())
Magic Number,DotNetSiemensPLCToolBoxLibrary.DBF,Util,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DBF\Util.cs,DoubleDate,The following statement contains a magic number: return 1e100;
Magic Number,DotNetSiemensPLCToolBoxLibrary.DBF,Util,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DBF\Util.cs,DoubleDate,The following statement contains a magic number: int year = int.Parse(s.Substring(0' 4));
Magic Number,DotNetSiemensPLCToolBoxLibrary.DBF,Util,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DBF\Util.cs,DoubleDate,The following statement contains a magic number: return 1e100;
Magic Number,DotNetSiemensPLCToolBoxLibrary.DBF,Util,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DBF\Util.cs,DoubleDate,The following statement contains a magic number: int[] days = {0' 31' 28' 31' 30' 31' 30' 31' 31' 30' 31' 30' 31};
Magic Number,DotNetSiemensPLCToolBoxLibrary.DBF,Util,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DBF\Util.cs,DoubleDate,The following statement contains a magic number: int[] days = {0' 31' 28' 31' 30' 31' 30' 31' 31' 30' 31' 30' 31};
Magic Number,DotNetSiemensPLCToolBoxLibrary.DBF,Util,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DBF\Util.cs,DoubleDate,The following statement contains a magic number: int[] days = {0' 31' 28' 31' 30' 31' 30' 31' 31' 30' 31' 30' 31};
Magic Number,DotNetSiemensPLCToolBoxLibrary.DBF,Util,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DBF\Util.cs,DoubleDate,The following statement contains a magic number: int[] days = {0' 31' 28' 31' 30' 31' 30' 31' 31' 30' 31' 30' 31};
Magic Number,DotNetSiemensPLCToolBoxLibrary.DBF,Util,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DBF\Util.cs,DoubleDate,The following statement contains a magic number: int[] days = {0' 31' 28' 31' 30' 31' 30' 31' 31' 30' 31' 30' 31};
Magic Number,DotNetSiemensPLCToolBoxLibrary.DBF,Util,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DBF\Util.cs,DoubleDate,The following statement contains a magic number: int[] days = {0' 31' 28' 31' 30' 31' 30' 31' 31' 30' 31' 30' 31};
Magic Number,DotNetSiemensPLCToolBoxLibrary.DBF,Util,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DBF\Util.cs,DoubleDate,The following statement contains a magic number: int[] days = {0' 31' 28' 31' 30' 31' 30' 31' 31' 30' 31' 30' 31};
Magic Number,DotNetSiemensPLCToolBoxLibrary.DBF,Util,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DBF\Util.cs,DoubleDate,The following statement contains a magic number: int[] days = {0' 31' 28' 31' 30' 31' 30' 31' 31' 30' 31' 30' 31};
Magic Number,DotNetSiemensPLCToolBoxLibrary.DBF,Util,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DBF\Util.cs,DoubleDate,The following statement contains a magic number: int[] days = {0' 31' 28' 31' 30' 31' 30' 31' 31' 30' 31' 30' 31};
Magic Number,DotNetSiemensPLCToolBoxLibrary.DBF,Util,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DBF\Util.cs,DoubleDate,The following statement contains a magic number: int[] days = {0' 31' 28' 31' 30' 31' 30' 31' 31' 30' 31' 30' 31};
Magic Number,DotNetSiemensPLCToolBoxLibrary.DBF,Util,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DBF\Util.cs,DoubleDate,The following statement contains a magic number: int[] days = {0' 31' 28' 31' 30' 31' 30' 31' 31' 30' 31' 30' 31};
Magic Number,DotNetSiemensPLCToolBoxLibrary.DBF,Util,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DBF\Util.cs,DoubleDate,The following statement contains a magic number: int[] days = {0' 31' 28' 31' 30' 31' 30' 31' 31' 30' 31' 30' 31};
Magic Number,DotNetSiemensPLCToolBoxLibrary.DBF,Util,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DBF\Util.cs,DoubleDate,The following statement contains a magic number: int month = int.Parse(s.Substring(4' 6));
Magic Number,DotNetSiemensPLCToolBoxLibrary.DBF,Util,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DBF\Util.cs,DoubleDate,The following statement contains a magic number: int month = int.Parse(s.Substring(4' 6));
Magic Number,DotNetSiemensPLCToolBoxLibrary.DBF,Util,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DBF\Util.cs,DoubleDate,The following statement contains a magic number: int day = int.Parse(s.Substring(6' 8));
Magic Number,DotNetSiemensPLCToolBoxLibrary.DBF,Util,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DBF\Util.cs,DoubleDate,The following statement contains a magic number: int day = int.Parse(s.Substring(6' 8));
Magic Number,DotNetSiemensPLCToolBoxLibrary.DBF,Util,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DBF\Util.cs,DoubleDate,The following statement contains a magic number: int daydif = 2378497;
Magic Number,DotNetSiemensPLCToolBoxLibrary.DBF,Util,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DBF\Util.cs,DoubleDate,The following statement contains a magic number: days[2] = 29;
Magic Number,DotNetSiemensPLCToolBoxLibrary.DBF,Util,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DBF\Util.cs,DoubleDate,The following statement contains a magic number: days[2] = 29;
Magic Number,DotNetSiemensPLCToolBoxLibrary.DBF,Util,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DBF\Util.cs,DoubleDate,The following statement contains a magic number: (year/4) == 0
Magic Number,DotNetSiemensPLCToolBoxLibrary.DBF,Util,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DBF\Util.cs,DoubleDate,The following statement contains a magic number: daydif += (year - 1800)*365;
Magic Number,DotNetSiemensPLCToolBoxLibrary.DBF,Util,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DBF\Util.cs,DoubleDate,The following statement contains a magic number: daydif += (year - 1800)*365;
Magic Number,DotNetSiemensPLCToolBoxLibrary.DBF,Util,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DBF\Util.cs,DoubleDate,The following statement contains a magic number: daydif += ((year - 1800)/4);
Magic Number,DotNetSiemensPLCToolBoxLibrary.DBF,Util,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DBF\Util.cs,DoubleDate,The following statement contains a magic number: daydif += ((year - 1800)/4);
Magic Number,DotNetSiemensPLCToolBoxLibrary.DBF,Util,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DBF\Util.cs,DoubleDate,The following statement contains a magic number: daydif -= ((year - 1800)%100);
Magic Number,DotNetSiemensPLCToolBoxLibrary.DBF,Util,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DBF\Util.cs,DoubleDate,The following statement contains a magic number: daydif -= ((year - 1800)%100);
Magic Number,DotNetSiemensPLCToolBoxLibrary.DBF,Util,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DBF\Util.cs,DoubleDate,The following statement contains a magic number: year > 1999
Magic Number,DotNetSiemensPLCToolBoxLibrary.DBF,Util,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DBF\Util.cs,DoubleDate,The following statement contains a magic number: year > 1799
Magic Number,DotNetSiemensPLCToolBoxLibrary.DBF,dBaseConverter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DBF\Util.cs,F_FromDouble,The following statement contains a magic number: DoubleString = DoubleString.PadRight(20);
Magic Number,DotNetSiemensPLCToolBoxLibrary.DBF,dBaseConverter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DBF\Util.cs,F_FromDouble,The following statement contains a magic number: DoubleString.Length > 20
Magic Number,DotNetSiemensPLCToolBoxLibrary.DBF,dBaseConverter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DBF\Util.cs,T_ToDateTime,The following statement contains a magic number: long lTime = BitConverter.ToInt32(dBaseTimeBytes' 4);
Magic Number,DotNetSiemensPLCToolBoxLibrary.DBF,dBaseConverter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DBF\Util.cs,D_ToDateTime,The following statement contains a magic number: string sYear = DateTimeString.Substring(0' 4);
Magic Number,DotNetSiemensPLCToolBoxLibrary.DBF,dBaseConverter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DBF\Util.cs,D_ToDateTime,The following statement contains a magic number: string sMonth = DateTimeString.Substring(4' 2);
Magic Number,DotNetSiemensPLCToolBoxLibrary.DBF,dBaseConverter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DBF\Util.cs,D_ToDateTime,The following statement contains a magic number: string sMonth = DateTimeString.Substring(4' 2);
Magic Number,DotNetSiemensPLCToolBoxLibrary.DBF,dBaseConverter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DBF\Util.cs,D_ToDateTime,The following statement contains a magic number: string sDay = DateTimeString.Substring(6' 2);
Magic Number,DotNetSiemensPLCToolBoxLibrary.DBF,dBaseConverter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DBF\Util.cs,D_ToDateTime,The following statement contains a magic number: string sDay = DateTimeString.Substring(6' 2);
Magic Number,DotNetSiemensPLCToolBoxLibrary.DBF,dBaseConverter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DBF\Util.cs,D_ToDateTime,The following statement contains a magic number: iYear > 1900
Magic Number,DotNetSiemensPLCToolBoxLibrary.DBF,dBaseConverter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DBF\Util.cs,JulianToDateTime,The following statement contains a magic number: double s1 = p + 68569;
Magic Number,DotNetSiemensPLCToolBoxLibrary.DBF,dBaseConverter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DBF\Util.cs,JulianToDateTime,The following statement contains a magic number: double n = Math.Floor(4*s1/146097);
Magic Number,DotNetSiemensPLCToolBoxLibrary.DBF,dBaseConverter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DBF\Util.cs,JulianToDateTime,The following statement contains a magic number: double n = Math.Floor(4*s1/146097);
Magic Number,DotNetSiemensPLCToolBoxLibrary.DBF,dBaseConverter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DBF\Util.cs,JulianToDateTime,The following statement contains a magic number: double s2 = s1 - Math.Floor((146097*n + 3)/4);
Magic Number,DotNetSiemensPLCToolBoxLibrary.DBF,dBaseConverter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DBF\Util.cs,JulianToDateTime,The following statement contains a magic number: double s2 = s1 - Math.Floor((146097*n + 3)/4);
Magic Number,DotNetSiemensPLCToolBoxLibrary.DBF,dBaseConverter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DBF\Util.cs,JulianToDateTime,The following statement contains a magic number: double s2 = s1 - Math.Floor((146097*n + 3)/4);
Magic Number,DotNetSiemensPLCToolBoxLibrary.DBF,dBaseConverter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DBF\Util.cs,JulianToDateTime,The following statement contains a magic number: double i = Math.Floor(4000*(s2 + 1)/1461001);
Magic Number,DotNetSiemensPLCToolBoxLibrary.DBF,dBaseConverter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DBF\Util.cs,JulianToDateTime,The following statement contains a magic number: double i = Math.Floor(4000*(s2 + 1)/1461001);
Magic Number,DotNetSiemensPLCToolBoxLibrary.DBF,dBaseConverter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DBF\Util.cs,JulianToDateTime,The following statement contains a magic number: double s3 = s2 - Math.Floor(1461*i/4) + 31;
Magic Number,DotNetSiemensPLCToolBoxLibrary.DBF,dBaseConverter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DBF\Util.cs,JulianToDateTime,The following statement contains a magic number: double s3 = s2 - Math.Floor(1461*i/4) + 31;
Magic Number,DotNetSiemensPLCToolBoxLibrary.DBF,dBaseConverter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DBF\Util.cs,JulianToDateTime,The following statement contains a magic number: double s3 = s2 - Math.Floor(1461*i/4) + 31;
Magic Number,DotNetSiemensPLCToolBoxLibrary.DBF,dBaseConverter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DBF\Util.cs,JulianToDateTime,The following statement contains a magic number: double q = Math.Floor(80*s3/2447);
Magic Number,DotNetSiemensPLCToolBoxLibrary.DBF,dBaseConverter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DBF\Util.cs,JulianToDateTime,The following statement contains a magic number: double q = Math.Floor(80*s3/2447);
Magic Number,DotNetSiemensPLCToolBoxLibrary.DBF,dBaseConverter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DBF\Util.cs,JulianToDateTime,The following statement contains a magic number: double d = s3 - Math.Floor(2447*q/80);
Magic Number,DotNetSiemensPLCToolBoxLibrary.DBF,dBaseConverter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DBF\Util.cs,JulianToDateTime,The following statement contains a magic number: double d = s3 - Math.Floor(2447*q/80);
Magic Number,DotNetSiemensPLCToolBoxLibrary.DBF,dBaseConverter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DBF\Util.cs,JulianToDateTime,The following statement contains a magic number: double s4 = Math.Floor(q/11);
Magic Number,DotNetSiemensPLCToolBoxLibrary.DBF,dBaseConverter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DBF\Util.cs,JulianToDateTime,The following statement contains a magic number: double m = q + 2 - 12*s4;
Magic Number,DotNetSiemensPLCToolBoxLibrary.DBF,dBaseConverter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DBF\Util.cs,JulianToDateTime,The following statement contains a magic number: double m = q + 2 - 12*s4;
Magic Number,DotNetSiemensPLCToolBoxLibrary.DBF,dBaseConverter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DBF\Util.cs,JulianToDateTime,The following statement contains a magic number: double j = 100*(n - 49) + i + s4;
Magic Number,DotNetSiemensPLCToolBoxLibrary.DBF,dBaseConverter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DBF\Util.cs,JulianToDateTime,The following statement contains a magic number: double j = 100*(n - 49) + i + s4;
Magic Number,DotNetSiemensPLCToolBoxLibrary.General,CrcHelper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\General\CrcHelper.cs,GetAccesKeyForSymbolTabelEntry,The following statement contains a magic number: retVal += CrcHelper.GetCrc32(Encoding.ASCII.GetBytes(name)).ToString("X").PadLeft(8' '0');
Magic Number,DotNetSiemensPLCToolBoxLibrary.General,CrcHelper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\General\CrcHelper.cs,GetAccesKeyForSymbolTabelEntry,The following statement contains a magic number: retVal += "4" + litId.ToString("X").PadLeft(7' '0');
Magic Number,DotNetSiemensPLCToolBoxLibrary.General,CrcHelper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\General\CrcHelper.cs,GetCrc32,The following statement contains a magic number: j < 8
Magic Number,DotNetSiemensPLCToolBoxLibrary.General,CrcHelper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\General\CrcHelper.cs,GetCrc16,The following statement contains a magic number: j < 8
Magic Number,DotNetSiemensPLCToolBoxLibrary.General,SingleExtensions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\General\SingleExtensions.cs,ToEngineering,The following statement contains a magic number: int exp = (int)(Math.Floor(Math.Log10(value) / 3.0) * 3.0);
Magic Number,DotNetSiemensPLCToolBoxLibrary.General,SingleExtensions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\General\SingleExtensions.cs,ToEngineering,The following statement contains a magic number: int exp = (int)(Math.Floor(Math.Log10(value) / 3.0) * 3.0);
Magic Number,DotNetSiemensPLCToolBoxLibrary.General,SingleExtensions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\General\SingleExtensions.cs,ToEngineering,The following statement contains a magic number: double newValue = value * Math.Pow(10.0' -exp);
Magic Number,DotNetSiemensPLCToolBoxLibrary.General,SingleExtensions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\General\SingleExtensions.cs,ToEngineering,The following statement contains a magic number: newValue = newValue / 1000.0;
Magic Number,DotNetSiemensPLCToolBoxLibrary.General,SingleExtensions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\General\SingleExtensions.cs,ToEngineering,The following statement contains a magic number: exp = exp + 3;
Magic Number,DotNetSiemensPLCToolBoxLibrary.General,SingleExtensions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\General\SingleExtensions.cs,ToEngineering,The following statement contains a magic number: newValue >= 1000.0
Magic Number,DotNetSiemensPLCToolBoxLibrary.General,SingleExtensions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\General\SingleExtensions.cs,ToS5,The following statement contains a magic number: double wrt = value * 10000000;
Magic Number,DotNetSiemensPLCToolBoxLibrary.General,SingleExtensions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\General\SingleExtensions.cs,ToS5,The following statement contains a magic number: int exp = (int)(Math.Floor(Math.Log10(wrt) / 3.0) * 3.0);
Magic Number,DotNetSiemensPLCToolBoxLibrary.General,SingleExtensions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\General\SingleExtensions.cs,ToS5,The following statement contains a magic number: int exp = (int)(Math.Floor(Math.Log10(wrt) / 3.0) * 3.0);
Magic Number,DotNetSiemensPLCToolBoxLibrary.General,SingleExtensions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\General\SingleExtensions.cs,ToS5,The following statement contains a magic number: double newValue = wrt * Math.Pow(10.0' -exp);
Magic Number,DotNetSiemensPLCToolBoxLibrary.General,SingleExtensions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\General\SingleExtensions.cs,ToS5,The following statement contains a magic number: newValue = newValue * 1000000.0;
Magic Number,DotNetSiemensPLCToolBoxLibrary.General,SingleExtensions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\General\SingleExtensions.cs,ToS5,The following statement contains a magic number: exp = exp - 6;
Magic Number,DotNetSiemensPLCToolBoxLibrary.General,SingleExtensions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\General\SingleExtensions.cs,ToS5,The following statement contains a magic number: newValue < 1000000.0
Magic Number,DotNetSiemensPLCToolBoxLibrary.General,SingleExtensions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\General\SingleExtensions.cs,ToS5,The following statement contains a magic number: newValue = newValue / 10.0;
Magic Number,DotNetSiemensPLCToolBoxLibrary.General,SingleExtensions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\General\SingleExtensions.cs,ToS5,The following statement contains a magic number: newValue > 10000000.0
Magic Number,DotNetSiemensPLCToolBoxLibrary.General,StringExtensions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\General\StringExtensions.cs,ToByteArray,The following statement contains a magic number: hex.Length % 2 == 1
Magic Number,DotNetSiemensPLCToolBoxLibrary.General,StringExtensions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\General\StringExtensions.cs,ToByteArray,The following statement contains a magic number: var tmp1 = (GetHexVal(hex[i << 1]) << 4);
Magic Number,DotNetSiemensPLCToolBoxLibrary.General,StringExtensions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\General\StringExtensions.cs,ToByteArray,The following statement contains a magic number: arr[i] = (byte)((GetHexVal(hex[i << 1]) << 4) + (GetHexVal(hex[(i << 1) + 1])));
Magic Number,DotNetSiemensPLCToolBoxLibrary.General,StringExtensions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\General\StringExtensions.cs,GetHexVal,The following statement contains a magic number: return val - (val < 58 ? 48 : 55);
Magic Number,DotNetSiemensPLCToolBoxLibrary.General,StringExtensions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\General\StringExtensions.cs,GetHexVal,The following statement contains a magic number: return val - (val < 58 ? 48 : 55);
Magic Number,DotNetSiemensPLCToolBoxLibrary.General,StringExtensions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\General\StringExtensions.cs,GetHexVal,The following statement contains a magic number: return val - (val < 58 ? 48 : 55);
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S5.MC5,MC5toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S5\MC5\MC5toAWL.cs,GetFunctionBlock,The following statement contains a magic number: retVal.AWLCode = GetMC5Rows(block' 10' null' (Step5BlocksFolder)blkInfo.ParentFolder' retVal);
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S5.MC5,MC5toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S5\MC5\MC5toAWL.cs,GetFunctionBlock,The following statement contains a magic number: int nr = 26;
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S5.MC5,MC5toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S5\MC5\MC5toAWL.cs,GetFunctionBlock,The following statement contains a magic number: int len = 0x7f & commentBlock[nr + 2];
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S5.MC5,MC5toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S5\MC5\MC5toAWL.cs,GetFunctionBlock,The following statement contains a magic number: string cmt = System.Text.Encoding.GetEncoding("ISO-8859-1").GetString(commentBlock' nr + 3' len);
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S5.MC5,MC5toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S5\MC5\MC5toAWL.cs,GetFunctionBlock,The following statement contains a magic number: nr += len + 3;
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S5.MC5,MC5toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S5\MC5\MC5toAWL.cs,GetFunctionBlock,The following statement contains a magic number: nr + 3 < commentBlock.Length
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S5.MC5,MC5toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S5\MC5\MC5toAWL.cs,GetParameters,The following statement contains a magic number: int index = find_mc5_code(code' 10);
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S5.MC5,MC5toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S5\MC5\MC5toAWL.cs,GetParameters,The following statement contains a magic number: int spa = find_mc5_param(code' 10' index);
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S5.MC5,MC5toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S5\MC5\MC5toAWL.cs,GetParameters,The following statement contains a magic number: int paranz = (spa - 5) / 3;
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S5.MC5,MC5toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S5\MC5\MC5toAWL.cs,GetParameters,The following statement contains a magic number: int paranz = (spa - 5) / 3;
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S5.MC5,MC5toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S5\MC5\MC5toAWL.cs,GetParameters,The following statement contains a magic number: int t1 = code[n * 6 + 20];
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S5.MC5,MC5toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S5\MC5\MC5toAWL.cs,GetParameters,The following statement contains a magic number: int t1 = code[n * 6 + 20];
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S5.MC5,MC5toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S5\MC5\MC5toAWL.cs,GetParameters,The following statement contains a magic number: switch (t1)                  {                      case 2:                          tmp.S5ParameterType = S5ParameterType.E;                          break;                      case 4:                          tmp.S5ParameterType = S5ParameterType.D;                          break;                      case 5:                          tmp.S5ParameterType = S5ParameterType.T;                          break;                      case 7:                          tmp.S5ParameterType = S5ParameterType.B;                          break;                      case 8:                          tmp.S5ParameterType = S5ParameterType.A;                          break;                  }
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S5.MC5,MC5toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S5\MC5\MC5toAWL.cs,GetParameters,The following statement contains a magic number: switch (t1)                  {                      case 2:                          tmp.S5ParameterType = S5ParameterType.E;                          break;                      case 4:                          tmp.S5ParameterType = S5ParameterType.D;                          break;                      case 5:                          tmp.S5ParameterType = S5ParameterType.T;                          break;                      case 7:                          tmp.S5ParameterType = S5ParameterType.B;                          break;                      case 8:                          tmp.S5ParameterType = S5ParameterType.A;                          break;                  }
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S5.MC5,MC5toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S5\MC5\MC5toAWL.cs,GetParameters,The following statement contains a magic number: switch (t1)                  {                      case 2:                          tmp.S5ParameterType = S5ParameterType.E;                          break;                      case 4:                          tmp.S5ParameterType = S5ParameterType.D;                          break;                      case 5:                          tmp.S5ParameterType = S5ParameterType.T;                          break;                      case 7:                          tmp.S5ParameterType = S5ParameterType.B;                          break;                      case 8:                          tmp.S5ParameterType = S5ParameterType.A;                          break;                  }
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S5.MC5,MC5toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S5\MC5\MC5toAWL.cs,GetParameters,The following statement contains a magic number: switch (t1)                  {                      case 2:                          tmp.S5ParameterType = S5ParameterType.E;                          break;                      case 4:                          tmp.S5ParameterType = S5ParameterType.D;                          break;                      case 5:                          tmp.S5ParameterType = S5ParameterType.T;                          break;                      case 7:                          tmp.S5ParameterType = S5ParameterType.B;                          break;                      case 8:                          tmp.S5ParameterType = S5ParameterType.A;                          break;                  }
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S5.MC5,MC5toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S5\MC5\MC5toAWL.cs,GetParameters,The following statement contains a magic number: switch (t1)                  {                      case 2:                          tmp.S5ParameterType = S5ParameterType.E;                          break;                      case 4:                          tmp.S5ParameterType = S5ParameterType.D;                          break;                      case 5:                          tmp.S5ParameterType = S5ParameterType.T;                          break;                      case 7:                          tmp.S5ParameterType = S5ParameterType.B;                          break;                      case 8:                          tmp.S5ParameterType = S5ParameterType.A;                          break;                  }
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S5.MC5,MC5toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S5\MC5\MC5toAWL.cs,GetParameters,The following statement contains a magic number: int t2 = code[n * 6 + 21];
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S5.MC5,MC5toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S5\MC5\MC5toAWL.cs,GetParameters,The following statement contains a magic number: int t2 = code[n * 6 + 21];
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S5.MC5,MC5toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S5\MC5\MC5toAWL.cs,GetParameters,The following statement contains a magic number: switch (t2)                      {                          case 1:                              tmp.S5ParameterFormat = S5ParameterFormat.KZ;                              break;                          case 2:                              tmp.S5ParameterFormat = S5ParameterFormat.KT;                              break;                          case 4:                              tmp.S5ParameterFormat = S5ParameterFormat.KF;                              break;                          case 8:                              tmp.S5ParameterFormat = S5ParameterFormat.KG;                              break;                          case 16:                              tmp.S5ParameterFormat = S5ParameterFormat.KC;                              break;                          case 32:                              tmp.S5ParameterFormat = S5ParameterFormat.KY;                              break;                          case 64:                              tmp.S5ParameterFormat = S5ParameterFormat.KH;                              break;                          case 128:                              tmp.S5ParameterFormat = S5ParameterFormat.KM;                              break;                      }
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S5.MC5,MC5toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S5\MC5\MC5toAWL.cs,GetParameters,The following statement contains a magic number: switch (t2)                      {                          case 1:                              tmp.S5ParameterFormat = S5ParameterFormat.KZ;                              break;                          case 2:                              tmp.S5ParameterFormat = S5ParameterFormat.KT;                              break;                          case 4:                              tmp.S5ParameterFormat = S5ParameterFormat.KF;                              break;                          case 8:                              tmp.S5ParameterFormat = S5ParameterFormat.KG;                              break;                          case 16:                              tmp.S5ParameterFormat = S5ParameterFormat.KC;                              break;                          case 32:                              tmp.S5ParameterFormat = S5ParameterFormat.KY;                              break;                          case 64:                              tmp.S5ParameterFormat = S5ParameterFormat.KH;                              break;                          case 128:                              tmp.S5ParameterFormat = S5ParameterFormat.KM;                              break;                      }
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S5.MC5,MC5toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S5\MC5\MC5toAWL.cs,GetParameters,The following statement contains a magic number: switch (t2)                      {                          case 1:                              tmp.S5ParameterFormat = S5ParameterFormat.KZ;                              break;                          case 2:                              tmp.S5ParameterFormat = S5ParameterFormat.KT;                              break;                          case 4:                              tmp.S5ParameterFormat = S5ParameterFormat.KF;                              break;                          case 8:                              tmp.S5ParameterFormat = S5ParameterFormat.KG;                              break;                          case 16:                              tmp.S5ParameterFormat = S5ParameterFormat.KC;                              break;                          case 32:                              tmp.S5ParameterFormat = S5ParameterFormat.KY;                              break;                          case 64:                              tmp.S5ParameterFormat = S5ParameterFormat.KH;                              break;                          case 128:                              tmp.S5ParameterFormat = S5ParameterFormat.KM;                              break;                      }
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S5.MC5,MC5toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S5\MC5\MC5toAWL.cs,GetParameters,The following statement contains a magic number: switch (t2)                      {                          case 1:                              tmp.S5ParameterFormat = S5ParameterFormat.KZ;                              break;                          case 2:                              tmp.S5ParameterFormat = S5ParameterFormat.KT;                              break;                          case 4:                              tmp.S5ParameterFormat = S5ParameterFormat.KF;                              break;                          case 8:                              tmp.S5ParameterFormat = S5ParameterFormat.KG;                              break;                          case 16:                              tmp.S5ParameterFormat = S5ParameterFormat.KC;                              break;                          case 32:                              tmp.S5ParameterFormat = S5ParameterFormat.KY;                              break;                          case 64:                              tmp.S5ParameterFormat = S5ParameterFormat.KH;                              break;                          case 128:                              tmp.S5ParameterFormat = S5ParameterFormat.KM;                              break;                      }
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S5.MC5,MC5toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S5\MC5\MC5toAWL.cs,GetParameters,The following statement contains a magic number: switch (t2)                      {                          case 1:                              tmp.S5ParameterFormat = S5ParameterFormat.KZ;                              break;                          case 2:                              tmp.S5ParameterFormat = S5ParameterFormat.KT;                              break;                          case 4:                              tmp.S5ParameterFormat = S5ParameterFormat.KF;                              break;                          case 8:                              tmp.S5ParameterFormat = S5ParameterFormat.KG;                              break;                          case 16:                              tmp.S5ParameterFormat = S5ParameterFormat.KC;                              break;                          case 32:                              tmp.S5ParameterFormat = S5ParameterFormat.KY;                              break;                          case 64:                              tmp.S5ParameterFormat = S5ParameterFormat.KH;                              break;                          case 128:                              tmp.S5ParameterFormat = S5ParameterFormat.KM;                              break;                      }
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S5.MC5,MC5toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S5\MC5\MC5toAWL.cs,GetParameters,The following statement contains a magic number: switch (t2)                      {                          case 1:                              tmp.S5ParameterFormat = S5ParameterFormat.KZ;                              break;                          case 2:                              tmp.S5ParameterFormat = S5ParameterFormat.KT;                              break;                          case 4:                              tmp.S5ParameterFormat = S5ParameterFormat.KF;                              break;                          case 8:                              tmp.S5ParameterFormat = S5ParameterFormat.KG;                              break;                          case 16:                              tmp.S5ParameterFormat = S5ParameterFormat.KC;                              break;                          case 32:                              tmp.S5ParameterFormat = S5ParameterFormat.KY;                              break;                          case 64:                              tmp.S5ParameterFormat = S5ParameterFormat.KH;                              break;                          case 128:                              tmp.S5ParameterFormat = S5ParameterFormat.KM;                              break;                      }
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S5.MC5,MC5toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S5\MC5\MC5toAWL.cs,GetParameters,The following statement contains a magic number: switch (t2)                      {                          case 1:                              tmp.S5ParameterFormat = S5ParameterFormat.KZ;                              break;                          case 2:                              tmp.S5ParameterFormat = S5ParameterFormat.KT;                              break;                          case 4:                              tmp.S5ParameterFormat = S5ParameterFormat.KF;                              break;                          case 8:                              tmp.S5ParameterFormat = S5ParameterFormat.KG;                              break;                          case 16:                              tmp.S5ParameterFormat = S5ParameterFormat.KC;                              break;                          case 32:                              tmp.S5ParameterFormat = S5ParameterFormat.KY;                              break;                          case 64:                              tmp.S5ParameterFormat = S5ParameterFormat.KH;                              break;                          case 128:                              tmp.S5ParameterFormat = S5ParameterFormat.KM;                              break;                      }
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S5.MC5,MC5toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S5\MC5\MC5toAWL.cs,GetParameters,The following statement contains a magic number: tmp.Name = System.Text.Encoding.GetEncoding("ISO-8859-1").GetString(code' n * 6 + 22' 4);
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S5.MC5,MC5toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S5\MC5\MC5toAWL.cs,GetParameters,The following statement contains a magic number: tmp.Name = System.Text.Encoding.GetEncoding("ISO-8859-1").GetString(code' n * 6 + 22' 4);
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S5.MC5,MC5toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S5\MC5\MC5toAWL.cs,GetParameters,The following statement contains a magic number: tmp.Name = System.Text.Encoding.GetEncoding("ISO-8859-1").GetString(code' n * 6 + 22' 4);
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S5.MC5,MC5toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S5\MC5\MC5toAWL.cs,IsCall,The following statement contains a magic number: (newRow.Command == "SPA" && newRow.Parameter.Substring(0' 2) == "FB") ||                          (newRow.Command == "SPB" && newRow.Parameter.Substring(0' 2) == "FB") ||                          (newRow.Command == "BA" && newRow.Parameter.Substring(0' 2) == "FX") ||                          (newRow.Command == "BAB" && newRow.Parameter.Substring(0' 2) == "FX")
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S5.MC5,MC5toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S5\MC5\MC5toAWL.cs,IsCall,The following statement contains a magic number: (newRow.Command == "SPA" && newRow.Parameter.Substring(0' 2) == "FB") ||                          (newRow.Command == "SPB" && newRow.Parameter.Substring(0' 2) == "FB") ||                          (newRow.Command == "BA" && newRow.Parameter.Substring(0' 2) == "FX") ||                          (newRow.Command == "BAB" && newRow.Parameter.Substring(0' 2) == "FX")
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S5.MC5,MC5toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S5\MC5\MC5toAWL.cs,IsCall,The following statement contains a magic number: (newRow.Command == "SPA" && newRow.Parameter.Substring(0' 2) == "FB") ||                          (newRow.Command == "SPB" && newRow.Parameter.Substring(0' 2) == "FB") ||                          (newRow.Command == "BA" && newRow.Parameter.Substring(0' 2) == "FX") ||                          (newRow.Command == "BAB" && newRow.Parameter.Substring(0' 2) == "FX")
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S5.MC5,MC5toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S5\MC5\MC5toAWL.cs,IsCall,The following statement contains a magic number: (newRow.Command == "SPA" && newRow.Parameter.Substring(0' 2) == "FB") ||                          (newRow.Command == "SPB" && newRow.Parameter.Substring(0' 2) == "FB") ||                          (newRow.Command == "BA" && newRow.Parameter.Substring(0' 2) == "FX") ||                          (newRow.Command == "BAB" && newRow.Parameter.Substring(0' 2) == "FX")
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S5.MC5,MC5toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S5\MC5\MC5toAWL.cs,GetMC5Rows,The following statement contains a magic number: int btSize = (_codelen + _parlen) / 8;
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S5.MC5,MC5toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S5\MC5\MC5toAWL.cs,GetMC5Rows,The following statement contains a magic number: string fbNM = System.Text.Encoding.GetEncoding("ISO-8859-1").GetString(calledfb' 12' 8);
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S5.MC5,MC5toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S5\MC5\MC5toAWL.cs,GetMC5Rows,The following statement contains a magic number: string fbNM = System.Text.Encoding.GetEncoding("ISO-8859-1").GetString(calledfb' 12' 8);
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S5.MC5,MC5toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S5\MC5\MC5toAWL.cs,GetMC5Rows,The following statement contains a magic number: int pos = codepos + j * 2;
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S5.MC5,MC5toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S5\MC5\MC5toAWL.cs,GetMC5Rows,The following statement contains a magic number: switch (s5Parameter.S5ParameterType)                                  {                                      case S5ParameterType.A:                                      case S5ParameterType.E:                                          int ber = code[pos];                                          switch (s5Parameter.S5ParameterFormat)                                          {                                                case S5ParameterFormat.BI:                                                  switch (ber & 0xf0)                                                  {                                                      case 0x80:                                                          akOper += "M";                                                          break;                                                  }                                                  akOper += code[pos + 1].ToString();                                                  akOper += "." + (code[pos] & 0x0f).ToString();                                                  break;                                              case S5ParameterFormat.BY:                                                  switch (ber)                                                  {                                                      case 0x0a:                                                          akOper += "MB";                                                          break;                                                      case 0x2a:                                                          akOper += "DR";                                                          break;                                                      case 0x22:                                                          akOper += "DL";                                                          break;                                                      default:                                                          akOper += "";                                                          break;                                                  }                                                  akOper += code[pos + 1].ToString();                                                  break;                                              case S5ParameterFormat.W:                                                  switch (ber)                                                  {                                                      case 0x12:                                                          akOper += "MW";                                                          break;                                                      case 0x32:                                                          akOper += "DW";                                                          break;                                                  }                                                    akOper += code[pos + 1].ToString();                                                  break;                                              case S5ParameterFormat.D:                                                  break;                                          }                                          break;                                      case S5ParameterType.D:                                          int wrt = code[pos] * 0x100 + code[pos + 1];                                          akOper += s5Parameter.S5ParameterFormat.ToString() + " ";                                          switch (s5Parameter.S5ParameterFormat)                                          {                                              case S5ParameterFormat.KF:                                                  if (((Int16)wrt) > 0)                                                      akOper += "+";                                                  akOper += ((Int16)wrt).ToString();                                                  break;                                              case S5ParameterFormat.KT:                                                  //code[pos + 1]                                                  // Bit      4-7       0-3    4-7   0-3                                                           //Format: Zeitbasis' 100er' 10er' 1er                                                  akOper += wrt.ToString().PadLeft(3' '0') + ".0";                                                  break;                                              case S5ParameterFormat.KC:                                                  akOper += (char)code[pos] + (char)code[pos + 1];                                                  break;                                              case S5ParameterFormat.KM:                                                  akOper += libnodave.dec2bin(code[pos]) + " ";                                                  akOper += libnodave.dec2bin(code[pos + 1]);                                                  break;                                              case S5ParameterFormat.KY:                                                  akOper += code[pos].ToString() + "'" + code[pos + 1].ToString();                                                  break;                                              default:                                                  akOper += ((Int16)wrt).ToString("X").PadLeft(4' '0');                                                  break;                                          }                                          break;                                      case S5ParameterType.B:                                          int bst = code[pos];                                          switch (bst)                                          {                                              case 0x20:                                                  akOper += "DB";                                                  break;                                          }                                          akOper += code[pos + 1].ToString();                                            break;                                      case S5ParameterType.T:                                          //int abst = code[pos];                                                                                                                                        akOper += "T " + code[pos + 1].ToString();                                          break;                                      case S5ParameterType.Z:                                          akOper += "Z " + code[pos + 1].ToString();                                          break;                                  }
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S5.MC5,MC5toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S5\MC5\MC5toAWL.cs,GetMC5Rows,The following statement contains a magic number: switch (s5Parameter.S5ParameterType)                                  {                                      case S5ParameterType.A:                                      case S5ParameterType.E:                                          int ber = code[pos];                                          switch (s5Parameter.S5ParameterFormat)                                          {                                                case S5ParameterFormat.BI:                                                  switch (ber & 0xf0)                                                  {                                                      case 0x80:                                                          akOper += "M";                                                          break;                                                  }                                                  akOper += code[pos + 1].ToString();                                                  akOper += "." + (code[pos] & 0x0f).ToString();                                                  break;                                              case S5ParameterFormat.BY:                                                  switch (ber)                                                  {                                                      case 0x0a:                                                          akOper += "MB";                                                          break;                                                      case 0x2a:                                                          akOper += "DR";                                                          break;                                                      case 0x22:                                                          akOper += "DL";                                                          break;                                                      default:                                                          akOper += "";                                                          break;                                                  }                                                  akOper += code[pos + 1].ToString();                                                  break;                                              case S5ParameterFormat.W:                                                  switch (ber)                                                  {                                                      case 0x12:                                                          akOper += "MW";                                                          break;                                                      case 0x32:                                                          akOper += "DW";                                                          break;                                                  }                                                    akOper += code[pos + 1].ToString();                                                  break;                                              case S5ParameterFormat.D:                                                  break;                                          }                                          break;                                      case S5ParameterType.D:                                          int wrt = code[pos] * 0x100 + code[pos + 1];                                          akOper += s5Parameter.S5ParameterFormat.ToString() + " ";                                          switch (s5Parameter.S5ParameterFormat)                                          {                                              case S5ParameterFormat.KF:                                                  if (((Int16)wrt) > 0)                                                      akOper += "+";                                                  akOper += ((Int16)wrt).ToString();                                                  break;                                              case S5ParameterFormat.KT:                                                  //code[pos + 1]                                                  // Bit      4-7       0-3    4-7   0-3                                                           //Format: Zeitbasis' 100er' 10er' 1er                                                  akOper += wrt.ToString().PadLeft(3' '0') + ".0";                                                  break;                                              case S5ParameterFormat.KC:                                                  akOper += (char)code[pos] + (char)code[pos + 1];                                                  break;                                              case S5ParameterFormat.KM:                                                  akOper += libnodave.dec2bin(code[pos]) + " ";                                                  akOper += libnodave.dec2bin(code[pos + 1]);                                                  break;                                              case S5ParameterFormat.KY:                                                  akOper += code[pos].ToString() + "'" + code[pos + 1].ToString();                                                  break;                                              default:                                                  akOper += ((Int16)wrt).ToString("X").PadLeft(4' '0');                                                  break;                                          }                                          break;                                      case S5ParameterType.B:                                          int bst = code[pos];                                          switch (bst)                                          {                                              case 0x20:                                                  akOper += "DB";                                                  break;                                          }                                          akOper += code[pos + 1].ToString();                                            break;                                      case S5ParameterType.T:                                          //int abst = code[pos];                                                                                                                                        akOper += "T " + code[pos + 1].ToString();                                          break;                                      case S5ParameterType.Z:                                          akOper += "Z " + code[pos + 1].ToString();                                          break;                                  }
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S5.MC5,MC5toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S5\MC5\MC5toAWL.cs,GetMC5Rows,The following statement contains a magic number: btSize += spa * 2;
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S5.MC5,MC5toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S5\MC5\MC5toAWL.cs,GetMC5Rows,The following statement contains a magic number: codepos += spa * 2;
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S5.MC5,MC5toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S5\MC5\MC5toAWL.cs,GetMC5Rows,The following statement contains a magic number: jmpBytePos = akBytePos + (tmp.JumpWidth * 2);
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S5.MC5,MC5toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S5\MC5\MC5toAWL.cs,GetMC5Rows,The following statement contains a magic number: target.Label = "M" + JumpCount.ToString().PadLeft(3' '0');
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S5.MC5,MC5toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S5\MC5\MC5toAWL.cs,swab_word,The following statement contains a magic number: return (inWrt << 16) | (inWrt >> 16);
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S5.MC5,MC5toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S5\MC5\MC5toAWL.cs,swab_word,The following statement contains a magic number: return (inWrt << 16) | (inWrt >> 16);
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S5.MC5,MC5toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S5\MC5\MC5toAWL.cs,find_mc5_param,The following statement contains a magic number: C16 = (parcode[codepos] << 8) | parcode[codepos + 1];
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S5.MC5,MC5toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S5\MC5\MC5toAWL.cs,find_mc5_param,The following statement contains a magic number: C32 = (parcode[codepos] << 24) | (parcode[codepos + 1] << 16) | (parcode[codepos + 2] << 8) | (parcode[codepos + 3]);
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S5.MC5,MC5toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S5\MC5\MC5toAWL.cs,find_mc5_param,The following statement contains a magic number: C32 = (parcode[codepos] << 24) | (parcode[codepos + 1] << 16) | (parcode[codepos + 2] << 8) | (parcode[codepos + 3]);
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S5.MC5,MC5toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S5\MC5\MC5toAWL.cs,find_mc5_param,The following statement contains a magic number: C32 = (parcode[codepos] << 24) | (parcode[codepos + 1] << 16) | (parcode[codepos + 2] << 8) | (parcode[codepos + 3]);
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S5.MC5,MC5toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S5\MC5\MC5toAWL.cs,find_mc5_param,The following statement contains a magic number: C32 = (parcode[codepos] << 24) | (parcode[codepos + 1] << 16) | (parcode[codepos + 2] << 8) | (parcode[codepos + 3]);
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S5.MC5,MC5toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S5\MC5\MC5toAWL.cs,find_mc5_param,The following statement contains a magic number: C32 = (parcode[codepos] << 24) | (parcode[codepos + 1] << 16) | (parcode[codepos + 2] << 8) | (parcode[codepos + 3]);
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S5.MC5,MC5toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S5\MC5\MC5toAWL.cs,find_mc5_param,The following statement contains a magic number: codepos + 3 < parcode.Length
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S5.MC5,MC5toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S5\MC5\MC5toAWL.cs,find_mc5_param,The following statement contains a magic number: _codelen + _parlen <= 16
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S5.MC5,MC5toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S5\MC5\MC5toAWL.cs,find_mc5_code,The following statement contains a magic number: C16 = (parcode[codepos] << 8) | parcode[codepos + 1];
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S5.MC5,MC5toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S5\MC5\MC5toAWL.cs,find_mc5_code,The following statement contains a magic number: C32 = (parcode[codepos] << 24) | (parcode[codepos + 1] << 16) | (parcode[codepos + 2] << 8) | (parcode[codepos + 3]);
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S5.MC5,MC5toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S5\MC5\MC5toAWL.cs,find_mc5_code,The following statement contains a magic number: C32 = (parcode[codepos] << 24) | (parcode[codepos + 1] << 16) | (parcode[codepos + 2] << 8) | (parcode[codepos + 3]);
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S5.MC5,MC5toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S5\MC5\MC5toAWL.cs,find_mc5_code,The following statement contains a magic number: C32 = (parcode[codepos] << 24) | (parcode[codepos + 1] << 16) | (parcode[codepos + 2] << 8) | (parcode[codepos + 3]);
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S5.MC5,MC5toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S5\MC5\MC5toAWL.cs,find_mc5_code,The following statement contains a magic number: C32 = (parcode[codepos] << 24) | (parcode[codepos + 1] << 16) | (parcode[codepos + 2] << 8) | (parcode[codepos + 3]);
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S5.MC5,MC5toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S5\MC5\MC5toAWL.cs,find_mc5_code,The following statement contains a magic number: C32 = (parcode[codepos] << 24) | (parcode[codepos + 1] << 16) | (parcode[codepos + 2] << 8) | (parcode[codepos + 3]);
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S5.MC5,MC5toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S5\MC5\MC5toAWL.cs,find_mc5_code,The following statement contains a magic number: codepos + 3 < parcode.Length
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S5.MC5,MC5toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S5\MC5\MC5toAWL.cs,find_mc5_code,The following statement contains a magic number: (int)((object[])sym[i])[codelen] <= 16
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S5.MC5,MC5toComment,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S5\MC5\MC5toComment.cs,GetCommentBlock,The following statement contains a magic number: int nr = 28;
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S5.MC5,MC5toComment,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S5\MC5\MC5toComment.cs,GetCommentBlock,The following statement contains a magic number: int len = 0x7f & commentBlock[nr + 2];
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S5.MC5,MC5toComment,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S5\MC5\MC5toComment.cs,GetCommentBlock,The following statement contains a magic number: string cmt = System.Text.Encoding.GetEncoding("ISO-8859-1").GetString(commentBlock' nr + 3' len);
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S5.MC5,MC5toComment,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S5\MC5\MC5toComment.cs,GetCommentBlock,The following statement contains a magic number: nr += len + 3;
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S5.MC5,MC5toComment,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S5\MC5\MC5toComment.cs,GetCommentBlock,The following statement contains a magic number: nr + 3 < commentBlock.Length
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S5.MC5,MC5toDB,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S5\MC5\MC5toDB.cs,GetDB,The following statement contains a magic number: int anzTypes = (((preHeader[6] * 256 + preHeader[7]) - 2)/2);
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S5.MC5,MC5toDB,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S5\MC5\MC5toDB.cs,GetDB,The following statement contains a magic number: int anzTypes = (((preHeader[6] * 256 + preHeader[7]) - 2)/2);
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S5.MC5,MC5toDB,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S5\MC5\MC5toDB.cs,GetDB,The following statement contains a magic number: int anzTypes = (((preHeader[6] * 256 + preHeader[7]) - 2)/2);
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S5.MC5,MC5toDB,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S5\MC5\MC5toDB.cs,GetDB,The following statement contains a magic number: int anzTypes = (((preHeader[6] * 256 + preHeader[7]) - 2)/2);
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S5.MC5,MC5toDB,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S5\MC5\MC5toDB.cs,GetDB,The following statement contains a magic number: int anzTypes = (((preHeader[6] * 256 + preHeader[7]) - 2)/2);
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S5.MC5,MC5toDB,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S5\MC5\MC5toDB.cs,GetDB,The following statement contains a magic number: int rowStart = preHeader[(n - 1) * 4 + 10] * 256 + preHeader[(n - 1) * 4 + 11];
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S5.MC5,MC5toDB,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S5\MC5\MC5toDB.cs,GetDB,The following statement contains a magic number: int rowStart = preHeader[(n - 1) * 4 + 10] * 256 + preHeader[(n - 1) * 4 + 11];
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S5.MC5,MC5toDB,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S5\MC5\MC5toDB.cs,GetDB,The following statement contains a magic number: int rowStart = preHeader[(n - 1) * 4 + 10] * 256 + preHeader[(n - 1) * 4 + 11];
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S5.MC5,MC5toDB,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S5\MC5\MC5toDB.cs,GetDB,The following statement contains a magic number: int rowStart = preHeader[(n - 1) * 4 + 10] * 256 + preHeader[(n - 1) * 4 + 11];
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S5.MC5,MC5toDB,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S5\MC5\MC5toDB.cs,GetDB,The following statement contains a magic number: int rowStart = preHeader[(n - 1) * 4 + 10] * 256 + preHeader[(n - 1) * 4 + 11];
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S5.MC5,MC5toDB,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S5\MC5\MC5toDB.cs,GetDB,The following statement contains a magic number: int rowStop = preHeader[n * 4 + 10] * 256 + preHeader[n * 4 + 11];
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S5.MC5,MC5toDB,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S5\MC5\MC5toDB.cs,GetDB,The following statement contains a magic number: int rowStop = preHeader[n * 4 + 10] * 256 + preHeader[n * 4 + 11];
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S5.MC5,MC5toDB,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S5\MC5\MC5toDB.cs,GetDB,The following statement contains a magic number: int rowStop = preHeader[n * 4 + 10] * 256 + preHeader[n * 4 + 11];
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S5.MC5,MC5toDB,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S5\MC5\MC5toDB.cs,GetDB,The following statement contains a magic number: int rowStop = preHeader[n * 4 + 10] * 256 + preHeader[n * 4 + 11];
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S5.MC5,MC5toDB,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S5\MC5\MC5toDB.cs,GetDB,The following statement contains a magic number: int rowStop = preHeader[n * 4 + 10] * 256 + preHeader[n * 4 + 11];
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S5.MC5,MC5toDB,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S5\MC5\MC5toDB.cs,GetDB,The following statement contains a magic number: var akRwTp = (S7DataRowType)(preHeader[9 + (n - 1) * 4] | 0xf00);
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S5.MC5,MC5toDB,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S5\MC5\MC5toDB.cs,GetDB,The following statement contains a magic number: var akRwTp = (S7DataRowType)(preHeader[9 + (n - 1) * 4] | 0xf00);
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S5.MC5,MC5toDB,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S5\MC5\MC5toDB.cs,GetDB,The following statement contains a magic number: row.StringSize = rowStop - j > 12 ? 24 : (rowStop - j)*2;
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S5.MC5,MC5toDB,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S5\MC5\MC5toDB.cs,GetDB,The following statement contains a magic number: row.StringSize = rowStop - j > 12 ? 24 : (rowStop - j)*2;
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S5.MC5,MC5toDB,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S5\MC5\MC5toDB.cs,GetDB,The following statement contains a magic number: row.StringSize = rowStop - j > 12 ? 24 : (rowStop - j)*2;
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S5.MC5,MC5toDB,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S5\MC5\MC5toDB.cs,GetDB,The following statement contains a magic number: q < (row.StringSize/2)
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S5.MC5,MC5toDB,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S5\MC5\MC5toDB.cs,GetDB,The following statement contains a magic number: int st = 10;
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S5.MC5,MC5toDB,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S5\MC5\MC5toDB.cs,GetDB,The following statement contains a magic number: int maxZ = (block[8] * 256 + block[9]);
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S5.MC5,MC5toDB,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S5\MC5\MC5toDB.cs,GetDB,The following statement contains a magic number: int maxZ = (block[8] * 256 + block[9]);
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S5.MC5,MC5toDB,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S5\MC5\MC5toDB.cs,GetDB,The following statement contains a magic number: int maxZ = (block[8] * 256 + block[9]);
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S5.MC5,MC5toDB,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S5\MC5\MC5toDB.cs,GetDB,The following statement contains a magic number: n += s7DataRow.ByteLength / 2;
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S5.MC5,MC5toDB,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S5\MC5\MC5toDB.cs,GetDB,The following statement contains a magic number: n < maxZ - 5
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S5.MC5,MC5toDB,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S5\MC5\MC5toDB.cs,GetDB,The following statement contains a magic number: int nr = 28;
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S5.MC5,MC5toDB,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S5\MC5\MC5toDB.cs,GetDB,The following statement contains a magic number: int zeile = ((commentBlock[nr + 1] - 128) * 256) + commentBlock[nr];
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S5.MC5,MC5toDB,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S5\MC5\MC5toDB.cs,GetDB,The following statement contains a magic number: int zeile = ((commentBlock[nr + 1] - 128) * 256) + commentBlock[nr];
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S5.MC5,MC5toDB,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S5\MC5\MC5toDB.cs,GetDB,The following statement contains a magic number: int len = 0x7f & commentBlock[nr + 2];
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S5.MC5,MC5toDB,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S5\MC5\MC5toDB.cs,GetDB,The following statement contains a magic number: string cmt = System.Text.Encoding.GetEncoding("ISO-8859-1").GetString(commentBlock' nr + 3' len);
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S5.MC5,MC5toDB,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S5\MC5\MC5toDB.cs,GetDB,The following statement contains a magic number: nr += len + 3;
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S5.MC5,MC5toDB,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S5\MC5\MC5toDB.cs,GetDB,The following statement contains a magic number: nr + 3 < commentBlock.Length
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_1xyy,VariableLengthQuantityHelper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_1xyy\VariableLengthQuantityHelper.cs,DecodeInt,The following statement contains a magic number: val <<= 6;
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_1xyy,VariableLengthQuantityHelper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_1xyy\VariableLengthQuantityHelper.cs,DecodeInt,The following statement contains a magic number: n <= 4 + 1
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_1xyy,VariableLengthQuantityHelper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_1xyy\VariableLengthQuantityHelper.cs,EncodeInt,The following statement contains a magic number: var anzBits = (int)Math.Ceiling(Math.Log(wr) / Math.Log(2));
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_1xyy,VariableLengthQuantityHelper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_1xyy\VariableLengthQuantityHelper.cs,EncodeInt,The following statement contains a magic number: anzBits -= 6;
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_1xyy,VariableLengthQuantityHelper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_1xyy\VariableLengthQuantityHelper.cs,EncodeInt,The following statement contains a magic number: anzBits >= 6
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_1xyy,VariableLengthQuantityHelper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_1xyy\VariableLengthQuantityHelper.cs,EncodeInt,The following statement contains a magic number: anzBits -= 7;
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_1xyy,VariableLengthQuantityHelper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_1xyy\VariableLengthQuantityHelper.cs,EncodeInt,The following statement contains a magic number: anzBits > 7
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_1xyy,VariableLengthQuantityHelper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_1xyy\VariableLengthQuantityHelper.cs,EncodeInt,The following statement contains a magic number: var fakt = (anzBytes - i) * 7;
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_1xyy,VariableLengthQuantityHelper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_1xyy\VariableLengthQuantityHelper.cs,EncodeInt,The following statement contains a magic number: var divisor = (int)Math.Pow(2' fakt);
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,AWLtoMC7,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\AWLtoMC7.cs,GetSize,The following statement contains a magic number: return 4;
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetNextBitAddress,The following statement contains a magic number: tmp.BitAddress > 7
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetNextBitAddress,The following statement contains a magic number: tmp.BitAddress == 7
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,ValueToString,The following statement contains a magic number: return ((UInt16)Value / 256).ToString().PadLeft(3' '0') + "'" + ((UInt16)Value % 256).ToString().PadLeft(3' '0');
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,ValueToString,The following statement contains a magic number: return ((UInt16)Value / 256).ToString().PadLeft(3' '0') + "'" + ((UInt16)Value % 256).ToString().PadLeft(3' '0');
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,ValueToString,The following statement contains a magic number: return ((UInt16)Value / 256).ToString().PadLeft(3' '0') + "'" + ((UInt16)Value % 256).ToString().PadLeft(3' '0');
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,ValueToString,The following statement contains a magic number: return ((UInt16)Value / 256).ToString().PadLeft(3' '0') + "'" + ((UInt16)Value % 256).ToString().PadLeft(3' '0');
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetDateTimeFromDateString,The following statement contains a magic number: d = Convert.ToInt32(tmp[2]);
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetDateTimeFromDateString,The following statement contains a magic number: tmp.Length > 2
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetDateTimeFromDateString,The following statement contains a magic number: y += y >= 90 ? 1900 : 2000;
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetDateTimeFromDateString,The following statement contains a magic number: y += y >= 90 ? 1900 : 2000;
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetDateTimeFromDateString,The following statement contains a magic number: y += y >= 90 ? 1900 : 2000;
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetDateTimeFromDateString,The following statement contains a magic number: y < 100
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetDateTimeFromTimeOfDayString,The following statement contains a magic number: s = Convert.ToInt32(tmp[2].Split('.')[0]);
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetDateTimeFromTimeOfDayString,The following statement contains a magic number: ms = Convert.ToInt32(tmp[2].Split('.')[1]);
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetDateTimeFromTimeOfDayString,The following statement contains a magic number: tmp.Length > 2
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetDateTimeFromTimeOfDayString,The following statement contains a magic number: return new DateTime(1990' 1' 1' h' m' s' ms);
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetIntFromBinString,The following statement contains a magic number: val *= 2;
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetUIntFromHexString,The following statement contains a magic number: val *= 16;
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetUIntFromHexString,The following statement contains a magic number: switch (tmp)                  {                      case '0':                      case '1':                      case '2':                      case '3':                      case '4':                      case '5':                      case '6':                      case '7':                      case '8':                      case '9':                          val += (uint)(tmp - '0');                          break;                      case 'a':                      case 'b':                      case 'c':                      case 'd':                      case 'e':                      case 'f':                          val += (uint)(tmp - 'a' + 10);                          break;                  }
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,EncodePassword,The following statement contains a magic number: retByteArray[2] = (byte)(retByteArray[2] ^ retByteArray[0]);
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,EncodePassword,The following statement contains a magic number: retByteArray[2] = (byte)(retByteArray[2] ^ retByteArray[0]);
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,EncodePassword,The following statement contains a magic number: retByteArray[3] = (byte)(retByteArray[3] ^ retByteArray[1]);
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,EncodePassword,The following statement contains a magic number: retByteArray[3] = (byte)(retByteArray[3] ^ retByteArray[1]);
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,EncodePassword,The following statement contains a magic number: retByteArray[4] = (byte)(retByteArray[4] ^ retByteArray[2]);
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,EncodePassword,The following statement contains a magic number: retByteArray[4] = (byte)(retByteArray[4] ^ retByteArray[2]);
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,EncodePassword,The following statement contains a magic number: retByteArray[4] = (byte)(retByteArray[4] ^ retByteArray[2]);
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,EncodePassword,The following statement contains a magic number: retByteArray[5] = (byte)(retByteArray[5] ^ retByteArray[3]);
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,EncodePassword,The following statement contains a magic number: retByteArray[5] = (byte)(retByteArray[5] ^ retByteArray[3]);
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,EncodePassword,The following statement contains a magic number: retByteArray[5] = (byte)(retByteArray[5] ^ retByteArray[3]);
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,EncodePassword,The following statement contains a magic number: retByteArray[6] = (byte)(retByteArray[6] ^ retByteArray[4]);
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,EncodePassword,The following statement contains a magic number: retByteArray[6] = (byte)(retByteArray[6] ^ retByteArray[4]);
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,EncodePassword,The following statement contains a magic number: retByteArray[6] = (byte)(retByteArray[6] ^ retByteArray[4]);
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,EncodePassword,The following statement contains a magic number: retByteArray[7] = (byte)(retByteArray[7] ^ retByteArray[5]);
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,EncodePassword,The following statement contains a magic number: retByteArray[7] = (byte)(retByteArray[7] ^ retByteArray[5]);
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,EncodePassword,The following statement contains a magic number: retByteArray[7] = (byte)(retByteArray[7] ^ retByteArray[5]);
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetIndirectBytesWord,The following statement contains a magic number: switch (tmp.Substring(0'2))              {                  case "PEW":                  case "PIW":                  case "PAW":                  case "POW":                      nr = Convert.ToInt32(tmp.Replace("PEW"' "").Replace("PAW"' "").Replace("PIW"' "").Replace("POW"' ""));                      nr2 = 0;                      break;                  case "EW":                  case "IW":                      nr = Convert.ToInt32(tmp.Replace("EW"' "").Replace("IW"' ""));                      nr2 = 10;                      break;                  case "AW":                  case "OW":                      nr = Convert.ToInt32(tmp.Replace("AW"' "").Replace("OW"' ""));                      nr2 = 20;                      break;                  case "MW":                      nr = Convert.ToInt32(tmp.Replace("MW"' ""));                      nr2 = 30;                      break;                  case "DBW":                      nr = Convert.ToInt32(tmp.Replace("DBW"' ""));                      nr2 = 40;                      break;                  case "DIW":                      nr = Convert.ToInt32(tmp.Replace("DIW"' ""));                      nr2 = 50;                      break;                  case "LW":                      nr = Convert.ToInt32(tmp.Replace("LW"' ""));                      nr2 = 60;                      break;              }
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetIndirectBytesWord,The following statement contains a magic number: switch (tmp.Substring(0'2))              {                  case "PEW":                  case "PIW":                  case "PAW":                  case "POW":                      nr = Convert.ToInt32(tmp.Replace("PEW"' "").Replace("PAW"' "").Replace("PIW"' "").Replace("POW"' ""));                      nr2 = 0;                      break;                  case "EW":                  case "IW":                      nr = Convert.ToInt32(tmp.Replace("EW"' "").Replace("IW"' ""));                      nr2 = 10;                      break;                  case "AW":                  case "OW":                      nr = Convert.ToInt32(tmp.Replace("AW"' "").Replace("OW"' ""));                      nr2 = 20;                      break;                  case "MW":                      nr = Convert.ToInt32(tmp.Replace("MW"' ""));                      nr2 = 30;                      break;                  case "DBW":                      nr = Convert.ToInt32(tmp.Replace("DBW"' ""));                      nr2 = 40;                      break;                  case "DIW":                      nr = Convert.ToInt32(tmp.Replace("DIW"' ""));                      nr2 = 50;                      break;                  case "LW":                      nr = Convert.ToInt32(tmp.Replace("LW"' ""));                      nr2 = 60;                      break;              }
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetIndirectBytesWord,The following statement contains a magic number: switch (tmp.Substring(0'2))              {                  case "PEW":                  case "PIW":                  case "PAW":                  case "POW":                      nr = Convert.ToInt32(tmp.Replace("PEW"' "").Replace("PAW"' "").Replace("PIW"' "").Replace("POW"' ""));                      nr2 = 0;                      break;                  case "EW":                  case "IW":                      nr = Convert.ToInt32(tmp.Replace("EW"' "").Replace("IW"' ""));                      nr2 = 10;                      break;                  case "AW":                  case "OW":                      nr = Convert.ToInt32(tmp.Replace("AW"' "").Replace("OW"' ""));                      nr2 = 20;                      break;                  case "MW":                      nr = Convert.ToInt32(tmp.Replace("MW"' ""));                      nr2 = 30;                      break;                  case "DBW":                      nr = Convert.ToInt32(tmp.Replace("DBW"' ""));                      nr2 = 40;                      break;                  case "DIW":                      nr = Convert.ToInt32(tmp.Replace("DIW"' ""));                      nr2 = 50;                      break;                  case "LW":                      nr = Convert.ToInt32(tmp.Replace("LW"' ""));                      nr2 = 60;                      break;              }
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetIndirectBytesWord,The following statement contains a magic number: switch (tmp.Substring(0'2))              {                  case "PEW":                  case "PIW":                  case "PAW":                  case "POW":                      nr = Convert.ToInt32(tmp.Replace("PEW"' "").Replace("PAW"' "").Replace("PIW"' "").Replace("POW"' ""));                      nr2 = 0;                      break;                  case "EW":                  case "IW":                      nr = Convert.ToInt32(tmp.Replace("EW"' "").Replace("IW"' ""));                      nr2 = 10;                      break;                  case "AW":                  case "OW":                      nr = Convert.ToInt32(tmp.Replace("AW"' "").Replace("OW"' ""));                      nr2 = 20;                      break;                  case "MW":                      nr = Convert.ToInt32(tmp.Replace("MW"' ""));                      nr2 = 30;                      break;                  case "DBW":                      nr = Convert.ToInt32(tmp.Replace("DBW"' ""));                      nr2 = 40;                      break;                  case "DIW":                      nr = Convert.ToInt32(tmp.Replace("DIW"' ""));                      nr2 = 50;                      break;                  case "LW":                      nr = Convert.ToInt32(tmp.Replace("LW"' ""));                      nr2 = 60;                      break;              }
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetIndirectBytesWord,The following statement contains a magic number: switch (tmp.Substring(0'2))              {                  case "PEW":                  case "PIW":                  case "PAW":                  case "POW":                      nr = Convert.ToInt32(tmp.Replace("PEW"' "").Replace("PAW"' "").Replace("PIW"' "").Replace("POW"' ""));                      nr2 = 0;                      break;                  case "EW":                  case "IW":                      nr = Convert.ToInt32(tmp.Replace("EW"' "").Replace("IW"' ""));                      nr2 = 10;                      break;                  case "AW":                  case "OW":                      nr = Convert.ToInt32(tmp.Replace("AW"' "").Replace("OW"' ""));                      nr2 = 20;                      break;                  case "MW":                      nr = Convert.ToInt32(tmp.Replace("MW"' ""));                      nr2 = 30;                      break;                  case "DBW":                      nr = Convert.ToInt32(tmp.Replace("DBW"' ""));                      nr2 = 40;                      break;                  case "DIW":                      nr = Convert.ToInt32(tmp.Replace("DIW"' ""));                      nr2 = 50;                      break;                  case "LW":                      nr = Convert.ToInt32(tmp.Replace("LW"' ""));                      nr2 = 60;                      break;              }
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetIndirectBytesWord,The following statement contains a magic number: switch (tmp.Substring(0'2))              {                  case "PEW":                  case "PIW":                  case "PAW":                  case "POW":                      nr = Convert.ToInt32(tmp.Replace("PEW"' "").Replace("PAW"' "").Replace("PIW"' "").Replace("POW"' ""));                      nr2 = 0;                      break;                  case "EW":                  case "IW":                      nr = Convert.ToInt32(tmp.Replace("EW"' "").Replace("IW"' ""));                      nr2 = 10;                      break;                  case "AW":                  case "OW":                      nr = Convert.ToInt32(tmp.Replace("AW"' "").Replace("OW"' ""));                      nr2 = 20;                      break;                  case "MW":                      nr = Convert.ToInt32(tmp.Replace("MW"' ""));                      nr2 = 30;                      break;                  case "DBW":                      nr = Convert.ToInt32(tmp.Replace("DBW"' ""));                      nr2 = 40;                      break;                  case "DIW":                      nr = Convert.ToInt32(tmp.Replace("DIW"' ""));                      nr2 = 50;                      break;                  case "LW":                      nr = Convert.ToInt32(tmp.Replace("LW"' ""));                      nr2 = 60;                      break;              }
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetIndirectBytesWord,The following statement contains a magic number: switch (tmp.Substring(0'2))              {                  case "PEW":                  case "PIW":                  case "PAW":                  case "POW":                      nr = Convert.ToInt32(tmp.Replace("PEW"' "").Replace("PAW"' "").Replace("PIW"' "").Replace("POW"' ""));                      nr2 = 0;                      break;                  case "EW":                  case "IW":                      nr = Convert.ToInt32(tmp.Replace("EW"' "").Replace("IW"' ""));                      nr2 = 10;                      break;                  case "AW":                  case "OW":                      nr = Convert.ToInt32(tmp.Replace("AW"' "").Replace("OW"' ""));                      nr2 = 20;                      break;                  case "MW":                      nr = Convert.ToInt32(tmp.Replace("MW"' ""));                      nr2 = 30;                      break;                  case "DBW":                      nr = Convert.ToInt32(tmp.Replace("DBW"' ""));                      nr2 = 40;                      break;                  case "DIW":                      nr = Convert.ToInt32(tmp.Replace("DIW"' ""));                      nr2 = 50;                      break;                  case "LW":                      nr = Convert.ToInt32(tmp.Replace("LW"' ""));                      nr2 = 60;                      break;              }
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetDaT,The following statement contains a magic number: int[] b1 = new int[4];
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetDaT,The following statement contains a magic number: int[] b2 = new int[4];
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetDaT,The following statement contains a magic number: int[] tYear = new int[2];
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetDaT,The following statement contains a magic number: int[] tMonth = new int[2];
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetDaT,The following statement contains a magic number: int[] tDay = new int[2];
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetDaT,The following statement contains a magic number: int[] tHour = new int[2];
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetDaT,The following statement contains a magic number: int[] tMinute = new int[2];
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetDaT,The following statement contains a magic number: int[] tSecond = new int[2];
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetDaT,The following statement contains a magic number: int[] tMilliSecond = new int[2];
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetDaT,The following statement contains a magic number: tYear[0] = (b1[3]/16)*10;
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetDaT,The following statement contains a magic number: tYear[0] = (b1[3]/16)*10;
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetDaT,The following statement contains a magic number: tYear[0] = (b1[3]/16)*10;
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetDaT,The following statement contains a magic number: tYear[1] = (b1[3]%16);
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetDaT,The following statement contains a magic number: tYear[1] = (b1[3]%16);
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetDaT,The following statement contains a magic number: (tYear[0]/10 > 9) || (tYear[1] > 9)
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetDaT,The following statement contains a magic number: (tYear[0]/10 > 9) || (tYear[1] > 9)
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetDaT,The following statement contains a magic number: (tYear[0]/10 > 9) || (tYear[1] > 9)
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetDaT,The following statement contains a magic number: Year = Year + 2000;
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetDaT,The following statement contains a magic number: Year < 90
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetDaT,The following statement contains a magic number: tMonth[0] = (b1[2]/16)*10;
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetDaT,The following statement contains a magic number: tMonth[0] = (b1[2]/16)*10;
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetDaT,The following statement contains a magic number: tMonth[0] = (b1[2]/16)*10;
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetDaT,The following statement contains a magic number: tMonth[1] = (b1[2]%16);
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetDaT,The following statement contains a magic number: tMonth[1] = (b1[2]%16);
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetDaT,The following statement contains a magic number: (tMonth[0]/10 > 9) || (tMonth[1] > 9)
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetDaT,The following statement contains a magic number: (tMonth[0]/10 > 9) || (tMonth[1] > 9)
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetDaT,The following statement contains a magic number: (tMonth[0]/10 > 9) || (tMonth[1] > 9)
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetDaT,The following statement contains a magic number: tDay[0] = (b1[1]/16)*10;
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetDaT,The following statement contains a magic number: tDay[0] = (b1[1]/16)*10;
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetDaT,The following statement contains a magic number: tDay[1] = (b1[1]%16);
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetDaT,The following statement contains a magic number: (tDay[0]/10 > 9) || (tDay[1] > 9)
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetDaT,The following statement contains a magic number: (tDay[0]/10 > 9) || (tDay[1] > 9)
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetDaT,The following statement contains a magic number: (tDay[0]/10 > 9) || (tDay[1] > 9)
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetDaT,The following statement contains a magic number: tHour[0] = (b1[0]/16)*10;
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetDaT,The following statement contains a magic number: tHour[0] = (b1[0]/16)*10;
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetDaT,The following statement contains a magic number: tHour[1] = (b1[0]%16);
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetDaT,The following statement contains a magic number: (tHour[0]/10 > 9) || (tHour[1] > 9)
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetDaT,The following statement contains a magic number: (tHour[0]/10 > 9) || (tHour[1] > 9)
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetDaT,The following statement contains a magic number: (tHour[0]/10 > 9) || (tHour[1] > 9)
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetDaT,The following statement contains a magic number: tMinute[0] = (b2[3]/16)*10;
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetDaT,The following statement contains a magic number: tMinute[0] = (b2[3]/16)*10;
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetDaT,The following statement contains a magic number: tMinute[0] = (b2[3]/16)*10;
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetDaT,The following statement contains a magic number: tMinute[1] = (b2[3]%16);
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetDaT,The following statement contains a magic number: tMinute[1] = (b2[3]%16);
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetDaT,The following statement contains a magic number: (tMinute[0]/10 > 9) || (tMinute[1] > 9)
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetDaT,The following statement contains a magic number: (tMinute[0]/10 > 9) || (tMinute[1] > 9)
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetDaT,The following statement contains a magic number: (tMinute[0]/10 > 9) || (tMinute[1] > 9)
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetDaT,The following statement contains a magic number: tSecond[0] = (b2[2]/16)*10;
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetDaT,The following statement contains a magic number: tSecond[0] = (b2[2]/16)*10;
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetDaT,The following statement contains a magic number: tSecond[0] = (b2[2]/16)*10;
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetDaT,The following statement contains a magic number: tSecond[1] = (b2[2]%16);
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetDaT,The following statement contains a magic number: tSecond[1] = (b2[2]%16);
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetDaT,The following statement contains a magic number: (tSecond[0]/10 > 9) || (tSecond[1] > 9)
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetDaT,The following statement contains a magic number: (tSecond[0]/10 > 9) || (tSecond[1] > 9)
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetDaT,The following statement contains a magic number: (tSecond[0]/10 > 9) || (tSecond[1] > 9)
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetDaT,The following statement contains a magic number: tMilliSec = (b2[1]/16)*100;
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetDaT,The following statement contains a magic number: tMilliSec = (b2[1]/16)*100;
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetDaT,The following statement contains a magic number: tMilliSecond[0] = (b2[1]%16)*10;
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetDaT,The following statement contains a magic number: tMilliSecond[0] = (b2[1]%16)*10;
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetDaT,The following statement contains a magic number: tMilliSecond[1] = (b2[0]/16);
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetDaT,The following statement contains a magic number: (tMilliSec/100 > 9) || (tMilliSecond[0]/10 > 9) || (tMilliSecond[1] > 9)
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetDaT,The following statement contains a magic number: (tMilliSec/100 > 9) || (tMilliSecond[0]/10 > 9) || (tMilliSecond[1] > 9)
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetDaT,The following statement contains a magic number: (tMilliSec/100 > 9) || (tMilliSecond[0]/10 > 9) || (tMilliSecond[1] > 9)
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetDaT,The following statement contains a magic number: (tMilliSec/100 > 9) || (tMilliSecond[0]/10 > 9) || (tMilliSecond[1] > 9)
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetDaT,The following statement contains a magic number: (tMilliSec/100 > 9) || (tMilliSecond[0]/10 > 9) || (tMilliSecond[1] > 9)
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetVersion,The following statement contains a magic number: Result = Convert.ToString((b & 0xF0) >> 4) + "." + Convert.ToString(b & 0x0F);
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetLang,The following statement contains a magic number: switch (b)              {                  case 1: Result = "AWL"; break;                  case 2: Result = "KOP"; break;                  case 3: Result = "FUP"; break;                  case 4: Result = "SCL"; break;                  case 5: Result = "DB"; break;                  case 6: Result = "GRAPH"; break;                                 default: Result = "unbekannt(0x" + (b).ToString("X") + ")";                      break;              }
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetLang,The following statement contains a magic number: switch (b)              {                  case 1: Result = "AWL"; break;                  case 2: Result = "KOP"; break;                  case 3: Result = "FUP"; break;                  case 4: Result = "SCL"; break;                  case 5: Result = "DB"; break;                  case 6: Result = "GRAPH"; break;                                 default: Result = "unbekannt(0x" + (b).ToString("X") + ")";                      break;              }
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetLang,The following statement contains a magic number: switch (b)              {                  case 1: Result = "AWL"; break;                  case 2: Result = "KOP"; break;                  case 3: Result = "FUP"; break;                  case 4: Result = "SCL"; break;                  case 5: Result = "DB"; break;                  case 6: Result = "GRAPH"; break;                                 default: Result = "unbekannt(0x" + (b).ToString("X") + ")";                      break;              }
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetLang,The following statement contains a magic number: switch (b)              {                  case 1: Result = "AWL"; break;                  case 2: Result = "KOP"; break;                  case 3: Result = "FUP"; break;                  case 4: Result = "SCL"; break;                  case 5: Result = "DB"; break;                  case 6: Result = "GRAPH"; break;                                 default: Result = "unbekannt(0x" + (b).ToString("X") + ")";                      break;              }
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetLang,The following statement contains a magic number: switch (b)              {                  case 1: Result = "AWL"; break;                  case 2: Result = "KOP"; break;                  case 3: Result = "FUP"; break;                  case 4: Result = "SCL"; break;                  case 5: Result = "DB"; break;                  case 6: Result = "GRAPH"; break;                                 default: Result = "unbekannt(0x" + (b).ToString("X") + ")";                      break;              }
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetDT,The following statement contains a magic number: DT = new DateTime(1984' 1' 1' 0' 0' 0' 0);
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetFCPointer,The following statement contains a magic number: switch (b1)              {                                  case 0x80:                      anf = "P#PE ";                      wrt = (b3 * 0x100 + b4) >> 3;                      break;                  case 0x81:                      anf = "P#E ";                      wrt = (b3 * 0x100 + b4) >> 3;                      break;                  case 0x82:                      anf = "P#A ";                      wrt = (b3 * 0x100 + b4) >> 3;                      break;                  case 0x83:                      anf = "P#M ";                      wrt = (b3 * 0x100 + b4) >> 3;                      break;                  case 0x84:                      anf = "P#DBX ";                      wrt = (b3 * 0x100 + b4) >> 3;                      break;                  case 0x85:                      anf = "P#DIX ";                      wrt = (b3 * 0x100 + b4) >> 3;                      break;                  case 0x86:                      anf = "P#L ";                      wrt = (b3 * 0x100 + b4) >> 3;                      break;                  case 0x87:                      anf = "P#V "; //Lokaldata of the Previous function                      wrt = (b3 * 0x100 + b4) >> 3;                      break;                  default:                      anf = "P#";                      wrt = (b1 * 0x100 + b2);                      return anf + (wrt>>3).ToString() + "." + (wrt & 0x07).ToString();                           break;              }
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetFCPointer,The following statement contains a magic number: switch (b1)              {                                  case 0x80:                      anf = "P#PE ";                      wrt = (b3 * 0x100 + b4) >> 3;                      break;                  case 0x81:                      anf = "P#E ";                      wrt = (b3 * 0x100 + b4) >> 3;                      break;                  case 0x82:                      anf = "P#A ";                      wrt = (b3 * 0x100 + b4) >> 3;                      break;                  case 0x83:                      anf = "P#M ";                      wrt = (b3 * 0x100 + b4) >> 3;                      break;                  case 0x84:                      anf = "P#DBX ";                      wrt = (b3 * 0x100 + b4) >> 3;                      break;                  case 0x85:                      anf = "P#DIX ";                      wrt = (b3 * 0x100 + b4) >> 3;                      break;                  case 0x86:                      anf = "P#L ";                      wrt = (b3 * 0x100 + b4) >> 3;                      break;                  case 0x87:                      anf = "P#V "; //Lokaldata of the Previous function                      wrt = (b3 * 0x100 + b4) >> 3;                      break;                  default:                      anf = "P#";                      wrt = (b1 * 0x100 + b2);                      return anf + (wrt>>3).ToString() + "." + (wrt & 0x07).ToString();                           break;              }
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetFCPointer,The following statement contains a magic number: switch (b1)              {                                  case 0x80:                      anf = "P#PE ";                      wrt = (b3 * 0x100 + b4) >> 3;                      break;                  case 0x81:                      anf = "P#E ";                      wrt = (b3 * 0x100 + b4) >> 3;                      break;                  case 0x82:                      anf = "P#A ";                      wrt = (b3 * 0x100 + b4) >> 3;                      break;                  case 0x83:                      anf = "P#M ";                      wrt = (b3 * 0x100 + b4) >> 3;                      break;                  case 0x84:                      anf = "P#DBX ";                      wrt = (b3 * 0x100 + b4) >> 3;                      break;                  case 0x85:                      anf = "P#DIX ";                      wrt = (b3 * 0x100 + b4) >> 3;                      break;                  case 0x86:                      anf = "P#L ";                      wrt = (b3 * 0x100 + b4) >> 3;                      break;                  case 0x87:                      anf = "P#V "; //Lokaldata of the Previous function                      wrt = (b3 * 0x100 + b4) >> 3;                      break;                  default:                      anf = "P#";                      wrt = (b1 * 0x100 + b2);                      return anf + (wrt>>3).ToString() + "." + (wrt & 0x07).ToString();                           break;              }
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetFCPointer,The following statement contains a magic number: switch (b1)              {                                  case 0x80:                      anf = "P#PE ";                      wrt = (b3 * 0x100 + b4) >> 3;                      break;                  case 0x81:                      anf = "P#E ";                      wrt = (b3 * 0x100 + b4) >> 3;                      break;                  case 0x82:                      anf = "P#A ";                      wrt = (b3 * 0x100 + b4) >> 3;                      break;                  case 0x83:                      anf = "P#M ";                      wrt = (b3 * 0x100 + b4) >> 3;                      break;                  case 0x84:                      anf = "P#DBX ";                      wrt = (b3 * 0x100 + b4) >> 3;                      break;                  case 0x85:                      anf = "P#DIX ";                      wrt = (b3 * 0x100 + b4) >> 3;                      break;                  case 0x86:                      anf = "P#L ";                      wrt = (b3 * 0x100 + b4) >> 3;                      break;                  case 0x87:                      anf = "P#V "; //Lokaldata of the Previous function                      wrt = (b3 * 0x100 + b4) >> 3;                      break;                  default:                      anf = "P#";                      wrt = (b1 * 0x100 + b2);                      return anf + (wrt>>3).ToString() + "." + (wrt & 0x07).ToString();                           break;              }
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetFCPointer,The following statement contains a magic number: switch (b1)              {                                  case 0x80:                      anf = "P#PE ";                      wrt = (b3 * 0x100 + b4) >> 3;                      break;                  case 0x81:                      anf = "P#E ";                      wrt = (b3 * 0x100 + b4) >> 3;                      break;                  case 0x82:                      anf = "P#A ";                      wrt = (b3 * 0x100 + b4) >> 3;                      break;                  case 0x83:                      anf = "P#M ";                      wrt = (b3 * 0x100 + b4) >> 3;                      break;                  case 0x84:                      anf = "P#DBX ";                      wrt = (b3 * 0x100 + b4) >> 3;                      break;                  case 0x85:                      anf = "P#DIX ";                      wrt = (b3 * 0x100 + b4) >> 3;                      break;                  case 0x86:                      anf = "P#L ";                      wrt = (b3 * 0x100 + b4) >> 3;                      break;                  case 0x87:                      anf = "P#V "; //Lokaldata of the Previous function                      wrt = (b3 * 0x100 + b4) >> 3;                      break;                  default:                      anf = "P#";                      wrt = (b1 * 0x100 + b2);                      return anf + (wrt>>3).ToString() + "." + (wrt & 0x07).ToString();                           break;              }
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetFCPointer,The following statement contains a magic number: switch (b1)              {                                  case 0x80:                      anf = "P#PE ";                      wrt = (b3 * 0x100 + b4) >> 3;                      break;                  case 0x81:                      anf = "P#E ";                      wrt = (b3 * 0x100 + b4) >> 3;                      break;                  case 0x82:                      anf = "P#A ";                      wrt = (b3 * 0x100 + b4) >> 3;                      break;                  case 0x83:                      anf = "P#M ";                      wrt = (b3 * 0x100 + b4) >> 3;                      break;                  case 0x84:                      anf = "P#DBX ";                      wrt = (b3 * 0x100 + b4) >> 3;                      break;                  case 0x85:                      anf = "P#DIX ";                      wrt = (b3 * 0x100 + b4) >> 3;                      break;                  case 0x86:                      anf = "P#L ";                      wrt = (b3 * 0x100 + b4) >> 3;                      break;                  case 0x87:                      anf = "P#V "; //Lokaldata of the Previous function                      wrt = (b3 * 0x100 + b4) >> 3;                      break;                  default:                      anf = "P#";                      wrt = (b1 * 0x100 + b2);                      return anf + (wrt>>3).ToString() + "." + (wrt & 0x07).ToString();                           break;              }
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetFCPointer,The following statement contains a magic number: switch (b1)              {                                  case 0x80:                      anf = "P#PE ";                      wrt = (b3 * 0x100 + b4) >> 3;                      break;                  case 0x81:                      anf = "P#E ";                      wrt = (b3 * 0x100 + b4) >> 3;                      break;                  case 0x82:                      anf = "P#A ";                      wrt = (b3 * 0x100 + b4) >> 3;                      break;                  case 0x83:                      anf = "P#M ";                      wrt = (b3 * 0x100 + b4) >> 3;                      break;                  case 0x84:                      anf = "P#DBX ";                      wrt = (b3 * 0x100 + b4) >> 3;                      break;                  case 0x85:                      anf = "P#DIX ";                      wrt = (b3 * 0x100 + b4) >> 3;                      break;                  case 0x86:                      anf = "P#L ";                      wrt = (b3 * 0x100 + b4) >> 3;                      break;                  case 0x87:                      anf = "P#V "; //Lokaldata of the Previous function                      wrt = (b3 * 0x100 + b4) >> 3;                      break;                  default:                      anf = "P#";                      wrt = (b1 * 0x100 + b2);                      return anf + (wrt>>3).ToString() + "." + (wrt & 0x07).ToString();                           break;              }
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetFCPointer,The following statement contains a magic number: switch (b1)              {                                  case 0x80:                      anf = "P#PE ";                      wrt = (b3 * 0x100 + b4) >> 3;                      break;                  case 0x81:                      anf = "P#E ";                      wrt = (b3 * 0x100 + b4) >> 3;                      break;                  case 0x82:                      anf = "P#A ";                      wrt = (b3 * 0x100 + b4) >> 3;                      break;                  case 0x83:                      anf = "P#M ";                      wrt = (b3 * 0x100 + b4) >> 3;                      break;                  case 0x84:                      anf = "P#DBX ";                      wrt = (b3 * 0x100 + b4) >> 3;                      break;                  case 0x85:                      anf = "P#DIX ";                      wrt = (b3 * 0x100 + b4) >> 3;                      break;                  case 0x86:                      anf = "P#L ";                      wrt = (b3 * 0x100 + b4) >> 3;                      break;                  case 0x87:                      anf = "P#V "; //Lokaldata of the Previous function                      wrt = (b3 * 0x100 + b4) >> 3;                      break;                  default:                      anf = "P#";                      wrt = (b1 * 0x100 + b2);                      return anf + (wrt>>3).ToString() + "." + (wrt & 0x07).ToString();                           break;              }
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetFCPointer,The following statement contains a magic number: switch (b1)              {                                  case 0x80:                      anf = "P#PE ";                      wrt = (b3 * 0x100 + b4) >> 3;                      break;                  case 0x81:                      anf = "P#E ";                      wrt = (b3 * 0x100 + b4) >> 3;                      break;                  case 0x82:                      anf = "P#A ";                      wrt = (b3 * 0x100 + b4) >> 3;                      break;                  case 0x83:                      anf = "P#M ";                      wrt = (b3 * 0x100 + b4) >> 3;                      break;                  case 0x84:                      anf = "P#DBX ";                      wrt = (b3 * 0x100 + b4) >> 3;                      break;                  case 0x85:                      anf = "P#DIX ";                      wrt = (b3 * 0x100 + b4) >> 3;                      break;                  case 0x86:                      anf = "P#L ";                      wrt = (b3 * 0x100 + b4) >> 3;                      break;                  case 0x87:                      anf = "P#V "; //Lokaldata of the Previous function                      wrt = (b3 * 0x100 + b4) >> 3;                      break;                  default:                      anf = "P#";                      wrt = (b1 * 0x100 + b2);                      return anf + (wrt>>3).ToString() + "." + (wrt & 0x07).ToString();                           break;              }
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetS5TimeFromTimeSpan,The following statement contains a magic number: var wr = ts.Ticks / 100000000;
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetS5TimeFromTimeSpan,The following statement contains a magic number: ts.Ticks > ((long)10000000 * 999)
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetS5TimeFromTimeSpan,The following statement contains a magic number: ts.Ticks > ((long)10000000 * 999)
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetS5Time,The following statement contains a magic number: ms = ((b1 & 0x0F) * 100) + (((b2 & 0xF0) >> 4) * 10) + (b2 & 0x0F);
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetS5Time,The following statement contains a magic number: ms = ((b1 & 0x0F) * 100) + (((b2 & 0xF0) >> 4) * 10) + (b2 & 0x0F);
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetS5Time,The following statement contains a magic number: ms = ((b1 & 0x0F) * 100) + (((b2 & 0xF0) >> 4) * 10) + (b2 & 0x0F);
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetS5Time,The following statement contains a magic number: switch ((b1 >> 4) & 0x03)              {                  case 0x00: ms = ms * 10; break;                  case 0x01: ms = ms * 100; break;                  case 0x02: ms = ms * 1000; break;                  case 0x03: ms = ms * 10000; break;              }
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetS5Time,The following statement contains a magic number: switch ((b1 >> 4) & 0x03)              {                  case 0x00: ms = ms * 10; break;                  case 0x01: ms = ms * 100; break;                  case 0x02: ms = ms * 1000; break;                  case 0x03: ms = ms * 10000; break;              }
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetS5Time,The following statement contains a magic number: switch ((b1 >> 4) & 0x03)              {                  case 0x00: ms = ms * 10; break;                  case 0x01: ms = ms * 100; break;                  case 0x02: ms = ms * 1000; break;                  case 0x03: ms = ms * 10000; break;              }
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetS5Time,The following statement contains a magic number: switch ((b1 >> 4) & 0x03)              {                  case 0x00: ms = ms * 10; break;                  case 0x01: ms = ms * 100; break;                  case 0x02: ms = ms * 1000; break;                  case 0x03: ms = ms * 10000; break;              }
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetS5Time,The following statement contains a magic number: switch ((b1 >> 4) & 0x03)              {                  case 0x00: ms = ms * 10; break;                  case 0x01: ms = ms * 100; break;                  case 0x02: ms = ms * 1000; break;                  case 0x03: ms = ms * 10000; break;              }
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetS5Time,The following statement contains a magic number: Result = Result + Convert.ToString(ms / 3600000) + "h";
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetS5Time,The following statement contains a magic number: ms = ms - ((ms / 3600000) * 3600000);
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetS5Time,The following statement contains a magic number: ms = ms - ((ms / 3600000) * 3600000);
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetS5Time,The following statement contains a magic number: ms >= 3600000
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetS5Time,The following statement contains a magic number: Result = Result + Convert.ToString(ms / 60000) + "m";
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetS5Time,The following statement contains a magic number: ms = ms - ((ms / 60000) * 60000);
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetS5Time,The following statement contains a magic number: ms = ms - ((ms / 60000) * 60000);
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetS5Time,The following statement contains a magic number: ms >= 60000
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetS5Time,The following statement contains a magic number: Result = Result + Convert.ToString(ms / 1000) + "s";
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetS5Time,The following statement contains a magic number: ms = ms - ((ms / 1000) * 1000);
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetS5Time,The following statement contains a magic number: ms = ms - ((ms / 1000) * 1000);
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetS5Time,The following statement contains a magic number: ms >= 1000
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetPointer,The following statement contains a magic number: byte[] tmpb = new byte[] {0' BD[pos + 1]' BD[pos + 2]' BD[pos + 3]};
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetPointer,The following statement contains a magic number: byte[] tmpb = new byte[] {0' BD[pos + 1]' BD[pos + 2]' BD[pos + 3]};
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetPointer,The following statement contains a magic number: Result = Result + Convert.ToString(((int)tmp / 8)) + "." + Convert.ToString(tmp % 8);
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetPointer,The following statement contains a magic number: Result = Result + Convert.ToString(((int)tmp / 8)) + "." + Convert.ToString(tmp % 8);
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetShortPointer,The following statement contains a magic number: Result = "P#" + Convert.ToString(((int)tmp / 8)) + "." + Convert.ToString(tmp % 8);
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetShortPointer,The following statement contains a magic number: Result = "P#" + Convert.ToString(((int)tmp / 8)) + "." + Convert.ToString(tmp % 8);
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetDTime,The following statement contains a magic number: Result = Result + Convert.ToString(ms / 86400000) + "d";
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetDTime,The following statement contains a magic number: ms = ms - ((ms / 86400000) * 86400000);
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetDTime,The following statement contains a magic number: ms = ms - ((ms / 86400000) * 86400000);
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetDTime,The following statement contains a magic number: ms >= 86400000
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetDTime,The following statement contains a magic number: Result = Result + Convert.ToString(ms / 3600000) + "h";
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetDTime,The following statement contains a magic number: ms = ms - ((ms / 3600000) * 3600000);
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetDTime,The following statement contains a magic number: ms = ms - ((ms / 3600000) * 3600000);
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetDTime,The following statement contains a magic number: ms >= 3600000
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetDTime,The following statement contains a magic number: Result = Result + Convert.ToString(ms / 60000) + "m";
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetDTime,The following statement contains a magic number: ms = ms - ((ms / 60000) * 60000);
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetDTime,The following statement contains a magic number: ms = ms - ((ms / 60000) * 60000);
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetDTime,The following statement contains a magic number: ms >= 60000
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetDTime,The following statement contains a magic number: Result = Result + Convert.ToString(ms / 1000) + "s";
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetDTime,The following statement contains a magic number: ms = ms - ((ms / 1000) * 1000);
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetDTime,The following statement contains a magic number: ms = ms - ((ms / 1000) * 1000);
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetDTime,The following statement contains a magic number: ms >= 1000
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetTOD,The following statement contains a magic number: DT = new DateTime(1990' 1' 1' 0' 0' 0);
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetDate,The following statement contains a magic number: DT = new DateTime(1990' 1' 1' 0' 0' 0' 0);
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetS7String,The following statement contains a magic number: Start = Start + 2;
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,TryGetStructuredName,The following statement contains a magic number: blockAddress.ByteAddress = int.Parse(pointPosition< 0 ? address.Substring(3) : address.Substring(3' pointPosition - 3));
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,TryGetStructuredName,The following statement contains a magic number: blockAddress.ByteAddress = int.Parse(pointPosition< 0 ? address.Substring(3) : address.Substring(3' pointPosition - 3));
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,TryGetStructuredName,The following statement contains a magic number: blockAddress.ByteAddress = int.Parse(pointPosition< 0 ? address.Substring(3) : address.Substring(3' pointPosition - 3));
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,TryGetStructuredName,The following statement contains a magic number: return dbRow.StructuredName + "[" + (byteOffset - 2) + "]";
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,JumpMarks,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\JumpMarks.cs,GetJumpadresses,The following statement contains a magic number: int startJump = 2 + 2 * nwanz;
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,JumpMarks,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\JumpMarks.cs,GetJumpadresses,The following statement contains a magic number: int startJump = 2 + 2 * nwanz;
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,JumpMarks,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\JumpMarks.cs,GetJumpadresses,The following statement contains a magic number: JumpPos[i] = BitConverter.ToUInt16(BD' startJump+2 + (i * 2));
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,JumpMarks,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\JumpMarks.cs,GetJumpadresses,The following statement contains a magic number: JumpPos[i] = BitConverter.ToUInt16(BD' startJump+2 + (i * 2));
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,JumpMarks,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\JumpMarks.cs,AddJumpmarks,The following statement contains a magic number: int anzJ = BitConverter.ToInt16(JumpMarks' NetworkCount * 2);
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,JumpMarks,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\JumpMarks.cs,AddJumpmarks,The following statement contains a magic number: aknm += ((char)JumpMarks[n + 2]);
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,JumpMarks,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\JumpMarks.cs,AddJumpmarks,The following statement contains a magic number: aknm += ((char)JumpMarks[n + 3]);
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,JumpMarks,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\JumpMarks.cs,AddJumpmarks,The following statement contains a magic number: JumpMarks[n + 3] != 0
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,JumpMarks,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\JumpMarks.cs,AddJumpmarks,The following statement contains a magic number: JumpMarks[n + 2] != 0
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,JumpMarks,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\JumpMarks.cs,AddJumpmarks,The following statement contains a magic number: JumpMarks[n] != 0 && JumpMarks.Length >= n + 3
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,JumpMarks,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\JumpMarks.cs,AddJumpmarks,The following statement contains a magic number: JumpMarks != null && JumpMarks.Length >= 5
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,JumpMarks,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\JumpMarks.cs,AddJumpmarks,The following statement contains a magic number: int arrPos = Array.IndexOf<int>(jpAddr' pos/2);
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7Converter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7Converter.cs,ParseBlockHeaderAndFooterFromMC7,The following statement contains a magic number: PLCBlockType BlockType = Helper.GetPLCBlockType(MC7Code[5]);
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7Converter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7Converter.cs,ParseBlockHeaderAndFooterFromMC7,The following statement contains a magic number: retBlock.BlockVersion = Convert.ToString(MC7Code[2] - 1);
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7Converter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7Converter.cs,ParseBlockHeaderAndFooterFromMC7,The following statement contains a magic number: retBlock.BlockAttribute = (S7Block.S7BlockAtributes)MC7Code[3];
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7Converter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7Converter.cs,ParseBlockHeaderAndFooterFromMC7,The following statement contains a magic number: retBlock.BlockLanguage = (PLCLanguage)MC7Code[4];
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7Converter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7Converter.cs,ParseBlockHeaderAndFooterFromMC7,The following statement contains a magic number: retBlock.BlockType = Helper.GetPLCBlockType(MC7Code[5]);
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7Converter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7Converter.cs,ParseBlockHeaderAndFooterFromMC7,The following statement contains a magic number: retBlock.BlockNumber = (MC7Code[6] * 0x100) + MC7Code[7];
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7Converter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7Converter.cs,ParseBlockHeaderAndFooterFromMC7,The following statement contains a magic number: retBlock.BlockNumber = (MC7Code[6] * 0x100) + MC7Code[7];
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7Converter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7Converter.cs,ParseBlockHeaderAndFooterFromMC7,The following statement contains a magic number: retBlock.Length = libnodave.getU32from(MC7Code' 8);
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7Converter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7Converter.cs,ParseBlockHeaderAndFooterFromMC7,The following statement contains a magic number: retBlock.Password = new byte[] { MC7Code[12]' MC7Code[13]' MC7Code[14]' MC7Code[15] };
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7Converter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7Converter.cs,ParseBlockHeaderAndFooterFromMC7,The following statement contains a magic number: retBlock.Password = new byte[] { MC7Code[12]' MC7Code[13]' MC7Code[14]' MC7Code[15] };
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7Converter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7Converter.cs,ParseBlockHeaderAndFooterFromMC7,The following statement contains a magic number: retBlock.Password = new byte[] { MC7Code[12]' MC7Code[13]' MC7Code[14]' MC7Code[15] };
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7Converter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7Converter.cs,ParseBlockHeaderAndFooterFromMC7,The following statement contains a magic number: retBlock.Password = new byte[] { MC7Code[12]' MC7Code[13]' MC7Code[14]' MC7Code[15] };
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7Converter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7Converter.cs,ParseBlockHeaderAndFooterFromMC7,The following statement contains a magic number: retBlock.KnowHowProtection = (MC7Code[12] + MC7Code[13] + MC7Code[14] + MC7Code[15]) != 0;
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7Converter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7Converter.cs,ParseBlockHeaderAndFooterFromMC7,The following statement contains a magic number: retBlock.KnowHowProtection = (MC7Code[12] + MC7Code[13] + MC7Code[14] + MC7Code[15]) != 0;
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7Converter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7Converter.cs,ParseBlockHeaderAndFooterFromMC7,The following statement contains a magic number: retBlock.KnowHowProtection = (MC7Code[12] + MC7Code[13] + MC7Code[14] + MC7Code[15]) != 0;
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7Converter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7Converter.cs,ParseBlockHeaderAndFooterFromMC7,The following statement contains a magic number: retBlock.KnowHowProtection = (MC7Code[12] + MC7Code[13] + MC7Code[14] + MC7Code[15]) != 0;
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7Converter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7Converter.cs,ParseBlockHeaderAndFooterFromMC7,The following statement contains a magic number: retBlock.LastCodeChange = Helper.GetDT(MC7Code[16]' MC7Code[17]' MC7Code[18]' MC7Code[19]' MC7Code[20]' MC7Code[21]);
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7Converter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7Converter.cs,ParseBlockHeaderAndFooterFromMC7,The following statement contains a magic number: retBlock.LastCodeChange = Helper.GetDT(MC7Code[16]' MC7Code[17]' MC7Code[18]' MC7Code[19]' MC7Code[20]' MC7Code[21]);
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7Converter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7Converter.cs,ParseBlockHeaderAndFooterFromMC7,The following statement contains a magic number: retBlock.LastCodeChange = Helper.GetDT(MC7Code[16]' MC7Code[17]' MC7Code[18]' MC7Code[19]' MC7Code[20]' MC7Code[21]);
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7Converter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7Converter.cs,ParseBlockHeaderAndFooterFromMC7,The following statement contains a magic number: retBlock.LastCodeChange = Helper.GetDT(MC7Code[16]' MC7Code[17]' MC7Code[18]' MC7Code[19]' MC7Code[20]' MC7Code[21]);
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7Converter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7Converter.cs,ParseBlockHeaderAndFooterFromMC7,The following statement contains a magic number: retBlock.LastCodeChange = Helper.GetDT(MC7Code[16]' MC7Code[17]' MC7Code[18]' MC7Code[19]' MC7Code[20]' MC7Code[21]);
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7Converter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7Converter.cs,ParseBlockHeaderAndFooterFromMC7,The following statement contains a magic number: retBlock.LastCodeChange = Helper.GetDT(MC7Code[16]' MC7Code[17]' MC7Code[18]' MC7Code[19]' MC7Code[20]' MC7Code[21]);
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7Converter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7Converter.cs,ParseBlockHeaderAndFooterFromMC7,The following statement contains a magic number: retBlock.LastInterfaceChange = Helper.GetDT(MC7Code[22]' MC7Code[23]' MC7Code[24]' MC7Code[25]' MC7Code[26]' MC7Code[27]);
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7Converter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7Converter.cs,ParseBlockHeaderAndFooterFromMC7,The following statement contains a magic number: retBlock.LastInterfaceChange = Helper.GetDT(MC7Code[22]' MC7Code[23]' MC7Code[24]' MC7Code[25]' MC7Code[26]' MC7Code[27]);
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7Converter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7Converter.cs,ParseBlockHeaderAndFooterFromMC7,The following statement contains a magic number: retBlock.LastInterfaceChange = Helper.GetDT(MC7Code[22]' MC7Code[23]' MC7Code[24]' MC7Code[25]' MC7Code[26]' MC7Code[27]);
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7Converter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7Converter.cs,ParseBlockHeaderAndFooterFromMC7,The following statement contains a magic number: retBlock.LastInterfaceChange = Helper.GetDT(MC7Code[22]' MC7Code[23]' MC7Code[24]' MC7Code[25]' MC7Code[26]' MC7Code[27]);
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7Converter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7Converter.cs,ParseBlockHeaderAndFooterFromMC7,The following statement contains a magic number: retBlock.LastInterfaceChange = Helper.GetDT(MC7Code[22]' MC7Code[23]' MC7Code[24]' MC7Code[25]' MC7Code[26]' MC7Code[27]);
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7Converter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7Converter.cs,ParseBlockHeaderAndFooterFromMC7,The following statement contains a magic number: retBlock.LastInterfaceChange = Helper.GetDT(MC7Code[22]' MC7Code[23]' MC7Code[24]' MC7Code[25]' MC7Code[26]' MC7Code[27]);
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7Converter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7Converter.cs,ParseBlockHeaderAndFooterFromMC7,The following statement contains a magic number: int InterfaceLength_or_DBActualValuesLength = libnodave.getU16from(MC7Code' 28);
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7Converter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7Converter.cs,ParseBlockHeaderAndFooterFromMC7,The following statement contains a magic number: retBlock.SegmentTableSize = libnodave.getU16from(MC7Code' 30);
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7Converter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7Converter.cs,ParseBlockHeaderAndFooterFromMC7,The following statement contains a magic number: int LocalDataLength = libnodave.getU16from(MC7Code' 32);
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7Converter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7Converter.cs,ParseBlockHeaderAndFooterFromMC7,The following statement contains a magic number: int MC7Length_or_DBBodyLength = libnodave.getU16from(MC7Code' 34);
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7Converter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7Converter.cs,ParseBlockHeaderAndFooterFromMC7,The following statement contains a magic number: retBlock.Author = Helper.GetString(FooterStart + 0' 8' MC7Code);
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7Converter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7Converter.cs,ParseBlockHeaderAndFooterFromMC7,The following statement contains a magic number: retBlock.Family = Helper.GetString(FooterStart + 8' 8' MC7Code);
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7Converter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7Converter.cs,ParseBlockHeaderAndFooterFromMC7,The following statement contains a magic number: retBlock.Family = Helper.GetString(FooterStart + 8' 8' MC7Code);
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7Converter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7Converter.cs,ParseBlockHeaderAndFooterFromMC7,The following statement contains a magic number: retBlock.Name = Helper.GetString(FooterStart + 16' 8' MC7Code);
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7Converter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7Converter.cs,ParseBlockHeaderAndFooterFromMC7,The following statement contains a magic number: retBlock.Name = Helper.GetString(FooterStart + 16' 8' MC7Code);
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7Converter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7Converter.cs,ParseBlockHeaderAndFooterFromMC7,The following statement contains a magic number: retBlock.Version = Helper.GetVersion(MC7Code[FooterStart + 24]);
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7Converter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7Converter.cs,ParseBlockHeaderAndFooterFromMC7,The following statement contains a magic number: retBlock.CheckSum = libnodave.getU16from(MC7Code 'FooterStart + 26);
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7Converter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7Converter.cs,GetAWLBlock,The following statement contains a magic number: int IntfStart = MC7Start_or_DBBodyStart + retBlock.CodeSize + 3;
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7Converter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7Converter.cs,GetAWLBlock,The following statement contains a magic number: int IntfLength = BitConverter.ToUInt16(MC7Code' IntfStart) + 4;
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7Converter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7Converter.cs,GetAWLBlock,The following statement contains a magic number: var interfaceBytes = new byte[IntfLength + 3];
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7Converter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7Converter.cs,GetAWLBlock,The following statement contains a magic number: Array.Copy(MC7Code' IntfStart - 3' interfaceBytes' 0' IntfLength + 3);
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7Converter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7Converter.cs,GetAWLBlock,The following statement contains a magic number: Array.Copy(MC7Code' IntfStart - 3' interfaceBytes' 0' IntfLength + 3);
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7Converter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7Converter.cs,GetAWLBlock,The following statement contains a magic number: int startValueLength = BitConverter.ToUInt16(interfaceBytes' 5);
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7toAWL.cs,GetAWL,The following statement contains a magic number: pos += 2;
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7toAWL.cs,GetAWL,The following statement contains a magic number: pos <= (Start + Count) - 2
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7toAWL.cs,GetAWL,The following statement contains a magic number: jmpBytePos = akBytePos + ((tmp.JumpWidth + 1) * 4);
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7toAWL.cs,GetAWL,The following statement contains a magic number: target.Label = "M" + JumpCount.ToString().PadLeft(3' '0');
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,NetWork,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\NetWork.cs,GetNetworks,The following statement contains a magic number: Networks[i] = BitConverter.ToUInt16(BD' Start + (i*2));
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Parameter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Parameter.cs,GetInterface,The following statement contains a magic number: int InterfacePos = 7;
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Parameter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Parameter.cs,GetInterface,The following statement contains a magic number: InterfacePos <= interfaceBytes.Length - 2
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Parameter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Parameter.cs,GetVarTypeEN,The following statement contains a magic number: switch (datatype)              {                  case S7DataRowType.BOOL:                  case S7DataRowType.BYTE:                  case S7DataRowType.CHAR:                  case S7DataRowType.WORD:                  case S7DataRowType.INT:                  case S7DataRowType.DWORD:                  case S7DataRowType.DINT:                  case S7DataRowType.REAL:                  case S7DataRowType.DATE:                  case S7DataRowType.TIME_OF_DAY:                  case S7DataRowType.TIME:                  case S7DataRowType.S5TIME:                  case S7DataRowType.DATE_AND_TIME:                  case S7DataRowType.POINTER:                  case S7DataRowType.ANY:                  case S7DataRowType.COUNTER:                  case S7DataRowType.TIMER:                  case S7DataRowType.BLOCK_FB:                  case S7DataRowType.BLOCK_FC:                  case S7DataRowType.BLOCK_DB:                  case S7DataRowType.BLOCK_SDB:                      //Parese Elementary unarray datatypes from the interface                      //All above datatypes have the same format:                      //the Length of the Interface itema is always 2 bytes                      //                      //InterfacePos + 0     = Datatype: 17 for Array                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration                      //                      //if parametertype is an "Ex" version                      //InterfacePos + 0     = Datatype: 17 for Array                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration                      //InterfacePos + 2     = Seemingly Random values' with unknown meaning                        var Par = new S7DataRow(VarName' datatype' myBlk);                      ParameterType parameterType = (ParameterType)interfaceBytes[InterfacePos + 1];                        //There is also an special case for "Extended" paramters. These contain an additional value                      if (HasExtendedParameter(parameterType))                      {                          int unkwonValue = interfaceBytes[InterfacePos + 2];                          InterfacePos++; //advance parsing by one additional byte                      }                        //if the type has an Start value' then parse it from the Start values                      if (HasInitialValues(parameterType))                          Par.StartValue = GetVarInitialValue(datatype' startValueBytes' ref StartValuePos);                        currPar.Add(Par);                      InterfacePos += 2; //Interface element is always 2 bytes                      break;                    case S7DataRowType.MultiInst_FB:                  case S7DataRowType.MultiInst_SFB:                      //Parese Block datatypes  from the interface                      //All above datatypes have the same format:                      //the Length of the Interface itema is always 3 bytes                      //                      //InterfacePos + 0     = Datatype: one of the BLOCK_xx types                      //InterfacePos + 1     = Block number LSB                      //InterfacePos + 1     = Block number MSB                        Par = new S7DataRow(VarName' datatype' myBlk);                        //if the type has an Start value' then parse it from the Start values                      int BlockNumber = BitConverter.ToInt16(interfaceBytes' InterfacePos + 1);                      Par.DataTypeBlockNumber = BlockNumber;                        currPar.Add(Par);                      InterfacePos += 3; //Interface element is always 3 bytes                      break;                    case S7DataRowType.STRING:                      //Parse String definition from Interface                      //Strings are a special case and have neither the format of Elementary nor the collection types or Array types                      //the Interface itme has an fixed length of:  3                       //                      //InterfacePos + 0     = Datatype: 0x13 for String                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration                      //InterfacePos + 2     = String Length                      //                      //Parameter Type is an EX version:                      //InterfacePos + 0     = Datatype: 0x13 for String                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration                      //InterfacePos + 2     = Seemingly Random values' with unknown meaning                      //InterfacePos + 3     = String Length                        Par = new S7DataRow(VarName' datatype' myBlk);                        //There is also an special case for "Extended" paramters. These contain an additional value                      parameterType = (ParameterType)interfaceBytes[InterfacePos + 1];                      if (HasExtendedParameter(parameterType))                      {                          int unkwonValue = interfaceBytes[InterfacePos + 2];                          InterfacePos++; //advance parsing by one additional byte                      }                        Par.StringSize = interfaceBytes[InterfacePos + 2];                        if (HasInitialValues(parameterType))                          Par.StartValue = GetVarInitialValue(datatype' startValueBytes' ref StartValuePos);                        currPar.Add(Par);                      InterfacePos += 3;  //3 byte interface row length                      break;                    case S7DataRowType.ARRAY:                      //Read the Array Dimension from the Interface                      //An array has the following format                      //the Interface itme has an variable length of:  3 + (Dimensions * 4)                      //                      //InterfacePos + 0     = Datatype: 0x10 for Array                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration                      //InterfacePos + 2     = Dimensions: Amount of dimensions to be parsed                      //InterfacePos + 3-4   = Lower Bound of 1st Dimension                      //InterfacePos + 5-6   = Upper Bound of 1st Dimension                      //InterfacePos + 7-8   = Lower Bound of 2nd Dimension if any                      //InterfacePos + 9-10  = Upper Bound of 2nd Dimensino if any                      //....                            //                      //Parameter Type is an EX version:                      //InterfacePos + 0     = Datatype: 0x10 for Array                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration                      //InterfacePos + 2     = Seemingly Random values' with unknown meaning                      //InterfacePos + 3     = Dimensions: Amount of dimensions to be parsed                      //InterfacePos + 4-5   = Lower Bound of 1st Dimension                      //InterfacePos + 6-7   = Upper Bound of 1st Dimension                      //InterfacePos + 8-9   = Lower Bound of 2nd Dimension if any                      //InterfacePos + 10-11  = Upper Bound of 2nd Dimensino if any                      //....                              //There is also an special case for "Extended" paramters. These contain an additional value                      parameterType = (ParameterType)interfaceBytes[InterfacePos + 1];                      if (HasExtendedParameter(parameterType))                      {                          int unkwonValue = interfaceBytes[InterfacePos + 2];                          InterfacePos++; //advance parsing by one additional byte                      }                        int ArrayDim = interfaceBytes[InterfacePos + 2];                      List<int> arrStart = new List<int>();                      List<int> arrStop = new List<int>();                        for (int i = 0; i <= ArrayDim - 1; i++)                      {                          arrStart.Add(BitConverter.ToInt16(interfaceBytes' InterfacePos + 3 + (i * 4)));                          arrStop.Add(BitConverter.ToInt16(interfaceBytes' InterfacePos + 5 + (i * 4)));                      }                        //Parse down child elements                      InterfacePos += 3 + (ArrayDim * 4);  //3 byte array header' and every dimension has an upper and lower bound' each an Uint16                      GetVarTypeEN(currPar' (S7DataRowType)interfaceBytes[InterfacePos]' true' true' VarName' interfaceBytes' ref InterfacePos' startValueBytes' ref StartValuePos' ref ParaList' ref StackNr' VarNameGen' myBlk);                        //Mark the current Element as Array' so that the recently parsed elements are counted as Array objects                      ((S7DataRow)currPar.Children[currPar.Children.Count - 1]).ArrayStart = arrStart;                      ((S7DataRow)currPar.Children[currPar.Children.Count - 1]).ArrayStop = arrStop;                      ((S7DataRow)currPar.Children[currPar.Children.Count - 1]).IsArray = true;                        break;                    case S7DataRowType.STRUCT: //Struct                      //Structs are nested datatypes' so go one recursivly. Also UDT get converted to Structs' so they are indistiguishable from them                      //Structs have the following format:                      //Structure Interface elements have an fixed length of 3 bytes or fixed length or 5 byte if children count is greater then 255.                      //There is also an special case with 4 Bytes length                      //                      //Child count < 255:                      //InterfacePos + 0     = Datatype: 0x11 for struct                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration. NOTE it is never DBInit' which means it never has Initial values                      //InterfacePos + 2     = Children count: the amount of sub-variables declared inside the structure                      //                      //There is an Special Case when the Child amount is greater than 255 Children.                       //in that case the original childcount on InterfacePos + 2 is set to FF and the next two bytes contain the real Child count                      //                      //Child count > 255:                      //InterfacePos + 0     = Datatype: 0x11 for struct                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration. NOTE it is never DBInit' which means it never has Initial values                      //InterfacePos + 2     = Marker that there are mor children: always 255                      //InterfacePos + 3     = Child count LSB                      //InterfacePos + 4     = Child count MSB                      //                      //There is another special case' when the ParameterType is 0x14. In that case the layout is similar to the special case with more than 255 children'                      //Except that the value InterfacePos + 2 has seemingly random Values. At the moment i do not know what these values mean                      //                      //Parameter Type is an EX version:                      //InterfacePos + 0     = Datatype: 0x11 for struct                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration. NOTE it is never DBInit' which means it never has Initial values                      //InterfacePos + 2     = Seemingly Random values' with unknown meaning                      //InterfacePos + 3     = Child count                        var akPar = new S7DataRow(VarName' datatype' myBlk);                      currPar.Add(akPar);                        //There is also an special case for "Extended" paramters. These contain an additional value                      parameterType = (ParameterType)interfaceBytes[InterfacePos + 1];                      if (HasExtendedParameter(parameterType))                      {                          int unkwonValue = interfaceBytes[InterfacePos + 2];                          InterfacePos++; //advance parsing by one additional byte                      }                        //Extract Children count from interface                      int Children = interfaceBytes[InterfacePos + 2];                      if (Children == 255)                      {                          //Reparse the children count from the next two bytes as an Integer as oposed to an single byte above                          Children = BitConverter.ToUInt16(interfaceBytes' InterfacePos + 3);                          InterfacePos += 5; //5 bytes for Structure Element length if more than 255 children' so it points to the next child element                      }                      else { InterfacePos += 3; } //3 bytes for Structure Element length' so it points to the next child element                        //Continue parsing insde the new Struct                      for (int i = 0; i < Children; i++)                      {                          GetVarTypeEN(akPar' (S7DataRowType)interfaceBytes[InterfacePos]' true' false' VarNameGen.GetNextVarName()' interfaceBytes' ref InterfacePos' startValueBytes' ref StartValuePos' ref ParaList' ref StackNr' VarNameGen' myBlk);                      }                      break;                    default:                      throw new Exception(string.Format("invalid or unknown interface declarations found while parsing the block interface at pos {0} with Paratype {1} and Datatype {2}"' InterfacePos' interfaceBytes[InterfacePos + 1]' interfaceBytes[InterfacePos]));              }
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Parameter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Parameter.cs,GetVarTypeEN,The following statement contains a magic number: switch (datatype)              {                  case S7DataRowType.BOOL:                  case S7DataRowType.BYTE:                  case S7DataRowType.CHAR:                  case S7DataRowType.WORD:                  case S7DataRowType.INT:                  case S7DataRowType.DWORD:                  case S7DataRowType.DINT:                  case S7DataRowType.REAL:                  case S7DataRowType.DATE:                  case S7DataRowType.TIME_OF_DAY:                  case S7DataRowType.TIME:                  case S7DataRowType.S5TIME:                  case S7DataRowType.DATE_AND_TIME:                  case S7DataRowType.POINTER:                  case S7DataRowType.ANY:                  case S7DataRowType.COUNTER:                  case S7DataRowType.TIMER:                  case S7DataRowType.BLOCK_FB:                  case S7DataRowType.BLOCK_FC:                  case S7DataRowType.BLOCK_DB:                  case S7DataRowType.BLOCK_SDB:                      //Parese Elementary unarray datatypes from the interface                      //All above datatypes have the same format:                      //the Length of the Interface itema is always 2 bytes                      //                      //InterfacePos + 0     = Datatype: 17 for Array                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration                      //                      //if parametertype is an "Ex" version                      //InterfacePos + 0     = Datatype: 17 for Array                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration                      //InterfacePos + 2     = Seemingly Random values' with unknown meaning                        var Par = new S7DataRow(VarName' datatype' myBlk);                      ParameterType parameterType = (ParameterType)interfaceBytes[InterfacePos + 1];                        //There is also an special case for "Extended" paramters. These contain an additional value                      if (HasExtendedParameter(parameterType))                      {                          int unkwonValue = interfaceBytes[InterfacePos + 2];                          InterfacePos++; //advance parsing by one additional byte                      }                        //if the type has an Start value' then parse it from the Start values                      if (HasInitialValues(parameterType))                          Par.StartValue = GetVarInitialValue(datatype' startValueBytes' ref StartValuePos);                        currPar.Add(Par);                      InterfacePos += 2; //Interface element is always 2 bytes                      break;                    case S7DataRowType.MultiInst_FB:                  case S7DataRowType.MultiInst_SFB:                      //Parese Block datatypes  from the interface                      //All above datatypes have the same format:                      //the Length of the Interface itema is always 3 bytes                      //                      //InterfacePos + 0     = Datatype: one of the BLOCK_xx types                      //InterfacePos + 1     = Block number LSB                      //InterfacePos + 1     = Block number MSB                        Par = new S7DataRow(VarName' datatype' myBlk);                        //if the type has an Start value' then parse it from the Start values                      int BlockNumber = BitConverter.ToInt16(interfaceBytes' InterfacePos + 1);                      Par.DataTypeBlockNumber = BlockNumber;                        currPar.Add(Par);                      InterfacePos += 3; //Interface element is always 3 bytes                      break;                    case S7DataRowType.STRING:                      //Parse String definition from Interface                      //Strings are a special case and have neither the format of Elementary nor the collection types or Array types                      //the Interface itme has an fixed length of:  3                       //                      //InterfacePos + 0     = Datatype: 0x13 for String                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration                      //InterfacePos + 2     = String Length                      //                      //Parameter Type is an EX version:                      //InterfacePos + 0     = Datatype: 0x13 for String                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration                      //InterfacePos + 2     = Seemingly Random values' with unknown meaning                      //InterfacePos + 3     = String Length                        Par = new S7DataRow(VarName' datatype' myBlk);                        //There is also an special case for "Extended" paramters. These contain an additional value                      parameterType = (ParameterType)interfaceBytes[InterfacePos + 1];                      if (HasExtendedParameter(parameterType))                      {                          int unkwonValue = interfaceBytes[InterfacePos + 2];                          InterfacePos++; //advance parsing by one additional byte                      }                        Par.StringSize = interfaceBytes[InterfacePos + 2];                        if (HasInitialValues(parameterType))                          Par.StartValue = GetVarInitialValue(datatype' startValueBytes' ref StartValuePos);                        currPar.Add(Par);                      InterfacePos += 3;  //3 byte interface row length                      break;                    case S7DataRowType.ARRAY:                      //Read the Array Dimension from the Interface                      //An array has the following format                      //the Interface itme has an variable length of:  3 + (Dimensions * 4)                      //                      //InterfacePos + 0     = Datatype: 0x10 for Array                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration                      //InterfacePos + 2     = Dimensions: Amount of dimensions to be parsed                      //InterfacePos + 3-4   = Lower Bound of 1st Dimension                      //InterfacePos + 5-6   = Upper Bound of 1st Dimension                      //InterfacePos + 7-8   = Lower Bound of 2nd Dimension if any                      //InterfacePos + 9-10  = Upper Bound of 2nd Dimensino if any                      //....                            //                      //Parameter Type is an EX version:                      //InterfacePos + 0     = Datatype: 0x10 for Array                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration                      //InterfacePos + 2     = Seemingly Random values' with unknown meaning                      //InterfacePos + 3     = Dimensions: Amount of dimensions to be parsed                      //InterfacePos + 4-5   = Lower Bound of 1st Dimension                      //InterfacePos + 6-7   = Upper Bound of 1st Dimension                      //InterfacePos + 8-9   = Lower Bound of 2nd Dimension if any                      //InterfacePos + 10-11  = Upper Bound of 2nd Dimensino if any                      //....                              //There is also an special case for "Extended" paramters. These contain an additional value                      parameterType = (ParameterType)interfaceBytes[InterfacePos + 1];                      if (HasExtendedParameter(parameterType))                      {                          int unkwonValue = interfaceBytes[InterfacePos + 2];                          InterfacePos++; //advance parsing by one additional byte                      }                        int ArrayDim = interfaceBytes[InterfacePos + 2];                      List<int> arrStart = new List<int>();                      List<int> arrStop = new List<int>();                        for (int i = 0; i <= ArrayDim - 1; i++)                      {                          arrStart.Add(BitConverter.ToInt16(interfaceBytes' InterfacePos + 3 + (i * 4)));                          arrStop.Add(BitConverter.ToInt16(interfaceBytes' InterfacePos + 5 + (i * 4)));                      }                        //Parse down child elements                      InterfacePos += 3 + (ArrayDim * 4);  //3 byte array header' and every dimension has an upper and lower bound' each an Uint16                      GetVarTypeEN(currPar' (S7DataRowType)interfaceBytes[InterfacePos]' true' true' VarName' interfaceBytes' ref InterfacePos' startValueBytes' ref StartValuePos' ref ParaList' ref StackNr' VarNameGen' myBlk);                        //Mark the current Element as Array' so that the recently parsed elements are counted as Array objects                      ((S7DataRow)currPar.Children[currPar.Children.Count - 1]).ArrayStart = arrStart;                      ((S7DataRow)currPar.Children[currPar.Children.Count - 1]).ArrayStop = arrStop;                      ((S7DataRow)currPar.Children[currPar.Children.Count - 1]).IsArray = true;                        break;                    case S7DataRowType.STRUCT: //Struct                      //Structs are nested datatypes' so go one recursivly. Also UDT get converted to Structs' so they are indistiguishable from them                      //Structs have the following format:                      //Structure Interface elements have an fixed length of 3 bytes or fixed length or 5 byte if children count is greater then 255.                      //There is also an special case with 4 Bytes length                      //                      //Child count < 255:                      //InterfacePos + 0     = Datatype: 0x11 for struct                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration. NOTE it is never DBInit' which means it never has Initial values                      //InterfacePos + 2     = Children count: the amount of sub-variables declared inside the structure                      //                      //There is an Special Case when the Child amount is greater than 255 Children.                       //in that case the original childcount on InterfacePos + 2 is set to FF and the next two bytes contain the real Child count                      //                      //Child count > 255:                      //InterfacePos + 0     = Datatype: 0x11 for struct                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration. NOTE it is never DBInit' which means it never has Initial values                      //InterfacePos + 2     = Marker that there are mor children: always 255                      //InterfacePos + 3     = Child count LSB                      //InterfacePos + 4     = Child count MSB                      //                      //There is another special case' when the ParameterType is 0x14. In that case the layout is similar to the special case with more than 255 children'                      //Except that the value InterfacePos + 2 has seemingly random Values. At the moment i do not know what these values mean                      //                      //Parameter Type is an EX version:                      //InterfacePos + 0     = Datatype: 0x11 for struct                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration. NOTE it is never DBInit' which means it never has Initial values                      //InterfacePos + 2     = Seemingly Random values' with unknown meaning                      //InterfacePos + 3     = Child count                        var akPar = new S7DataRow(VarName' datatype' myBlk);                      currPar.Add(akPar);                        //There is also an special case for "Extended" paramters. These contain an additional value                      parameterType = (ParameterType)interfaceBytes[InterfacePos + 1];                      if (HasExtendedParameter(parameterType))                      {                          int unkwonValue = interfaceBytes[InterfacePos + 2];                          InterfacePos++; //advance parsing by one additional byte                      }                        //Extract Children count from interface                      int Children = interfaceBytes[InterfacePos + 2];                      if (Children == 255)                      {                          //Reparse the children count from the next two bytes as an Integer as oposed to an single byte above                          Children = BitConverter.ToUInt16(interfaceBytes' InterfacePos + 3);                          InterfacePos += 5; //5 bytes for Structure Element length if more than 255 children' so it points to the next child element                      }                      else { InterfacePos += 3; } //3 bytes for Structure Element length' so it points to the next child element                        //Continue parsing insde the new Struct                      for (int i = 0; i < Children; i++)                      {                          GetVarTypeEN(akPar' (S7DataRowType)interfaceBytes[InterfacePos]' true' false' VarNameGen.GetNextVarName()' interfaceBytes' ref InterfacePos' startValueBytes' ref StartValuePos' ref ParaList' ref StackNr' VarNameGen' myBlk);                      }                      break;                    default:                      throw new Exception(string.Format("invalid or unknown interface declarations found while parsing the block interface at pos {0} with Paratype {1} and Datatype {2}"' InterfacePos' interfaceBytes[InterfacePos + 1]' interfaceBytes[InterfacePos]));              }
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Parameter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Parameter.cs,GetVarTypeEN,The following statement contains a magic number: switch (datatype)              {                  case S7DataRowType.BOOL:                  case S7DataRowType.BYTE:                  case S7DataRowType.CHAR:                  case S7DataRowType.WORD:                  case S7DataRowType.INT:                  case S7DataRowType.DWORD:                  case S7DataRowType.DINT:                  case S7DataRowType.REAL:                  case S7DataRowType.DATE:                  case S7DataRowType.TIME_OF_DAY:                  case S7DataRowType.TIME:                  case S7DataRowType.S5TIME:                  case S7DataRowType.DATE_AND_TIME:                  case S7DataRowType.POINTER:                  case S7DataRowType.ANY:                  case S7DataRowType.COUNTER:                  case S7DataRowType.TIMER:                  case S7DataRowType.BLOCK_FB:                  case S7DataRowType.BLOCK_FC:                  case S7DataRowType.BLOCK_DB:                  case S7DataRowType.BLOCK_SDB:                      //Parese Elementary unarray datatypes from the interface                      //All above datatypes have the same format:                      //the Length of the Interface itema is always 2 bytes                      //                      //InterfacePos + 0     = Datatype: 17 for Array                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration                      //                      //if parametertype is an "Ex" version                      //InterfacePos + 0     = Datatype: 17 for Array                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration                      //InterfacePos + 2     = Seemingly Random values' with unknown meaning                        var Par = new S7DataRow(VarName' datatype' myBlk);                      ParameterType parameterType = (ParameterType)interfaceBytes[InterfacePos + 1];                        //There is also an special case for "Extended" paramters. These contain an additional value                      if (HasExtendedParameter(parameterType))                      {                          int unkwonValue = interfaceBytes[InterfacePos + 2];                          InterfacePos++; //advance parsing by one additional byte                      }                        //if the type has an Start value' then parse it from the Start values                      if (HasInitialValues(parameterType))                          Par.StartValue = GetVarInitialValue(datatype' startValueBytes' ref StartValuePos);                        currPar.Add(Par);                      InterfacePos += 2; //Interface element is always 2 bytes                      break;                    case S7DataRowType.MultiInst_FB:                  case S7DataRowType.MultiInst_SFB:                      //Parese Block datatypes  from the interface                      //All above datatypes have the same format:                      //the Length of the Interface itema is always 3 bytes                      //                      //InterfacePos + 0     = Datatype: one of the BLOCK_xx types                      //InterfacePos + 1     = Block number LSB                      //InterfacePos + 1     = Block number MSB                        Par = new S7DataRow(VarName' datatype' myBlk);                        //if the type has an Start value' then parse it from the Start values                      int BlockNumber = BitConverter.ToInt16(interfaceBytes' InterfacePos + 1);                      Par.DataTypeBlockNumber = BlockNumber;                        currPar.Add(Par);                      InterfacePos += 3; //Interface element is always 3 bytes                      break;                    case S7DataRowType.STRING:                      //Parse String definition from Interface                      //Strings are a special case and have neither the format of Elementary nor the collection types or Array types                      //the Interface itme has an fixed length of:  3                       //                      //InterfacePos + 0     = Datatype: 0x13 for String                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration                      //InterfacePos + 2     = String Length                      //                      //Parameter Type is an EX version:                      //InterfacePos + 0     = Datatype: 0x13 for String                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration                      //InterfacePos + 2     = Seemingly Random values' with unknown meaning                      //InterfacePos + 3     = String Length                        Par = new S7DataRow(VarName' datatype' myBlk);                        //There is also an special case for "Extended" paramters. These contain an additional value                      parameterType = (ParameterType)interfaceBytes[InterfacePos + 1];                      if (HasExtendedParameter(parameterType))                      {                          int unkwonValue = interfaceBytes[InterfacePos + 2];                          InterfacePos++; //advance parsing by one additional byte                      }                        Par.StringSize = interfaceBytes[InterfacePos + 2];                        if (HasInitialValues(parameterType))                          Par.StartValue = GetVarInitialValue(datatype' startValueBytes' ref StartValuePos);                        currPar.Add(Par);                      InterfacePos += 3;  //3 byte interface row length                      break;                    case S7DataRowType.ARRAY:                      //Read the Array Dimension from the Interface                      //An array has the following format                      //the Interface itme has an variable length of:  3 + (Dimensions * 4)                      //                      //InterfacePos + 0     = Datatype: 0x10 for Array                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration                      //InterfacePos + 2     = Dimensions: Amount of dimensions to be parsed                      //InterfacePos + 3-4   = Lower Bound of 1st Dimension                      //InterfacePos + 5-6   = Upper Bound of 1st Dimension                      //InterfacePos + 7-8   = Lower Bound of 2nd Dimension if any                      //InterfacePos + 9-10  = Upper Bound of 2nd Dimensino if any                      //....                            //                      //Parameter Type is an EX version:                      //InterfacePos + 0     = Datatype: 0x10 for Array                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration                      //InterfacePos + 2     = Seemingly Random values' with unknown meaning                      //InterfacePos + 3     = Dimensions: Amount of dimensions to be parsed                      //InterfacePos + 4-5   = Lower Bound of 1st Dimension                      //InterfacePos + 6-7   = Upper Bound of 1st Dimension                      //InterfacePos + 8-9   = Lower Bound of 2nd Dimension if any                      //InterfacePos + 10-11  = Upper Bound of 2nd Dimensino if any                      //....                              //There is also an special case for "Extended" paramters. These contain an additional value                      parameterType = (ParameterType)interfaceBytes[InterfacePos + 1];                      if (HasExtendedParameter(parameterType))                      {                          int unkwonValue = interfaceBytes[InterfacePos + 2];                          InterfacePos++; //advance parsing by one additional byte                      }                        int ArrayDim = interfaceBytes[InterfacePos + 2];                      List<int> arrStart = new List<int>();                      List<int> arrStop = new List<int>();                        for (int i = 0; i <= ArrayDim - 1; i++)                      {                          arrStart.Add(BitConverter.ToInt16(interfaceBytes' InterfacePos + 3 + (i * 4)));                          arrStop.Add(BitConverter.ToInt16(interfaceBytes' InterfacePos + 5 + (i * 4)));                      }                        //Parse down child elements                      InterfacePos += 3 + (ArrayDim * 4);  //3 byte array header' and every dimension has an upper and lower bound' each an Uint16                      GetVarTypeEN(currPar' (S7DataRowType)interfaceBytes[InterfacePos]' true' true' VarName' interfaceBytes' ref InterfacePos' startValueBytes' ref StartValuePos' ref ParaList' ref StackNr' VarNameGen' myBlk);                        //Mark the current Element as Array' so that the recently parsed elements are counted as Array objects                      ((S7DataRow)currPar.Children[currPar.Children.Count - 1]).ArrayStart = arrStart;                      ((S7DataRow)currPar.Children[currPar.Children.Count - 1]).ArrayStop = arrStop;                      ((S7DataRow)currPar.Children[currPar.Children.Count - 1]).IsArray = true;                        break;                    case S7DataRowType.STRUCT: //Struct                      //Structs are nested datatypes' so go one recursivly. Also UDT get converted to Structs' so they are indistiguishable from them                      //Structs have the following format:                      //Structure Interface elements have an fixed length of 3 bytes or fixed length or 5 byte if children count is greater then 255.                      //There is also an special case with 4 Bytes length                      //                      //Child count < 255:                      //InterfacePos + 0     = Datatype: 0x11 for struct                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration. NOTE it is never DBInit' which means it never has Initial values                      //InterfacePos + 2     = Children count: the amount of sub-variables declared inside the structure                      //                      //There is an Special Case when the Child amount is greater than 255 Children.                       //in that case the original childcount on InterfacePos + 2 is set to FF and the next two bytes contain the real Child count                      //                      //Child count > 255:                      //InterfacePos + 0     = Datatype: 0x11 for struct                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration. NOTE it is never DBInit' which means it never has Initial values                      //InterfacePos + 2     = Marker that there are mor children: always 255                      //InterfacePos + 3     = Child count LSB                      //InterfacePos + 4     = Child count MSB                      //                      //There is another special case' when the ParameterType is 0x14. In that case the layout is similar to the special case with more than 255 children'                      //Except that the value InterfacePos + 2 has seemingly random Values. At the moment i do not know what these values mean                      //                      //Parameter Type is an EX version:                      //InterfacePos + 0     = Datatype: 0x11 for struct                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration. NOTE it is never DBInit' which means it never has Initial values                      //InterfacePos + 2     = Seemingly Random values' with unknown meaning                      //InterfacePos + 3     = Child count                        var akPar = new S7DataRow(VarName' datatype' myBlk);                      currPar.Add(akPar);                        //There is also an special case for "Extended" paramters. These contain an additional value                      parameterType = (ParameterType)interfaceBytes[InterfacePos + 1];                      if (HasExtendedParameter(parameterType))                      {                          int unkwonValue = interfaceBytes[InterfacePos + 2];                          InterfacePos++; //advance parsing by one additional byte                      }                        //Extract Children count from interface                      int Children = interfaceBytes[InterfacePos + 2];                      if (Children == 255)                      {                          //Reparse the children count from the next two bytes as an Integer as oposed to an single byte above                          Children = BitConverter.ToUInt16(interfaceBytes' InterfacePos + 3);                          InterfacePos += 5; //5 bytes for Structure Element length if more than 255 children' so it points to the next child element                      }                      else { InterfacePos += 3; } //3 bytes for Structure Element length' so it points to the next child element                        //Continue parsing insde the new Struct                      for (int i = 0; i < Children; i++)                      {                          GetVarTypeEN(akPar' (S7DataRowType)interfaceBytes[InterfacePos]' true' false' VarNameGen.GetNextVarName()' interfaceBytes' ref InterfacePos' startValueBytes' ref StartValuePos' ref ParaList' ref StackNr' VarNameGen' myBlk);                      }                      break;                    default:                      throw new Exception(string.Format("invalid or unknown interface declarations found while parsing the block interface at pos {0} with Paratype {1} and Datatype {2}"' InterfacePos' interfaceBytes[InterfacePos + 1]' interfaceBytes[InterfacePos]));              }
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Parameter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Parameter.cs,GetVarTypeEN,The following statement contains a magic number: switch (datatype)              {                  case S7DataRowType.BOOL:                  case S7DataRowType.BYTE:                  case S7DataRowType.CHAR:                  case S7DataRowType.WORD:                  case S7DataRowType.INT:                  case S7DataRowType.DWORD:                  case S7DataRowType.DINT:                  case S7DataRowType.REAL:                  case S7DataRowType.DATE:                  case S7DataRowType.TIME_OF_DAY:                  case S7DataRowType.TIME:                  case S7DataRowType.S5TIME:                  case S7DataRowType.DATE_AND_TIME:                  case S7DataRowType.POINTER:                  case S7DataRowType.ANY:                  case S7DataRowType.COUNTER:                  case S7DataRowType.TIMER:                  case S7DataRowType.BLOCK_FB:                  case S7DataRowType.BLOCK_FC:                  case S7DataRowType.BLOCK_DB:                  case S7DataRowType.BLOCK_SDB:                      //Parese Elementary unarray datatypes from the interface                      //All above datatypes have the same format:                      //the Length of the Interface itema is always 2 bytes                      //                      //InterfacePos + 0     = Datatype: 17 for Array                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration                      //                      //if parametertype is an "Ex" version                      //InterfacePos + 0     = Datatype: 17 for Array                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration                      //InterfacePos + 2     = Seemingly Random values' with unknown meaning                        var Par = new S7DataRow(VarName' datatype' myBlk);                      ParameterType parameterType = (ParameterType)interfaceBytes[InterfacePos + 1];                        //There is also an special case for "Extended" paramters. These contain an additional value                      if (HasExtendedParameter(parameterType))                      {                          int unkwonValue = interfaceBytes[InterfacePos + 2];                          InterfacePos++; //advance parsing by one additional byte                      }                        //if the type has an Start value' then parse it from the Start values                      if (HasInitialValues(parameterType))                          Par.StartValue = GetVarInitialValue(datatype' startValueBytes' ref StartValuePos);                        currPar.Add(Par);                      InterfacePos += 2; //Interface element is always 2 bytes                      break;                    case S7DataRowType.MultiInst_FB:                  case S7DataRowType.MultiInst_SFB:                      //Parese Block datatypes  from the interface                      //All above datatypes have the same format:                      //the Length of the Interface itema is always 3 bytes                      //                      //InterfacePos + 0     = Datatype: one of the BLOCK_xx types                      //InterfacePos + 1     = Block number LSB                      //InterfacePos + 1     = Block number MSB                        Par = new S7DataRow(VarName' datatype' myBlk);                        //if the type has an Start value' then parse it from the Start values                      int BlockNumber = BitConverter.ToInt16(interfaceBytes' InterfacePos + 1);                      Par.DataTypeBlockNumber = BlockNumber;                        currPar.Add(Par);                      InterfacePos += 3; //Interface element is always 3 bytes                      break;                    case S7DataRowType.STRING:                      //Parse String definition from Interface                      //Strings are a special case and have neither the format of Elementary nor the collection types or Array types                      //the Interface itme has an fixed length of:  3                       //                      //InterfacePos + 0     = Datatype: 0x13 for String                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration                      //InterfacePos + 2     = String Length                      //                      //Parameter Type is an EX version:                      //InterfacePos + 0     = Datatype: 0x13 for String                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration                      //InterfacePos + 2     = Seemingly Random values' with unknown meaning                      //InterfacePos + 3     = String Length                        Par = new S7DataRow(VarName' datatype' myBlk);                        //There is also an special case for "Extended" paramters. These contain an additional value                      parameterType = (ParameterType)interfaceBytes[InterfacePos + 1];                      if (HasExtendedParameter(parameterType))                      {                          int unkwonValue = interfaceBytes[InterfacePos + 2];                          InterfacePos++; //advance parsing by one additional byte                      }                        Par.StringSize = interfaceBytes[InterfacePos + 2];                        if (HasInitialValues(parameterType))                          Par.StartValue = GetVarInitialValue(datatype' startValueBytes' ref StartValuePos);                        currPar.Add(Par);                      InterfacePos += 3;  //3 byte interface row length                      break;                    case S7DataRowType.ARRAY:                      //Read the Array Dimension from the Interface                      //An array has the following format                      //the Interface itme has an variable length of:  3 + (Dimensions * 4)                      //                      //InterfacePos + 0     = Datatype: 0x10 for Array                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration                      //InterfacePos + 2     = Dimensions: Amount of dimensions to be parsed                      //InterfacePos + 3-4   = Lower Bound of 1st Dimension                      //InterfacePos + 5-6   = Upper Bound of 1st Dimension                      //InterfacePos + 7-8   = Lower Bound of 2nd Dimension if any                      //InterfacePos + 9-10  = Upper Bound of 2nd Dimensino if any                      //....                            //                      //Parameter Type is an EX version:                      //InterfacePos + 0     = Datatype: 0x10 for Array                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration                      //InterfacePos + 2     = Seemingly Random values' with unknown meaning                      //InterfacePos + 3     = Dimensions: Amount of dimensions to be parsed                      //InterfacePos + 4-5   = Lower Bound of 1st Dimension                      //InterfacePos + 6-7   = Upper Bound of 1st Dimension                      //InterfacePos + 8-9   = Lower Bound of 2nd Dimension if any                      //InterfacePos + 10-11  = Upper Bound of 2nd Dimensino if any                      //....                              //There is also an special case for "Extended" paramters. These contain an additional value                      parameterType = (ParameterType)interfaceBytes[InterfacePos + 1];                      if (HasExtendedParameter(parameterType))                      {                          int unkwonValue = interfaceBytes[InterfacePos + 2];                          InterfacePos++; //advance parsing by one additional byte                      }                        int ArrayDim = interfaceBytes[InterfacePos + 2];                      List<int> arrStart = new List<int>();                      List<int> arrStop = new List<int>();                        for (int i = 0; i <= ArrayDim - 1; i++)                      {                          arrStart.Add(BitConverter.ToInt16(interfaceBytes' InterfacePos + 3 + (i * 4)));                          arrStop.Add(BitConverter.ToInt16(interfaceBytes' InterfacePos + 5 + (i * 4)));                      }                        //Parse down child elements                      InterfacePos += 3 + (ArrayDim * 4);  //3 byte array header' and every dimension has an upper and lower bound' each an Uint16                      GetVarTypeEN(currPar' (S7DataRowType)interfaceBytes[InterfacePos]' true' true' VarName' interfaceBytes' ref InterfacePos' startValueBytes' ref StartValuePos' ref ParaList' ref StackNr' VarNameGen' myBlk);                        //Mark the current Element as Array' so that the recently parsed elements are counted as Array objects                      ((S7DataRow)currPar.Children[currPar.Children.Count - 1]).ArrayStart = arrStart;                      ((S7DataRow)currPar.Children[currPar.Children.Count - 1]).ArrayStop = arrStop;                      ((S7DataRow)currPar.Children[currPar.Children.Count - 1]).IsArray = true;                        break;                    case S7DataRowType.STRUCT: //Struct                      //Structs are nested datatypes' so go one recursivly. Also UDT get converted to Structs' so they are indistiguishable from them                      //Structs have the following format:                      //Structure Interface elements have an fixed length of 3 bytes or fixed length or 5 byte if children count is greater then 255.                      //There is also an special case with 4 Bytes length                      //                      //Child count < 255:                      //InterfacePos + 0     = Datatype: 0x11 for struct                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration. NOTE it is never DBInit' which means it never has Initial values                      //InterfacePos + 2     = Children count: the amount of sub-variables declared inside the structure                      //                      //There is an Special Case when the Child amount is greater than 255 Children.                       //in that case the original childcount on InterfacePos + 2 is set to FF and the next two bytes contain the real Child count                      //                      //Child count > 255:                      //InterfacePos + 0     = Datatype: 0x11 for struct                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration. NOTE it is never DBInit' which means it never has Initial values                      //InterfacePos + 2     = Marker that there are mor children: always 255                      //InterfacePos + 3     = Child count LSB                      //InterfacePos + 4     = Child count MSB                      //                      //There is another special case' when the ParameterType is 0x14. In that case the layout is similar to the special case with more than 255 children'                      //Except that the value InterfacePos + 2 has seemingly random Values. At the moment i do not know what these values mean                      //                      //Parameter Type is an EX version:                      //InterfacePos + 0     = Datatype: 0x11 for struct                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration. NOTE it is never DBInit' which means it never has Initial values                      //InterfacePos + 2     = Seemingly Random values' with unknown meaning                      //InterfacePos + 3     = Child count                        var akPar = new S7DataRow(VarName' datatype' myBlk);                      currPar.Add(akPar);                        //There is also an special case for "Extended" paramters. These contain an additional value                      parameterType = (ParameterType)interfaceBytes[InterfacePos + 1];                      if (HasExtendedParameter(parameterType))                      {                          int unkwonValue = interfaceBytes[InterfacePos + 2];                          InterfacePos++; //advance parsing by one additional byte                      }                        //Extract Children count from interface                      int Children = interfaceBytes[InterfacePos + 2];                      if (Children == 255)                      {                          //Reparse the children count from the next two bytes as an Integer as oposed to an single byte above                          Children = BitConverter.ToUInt16(interfaceBytes' InterfacePos + 3);                          InterfacePos += 5; //5 bytes for Structure Element length if more than 255 children' so it points to the next child element                      }                      else { InterfacePos += 3; } //3 bytes for Structure Element length' so it points to the next child element                        //Continue parsing insde the new Struct                      for (int i = 0; i < Children; i++)                      {                          GetVarTypeEN(akPar' (S7DataRowType)interfaceBytes[InterfacePos]' true' false' VarNameGen.GetNextVarName()' interfaceBytes' ref InterfacePos' startValueBytes' ref StartValuePos' ref ParaList' ref StackNr' VarNameGen' myBlk);                      }                      break;                    default:                      throw new Exception(string.Format("invalid or unknown interface declarations found while parsing the block interface at pos {0} with Paratype {1} and Datatype {2}"' InterfacePos' interfaceBytes[InterfacePos + 1]' interfaceBytes[InterfacePos]));              }
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Parameter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Parameter.cs,GetVarTypeEN,The following statement contains a magic number: switch (datatype)              {                  case S7DataRowType.BOOL:                  case S7DataRowType.BYTE:                  case S7DataRowType.CHAR:                  case S7DataRowType.WORD:                  case S7DataRowType.INT:                  case S7DataRowType.DWORD:                  case S7DataRowType.DINT:                  case S7DataRowType.REAL:                  case S7DataRowType.DATE:                  case S7DataRowType.TIME_OF_DAY:                  case S7DataRowType.TIME:                  case S7DataRowType.S5TIME:                  case S7DataRowType.DATE_AND_TIME:                  case S7DataRowType.POINTER:                  case S7DataRowType.ANY:                  case S7DataRowType.COUNTER:                  case S7DataRowType.TIMER:                  case S7DataRowType.BLOCK_FB:                  case S7DataRowType.BLOCK_FC:                  case S7DataRowType.BLOCK_DB:                  case S7DataRowType.BLOCK_SDB:                      //Parese Elementary unarray datatypes from the interface                      //All above datatypes have the same format:                      //the Length of the Interface itema is always 2 bytes                      //                      //InterfacePos + 0     = Datatype: 17 for Array                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration                      //                      //if parametertype is an "Ex" version                      //InterfacePos + 0     = Datatype: 17 for Array                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration                      //InterfacePos + 2     = Seemingly Random values' with unknown meaning                        var Par = new S7DataRow(VarName' datatype' myBlk);                      ParameterType parameterType = (ParameterType)interfaceBytes[InterfacePos + 1];                        //There is also an special case for "Extended" paramters. These contain an additional value                      if (HasExtendedParameter(parameterType))                      {                          int unkwonValue = interfaceBytes[InterfacePos + 2];                          InterfacePos++; //advance parsing by one additional byte                      }                        //if the type has an Start value' then parse it from the Start values                      if (HasInitialValues(parameterType))                          Par.StartValue = GetVarInitialValue(datatype' startValueBytes' ref StartValuePos);                        currPar.Add(Par);                      InterfacePos += 2; //Interface element is always 2 bytes                      break;                    case S7DataRowType.MultiInst_FB:                  case S7DataRowType.MultiInst_SFB:                      //Parese Block datatypes  from the interface                      //All above datatypes have the same format:                      //the Length of the Interface itema is always 3 bytes                      //                      //InterfacePos + 0     = Datatype: one of the BLOCK_xx types                      //InterfacePos + 1     = Block number LSB                      //InterfacePos + 1     = Block number MSB                        Par = new S7DataRow(VarName' datatype' myBlk);                        //if the type has an Start value' then parse it from the Start values                      int BlockNumber = BitConverter.ToInt16(interfaceBytes' InterfacePos + 1);                      Par.DataTypeBlockNumber = BlockNumber;                        currPar.Add(Par);                      InterfacePos += 3; //Interface element is always 3 bytes                      break;                    case S7DataRowType.STRING:                      //Parse String definition from Interface                      //Strings are a special case and have neither the format of Elementary nor the collection types or Array types                      //the Interface itme has an fixed length of:  3                       //                      //InterfacePos + 0     = Datatype: 0x13 for String                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration                      //InterfacePos + 2     = String Length                      //                      //Parameter Type is an EX version:                      //InterfacePos + 0     = Datatype: 0x13 for String                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration                      //InterfacePos + 2     = Seemingly Random values' with unknown meaning                      //InterfacePos + 3     = String Length                        Par = new S7DataRow(VarName' datatype' myBlk);                        //There is also an special case for "Extended" paramters. These contain an additional value                      parameterType = (ParameterType)interfaceBytes[InterfacePos + 1];                      if (HasExtendedParameter(parameterType))                      {                          int unkwonValue = interfaceBytes[InterfacePos + 2];                          InterfacePos++; //advance parsing by one additional byte                      }                        Par.StringSize = interfaceBytes[InterfacePos + 2];                        if (HasInitialValues(parameterType))                          Par.StartValue = GetVarInitialValue(datatype' startValueBytes' ref StartValuePos);                        currPar.Add(Par);                      InterfacePos += 3;  //3 byte interface row length                      break;                    case S7DataRowType.ARRAY:                      //Read the Array Dimension from the Interface                      //An array has the following format                      //the Interface itme has an variable length of:  3 + (Dimensions * 4)                      //                      //InterfacePos + 0     = Datatype: 0x10 for Array                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration                      //InterfacePos + 2     = Dimensions: Amount of dimensions to be parsed                      //InterfacePos + 3-4   = Lower Bound of 1st Dimension                      //InterfacePos + 5-6   = Upper Bound of 1st Dimension                      //InterfacePos + 7-8   = Lower Bound of 2nd Dimension if any                      //InterfacePos + 9-10  = Upper Bound of 2nd Dimensino if any                      //....                            //                      //Parameter Type is an EX version:                      //InterfacePos + 0     = Datatype: 0x10 for Array                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration                      //InterfacePos + 2     = Seemingly Random values' with unknown meaning                      //InterfacePos + 3     = Dimensions: Amount of dimensions to be parsed                      //InterfacePos + 4-5   = Lower Bound of 1st Dimension                      //InterfacePos + 6-7   = Upper Bound of 1st Dimension                      //InterfacePos + 8-9   = Lower Bound of 2nd Dimension if any                      //InterfacePos + 10-11  = Upper Bound of 2nd Dimensino if any                      //....                              //There is also an special case for "Extended" paramters. These contain an additional value                      parameterType = (ParameterType)interfaceBytes[InterfacePos + 1];                      if (HasExtendedParameter(parameterType))                      {                          int unkwonValue = interfaceBytes[InterfacePos + 2];                          InterfacePos++; //advance parsing by one additional byte                      }                        int ArrayDim = interfaceBytes[InterfacePos + 2];                      List<int> arrStart = new List<int>();                      List<int> arrStop = new List<int>();                        for (int i = 0; i <= ArrayDim - 1; i++)                      {                          arrStart.Add(BitConverter.ToInt16(interfaceBytes' InterfacePos + 3 + (i * 4)));                          arrStop.Add(BitConverter.ToInt16(interfaceBytes' InterfacePos + 5 + (i * 4)));                      }                        //Parse down child elements                      InterfacePos += 3 + (ArrayDim * 4);  //3 byte array header' and every dimension has an upper and lower bound' each an Uint16                      GetVarTypeEN(currPar' (S7DataRowType)interfaceBytes[InterfacePos]' true' true' VarName' interfaceBytes' ref InterfacePos' startValueBytes' ref StartValuePos' ref ParaList' ref StackNr' VarNameGen' myBlk);                        //Mark the current Element as Array' so that the recently parsed elements are counted as Array objects                      ((S7DataRow)currPar.Children[currPar.Children.Count - 1]).ArrayStart = arrStart;                      ((S7DataRow)currPar.Children[currPar.Children.Count - 1]).ArrayStop = arrStop;                      ((S7DataRow)currPar.Children[currPar.Children.Count - 1]).IsArray = true;                        break;                    case S7DataRowType.STRUCT: //Struct                      //Structs are nested datatypes' so go one recursivly. Also UDT get converted to Structs' so they are indistiguishable from them                      //Structs have the following format:                      //Structure Interface elements have an fixed length of 3 bytes or fixed length or 5 byte if children count is greater then 255.                      //There is also an special case with 4 Bytes length                      //                      //Child count < 255:                      //InterfacePos + 0     = Datatype: 0x11 for struct                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration. NOTE it is never DBInit' which means it never has Initial values                      //InterfacePos + 2     = Children count: the amount of sub-variables declared inside the structure                      //                      //There is an Special Case when the Child amount is greater than 255 Children.                       //in that case the original childcount on InterfacePos + 2 is set to FF and the next two bytes contain the real Child count                      //                      //Child count > 255:                      //InterfacePos + 0     = Datatype: 0x11 for struct                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration. NOTE it is never DBInit' which means it never has Initial values                      //InterfacePos + 2     = Marker that there are mor children: always 255                      //InterfacePos + 3     = Child count LSB                      //InterfacePos + 4     = Child count MSB                      //                      //There is another special case' when the ParameterType is 0x14. In that case the layout is similar to the special case with more than 255 children'                      //Except that the value InterfacePos + 2 has seemingly random Values. At the moment i do not know what these values mean                      //                      //Parameter Type is an EX version:                      //InterfacePos + 0     = Datatype: 0x11 for struct                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration. NOTE it is never DBInit' which means it never has Initial values                      //InterfacePos + 2     = Seemingly Random values' with unknown meaning                      //InterfacePos + 3     = Child count                        var akPar = new S7DataRow(VarName' datatype' myBlk);                      currPar.Add(akPar);                        //There is also an special case for "Extended" paramters. These contain an additional value                      parameterType = (ParameterType)interfaceBytes[InterfacePos + 1];                      if (HasExtendedParameter(parameterType))                      {                          int unkwonValue = interfaceBytes[InterfacePos + 2];                          InterfacePos++; //advance parsing by one additional byte                      }                        //Extract Children count from interface                      int Children = interfaceBytes[InterfacePos + 2];                      if (Children == 255)                      {                          //Reparse the children count from the next two bytes as an Integer as oposed to an single byte above                          Children = BitConverter.ToUInt16(interfaceBytes' InterfacePos + 3);                          InterfacePos += 5; //5 bytes for Structure Element length if more than 255 children' so it points to the next child element                      }                      else { InterfacePos += 3; } //3 bytes for Structure Element length' so it points to the next child element                        //Continue parsing insde the new Struct                      for (int i = 0; i < Children; i++)                      {                          GetVarTypeEN(akPar' (S7DataRowType)interfaceBytes[InterfacePos]' true' false' VarNameGen.GetNextVarName()' interfaceBytes' ref InterfacePos' startValueBytes' ref StartValuePos' ref ParaList' ref StackNr' VarNameGen' myBlk);                      }                      break;                    default:                      throw new Exception(string.Format("invalid or unknown interface declarations found while parsing the block interface at pos {0} with Paratype {1} and Datatype {2}"' InterfacePos' interfaceBytes[InterfacePos + 1]' interfaceBytes[InterfacePos]));              }
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Parameter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Parameter.cs,GetVarTypeEN,The following statement contains a magic number: switch (datatype)              {                  case S7DataRowType.BOOL:                  case S7DataRowType.BYTE:                  case S7DataRowType.CHAR:                  case S7DataRowType.WORD:                  case S7DataRowType.INT:                  case S7DataRowType.DWORD:                  case S7DataRowType.DINT:                  case S7DataRowType.REAL:                  case S7DataRowType.DATE:                  case S7DataRowType.TIME_OF_DAY:                  case S7DataRowType.TIME:                  case S7DataRowType.S5TIME:                  case S7DataRowType.DATE_AND_TIME:                  case S7DataRowType.POINTER:                  case S7DataRowType.ANY:                  case S7DataRowType.COUNTER:                  case S7DataRowType.TIMER:                  case S7DataRowType.BLOCK_FB:                  case S7DataRowType.BLOCK_FC:                  case S7DataRowType.BLOCK_DB:                  case S7DataRowType.BLOCK_SDB:                      //Parese Elementary unarray datatypes from the interface                      //All above datatypes have the same format:                      //the Length of the Interface itema is always 2 bytes                      //                      //InterfacePos + 0     = Datatype: 17 for Array                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration                      //                      //if parametertype is an "Ex" version                      //InterfacePos + 0     = Datatype: 17 for Array                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration                      //InterfacePos + 2     = Seemingly Random values' with unknown meaning                        var Par = new S7DataRow(VarName' datatype' myBlk);                      ParameterType parameterType = (ParameterType)interfaceBytes[InterfacePos + 1];                        //There is also an special case for "Extended" paramters. These contain an additional value                      if (HasExtendedParameter(parameterType))                      {                          int unkwonValue = interfaceBytes[InterfacePos + 2];                          InterfacePos++; //advance parsing by one additional byte                      }                        //if the type has an Start value' then parse it from the Start values                      if (HasInitialValues(parameterType))                          Par.StartValue = GetVarInitialValue(datatype' startValueBytes' ref StartValuePos);                        currPar.Add(Par);                      InterfacePos += 2; //Interface element is always 2 bytes                      break;                    case S7DataRowType.MultiInst_FB:                  case S7DataRowType.MultiInst_SFB:                      //Parese Block datatypes  from the interface                      //All above datatypes have the same format:                      //the Length of the Interface itema is always 3 bytes                      //                      //InterfacePos + 0     = Datatype: one of the BLOCK_xx types                      //InterfacePos + 1     = Block number LSB                      //InterfacePos + 1     = Block number MSB                        Par = new S7DataRow(VarName' datatype' myBlk);                        //if the type has an Start value' then parse it from the Start values                      int BlockNumber = BitConverter.ToInt16(interfaceBytes' InterfacePos + 1);                      Par.DataTypeBlockNumber = BlockNumber;                        currPar.Add(Par);                      InterfacePos += 3; //Interface element is always 3 bytes                      break;                    case S7DataRowType.STRING:                      //Parse String definition from Interface                      //Strings are a special case and have neither the format of Elementary nor the collection types or Array types                      //the Interface itme has an fixed length of:  3                       //                      //InterfacePos + 0     = Datatype: 0x13 for String                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration                      //InterfacePos + 2     = String Length                      //                      //Parameter Type is an EX version:                      //InterfacePos + 0     = Datatype: 0x13 for String                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration                      //InterfacePos + 2     = Seemingly Random values' with unknown meaning                      //InterfacePos + 3     = String Length                        Par = new S7DataRow(VarName' datatype' myBlk);                        //There is also an special case for "Extended" paramters. These contain an additional value                      parameterType = (ParameterType)interfaceBytes[InterfacePos + 1];                      if (HasExtendedParameter(parameterType))                      {                          int unkwonValue = interfaceBytes[InterfacePos + 2];                          InterfacePos++; //advance parsing by one additional byte                      }                        Par.StringSize = interfaceBytes[InterfacePos + 2];                        if (HasInitialValues(parameterType))                          Par.StartValue = GetVarInitialValue(datatype' startValueBytes' ref StartValuePos);                        currPar.Add(Par);                      InterfacePos += 3;  //3 byte interface row length                      break;                    case S7DataRowType.ARRAY:                      //Read the Array Dimension from the Interface                      //An array has the following format                      //the Interface itme has an variable length of:  3 + (Dimensions * 4)                      //                      //InterfacePos + 0     = Datatype: 0x10 for Array                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration                      //InterfacePos + 2     = Dimensions: Amount of dimensions to be parsed                      //InterfacePos + 3-4   = Lower Bound of 1st Dimension                      //InterfacePos + 5-6   = Upper Bound of 1st Dimension                      //InterfacePos + 7-8   = Lower Bound of 2nd Dimension if any                      //InterfacePos + 9-10  = Upper Bound of 2nd Dimensino if any                      //....                            //                      //Parameter Type is an EX version:                      //InterfacePos + 0     = Datatype: 0x10 for Array                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration                      //InterfacePos + 2     = Seemingly Random values' with unknown meaning                      //InterfacePos + 3     = Dimensions: Amount of dimensions to be parsed                      //InterfacePos + 4-5   = Lower Bound of 1st Dimension                      //InterfacePos + 6-7   = Upper Bound of 1st Dimension                      //InterfacePos + 8-9   = Lower Bound of 2nd Dimension if any                      //InterfacePos + 10-11  = Upper Bound of 2nd Dimensino if any                      //....                              //There is also an special case for "Extended" paramters. These contain an additional value                      parameterType = (ParameterType)interfaceBytes[InterfacePos + 1];                      if (HasExtendedParameter(parameterType))                      {                          int unkwonValue = interfaceBytes[InterfacePos + 2];                          InterfacePos++; //advance parsing by one additional byte                      }                        int ArrayDim = interfaceBytes[InterfacePos + 2];                      List<int> arrStart = new List<int>();                      List<int> arrStop = new List<int>();                        for (int i = 0; i <= ArrayDim - 1; i++)                      {                          arrStart.Add(BitConverter.ToInt16(interfaceBytes' InterfacePos + 3 + (i * 4)));                          arrStop.Add(BitConverter.ToInt16(interfaceBytes' InterfacePos + 5 + (i * 4)));                      }                        //Parse down child elements                      InterfacePos += 3 + (ArrayDim * 4);  //3 byte array header' and every dimension has an upper and lower bound' each an Uint16                      GetVarTypeEN(currPar' (S7DataRowType)interfaceBytes[InterfacePos]' true' true' VarName' interfaceBytes' ref InterfacePos' startValueBytes' ref StartValuePos' ref ParaList' ref StackNr' VarNameGen' myBlk);                        //Mark the current Element as Array' so that the recently parsed elements are counted as Array objects                      ((S7DataRow)currPar.Children[currPar.Children.Count - 1]).ArrayStart = arrStart;                      ((S7DataRow)currPar.Children[currPar.Children.Count - 1]).ArrayStop = arrStop;                      ((S7DataRow)currPar.Children[currPar.Children.Count - 1]).IsArray = true;                        break;                    case S7DataRowType.STRUCT: //Struct                      //Structs are nested datatypes' so go one recursivly. Also UDT get converted to Structs' so they are indistiguishable from them                      //Structs have the following format:                      //Structure Interface elements have an fixed length of 3 bytes or fixed length or 5 byte if children count is greater then 255.                      //There is also an special case with 4 Bytes length                      //                      //Child count < 255:                      //InterfacePos + 0     = Datatype: 0x11 for struct                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration. NOTE it is never DBInit' which means it never has Initial values                      //InterfacePos + 2     = Children count: the amount of sub-variables declared inside the structure                      //                      //There is an Special Case when the Child amount is greater than 255 Children.                       //in that case the original childcount on InterfacePos + 2 is set to FF and the next two bytes contain the real Child count                      //                      //Child count > 255:                      //InterfacePos + 0     = Datatype: 0x11 for struct                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration. NOTE it is never DBInit' which means it never has Initial values                      //InterfacePos + 2     = Marker that there are mor children: always 255                      //InterfacePos + 3     = Child count LSB                      //InterfacePos + 4     = Child count MSB                      //                      //There is another special case' when the ParameterType is 0x14. In that case the layout is similar to the special case with more than 255 children'                      //Except that the value InterfacePos + 2 has seemingly random Values. At the moment i do not know what these values mean                      //                      //Parameter Type is an EX version:                      //InterfacePos + 0     = Datatype: 0x11 for struct                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration. NOTE it is never DBInit' which means it never has Initial values                      //InterfacePos + 2     = Seemingly Random values' with unknown meaning                      //InterfacePos + 3     = Child count                        var akPar = new S7DataRow(VarName' datatype' myBlk);                      currPar.Add(akPar);                        //There is also an special case for "Extended" paramters. These contain an additional value                      parameterType = (ParameterType)interfaceBytes[InterfacePos + 1];                      if (HasExtendedParameter(parameterType))                      {                          int unkwonValue = interfaceBytes[InterfacePos + 2];                          InterfacePos++; //advance parsing by one additional byte                      }                        //Extract Children count from interface                      int Children = interfaceBytes[InterfacePos + 2];                      if (Children == 255)                      {                          //Reparse the children count from the next two bytes as an Integer as oposed to an single byte above                          Children = BitConverter.ToUInt16(interfaceBytes' InterfacePos + 3);                          InterfacePos += 5; //5 bytes for Structure Element length if more than 255 children' so it points to the next child element                      }                      else { InterfacePos += 3; } //3 bytes for Structure Element length' so it points to the next child element                        //Continue parsing insde the new Struct                      for (int i = 0; i < Children; i++)                      {                          GetVarTypeEN(akPar' (S7DataRowType)interfaceBytes[InterfacePos]' true' false' VarNameGen.GetNextVarName()' interfaceBytes' ref InterfacePos' startValueBytes' ref StartValuePos' ref ParaList' ref StackNr' VarNameGen' myBlk);                      }                      break;                    default:                      throw new Exception(string.Format("invalid or unknown interface declarations found while parsing the block interface at pos {0} with Paratype {1} and Datatype {2}"' InterfacePos' interfaceBytes[InterfacePos + 1]' interfaceBytes[InterfacePos]));              }
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Parameter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Parameter.cs,GetVarTypeEN,The following statement contains a magic number: switch (datatype)              {                  case S7DataRowType.BOOL:                  case S7DataRowType.BYTE:                  case S7DataRowType.CHAR:                  case S7DataRowType.WORD:                  case S7DataRowType.INT:                  case S7DataRowType.DWORD:                  case S7DataRowType.DINT:                  case S7DataRowType.REAL:                  case S7DataRowType.DATE:                  case S7DataRowType.TIME_OF_DAY:                  case S7DataRowType.TIME:                  case S7DataRowType.S5TIME:                  case S7DataRowType.DATE_AND_TIME:                  case S7DataRowType.POINTER:                  case S7DataRowType.ANY:                  case S7DataRowType.COUNTER:                  case S7DataRowType.TIMER:                  case S7DataRowType.BLOCK_FB:                  case S7DataRowType.BLOCK_FC:                  case S7DataRowType.BLOCK_DB:                  case S7DataRowType.BLOCK_SDB:                      //Parese Elementary unarray datatypes from the interface                      //All above datatypes have the same format:                      //the Length of the Interface itema is always 2 bytes                      //                      //InterfacePos + 0     = Datatype: 17 for Array                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration                      //                      //if parametertype is an "Ex" version                      //InterfacePos + 0     = Datatype: 17 for Array                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration                      //InterfacePos + 2     = Seemingly Random values' with unknown meaning                        var Par = new S7DataRow(VarName' datatype' myBlk);                      ParameterType parameterType = (ParameterType)interfaceBytes[InterfacePos + 1];                        //There is also an special case for "Extended" paramters. These contain an additional value                      if (HasExtendedParameter(parameterType))                      {                          int unkwonValue = interfaceBytes[InterfacePos + 2];                          InterfacePos++; //advance parsing by one additional byte                      }                        //if the type has an Start value' then parse it from the Start values                      if (HasInitialValues(parameterType))                          Par.StartValue = GetVarInitialValue(datatype' startValueBytes' ref StartValuePos);                        currPar.Add(Par);                      InterfacePos += 2; //Interface element is always 2 bytes                      break;                    case S7DataRowType.MultiInst_FB:                  case S7DataRowType.MultiInst_SFB:                      //Parese Block datatypes  from the interface                      //All above datatypes have the same format:                      //the Length of the Interface itema is always 3 bytes                      //                      //InterfacePos + 0     = Datatype: one of the BLOCK_xx types                      //InterfacePos + 1     = Block number LSB                      //InterfacePos + 1     = Block number MSB                        Par = new S7DataRow(VarName' datatype' myBlk);                        //if the type has an Start value' then parse it from the Start values                      int BlockNumber = BitConverter.ToInt16(interfaceBytes' InterfacePos + 1);                      Par.DataTypeBlockNumber = BlockNumber;                        currPar.Add(Par);                      InterfacePos += 3; //Interface element is always 3 bytes                      break;                    case S7DataRowType.STRING:                      //Parse String definition from Interface                      //Strings are a special case and have neither the format of Elementary nor the collection types or Array types                      //the Interface itme has an fixed length of:  3                       //                      //InterfacePos + 0     = Datatype: 0x13 for String                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration                      //InterfacePos + 2     = String Length                      //                      //Parameter Type is an EX version:                      //InterfacePos + 0     = Datatype: 0x13 for String                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration                      //InterfacePos + 2     = Seemingly Random values' with unknown meaning                      //InterfacePos + 3     = String Length                        Par = new S7DataRow(VarName' datatype' myBlk);                        //There is also an special case for "Extended" paramters. These contain an additional value                      parameterType = (ParameterType)interfaceBytes[InterfacePos + 1];                      if (HasExtendedParameter(parameterType))                      {                          int unkwonValue = interfaceBytes[InterfacePos + 2];                          InterfacePos++; //advance parsing by one additional byte                      }                        Par.StringSize = interfaceBytes[InterfacePos + 2];                        if (HasInitialValues(parameterType))                          Par.StartValue = GetVarInitialValue(datatype' startValueBytes' ref StartValuePos);                        currPar.Add(Par);                      InterfacePos += 3;  //3 byte interface row length                      break;                    case S7DataRowType.ARRAY:                      //Read the Array Dimension from the Interface                      //An array has the following format                      //the Interface itme has an variable length of:  3 + (Dimensions * 4)                      //                      //InterfacePos + 0     = Datatype: 0x10 for Array                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration                      //InterfacePos + 2     = Dimensions: Amount of dimensions to be parsed                      //InterfacePos + 3-4   = Lower Bound of 1st Dimension                      //InterfacePos + 5-6   = Upper Bound of 1st Dimension                      //InterfacePos + 7-8   = Lower Bound of 2nd Dimension if any                      //InterfacePos + 9-10  = Upper Bound of 2nd Dimensino if any                      //....                            //                      //Parameter Type is an EX version:                      //InterfacePos + 0     = Datatype: 0x10 for Array                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration                      //InterfacePos + 2     = Seemingly Random values' with unknown meaning                      //InterfacePos + 3     = Dimensions: Amount of dimensions to be parsed                      //InterfacePos + 4-5   = Lower Bound of 1st Dimension                      //InterfacePos + 6-7   = Upper Bound of 1st Dimension                      //InterfacePos + 8-9   = Lower Bound of 2nd Dimension if any                      //InterfacePos + 10-11  = Upper Bound of 2nd Dimensino if any                      //....                              //There is also an special case for "Extended" paramters. These contain an additional value                      parameterType = (ParameterType)interfaceBytes[InterfacePos + 1];                      if (HasExtendedParameter(parameterType))                      {                          int unkwonValue = interfaceBytes[InterfacePos + 2];                          InterfacePos++; //advance parsing by one additional byte                      }                        int ArrayDim = interfaceBytes[InterfacePos + 2];                      List<int> arrStart = new List<int>();                      List<int> arrStop = new List<int>();                        for (int i = 0; i <= ArrayDim - 1; i++)                      {                          arrStart.Add(BitConverter.ToInt16(interfaceBytes' InterfacePos + 3 + (i * 4)));                          arrStop.Add(BitConverter.ToInt16(interfaceBytes' InterfacePos + 5 + (i * 4)));                      }                        //Parse down child elements                      InterfacePos += 3 + (ArrayDim * 4);  //3 byte array header' and every dimension has an upper and lower bound' each an Uint16                      GetVarTypeEN(currPar' (S7DataRowType)interfaceBytes[InterfacePos]' true' true' VarName' interfaceBytes' ref InterfacePos' startValueBytes' ref StartValuePos' ref ParaList' ref StackNr' VarNameGen' myBlk);                        //Mark the current Element as Array' so that the recently parsed elements are counted as Array objects                      ((S7DataRow)currPar.Children[currPar.Children.Count - 1]).ArrayStart = arrStart;                      ((S7DataRow)currPar.Children[currPar.Children.Count - 1]).ArrayStop = arrStop;                      ((S7DataRow)currPar.Children[currPar.Children.Count - 1]).IsArray = true;                        break;                    case S7DataRowType.STRUCT: //Struct                      //Structs are nested datatypes' so go one recursivly. Also UDT get converted to Structs' so they are indistiguishable from them                      //Structs have the following format:                      //Structure Interface elements have an fixed length of 3 bytes or fixed length or 5 byte if children count is greater then 255.                      //There is also an special case with 4 Bytes length                      //                      //Child count < 255:                      //InterfacePos + 0     = Datatype: 0x11 for struct                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration. NOTE it is never DBInit' which means it never has Initial values                      //InterfacePos + 2     = Children count: the amount of sub-variables declared inside the structure                      //                      //There is an Special Case when the Child amount is greater than 255 Children.                       //in that case the original childcount on InterfacePos + 2 is set to FF and the next two bytes contain the real Child count                      //                      //Child count > 255:                      //InterfacePos + 0     = Datatype: 0x11 for struct                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration. NOTE it is never DBInit' which means it never has Initial values                      //InterfacePos + 2     = Marker that there are mor children: always 255                      //InterfacePos + 3     = Child count LSB                      //InterfacePos + 4     = Child count MSB                      //                      //There is another special case' when the ParameterType is 0x14. In that case the layout is similar to the special case with more than 255 children'                      //Except that the value InterfacePos + 2 has seemingly random Values. At the moment i do not know what these values mean                      //                      //Parameter Type is an EX version:                      //InterfacePos + 0     = Datatype: 0x11 for struct                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration. NOTE it is never DBInit' which means it never has Initial values                      //InterfacePos + 2     = Seemingly Random values' with unknown meaning                      //InterfacePos + 3     = Child count                        var akPar = new S7DataRow(VarName' datatype' myBlk);                      currPar.Add(akPar);                        //There is also an special case for "Extended" paramters. These contain an additional value                      parameterType = (ParameterType)interfaceBytes[InterfacePos + 1];                      if (HasExtendedParameter(parameterType))                      {                          int unkwonValue = interfaceBytes[InterfacePos + 2];                          InterfacePos++; //advance parsing by one additional byte                      }                        //Extract Children count from interface                      int Children = interfaceBytes[InterfacePos + 2];                      if (Children == 255)                      {                          //Reparse the children count from the next two bytes as an Integer as oposed to an single byte above                          Children = BitConverter.ToUInt16(interfaceBytes' InterfacePos + 3);                          InterfacePos += 5; //5 bytes for Structure Element length if more than 255 children' so it points to the next child element                      }                      else { InterfacePos += 3; } //3 bytes for Structure Element length' so it points to the next child element                        //Continue parsing insde the new Struct                      for (int i = 0; i < Children; i++)                      {                          GetVarTypeEN(akPar' (S7DataRowType)interfaceBytes[InterfacePos]' true' false' VarNameGen.GetNextVarName()' interfaceBytes' ref InterfacePos' startValueBytes' ref StartValuePos' ref ParaList' ref StackNr' VarNameGen' myBlk);                      }                      break;                    default:                      throw new Exception(string.Format("invalid or unknown interface declarations found while parsing the block interface at pos {0} with Paratype {1} and Datatype {2}"' InterfacePos' interfaceBytes[InterfacePos + 1]' interfaceBytes[InterfacePos]));              }
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Parameter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Parameter.cs,GetVarTypeEN,The following statement contains a magic number: switch (datatype)              {                  case S7DataRowType.BOOL:                  case S7DataRowType.BYTE:                  case S7DataRowType.CHAR:                  case S7DataRowType.WORD:                  case S7DataRowType.INT:                  case S7DataRowType.DWORD:                  case S7DataRowType.DINT:                  case S7DataRowType.REAL:                  case S7DataRowType.DATE:                  case S7DataRowType.TIME_OF_DAY:                  case S7DataRowType.TIME:                  case S7DataRowType.S5TIME:                  case S7DataRowType.DATE_AND_TIME:                  case S7DataRowType.POINTER:                  case S7DataRowType.ANY:                  case S7DataRowType.COUNTER:                  case S7DataRowType.TIMER:                  case S7DataRowType.BLOCK_FB:                  case S7DataRowType.BLOCK_FC:                  case S7DataRowType.BLOCK_DB:                  case S7DataRowType.BLOCK_SDB:                      //Parese Elementary unarray datatypes from the interface                      //All above datatypes have the same format:                      //the Length of the Interface itema is always 2 bytes                      //                      //InterfacePos + 0     = Datatype: 17 for Array                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration                      //                      //if parametertype is an "Ex" version                      //InterfacePos + 0     = Datatype: 17 for Array                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration                      //InterfacePos + 2     = Seemingly Random values' with unknown meaning                        var Par = new S7DataRow(VarName' datatype' myBlk);                      ParameterType parameterType = (ParameterType)interfaceBytes[InterfacePos + 1];                        //There is also an special case for "Extended" paramters. These contain an additional value                      if (HasExtendedParameter(parameterType))                      {                          int unkwonValue = interfaceBytes[InterfacePos + 2];                          InterfacePos++; //advance parsing by one additional byte                      }                        //if the type has an Start value' then parse it from the Start values                      if (HasInitialValues(parameterType))                          Par.StartValue = GetVarInitialValue(datatype' startValueBytes' ref StartValuePos);                        currPar.Add(Par);                      InterfacePos += 2; //Interface element is always 2 bytes                      break;                    case S7DataRowType.MultiInst_FB:                  case S7DataRowType.MultiInst_SFB:                      //Parese Block datatypes  from the interface                      //All above datatypes have the same format:                      //the Length of the Interface itema is always 3 bytes                      //                      //InterfacePos + 0     = Datatype: one of the BLOCK_xx types                      //InterfacePos + 1     = Block number LSB                      //InterfacePos + 1     = Block number MSB                        Par = new S7DataRow(VarName' datatype' myBlk);                        //if the type has an Start value' then parse it from the Start values                      int BlockNumber = BitConverter.ToInt16(interfaceBytes' InterfacePos + 1);                      Par.DataTypeBlockNumber = BlockNumber;                        currPar.Add(Par);                      InterfacePos += 3; //Interface element is always 3 bytes                      break;                    case S7DataRowType.STRING:                      //Parse String definition from Interface                      //Strings are a special case and have neither the format of Elementary nor the collection types or Array types                      //the Interface itme has an fixed length of:  3                       //                      //InterfacePos + 0     = Datatype: 0x13 for String                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration                      //InterfacePos + 2     = String Length                      //                      //Parameter Type is an EX version:                      //InterfacePos + 0     = Datatype: 0x13 for String                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration                      //InterfacePos + 2     = Seemingly Random values' with unknown meaning                      //InterfacePos + 3     = String Length                        Par = new S7DataRow(VarName' datatype' myBlk);                        //There is also an special case for "Extended" paramters. These contain an additional value                      parameterType = (ParameterType)interfaceBytes[InterfacePos + 1];                      if (HasExtendedParameter(parameterType))                      {                          int unkwonValue = interfaceBytes[InterfacePos + 2];                          InterfacePos++; //advance parsing by one additional byte                      }                        Par.StringSize = interfaceBytes[InterfacePos + 2];                        if (HasInitialValues(parameterType))                          Par.StartValue = GetVarInitialValue(datatype' startValueBytes' ref StartValuePos);                        currPar.Add(Par);                      InterfacePos += 3;  //3 byte interface row length                      break;                    case S7DataRowType.ARRAY:                      //Read the Array Dimension from the Interface                      //An array has the following format                      //the Interface itme has an variable length of:  3 + (Dimensions * 4)                      //                      //InterfacePos + 0     = Datatype: 0x10 for Array                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration                      //InterfacePos + 2     = Dimensions: Amount of dimensions to be parsed                      //InterfacePos + 3-4   = Lower Bound of 1st Dimension                      //InterfacePos + 5-6   = Upper Bound of 1st Dimension                      //InterfacePos + 7-8   = Lower Bound of 2nd Dimension if any                      //InterfacePos + 9-10  = Upper Bound of 2nd Dimensino if any                      //....                            //                      //Parameter Type is an EX version:                      //InterfacePos + 0     = Datatype: 0x10 for Array                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration                      //InterfacePos + 2     = Seemingly Random values' with unknown meaning                      //InterfacePos + 3     = Dimensions: Amount of dimensions to be parsed                      //InterfacePos + 4-5   = Lower Bound of 1st Dimension                      //InterfacePos + 6-7   = Upper Bound of 1st Dimension                      //InterfacePos + 8-9   = Lower Bound of 2nd Dimension if any                      //InterfacePos + 10-11  = Upper Bound of 2nd Dimensino if any                      //....                              //There is also an special case for "Extended" paramters. These contain an additional value                      parameterType = (ParameterType)interfaceBytes[InterfacePos + 1];                      if (HasExtendedParameter(parameterType))                      {                          int unkwonValue = interfaceBytes[InterfacePos + 2];                          InterfacePos++; //advance parsing by one additional byte                      }                        int ArrayDim = interfaceBytes[InterfacePos + 2];                      List<int> arrStart = new List<int>();                      List<int> arrStop = new List<int>();                        for (int i = 0; i <= ArrayDim - 1; i++)                      {                          arrStart.Add(BitConverter.ToInt16(interfaceBytes' InterfacePos + 3 + (i * 4)));                          arrStop.Add(BitConverter.ToInt16(interfaceBytes' InterfacePos + 5 + (i * 4)));                      }                        //Parse down child elements                      InterfacePos += 3 + (ArrayDim * 4);  //3 byte array header' and every dimension has an upper and lower bound' each an Uint16                      GetVarTypeEN(currPar' (S7DataRowType)interfaceBytes[InterfacePos]' true' true' VarName' interfaceBytes' ref InterfacePos' startValueBytes' ref StartValuePos' ref ParaList' ref StackNr' VarNameGen' myBlk);                        //Mark the current Element as Array' so that the recently parsed elements are counted as Array objects                      ((S7DataRow)currPar.Children[currPar.Children.Count - 1]).ArrayStart = arrStart;                      ((S7DataRow)currPar.Children[currPar.Children.Count - 1]).ArrayStop = arrStop;                      ((S7DataRow)currPar.Children[currPar.Children.Count - 1]).IsArray = true;                        break;                    case S7DataRowType.STRUCT: //Struct                      //Structs are nested datatypes' so go one recursivly. Also UDT get converted to Structs' so they are indistiguishable from them                      //Structs have the following format:                      //Structure Interface elements have an fixed length of 3 bytes or fixed length or 5 byte if children count is greater then 255.                      //There is also an special case with 4 Bytes length                      //                      //Child count < 255:                      //InterfacePos + 0     = Datatype: 0x11 for struct                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration. NOTE it is never DBInit' which means it never has Initial values                      //InterfacePos + 2     = Children count: the amount of sub-variables declared inside the structure                      //                      //There is an Special Case when the Child amount is greater than 255 Children.                       //in that case the original childcount on InterfacePos + 2 is set to FF and the next two bytes contain the real Child count                      //                      //Child count > 255:                      //InterfacePos + 0     = Datatype: 0x11 for struct                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration. NOTE it is never DBInit' which means it never has Initial values                      //InterfacePos + 2     = Marker that there are mor children: always 255                      //InterfacePos + 3     = Child count LSB                      //InterfacePos + 4     = Child count MSB                      //                      //There is another special case' when the ParameterType is 0x14. In that case the layout is similar to the special case with more than 255 children'                      //Except that the value InterfacePos + 2 has seemingly random Values. At the moment i do not know what these values mean                      //                      //Parameter Type is an EX version:                      //InterfacePos + 0     = Datatype: 0x11 for struct                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration. NOTE it is never DBInit' which means it never has Initial values                      //InterfacePos + 2     = Seemingly Random values' with unknown meaning                      //InterfacePos + 3     = Child count                        var akPar = new S7DataRow(VarName' datatype' myBlk);                      currPar.Add(akPar);                        //There is also an special case for "Extended" paramters. These contain an additional value                      parameterType = (ParameterType)interfaceBytes[InterfacePos + 1];                      if (HasExtendedParameter(parameterType))                      {                          int unkwonValue = interfaceBytes[InterfacePos + 2];                          InterfacePos++; //advance parsing by one additional byte                      }                        //Extract Children count from interface                      int Children = interfaceBytes[InterfacePos + 2];                      if (Children == 255)                      {                          //Reparse the children count from the next two bytes as an Integer as oposed to an single byte above                          Children = BitConverter.ToUInt16(interfaceBytes' InterfacePos + 3);                          InterfacePos += 5; //5 bytes for Structure Element length if more than 255 children' so it points to the next child element                      }                      else { InterfacePos += 3; } //3 bytes for Structure Element length' so it points to the next child element                        //Continue parsing insde the new Struct                      for (int i = 0; i < Children; i++)                      {                          GetVarTypeEN(akPar' (S7DataRowType)interfaceBytes[InterfacePos]' true' false' VarNameGen.GetNextVarName()' interfaceBytes' ref InterfacePos' startValueBytes' ref StartValuePos' ref ParaList' ref StackNr' VarNameGen' myBlk);                      }                      break;                    default:                      throw new Exception(string.Format("invalid or unknown interface declarations found while parsing the block interface at pos {0} with Paratype {1} and Datatype {2}"' InterfacePos' interfaceBytes[InterfacePos + 1]' interfaceBytes[InterfacePos]));              }
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Parameter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Parameter.cs,GetVarTypeEN,The following statement contains a magic number: switch (datatype)              {                  case S7DataRowType.BOOL:                  case S7DataRowType.BYTE:                  case S7DataRowType.CHAR:                  case S7DataRowType.WORD:                  case S7DataRowType.INT:                  case S7DataRowType.DWORD:                  case S7DataRowType.DINT:                  case S7DataRowType.REAL:                  case S7DataRowType.DATE:                  case S7DataRowType.TIME_OF_DAY:                  case S7DataRowType.TIME:                  case S7DataRowType.S5TIME:                  case S7DataRowType.DATE_AND_TIME:                  case S7DataRowType.POINTER:                  case S7DataRowType.ANY:                  case S7DataRowType.COUNTER:                  case S7DataRowType.TIMER:                  case S7DataRowType.BLOCK_FB:                  case S7DataRowType.BLOCK_FC:                  case S7DataRowType.BLOCK_DB:                  case S7DataRowType.BLOCK_SDB:                      //Parese Elementary unarray datatypes from the interface                      //All above datatypes have the same format:                      //the Length of the Interface itema is always 2 bytes                      //                      //InterfacePos + 0     = Datatype: 17 for Array                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration                      //                      //if parametertype is an "Ex" version                      //InterfacePos + 0     = Datatype: 17 for Array                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration                      //InterfacePos + 2     = Seemingly Random values' with unknown meaning                        var Par = new S7DataRow(VarName' datatype' myBlk);                      ParameterType parameterType = (ParameterType)interfaceBytes[InterfacePos + 1];                        //There is also an special case for "Extended" paramters. These contain an additional value                      if (HasExtendedParameter(parameterType))                      {                          int unkwonValue = interfaceBytes[InterfacePos + 2];                          InterfacePos++; //advance parsing by one additional byte                      }                        //if the type has an Start value' then parse it from the Start values                      if (HasInitialValues(parameterType))                          Par.StartValue = GetVarInitialValue(datatype' startValueBytes' ref StartValuePos);                        currPar.Add(Par);                      InterfacePos += 2; //Interface element is always 2 bytes                      break;                    case S7DataRowType.MultiInst_FB:                  case S7DataRowType.MultiInst_SFB:                      //Parese Block datatypes  from the interface                      //All above datatypes have the same format:                      //the Length of the Interface itema is always 3 bytes                      //                      //InterfacePos + 0     = Datatype: one of the BLOCK_xx types                      //InterfacePos + 1     = Block number LSB                      //InterfacePos + 1     = Block number MSB                        Par = new S7DataRow(VarName' datatype' myBlk);                        //if the type has an Start value' then parse it from the Start values                      int BlockNumber = BitConverter.ToInt16(interfaceBytes' InterfacePos + 1);                      Par.DataTypeBlockNumber = BlockNumber;                        currPar.Add(Par);                      InterfacePos += 3; //Interface element is always 3 bytes                      break;                    case S7DataRowType.STRING:                      //Parse String definition from Interface                      //Strings are a special case and have neither the format of Elementary nor the collection types or Array types                      //the Interface itme has an fixed length of:  3                       //                      //InterfacePos + 0     = Datatype: 0x13 for String                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration                      //InterfacePos + 2     = String Length                      //                      //Parameter Type is an EX version:                      //InterfacePos + 0     = Datatype: 0x13 for String                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration                      //InterfacePos + 2     = Seemingly Random values' with unknown meaning                      //InterfacePos + 3     = String Length                        Par = new S7DataRow(VarName' datatype' myBlk);                        //There is also an special case for "Extended" paramters. These contain an additional value                      parameterType = (ParameterType)interfaceBytes[InterfacePos + 1];                      if (HasExtendedParameter(parameterType))                      {                          int unkwonValue = interfaceBytes[InterfacePos + 2];                          InterfacePos++; //advance parsing by one additional byte                      }                        Par.StringSize = interfaceBytes[InterfacePos + 2];                        if (HasInitialValues(parameterType))                          Par.StartValue = GetVarInitialValue(datatype' startValueBytes' ref StartValuePos);                        currPar.Add(Par);                      InterfacePos += 3;  //3 byte interface row length                      break;                    case S7DataRowType.ARRAY:                      //Read the Array Dimension from the Interface                      //An array has the following format                      //the Interface itme has an variable length of:  3 + (Dimensions * 4)                      //                      //InterfacePos + 0     = Datatype: 0x10 for Array                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration                      //InterfacePos + 2     = Dimensions: Amount of dimensions to be parsed                      //InterfacePos + 3-4   = Lower Bound of 1st Dimension                      //InterfacePos + 5-6   = Upper Bound of 1st Dimension                      //InterfacePos + 7-8   = Lower Bound of 2nd Dimension if any                      //InterfacePos + 9-10  = Upper Bound of 2nd Dimensino if any                      //....                            //                      //Parameter Type is an EX version:                      //InterfacePos + 0     = Datatype: 0x10 for Array                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration                      //InterfacePos + 2     = Seemingly Random values' with unknown meaning                      //InterfacePos + 3     = Dimensions: Amount of dimensions to be parsed                      //InterfacePos + 4-5   = Lower Bound of 1st Dimension                      //InterfacePos + 6-7   = Upper Bound of 1st Dimension                      //InterfacePos + 8-9   = Lower Bound of 2nd Dimension if any                      //InterfacePos + 10-11  = Upper Bound of 2nd Dimensino if any                      //....                              //There is also an special case for "Extended" paramters. These contain an additional value                      parameterType = (ParameterType)interfaceBytes[InterfacePos + 1];                      if (HasExtendedParameter(parameterType))                      {                          int unkwonValue = interfaceBytes[InterfacePos + 2];                          InterfacePos++; //advance parsing by one additional byte                      }                        int ArrayDim = interfaceBytes[InterfacePos + 2];                      List<int> arrStart = new List<int>();                      List<int> arrStop = new List<int>();                        for (int i = 0; i <= ArrayDim - 1; i++)                      {                          arrStart.Add(BitConverter.ToInt16(interfaceBytes' InterfacePos + 3 + (i * 4)));                          arrStop.Add(BitConverter.ToInt16(interfaceBytes' InterfacePos + 5 + (i * 4)));                      }                        //Parse down child elements                      InterfacePos += 3 + (ArrayDim * 4);  //3 byte array header' and every dimension has an upper and lower bound' each an Uint16                      GetVarTypeEN(currPar' (S7DataRowType)interfaceBytes[InterfacePos]' true' true' VarName' interfaceBytes' ref InterfacePos' startValueBytes' ref StartValuePos' ref ParaList' ref StackNr' VarNameGen' myBlk);                        //Mark the current Element as Array' so that the recently parsed elements are counted as Array objects                      ((S7DataRow)currPar.Children[currPar.Children.Count - 1]).ArrayStart = arrStart;                      ((S7DataRow)currPar.Children[currPar.Children.Count - 1]).ArrayStop = arrStop;                      ((S7DataRow)currPar.Children[currPar.Children.Count - 1]).IsArray = true;                        break;                    case S7DataRowType.STRUCT: //Struct                      //Structs are nested datatypes' so go one recursivly. Also UDT get converted to Structs' so they are indistiguishable from them                      //Structs have the following format:                      //Structure Interface elements have an fixed length of 3 bytes or fixed length or 5 byte if children count is greater then 255.                      //There is also an special case with 4 Bytes length                      //                      //Child count < 255:                      //InterfacePos + 0     = Datatype: 0x11 for struct                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration. NOTE it is never DBInit' which means it never has Initial values                      //InterfacePos + 2     = Children count: the amount of sub-variables declared inside the structure                      //                      //There is an Special Case when the Child amount is greater than 255 Children.                       //in that case the original childcount on InterfacePos + 2 is set to FF and the next two bytes contain the real Child count                      //                      //Child count > 255:                      //InterfacePos + 0     = Datatype: 0x11 for struct                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration. NOTE it is never DBInit' which means it never has Initial values                      //InterfacePos + 2     = Marker that there are mor children: always 255                      //InterfacePos + 3     = Child count LSB                      //InterfacePos + 4     = Child count MSB                      //                      //There is another special case' when the ParameterType is 0x14. In that case the layout is similar to the special case with more than 255 children'                      //Except that the value InterfacePos + 2 has seemingly random Values. At the moment i do not know what these values mean                      //                      //Parameter Type is an EX version:                      //InterfacePos + 0     = Datatype: 0x11 for struct                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration. NOTE it is never DBInit' which means it never has Initial values                      //InterfacePos + 2     = Seemingly Random values' with unknown meaning                      //InterfacePos + 3     = Child count                        var akPar = new S7DataRow(VarName' datatype' myBlk);                      currPar.Add(akPar);                        //There is also an special case for "Extended" paramters. These contain an additional value                      parameterType = (ParameterType)interfaceBytes[InterfacePos + 1];                      if (HasExtendedParameter(parameterType))                      {                          int unkwonValue = interfaceBytes[InterfacePos + 2];                          InterfacePos++; //advance parsing by one additional byte                      }                        //Extract Children count from interface                      int Children = interfaceBytes[InterfacePos + 2];                      if (Children == 255)                      {                          //Reparse the children count from the next two bytes as an Integer as oposed to an single byte above                          Children = BitConverter.ToUInt16(interfaceBytes' InterfacePos + 3);                          InterfacePos += 5; //5 bytes for Structure Element length if more than 255 children' so it points to the next child element                      }                      else { InterfacePos += 3; } //3 bytes for Structure Element length' so it points to the next child element                        //Continue parsing insde the new Struct                      for (int i = 0; i < Children; i++)                      {                          GetVarTypeEN(akPar' (S7DataRowType)interfaceBytes[InterfacePos]' true' false' VarNameGen.GetNextVarName()' interfaceBytes' ref InterfacePos' startValueBytes' ref StartValuePos' ref ParaList' ref StackNr' VarNameGen' myBlk);                      }                      break;                    default:                      throw new Exception(string.Format("invalid or unknown interface declarations found while parsing the block interface at pos {0} with Paratype {1} and Datatype {2}"' InterfacePos' interfaceBytes[InterfacePos + 1]' interfaceBytes[InterfacePos]));              }
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Parameter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Parameter.cs,GetVarTypeEN,The following statement contains a magic number: switch (datatype)              {                  case S7DataRowType.BOOL:                  case S7DataRowType.BYTE:                  case S7DataRowType.CHAR:                  case S7DataRowType.WORD:                  case S7DataRowType.INT:                  case S7DataRowType.DWORD:                  case S7DataRowType.DINT:                  case S7DataRowType.REAL:                  case S7DataRowType.DATE:                  case S7DataRowType.TIME_OF_DAY:                  case S7DataRowType.TIME:                  case S7DataRowType.S5TIME:                  case S7DataRowType.DATE_AND_TIME:                  case S7DataRowType.POINTER:                  case S7DataRowType.ANY:                  case S7DataRowType.COUNTER:                  case S7DataRowType.TIMER:                  case S7DataRowType.BLOCK_FB:                  case S7DataRowType.BLOCK_FC:                  case S7DataRowType.BLOCK_DB:                  case S7DataRowType.BLOCK_SDB:                      //Parese Elementary unarray datatypes from the interface                      //All above datatypes have the same format:                      //the Length of the Interface itema is always 2 bytes                      //                      //InterfacePos + 0     = Datatype: 17 for Array                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration                      //                      //if parametertype is an "Ex" version                      //InterfacePos + 0     = Datatype: 17 for Array                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration                      //InterfacePos + 2     = Seemingly Random values' with unknown meaning                        var Par = new S7DataRow(VarName' datatype' myBlk);                      ParameterType parameterType = (ParameterType)interfaceBytes[InterfacePos + 1];                        //There is also an special case for "Extended" paramters. These contain an additional value                      if (HasExtendedParameter(parameterType))                      {                          int unkwonValue = interfaceBytes[InterfacePos + 2];                          InterfacePos++; //advance parsing by one additional byte                      }                        //if the type has an Start value' then parse it from the Start values                      if (HasInitialValues(parameterType))                          Par.StartValue = GetVarInitialValue(datatype' startValueBytes' ref StartValuePos);                        currPar.Add(Par);                      InterfacePos += 2; //Interface element is always 2 bytes                      break;                    case S7DataRowType.MultiInst_FB:                  case S7DataRowType.MultiInst_SFB:                      //Parese Block datatypes  from the interface                      //All above datatypes have the same format:                      //the Length of the Interface itema is always 3 bytes                      //                      //InterfacePos + 0     = Datatype: one of the BLOCK_xx types                      //InterfacePos + 1     = Block number LSB                      //InterfacePos + 1     = Block number MSB                        Par = new S7DataRow(VarName' datatype' myBlk);                        //if the type has an Start value' then parse it from the Start values                      int BlockNumber = BitConverter.ToInt16(interfaceBytes' InterfacePos + 1);                      Par.DataTypeBlockNumber = BlockNumber;                        currPar.Add(Par);                      InterfacePos += 3; //Interface element is always 3 bytes                      break;                    case S7DataRowType.STRING:                      //Parse String definition from Interface                      //Strings are a special case and have neither the format of Elementary nor the collection types or Array types                      //the Interface itme has an fixed length of:  3                       //                      //InterfacePos + 0     = Datatype: 0x13 for String                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration                      //InterfacePos + 2     = String Length                      //                      //Parameter Type is an EX version:                      //InterfacePos + 0     = Datatype: 0x13 for String                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration                      //InterfacePos + 2     = Seemingly Random values' with unknown meaning                      //InterfacePos + 3     = String Length                        Par = new S7DataRow(VarName' datatype' myBlk);                        //There is also an special case for "Extended" paramters. These contain an additional value                      parameterType = (ParameterType)interfaceBytes[InterfacePos + 1];                      if (HasExtendedParameter(parameterType))                      {                          int unkwonValue = interfaceBytes[InterfacePos + 2];                          InterfacePos++; //advance parsing by one additional byte                      }                        Par.StringSize = interfaceBytes[InterfacePos + 2];                        if (HasInitialValues(parameterType))                          Par.StartValue = GetVarInitialValue(datatype' startValueBytes' ref StartValuePos);                        currPar.Add(Par);                      InterfacePos += 3;  //3 byte interface row length                      break;                    case S7DataRowType.ARRAY:                      //Read the Array Dimension from the Interface                      //An array has the following format                      //the Interface itme has an variable length of:  3 + (Dimensions * 4)                      //                      //InterfacePos + 0     = Datatype: 0x10 for Array                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration                      //InterfacePos + 2     = Dimensions: Amount of dimensions to be parsed                      //InterfacePos + 3-4   = Lower Bound of 1st Dimension                      //InterfacePos + 5-6   = Upper Bound of 1st Dimension                      //InterfacePos + 7-8   = Lower Bound of 2nd Dimension if any                      //InterfacePos + 9-10  = Upper Bound of 2nd Dimensino if any                      //....                            //                      //Parameter Type is an EX version:                      //InterfacePos + 0     = Datatype: 0x10 for Array                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration                      //InterfacePos + 2     = Seemingly Random values' with unknown meaning                      //InterfacePos + 3     = Dimensions: Amount of dimensions to be parsed                      //InterfacePos + 4-5   = Lower Bound of 1st Dimension                      //InterfacePos + 6-7   = Upper Bound of 1st Dimension                      //InterfacePos + 8-9   = Lower Bound of 2nd Dimension if any                      //InterfacePos + 10-11  = Upper Bound of 2nd Dimensino if any                      //....                              //There is also an special case for "Extended" paramters. These contain an additional value                      parameterType = (ParameterType)interfaceBytes[InterfacePos + 1];                      if (HasExtendedParameter(parameterType))                      {                          int unkwonValue = interfaceBytes[InterfacePos + 2];                          InterfacePos++; //advance parsing by one additional byte                      }                        int ArrayDim = interfaceBytes[InterfacePos + 2];                      List<int> arrStart = new List<int>();                      List<int> arrStop = new List<int>();                        for (int i = 0; i <= ArrayDim - 1; i++)                      {                          arrStart.Add(BitConverter.ToInt16(interfaceBytes' InterfacePos + 3 + (i * 4)));                          arrStop.Add(BitConverter.ToInt16(interfaceBytes' InterfacePos + 5 + (i * 4)));                      }                        //Parse down child elements                      InterfacePos += 3 + (ArrayDim * 4);  //3 byte array header' and every dimension has an upper and lower bound' each an Uint16                      GetVarTypeEN(currPar' (S7DataRowType)interfaceBytes[InterfacePos]' true' true' VarName' interfaceBytes' ref InterfacePos' startValueBytes' ref StartValuePos' ref ParaList' ref StackNr' VarNameGen' myBlk);                        //Mark the current Element as Array' so that the recently parsed elements are counted as Array objects                      ((S7DataRow)currPar.Children[currPar.Children.Count - 1]).ArrayStart = arrStart;                      ((S7DataRow)currPar.Children[currPar.Children.Count - 1]).ArrayStop = arrStop;                      ((S7DataRow)currPar.Children[currPar.Children.Count - 1]).IsArray = true;                        break;                    case S7DataRowType.STRUCT: //Struct                      //Structs are nested datatypes' so go one recursivly. Also UDT get converted to Structs' so they are indistiguishable from them                      //Structs have the following format:                      //Structure Interface elements have an fixed length of 3 bytes or fixed length or 5 byte if children count is greater then 255.                      //There is also an special case with 4 Bytes length                      //                      //Child count < 255:                      //InterfacePos + 0     = Datatype: 0x11 for struct                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration. NOTE it is never DBInit' which means it never has Initial values                      //InterfacePos + 2     = Children count: the amount of sub-variables declared inside the structure                      //                      //There is an Special Case when the Child amount is greater than 255 Children.                       //in that case the original childcount on InterfacePos + 2 is set to FF and the next two bytes contain the real Child count                      //                      //Child count > 255:                      //InterfacePos + 0     = Datatype: 0x11 for struct                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration. NOTE it is never DBInit' which means it never has Initial values                      //InterfacePos + 2     = Marker that there are mor children: always 255                      //InterfacePos + 3     = Child count LSB                      //InterfacePos + 4     = Child count MSB                      //                      //There is another special case' when the ParameterType is 0x14. In that case the layout is similar to the special case with more than 255 children'                      //Except that the value InterfacePos + 2 has seemingly random Values. At the moment i do not know what these values mean                      //                      //Parameter Type is an EX version:                      //InterfacePos + 0     = Datatype: 0x11 for struct                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration. NOTE it is never DBInit' which means it never has Initial values                      //InterfacePos + 2     = Seemingly Random values' with unknown meaning                      //InterfacePos + 3     = Child count                        var akPar = new S7DataRow(VarName' datatype' myBlk);                      currPar.Add(akPar);                        //There is also an special case for "Extended" paramters. These contain an additional value                      parameterType = (ParameterType)interfaceBytes[InterfacePos + 1];                      if (HasExtendedParameter(parameterType))                      {                          int unkwonValue = interfaceBytes[InterfacePos + 2];                          InterfacePos++; //advance parsing by one additional byte                      }                        //Extract Children count from interface                      int Children = interfaceBytes[InterfacePos + 2];                      if (Children == 255)                      {                          //Reparse the children count from the next two bytes as an Integer as oposed to an single byte above                          Children = BitConverter.ToUInt16(interfaceBytes' InterfacePos + 3);                          InterfacePos += 5; //5 bytes for Structure Element length if more than 255 children' so it points to the next child element                      }                      else { InterfacePos += 3; } //3 bytes for Structure Element length' so it points to the next child element                        //Continue parsing insde the new Struct                      for (int i = 0; i < Children; i++)                      {                          GetVarTypeEN(akPar' (S7DataRowType)interfaceBytes[InterfacePos]' true' false' VarNameGen.GetNextVarName()' interfaceBytes' ref InterfacePos' startValueBytes' ref StartValuePos' ref ParaList' ref StackNr' VarNameGen' myBlk);                      }                      break;                    default:                      throw new Exception(string.Format("invalid or unknown interface declarations found while parsing the block interface at pos {0} with Paratype {1} and Datatype {2}"' InterfacePos' interfaceBytes[InterfacePos + 1]' interfaceBytes[InterfacePos]));              }
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Parameter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Parameter.cs,GetVarTypeEN,The following statement contains a magic number: switch (datatype)              {                  case S7DataRowType.BOOL:                  case S7DataRowType.BYTE:                  case S7DataRowType.CHAR:                  case S7DataRowType.WORD:                  case S7DataRowType.INT:                  case S7DataRowType.DWORD:                  case S7DataRowType.DINT:                  case S7DataRowType.REAL:                  case S7DataRowType.DATE:                  case S7DataRowType.TIME_OF_DAY:                  case S7DataRowType.TIME:                  case S7DataRowType.S5TIME:                  case S7DataRowType.DATE_AND_TIME:                  case S7DataRowType.POINTER:                  case S7DataRowType.ANY:                  case S7DataRowType.COUNTER:                  case S7DataRowType.TIMER:                  case S7DataRowType.BLOCK_FB:                  case S7DataRowType.BLOCK_FC:                  case S7DataRowType.BLOCK_DB:                  case S7DataRowType.BLOCK_SDB:                      //Parese Elementary unarray datatypes from the interface                      //All above datatypes have the same format:                      //the Length of the Interface itema is always 2 bytes                      //                      //InterfacePos + 0     = Datatype: 17 for Array                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration                      //                      //if parametertype is an "Ex" version                      //InterfacePos + 0     = Datatype: 17 for Array                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration                      //InterfacePos + 2     = Seemingly Random values' with unknown meaning                        var Par = new S7DataRow(VarName' datatype' myBlk);                      ParameterType parameterType = (ParameterType)interfaceBytes[InterfacePos + 1];                        //There is also an special case for "Extended" paramters. These contain an additional value                      if (HasExtendedParameter(parameterType))                      {                          int unkwonValue = interfaceBytes[InterfacePos + 2];                          InterfacePos++; //advance parsing by one additional byte                      }                        //if the type has an Start value' then parse it from the Start values                      if (HasInitialValues(parameterType))                          Par.StartValue = GetVarInitialValue(datatype' startValueBytes' ref StartValuePos);                        currPar.Add(Par);                      InterfacePos += 2; //Interface element is always 2 bytes                      break;                    case S7DataRowType.MultiInst_FB:                  case S7DataRowType.MultiInst_SFB:                      //Parese Block datatypes  from the interface                      //All above datatypes have the same format:                      //the Length of the Interface itema is always 3 bytes                      //                      //InterfacePos + 0     = Datatype: one of the BLOCK_xx types                      //InterfacePos + 1     = Block number LSB                      //InterfacePos + 1     = Block number MSB                        Par = new S7DataRow(VarName' datatype' myBlk);                        //if the type has an Start value' then parse it from the Start values                      int BlockNumber = BitConverter.ToInt16(interfaceBytes' InterfacePos + 1);                      Par.DataTypeBlockNumber = BlockNumber;                        currPar.Add(Par);                      InterfacePos += 3; //Interface element is always 3 bytes                      break;                    case S7DataRowType.STRING:                      //Parse String definition from Interface                      //Strings are a special case and have neither the format of Elementary nor the collection types or Array types                      //the Interface itme has an fixed length of:  3                       //                      //InterfacePos + 0     = Datatype: 0x13 for String                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration                      //InterfacePos + 2     = String Length                      //                      //Parameter Type is an EX version:                      //InterfacePos + 0     = Datatype: 0x13 for String                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration                      //InterfacePos + 2     = Seemingly Random values' with unknown meaning                      //InterfacePos + 3     = String Length                        Par = new S7DataRow(VarName' datatype' myBlk);                        //There is also an special case for "Extended" paramters. These contain an additional value                      parameterType = (ParameterType)interfaceBytes[InterfacePos + 1];                      if (HasExtendedParameter(parameterType))                      {                          int unkwonValue = interfaceBytes[InterfacePos + 2];                          InterfacePos++; //advance parsing by one additional byte                      }                        Par.StringSize = interfaceBytes[InterfacePos + 2];                        if (HasInitialValues(parameterType))                          Par.StartValue = GetVarInitialValue(datatype' startValueBytes' ref StartValuePos);                        currPar.Add(Par);                      InterfacePos += 3;  //3 byte interface row length                      break;                    case S7DataRowType.ARRAY:                      //Read the Array Dimension from the Interface                      //An array has the following format                      //the Interface itme has an variable length of:  3 + (Dimensions * 4)                      //                      //InterfacePos + 0     = Datatype: 0x10 for Array                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration                      //InterfacePos + 2     = Dimensions: Amount of dimensions to be parsed                      //InterfacePos + 3-4   = Lower Bound of 1st Dimension                      //InterfacePos + 5-6   = Upper Bound of 1st Dimension                      //InterfacePos + 7-8   = Lower Bound of 2nd Dimension if any                      //InterfacePos + 9-10  = Upper Bound of 2nd Dimensino if any                      //....                            //                      //Parameter Type is an EX version:                      //InterfacePos + 0     = Datatype: 0x10 for Array                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration                      //InterfacePos + 2     = Seemingly Random values' with unknown meaning                      //InterfacePos + 3     = Dimensions: Amount of dimensions to be parsed                      //InterfacePos + 4-5   = Lower Bound of 1st Dimension                      //InterfacePos + 6-7   = Upper Bound of 1st Dimension                      //InterfacePos + 8-9   = Lower Bound of 2nd Dimension if any                      //InterfacePos + 10-11  = Upper Bound of 2nd Dimensino if any                      //....                              //There is also an special case for "Extended" paramters. These contain an additional value                      parameterType = (ParameterType)interfaceBytes[InterfacePos + 1];                      if (HasExtendedParameter(parameterType))                      {                          int unkwonValue = interfaceBytes[InterfacePos + 2];                          InterfacePos++; //advance parsing by one additional byte                      }                        int ArrayDim = interfaceBytes[InterfacePos + 2];                      List<int> arrStart = new List<int>();                      List<int> arrStop = new List<int>();                        for (int i = 0; i <= ArrayDim - 1; i++)                      {                          arrStart.Add(BitConverter.ToInt16(interfaceBytes' InterfacePos + 3 + (i * 4)));                          arrStop.Add(BitConverter.ToInt16(interfaceBytes' InterfacePos + 5 + (i * 4)));                      }                        //Parse down child elements                      InterfacePos += 3 + (ArrayDim * 4);  //3 byte array header' and every dimension has an upper and lower bound' each an Uint16                      GetVarTypeEN(currPar' (S7DataRowType)interfaceBytes[InterfacePos]' true' true' VarName' interfaceBytes' ref InterfacePos' startValueBytes' ref StartValuePos' ref ParaList' ref StackNr' VarNameGen' myBlk);                        //Mark the current Element as Array' so that the recently parsed elements are counted as Array objects                      ((S7DataRow)currPar.Children[currPar.Children.Count - 1]).ArrayStart = arrStart;                      ((S7DataRow)currPar.Children[currPar.Children.Count - 1]).ArrayStop = arrStop;                      ((S7DataRow)currPar.Children[currPar.Children.Count - 1]).IsArray = true;                        break;                    case S7DataRowType.STRUCT: //Struct                      //Structs are nested datatypes' so go one recursivly. Also UDT get converted to Structs' so they are indistiguishable from them                      //Structs have the following format:                      //Structure Interface elements have an fixed length of 3 bytes or fixed length or 5 byte if children count is greater then 255.                      //There is also an special case with 4 Bytes length                      //                      //Child count < 255:                      //InterfacePos + 0     = Datatype: 0x11 for struct                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration. NOTE it is never DBInit' which means it never has Initial values                      //InterfacePos + 2     = Children count: the amount of sub-variables declared inside the structure                      //                      //There is an Special Case when the Child amount is greater than 255 Children.                       //in that case the original childcount on InterfacePos + 2 is set to FF and the next two bytes contain the real Child count                      //                      //Child count > 255:                      //InterfacePos + 0     = Datatype: 0x11 for struct                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration. NOTE it is never DBInit' which means it never has Initial values                      //InterfacePos + 2     = Marker that there are mor children: always 255                      //InterfacePos + 3     = Child count LSB                      //InterfacePos + 4     = Child count MSB                      //                      //There is another special case' when the ParameterType is 0x14. In that case the layout is similar to the special case with more than 255 children'                      //Except that the value InterfacePos + 2 has seemingly random Values. At the moment i do not know what these values mean                      //                      //Parameter Type is an EX version:                      //InterfacePos + 0     = Datatype: 0x11 for struct                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration. NOTE it is never DBInit' which means it never has Initial values                      //InterfacePos + 2     = Seemingly Random values' with unknown meaning                      //InterfacePos + 3     = Child count                        var akPar = new S7DataRow(VarName' datatype' myBlk);                      currPar.Add(akPar);                        //There is also an special case for "Extended" paramters. These contain an additional value                      parameterType = (ParameterType)interfaceBytes[InterfacePos + 1];                      if (HasExtendedParameter(parameterType))                      {                          int unkwonValue = interfaceBytes[InterfacePos + 2];                          InterfacePos++; //advance parsing by one additional byte                      }                        //Extract Children count from interface                      int Children = interfaceBytes[InterfacePos + 2];                      if (Children == 255)                      {                          //Reparse the children count from the next two bytes as an Integer as oposed to an single byte above                          Children = BitConverter.ToUInt16(interfaceBytes' InterfacePos + 3);                          InterfacePos += 5; //5 bytes for Structure Element length if more than 255 children' so it points to the next child element                      }                      else { InterfacePos += 3; } //3 bytes for Structure Element length' so it points to the next child element                        //Continue parsing insde the new Struct                      for (int i = 0; i < Children; i++)                      {                          GetVarTypeEN(akPar' (S7DataRowType)interfaceBytes[InterfacePos]' true' false' VarNameGen.GetNextVarName()' interfaceBytes' ref InterfacePos' startValueBytes' ref StartValuePos' ref ParaList' ref StackNr' VarNameGen' myBlk);                      }                      break;                    default:                      throw new Exception(string.Format("invalid or unknown interface declarations found while parsing the block interface at pos {0} with Paratype {1} and Datatype {2}"' InterfacePos' interfaceBytes[InterfacePos + 1]' interfaceBytes[InterfacePos]));              }
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Parameter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Parameter.cs,GetVarTypeEN,The following statement contains a magic number: switch (datatype)              {                  case S7DataRowType.BOOL:                  case S7DataRowType.BYTE:                  case S7DataRowType.CHAR:                  case S7DataRowType.WORD:                  case S7DataRowType.INT:                  case S7DataRowType.DWORD:                  case S7DataRowType.DINT:                  case S7DataRowType.REAL:                  case S7DataRowType.DATE:                  case S7DataRowType.TIME_OF_DAY:                  case S7DataRowType.TIME:                  case S7DataRowType.S5TIME:                  case S7DataRowType.DATE_AND_TIME:                  case S7DataRowType.POINTER:                  case S7DataRowType.ANY:                  case S7DataRowType.COUNTER:                  case S7DataRowType.TIMER:                  case S7DataRowType.BLOCK_FB:                  case S7DataRowType.BLOCK_FC:                  case S7DataRowType.BLOCK_DB:                  case S7DataRowType.BLOCK_SDB:                      //Parese Elementary unarray datatypes from the interface                      //All above datatypes have the same format:                      //the Length of the Interface itema is always 2 bytes                      //                      //InterfacePos + 0     = Datatype: 17 for Array                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration                      //                      //if parametertype is an "Ex" version                      //InterfacePos + 0     = Datatype: 17 for Array                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration                      //InterfacePos + 2     = Seemingly Random values' with unknown meaning                        var Par = new S7DataRow(VarName' datatype' myBlk);                      ParameterType parameterType = (ParameterType)interfaceBytes[InterfacePos + 1];                        //There is also an special case for "Extended" paramters. These contain an additional value                      if (HasExtendedParameter(parameterType))                      {                          int unkwonValue = interfaceBytes[InterfacePos + 2];                          InterfacePos++; //advance parsing by one additional byte                      }                        //if the type has an Start value' then parse it from the Start values                      if (HasInitialValues(parameterType))                          Par.StartValue = GetVarInitialValue(datatype' startValueBytes' ref StartValuePos);                        currPar.Add(Par);                      InterfacePos += 2; //Interface element is always 2 bytes                      break;                    case S7DataRowType.MultiInst_FB:                  case S7DataRowType.MultiInst_SFB:                      //Parese Block datatypes  from the interface                      //All above datatypes have the same format:                      //the Length of the Interface itema is always 3 bytes                      //                      //InterfacePos + 0     = Datatype: one of the BLOCK_xx types                      //InterfacePos + 1     = Block number LSB                      //InterfacePos + 1     = Block number MSB                        Par = new S7DataRow(VarName' datatype' myBlk);                        //if the type has an Start value' then parse it from the Start values                      int BlockNumber = BitConverter.ToInt16(interfaceBytes' InterfacePos + 1);                      Par.DataTypeBlockNumber = BlockNumber;                        currPar.Add(Par);                      InterfacePos += 3; //Interface element is always 3 bytes                      break;                    case S7DataRowType.STRING:                      //Parse String definition from Interface                      //Strings are a special case and have neither the format of Elementary nor the collection types or Array types                      //the Interface itme has an fixed length of:  3                       //                      //InterfacePos + 0     = Datatype: 0x13 for String                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration                      //InterfacePos + 2     = String Length                      //                      //Parameter Type is an EX version:                      //InterfacePos + 0     = Datatype: 0x13 for String                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration                      //InterfacePos + 2     = Seemingly Random values' with unknown meaning                      //InterfacePos + 3     = String Length                        Par = new S7DataRow(VarName' datatype' myBlk);                        //There is also an special case for "Extended" paramters. These contain an additional value                      parameterType = (ParameterType)interfaceBytes[InterfacePos + 1];                      if (HasExtendedParameter(parameterType))                      {                          int unkwonValue = interfaceBytes[InterfacePos + 2];                          InterfacePos++; //advance parsing by one additional byte                      }                        Par.StringSize = interfaceBytes[InterfacePos + 2];                        if (HasInitialValues(parameterType))                          Par.StartValue = GetVarInitialValue(datatype' startValueBytes' ref StartValuePos);                        currPar.Add(Par);                      InterfacePos += 3;  //3 byte interface row length                      break;                    case S7DataRowType.ARRAY:                      //Read the Array Dimension from the Interface                      //An array has the following format                      //the Interface itme has an variable length of:  3 + (Dimensions * 4)                      //                      //InterfacePos + 0     = Datatype: 0x10 for Array                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration                      //InterfacePos + 2     = Dimensions: Amount of dimensions to be parsed                      //InterfacePos + 3-4   = Lower Bound of 1st Dimension                      //InterfacePos + 5-6   = Upper Bound of 1st Dimension                      //InterfacePos + 7-8   = Lower Bound of 2nd Dimension if any                      //InterfacePos + 9-10  = Upper Bound of 2nd Dimensino if any                      //....                            //                      //Parameter Type is an EX version:                      //InterfacePos + 0     = Datatype: 0x10 for Array                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration                      //InterfacePos + 2     = Seemingly Random values' with unknown meaning                      //InterfacePos + 3     = Dimensions: Amount of dimensions to be parsed                      //InterfacePos + 4-5   = Lower Bound of 1st Dimension                      //InterfacePos + 6-7   = Upper Bound of 1st Dimension                      //InterfacePos + 8-9   = Lower Bound of 2nd Dimension if any                      //InterfacePos + 10-11  = Upper Bound of 2nd Dimensino if any                      //....                              //There is also an special case for "Extended" paramters. These contain an additional value                      parameterType = (ParameterType)interfaceBytes[InterfacePos + 1];                      if (HasExtendedParameter(parameterType))                      {                          int unkwonValue = interfaceBytes[InterfacePos + 2];                          InterfacePos++; //advance parsing by one additional byte                      }                        int ArrayDim = interfaceBytes[InterfacePos + 2];                      List<int> arrStart = new List<int>();                      List<int> arrStop = new List<int>();                        for (int i = 0; i <= ArrayDim - 1; i++)                      {                          arrStart.Add(BitConverter.ToInt16(interfaceBytes' InterfacePos + 3 + (i * 4)));                          arrStop.Add(BitConverter.ToInt16(interfaceBytes' InterfacePos + 5 + (i * 4)));                      }                        //Parse down child elements                      InterfacePos += 3 + (ArrayDim * 4);  //3 byte array header' and every dimension has an upper and lower bound' each an Uint16                      GetVarTypeEN(currPar' (S7DataRowType)interfaceBytes[InterfacePos]' true' true' VarName' interfaceBytes' ref InterfacePos' startValueBytes' ref StartValuePos' ref ParaList' ref StackNr' VarNameGen' myBlk);                        //Mark the current Element as Array' so that the recently parsed elements are counted as Array objects                      ((S7DataRow)currPar.Children[currPar.Children.Count - 1]).ArrayStart = arrStart;                      ((S7DataRow)currPar.Children[currPar.Children.Count - 1]).ArrayStop = arrStop;                      ((S7DataRow)currPar.Children[currPar.Children.Count - 1]).IsArray = true;                        break;                    case S7DataRowType.STRUCT: //Struct                      //Structs are nested datatypes' so go one recursivly. Also UDT get converted to Structs' so they are indistiguishable from them                      //Structs have the following format:                      //Structure Interface elements have an fixed length of 3 bytes or fixed length or 5 byte if children count is greater then 255.                      //There is also an special case with 4 Bytes length                      //                      //Child count < 255:                      //InterfacePos + 0     = Datatype: 0x11 for struct                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration. NOTE it is never DBInit' which means it never has Initial values                      //InterfacePos + 2     = Children count: the amount of sub-variables declared inside the structure                      //                      //There is an Special Case when the Child amount is greater than 255 Children.                       //in that case the original childcount on InterfacePos + 2 is set to FF and the next two bytes contain the real Child count                      //                      //Child count > 255:                      //InterfacePos + 0     = Datatype: 0x11 for struct                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration. NOTE it is never DBInit' which means it never has Initial values                      //InterfacePos + 2     = Marker that there are mor children: always 255                      //InterfacePos + 3     = Child count LSB                      //InterfacePos + 4     = Child count MSB                      //                      //There is another special case' when the ParameterType is 0x14. In that case the layout is similar to the special case with more than 255 children'                      //Except that the value InterfacePos + 2 has seemingly random Values. At the moment i do not know what these values mean                      //                      //Parameter Type is an EX version:                      //InterfacePos + 0     = Datatype: 0x11 for struct                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration. NOTE it is never DBInit' which means it never has Initial values                      //InterfacePos + 2     = Seemingly Random values' with unknown meaning                      //InterfacePos + 3     = Child count                        var akPar = new S7DataRow(VarName' datatype' myBlk);                      currPar.Add(akPar);                        //There is also an special case for "Extended" paramters. These contain an additional value                      parameterType = (ParameterType)interfaceBytes[InterfacePos + 1];                      if (HasExtendedParameter(parameterType))                      {                          int unkwonValue = interfaceBytes[InterfacePos + 2];                          InterfacePos++; //advance parsing by one additional byte                      }                        //Extract Children count from interface                      int Children = interfaceBytes[InterfacePos + 2];                      if (Children == 255)                      {                          //Reparse the children count from the next two bytes as an Integer as oposed to an single byte above                          Children = BitConverter.ToUInt16(interfaceBytes' InterfacePos + 3);                          InterfacePos += 5; //5 bytes for Structure Element length if more than 255 children' so it points to the next child element                      }                      else { InterfacePos += 3; } //3 bytes for Structure Element length' so it points to the next child element                        //Continue parsing insde the new Struct                      for (int i = 0; i < Children; i++)                      {                          GetVarTypeEN(akPar' (S7DataRowType)interfaceBytes[InterfacePos]' true' false' VarNameGen.GetNextVarName()' interfaceBytes' ref InterfacePos' startValueBytes' ref StartValuePos' ref ParaList' ref StackNr' VarNameGen' myBlk);                      }                      break;                    default:                      throw new Exception(string.Format("invalid or unknown interface declarations found while parsing the block interface at pos {0} with Paratype {1} and Datatype {2}"' InterfacePos' interfaceBytes[InterfacePos + 1]' interfaceBytes[InterfacePos]));              }
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Parameter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Parameter.cs,GetVarTypeEN,The following statement contains a magic number: switch (datatype)              {                  case S7DataRowType.BOOL:                  case S7DataRowType.BYTE:                  case S7DataRowType.CHAR:                  case S7DataRowType.WORD:                  case S7DataRowType.INT:                  case S7DataRowType.DWORD:                  case S7DataRowType.DINT:                  case S7DataRowType.REAL:                  case S7DataRowType.DATE:                  case S7DataRowType.TIME_OF_DAY:                  case S7DataRowType.TIME:                  case S7DataRowType.S5TIME:                  case S7DataRowType.DATE_AND_TIME:                  case S7DataRowType.POINTER:                  case S7DataRowType.ANY:                  case S7DataRowType.COUNTER:                  case S7DataRowType.TIMER:                  case S7DataRowType.BLOCK_FB:                  case S7DataRowType.BLOCK_FC:                  case S7DataRowType.BLOCK_DB:                  case S7DataRowType.BLOCK_SDB:                      //Parese Elementary unarray datatypes from the interface                      //All above datatypes have the same format:                      //the Length of the Interface itema is always 2 bytes                      //                      //InterfacePos + 0     = Datatype: 17 for Array                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration                      //                      //if parametertype is an "Ex" version                      //InterfacePos + 0     = Datatype: 17 for Array                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration                      //InterfacePos + 2     = Seemingly Random values' with unknown meaning                        var Par = new S7DataRow(VarName' datatype' myBlk);                      ParameterType parameterType = (ParameterType)interfaceBytes[InterfacePos + 1];                        //There is also an special case for "Extended" paramters. These contain an additional value                      if (HasExtendedParameter(parameterType))                      {                          int unkwonValue = interfaceBytes[InterfacePos + 2];                          InterfacePos++; //advance parsing by one additional byte                      }                        //if the type has an Start value' then parse it from the Start values                      if (HasInitialValues(parameterType))                          Par.StartValue = GetVarInitialValue(datatype' startValueBytes' ref StartValuePos);                        currPar.Add(Par);                      InterfacePos += 2; //Interface element is always 2 bytes                      break;                    case S7DataRowType.MultiInst_FB:                  case S7DataRowType.MultiInst_SFB:                      //Parese Block datatypes  from the interface                      //All above datatypes have the same format:                      //the Length of the Interface itema is always 3 bytes                      //                      //InterfacePos + 0     = Datatype: one of the BLOCK_xx types                      //InterfacePos + 1     = Block number LSB                      //InterfacePos + 1     = Block number MSB                        Par = new S7DataRow(VarName' datatype' myBlk);                        //if the type has an Start value' then parse it from the Start values                      int BlockNumber = BitConverter.ToInt16(interfaceBytes' InterfacePos + 1);                      Par.DataTypeBlockNumber = BlockNumber;                        currPar.Add(Par);                      InterfacePos += 3; //Interface element is always 3 bytes                      break;                    case S7DataRowType.STRING:                      //Parse String definition from Interface                      //Strings are a special case and have neither the format of Elementary nor the collection types or Array types                      //the Interface itme has an fixed length of:  3                       //                      //InterfacePos + 0     = Datatype: 0x13 for String                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration                      //InterfacePos + 2     = String Length                      //                      //Parameter Type is an EX version:                      //InterfacePos + 0     = Datatype: 0x13 for String                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration                      //InterfacePos + 2     = Seemingly Random values' with unknown meaning                      //InterfacePos + 3     = String Length                        Par = new S7DataRow(VarName' datatype' myBlk);                        //There is also an special case for "Extended" paramters. These contain an additional value                      parameterType = (ParameterType)interfaceBytes[InterfacePos + 1];                      if (HasExtendedParameter(parameterType))                      {                          int unkwonValue = interfaceBytes[InterfacePos + 2];                          InterfacePos++; //advance parsing by one additional byte                      }                        Par.StringSize = interfaceBytes[InterfacePos + 2];                        if (HasInitialValues(parameterType))                          Par.StartValue = GetVarInitialValue(datatype' startValueBytes' ref StartValuePos);                        currPar.Add(Par);                      InterfacePos += 3;  //3 byte interface row length                      break;                    case S7DataRowType.ARRAY:                      //Read the Array Dimension from the Interface                      //An array has the following format                      //the Interface itme has an variable length of:  3 + (Dimensions * 4)                      //                      //InterfacePos + 0     = Datatype: 0x10 for Array                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration                      //InterfacePos + 2     = Dimensions: Amount of dimensions to be parsed                      //InterfacePos + 3-4   = Lower Bound of 1st Dimension                      //InterfacePos + 5-6   = Upper Bound of 1st Dimension                      //InterfacePos + 7-8   = Lower Bound of 2nd Dimension if any                      //InterfacePos + 9-10  = Upper Bound of 2nd Dimensino if any                      //....                            //                      //Parameter Type is an EX version:                      //InterfacePos + 0     = Datatype: 0x10 for Array                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration                      //InterfacePos + 2     = Seemingly Random values' with unknown meaning                      //InterfacePos + 3     = Dimensions: Amount of dimensions to be parsed                      //InterfacePos + 4-5   = Lower Bound of 1st Dimension                      //InterfacePos + 6-7   = Upper Bound of 1st Dimension                      //InterfacePos + 8-9   = Lower Bound of 2nd Dimension if any                      //InterfacePos + 10-11  = Upper Bound of 2nd Dimensino if any                      //....                              //There is also an special case for "Extended" paramters. These contain an additional value                      parameterType = (ParameterType)interfaceBytes[InterfacePos + 1];                      if (HasExtendedParameter(parameterType))                      {                          int unkwonValue = interfaceBytes[InterfacePos + 2];                          InterfacePos++; //advance parsing by one additional byte                      }                        int ArrayDim = interfaceBytes[InterfacePos + 2];                      List<int> arrStart = new List<int>();                      List<int> arrStop = new List<int>();                        for (int i = 0; i <= ArrayDim - 1; i++)                      {                          arrStart.Add(BitConverter.ToInt16(interfaceBytes' InterfacePos + 3 + (i * 4)));                          arrStop.Add(BitConverter.ToInt16(interfaceBytes' InterfacePos + 5 + (i * 4)));                      }                        //Parse down child elements                      InterfacePos += 3 + (ArrayDim * 4);  //3 byte array header' and every dimension has an upper and lower bound' each an Uint16                      GetVarTypeEN(currPar' (S7DataRowType)interfaceBytes[InterfacePos]' true' true' VarName' interfaceBytes' ref InterfacePos' startValueBytes' ref StartValuePos' ref ParaList' ref StackNr' VarNameGen' myBlk);                        //Mark the current Element as Array' so that the recently parsed elements are counted as Array objects                      ((S7DataRow)currPar.Children[currPar.Children.Count - 1]).ArrayStart = arrStart;                      ((S7DataRow)currPar.Children[currPar.Children.Count - 1]).ArrayStop = arrStop;                      ((S7DataRow)currPar.Children[currPar.Children.Count - 1]).IsArray = true;                        break;                    case S7DataRowType.STRUCT: //Struct                      //Structs are nested datatypes' so go one recursivly. Also UDT get converted to Structs' so they are indistiguishable from them                      //Structs have the following format:                      //Structure Interface elements have an fixed length of 3 bytes or fixed length or 5 byte if children count is greater then 255.                      //There is also an special case with 4 Bytes length                      //                      //Child count < 255:                      //InterfacePos + 0     = Datatype: 0x11 for struct                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration. NOTE it is never DBInit' which means it never has Initial values                      //InterfacePos + 2     = Children count: the amount of sub-variables declared inside the structure                      //                      //There is an Special Case when the Child amount is greater than 255 Children.                       //in that case the original childcount on InterfacePos + 2 is set to FF and the next two bytes contain the real Child count                      //                      //Child count > 255:                      //InterfacePos + 0     = Datatype: 0x11 for struct                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration. NOTE it is never DBInit' which means it never has Initial values                      //InterfacePos + 2     = Marker that there are mor children: always 255                      //InterfacePos + 3     = Child count LSB                      //InterfacePos + 4     = Child count MSB                      //                      //There is another special case' when the ParameterType is 0x14. In that case the layout is similar to the special case with more than 255 children'                      //Except that the value InterfacePos + 2 has seemingly random Values. At the moment i do not know what these values mean                      //                      //Parameter Type is an EX version:                      //InterfacePos + 0     = Datatype: 0x11 for struct                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration. NOTE it is never DBInit' which means it never has Initial values                      //InterfacePos + 2     = Seemingly Random values' with unknown meaning                      //InterfacePos + 3     = Child count                        var akPar = new S7DataRow(VarName' datatype' myBlk);                      currPar.Add(akPar);                        //There is also an special case for "Extended" paramters. These contain an additional value                      parameterType = (ParameterType)interfaceBytes[InterfacePos + 1];                      if (HasExtendedParameter(parameterType))                      {                          int unkwonValue = interfaceBytes[InterfacePos + 2];                          InterfacePos++; //advance parsing by one additional byte                      }                        //Extract Children count from interface                      int Children = interfaceBytes[InterfacePos + 2];                      if (Children == 255)                      {                          //Reparse the children count from the next two bytes as an Integer as oposed to an single byte above                          Children = BitConverter.ToUInt16(interfaceBytes' InterfacePos + 3);                          InterfacePos += 5; //5 bytes for Structure Element length if more than 255 children' so it points to the next child element                      }                      else { InterfacePos += 3; } //3 bytes for Structure Element length' so it points to the next child element                        //Continue parsing insde the new Struct                      for (int i = 0; i < Children; i++)                      {                          GetVarTypeEN(akPar' (S7DataRowType)interfaceBytes[InterfacePos]' true' false' VarNameGen.GetNextVarName()' interfaceBytes' ref InterfacePos' startValueBytes' ref StartValuePos' ref ParaList' ref StackNr' VarNameGen' myBlk);                      }                      break;                    default:                      throw new Exception(string.Format("invalid or unknown interface declarations found while parsing the block interface at pos {0} with Paratype {1} and Datatype {2}"' InterfacePos' interfaceBytes[InterfacePos + 1]' interfaceBytes[InterfacePos]));              }
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Parameter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Parameter.cs,GetVarTypeEN,The following statement contains a magic number: switch (datatype)              {                  case S7DataRowType.BOOL:                  case S7DataRowType.BYTE:                  case S7DataRowType.CHAR:                  case S7DataRowType.WORD:                  case S7DataRowType.INT:                  case S7DataRowType.DWORD:                  case S7DataRowType.DINT:                  case S7DataRowType.REAL:                  case S7DataRowType.DATE:                  case S7DataRowType.TIME_OF_DAY:                  case S7DataRowType.TIME:                  case S7DataRowType.S5TIME:                  case S7DataRowType.DATE_AND_TIME:                  case S7DataRowType.POINTER:                  case S7DataRowType.ANY:                  case S7DataRowType.COUNTER:                  case S7DataRowType.TIMER:                  case S7DataRowType.BLOCK_FB:                  case S7DataRowType.BLOCK_FC:                  case S7DataRowType.BLOCK_DB:                  case S7DataRowType.BLOCK_SDB:                      //Parese Elementary unarray datatypes from the interface                      //All above datatypes have the same format:                      //the Length of the Interface itema is always 2 bytes                      //                      //InterfacePos + 0     = Datatype: 17 for Array                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration                      //                      //if parametertype is an "Ex" version                      //InterfacePos + 0     = Datatype: 17 for Array                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration                      //InterfacePos + 2     = Seemingly Random values' with unknown meaning                        var Par = new S7DataRow(VarName' datatype' myBlk);                      ParameterType parameterType = (ParameterType)interfaceBytes[InterfacePos + 1];                        //There is also an special case for "Extended" paramters. These contain an additional value                      if (HasExtendedParameter(parameterType))                      {                          int unkwonValue = interfaceBytes[InterfacePos + 2];                          InterfacePos++; //advance parsing by one additional byte                      }                        //if the type has an Start value' then parse it from the Start values                      if (HasInitialValues(parameterType))                          Par.StartValue = GetVarInitialValue(datatype' startValueBytes' ref StartValuePos);                        currPar.Add(Par);                      InterfacePos += 2; //Interface element is always 2 bytes                      break;                    case S7DataRowType.MultiInst_FB:                  case S7DataRowType.MultiInst_SFB:                      //Parese Block datatypes  from the interface                      //All above datatypes have the same format:                      //the Length of the Interface itema is always 3 bytes                      //                      //InterfacePos + 0     = Datatype: one of the BLOCK_xx types                      //InterfacePos + 1     = Block number LSB                      //InterfacePos + 1     = Block number MSB                        Par = new S7DataRow(VarName' datatype' myBlk);                        //if the type has an Start value' then parse it from the Start values                      int BlockNumber = BitConverter.ToInt16(interfaceBytes' InterfacePos + 1);                      Par.DataTypeBlockNumber = BlockNumber;                        currPar.Add(Par);                      InterfacePos += 3; //Interface element is always 3 bytes                      break;                    case S7DataRowType.STRING:                      //Parse String definition from Interface                      //Strings are a special case and have neither the format of Elementary nor the collection types or Array types                      //the Interface itme has an fixed length of:  3                       //                      //InterfacePos + 0     = Datatype: 0x13 for String                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration                      //InterfacePos + 2     = String Length                      //                      //Parameter Type is an EX version:                      //InterfacePos + 0     = Datatype: 0x13 for String                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration                      //InterfacePos + 2     = Seemingly Random values' with unknown meaning                      //InterfacePos + 3     = String Length                        Par = new S7DataRow(VarName' datatype' myBlk);                        //There is also an special case for "Extended" paramters. These contain an additional value                      parameterType = (ParameterType)interfaceBytes[InterfacePos + 1];                      if (HasExtendedParameter(parameterType))                      {                          int unkwonValue = interfaceBytes[InterfacePos + 2];                          InterfacePos++; //advance parsing by one additional byte                      }                        Par.StringSize = interfaceBytes[InterfacePos + 2];                        if (HasInitialValues(parameterType))                          Par.StartValue = GetVarInitialValue(datatype' startValueBytes' ref StartValuePos);                        currPar.Add(Par);                      InterfacePos += 3;  //3 byte interface row length                      break;                    case S7DataRowType.ARRAY:                      //Read the Array Dimension from the Interface                      //An array has the following format                      //the Interface itme has an variable length of:  3 + (Dimensions * 4)                      //                      //InterfacePos + 0     = Datatype: 0x10 for Array                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration                      //InterfacePos + 2     = Dimensions: Amount of dimensions to be parsed                      //InterfacePos + 3-4   = Lower Bound of 1st Dimension                      //InterfacePos + 5-6   = Upper Bound of 1st Dimension                      //InterfacePos + 7-8   = Lower Bound of 2nd Dimension if any                      //InterfacePos + 9-10  = Upper Bound of 2nd Dimensino if any                      //....                            //                      //Parameter Type is an EX version:                      //InterfacePos + 0     = Datatype: 0x10 for Array                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration                      //InterfacePos + 2     = Seemingly Random values' with unknown meaning                      //InterfacePos + 3     = Dimensions: Amount of dimensions to be parsed                      //InterfacePos + 4-5   = Lower Bound of 1st Dimension                      //InterfacePos + 6-7   = Upper Bound of 1st Dimension                      //InterfacePos + 8-9   = Lower Bound of 2nd Dimension if any                      //InterfacePos + 10-11  = Upper Bound of 2nd Dimensino if any                      //....                              //There is also an special case for "Extended" paramters. These contain an additional value                      parameterType = (ParameterType)interfaceBytes[InterfacePos + 1];                      if (HasExtendedParameter(parameterType))                      {                          int unkwonValue = interfaceBytes[InterfacePos + 2];                          InterfacePos++; //advance parsing by one additional byte                      }                        int ArrayDim = interfaceBytes[InterfacePos + 2];                      List<int> arrStart = new List<int>();                      List<int> arrStop = new List<int>();                        for (int i = 0; i <= ArrayDim - 1; i++)                      {                          arrStart.Add(BitConverter.ToInt16(interfaceBytes' InterfacePos + 3 + (i * 4)));                          arrStop.Add(BitConverter.ToInt16(interfaceBytes' InterfacePos + 5 + (i * 4)));                      }                        //Parse down child elements                      InterfacePos += 3 + (ArrayDim * 4);  //3 byte array header' and every dimension has an upper and lower bound' each an Uint16                      GetVarTypeEN(currPar' (S7DataRowType)interfaceBytes[InterfacePos]' true' true' VarName' interfaceBytes' ref InterfacePos' startValueBytes' ref StartValuePos' ref ParaList' ref StackNr' VarNameGen' myBlk);                        //Mark the current Element as Array' so that the recently parsed elements are counted as Array objects                      ((S7DataRow)currPar.Children[currPar.Children.Count - 1]).ArrayStart = arrStart;                      ((S7DataRow)currPar.Children[currPar.Children.Count - 1]).ArrayStop = arrStop;                      ((S7DataRow)currPar.Children[currPar.Children.Count - 1]).IsArray = true;                        break;                    case S7DataRowType.STRUCT: //Struct                      //Structs are nested datatypes' so go one recursivly. Also UDT get converted to Structs' so they are indistiguishable from them                      //Structs have the following format:                      //Structure Interface elements have an fixed length of 3 bytes or fixed length or 5 byte if children count is greater then 255.                      //There is also an special case with 4 Bytes length                      //                      //Child count < 255:                      //InterfacePos + 0     = Datatype: 0x11 for struct                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration. NOTE it is never DBInit' which means it never has Initial values                      //InterfacePos + 2     = Children count: the amount of sub-variables declared inside the structure                      //                      //There is an Special Case when the Child amount is greater than 255 Children.                       //in that case the original childcount on InterfacePos + 2 is set to FF and the next two bytes contain the real Child count                      //                      //Child count > 255:                      //InterfacePos + 0     = Datatype: 0x11 for struct                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration. NOTE it is never DBInit' which means it never has Initial values                      //InterfacePos + 2     = Marker that there are mor children: always 255                      //InterfacePos + 3     = Child count LSB                      //InterfacePos + 4     = Child count MSB                      //                      //There is another special case' when the ParameterType is 0x14. In that case the layout is similar to the special case with more than 255 children'                      //Except that the value InterfacePos + 2 has seemingly random Values. At the moment i do not know what these values mean                      //                      //Parameter Type is an EX version:                      //InterfacePos + 0     = Datatype: 0x11 for struct                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration. NOTE it is never DBInit' which means it never has Initial values                      //InterfacePos + 2     = Seemingly Random values' with unknown meaning                      //InterfacePos + 3     = Child count                        var akPar = new S7DataRow(VarName' datatype' myBlk);                      currPar.Add(akPar);                        //There is also an special case for "Extended" paramters. These contain an additional value                      parameterType = (ParameterType)interfaceBytes[InterfacePos + 1];                      if (HasExtendedParameter(parameterType))                      {                          int unkwonValue = interfaceBytes[InterfacePos + 2];                          InterfacePos++; //advance parsing by one additional byte                      }                        //Extract Children count from interface                      int Children = interfaceBytes[InterfacePos + 2];                      if (Children == 255)                      {                          //Reparse the children count from the next two bytes as an Integer as oposed to an single byte above                          Children = BitConverter.ToUInt16(interfaceBytes' InterfacePos + 3);                          InterfacePos += 5; //5 bytes for Structure Element length if more than 255 children' so it points to the next child element                      }                      else { InterfacePos += 3; } //3 bytes for Structure Element length' so it points to the next child element                        //Continue parsing insde the new Struct                      for (int i = 0; i < Children; i++)                      {                          GetVarTypeEN(akPar' (S7DataRowType)interfaceBytes[InterfacePos]' true' false' VarNameGen.GetNextVarName()' interfaceBytes' ref InterfacePos' startValueBytes' ref StartValuePos' ref ParaList' ref StackNr' VarNameGen' myBlk);                      }                      break;                    default:                      throw new Exception(string.Format("invalid or unknown interface declarations found while parsing the block interface at pos {0} with Paratype {1} and Datatype {2}"' InterfacePos' interfaceBytes[InterfacePos + 1]' interfaceBytes[InterfacePos]));              }
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Parameter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Parameter.cs,GetVarTypeEN,The following statement contains a magic number: switch (datatype)              {                  case S7DataRowType.BOOL:                  case S7DataRowType.BYTE:                  case S7DataRowType.CHAR:                  case S7DataRowType.WORD:                  case S7DataRowType.INT:                  case S7DataRowType.DWORD:                  case S7DataRowType.DINT:                  case S7DataRowType.REAL:                  case S7DataRowType.DATE:                  case S7DataRowType.TIME_OF_DAY:                  case S7DataRowType.TIME:                  case S7DataRowType.S5TIME:                  case S7DataRowType.DATE_AND_TIME:                  case S7DataRowType.POINTER:                  case S7DataRowType.ANY:                  case S7DataRowType.COUNTER:                  case S7DataRowType.TIMER:                  case S7DataRowType.BLOCK_FB:                  case S7DataRowType.BLOCK_FC:                  case S7DataRowType.BLOCK_DB:                  case S7DataRowType.BLOCK_SDB:                      //Parese Elementary unarray datatypes from the interface                      //All above datatypes have the same format:                      //the Length of the Interface itema is always 2 bytes                      //                      //InterfacePos + 0     = Datatype: 17 for Array                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration                      //                      //if parametertype is an "Ex" version                      //InterfacePos + 0     = Datatype: 17 for Array                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration                      //InterfacePos + 2     = Seemingly Random values' with unknown meaning                        var Par = new S7DataRow(VarName' datatype' myBlk);                      ParameterType parameterType = (ParameterType)interfaceBytes[InterfacePos + 1];                        //There is also an special case for "Extended" paramters. These contain an additional value                      if (HasExtendedParameter(parameterType))                      {                          int unkwonValue = interfaceBytes[InterfacePos + 2];                          InterfacePos++; //advance parsing by one additional byte                      }                        //if the type has an Start value' then parse it from the Start values                      if (HasInitialValues(parameterType))                          Par.StartValue = GetVarInitialValue(datatype' startValueBytes' ref StartValuePos);                        currPar.Add(Par);                      InterfacePos += 2; //Interface element is always 2 bytes                      break;                    case S7DataRowType.MultiInst_FB:                  case S7DataRowType.MultiInst_SFB:                      //Parese Block datatypes  from the interface                      //All above datatypes have the same format:                      //the Length of the Interface itema is always 3 bytes                      //                      //InterfacePos + 0     = Datatype: one of the BLOCK_xx types                      //InterfacePos + 1     = Block number LSB                      //InterfacePos + 1     = Block number MSB                        Par = new S7DataRow(VarName' datatype' myBlk);                        //if the type has an Start value' then parse it from the Start values                      int BlockNumber = BitConverter.ToInt16(interfaceBytes' InterfacePos + 1);                      Par.DataTypeBlockNumber = BlockNumber;                        currPar.Add(Par);                      InterfacePos += 3; //Interface element is always 3 bytes                      break;                    case S7DataRowType.STRING:                      //Parse String definition from Interface                      //Strings are a special case and have neither the format of Elementary nor the collection types or Array types                      //the Interface itme has an fixed length of:  3                       //                      //InterfacePos + 0     = Datatype: 0x13 for String                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration                      //InterfacePos + 2     = String Length                      //                      //Parameter Type is an EX version:                      //InterfacePos + 0     = Datatype: 0x13 for String                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration                      //InterfacePos + 2     = Seemingly Random values' with unknown meaning                      //InterfacePos + 3     = String Length                        Par = new S7DataRow(VarName' datatype' myBlk);                        //There is also an special case for "Extended" paramters. These contain an additional value                      parameterType = (ParameterType)interfaceBytes[InterfacePos + 1];                      if (HasExtendedParameter(parameterType))                      {                          int unkwonValue = interfaceBytes[InterfacePos + 2];                          InterfacePos++; //advance parsing by one additional byte                      }                        Par.StringSize = interfaceBytes[InterfacePos + 2];                        if (HasInitialValues(parameterType))                          Par.StartValue = GetVarInitialValue(datatype' startValueBytes' ref StartValuePos);                        currPar.Add(Par);                      InterfacePos += 3;  //3 byte interface row length                      break;                    case S7DataRowType.ARRAY:                      //Read the Array Dimension from the Interface                      //An array has the following format                      //the Interface itme has an variable length of:  3 + (Dimensions * 4)                      //                      //InterfacePos + 0     = Datatype: 0x10 for Array                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration                      //InterfacePos + 2     = Dimensions: Amount of dimensions to be parsed                      //InterfacePos + 3-4   = Lower Bound of 1st Dimension                      //InterfacePos + 5-6   = Upper Bound of 1st Dimension                      //InterfacePos + 7-8   = Lower Bound of 2nd Dimension if any                      //InterfacePos + 9-10  = Upper Bound of 2nd Dimensino if any                      //....                            //                      //Parameter Type is an EX version:                      //InterfacePos + 0     = Datatype: 0x10 for Array                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration                      //InterfacePos + 2     = Seemingly Random values' with unknown meaning                      //InterfacePos + 3     = Dimensions: Amount of dimensions to be parsed                      //InterfacePos + 4-5   = Lower Bound of 1st Dimension                      //InterfacePos + 6-7   = Upper Bound of 1st Dimension                      //InterfacePos + 8-9   = Lower Bound of 2nd Dimension if any                      //InterfacePos + 10-11  = Upper Bound of 2nd Dimensino if any                      //....                              //There is also an special case for "Extended" paramters. These contain an additional value                      parameterType = (ParameterType)interfaceBytes[InterfacePos + 1];                      if (HasExtendedParameter(parameterType))                      {                          int unkwonValue = interfaceBytes[InterfacePos + 2];                          InterfacePos++; //advance parsing by one additional byte                      }                        int ArrayDim = interfaceBytes[InterfacePos + 2];                      List<int> arrStart = new List<int>();                      List<int> arrStop = new List<int>();                        for (int i = 0; i <= ArrayDim - 1; i++)                      {                          arrStart.Add(BitConverter.ToInt16(interfaceBytes' InterfacePos + 3 + (i * 4)));                          arrStop.Add(BitConverter.ToInt16(interfaceBytes' InterfacePos + 5 + (i * 4)));                      }                        //Parse down child elements                      InterfacePos += 3 + (ArrayDim * 4);  //3 byte array header' and every dimension has an upper and lower bound' each an Uint16                      GetVarTypeEN(currPar' (S7DataRowType)interfaceBytes[InterfacePos]' true' true' VarName' interfaceBytes' ref InterfacePos' startValueBytes' ref StartValuePos' ref ParaList' ref StackNr' VarNameGen' myBlk);                        //Mark the current Element as Array' so that the recently parsed elements are counted as Array objects                      ((S7DataRow)currPar.Children[currPar.Children.Count - 1]).ArrayStart = arrStart;                      ((S7DataRow)currPar.Children[currPar.Children.Count - 1]).ArrayStop = arrStop;                      ((S7DataRow)currPar.Children[currPar.Children.Count - 1]).IsArray = true;                        break;                    case S7DataRowType.STRUCT: //Struct                      //Structs are nested datatypes' so go one recursivly. Also UDT get converted to Structs' so they are indistiguishable from them                      //Structs have the following format:                      //Structure Interface elements have an fixed length of 3 bytes or fixed length or 5 byte if children count is greater then 255.                      //There is also an special case with 4 Bytes length                      //                      //Child count < 255:                      //InterfacePos + 0     = Datatype: 0x11 for struct                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration. NOTE it is never DBInit' which means it never has Initial values                      //InterfacePos + 2     = Children count: the amount of sub-variables declared inside the structure                      //                      //There is an Special Case when the Child amount is greater than 255 Children.                       //in that case the original childcount on InterfacePos + 2 is set to FF and the next two bytes contain the real Child count                      //                      //Child count > 255:                      //InterfacePos + 0     = Datatype: 0x11 for struct                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration. NOTE it is never DBInit' which means it never has Initial values                      //InterfacePos + 2     = Marker that there are mor children: always 255                      //InterfacePos + 3     = Child count LSB                      //InterfacePos + 4     = Child count MSB                      //                      //There is another special case' when the ParameterType is 0x14. In that case the layout is similar to the special case with more than 255 children'                      //Except that the value InterfacePos + 2 has seemingly random Values. At the moment i do not know what these values mean                      //                      //Parameter Type is an EX version:                      //InterfacePos + 0     = Datatype: 0x11 for struct                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration. NOTE it is never DBInit' which means it never has Initial values                      //InterfacePos + 2     = Seemingly Random values' with unknown meaning                      //InterfacePos + 3     = Child count                        var akPar = new S7DataRow(VarName' datatype' myBlk);                      currPar.Add(akPar);                        //There is also an special case for "Extended" paramters. These contain an additional value                      parameterType = (ParameterType)interfaceBytes[InterfacePos + 1];                      if (HasExtendedParameter(parameterType))                      {                          int unkwonValue = interfaceBytes[InterfacePos + 2];                          InterfacePos++; //advance parsing by one additional byte                      }                        //Extract Children count from interface                      int Children = interfaceBytes[InterfacePos + 2];                      if (Children == 255)                      {                          //Reparse the children count from the next two bytes as an Integer as oposed to an single byte above                          Children = BitConverter.ToUInt16(interfaceBytes' InterfacePos + 3);                          InterfacePos += 5; //5 bytes for Structure Element length if more than 255 children' so it points to the next child element                      }                      else { InterfacePos += 3; } //3 bytes for Structure Element length' so it points to the next child element                        //Continue parsing insde the new Struct                      for (int i = 0; i < Children; i++)                      {                          GetVarTypeEN(akPar' (S7DataRowType)interfaceBytes[InterfacePos]' true' false' VarNameGen.GetNextVarName()' interfaceBytes' ref InterfacePos' startValueBytes' ref StartValuePos' ref ParaList' ref StackNr' VarNameGen' myBlk);                      }                      break;                    default:                      throw new Exception(string.Format("invalid or unknown interface declarations found while parsing the block interface at pos {0} with Paratype {1} and Datatype {2}"' InterfacePos' interfaceBytes[InterfacePos + 1]' interfaceBytes[InterfacePos]));              }
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Parameter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Parameter.cs,GetVarTypeEN,The following statement contains a magic number: switch (datatype)              {                  case S7DataRowType.BOOL:                  case S7DataRowType.BYTE:                  case S7DataRowType.CHAR:                  case S7DataRowType.WORD:                  case S7DataRowType.INT:                  case S7DataRowType.DWORD:                  case S7DataRowType.DINT:                  case S7DataRowType.REAL:                  case S7DataRowType.DATE:                  case S7DataRowType.TIME_OF_DAY:                  case S7DataRowType.TIME:                  case S7DataRowType.S5TIME:                  case S7DataRowType.DATE_AND_TIME:                  case S7DataRowType.POINTER:                  case S7DataRowType.ANY:                  case S7DataRowType.COUNTER:                  case S7DataRowType.TIMER:                  case S7DataRowType.BLOCK_FB:                  case S7DataRowType.BLOCK_FC:                  case S7DataRowType.BLOCK_DB:                  case S7DataRowType.BLOCK_SDB:                      //Parese Elementary unarray datatypes from the interface                      //All above datatypes have the same format:                      //the Length of the Interface itema is always 2 bytes                      //                      //InterfacePos + 0     = Datatype: 17 for Array                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration                      //                      //if parametertype is an "Ex" version                      //InterfacePos + 0     = Datatype: 17 for Array                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration                      //InterfacePos + 2     = Seemingly Random values' with unknown meaning                        var Par = new S7DataRow(VarName' datatype' myBlk);                      ParameterType parameterType = (ParameterType)interfaceBytes[InterfacePos + 1];                        //There is also an special case for "Extended" paramters. These contain an additional value                      if (HasExtendedParameter(parameterType))                      {                          int unkwonValue = interfaceBytes[InterfacePos + 2];                          InterfacePos++; //advance parsing by one additional byte                      }                        //if the type has an Start value' then parse it from the Start values                      if (HasInitialValues(parameterType))                          Par.StartValue = GetVarInitialValue(datatype' startValueBytes' ref StartValuePos);                        currPar.Add(Par);                      InterfacePos += 2; //Interface element is always 2 bytes                      break;                    case S7DataRowType.MultiInst_FB:                  case S7DataRowType.MultiInst_SFB:                      //Parese Block datatypes  from the interface                      //All above datatypes have the same format:                      //the Length of the Interface itema is always 3 bytes                      //                      //InterfacePos + 0     = Datatype: one of the BLOCK_xx types                      //InterfacePos + 1     = Block number LSB                      //InterfacePos + 1     = Block number MSB                        Par = new S7DataRow(VarName' datatype' myBlk);                        //if the type has an Start value' then parse it from the Start values                      int BlockNumber = BitConverter.ToInt16(interfaceBytes' InterfacePos + 1);                      Par.DataTypeBlockNumber = BlockNumber;                        currPar.Add(Par);                      InterfacePos += 3; //Interface element is always 3 bytes                      break;                    case S7DataRowType.STRING:                      //Parse String definition from Interface                      //Strings are a special case and have neither the format of Elementary nor the collection types or Array types                      //the Interface itme has an fixed length of:  3                       //                      //InterfacePos + 0     = Datatype: 0x13 for String                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration                      //InterfacePos + 2     = String Length                      //                      //Parameter Type is an EX version:                      //InterfacePos + 0     = Datatype: 0x13 for String                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration                      //InterfacePos + 2     = Seemingly Random values' with unknown meaning                      //InterfacePos + 3     = String Length                        Par = new S7DataRow(VarName' datatype' myBlk);                        //There is also an special case for "Extended" paramters. These contain an additional value                      parameterType = (ParameterType)interfaceBytes[InterfacePos + 1];                      if (HasExtendedParameter(parameterType))                      {                          int unkwonValue = interfaceBytes[InterfacePos + 2];                          InterfacePos++; //advance parsing by one additional byte                      }                        Par.StringSize = interfaceBytes[InterfacePos + 2];                        if (HasInitialValues(parameterType))                          Par.StartValue = GetVarInitialValue(datatype' startValueBytes' ref StartValuePos);                        currPar.Add(Par);                      InterfacePos += 3;  //3 byte interface row length                      break;                    case S7DataRowType.ARRAY:                      //Read the Array Dimension from the Interface                      //An array has the following format                      //the Interface itme has an variable length of:  3 + (Dimensions * 4)                      //                      //InterfacePos + 0     = Datatype: 0x10 for Array                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration                      //InterfacePos + 2     = Dimensions: Amount of dimensions to be parsed                      //InterfacePos + 3-4   = Lower Bound of 1st Dimension                      //InterfacePos + 5-6   = Upper Bound of 1st Dimension                      //InterfacePos + 7-8   = Lower Bound of 2nd Dimension if any                      //InterfacePos + 9-10  = Upper Bound of 2nd Dimensino if any                      //....                            //                      //Parameter Type is an EX version:                      //InterfacePos + 0     = Datatype: 0x10 for Array                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration                      //InterfacePos + 2     = Seemingly Random values' with unknown meaning                      //InterfacePos + 3     = Dimensions: Amount of dimensions to be parsed                      //InterfacePos + 4-5   = Lower Bound of 1st Dimension                      //InterfacePos + 6-7   = Upper Bound of 1st Dimension                      //InterfacePos + 8-9   = Lower Bound of 2nd Dimension if any                      //InterfacePos + 10-11  = Upper Bound of 2nd Dimensino if any                      //....                              //There is also an special case for "Extended" paramters. These contain an additional value                      parameterType = (ParameterType)interfaceBytes[InterfacePos + 1];                      if (HasExtendedParameter(parameterType))                      {                          int unkwonValue = interfaceBytes[InterfacePos + 2];                          InterfacePos++; //advance parsing by one additional byte                      }                        int ArrayDim = interfaceBytes[InterfacePos + 2];                      List<int> arrStart = new List<int>();                      List<int> arrStop = new List<int>();                        for (int i = 0; i <= ArrayDim - 1; i++)                      {                          arrStart.Add(BitConverter.ToInt16(interfaceBytes' InterfacePos + 3 + (i * 4)));                          arrStop.Add(BitConverter.ToInt16(interfaceBytes' InterfacePos + 5 + (i * 4)));                      }                        //Parse down child elements                      InterfacePos += 3 + (ArrayDim * 4);  //3 byte array header' and every dimension has an upper and lower bound' each an Uint16                      GetVarTypeEN(currPar' (S7DataRowType)interfaceBytes[InterfacePos]' true' true' VarName' interfaceBytes' ref InterfacePos' startValueBytes' ref StartValuePos' ref ParaList' ref StackNr' VarNameGen' myBlk);                        //Mark the current Element as Array' so that the recently parsed elements are counted as Array objects                      ((S7DataRow)currPar.Children[currPar.Children.Count - 1]).ArrayStart = arrStart;                      ((S7DataRow)currPar.Children[currPar.Children.Count - 1]).ArrayStop = arrStop;                      ((S7DataRow)currPar.Children[currPar.Children.Count - 1]).IsArray = true;                        break;                    case S7DataRowType.STRUCT: //Struct                      //Structs are nested datatypes' so go one recursivly. Also UDT get converted to Structs' so they are indistiguishable from them                      //Structs have the following format:                      //Structure Interface elements have an fixed length of 3 bytes or fixed length or 5 byte if children count is greater then 255.                      //There is also an special case with 4 Bytes length                      //                      //Child count < 255:                      //InterfacePos + 0     = Datatype: 0x11 for struct                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration. NOTE it is never DBInit' which means it never has Initial values                      //InterfacePos + 2     = Children count: the amount of sub-variables declared inside the structure                      //                      //There is an Special Case when the Child amount is greater than 255 Children.                       //in that case the original childcount on InterfacePos + 2 is set to FF and the next two bytes contain the real Child count                      //                      //Child count > 255:                      //InterfacePos + 0     = Datatype: 0x11 for struct                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration. NOTE it is never DBInit' which means it never has Initial values                      //InterfacePos + 2     = Marker that there are mor children: always 255                      //InterfacePos + 3     = Child count LSB                      //InterfacePos + 4     = Child count MSB                      //                      //There is another special case' when the ParameterType is 0x14. In that case the layout is similar to the special case with more than 255 children'                      //Except that the value InterfacePos + 2 has seemingly random Values. At the moment i do not know what these values mean                      //                      //Parameter Type is an EX version:                      //InterfacePos + 0     = Datatype: 0x11 for struct                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration. NOTE it is never DBInit' which means it never has Initial values                      //InterfacePos + 2     = Seemingly Random values' with unknown meaning                      //InterfacePos + 3     = Child count                        var akPar = new S7DataRow(VarName' datatype' myBlk);                      currPar.Add(akPar);                        //There is also an special case for "Extended" paramters. These contain an additional value                      parameterType = (ParameterType)interfaceBytes[InterfacePos + 1];                      if (HasExtendedParameter(parameterType))                      {                          int unkwonValue = interfaceBytes[InterfacePos + 2];                          InterfacePos++; //advance parsing by one additional byte                      }                        //Extract Children count from interface                      int Children = interfaceBytes[InterfacePos + 2];                      if (Children == 255)                      {                          //Reparse the children count from the next two bytes as an Integer as oposed to an single byte above                          Children = BitConverter.ToUInt16(interfaceBytes' InterfacePos + 3);                          InterfacePos += 5; //5 bytes for Structure Element length if more than 255 children' so it points to the next child element                      }                      else { InterfacePos += 3; } //3 bytes for Structure Element length' so it points to the next child element                        //Continue parsing insde the new Struct                      for (int i = 0; i < Children; i++)                      {                          GetVarTypeEN(akPar' (S7DataRowType)interfaceBytes[InterfacePos]' true' false' VarNameGen.GetNextVarName()' interfaceBytes' ref InterfacePos' startValueBytes' ref StartValuePos' ref ParaList' ref StackNr' VarNameGen' myBlk);                      }                      break;                    default:                      throw new Exception(string.Format("invalid or unknown interface declarations found while parsing the block interface at pos {0} with Paratype {1} and Datatype {2}"' InterfacePos' interfaceBytes[InterfacePos + 1]' interfaceBytes[InterfacePos]));              }
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Parameter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Parameter.cs,GetVarTypeEN,The following statement contains a magic number: switch (datatype)              {                  case S7DataRowType.BOOL:                  case S7DataRowType.BYTE:                  case S7DataRowType.CHAR:                  case S7DataRowType.WORD:                  case S7DataRowType.INT:                  case S7DataRowType.DWORD:                  case S7DataRowType.DINT:                  case S7DataRowType.REAL:                  case S7DataRowType.DATE:                  case S7DataRowType.TIME_OF_DAY:                  case S7DataRowType.TIME:                  case S7DataRowType.S5TIME:                  case S7DataRowType.DATE_AND_TIME:                  case S7DataRowType.POINTER:                  case S7DataRowType.ANY:                  case S7DataRowType.COUNTER:                  case S7DataRowType.TIMER:                  case S7DataRowType.BLOCK_FB:                  case S7DataRowType.BLOCK_FC:                  case S7DataRowType.BLOCK_DB:                  case S7DataRowType.BLOCK_SDB:                      //Parese Elementary unarray datatypes from the interface                      //All above datatypes have the same format:                      //the Length of the Interface itema is always 2 bytes                      //                      //InterfacePos + 0     = Datatype: 17 for Array                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration                      //                      //if parametertype is an "Ex" version                      //InterfacePos + 0     = Datatype: 17 for Array                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration                      //InterfacePos + 2     = Seemingly Random values' with unknown meaning                        var Par = new S7DataRow(VarName' datatype' myBlk);                      ParameterType parameterType = (ParameterType)interfaceBytes[InterfacePos + 1];                        //There is also an special case for "Extended" paramters. These contain an additional value                      if (HasExtendedParameter(parameterType))                      {                          int unkwonValue = interfaceBytes[InterfacePos + 2];                          InterfacePos++; //advance parsing by one additional byte                      }                        //if the type has an Start value' then parse it from the Start values                      if (HasInitialValues(parameterType))                          Par.StartValue = GetVarInitialValue(datatype' startValueBytes' ref StartValuePos);                        currPar.Add(Par);                      InterfacePos += 2; //Interface element is always 2 bytes                      break;                    case S7DataRowType.MultiInst_FB:                  case S7DataRowType.MultiInst_SFB:                      //Parese Block datatypes  from the interface                      //All above datatypes have the same format:                      //the Length of the Interface itema is always 3 bytes                      //                      //InterfacePos + 0     = Datatype: one of the BLOCK_xx types                      //InterfacePos + 1     = Block number LSB                      //InterfacePos + 1     = Block number MSB                        Par = new S7DataRow(VarName' datatype' myBlk);                        //if the type has an Start value' then parse it from the Start values                      int BlockNumber = BitConverter.ToInt16(interfaceBytes' InterfacePos + 1);                      Par.DataTypeBlockNumber = BlockNumber;                        currPar.Add(Par);                      InterfacePos += 3; //Interface element is always 3 bytes                      break;                    case S7DataRowType.STRING:                      //Parse String definition from Interface                      //Strings are a special case and have neither the format of Elementary nor the collection types or Array types                      //the Interface itme has an fixed length of:  3                       //                      //InterfacePos + 0     = Datatype: 0x13 for String                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration                      //InterfacePos + 2     = String Length                      //                      //Parameter Type is an EX version:                      //InterfacePos + 0     = Datatype: 0x13 for String                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration                      //InterfacePos + 2     = Seemingly Random values' with unknown meaning                      //InterfacePos + 3     = String Length                        Par = new S7DataRow(VarName' datatype' myBlk);                        //There is also an special case for "Extended" paramters. These contain an additional value                      parameterType = (ParameterType)interfaceBytes[InterfacePos + 1];                      if (HasExtendedParameter(parameterType))                      {                          int unkwonValue = interfaceBytes[InterfacePos + 2];                          InterfacePos++; //advance parsing by one additional byte                      }                        Par.StringSize = interfaceBytes[InterfacePos + 2];                        if (HasInitialValues(parameterType))                          Par.StartValue = GetVarInitialValue(datatype' startValueBytes' ref StartValuePos);                        currPar.Add(Par);                      InterfacePos += 3;  //3 byte interface row length                      break;                    case S7DataRowType.ARRAY:                      //Read the Array Dimension from the Interface                      //An array has the following format                      //the Interface itme has an variable length of:  3 + (Dimensions * 4)                      //                      //InterfacePos + 0     = Datatype: 0x10 for Array                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration                      //InterfacePos + 2     = Dimensions: Amount of dimensions to be parsed                      //InterfacePos + 3-4   = Lower Bound of 1st Dimension                      //InterfacePos + 5-6   = Upper Bound of 1st Dimension                      //InterfacePos + 7-8   = Lower Bound of 2nd Dimension if any                      //InterfacePos + 9-10  = Upper Bound of 2nd Dimensino if any                      //....                            //                      //Parameter Type is an EX version:                      //InterfacePos + 0     = Datatype: 0x10 for Array                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration                      //InterfacePos + 2     = Seemingly Random values' with unknown meaning                      //InterfacePos + 3     = Dimensions: Amount of dimensions to be parsed                      //InterfacePos + 4-5   = Lower Bound of 1st Dimension                      //InterfacePos + 6-7   = Upper Bound of 1st Dimension                      //InterfacePos + 8-9   = Lower Bound of 2nd Dimension if any                      //InterfacePos + 10-11  = Upper Bound of 2nd Dimensino if any                      //....                              //There is also an special case for "Extended" paramters. These contain an additional value                      parameterType = (ParameterType)interfaceBytes[InterfacePos + 1];                      if (HasExtendedParameter(parameterType))                      {                          int unkwonValue = interfaceBytes[InterfacePos + 2];                          InterfacePos++; //advance parsing by one additional byte                      }                        int ArrayDim = interfaceBytes[InterfacePos + 2];                      List<int> arrStart = new List<int>();                      List<int> arrStop = new List<int>();                        for (int i = 0; i <= ArrayDim - 1; i++)                      {                          arrStart.Add(BitConverter.ToInt16(interfaceBytes' InterfacePos + 3 + (i * 4)));                          arrStop.Add(BitConverter.ToInt16(interfaceBytes' InterfacePos + 5 + (i * 4)));                      }                        //Parse down child elements                      InterfacePos += 3 + (ArrayDim * 4);  //3 byte array header' and every dimension has an upper and lower bound' each an Uint16                      GetVarTypeEN(currPar' (S7DataRowType)interfaceBytes[InterfacePos]' true' true' VarName' interfaceBytes' ref InterfacePos' startValueBytes' ref StartValuePos' ref ParaList' ref StackNr' VarNameGen' myBlk);                        //Mark the current Element as Array' so that the recently parsed elements are counted as Array objects                      ((S7DataRow)currPar.Children[currPar.Children.Count - 1]).ArrayStart = arrStart;                      ((S7DataRow)currPar.Children[currPar.Children.Count - 1]).ArrayStop = arrStop;                      ((S7DataRow)currPar.Children[currPar.Children.Count - 1]).IsArray = true;                        break;                    case S7DataRowType.STRUCT: //Struct                      //Structs are nested datatypes' so go one recursivly. Also UDT get converted to Structs' so they are indistiguishable from them                      //Structs have the following format:                      //Structure Interface elements have an fixed length of 3 bytes or fixed length or 5 byte if children count is greater then 255.                      //There is also an special case with 4 Bytes length                      //                      //Child count < 255:                      //InterfacePos + 0     = Datatype: 0x11 for struct                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration. NOTE it is never DBInit' which means it never has Initial values                      //InterfacePos + 2     = Children count: the amount of sub-variables declared inside the structure                      //                      //There is an Special Case when the Child amount is greater than 255 Children.                       //in that case the original childcount on InterfacePos + 2 is set to FF and the next two bytes contain the real Child count                      //                      //Child count > 255:                      //InterfacePos + 0     = Datatype: 0x11 for struct                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration. NOTE it is never DBInit' which means it never has Initial values                      //InterfacePos + 2     = Marker that there are mor children: always 255                      //InterfacePos + 3     = Child count LSB                      //InterfacePos + 4     = Child count MSB                      //                      //There is another special case' when the ParameterType is 0x14. In that case the layout is similar to the special case with more than 255 children'                      //Except that the value InterfacePos + 2 has seemingly random Values. At the moment i do not know what these values mean                      //                      //Parameter Type is an EX version:                      //InterfacePos + 0     = Datatype: 0x11 for struct                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration. NOTE it is never DBInit' which means it never has Initial values                      //InterfacePos + 2     = Seemingly Random values' with unknown meaning                      //InterfacePos + 3     = Child count                        var akPar = new S7DataRow(VarName' datatype' myBlk);                      currPar.Add(akPar);                        //There is also an special case for "Extended" paramters. These contain an additional value                      parameterType = (ParameterType)interfaceBytes[InterfacePos + 1];                      if (HasExtendedParameter(parameterType))                      {                          int unkwonValue = interfaceBytes[InterfacePos + 2];                          InterfacePos++; //advance parsing by one additional byte                      }                        //Extract Children count from interface                      int Children = interfaceBytes[InterfacePos + 2];                      if (Children == 255)                      {                          //Reparse the children count from the next two bytes as an Integer as oposed to an single byte above                          Children = BitConverter.ToUInt16(interfaceBytes' InterfacePos + 3);                          InterfacePos += 5; //5 bytes for Structure Element length if more than 255 children' so it points to the next child element                      }                      else { InterfacePos += 3; } //3 bytes for Structure Element length' so it points to the next child element                        //Continue parsing insde the new Struct                      for (int i = 0; i < Children; i++)                      {                          GetVarTypeEN(akPar' (S7DataRowType)interfaceBytes[InterfacePos]' true' false' VarNameGen.GetNextVarName()' interfaceBytes' ref InterfacePos' startValueBytes' ref StartValuePos' ref ParaList' ref StackNr' VarNameGen' myBlk);                      }                      break;                    default:                      throw new Exception(string.Format("invalid or unknown interface declarations found while parsing the block interface at pos {0} with Paratype {1} and Datatype {2}"' InterfacePos' interfaceBytes[InterfacePos + 1]' interfaceBytes[InterfacePos]));              }
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Parameter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Parameter.cs,GetVarTypeEN,The following statement contains a magic number: switch (datatype)              {                  case S7DataRowType.BOOL:                  case S7DataRowType.BYTE:                  case S7DataRowType.CHAR:                  case S7DataRowType.WORD:                  case S7DataRowType.INT:                  case S7DataRowType.DWORD:                  case S7DataRowType.DINT:                  case S7DataRowType.REAL:                  case S7DataRowType.DATE:                  case S7DataRowType.TIME_OF_DAY:                  case S7DataRowType.TIME:                  case S7DataRowType.S5TIME:                  case S7DataRowType.DATE_AND_TIME:                  case S7DataRowType.POINTER:                  case S7DataRowType.ANY:                  case S7DataRowType.COUNTER:                  case S7DataRowType.TIMER:                  case S7DataRowType.BLOCK_FB:                  case S7DataRowType.BLOCK_FC:                  case S7DataRowType.BLOCK_DB:                  case S7DataRowType.BLOCK_SDB:                      //Parese Elementary unarray datatypes from the interface                      //All above datatypes have the same format:                      //the Length of the Interface itema is always 2 bytes                      //                      //InterfacePos + 0     = Datatype: 17 for Array                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration                      //                      //if parametertype is an "Ex" version                      //InterfacePos + 0     = Datatype: 17 for Array                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration                      //InterfacePos + 2     = Seemingly Random values' with unknown meaning                        var Par = new S7DataRow(VarName' datatype' myBlk);                      ParameterType parameterType = (ParameterType)interfaceBytes[InterfacePos + 1];                        //There is also an special case for "Extended" paramters. These contain an additional value                      if (HasExtendedParameter(parameterType))                      {                          int unkwonValue = interfaceBytes[InterfacePos + 2];                          InterfacePos++; //advance parsing by one additional byte                      }                        //if the type has an Start value' then parse it from the Start values                      if (HasInitialValues(parameterType))                          Par.StartValue = GetVarInitialValue(datatype' startValueBytes' ref StartValuePos);                        currPar.Add(Par);                      InterfacePos += 2; //Interface element is always 2 bytes                      break;                    case S7DataRowType.MultiInst_FB:                  case S7DataRowType.MultiInst_SFB:                      //Parese Block datatypes  from the interface                      //All above datatypes have the same format:                      //the Length of the Interface itema is always 3 bytes                      //                      //InterfacePos + 0     = Datatype: one of the BLOCK_xx types                      //InterfacePos + 1     = Block number LSB                      //InterfacePos + 1     = Block number MSB                        Par = new S7DataRow(VarName' datatype' myBlk);                        //if the type has an Start value' then parse it from the Start values                      int BlockNumber = BitConverter.ToInt16(interfaceBytes' InterfacePos + 1);                      Par.DataTypeBlockNumber = BlockNumber;                        currPar.Add(Par);                      InterfacePos += 3; //Interface element is always 3 bytes                      break;                    case S7DataRowType.STRING:                      //Parse String definition from Interface                      //Strings are a special case and have neither the format of Elementary nor the collection types or Array types                      //the Interface itme has an fixed length of:  3                       //                      //InterfacePos + 0     = Datatype: 0x13 for String                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration                      //InterfacePos + 2     = String Length                      //                      //Parameter Type is an EX version:                      //InterfacePos + 0     = Datatype: 0x13 for String                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration                      //InterfacePos + 2     = Seemingly Random values' with unknown meaning                      //InterfacePos + 3     = String Length                        Par = new S7DataRow(VarName' datatype' myBlk);                        //There is also an special case for "Extended" paramters. These contain an additional value                      parameterType = (ParameterType)interfaceBytes[InterfacePos + 1];                      if (HasExtendedParameter(parameterType))                      {                          int unkwonValue = interfaceBytes[InterfacePos + 2];                          InterfacePos++; //advance parsing by one additional byte                      }                        Par.StringSize = interfaceBytes[InterfacePos + 2];                        if (HasInitialValues(parameterType))                          Par.StartValue = GetVarInitialValue(datatype' startValueBytes' ref StartValuePos);                        currPar.Add(Par);                      InterfacePos += 3;  //3 byte interface row length                      break;                    case S7DataRowType.ARRAY:                      //Read the Array Dimension from the Interface                      //An array has the following format                      //the Interface itme has an variable length of:  3 + (Dimensions * 4)                      //                      //InterfacePos + 0     = Datatype: 0x10 for Array                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration                      //InterfacePos + 2     = Dimensions: Amount of dimensions to be parsed                      //InterfacePos + 3-4   = Lower Bound of 1st Dimension                      //InterfacePos + 5-6   = Upper Bound of 1st Dimension                      //InterfacePos + 7-8   = Lower Bound of 2nd Dimension if any                      //InterfacePos + 9-10  = Upper Bound of 2nd Dimensino if any                      //....                            //                      //Parameter Type is an EX version:                      //InterfacePos + 0     = Datatype: 0x10 for Array                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration                      //InterfacePos + 2     = Seemingly Random values' with unknown meaning                      //InterfacePos + 3     = Dimensions: Amount of dimensions to be parsed                      //InterfacePos + 4-5   = Lower Bound of 1st Dimension                      //InterfacePos + 6-7   = Upper Bound of 1st Dimension                      //InterfacePos + 8-9   = Lower Bound of 2nd Dimension if any                      //InterfacePos + 10-11  = Upper Bound of 2nd Dimensino if any                      //....                              //There is also an special case for "Extended" paramters. These contain an additional value                      parameterType = (ParameterType)interfaceBytes[InterfacePos + 1];                      if (HasExtendedParameter(parameterType))                      {                          int unkwonValue = interfaceBytes[InterfacePos + 2];                          InterfacePos++; //advance parsing by one additional byte                      }                        int ArrayDim = interfaceBytes[InterfacePos + 2];                      List<int> arrStart = new List<int>();                      List<int> arrStop = new List<int>();                        for (int i = 0; i <= ArrayDim - 1; i++)                      {                          arrStart.Add(BitConverter.ToInt16(interfaceBytes' InterfacePos + 3 + (i * 4)));                          arrStop.Add(BitConverter.ToInt16(interfaceBytes' InterfacePos + 5 + (i * 4)));                      }                        //Parse down child elements                      InterfacePos += 3 + (ArrayDim * 4);  //3 byte array header' and every dimension has an upper and lower bound' each an Uint16                      GetVarTypeEN(currPar' (S7DataRowType)interfaceBytes[InterfacePos]' true' true' VarName' interfaceBytes' ref InterfacePos' startValueBytes' ref StartValuePos' ref ParaList' ref StackNr' VarNameGen' myBlk);                        //Mark the current Element as Array' so that the recently parsed elements are counted as Array objects                      ((S7DataRow)currPar.Children[currPar.Children.Count - 1]).ArrayStart = arrStart;                      ((S7DataRow)currPar.Children[currPar.Children.Count - 1]).ArrayStop = arrStop;                      ((S7DataRow)currPar.Children[currPar.Children.Count - 1]).IsArray = true;                        break;                    case S7DataRowType.STRUCT: //Struct                      //Structs are nested datatypes' so go one recursivly. Also UDT get converted to Structs' so they are indistiguishable from them                      //Structs have the following format:                      //Structure Interface elements have an fixed length of 3 bytes or fixed length or 5 byte if children count is greater then 255.                      //There is also an special case with 4 Bytes length                      //                      //Child count < 255:                      //InterfacePos + 0     = Datatype: 0x11 for struct                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration. NOTE it is never DBInit' which means it never has Initial values                      //InterfacePos + 2     = Children count: the amount of sub-variables declared inside the structure                      //                      //There is an Special Case when the Child amount is greater than 255 Children.                       //in that case the original childcount on InterfacePos + 2 is set to FF and the next two bytes contain the real Child count                      //                      //Child count > 255:                      //InterfacePos + 0     = Datatype: 0x11 for struct                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration. NOTE it is never DBInit' which means it never has Initial values                      //InterfacePos + 2     = Marker that there are mor children: always 255                      //InterfacePos + 3     = Child count LSB                      //InterfacePos + 4     = Child count MSB                      //                      //There is another special case' when the ParameterType is 0x14. In that case the layout is similar to the special case with more than 255 children'                      //Except that the value InterfacePos + 2 has seemingly random Values. At the moment i do not know what these values mean                      //                      //Parameter Type is an EX version:                      //InterfacePos + 0     = Datatype: 0x11 for struct                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration. NOTE it is never DBInit' which means it never has Initial values                      //InterfacePos + 2     = Seemingly Random values' with unknown meaning                      //InterfacePos + 3     = Child count                        var akPar = new S7DataRow(VarName' datatype' myBlk);                      currPar.Add(akPar);                        //There is also an special case for "Extended" paramters. These contain an additional value                      parameterType = (ParameterType)interfaceBytes[InterfacePos + 1];                      if (HasExtendedParameter(parameterType))                      {                          int unkwonValue = interfaceBytes[InterfacePos + 2];                          InterfacePos++; //advance parsing by one additional byte                      }                        //Extract Children count from interface                      int Children = interfaceBytes[InterfacePos + 2];                      if (Children == 255)                      {                          //Reparse the children count from the next two bytes as an Integer as oposed to an single byte above                          Children = BitConverter.ToUInt16(interfaceBytes' InterfacePos + 3);                          InterfacePos += 5; //5 bytes for Structure Element length if more than 255 children' so it points to the next child element                      }                      else { InterfacePos += 3; } //3 bytes for Structure Element length' so it points to the next child element                        //Continue parsing insde the new Struct                      for (int i = 0; i < Children; i++)                      {                          GetVarTypeEN(akPar' (S7DataRowType)interfaceBytes[InterfacePos]' true' false' VarNameGen.GetNextVarName()' interfaceBytes' ref InterfacePos' startValueBytes' ref StartValuePos' ref ParaList' ref StackNr' VarNameGen' myBlk);                      }                      break;                    default:                      throw new Exception(string.Format("invalid or unknown interface declarations found while parsing the block interface at pos {0} with Paratype {1} and Datatype {2}"' InterfacePos' interfaceBytes[InterfacePos + 1]' interfaceBytes[InterfacePos]));              }
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Parameter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Parameter.cs,GetVarTypeEN,The following statement contains a magic number: switch (datatype)              {                  case S7DataRowType.BOOL:                  case S7DataRowType.BYTE:                  case S7DataRowType.CHAR:                  case S7DataRowType.WORD:                  case S7DataRowType.INT:                  case S7DataRowType.DWORD:                  case S7DataRowType.DINT:                  case S7DataRowType.REAL:                  case S7DataRowType.DATE:                  case S7DataRowType.TIME_OF_DAY:                  case S7DataRowType.TIME:                  case S7DataRowType.S5TIME:                  case S7DataRowType.DATE_AND_TIME:                  case S7DataRowType.POINTER:                  case S7DataRowType.ANY:                  case S7DataRowType.COUNTER:                  case S7DataRowType.TIMER:                  case S7DataRowType.BLOCK_FB:                  case S7DataRowType.BLOCK_FC:                  case S7DataRowType.BLOCK_DB:                  case S7DataRowType.BLOCK_SDB:                      //Parese Elementary unarray datatypes from the interface                      //All above datatypes have the same format:                      //the Length of the Interface itema is always 2 bytes                      //                      //InterfacePos + 0     = Datatype: 17 for Array                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration                      //                      //if parametertype is an "Ex" version                      //InterfacePos + 0     = Datatype: 17 for Array                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration                      //InterfacePos + 2     = Seemingly Random values' with unknown meaning                        var Par = new S7DataRow(VarName' datatype' myBlk);                      ParameterType parameterType = (ParameterType)interfaceBytes[InterfacePos + 1];                        //There is also an special case for "Extended" paramters. These contain an additional value                      if (HasExtendedParameter(parameterType))                      {                          int unkwonValue = interfaceBytes[InterfacePos + 2];                          InterfacePos++; //advance parsing by one additional byte                      }                        //if the type has an Start value' then parse it from the Start values                      if (HasInitialValues(parameterType))                          Par.StartValue = GetVarInitialValue(datatype' startValueBytes' ref StartValuePos);                        currPar.Add(Par);                      InterfacePos += 2; //Interface element is always 2 bytes                      break;                    case S7DataRowType.MultiInst_FB:                  case S7DataRowType.MultiInst_SFB:                      //Parese Block datatypes  from the interface                      //All above datatypes have the same format:                      //the Length of the Interface itema is always 3 bytes                      //                      //InterfacePos + 0     = Datatype: one of the BLOCK_xx types                      //InterfacePos + 1     = Block number LSB                      //InterfacePos + 1     = Block number MSB                        Par = new S7DataRow(VarName' datatype' myBlk);                        //if the type has an Start value' then parse it from the Start values                      int BlockNumber = BitConverter.ToInt16(interfaceBytes' InterfacePos + 1);                      Par.DataTypeBlockNumber = BlockNumber;                        currPar.Add(Par);                      InterfacePos += 3; //Interface element is always 3 bytes                      break;                    case S7DataRowType.STRING:                      //Parse String definition from Interface                      //Strings are a special case and have neither the format of Elementary nor the collection types or Array types                      //the Interface itme has an fixed length of:  3                       //                      //InterfacePos + 0     = Datatype: 0x13 for String                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration                      //InterfacePos + 2     = String Length                      //                      //Parameter Type is an EX version:                      //InterfacePos + 0     = Datatype: 0x13 for String                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration                      //InterfacePos + 2     = Seemingly Random values' with unknown meaning                      //InterfacePos + 3     = String Length                        Par = new S7DataRow(VarName' datatype' myBlk);                        //There is also an special case for "Extended" paramters. These contain an additional value                      parameterType = (ParameterType)interfaceBytes[InterfacePos + 1];                      if (HasExtendedParameter(parameterType))                      {                          int unkwonValue = interfaceBytes[InterfacePos + 2];                          InterfacePos++; //advance parsing by one additional byte                      }                        Par.StringSize = interfaceBytes[InterfacePos + 2];                        if (HasInitialValues(parameterType))                          Par.StartValue = GetVarInitialValue(datatype' startValueBytes' ref StartValuePos);                        currPar.Add(Par);                      InterfacePos += 3;  //3 byte interface row length                      break;                    case S7DataRowType.ARRAY:                      //Read the Array Dimension from the Interface                      //An array has the following format                      //the Interface itme has an variable length of:  3 + (Dimensions * 4)                      //                      //InterfacePos + 0     = Datatype: 0x10 for Array                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration                      //InterfacePos + 2     = Dimensions: Amount of dimensions to be parsed                      //InterfacePos + 3-4   = Lower Bound of 1st Dimension                      //InterfacePos + 5-6   = Upper Bound of 1st Dimension                      //InterfacePos + 7-8   = Lower Bound of 2nd Dimension if any                      //InterfacePos + 9-10  = Upper Bound of 2nd Dimensino if any                      //....                            //                      //Parameter Type is an EX version:                      //InterfacePos + 0     = Datatype: 0x10 for Array                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration                      //InterfacePos + 2     = Seemingly Random values' with unknown meaning                      //InterfacePos + 3     = Dimensions: Amount of dimensions to be parsed                      //InterfacePos + 4-5   = Lower Bound of 1st Dimension                      //InterfacePos + 6-7   = Upper Bound of 1st Dimension                      //InterfacePos + 8-9   = Lower Bound of 2nd Dimension if any                      //InterfacePos + 10-11  = Upper Bound of 2nd Dimensino if any                      //....                              //There is also an special case for "Extended" paramters. These contain an additional value                      parameterType = (ParameterType)interfaceBytes[InterfacePos + 1];                      if (HasExtendedParameter(parameterType))                      {                          int unkwonValue = interfaceBytes[InterfacePos + 2];                          InterfacePos++; //advance parsing by one additional byte                      }                        int ArrayDim = interfaceBytes[InterfacePos + 2];                      List<int> arrStart = new List<int>();                      List<int> arrStop = new List<int>();                        for (int i = 0; i <= ArrayDim - 1; i++)                      {                          arrStart.Add(BitConverter.ToInt16(interfaceBytes' InterfacePos + 3 + (i * 4)));                          arrStop.Add(BitConverter.ToInt16(interfaceBytes' InterfacePos + 5 + (i * 4)));                      }                        //Parse down child elements                      InterfacePos += 3 + (ArrayDim * 4);  //3 byte array header' and every dimension has an upper and lower bound' each an Uint16                      GetVarTypeEN(currPar' (S7DataRowType)interfaceBytes[InterfacePos]' true' true' VarName' interfaceBytes' ref InterfacePos' startValueBytes' ref StartValuePos' ref ParaList' ref StackNr' VarNameGen' myBlk);                        //Mark the current Element as Array' so that the recently parsed elements are counted as Array objects                      ((S7DataRow)currPar.Children[currPar.Children.Count - 1]).ArrayStart = arrStart;                      ((S7DataRow)currPar.Children[currPar.Children.Count - 1]).ArrayStop = arrStop;                      ((S7DataRow)currPar.Children[currPar.Children.Count - 1]).IsArray = true;                        break;                    case S7DataRowType.STRUCT: //Struct                      //Structs are nested datatypes' so go one recursivly. Also UDT get converted to Structs' so they are indistiguishable from them                      //Structs have the following format:                      //Structure Interface elements have an fixed length of 3 bytes or fixed length or 5 byte if children count is greater then 255.                      //There is also an special case with 4 Bytes length                      //                      //Child count < 255:                      //InterfacePos + 0     = Datatype: 0x11 for struct                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration. NOTE it is never DBInit' which means it never has Initial values                      //InterfacePos + 2     = Children count: the amount of sub-variables declared inside the structure                      //                      //There is an Special Case when the Child amount is greater than 255 Children.                       //in that case the original childcount on InterfacePos + 2 is set to FF and the next two bytes contain the real Child count                      //                      //Child count > 255:                      //InterfacePos + 0     = Datatype: 0x11 for struct                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration. NOTE it is never DBInit' which means it never has Initial values                      //InterfacePos + 2     = Marker that there are mor children: always 255                      //InterfacePos + 3     = Child count LSB                      //InterfacePos + 4     = Child count MSB                      //                      //There is another special case' when the ParameterType is 0x14. In that case the layout is similar to the special case with more than 255 children'                      //Except that the value InterfacePos + 2 has seemingly random Values. At the moment i do not know what these values mean                      //                      //Parameter Type is an EX version:                      //InterfacePos + 0     = Datatype: 0x11 for struct                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration. NOTE it is never DBInit' which means it never has Initial values                      //InterfacePos + 2     = Seemingly Random values' with unknown meaning                      //InterfacePos + 3     = Child count                        var akPar = new S7DataRow(VarName' datatype' myBlk);                      currPar.Add(akPar);                        //There is also an special case for "Extended" paramters. These contain an additional value                      parameterType = (ParameterType)interfaceBytes[InterfacePos + 1];                      if (HasExtendedParameter(parameterType))                      {                          int unkwonValue = interfaceBytes[InterfacePos + 2];                          InterfacePos++; //advance parsing by one additional byte                      }                        //Extract Children count from interface                      int Children = interfaceBytes[InterfacePos + 2];                      if (Children == 255)                      {                          //Reparse the children count from the next two bytes as an Integer as oposed to an single byte above                          Children = BitConverter.ToUInt16(interfaceBytes' InterfacePos + 3);                          InterfacePos += 5; //5 bytes for Structure Element length if more than 255 children' so it points to the next child element                      }                      else { InterfacePos += 3; } //3 bytes for Structure Element length' so it points to the next child element                        //Continue parsing insde the new Struct                      for (int i = 0; i < Children; i++)                      {                          GetVarTypeEN(akPar' (S7DataRowType)interfaceBytes[InterfacePos]' true' false' VarNameGen.GetNextVarName()' interfaceBytes' ref InterfacePos' startValueBytes' ref StartValuePos' ref ParaList' ref StackNr' VarNameGen' myBlk);                      }                      break;                    default:                      throw new Exception(string.Format("invalid or unknown interface declarations found while parsing the block interface at pos {0} with Paratype {1} and Datatype {2}"' InterfacePos' interfaceBytes[InterfacePos + 1]' interfaceBytes[InterfacePos]));              }
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Parameter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Parameter.cs,GetVarTypeEN,The following statement contains a magic number: switch (datatype)              {                  case S7DataRowType.BOOL:                  case S7DataRowType.BYTE:                  case S7DataRowType.CHAR:                  case S7DataRowType.WORD:                  case S7DataRowType.INT:                  case S7DataRowType.DWORD:                  case S7DataRowType.DINT:                  case S7DataRowType.REAL:                  case S7DataRowType.DATE:                  case S7DataRowType.TIME_OF_DAY:                  case S7DataRowType.TIME:                  case S7DataRowType.S5TIME:                  case S7DataRowType.DATE_AND_TIME:                  case S7DataRowType.POINTER:                  case S7DataRowType.ANY:                  case S7DataRowType.COUNTER:                  case S7DataRowType.TIMER:                  case S7DataRowType.BLOCK_FB:                  case S7DataRowType.BLOCK_FC:                  case S7DataRowType.BLOCK_DB:                  case S7DataRowType.BLOCK_SDB:                      //Parese Elementary unarray datatypes from the interface                      //All above datatypes have the same format:                      //the Length of the Interface itema is always 2 bytes                      //                      //InterfacePos + 0     = Datatype: 17 for Array                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration                      //                      //if parametertype is an "Ex" version                      //InterfacePos + 0     = Datatype: 17 for Array                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration                      //InterfacePos + 2     = Seemingly Random values' with unknown meaning                        var Par = new S7DataRow(VarName' datatype' myBlk);                      ParameterType parameterType = (ParameterType)interfaceBytes[InterfacePos + 1];                        //There is also an special case for "Extended" paramters. These contain an additional value                      if (HasExtendedParameter(parameterType))                      {                          int unkwonValue = interfaceBytes[InterfacePos + 2];                          InterfacePos++; //advance parsing by one additional byte                      }                        //if the type has an Start value' then parse it from the Start values                      if (HasInitialValues(parameterType))                          Par.StartValue = GetVarInitialValue(datatype' startValueBytes' ref StartValuePos);                        currPar.Add(Par);                      InterfacePos += 2; //Interface element is always 2 bytes                      break;                    case S7DataRowType.MultiInst_FB:                  case S7DataRowType.MultiInst_SFB:                      //Parese Block datatypes  from the interface                      //All above datatypes have the same format:                      //the Length of the Interface itema is always 3 bytes                      //                      //InterfacePos + 0     = Datatype: one of the BLOCK_xx types                      //InterfacePos + 1     = Block number LSB                      //InterfacePos + 1     = Block number MSB                        Par = new S7DataRow(VarName' datatype' myBlk);                        //if the type has an Start value' then parse it from the Start values                      int BlockNumber = BitConverter.ToInt16(interfaceBytes' InterfacePos + 1);                      Par.DataTypeBlockNumber = BlockNumber;                        currPar.Add(Par);                      InterfacePos += 3; //Interface element is always 3 bytes                      break;                    case S7DataRowType.STRING:                      //Parse String definition from Interface                      //Strings are a special case and have neither the format of Elementary nor the collection types or Array types                      //the Interface itme has an fixed length of:  3                       //                      //InterfacePos + 0     = Datatype: 0x13 for String                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration                      //InterfacePos + 2     = String Length                      //                      //Parameter Type is an EX version:                      //InterfacePos + 0     = Datatype: 0x13 for String                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration                      //InterfacePos + 2     = Seemingly Random values' with unknown meaning                      //InterfacePos + 3     = String Length                        Par = new S7DataRow(VarName' datatype' myBlk);                        //There is also an special case for "Extended" paramters. These contain an additional value                      parameterType = (ParameterType)interfaceBytes[InterfacePos + 1];                      if (HasExtendedParameter(parameterType))                      {                          int unkwonValue = interfaceBytes[InterfacePos + 2];                          InterfacePos++; //advance parsing by one additional byte                      }                        Par.StringSize = interfaceBytes[InterfacePos + 2];                        if (HasInitialValues(parameterType))                          Par.StartValue = GetVarInitialValue(datatype' startValueBytes' ref StartValuePos);                        currPar.Add(Par);                      InterfacePos += 3;  //3 byte interface row length                      break;                    case S7DataRowType.ARRAY:                      //Read the Array Dimension from the Interface                      //An array has the following format                      //the Interface itme has an variable length of:  3 + (Dimensions * 4)                      //                      //InterfacePos + 0     = Datatype: 0x10 for Array                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration                      //InterfacePos + 2     = Dimensions: Amount of dimensions to be parsed                      //InterfacePos + 3-4   = Lower Bound of 1st Dimension                      //InterfacePos + 5-6   = Upper Bound of 1st Dimension                      //InterfacePos + 7-8   = Lower Bound of 2nd Dimension if any                      //InterfacePos + 9-10  = Upper Bound of 2nd Dimensino if any                      //....                            //                      //Parameter Type is an EX version:                      //InterfacePos + 0     = Datatype: 0x10 for Array                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration                      //InterfacePos + 2     = Seemingly Random values' with unknown meaning                      //InterfacePos + 3     = Dimensions: Amount of dimensions to be parsed                      //InterfacePos + 4-5   = Lower Bound of 1st Dimension                      //InterfacePos + 6-7   = Upper Bound of 1st Dimension                      //InterfacePos + 8-9   = Lower Bound of 2nd Dimension if any                      //InterfacePos + 10-11  = Upper Bound of 2nd Dimensino if any                      //....                              //There is also an special case for "Extended" paramters. These contain an additional value                      parameterType = (ParameterType)interfaceBytes[InterfacePos + 1];                      if (HasExtendedParameter(parameterType))                      {                          int unkwonValue = interfaceBytes[InterfacePos + 2];                          InterfacePos++; //advance parsing by one additional byte                      }                        int ArrayDim = interfaceBytes[InterfacePos + 2];                      List<int> arrStart = new List<int>();                      List<int> arrStop = new List<int>();                        for (int i = 0; i <= ArrayDim - 1; i++)                      {                          arrStart.Add(BitConverter.ToInt16(interfaceBytes' InterfacePos + 3 + (i * 4)));                          arrStop.Add(BitConverter.ToInt16(interfaceBytes' InterfacePos + 5 + (i * 4)));                      }                        //Parse down child elements                      InterfacePos += 3 + (ArrayDim * 4);  //3 byte array header' and every dimension has an upper and lower bound' each an Uint16                      GetVarTypeEN(currPar' (S7DataRowType)interfaceBytes[InterfacePos]' true' true' VarName' interfaceBytes' ref InterfacePos' startValueBytes' ref StartValuePos' ref ParaList' ref StackNr' VarNameGen' myBlk);                        //Mark the current Element as Array' so that the recently parsed elements are counted as Array objects                      ((S7DataRow)currPar.Children[currPar.Children.Count - 1]).ArrayStart = arrStart;                      ((S7DataRow)currPar.Children[currPar.Children.Count - 1]).ArrayStop = arrStop;                      ((S7DataRow)currPar.Children[currPar.Children.Count - 1]).IsArray = true;                        break;                    case S7DataRowType.STRUCT: //Struct                      //Structs are nested datatypes' so go one recursivly. Also UDT get converted to Structs' so they are indistiguishable from them                      //Structs have the following format:                      //Structure Interface elements have an fixed length of 3 bytes or fixed length or 5 byte if children count is greater then 255.                      //There is also an special case with 4 Bytes length                      //                      //Child count < 255:                      //InterfacePos + 0     = Datatype: 0x11 for struct                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration. NOTE it is never DBInit' which means it never has Initial values                      //InterfacePos + 2     = Children count: the amount of sub-variables declared inside the structure                      //                      //There is an Special Case when the Child amount is greater than 255 Children.                       //in that case the original childcount on InterfacePos + 2 is set to FF and the next two bytes contain the real Child count                      //                      //Child count > 255:                      //InterfacePos + 0     = Datatype: 0x11 for struct                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration. NOTE it is never DBInit' which means it never has Initial values                      //InterfacePos + 2     = Marker that there are mor children: always 255                      //InterfacePos + 3     = Child count LSB                      //InterfacePos + 4     = Child count MSB                      //                      //There is another special case' when the ParameterType is 0x14. In that case the layout is similar to the special case with more than 255 children'                      //Except that the value InterfacePos + 2 has seemingly random Values. At the moment i do not know what these values mean                      //                      //Parameter Type is an EX version:                      //InterfacePos + 0     = Datatype: 0x11 for struct                      //InterfacePos + 1     = ParameterType: see "ParameterType" Enumeration. NOTE it is never DBInit' which means it never has Initial values                      //InterfacePos + 2     = Seemingly Random values' with unknown meaning                      //InterfacePos + 3     = Child count                        var akPar = new S7DataRow(VarName' datatype' myBlk);                      currPar.Add(akPar);                        //There is also an special case for "Extended" paramters. These contain an additional value                      parameterType = (ParameterType)interfaceBytes[InterfacePos + 1];                      if (HasExtendedParameter(parameterType))                      {                          int unkwonValue = interfaceBytes[InterfacePos + 2];                          InterfacePos++; //advance parsing by one additional byte                      }                        //Extract Children count from interface                      int Children = interfaceBytes[InterfacePos + 2];                      if (Children == 255)                      {                          //Reparse the children count from the next two bytes as an Integer as oposed to an single byte above                          Children = BitConverter.ToUInt16(interfaceBytes' InterfacePos + 3);                          InterfacePos += 5; //5 bytes for Structure Element length if more than 255 children' so it points to the next child element                      }                      else { InterfacePos += 3; } //3 bytes for Structure Element length' so it points to the next child element                        //Continue parsing insde the new Struct                      for (int i = 0; i < Children; i++)                      {                          GetVarTypeEN(akPar' (S7DataRowType)interfaceBytes[InterfacePos]' true' false' VarNameGen.GetNextVarName()' interfaceBytes' ref InterfacePos' startValueBytes' ref StartValuePos' ref ParaList' ref StackNr' VarNameGen' myBlk);                      }                      break;                    default:                      throw new Exception(string.Format("invalid or unknown interface declarations found while parsing the block interface at pos {0} with Paratype {1} and Datatype {2}"' InterfacePos' interfaceBytes[InterfacePos + 1]' interfaceBytes[InterfacePos]));              }
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Parameter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Parameter.cs,GetVarInitialValue,The following statement contains a magic number: switch (dataType)              {                  case S7DataRowType.BOOL:                      Result = data[valpos] > 0;                      valpos++;                      break;                  case S7DataRowType.BYTE:                      Result = data[valpos];                      valpos++;                      break;                  case S7DataRowType.CHAR:                      { // 'CHAR';                          Result = (char)data[valpos];                          valpos++;                      }                      break;                  case S7DataRowType.WORD:                      { // 'WORD';                          Result = BitConverter.ToInt16(data' valpos);                          valpos += 2;                      }                      break;                  case S7DataRowType.INT:                      { // 'INT';                          Result = BitConverter.ToInt16(data' valpos);                          valpos += 2;                      }                      break;                  case S7DataRowType.DWORD:                      { // 'DWORD';                          Result = BitConverter.ToInt32(data' valpos);                          valpos += 4;                      }                      break;                  case S7DataRowType.DINT:                      { // 'DINT';                          Result = BitConverter.ToInt32(data' valpos);                          valpos += 4;                      }                      break;                  case S7DataRowType.REAL:                      { // 'REAL';                          Result = BitConverter.ToSingle(data' valpos);                          valpos += 4;                      }                      break;                  case S7DataRowType.DATE:                      { // 'DATE';                          DateTime tmp = new DateTime(1990' 1' 1);                          var tmp2 = TimeSpan.FromDays(BitConverter.ToUInt16(data' valpos));                          tmp = tmp.Add(tmp2);                          Result = tmp;                          valpos += 2;                      }                      break;                  case S7DataRowType.TIME_OF_DAY:                      { // 'TIME_OF_DAY';                          long msval = BitConverter.ToUInt32(data' valpos);                          Result = new DateTime(msval * 10000);                          valpos += 4;                      }                      break;                  case S7DataRowType.TIME:                      { // 'TIME';                          long msval = BitConverter.ToInt32(data' valpos);                          Result = TimeSpan.FromMilliseconds(msval);                          valpos += 4;                      }                      break;                  case S7DataRowType.S5TIME:                      { // 'S5TIME';                          byte[] b1 = new byte[2];                          b1[1] = data[valpos + 0];                          b1[0] = data[valpos + 1];                            Result = libnodave.getS5Timefrom(b1' 0);                          valpos += 2;                      }                      break;                  case S7DataRowType.DATE_AND_TIME:                      { // 'DATE_AND_TIME';                                                  Result = libnodave.getDateTimefrom(data' valpos);                          valpos += 8;                      }                      break;                  case S7DataRowType.STRING:                      { // 'STRING';                          Result = Helper.GetS7String(valpos' -1' data);                          valpos += ((string)Result).Length + 2 - 2; //+2 because S7 strings have an one byte length filed and one byte used filed' and -2 because this library returns the string single quoted                      }                      break;                  //case S7DataRowType.SFB: //unclear' needs to be checked                  //    { // 'SFB??';                  //        Result = "SFB??";                  //    }                  //    break;                  default:                      Result = null;                      break;              }
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Parameter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Parameter.cs,GetVarInitialValue,The following statement contains a magic number: switch (dataType)              {                  case S7DataRowType.BOOL:                      Result = data[valpos] > 0;                      valpos++;                      break;                  case S7DataRowType.BYTE:                      Result = data[valpos];                      valpos++;                      break;                  case S7DataRowType.CHAR:                      { // 'CHAR';                          Result = (char)data[valpos];                          valpos++;                      }                      break;                  case S7DataRowType.WORD:                      { // 'WORD';                          Result = BitConverter.ToInt16(data' valpos);                          valpos += 2;                      }                      break;                  case S7DataRowType.INT:                      { // 'INT';                          Result = BitConverter.ToInt16(data' valpos);                          valpos += 2;                      }                      break;                  case S7DataRowType.DWORD:                      { // 'DWORD';                          Result = BitConverter.ToInt32(data' valpos);                          valpos += 4;                      }                      break;                  case S7DataRowType.DINT:                      { // 'DINT';                          Result = BitConverter.ToInt32(data' valpos);                          valpos += 4;                      }                      break;                  case S7DataRowType.REAL:                      { // 'REAL';                          Result = BitConverter.ToSingle(data' valpos);                          valpos += 4;                      }                      break;                  case S7DataRowType.DATE:                      { // 'DATE';                          DateTime tmp = new DateTime(1990' 1' 1);                          var tmp2 = TimeSpan.FromDays(BitConverter.ToUInt16(data' valpos));                          tmp = tmp.Add(tmp2);                          Result = tmp;                          valpos += 2;                      }                      break;                  case S7DataRowType.TIME_OF_DAY:                      { // 'TIME_OF_DAY';                          long msval = BitConverter.ToUInt32(data' valpos);                          Result = new DateTime(msval * 10000);                          valpos += 4;                      }                      break;                  case S7DataRowType.TIME:                      { // 'TIME';                          long msval = BitConverter.ToInt32(data' valpos);                          Result = TimeSpan.FromMilliseconds(msval);                          valpos += 4;                      }                      break;                  case S7DataRowType.S5TIME:                      { // 'S5TIME';                          byte[] b1 = new byte[2];                          b1[1] = data[valpos + 0];                          b1[0] = data[valpos + 1];                            Result = libnodave.getS5Timefrom(b1' 0);                          valpos += 2;                      }                      break;                  case S7DataRowType.DATE_AND_TIME:                      { // 'DATE_AND_TIME';                                                  Result = libnodave.getDateTimefrom(data' valpos);                          valpos += 8;                      }                      break;                  case S7DataRowType.STRING:                      { // 'STRING';                          Result = Helper.GetS7String(valpos' -1' data);                          valpos += ((string)Result).Length + 2 - 2; //+2 because S7 strings have an one byte length filed and one byte used filed' and -2 because this library returns the string single quoted                      }                      break;                  //case S7DataRowType.SFB: //unclear' needs to be checked                  //    { // 'SFB??';                  //        Result = "SFB??";                  //    }                  //    break;                  default:                      Result = null;                      break;              }
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Parameter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Parameter.cs,GetVarInitialValue,The following statement contains a magic number: switch (dataType)              {                  case S7DataRowType.BOOL:                      Result = data[valpos] > 0;                      valpos++;                      break;                  case S7DataRowType.BYTE:                      Result = data[valpos];                      valpos++;                      break;                  case S7DataRowType.CHAR:                      { // 'CHAR';                          Result = (char)data[valpos];                          valpos++;                      }                      break;                  case S7DataRowType.WORD:                      { // 'WORD';                          Result = BitConverter.ToInt16(data' valpos);                          valpos += 2;                      }                      break;                  case S7DataRowType.INT:                      { // 'INT';                          Result = BitConverter.ToInt16(data' valpos);                          valpos += 2;                      }                      break;                  case S7DataRowType.DWORD:                      { // 'DWORD';                          Result = BitConverter.ToInt32(data' valpos);                          valpos += 4;                      }                      break;                  case S7DataRowType.DINT:                      { // 'DINT';                          Result = BitConverter.ToInt32(data' valpos);                          valpos += 4;                      }                      break;                  case S7DataRowType.REAL:                      { // 'REAL';                          Result = BitConverter.ToSingle(data' valpos);                          valpos += 4;                      }                      break;                  case S7DataRowType.DATE:                      { // 'DATE';                          DateTime tmp = new DateTime(1990' 1' 1);                          var tmp2 = TimeSpan.FromDays(BitConverter.ToUInt16(data' valpos));                          tmp = tmp.Add(tmp2);                          Result = tmp;                          valpos += 2;                      }                      break;                  case S7DataRowType.TIME_OF_DAY:                      { // 'TIME_OF_DAY';                          long msval = BitConverter.ToUInt32(data' valpos);                          Result = new DateTime(msval * 10000);                          valpos += 4;                      }                      break;                  case S7DataRowType.TIME:                      { // 'TIME';                          long msval = BitConverter.ToInt32(data' valpos);                          Result = TimeSpan.FromMilliseconds(msval);                          valpos += 4;                      }                      break;                  case S7DataRowType.S5TIME:                      { // 'S5TIME';                          byte[] b1 = new byte[2];                          b1[1] = data[valpos + 0];                          b1[0] = data[valpos + 1];                            Result = libnodave.getS5Timefrom(b1' 0);                          valpos += 2;                      }                      break;                  case S7DataRowType.DATE_AND_TIME:                      { // 'DATE_AND_TIME';                                                  Result = libnodave.getDateTimefrom(data' valpos);                          valpos += 8;                      }                      break;                  case S7DataRowType.STRING:                      { // 'STRING';                          Result = Helper.GetS7String(valpos' -1' data);                          valpos += ((string)Result).Length + 2 - 2; //+2 because S7 strings have an one byte length filed and one byte used filed' and -2 because this library returns the string single quoted                      }                      break;                  //case S7DataRowType.SFB: //unclear' needs to be checked                  //    { // 'SFB??';                  //        Result = "SFB??";                  //    }                  //    break;                  default:                      Result = null;                      break;              }
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Parameter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Parameter.cs,GetVarInitialValue,The following statement contains a magic number: switch (dataType)              {                  case S7DataRowType.BOOL:                      Result = data[valpos] > 0;                      valpos++;                      break;                  case S7DataRowType.BYTE:                      Result = data[valpos];                      valpos++;                      break;                  case S7DataRowType.CHAR:                      { // 'CHAR';                          Result = (char)data[valpos];                          valpos++;                      }                      break;                  case S7DataRowType.WORD:                      { // 'WORD';                          Result = BitConverter.ToInt16(data' valpos);                          valpos += 2;                      }                      break;                  case S7DataRowType.INT:                      { // 'INT';                          Result = BitConverter.ToInt16(data' valpos);                          valpos += 2;                      }                      break;                  case S7DataRowType.DWORD:                      { // 'DWORD';                          Result = BitConverter.ToInt32(data' valpos);                          valpos += 4;                      }                      break;                  case S7DataRowType.DINT:                      { // 'DINT';                          Result = BitConverter.ToInt32(data' valpos);                          valpos += 4;                      }                      break;                  case S7DataRowType.REAL:                      { // 'REAL';                          Result = BitConverter.ToSingle(data' valpos);                          valpos += 4;                      }                      break;                  case S7DataRowType.DATE:                      { // 'DATE';                          DateTime tmp = new DateTime(1990' 1' 1);                          var tmp2 = TimeSpan.FromDays(BitConverter.ToUInt16(data' valpos));                          tmp = tmp.Add(tmp2);                          Result = tmp;                          valpos += 2;                      }                      break;                  case S7DataRowType.TIME_OF_DAY:                      { // 'TIME_OF_DAY';                          long msval = BitConverter.ToUInt32(data' valpos);                          Result = new DateTime(msval * 10000);                          valpos += 4;                      }                      break;                  case S7DataRowType.TIME:                      { // 'TIME';                          long msval = BitConverter.ToInt32(data' valpos);                          Result = TimeSpan.FromMilliseconds(msval);                          valpos += 4;                      }                      break;                  case S7DataRowType.S5TIME:                      { // 'S5TIME';                          byte[] b1 = new byte[2];                          b1[1] = data[valpos + 0];                          b1[0] = data[valpos + 1];                            Result = libnodave.getS5Timefrom(b1' 0);                          valpos += 2;                      }                      break;                  case S7DataRowType.DATE_AND_TIME:                      { // 'DATE_AND_TIME';                                                  Result = libnodave.getDateTimefrom(data' valpos);                          valpos += 8;                      }                      break;                  case S7DataRowType.STRING:                      { // 'STRING';                          Result = Helper.GetS7String(valpos' -1' data);                          valpos += ((string)Result).Length + 2 - 2; //+2 because S7 strings have an one byte length filed and one byte used filed' and -2 because this library returns the string single quoted                      }                      break;                  //case S7DataRowType.SFB: //unclear' needs to be checked                  //    { // 'SFB??';                  //        Result = "SFB??";                  //    }                  //    break;                  default:                      Result = null;                      break;              }
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Parameter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Parameter.cs,GetVarInitialValue,The following statement contains a magic number: switch (dataType)              {                  case S7DataRowType.BOOL:                      Result = data[valpos] > 0;                      valpos++;                      break;                  case S7DataRowType.BYTE:                      Result = data[valpos];                      valpos++;                      break;                  case S7DataRowType.CHAR:                      { // 'CHAR';                          Result = (char)data[valpos];                          valpos++;                      }                      break;                  case S7DataRowType.WORD:                      { // 'WORD';                          Result = BitConverter.ToInt16(data' valpos);                          valpos += 2;                      }                      break;                  case S7DataRowType.INT:                      { // 'INT';                          Result = BitConverter.ToInt16(data' valpos);                          valpos += 2;                      }                      break;                  case S7DataRowType.DWORD:                      { // 'DWORD';                          Result = BitConverter.ToInt32(data' valpos);                          valpos += 4;                      }                      break;                  case S7DataRowType.DINT:                      { // 'DINT';                          Result = BitConverter.ToInt32(data' valpos);                          valpos += 4;                      }                      break;                  case S7DataRowType.REAL:                      { // 'REAL';                          Result = BitConverter.ToSingle(data' valpos);                          valpos += 4;                      }                      break;                  case S7DataRowType.DATE:                      { // 'DATE';                          DateTime tmp = new DateTime(1990' 1' 1);                          var tmp2 = TimeSpan.FromDays(BitConverter.ToUInt16(data' valpos));                          tmp = tmp.Add(tmp2);                          Result = tmp;                          valpos += 2;                      }                      break;                  case S7DataRowType.TIME_OF_DAY:                      { // 'TIME_OF_DAY';                          long msval = BitConverter.ToUInt32(data' valpos);                          Result = new DateTime(msval * 10000);                          valpos += 4;                      }                      break;                  case S7DataRowType.TIME:                      { // 'TIME';                          long msval = BitConverter.ToInt32(data' valpos);                          Result = TimeSpan.FromMilliseconds(msval);                          valpos += 4;                      }                      break;                  case S7DataRowType.S5TIME:                      { // 'S5TIME';                          byte[] b1 = new byte[2];                          b1[1] = data[valpos + 0];                          b1[0] = data[valpos + 1];                            Result = libnodave.getS5Timefrom(b1' 0);                          valpos += 2;                      }                      break;                  case S7DataRowType.DATE_AND_TIME:                      { // 'DATE_AND_TIME';                                                  Result = libnodave.getDateTimefrom(data' valpos);                          valpos += 8;                      }                      break;                  case S7DataRowType.STRING:                      { // 'STRING';                          Result = Helper.GetS7String(valpos' -1' data);                          valpos += ((string)Result).Length + 2 - 2; //+2 because S7 strings have an one byte length filed and one byte used filed' and -2 because this library returns the string single quoted                      }                      break;                  //case S7DataRowType.SFB: //unclear' needs to be checked                  //    { // 'SFB??';                  //        Result = "SFB??";                  //    }                  //    break;                  default:                      Result = null;                      break;              }
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Parameter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Parameter.cs,GetVarInitialValue,The following statement contains a magic number: switch (dataType)              {                  case S7DataRowType.BOOL:                      Result = data[valpos] > 0;                      valpos++;                      break;                  case S7DataRowType.BYTE:                      Result = data[valpos];                      valpos++;                      break;                  case S7DataRowType.CHAR:                      { // 'CHAR';                          Result = (char)data[valpos];                          valpos++;                      }                      break;                  case S7DataRowType.WORD:                      { // 'WORD';                          Result = BitConverter.ToInt16(data' valpos);                          valpos += 2;                      }                      break;                  case S7DataRowType.INT:                      { // 'INT';                          Result = BitConverter.ToInt16(data' valpos);                          valpos += 2;                      }                      break;                  case S7DataRowType.DWORD:                      { // 'DWORD';                          Result = BitConverter.ToInt32(data' valpos);                          valpos += 4;                      }                      break;                  case S7DataRowType.DINT:                      { // 'DINT';                          Result = BitConverter.ToInt32(data' valpos);                          valpos += 4;                      }                      break;                  case S7DataRowType.REAL:                      { // 'REAL';                          Result = BitConverter.ToSingle(data' valpos);                          valpos += 4;                      }                      break;                  case S7DataRowType.DATE:                      { // 'DATE';                          DateTime tmp = new DateTime(1990' 1' 1);                          var tmp2 = TimeSpan.FromDays(BitConverter.ToUInt16(data' valpos));                          tmp = tmp.Add(tmp2);                          Result = tmp;                          valpos += 2;                      }                      break;                  case S7DataRowType.TIME_OF_DAY:                      { // 'TIME_OF_DAY';                          long msval = BitConverter.ToUInt32(data' valpos);                          Result = new DateTime(msval * 10000);                          valpos += 4;                      }                      break;                  case S7DataRowType.TIME:                      { // 'TIME';                          long msval = BitConverter.ToInt32(data' valpos);                          Result = TimeSpan.FromMilliseconds(msval);                          valpos += 4;                      }                      break;                  case S7DataRowType.S5TIME:                      { // 'S5TIME';                          byte[] b1 = new byte[2];                          b1[1] = data[valpos + 0];                          b1[0] = data[valpos + 1];                            Result = libnodave.getS5Timefrom(b1' 0);                          valpos += 2;                      }                      break;                  case S7DataRowType.DATE_AND_TIME:                      { // 'DATE_AND_TIME';                                                  Result = libnodave.getDateTimefrom(data' valpos);                          valpos += 8;                      }                      break;                  case S7DataRowType.STRING:                      { // 'STRING';                          Result = Helper.GetS7String(valpos' -1' data);                          valpos += ((string)Result).Length + 2 - 2; //+2 because S7 strings have an one byte length filed and one byte used filed' and -2 because this library returns the string single quoted                      }                      break;                  //case S7DataRowType.SFB: //unclear' needs to be checked                  //    { // 'SFB??';                  //        Result = "SFB??";                  //    }                  //    break;                  default:                      Result = null;                      break;              }
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Parameter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Parameter.cs,GetVarInitialValue,The following statement contains a magic number: switch (dataType)              {                  case S7DataRowType.BOOL:                      Result = data[valpos] > 0;                      valpos++;                      break;                  case S7DataRowType.BYTE:                      Result = data[valpos];                      valpos++;                      break;                  case S7DataRowType.CHAR:                      { // 'CHAR';                          Result = (char)data[valpos];                          valpos++;                      }                      break;                  case S7DataRowType.WORD:                      { // 'WORD';                          Result = BitConverter.ToInt16(data' valpos);                          valpos += 2;                      }                      break;                  case S7DataRowType.INT:                      { // 'INT';                          Result = BitConverter.ToInt16(data' valpos);                          valpos += 2;                      }                      break;                  case S7DataRowType.DWORD:                      { // 'DWORD';                          Result = BitConverter.ToInt32(data' valpos);                          valpos += 4;                      }                      break;                  case S7DataRowType.DINT:                      { // 'DINT';                          Result = BitConverter.ToInt32(data' valpos);                          valpos += 4;                      }                      break;                  case S7DataRowType.REAL:                      { // 'REAL';                          Result = BitConverter.ToSingle(data' valpos);                          valpos += 4;                      }                      break;                  case S7DataRowType.DATE:                      { // 'DATE';                          DateTime tmp = new DateTime(1990' 1' 1);                          var tmp2 = TimeSpan.FromDays(BitConverter.ToUInt16(data' valpos));                          tmp = tmp.Add(tmp2);                          Result = tmp;                          valpos += 2;                      }                      break;                  case S7DataRowType.TIME_OF_DAY:                      { // 'TIME_OF_DAY';                          long msval = BitConverter.ToUInt32(data' valpos);                          Result = new DateTime(msval * 10000);                          valpos += 4;                      }                      break;                  case S7DataRowType.TIME:                      { // 'TIME';                          long msval = BitConverter.ToInt32(data' valpos);                          Result = TimeSpan.FromMilliseconds(msval);                          valpos += 4;                      }                      break;                  case S7DataRowType.S5TIME:                      { // 'S5TIME';                          byte[] b1 = new byte[2];                          b1[1] = data[valpos + 0];                          b1[0] = data[valpos + 1];                            Result = libnodave.getS5Timefrom(b1' 0);                          valpos += 2;                      }                      break;                  case S7DataRowType.DATE_AND_TIME:                      { // 'DATE_AND_TIME';                                                  Result = libnodave.getDateTimefrom(data' valpos);                          valpos += 8;                      }                      break;                  case S7DataRowType.STRING:                      { // 'STRING';                          Result = Helper.GetS7String(valpos' -1' data);                          valpos += ((string)Result).Length + 2 - 2; //+2 because S7 strings have an one byte length filed and one byte used filed' and -2 because this library returns the string single quoted                      }                      break;                  //case S7DataRowType.SFB: //unclear' needs to be checked                  //    { // 'SFB??';                  //        Result = "SFB??";                  //    }                  //    break;                  default:                      Result = null;                      break;              }
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Parameter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Parameter.cs,GetVarInitialValue,The following statement contains a magic number: switch (dataType)              {                  case S7DataRowType.BOOL:                      Result = data[valpos] > 0;                      valpos++;                      break;                  case S7DataRowType.BYTE:                      Result = data[valpos];                      valpos++;                      break;                  case S7DataRowType.CHAR:                      { // 'CHAR';                          Result = (char)data[valpos];                          valpos++;                      }                      break;                  case S7DataRowType.WORD:                      { // 'WORD';                          Result = BitConverter.ToInt16(data' valpos);                          valpos += 2;                      }                      break;                  case S7DataRowType.INT:                      { // 'INT';                          Result = BitConverter.ToInt16(data' valpos);                          valpos += 2;                      }                      break;                  case S7DataRowType.DWORD:                      { // 'DWORD';                          Result = BitConverter.ToInt32(data' valpos);                          valpos += 4;                      }                      break;                  case S7DataRowType.DINT:                      { // 'DINT';                          Result = BitConverter.ToInt32(data' valpos);                          valpos += 4;                      }                      break;                  case S7DataRowType.REAL:                      { // 'REAL';                          Result = BitConverter.ToSingle(data' valpos);                          valpos += 4;                      }                      break;                  case S7DataRowType.DATE:                      { // 'DATE';                          DateTime tmp = new DateTime(1990' 1' 1);                          var tmp2 = TimeSpan.FromDays(BitConverter.ToUInt16(data' valpos));                          tmp = tmp.Add(tmp2);                          Result = tmp;                          valpos += 2;                      }                      break;                  case S7DataRowType.TIME_OF_DAY:                      { // 'TIME_OF_DAY';                          long msval = BitConverter.ToUInt32(data' valpos);                          Result = new DateTime(msval * 10000);                          valpos += 4;                      }                      break;                  case S7DataRowType.TIME:                      { // 'TIME';                          long msval = BitConverter.ToInt32(data' valpos);                          Result = TimeSpan.FromMilliseconds(msval);                          valpos += 4;                      }                      break;                  case S7DataRowType.S5TIME:                      { // 'S5TIME';                          byte[] b1 = new byte[2];                          b1[1] = data[valpos + 0];                          b1[0] = data[valpos + 1];                            Result = libnodave.getS5Timefrom(b1' 0);                          valpos += 2;                      }                      break;                  case S7DataRowType.DATE_AND_TIME:                      { // 'DATE_AND_TIME';                                                  Result = libnodave.getDateTimefrom(data' valpos);                          valpos += 8;                      }                      break;                  case S7DataRowType.STRING:                      { // 'STRING';                          Result = Helper.GetS7String(valpos' -1' data);                          valpos += ((string)Result).Length + 2 - 2; //+2 because S7 strings have an one byte length filed and one byte used filed' and -2 because this library returns the string single quoted                      }                      break;                  //case S7DataRowType.SFB: //unclear' needs to be checked                  //    { // 'SFB??';                  //        Result = "SFB??";                  //    }                  //    break;                  default:                      Result = null;                      break;              }
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Parameter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Parameter.cs,GetVarInitialValue,The following statement contains a magic number: switch (dataType)              {                  case S7DataRowType.BOOL:                      Result = data[valpos] > 0;                      valpos++;                      break;                  case S7DataRowType.BYTE:                      Result = data[valpos];                      valpos++;                      break;                  case S7DataRowType.CHAR:                      { // 'CHAR';                          Result = (char)data[valpos];                          valpos++;                      }                      break;                  case S7DataRowType.WORD:                      { // 'WORD';                          Result = BitConverter.ToInt16(data' valpos);                          valpos += 2;                      }                      break;                  case S7DataRowType.INT:                      { // 'INT';                          Result = BitConverter.ToInt16(data' valpos);                          valpos += 2;                      }                      break;                  case S7DataRowType.DWORD:                      { // 'DWORD';                          Result = BitConverter.ToInt32(data' valpos);                          valpos += 4;                      }                      break;                  case S7DataRowType.DINT:                      { // 'DINT';                          Result = BitConverter.ToInt32(data' valpos);                          valpos += 4;                      }                      break;                  case S7DataRowType.REAL:                      { // 'REAL';                          Result = BitConverter.ToSingle(data' valpos);                          valpos += 4;                      }                      break;                  case S7DataRowType.DATE:                      { // 'DATE';                          DateTime tmp = new DateTime(1990' 1' 1);                          var tmp2 = TimeSpan.FromDays(BitConverter.ToUInt16(data' valpos));                          tmp = tmp.Add(tmp2);                          Result = tmp;                          valpos += 2;                      }                      break;                  case S7DataRowType.TIME_OF_DAY:                      { // 'TIME_OF_DAY';                          long msval = BitConverter.ToUInt32(data' valpos);                          Result = new DateTime(msval * 10000);                          valpos += 4;                      }                      break;                  case S7DataRowType.TIME:                      { // 'TIME';                          long msval = BitConverter.ToInt32(data' valpos);                          Result = TimeSpan.FromMilliseconds(msval);                          valpos += 4;                      }                      break;                  case S7DataRowType.S5TIME:                      { // 'S5TIME';                          byte[] b1 = new byte[2];                          b1[1] = data[valpos + 0];                          b1[0] = data[valpos + 1];                            Result = libnodave.getS5Timefrom(b1' 0);                          valpos += 2;                      }                      break;                  case S7DataRowType.DATE_AND_TIME:                      { // 'DATE_AND_TIME';                                                  Result = libnodave.getDateTimefrom(data' valpos);                          valpos += 8;                      }                      break;                  case S7DataRowType.STRING:                      { // 'STRING';                          Result = Helper.GetS7String(valpos' -1' data);                          valpos += ((string)Result).Length + 2 - 2; //+2 because S7 strings have an one byte length filed and one byte used filed' and -2 because this library returns the string single quoted                      }                      break;                  //case S7DataRowType.SFB: //unclear' needs to be checked                  //    { // 'SFB??';                  //        Result = "SFB??";                  //    }                  //    break;                  default:                      Result = null;                      break;              }
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Parameter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Parameter.cs,GetVarInitialValue,The following statement contains a magic number: switch (dataType)              {                  case S7DataRowType.BOOL:                      Result = data[valpos] > 0;                      valpos++;                      break;                  case S7DataRowType.BYTE:                      Result = data[valpos];                      valpos++;                      break;                  case S7DataRowType.CHAR:                      { // 'CHAR';                          Result = (char)data[valpos];                          valpos++;                      }                      break;                  case S7DataRowType.WORD:                      { // 'WORD';                          Result = BitConverter.ToInt16(data' valpos);                          valpos += 2;                      }                      break;                  case S7DataRowType.INT:                      { // 'INT';                          Result = BitConverter.ToInt16(data' valpos);                          valpos += 2;                      }                      break;                  case S7DataRowType.DWORD:                      { // 'DWORD';                          Result = BitConverter.ToInt32(data' valpos);                          valpos += 4;                      }                      break;                  case S7DataRowType.DINT:                      { // 'DINT';                          Result = BitConverter.ToInt32(data' valpos);                          valpos += 4;                      }                      break;                  case S7DataRowType.REAL:                      { // 'REAL';                          Result = BitConverter.ToSingle(data' valpos);                          valpos += 4;                      }                      break;                  case S7DataRowType.DATE:                      { // 'DATE';                          DateTime tmp = new DateTime(1990' 1' 1);                          var tmp2 = TimeSpan.FromDays(BitConverter.ToUInt16(data' valpos));                          tmp = tmp.Add(tmp2);                          Result = tmp;                          valpos += 2;                      }                      break;                  case S7DataRowType.TIME_OF_DAY:                      { // 'TIME_OF_DAY';                          long msval = BitConverter.ToUInt32(data' valpos);                          Result = new DateTime(msval * 10000);                          valpos += 4;                      }                      break;                  case S7DataRowType.TIME:                      { // 'TIME';                          long msval = BitConverter.ToInt32(data' valpos);                          Result = TimeSpan.FromMilliseconds(msval);                          valpos += 4;                      }                      break;                  case S7DataRowType.S5TIME:                      { // 'S5TIME';                          byte[] b1 = new byte[2];                          b1[1] = data[valpos + 0];                          b1[0] = data[valpos + 1];                            Result = libnodave.getS5Timefrom(b1' 0);                          valpos += 2;                      }                      break;                  case S7DataRowType.DATE_AND_TIME:                      { // 'DATE_AND_TIME';                                                  Result = libnodave.getDateTimefrom(data' valpos);                          valpos += 8;                      }                      break;                  case S7DataRowType.STRING:                      { // 'STRING';                          Result = Helper.GetS7String(valpos' -1' data);                          valpos += ((string)Result).Length + 2 - 2; //+2 because S7 strings have an one byte length filed and one byte used filed' and -2 because this library returns the string single quoted                      }                      break;                  //case S7DataRowType.SFB: //unclear' needs to be checked                  //    { // 'SFB??';                  //        Result = "SFB??";                  //    }                  //    break;                  default:                      Result = null;                      break;              }
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Parameter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Parameter.cs,GetVarInitialValue,The following statement contains a magic number: switch (dataType)              {                  case S7DataRowType.BOOL:                      Result = data[valpos] > 0;                      valpos++;                      break;                  case S7DataRowType.BYTE:                      Result = data[valpos];                      valpos++;                      break;                  case S7DataRowType.CHAR:                      { // 'CHAR';                          Result = (char)data[valpos];                          valpos++;                      }                      break;                  case S7DataRowType.WORD:                      { // 'WORD';                          Result = BitConverter.ToInt16(data' valpos);                          valpos += 2;                      }                      break;                  case S7DataRowType.INT:                      { // 'INT';                          Result = BitConverter.ToInt16(data' valpos);                          valpos += 2;                      }                      break;                  case S7DataRowType.DWORD:                      { // 'DWORD';                          Result = BitConverter.ToInt32(data' valpos);                          valpos += 4;                      }                      break;                  case S7DataRowType.DINT:                      { // 'DINT';                          Result = BitConverter.ToInt32(data' valpos);                          valpos += 4;                      }                      break;                  case S7DataRowType.REAL:                      { // 'REAL';                          Result = BitConverter.ToSingle(data' valpos);                          valpos += 4;                      }                      break;                  case S7DataRowType.DATE:                      { // 'DATE';                          DateTime tmp = new DateTime(1990' 1' 1);                          var tmp2 = TimeSpan.FromDays(BitConverter.ToUInt16(data' valpos));                          tmp = tmp.Add(tmp2);                          Result = tmp;                          valpos += 2;                      }                      break;                  case S7DataRowType.TIME_OF_DAY:                      { // 'TIME_OF_DAY';                          long msval = BitConverter.ToUInt32(data' valpos);                          Result = new DateTime(msval * 10000);                          valpos += 4;                      }                      break;                  case S7DataRowType.TIME:                      { // 'TIME';                          long msval = BitConverter.ToInt32(data' valpos);                          Result = TimeSpan.FromMilliseconds(msval);                          valpos += 4;                      }                      break;                  case S7DataRowType.S5TIME:                      { // 'S5TIME';                          byte[] b1 = new byte[2];                          b1[1] = data[valpos + 0];                          b1[0] = data[valpos + 1];                            Result = libnodave.getS5Timefrom(b1' 0);                          valpos += 2;                      }                      break;                  case S7DataRowType.DATE_AND_TIME:                      { // 'DATE_AND_TIME';                                                  Result = libnodave.getDateTimefrom(data' valpos);                          valpos += 8;                      }                      break;                  case S7DataRowType.STRING:                      { // 'STRING';                          Result = Helper.GetS7String(valpos' -1' data);                          valpos += ((string)Result).Length + 2 - 2; //+2 because S7 strings have an one byte length filed and one byte used filed' and -2 because this library returns the string single quoted                      }                      break;                  //case S7DataRowType.SFB: //unclear' needs to be checked                  //    { // 'SFB??';                  //        Result = "SFB??";                  //    }                  //    break;                  default:                      Result = null;                      break;              }
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Parameter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Parameter.cs,GetVarInitialValue,The following statement contains a magic number: switch (dataType)              {                  case S7DataRowType.BOOL:                      Result = data[valpos] > 0;                      valpos++;                      break;                  case S7DataRowType.BYTE:                      Result = data[valpos];                      valpos++;                      break;                  case S7DataRowType.CHAR:                      { // 'CHAR';                          Result = (char)data[valpos];                          valpos++;                      }                      break;                  case S7DataRowType.WORD:                      { // 'WORD';                          Result = BitConverter.ToInt16(data' valpos);                          valpos += 2;                      }                      break;                  case S7DataRowType.INT:                      { // 'INT';                          Result = BitConverter.ToInt16(data' valpos);                          valpos += 2;                      }                      break;                  case S7DataRowType.DWORD:                      { // 'DWORD';                          Result = BitConverter.ToInt32(data' valpos);                          valpos += 4;                      }                      break;                  case S7DataRowType.DINT:                      { // 'DINT';                          Result = BitConverter.ToInt32(data' valpos);                          valpos += 4;                      }                      break;                  case S7DataRowType.REAL:                      { // 'REAL';                          Result = BitConverter.ToSingle(data' valpos);                          valpos += 4;                      }                      break;                  case S7DataRowType.DATE:                      { // 'DATE';                          DateTime tmp = new DateTime(1990' 1' 1);                          var tmp2 = TimeSpan.FromDays(BitConverter.ToUInt16(data' valpos));                          tmp = tmp.Add(tmp2);                          Result = tmp;                          valpos += 2;                      }                      break;                  case S7DataRowType.TIME_OF_DAY:                      { // 'TIME_OF_DAY';                          long msval = BitConverter.ToUInt32(data' valpos);                          Result = new DateTime(msval * 10000);                          valpos += 4;                      }                      break;                  case S7DataRowType.TIME:                      { // 'TIME';                          long msval = BitConverter.ToInt32(data' valpos);                          Result = TimeSpan.FromMilliseconds(msval);                          valpos += 4;                      }                      break;                  case S7DataRowType.S5TIME:                      { // 'S5TIME';                          byte[] b1 = new byte[2];                          b1[1] = data[valpos + 0];                          b1[0] = data[valpos + 1];                            Result = libnodave.getS5Timefrom(b1' 0);                          valpos += 2;                      }                      break;                  case S7DataRowType.DATE_AND_TIME:                      { // 'DATE_AND_TIME';                                                  Result = libnodave.getDateTimefrom(data' valpos);                          valpos += 8;                      }                      break;                  case S7DataRowType.STRING:                      { // 'STRING';                          Result = Helper.GetS7String(valpos' -1' data);                          valpos += ((string)Result).Length + 2 - 2; //+2 because S7 strings have an one byte length filed and one byte used filed' and -2 because this library returns the string single quoted                      }                      break;                  //case S7DataRowType.SFB: //unclear' needs to be checked                  //    { // 'SFB??';                  //        Result = "SFB??";                  //    }                  //    break;                  default:                      Result = null;                      break;              }
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Parameter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Parameter.cs,GetVarInitialValue,The following statement contains a magic number: switch (dataType)              {                  case S7DataRowType.BOOL:                      Result = data[valpos] > 0;                      valpos++;                      break;                  case S7DataRowType.BYTE:                      Result = data[valpos];                      valpos++;                      break;                  case S7DataRowType.CHAR:                      { // 'CHAR';                          Result = (char)data[valpos];                          valpos++;                      }                      break;                  case S7DataRowType.WORD:                      { // 'WORD';                          Result = BitConverter.ToInt16(data' valpos);                          valpos += 2;                      }                      break;                  case S7DataRowType.INT:                      { // 'INT';                          Result = BitConverter.ToInt16(data' valpos);                          valpos += 2;                      }                      break;                  case S7DataRowType.DWORD:                      { // 'DWORD';                          Result = BitConverter.ToInt32(data' valpos);                          valpos += 4;                      }                      break;                  case S7DataRowType.DINT:                      { // 'DINT';                          Result = BitConverter.ToInt32(data' valpos);                          valpos += 4;                      }                      break;                  case S7DataRowType.REAL:                      { // 'REAL';                          Result = BitConverter.ToSingle(data' valpos);                          valpos += 4;                      }                      break;                  case S7DataRowType.DATE:                      { // 'DATE';                          DateTime tmp = new DateTime(1990' 1' 1);                          var tmp2 = TimeSpan.FromDays(BitConverter.ToUInt16(data' valpos));                          tmp = tmp.Add(tmp2);                          Result = tmp;                          valpos += 2;                      }                      break;                  case S7DataRowType.TIME_OF_DAY:                      { // 'TIME_OF_DAY';                          long msval = BitConverter.ToUInt32(data' valpos);                          Result = new DateTime(msval * 10000);                          valpos += 4;                      }                      break;                  case S7DataRowType.TIME:                      { // 'TIME';                          long msval = BitConverter.ToInt32(data' valpos);                          Result = TimeSpan.FromMilliseconds(msval);                          valpos += 4;                      }                      break;                  case S7DataRowType.S5TIME:                      { // 'S5TIME';                          byte[] b1 = new byte[2];                          b1[1] = data[valpos + 0];                          b1[0] = data[valpos + 1];                            Result = libnodave.getS5Timefrom(b1' 0);                          valpos += 2;                      }                      break;                  case S7DataRowType.DATE_AND_TIME:                      { // 'DATE_AND_TIME';                                                  Result = libnodave.getDateTimefrom(data' valpos);                          valpos += 8;                      }                      break;                  case S7DataRowType.STRING:                      { // 'STRING';                          Result = Helper.GetS7String(valpos' -1' data);                          valpos += ((string)Result).Length + 2 - 2; //+2 because S7 strings have an one byte length filed and one byte used filed' and -2 because this library returns the string single quoted                      }                      break;                  //case S7DataRowType.SFB: //unclear' needs to be checked                  //    { // 'SFB??';                  //        Result = "SFB??";                  //    }                  //    break;                  default:                      Result = null;                      break;              }
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Parameter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Parameter.cs,GetVarInitialValue,The following statement contains a magic number: switch (dataType)              {                  case S7DataRowType.BOOL:                      Result = data[valpos] > 0;                      valpos++;                      break;                  case S7DataRowType.BYTE:                      Result = data[valpos];                      valpos++;                      break;                  case S7DataRowType.CHAR:                      { // 'CHAR';                          Result = (char)data[valpos];                          valpos++;                      }                      break;                  case S7DataRowType.WORD:                      { // 'WORD';                          Result = BitConverter.ToInt16(data' valpos);                          valpos += 2;                      }                      break;                  case S7DataRowType.INT:                      { // 'INT';                          Result = BitConverter.ToInt16(data' valpos);                          valpos += 2;                      }                      break;                  case S7DataRowType.DWORD:                      { // 'DWORD';                          Result = BitConverter.ToInt32(data' valpos);                          valpos += 4;                      }                      break;                  case S7DataRowType.DINT:                      { // 'DINT';                          Result = BitConverter.ToInt32(data' valpos);                          valpos += 4;                      }                      break;                  case S7DataRowType.REAL:                      { // 'REAL';                          Result = BitConverter.ToSingle(data' valpos);                          valpos += 4;                      }                      break;                  case S7DataRowType.DATE:                      { // 'DATE';                          DateTime tmp = new DateTime(1990' 1' 1);                          var tmp2 = TimeSpan.FromDays(BitConverter.ToUInt16(data' valpos));                          tmp = tmp.Add(tmp2);                          Result = tmp;                          valpos += 2;                      }                      break;                  case S7DataRowType.TIME_OF_DAY:                      { // 'TIME_OF_DAY';                          long msval = BitConverter.ToUInt32(data' valpos);                          Result = new DateTime(msval * 10000);                          valpos += 4;                      }                      break;                  case S7DataRowType.TIME:                      { // 'TIME';                          long msval = BitConverter.ToInt32(data' valpos);                          Result = TimeSpan.FromMilliseconds(msval);                          valpos += 4;                      }                      break;                  case S7DataRowType.S5TIME:                      { // 'S5TIME';                          byte[] b1 = new byte[2];                          b1[1] = data[valpos + 0];                          b1[0] = data[valpos + 1];                            Result = libnodave.getS5Timefrom(b1' 0);                          valpos += 2;                      }                      break;                  case S7DataRowType.DATE_AND_TIME:                      { // 'DATE_AND_TIME';                                                  Result = libnodave.getDateTimefrom(data' valpos);                          valpos += 8;                      }                      break;                  case S7DataRowType.STRING:                      { // 'STRING';                          Result = Helper.GetS7String(valpos' -1' data);                          valpos += ((string)Result).Length + 2 - 2; //+2 because S7 strings have an one byte length filed and one byte used filed' and -2 because this library returns the string single quoted                      }                      break;                  //case S7DataRowType.SFB: //unclear' needs to be checked                  //    { // 'SFB??';                  //        Result = "SFB??";                  //    }                  //    break;                  default:                      Result = null;                      break;              }
Magic Number,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Parameter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Parameter.cs,GetVarInitialValue,The following statement contains a magic number: switch (dataType)              {                  case S7DataRowType.BOOL:                      Result = data[valpos] > 0;                      valpos++;                      break;                  case S7DataRowType.BYTE:                      Result = data[valpos];                      valpos++;                      break;                  case S7DataRowType.CHAR:                      { // 'CHAR';                          Result = (char)data[valpos];                          valpos++;                      }                      break;                  case S7DataRowType.WORD:                      { // 'WORD';                          Result = BitConverter.ToInt16(data' valpos);                          valpos += 2;                      }                      break;                  case S7DataRowType.INT:                      { // 'INT';                          Result = BitConverter.ToInt16(data' valpos);                          valpos += 2;                      }                      break;                  case S7DataRowType.DWORD:                      { // 'DWORD';                          Result = BitConverter.ToInt32(data' valpos);                          valpos += 4;                      }                      break;                  case S7DataRowType.DINT:                      { // 'DINT';                          Result = BitConverter.ToInt32(data' valpos);                          valpos += 4;                      }                      break;                  case S7DataRowType.REAL:                      { // 'REAL';                          Result = BitConverter.ToSingle(data' valpos);                          valpos += 4;                      }                      break;                  case S7DataRowType.DATE:                      { // 'DATE';                          DateTime tmp = new DateTime(1990' 1' 1);                          var tmp2 = TimeSpan.FromDays(BitConverter.ToUInt16(data' valpos));                          tmp = tmp.Add(tmp2);                          Result = tmp;                          valpos += 2;                      }                      break;                  case S7DataRowType.TIME_OF_DAY:                      { // 'TIME_OF_DAY';                          long msval = BitConverter.ToUInt32(data' valpos);                          Result = new DateTime(msval * 10000);                          valpos += 4;                      }                      break;                  case S7DataRowType.TIME:                      { // 'TIME';                          long msval = BitConverter.ToInt32(data' valpos);                          Result = TimeSpan.FromMilliseconds(msval);                          valpos += 4;                      }                      break;                  case S7DataRowType.S5TIME:                      { // 'S5TIME';                          byte[] b1 = new byte[2];                          b1[1] = data[valpos + 0];                          b1[0] = data[valpos + 1];                            Result = libnodave.getS5Timefrom(b1' 0);                          valpos += 2;                      }                      break;                  case S7DataRowType.DATE_AND_TIME:                      { // 'DATE_AND_TIME';                                                  Result = libnodave.getDateTimefrom(data' valpos);                          valpos += 8;                      }                      break;                  case S7DataRowType.STRING:                      { // 'STRING';                          Result = Helper.GetS7String(valpos' -1' data);                          valpos += ((string)Result).Length + 2 - 2; //+2 because S7 strings have an one byte length filed and one byte used filed' and -2 because this library returns the string single quoted                      }                      break;                  //case S7DataRowType.SFB: //unclear' needs to be checked                  //    { // 'SFB??';                  //        Result = "SFB??";                  //    }                  //    break;                  default:                      Result = null;                      break;              }
Magic Number,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step5Project,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step5Project.cs,LoadProject,The following statement contains a magic number: ProjectName = System.Text.Encoding.UTF7.GetString(s5ProjectByteArray' 0x08' 8);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step5Project,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step5Project.cs,LoadProject,The following statement contains a magic number: int pos = 0x44 + j*19;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step5Project,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step5Project.cs,LoadProject,The following statement contains a magic number: sections_lst.Add(s5ProjectByteArray[pos + 15] + s5ProjectByteArray[pos + 16]*0x100);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step5Project,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step5Project.cs,LoadProject,The following statement contains a magic number: sections_lst.Add(s5ProjectByteArray[pos + 15] + s5ProjectByteArray[pos + 16]*0x100);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step5Project,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step5Project.cs,LoadProject,The following statement contains a magic number: int section_header_type = s5ProjectByteArray[section_start + 8];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step5Project,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step5Project.cs,LoadProject,The following statement contains a magic number: int anzbst = s5ProjectByteArray[section_start + 22];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step5Project,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step5Project.cs,LoadProject,The following statement contains a magic number: byte[] tmp = new byte[15];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step5Project,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step5Project.cs,LoadProject,The following statement contains a magic number: Array.Copy(s5ProjectByteArray' section_start + 68 + j*15' tmp' 0' 15);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step5Project,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step5Project.cs,LoadProject,The following statement contains a magic number: Array.Copy(s5ProjectByteArray' section_start + 68 + j*15' tmp' 0' 15);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step5Project,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step5Project.cs,LoadProject,The following statement contains a magic number: Array.Copy(s5ProjectByteArray' section_start + 68 + j*15' tmp' 0' 15);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step5Project,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step5Project.cs,LoadProject,The following statement contains a magic number: int section_header_size = s5ProjectByteArray[section_start + 18]*0x80;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step5Project,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step5Project.cs,AddBlockInfo,The following statement contains a magic number: len = (s5ProjectByteArray[pos + 8] * 0x100 + s5ProjectByteArray[pos + 9]) * 2;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step5Project,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step5Project.cs,AddBlockInfo,The following statement contains a magic number: len = (s5ProjectByteArray[pos + 8] * 0x100 + s5ProjectByteArray[pos + 9]) * 2;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step5Project,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step5Project.cs,AddBlockInfo,The following statement contains a magic number: len = (s5ProjectByteArray[pos + 8] * 0x100 + s5ProjectByteArray[pos + 9]) * 2;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step5Project,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step5Project.cs,AddBlockInfo,The following statement contains a magic number: tmpBlk.BlockType = (PLCBlockType)(s5ProjectByteArray[pos + 2] | 0xf00);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step5Project,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step5Project.cs,AddBlockInfo,The following statement contains a magic number: tmpBlk.BlockNumber = s5ProjectByteArray[pos + 3];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step5Project,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step5Project.cs,AddBlockInfo,The following statement contains a magic number: var bits = s5ProjectByteArray[pos + 4];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step5Project,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step5Project.cs,AddBlockInfo,The following statement contains a magic number: var bibNumber = s5ProjectByteArray[pos + 5] * 0x10000 + s5ProjectByteArray[pos + 6] * 0x100 + s5ProjectByteArray[pos + 7];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step5Project,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step5Project.cs,AddBlockInfo,The following statement contains a magic number: var bibNumber = s5ProjectByteArray[pos + 5] * 0x10000 + s5ProjectByteArray[pos + 6] * 0x100 + s5ProjectByteArray[pos + 7];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step5Project,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step5Project.cs,AddBlockInfo,The following statement contains a magic number: var bibNumber = s5ProjectByteArray[pos + 5] * 0x10000 + s5ProjectByteArray[pos + 6] * 0x100 + s5ProjectByteArray[pos + 7];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProjectHeader,The following statement contains a magic number: ProjectName = System.Text.Encoding.UTF7.GetString(projectFile' 5' projectFile[4]);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProjectHeader,The following statement contains a magic number: ProjectName = System.Text.Encoding.UTF7.GetString(projectFile' 5' projectFile[4]);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProjectHeader,The following statement contains a magic number: ProjectDescription = System.Text.Encoding.UTF7.GetString(projectFile' 5 + projectFile[4] + 2' projectFile[projectFile[4] + 6]);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProjectHeader,The following statement contains a magic number: ProjectDescription = System.Text.Encoding.UTF7.GetString(projectFile' 5 + projectFile[4] + 2' projectFile[projectFile[4] + 6]);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProjectHeader,The following statement contains a magic number: ProjectDescription = System.Text.Encoding.UTF7.GetString(projectFile' 5 + projectFile[4] + 2' projectFile[projectFile[4] + 6]);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProjectHeader,The following statement contains a magic number: ProjectDescription = System.Text.Encoding.UTF7.GetString(projectFile' 5 + projectFile[4] + 2' projectFile[projectFile[4] + 6]);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProjectHeader,The following statement contains a magic number: ProjectDescription = System.Text.Encoding.UTF7.GetString(projectFile' 5 + projectFile[4] + 2' projectFile[projectFile[4] + 6]);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The following statement contains a magic number: Convert.ToInt32(row["RELID"]) == 1315820
Magic Number,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The following statement contains a magic number: relID == 1315827
Magic Number,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The following statement contains a magic number: (int)row["TUNITID"] == z.ID && (int)row["TOBJTYP"] == 1314972
Magic Number,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The following statement contains a magic number: (int)row["TUNITID"] == z.ID && (int)row["TOBJTYP"] == 1314972
Magic Number,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The following statement contains a magic number: (int)row["TUNITID"] == z.ID && ((int)row["TOBJTYP"] == 1314972 || (int)row["TOBJTYP"] == 1315656 /* BackupCPU bei H Sys */)
Magic Number,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The following statement contains a magic number: (int)row["TUNITID"] == z.ID && ((int)row["TOBJTYP"] == 1314972 || (int)row["TOBJTYP"] == 1315656 /* BackupCPU bei H Sys */)
Magic Number,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The following statement contains a magic number: byte[] mempass = new byte[8];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The following statement contains a magic number: mempass[i] = (byte)(memoarray[i + 4] ^ 0xAA);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The following statement contains a magic number: i < 2
Magic Number,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The following statement contains a magic number: i < 8
Magic Number,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The following statement contains a magic number: memoarray.Length >= 12
Magic Number,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The following statement contains a magic number: (int)row["ATTRIIDM"] == 111142
Magic Number,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The following statement contains a magic number: byte[] mempass = new byte[8];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The following statement contains a magic number: mempass[i] = (byte)(memoarray[i + 4] ^ 0xAA);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The following statement contains a magic number: i < 2
Magic Number,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The following statement contains a magic number: i < 8
Magic Number,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The following statement contains a magic number: memoarray.Length >= 12
Magic Number,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The following statement contains a magic number: (int)row["ATTRIIDM"] == 111142
Magic Number,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The following statement contains a magic number: (int)row["RELID"] == 16
Magic Number,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The following statement contains a magic number: (int)row["RELID"] == 16
Magic Number,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The following statement contains a magic number: (int)row["RELID"] == 16
Magic Number,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The following statement contains a magic number: x.Folder = ProjectFolder + "ombstx" + _DirSeperator + "offline" + _DirSeperator + x.ID.ToString("X").PadLeft(8' '0') + _DirSeperator;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The following statement contains a magic number: x.Folder = ProjectFolder + "s7asrcom" + _DirSeperator + x.ID.ToString("X").PadLeft(8' '0') + _DirSeperator;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The following statement contains a magic number: (int)row["OBJTYP"] == 1314971
Magic Number,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The following statement contains a magic number: (int)row["OBJTYP"] == 1314988
Magic Number,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The following statement contains a magic number: objType == 1316787
Magic Number,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The following statement contains a magic number: Convert.ToInt32(row["RELID"]) == 64
Magic Number,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The following statement contains a magic number: var inf = attLst.FirstOrDefault(x => x.IDM == (int)row["ID"] && x.ATTRIIDM == 111386);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The following statement contains a magic number: (int)row["OBJTYP"] == 1316803
Magic Number,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The following statement contains a magic number: int wrt1 = tmpLink[pos1 + 3] * 0x100 + tmpLink[pos1 + 4];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The following statement contains a magic number: int wrt1 = tmpLink[pos1 + 3] * 0x100 + tmpLink[pos1 + 4];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The following statement contains a magic number: int wrt2 = tmpLink[pos2 + 3] * 0x100 + tmpLink[pos2 + 4];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The following statement contains a magic number: int wrt2 = tmpLink[pos2 + 3] * 0x100 + tmpLink[pos2 + 4];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The following statement contains a magic number: relID == 1315837
Magic Number,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The following statement contains a magic number: int lenStructure = 1705;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The following statement contains a magic number: int number = BitConverter.ToInt32(completeBuffer' position + 4);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The following statement contains a magic number: string strName = System.Text.Encoding.Default.GetString(completeBuffer' pos + 25' (int)completeBuffer[pos + 24]);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The following statement contains a magic number: string strName = System.Text.Encoding.Default.GetString(completeBuffer' pos + 25' (int)completeBuffer[pos + 24]);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The following statement contains a magic number: string strIP = System.Text.Encoding.Default.GetString(completeBuffer' pos + 20' (int)completeBuffer[pos + 19]);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The following statement contains a magic number: string strIP = System.Text.Encoding.Default.GetString(completeBuffer' pos + 20' (int)completeBuffer[pos + 19]);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The following statement contains a magic number: byte[] bIP = new byte[4];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The following statement contains a magic number: bIP[0] = byte.Parse(strIP.Substring(0' 2)' System.Globalization.NumberStyles.AllowHexSpecifier);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The following statement contains a magic number: bIP[1] = byte.Parse(strIP.Substring(2' 2)' System.Globalization.NumberStyles.AllowHexSpecifier);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The following statement contains a magic number: bIP[1] = byte.Parse(strIP.Substring(2' 2)' System.Globalization.NumberStyles.AllowHexSpecifier);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The following statement contains a magic number: bIP[2] = byte.Parse(strIP.Substring(4' 2)' System.Globalization.NumberStyles.AllowHexSpecifier);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The following statement contains a magic number: bIP[2] = byte.Parse(strIP.Substring(4' 2)' System.Globalization.NumberStyles.AllowHexSpecifier);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The following statement contains a magic number: bIP[2] = byte.Parse(strIP.Substring(4' 2)' System.Globalization.NumberStyles.AllowHexSpecifier);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The following statement contains a magic number: bIP[3] = byte.Parse(strIP.Substring(6' 2)' System.Globalization.NumberStyles.AllowHexSpecifier);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The following statement contains a magic number: bIP[3] = byte.Parse(strIP.Substring(6' 2)' System.Globalization.NumberStyles.AllowHexSpecifier);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The following statement contains a magic number: bIP[3] = byte.Parse(strIP.Substring(6' 2)' System.Globalization.NumberStyles.AllowHexSpecifier);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The following statement contains a magic number: string strMAC = System.Text.Encoding.Default.GetString(completeBuffer' pos + 20' (int)completeBuffer[pos + 19]);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The following statement contains a magic number: string strMAC = System.Text.Encoding.Default.GetString(completeBuffer' pos + 20' (int)completeBuffer[pos + 19]);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The following statement contains a magic number: string strMask = System.Text.Encoding.Default.GetString(completeBuffer' pos + 20' (int)completeBuffer[pos + 19]);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The following statement contains a magic number: string strMask = System.Text.Encoding.Default.GetString(completeBuffer' pos + 20' (int)completeBuffer[pos + 19]);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The following statement contains a magic number: byte[] bIP = new byte[4];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The following statement contains a magic number: bIP[0] = byte.Parse(strMask.Substring(0' 2)' System.Globalization.NumberStyles.AllowHexSpecifier);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The following statement contains a magic number: bIP[1] = byte.Parse(strMask.Substring(2' 2)' System.Globalization.NumberStyles.AllowHexSpecifier);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The following statement contains a magic number: bIP[1] = byte.Parse(strMask.Substring(2' 2)' System.Globalization.NumberStyles.AllowHexSpecifier);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The following statement contains a magic number: bIP[2] = byte.Parse(strMask.Substring(4' 2)' System.Globalization.NumberStyles.AllowHexSpecifier);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The following statement contains a magic number: bIP[2] = byte.Parse(strMask.Substring(4' 2)' System.Globalization.NumberStyles.AllowHexSpecifier);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The following statement contains a magic number: bIP[2] = byte.Parse(strMask.Substring(4' 2)' System.Globalization.NumberStyles.AllowHexSpecifier);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The following statement contains a magic number: bIP[3] = byte.Parse(strMask.Substring(6' 2)' System.Globalization.NumberStyles.AllowHexSpecifier);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The following statement contains a magic number: bIP[3] = byte.Parse(strMask.Substring(6' 2)' System.Globalization.NumberStyles.AllowHexSpecifier);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The following statement contains a magic number: bIP[3] = byte.Parse(strMask.Substring(6' 2)' System.Globalization.NumberStyles.AllowHexSpecifier);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The following statement contains a magic number: string strRouter = System.Text.Encoding.Default.GetString(completeBuffer' pos + 20' (int)completeBuffer[pos + 19]);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The following statement contains a magic number: string strRouter = System.Text.Encoding.Default.GetString(completeBuffer' pos + 20' (int)completeBuffer[pos + 19]);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The following statement contains a magic number: byte[] bIP = new byte[4];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The following statement contains a magic number: bIP[0] = byte.Parse(strRouter.Substring(0' 2)' System.Globalization.NumberStyles.AllowHexSpecifier);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The following statement contains a magic number: bIP[1] = byte.Parse(strRouter.Substring(2' 2)' System.Globalization.NumberStyles.AllowHexSpecifier);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The following statement contains a magic number: bIP[1] = byte.Parse(strRouter.Substring(2' 2)' System.Globalization.NumberStyles.AllowHexSpecifier);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The following statement contains a magic number: bIP[2] = byte.Parse(strRouter.Substring(4' 2)' System.Globalization.NumberStyles.AllowHexSpecifier);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The following statement contains a magic number: bIP[2] = byte.Parse(strRouter.Substring(4' 2)' System.Globalization.NumberStyles.AllowHexSpecifier);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The following statement contains a magic number: bIP[2] = byte.Parse(strRouter.Substring(4' 2)' System.Globalization.NumberStyles.AllowHexSpecifier);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The following statement contains a magic number: bIP[3] = byte.Parse(strRouter.Substring(6' 2)' System.Globalization.NumberStyles.AllowHexSpecifier);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The following statement contains a magic number: bIP[3] = byte.Parse(strRouter.Substring(6' 2)' System.Globalization.NumberStyles.AllowHexSpecifier);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The following statement contains a magic number: bIP[3] = byte.Parse(strRouter.Substring(6' 2)' System.Globalization.NumberStyles.AllowHexSpecifier);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The following statement contains a magic number: ethernet.UseRouter = Convert.ToBoolean(completeBuffer[pos + 19]);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The following statement contains a magic number: ethernet.UseIp = Convert.ToBoolean(completeBuffer[pos + 19]);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The following statement contains a magic number: ethernet.UseIso = Convert.ToBoolean(completeBuffer[pos + 19]);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The following statement contains a magic number: lenStructure = 2000;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The following statement contains a magic number: int number = BitConverter.ToInt32(completeBuffer' position + 4);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The following statement contains a magic number: MpiDP.Address = (int)Convert.ToByte(completeBuffer[pos + 19 + (int)Convert.ToByte(completeBuffer[pos + 8])]);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The following statement contains a magic number: MpiDP.Address = (int)Convert.ToByte(completeBuffer[pos + 19 + (int)Convert.ToByte(completeBuffer[pos + 8])]);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The following statement contains a magic number: string strName = System.Text.Encoding.Default.GetString(completeBuffer' pos + 25' (int)completeBuffer[pos + 24]);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The following statement contains a magic number: string strName = System.Text.Encoding.Default.GetString(completeBuffer' pos + 25' (int)completeBuffer[pos + 24]);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The following statement contains a magic number: lenStructure = 2000;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The following statement contains a magic number: int number = BitConverter.ToInt32(completeBuffer' position + 4);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The following statement contains a magic number: MpiDP.Address = (int)Convert.ToByte(completeBuffer[pos + 19 + (int)Convert.ToByte(completeBuffer[pos + 8])]);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The following statement contains a magic number: MpiDP.Address = (int)Convert.ToByte(completeBuffer[pos + 19 + (int)Convert.ToByte(completeBuffer[pos + 8])]);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The following statement contains a magic number: string strName = System.Text.Encoding.Default.GetString(completeBuffer' pos + 25' (int)completeBuffer[pos + 24]);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The following statement contains a magic number: string strName = System.Text.Encoding.Default.GetString(completeBuffer' pos + 25' (int)completeBuffer[pos + 24]);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Projectfiles.TIA,TiaCompression,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\TIA\TiaCompression.cs,IsDeflateStream,The following statement contains a magic number: byte[] buffer = new byte[4];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Projectfiles.TIA,TiaCompression,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\TIA\TiaCompression.cs,IsDeflateStream,The following statement contains a magic number: compressedStream.Read(buffer' 0' 4);
Magic Number,DotNetSiemensPLCToolBoxLibrary.Projectfiles.TIA,TiaCompression,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\TIA\TiaCompression.cs,IsDeflateStream,The following statement contains a magic number: compressedStream.Position -= 4L;
Magic Number,DotNetSiemensPLCToolBoxLibrary.Projectfiles.TIA,TiaHelper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\TIA\TiaHelper.cs,IsMarker,The following statement contains a magic number: var arr = new byte[20];
Magic Number,DotNetSiemensPLCToolBoxLibrary.Projectfiles.TIA,TiaHelper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\TIA\TiaHelper.cs,IsMarker,The following statement contains a magic number: arr[1] == '#' && arr[2] == '#'
Magic Number,DotNetSiemensPLCToolBoxLibrary.Projectfiles.TIA,TiaHelper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\TIA\TiaHelper.cs,IsMarker,The following statement contains a magic number: arr[1] == '$' && arr[2] == '$'
Magic Number,DotNetSiemensPLCToolBoxLibrary.Projectfiles.TIA,TiaObjectId,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\TIA\TiaObjectId.cs,GetHashCode,The following statement contains a magic number: result = (result * 397) ^ InstanceId.GetHashCode();
Magic Number,DotNetSiemensPLCToolBoxLibrary.Projectfiles.TIA,TiaObjectId,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\TIA\TiaObjectId.cs,GetHashCode,The following statement contains a magic number: result = (result * 397) ^ TypeId.GetHashCode();
Duplicate Code,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,CallConverter,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\CallConverter.cs,ConvertUCToCall,The method contains a code clone-set at the following line numbers (starting from the method definition): ((369' 402)' (628' 661))
Duplicate Code,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7toAWL.cs,GetAWL,The method contains a code clone-set at the following line numbers (starting from the method definition): ((3022' 3041)' (3064' 3083)' (3202' 3221))
Duplicate Code,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The method contains a code clone-set at the following line numbers (starting from the method definition): ((349' 371)' (413' 435))
Duplicate Code,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The method contains a code clone-set at the following line numbers (starting from the method definition): ((1136' 1156)' (1181' 1201))
Missing Default,DotNetSiemensPLCToolBoxLibrary.Communication.FetchWrite,FetchWriteConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\FetchWrite\FetchWriteConnection.cs,ReadValue,The following switch statement is missing a default case: switch (tag.TagDataSource)                  {                      case MemoryArea.Datablock:                      case MemoryArea.InstanceDatablock:                          rqHeader.org_id = (byte) OrgTypes.DB;                          break;                      case MemoryArea.Inputs:                          rqHeader.org_id = (byte) OrgTypes.Inputs;                          break;                      case MemoryArea.Outputs:                          rqHeader.org_id = (byte) OrgTypes.Outputs;                          break;                      case MemoryArea.S5_DX:                          rqHeader.org_id = (byte) OrgTypes.DBx;                          break;                      case MemoryArea.Flags:                          rqHeader.org_id = (byte) OrgTypes.Flags;                          break;                      case MemoryArea.Counter:                          rqHeader.org_id = (byte) OrgTypes.Counters;                          break;                      case MemoryArea.Timer:                          rqHeader.org_id = (byte) OrgTypes.Timer;                          break;                  }
Missing Default,DotNetSiemensPLCToolBoxLibrary.Communication.FetchWrite,FetchWriteConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\FetchWrite\FetchWriteConnection.cs,WriteValue,The following switch statement is missing a default case: switch (tag.TagDataSource)                  {                      case MemoryArea.Datablock:                      case MemoryArea.InstanceDatablock:                          rqHeader.org_id = (byte) OrgTypes.DB;                          break;                      case MemoryArea.Inputs:                          rqHeader.org_id = (byte) OrgTypes.Inputs;                          break;                      case MemoryArea.Outputs:                          rqHeader.org_id = (byte) OrgTypes.Outputs;                          break;                      case MemoryArea.S5_DX:                          rqHeader.org_id = (byte) OrgTypes.DBx;                          break;                      case MemoryArea.Flags:                          rqHeader.org_id = (byte) OrgTypes.Flags;                          break;                      case MemoryArea.Counter:                          rqHeader.org_id = (byte) OrgTypes.Counters;                          break;                      case MemoryArea.Timer:                          rqHeader.org_id = (byte) OrgTypes.Timer;                          break;                  }
Missing Default,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,daveStrS7onlineError,The following switch statement is missing a default case: switch (err)              {                  case 202:                      return "S7Online: Ressourcenengpaß im Treiber oder in der Library";                  case 203:                      return "S7Online: Konfigurationsfehler";                  case 205:                      return "S7Online: Auftrag zur Zeit nicht erlaubt";                  case 206:                      return "S7Online: Parameterfehler";                  case 207:                      return "S7Online: Gerät bereits/noch nicht geöffnet.";                  case 208:                      return "S7Online: CP reagiert nicht";                  case 209:                      return "S7Online: Fehler in der Firmware";                  case 210:                      return "S7Online: Speicherengpaß im Treiber";                  case 215:                      return "S7Online: Keine Nachricht vorhanden";                  case 216:                      return "S7Online: Fehler bei Zugriff auf Anwendungspuffer";                  case 219:                      return "S7Online: Timeout abgelaufen";                  case 225:                      return "S7Online: Die maximale Anzahl an Anmeldungen ist überschritten";                  case 226:                      return "S7Online: Der Auftrag wurde abgebrochen";                  case 233:                      return "S7Online: Ein Hilfsprogramm konnte nicht gestartet werden";                  case 234:                      return "S7Online: Keine Autorisierung für diese Funktion vorhanden";                  case 304:                      return "S7Online: Initialisierung noch nicht abgeschlossen";                  case 305:                      return "S7Online: Funktion nicht implementiert";                  case 4865:                      return "S7Online: CP-Name nicht vorhanden";                  case 4866:                      return "S7Online: CP-Name nicht konfiguriert";                  case 4867:                      return "S7Online: Kanalname nicht vorhanden";                  case 4868:                      return "S7Online: Kanalname nicht konfiguriert";              }
Missing Default,DotNetSiemensPLCToolBoxLibrary.Communication.LibNoDave,libnodave,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\LibNoDave\libnodave.net.cs,getS5Timefrom,The following switch statement is missing a default case: switch (basis)              {                  case 0:                      zahl = zahl * 100000;                      break;                  case 1:                      zahl = zahl * 1000000;                      break;                  case 2:                      zahl = zahl * 10000000;                      break;                  case 3:                      zahl = zahl * 100000000;                      break;                }
Missing Default,DotNetSiemensPLCToolBoxLibrary.Communication.Library,ByteFunctions,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\Library\ByteFunctions.cs,getS5Timefrom,The following switch statement is missing a default case: switch (basis)              {                  case 0:                      zahl = zahl*100000;                      break;                  case 1:                      zahl = zahl*1000000;                      break;                  case 2:                      zahl = zahl*10000000;                      break;                  case 3:                      zahl = zahl*100000000;                      break;                }
Missing Default,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,Connect,The following switch statement is missing a default case: switch (_configuration.ConnectionType)                  {                      case LibNodaveConnectionTypes.MPI_über_Serial_Adapter:                      case LibNodaveConnectionTypes.MPI_über_Serial_Adapter_Andrews_Version_without_STX:                      case LibNodaveConnectionTypes.MPI_über_Serial_Adapter_Step_7_Version:                      case LibNodaveConnectionTypes.MPI_über_Serial_Adapter_Adrews_Version_with_STX:                      case LibNodaveConnectionTypes.PPI_über_Serial_Adapter:                          _errorCodeConverter = libnodave.daveStrerror;                          _fds.rfd = libnodave.setPort(_configuration.ComPort' _configuration.ComPortSpeed' (int)_configuration.ComPortParity);                          break;                        case LibNodaveConnectionTypes.AS_511:                          _errorCodeConverter = libnodave.daveStrerror;                          _fds.rfd = libnodave.setPort(_configuration.ComPort' _configuration.ComPortSpeed' (int)_configuration.ComPortParity);                          break;    #if !IPHONE                      case LibNodaveConnectionTypes.Use_Step7_DLL:                      case LibNodaveConnectionTypes.Use_Step7_DLL_Without_TCP:                          _errorCodeConverter = libnodave.daveStrerror;                          _fds.rfd = libnodave.openS7online(_configuration.EntryPoint' 0);                          if (_fds.rfd.ToInt32() == -1)                          {                              _NeedDispose = false;                              throw new Exception("Error: " + libnodave.daveStrS7onlineError());                          }                          break;  #endif                        case LibNodaveConnectionTypes.ISO_over_TCP:                      case LibNodaveConnectionTypes.ISO_over_TCP_CP_243:                      case LibNodaveConnectionTypes.Netlink_lite:                      case LibNodaveConnectionTypes.Netlink_lite_PPI:                      case LibNodaveConnectionTypes.Netlink_Pro:                          _errorCodeConverter = libnodave.daveStrerror;                          socketTimer = new System.Timers.Timer(_configuration.TimeoutIPConnect.TotalMilliseconds);                          socketTimer.AutoReset = true;                          socketTimer.Elapsed += socketTimer_Elapsed;                          socketTimer.Start();                          socketThread = new Thread(this.socket_Thread);                          socketThread.Start();                          try                          {                              while (socketThread.ThreadState != ThreadState.AbortRequested &&                                     socketThread.ThreadState != ThreadState.Aborted &&                                     socketThread.ThreadState != ThreadState.Stopped)                              {                                  Thread.Sleep(50);                              }                          }                          catch (Exception ex)                          {                          }                          if (socketTimer != null)                              socketTimer.Stop();                          if (socketThread != null)                              socketThread.Abort();                          socketTimer = null;                          socketThread = null;                          break;                        case LibNodaveConnectionTypes.Fetch_Write_Active:                          _fetchWriteConnection = new FetchWriteConnection(this.Configuration);                          _fetchWriteConnection.Connect();                          Connected = true;                          return;                        //case 9050:                      //    _errorCodeConverter = Connection.daveStrerror;                      //    _dc = new S7onlineNETdave(_configuration);                      //    break;                      case LibNodaveConnectionTypes.ISO_over_TCP_Managed:                          _errorCodeConverter = Connection.daveStrerror;                          _dc = new TcpNETdave(_configuration);                          break;                  }
Missing Default,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PLCGetBlockInMC7,The following switch statement is missing a default case: switch (block)                      {                          case "FC":                              blk = DataTypes.PLCBlockType.FC;                              break;                          case "FB":                              blk = DataTypes.PLCBlockType.FB;                              break;                          case "DB":                              blk = DataTypes.PLCBlockType.DB;                              break;                          case "OB":                              blk = DataTypes.PLCBlockType.OB;                              break;                          case "SDB":                              blk = DataTypes.PLCBlockType.SDB;                              break;                      }
Missing Default,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PLCPutBlockFromMC7toPLC,The following switch statement is missing a default case: switch (block)                      {                          case "FC":                              blk = DataTypes.PLCBlockType.FC;                              break;                          case "FB":                              blk = DataTypes.PLCBlockType.FB;                              break;                          case "DB":                              blk = DataTypes.PLCBlockType.DB;                              break;                          case "OB":                              blk = DataTypes.PLCBlockType.OB;                              break;                          case "SDB":                              blk = DataTypes.PLCBlockType.SDB;                              break;                      }
Missing Default,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,PLCDeleteBlock,The following switch statement is missing a default case: switch (block)                      {                          case "FC":                              blk = DataTypes.PLCBlockType.FC;                              break;                          case "FB":                              blk = DataTypes.PLCBlockType.FB;                              break;                          case "DB":                              blk = DataTypes.PLCBlockType.DB;                              break;                          case "OB":                              blk = DataTypes.PLCBlockType.OB;                              break;                      }
Missing Default,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,ReadValuesWithVarTabFunctions,The following switch statement is missing a default case: switch (plcTag.TagDataSource)                      {                          case MemoryArea.Flags:                              dtaTyp = 0;                              break;                          case MemoryArea.Inputs:                              dtaTyp = 1;                              break;                          case MemoryArea.Outputs:                              dtaTyp = 2;                              break;                          case MemoryArea.Datablock:                              dtaTyp = 0x07;                              dbNo = plcTag.DataBlockNumber;                              break;                          case MemoryArea.Timer:                              dtaTyp = 5;                              break;                          case MemoryArea.Counter:                              dtaTyp = 6;                              break;                          case MemoryArea.LocalData:                              dtaTyp = 0x0c;                              break;                      }
Missing Default,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,WriteValuesWithVarTabFunctions,The following switch statement is missing a default case: switch (plcTag.TagDataSource)                      {                          case MemoryArea.Flags:                              dtaTyp = 0;                              break;                          case MemoryArea.Inputs:                              dtaTyp = 1;                              break;                          case MemoryArea.Outputs:                              dtaTyp = 2;                              break;                          case MemoryArea.Datablock:                              dtaTyp = 0x07;                              dbNo = plcTag.DataBlockNumber;                              break;                          case MemoryArea.Timer:                              dtaTyp = 5;                              break;                          case MemoryArea.Counter:                              dtaTyp = 6;                              break;                          case MemoryArea.LocalData:                              dtaTyp = 0x0c;                              break;                      }
Missing Default,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnection,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnection.cs,Dispose,The following switch statement is missing a default case: switch (_configuration.ConnectionType)                      {                          case LibNodaveConnectionTypes.MPI_über_Serial_Adapter:                          case LibNodaveConnectionTypes.MPI_über_Serial_Adapter_Andrews_Version_without_STX:                          case LibNodaveConnectionTypes.MPI_über_Serial_Adapter_Step_7_Version:                          case LibNodaveConnectionTypes.MPI_über_Serial_Adapter_Adrews_Version_with_STX:                          case LibNodaveConnectionTypes.PPI_über_Serial_Adapter:                          case LibNodaveConnectionTypes.AS_511:                              libnodave.closePort(_fds.rfd);                              break;                          case LibNodaveConnectionTypes.Use_Step7_DLL:                          case LibNodaveConnectionTypes.Use_Step7_DLL_Without_TCP:                              libnodave.closeS7online(_fds.rfd);                              break;                          case LibNodaveConnectionTypes.ISO_over_TCP:                          case LibNodaveConnectionTypes.ISO_over_TCP_CP_243:                          case LibNodaveConnectionTypes.Netlink_lite:                          case LibNodaveConnectionTypes.Netlink_lite_PPI:                          case LibNodaveConnectionTypes.Netlink_Pro:                              libnodave.closeSocket(_fds.rfd);                              _socketPtr = null;                              break;                      }
Missing Default,DotNetSiemensPLCToolBoxLibrary.Communication,PLCConnectionConfiguration,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCConnectionConfiguration.cs,ToString,The following switch statement is missing a default case: switch (ConnectionType)              {                    case LibNodaveConnectionTypes.MPI_über_Serial_Adapter:                      retVal = "MPI über seriell" + " (Port: " + ComPort + "' MPI: " + CpuMpi.ToString() + ")";                      break;                  case LibNodaveConnectionTypes.MPI_über_Serial_Adapter_Andrews_Version_without_STX:                      retVal = "MPI über seriell (Andrews Version)" + " (Port: " + ComPort + "' MPI: " + CpuMpi.ToString() + ")";                      break;                  case  LibNodaveConnectionTypes.MPI_über_Serial_Adapter_Step_7_Version:                      retVal = "MPI über seriell (Step7 Version)" + " (Port: " + ComPort + "' MPI: " + CpuMpi.ToString() + ")";                      break;                  case  LibNodaveConnectionTypes.MPI_über_Serial_Adapter_Adrews_Version_with_STX:                      retVal = "MPI über seriell" + " (Port: " + ComPort + "' MPI: " + CpuMpi.ToString() + ")";                      break;                  case  LibNodaveConnectionTypes.PPI_über_Serial_Adapter:                      retVal = "PPI über seriell";                      break;                  case  LibNodaveConnectionTypes.AS_511:                      retVal = "AS 511";                      break;                  case LibNodaveConnectionTypes.Use_Step7_DLL:                  case LibNodaveConnectionTypes.Use_Step7_DLL_Without_TCP:                      retVal = "Step7 DLL" + " (" + EntryPoint + ")";                      break;                  case  LibNodaveConnectionTypes.ISO_over_TCP:                      retVal = "ISO over TCP" + " (IP:" + CpuIP.ToString() + "'Rack:" + CpuRack.ToString() + "'Slot:" + CpuSlot.ToString() + ")";                      break;                  case  LibNodaveConnectionTypes.ISO_over_TCP_CP_243:                      retVal = "ISO over TCP (CP243)" + " (IP:" + CpuIP.ToString() + "'Rack:" + CpuRack.ToString() + "'Slot:" + CpuSlot.ToString() + ")";                      break;                  case LibNodaveConnectionTypes.Netlink_lite:                      retVal = "Netlink lite" + " (IP:" + CpuIP.ToString() + ")";                      break;                  case LibNodaveConnectionTypes.Netlink_lite_PPI:                      retVal = "Netlink lite PPI" + " (IP:" + CpuIP.ToString() + ")";                      break;                  case LibNodaveConnectionTypes.Netlink_Pro:                      retVal = "Netlink PRO" + " (IP:" + CpuIP.ToString() + ")";                      break;                  case LibNodaveConnectionTypes.Fetch_Write_Active:                      retVal = "Fetch/Write (Active)" + " (IP:" + CpuIP.ToString() + "' Port:" + Port + "' WritePort:" + WritePort + ")";                      break;                  case LibNodaveConnectionTypes.Fetch_Write_Passive:                      retVal = "Fetch/Write (Passive)" + " (IP:" + CpuIP.ToString() + "' Port:" + Port + "' WritePort:" + WritePort + ")";                      break;              }
Missing Default,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTag.cs,ParseControlValueFromString,The following switch statement is missing a default case: switch (this.TagDataType)              {                  case TagDataType.S5Time:                  case TagDataType.Time:                  case TagDataType.LTime:                      if (myValueStrip.Contains("t#") || myValueStrip.Contains("s5t#"))                      {                          Controlvalue = Helper.GetTimespanFromS5TimeorTime(myValue);                      }                      else                      {                          TimeSpan ret;                          TimeSpan.TryParse(myValue' out ret);                          Controlvalue = ret;                      }                      break;                  case TagDataType.BCDWord:                  case TagDataType.Int:                      if (myValueStrip.Contains("w#16#") || myValueStrip.Contains("dw#16#"))                      {                          Controlvalue = Convert.ToInt16(Helper.GetIntFromHexString(myValue));                      }                      else if (myValue.StartsWith("2#"))                      {                          Controlvalue = Convert.ToInt16(Helper.GetIntFromBinString(myValue));                      }                      else                      {                          Int16 ret;                          Int16.TryParse(myValue' out ret);                          Controlvalue = ret;                      }                      break;                  case TagDataType.BCDDWord:                  case TagDataType.Dint:                      if (myValueStrip.Contains("w#16#") || myValueStrip.Contains("dw#16#"))                          Controlvalue = Convert.ToInt32(Helper.GetIntFromHexString(myValue));                      else if (myValue.StartsWith("2#"))                          Controlvalue = Convert.ToInt32(Helper.GetIntFromBinString(myValue));                      else                          try                          {                              if (!string.IsNullOrEmpty(myValue))                                  Controlvalue = Int32.Parse(myValue);                          }                          catch (Exception) { }                      break;                  case TagDataType.BCDArray:                      if (myValueStrip.Contains("w#16#") || myValueStrip.Contains("dw#16#"))                          Controlvalue = Convert.ToUInt64(Helper.GetIntFromHexString(myValue));                      else if (myValue.StartsWith("2#"))                          Controlvalue = Convert.ToUInt64(Helper.GetIntFromBinString(myValue));                      else                          try                          {                              if (!string.IsNullOrEmpty(myValue))                                  Controlvalue = UInt64.Parse(myValue);                          }                          catch (Exception) { }                      break;                  case TagDataType.Byte:                      if (myValueStrip.Contains("w#16#") || myValueStrip.Contains("dw#16#"))                      {                          Controlvalue = Convert.ToByte(Helper.GetUIntFromHexString(myValue));                      }                      else if (myValue.StartsWith("2#"))                      {                          Controlvalue = Convert.ToByte(Helper.GetIntFromBinString(myValue));                      }                      else                      {                          Byte ret;                          Byte.TryParse(myValue' out ret);                          Controlvalue = ret;                      }                      break;                  case TagDataType.BCDByte:                  case TagDataType.SByte:                      if (myValueStrip.Contains("w#16#") || myValueStrip.Contains("dw#16#"))                      {                          Controlvalue = Convert.ToSByte(Helper.GetIntFromHexString(myValue));                      }                      else if (myValue.StartsWith("2#"))                      {                          Controlvalue = Convert.ToSByte(Helper.GetIntFromBinString(myValue));                      }                      else                      {                          SByte ret;                          SByte.TryParse(myValue' out ret);                          Controlvalue = ret;                      }                      break;                  case TagDataType.Word:                      if (myValueStrip.Contains("w#16#") || myValueStrip.Contains("dw#16#"))                      {                          Controlvalue = Convert.ToUInt16(Helper.GetUIntFromHexString(myValue));                      }                      else if (myValue.StartsWith("2#"))                      {                          Controlvalue = Convert.ToUInt16(Helper.GetIntFromBinString(myValue));                      }                      else                      {                          UInt16 ret;                          UInt16.TryParse(myValue' out ret);                          Controlvalue = ret;                      }                      break;                  case TagDataType.Dword:                      if (myValueStrip.Contains("w#16#") || myValueStrip.Contains("dw#16#"))                      {                          Controlvalue = Convert.ToUInt32(Helper.GetUIntFromHexString(myValue));                      }                      else if (myValue.StartsWith("2#"))                      {                          Controlvalue = Convert.ToUInt32(Helper.GetIntFromBinString(myValue));                      }                      else                      {                          UInt32 ret;                          UInt32.TryParse(myValue' out ret);                          Controlvalue = ret;                      }                      break;                  case TagDataType.LInt:                      {                          Int64 ret;                          Int64.TryParse(myValue' out ret);                          Controlvalue = ret;                      }                      break;                  case TagDataType.LWord:                      {                          UInt64 ret;                          UInt64.TryParse(myValue' out ret);                          Controlvalue = ret;                      }                      break;                  case TagDataType.LReal:                      {                          double ret;                          double.TryParse(myValue' out ret);                          Controlvalue = ret;                      }                      break;                  case TagDataType.Bool:                      if (myValue == "1")                          Controlvalue = true;                      else if (myValue == "0")                          Controlvalue = false;                      else                      {                          bool bvalue;                          bool.TryParse(myValue' out bvalue);                          Controlvalue = bvalue;                      }                      break;                  case TagDataType.String:                  case TagDataType.CharArray:                      Controlvalue = myValue;                      break;                  case TagDataType.DateTime:                  case TagDataType.Date:                  case TagDataType.TimeOfDay:                  case TagDataType.LTimeOfDay:                      if (myValueStrip.StartsWith("d#"))                          Controlvalue = Helper.GetDateTimeFromDateString(myValue);                      else if (myValueStrip.StartsWith("tod#"))                          Controlvalue = Helper.GetDateTimeFromTimeOfDayString(myValue);                      else if (myValueStrip.StartsWith("dt#"))                          Controlvalue = Helper.GetDateTimeFromDateAndTimeString(myValue);                      else if (!string.IsNullOrEmpty(myValue))                          try                          {                              if (!string.IsNullOrEmpty(myValue))                                  Controlvalue = DateTime.Parse(myValue);                          }                          catch (Exception) { }                      break;                  case TagDataType.ByteArray:                      {                          if (myValueStrip.Length > 2 && myValueStrip[0] == '{' && myValueStrip[myValueStrip.Length - 1] == '}')                              myValueStrip = myValueStrip.Substring(1' myValueStrip.Length - 2);                          string[] vals = myValueStrip.Split(''');                          byte[] wrt = new byte[vals.Length];                          int i = 0;                            foreach (string val in vals)                          {                              try                              {                                  wrt[i++] = Convert.ToByte(val);                              }                              catch (Exception)                              { }                          }                          Controlvalue = wrt;                      }                      break;                  case TagDataType.Float:                      {                          Single val;                          Controlvalue = Single.TryParse(myValue' out val);                          Controlvalue = val;                      }                      break;                      /*                        *  case TagDataType.TimeOfDay:                              case TagDataType.Float:                          */              }
Missing Default,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTag.cs,GetValueAsString,The following switch statement is missing a default case: switch (this.TagDataType)                  {                      case TagDataType.String:                      case TagDataType.CharArray:                      case TagDataType.BCDArray:                          return myValue.ToString();                      case TagDataType.ByteArray:                          {                              StringBuilder sb = new StringBuilder();                              sb.Append("{");                              foreach (Byte bt in ((System.Byte[])myValue))                              {                                  if (sb.Length > 1) sb.Append(";");                                  sb.Append(bt.ToString());                              }                              sb.Append("}");                              return sb.ToString();                          }                        case TagDataType.S5Time:                      case TagDataType.Time:                      case TagDataType.LTime:                      case TagDataType.Bool:                      case TagDataType.DateTime:                      case TagDataType.Date:                      case TagDataType.TimeOfDay:                      case TagDataType.LTimeOfDay:                      case TagDataType.Int:                      case TagDataType.Dint:                      case TagDataType.LInt:                      case TagDataType.LWord:                      case TagDataType.LReal:                      case TagDataType.Byte:                      case TagDataType.SByte:                      case TagDataType.Word:                      case TagDataType.Dword:                      case TagDataType.Float:                      case TagDataType.BCDByte:                      case TagDataType.BCDWord:                      case TagDataType.BCDDWord:                          if (!myValue.GetType().IsArray /*ArraySize < 2*/)                          {                              return this.GetValueAsStringInternal(myValue);                          }                          else                          {                              string ret = "";                              var ienumer = myValue as IEnumerable;                              if (ienumer != null)                              {                                  var enumer = ienumer.GetEnumerator();                                  for (int i = 0; i < ArraySize; i++)                                  {                                      if (enumer.MoveNext())                                      {                                          if (ret != "") ret += ";";                                          ret += this.GetValueAsStringInternal(enumer.Current);                                      }                                  }                                  return ret;                              }                          }                          break;                  }
Missing Default,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTag.cs,GetValueAsStringInternal,The following switch statement is missing a default case: switch (this.TagDataType)                  {                      case TagDataType.S5Time:                          {                              if (DataTypeStringFormat == TagDisplayDataType.S5Time)                              {                                  var bt = new byte[2];                                  libnodave.putS5Timeat(bt' 0' (TimeSpan)myValue);                                  return Helper.GetS5Time(bt[0]' bt[1]);                              }                              return ((TimeSpan)myValue).ToString();                          }                      case TagDataType.Time:                      case TagDataType.LTime:                          {                              var tm = (TimeSpan)myValue;                              var ret = new StringBuilder("T#");                              if (tm.TotalMilliseconds < 0) ret.Append("-");                              if (tm.Days != 0) ret.Append(tm.Days + "D");                              if (tm.Hours != 0) ret.Append(tm.Hours + "H");                              if (tm.Minutes != 0) ret.Append(tm.Minutes + "M");                              if (tm.Seconds != 0) ret.Append(tm.Seconds + "S");                              if (tm.Milliseconds != 0) ret.Append(tm.Milliseconds + "MS");                              return ret.ToString();                          }                      case TagDataType.Bool:                          if (DataTypeStringFormat == TagDisplayDataType.Binary)                          {                              if (((bool)myValue) == true)                                  return "1";                              return "0";                          }                          return myValue.ToString();                      case TagDataType.DateTime:                      case TagDataType.Date:                      case TagDataType.TimeOfDay:                      case TagDataType.LTimeOfDay:                          if (DataTypeStringFormat == TagDisplayDataType.S7DateTime)                          {                              DateTime ak = (DateTime)myValue;                              StringBuilder sb = new StringBuilder();                              sb.Append("DT#");                              sb.Append(ak.Year.ToString().Substring(2));                              sb.Append("-");                              sb.Append(ak.Month);                              sb.Append("-");                              sb.Append(ak.Day);                              sb.Append("-");                              sb.Append(ak.Hour);                              sb.Append(":");                              sb.Append(ak.Minute);                              sb.Append(":");                              sb.Append(ak.Second);                              sb.Append(".");                              sb.Append(ak.Millisecond.ToString().PadRight(3' '0'));                              return sb.ToString();                          }                          else if (DataTypeStringFormat == TagDisplayDataType.S7Date)                          {                              DateTime ak = (DateTime)myValue;                              StringBuilder sb = new StringBuilder();                              sb.Append("D#");                              sb.Append(ak.Year);                              sb.Append("-");                              sb.Append(ak.Month);                              sb.Append("-");                              sb.Append(ak.Day);                              return sb.ToString();                          }                          else if (DataTypeStringFormat == TagDisplayDataType.S7TimeOfDay)                          {                              DateTime ak = (DateTime)myValue;                              StringBuilder sb = new StringBuilder();                              sb.Append("TOD#");                              sb.Append(ak.Hour);                              sb.Append(":");                              sb.Append(ak.Minute);                              sb.Append(":");                              sb.Append(ak.Second);                              sb.Append(".");                              sb.Append(ak.Millisecond.ToString().PadRight(3' '0'));                              return sb.ToString();                          }                          return myValue.ToString();                        case TagDataType.Int:                      case TagDataType.Dint:                      case TagDataType.LWord:                      case TagDataType.LInt:                      case TagDataType.LReal:                      case TagDataType.Byte:                      case TagDataType.SByte:                      case TagDataType.Word:                      case TagDataType.Dword:                      case TagDataType.Float:                      case TagDataType.BCDByte:                      case TagDataType.BCDWord:                      case TagDataType.BCDDWord:                          IFormattable val = myValue as IFormattable ?? 0;                          switch (DataTypeStringFormat)                          {                              case TagDisplayDataType.String:                                  switch (this.TagDataType)                                  {                                      case TagDataType.Int:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((Int16)myValue));                                      case TagDataType.Dint:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((Int32)myValue));                                      case TagDataType.LInt:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((Int64)myValue));                                      case TagDataType.Byte:                                          return Encoding.ASCII.GetString(new[] { (Byte)myValue });                                      case TagDataType.SByte:                                          return Encoding.ASCII.GetString(new[] { BitConverter.GetBytes((SByte)myValue)[0] });                                      case TagDataType.Word:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((UInt16)myValue));                                      case TagDataType.Dword:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((UInt32)myValue));                                      case TagDataType.LWord:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((UInt64)myValue));                                      case TagDataType.Float:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((Single)myValue));                                      case TagDataType.LReal:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((Double)myValue));                                      case TagDataType.BCDByte:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((Byte)myValue));                                      case TagDataType.BCDWord:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((UInt16)myValue));                                      case TagDataType.BCDDWord:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((UInt32)myValue));                                  }                                  break;                              case TagDisplayDataType.Pointer:                                  return "P#" + (Convert.ToInt32(myValue) / 8).ToString() + "." + (Convert.ToInt32(myValue) % 8).ToString();                                  break;                              case TagDisplayDataType.Hexadecimal:                                  string ad = "";                                  switch (_internalGetSize())                                  {                                      case 1:                                          ad = "B#16#";                                          break;                                      case 2:                                          ad = "W#16#";                                          break;                                      case 4:                                          ad = "DW#16#";                                          break;                                      case 8:                                          ad = "L#16#";                                          break;                                  }                                  return ad + val.ToString("X"' NumberFormatInfo.CurrentInfo).PadLeft(_internalGetSize() * 2' '0');                              case TagDisplayDataType.Binary:                                  byte[] bt = new byte[] { };                                  switch (this.TagDataType)                                  {                                      case TagDataType.Int:                                          bt = BitConverter.GetBytes((Int16)myValue);                                          break;                                      case TagDataType.Dint:                                          bt = BitConverter.GetBytes((Int32)myValue);                                          break;                                      case TagDataType.LInt:                                          bt = BitConverter.GetBytes((Int64)myValue);                                          break;                                      case TagDataType.Byte:                                          bt = new byte[] { (byte)myValue };                                          break;                                      case TagDataType.SByte:                                          bt = new byte[] { (byte)myValue };                                          break;                                      case TagDataType.Word:                                          bt = BitConverter.GetBytes((UInt16)myValue);                                          break;                                      case TagDataType.Dword:                                          bt = BitConverter.GetBytes((UInt32)myValue);                                          break;                                      case TagDataType.LWord:                                          bt = BitConverter.GetBytes((UInt64)myValue);                                          break;                                      case TagDataType.Float:                                          bt = BitConverter.GetBytes((float)myValue);                                          break;                                      case TagDataType.LReal:                                          bt = BitConverter.GetBytes((double)myValue);                                          break;                                      case TagDataType.BCDByte:                                          bt = BitConverter.GetBytes((byte)myValue);                                          break;                                      case TagDataType.BCDWord:                                          bt = BitConverter.GetBytes((Int16)myValue);                                          break;                                      case TagDataType.BCDDWord:                                          bt = BitConverter.GetBytes((Int32)myValue);                                          break;                                  }                                  string ret = "";                                  foreach (byte b in bt)                                  {                                      if (ret != "") ret = "_" + ret;                                      ret = libnodave.dec2bin(b).Substring(0' 4) + "_" + libnodave.dec2bin(b).Substring(4' 4) + ret;                                    }                                  return "2#" + ret;                            }                          return val.ToString();                  }
Missing Default,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTag.cs,GetValueAsStringInternal,The following switch statement is missing a default case: switch (DataTypeStringFormat)                          {                              case TagDisplayDataType.String:                                  switch (this.TagDataType)                                  {                                      case TagDataType.Int:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((Int16)myValue));                                      case TagDataType.Dint:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((Int32)myValue));                                      case TagDataType.LInt:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((Int64)myValue));                                      case TagDataType.Byte:                                          return Encoding.ASCII.GetString(new[] { (Byte)myValue });                                      case TagDataType.SByte:                                          return Encoding.ASCII.GetString(new[] { BitConverter.GetBytes((SByte)myValue)[0] });                                      case TagDataType.Word:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((UInt16)myValue));                                      case TagDataType.Dword:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((UInt32)myValue));                                      case TagDataType.LWord:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((UInt64)myValue));                                      case TagDataType.Float:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((Single)myValue));                                      case TagDataType.LReal:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((Double)myValue));                                      case TagDataType.BCDByte:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((Byte)myValue));                                      case TagDataType.BCDWord:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((UInt16)myValue));                                      case TagDataType.BCDDWord:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((UInt32)myValue));                                  }                                  break;                              case TagDisplayDataType.Pointer:                                  return "P#" + (Convert.ToInt32(myValue) / 8).ToString() + "." + (Convert.ToInt32(myValue) % 8).ToString();                                  break;                              case TagDisplayDataType.Hexadecimal:                                  string ad = "";                                  switch (_internalGetSize())                                  {                                      case 1:                                          ad = "B#16#";                                          break;                                      case 2:                                          ad = "W#16#";                                          break;                                      case 4:                                          ad = "DW#16#";                                          break;                                      case 8:                                          ad = "L#16#";                                          break;                                  }                                  return ad + val.ToString("X"' NumberFormatInfo.CurrentInfo).PadLeft(_internalGetSize() * 2' '0');                              case TagDisplayDataType.Binary:                                  byte[] bt = new byte[] { };                                  switch (this.TagDataType)                                  {                                      case TagDataType.Int:                                          bt = BitConverter.GetBytes((Int16)myValue);                                          break;                                      case TagDataType.Dint:                                          bt = BitConverter.GetBytes((Int32)myValue);                                          break;                                      case TagDataType.LInt:                                          bt = BitConverter.GetBytes((Int64)myValue);                                          break;                                      case TagDataType.Byte:                                          bt = new byte[] { (byte)myValue };                                          break;                                      case TagDataType.SByte:                                          bt = new byte[] { (byte)myValue };                                          break;                                      case TagDataType.Word:                                          bt = BitConverter.GetBytes((UInt16)myValue);                                          break;                                      case TagDataType.Dword:                                          bt = BitConverter.GetBytes((UInt32)myValue);                                          break;                                      case TagDataType.LWord:                                          bt = BitConverter.GetBytes((UInt64)myValue);                                          break;                                      case TagDataType.Float:                                          bt = BitConverter.GetBytes((float)myValue);                                          break;                                      case TagDataType.LReal:                                          bt = BitConverter.GetBytes((double)myValue);                                          break;                                      case TagDataType.BCDByte:                                          bt = BitConverter.GetBytes((byte)myValue);                                          break;                                      case TagDataType.BCDWord:                                          bt = BitConverter.GetBytes((Int16)myValue);                                          break;                                      case TagDataType.BCDDWord:                                          bt = BitConverter.GetBytes((Int32)myValue);                                          break;                                  }                                  string ret = "";                                  foreach (byte b in bt)                                  {                                      if (ret != "") ret = "_" + ret;                                      ret = libnodave.dec2bin(b).Substring(0' 4) + "_" + libnodave.dec2bin(b).Substring(4' 4) + ret;                                    }                                  return "2#" + ret;                            }
Missing Default,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTag.cs,GetValueAsStringInternal,The following switch statement is missing a default case: switch (this.TagDataType)                                  {                                      case TagDataType.Int:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((Int16)myValue));                                      case TagDataType.Dint:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((Int32)myValue));                                      case TagDataType.LInt:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((Int64)myValue));                                      case TagDataType.Byte:                                          return Encoding.ASCII.GetString(new[] { (Byte)myValue });                                      case TagDataType.SByte:                                          return Encoding.ASCII.GetString(new[] { BitConverter.GetBytes((SByte)myValue)[0] });                                      case TagDataType.Word:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((UInt16)myValue));                                      case TagDataType.Dword:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((UInt32)myValue));                                      case TagDataType.LWord:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((UInt64)myValue));                                      case TagDataType.Float:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((Single)myValue));                                      case TagDataType.LReal:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((Double)myValue));                                      case TagDataType.BCDByte:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((Byte)myValue));                                      case TagDataType.BCDWord:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((UInt16)myValue));                                      case TagDataType.BCDDWord:                                          return Encoding.ASCII.GetString(BitConverter.GetBytes((UInt32)myValue));                                  }
Missing Default,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTag.cs,GetValueAsStringInternal,The following switch statement is missing a default case: switch (_internalGetSize())                                  {                                      case 1:                                          ad = "B#16#";                                          break;                                      case 2:                                          ad = "W#16#";                                          break;                                      case 4:                                          ad = "DW#16#";                                          break;                                      case 8:                                          ad = "L#16#";                                          break;                                  }
Missing Default,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTag.cs,GetValueAsStringInternal,The following switch statement is missing a default case: switch (this.TagDataType)                                  {                                      case TagDataType.Int:                                          bt = BitConverter.GetBytes((Int16)myValue);                                          break;                                      case TagDataType.Dint:                                          bt = BitConverter.GetBytes((Int32)myValue);                                          break;                                      case TagDataType.LInt:                                          bt = BitConverter.GetBytes((Int64)myValue);                                          break;                                      case TagDataType.Byte:                                          bt = new byte[] { (byte)myValue };                                          break;                                      case TagDataType.SByte:                                          bt = new byte[] { (byte)myValue };                                          break;                                      case TagDataType.Word:                                          bt = BitConverter.GetBytes((UInt16)myValue);                                          break;                                      case TagDataType.Dword:                                          bt = BitConverter.GetBytes((UInt32)myValue);                                          break;                                      case TagDataType.LWord:                                          bt = BitConverter.GetBytes((UInt64)myValue);                                          break;                                      case TagDataType.Float:                                          bt = BitConverter.GetBytes((float)myValue);                                          break;                                      case TagDataType.LReal:                                          bt = BitConverter.GetBytes((double)myValue);                                          break;                                      case TagDataType.BCDByte:                                          bt = BitConverter.GetBytes((byte)myValue);                                          break;                                      case TagDataType.BCDWord:                                          bt = BitConverter.GetBytes((Int16)myValue);                                          break;                                      case TagDataType.BCDDWord:                                          bt = BitConverter.GetBytes((Int32)myValue);                                          break;                                  }
Missing Default,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTag.cs,ChangeAddressFromString,The following switch statement is missing a default case: switch (myPlcAddress[1])                      {                          case "word":                          case "int":                          case "date":                          case "s5time":                              tsize = 2;                              break;                          case "real":                          case "dword":                          case "dint":                          case "time":                          case "time_of_day":                              tsize = 4;                              break;                          case "lreal":                          case "lword":                          case "lint":                          case "ltime":                          case "ltime_of_day":                              tsize = 8;                              break;                      }
Missing Default,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTag.cs,ChangeDataTypeFromString,The following switch statement is missing a default case: switch (datatype)                  {                      case "bool":                          tp = TagDataType.Bool;                          break;                      case "word":                          tp = TagDataType.Word;                          break;                      case "lword":                      case "word64":                          tp = TagDataType.LWord;                          break;                      case "lint":                      case "int64":                          tp = TagDataType.LInt;                          break;                      case "lreal":                      case "double":                          tp = TagDataType.LReal;                          break;                      case "int":                      case "integer":                          tp = TagDataType.Int;                          break;                      case "dword":                          tp = TagDataType.Dword;                          break;                      case "dint":                          tp = TagDataType.Dint;                          break;                      case "byte":                          tp = TagDataType.Byte;                          break;                      case "sbyte":                          tp = TagDataType.SByte;                          break;                      case "string":                          tp = TagDataType.String;                          break;                      case "time":                          tp = TagDataType.Time;                          break;                      case "ltime":                          tp = TagDataType.LTime;                          break;                      case "s5time":                          tp = TagDataType.S5Time;                          break;                      case "timeofday":                          tp = TagDataType.TimeOfDay;                          break;                      case "ltimeofday":                          tp = TagDataType.LTimeOfDay;                          break;                      case "date":                          tp = TagDataType.Date;                          break;                      case "bcdbyte":                      case "bcd":                          tp = TagDataType.BCDByte;                          break;                      case "bcdword":                          tp = TagDataType.BCDWord;                          break;                      case "bcddword":                          tp = TagDataType.BCDDWord;                          break;                      case "bcdarray":                          tp = TagDataType.BCDArray;                          break;                      case "datetime":                      case "dateandtime":                          tp = TagDataType.DateTime;                          break;                      case "char":                      case "chararray":                          tp = TagDataType.CharArray;                          break;                      case "bytearray":                          tp = TagDataType.ByteArray;                          break;                      case "float":                      case "real":                          tp = TagDataType.Float;                          break;                  }
Missing Default,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTag.cs,ChangeDataTypeStringFormatFromString,The following switch statement is missing a default case: switch (datatype.Replace(" "' "").Replace("_"' "").Trim())                  {                      case "decimal":                      case "dec":                          tp = TagDisplayDataType.Decimal;                          break;                      case "hexadecimal":                      case "hex":                          tp = TagDisplayDataType.Hexadecimal;                          break;                      case "binary":                      case "bin":                          tp = TagDisplayDataType.Binary;                          break;                      case "pointer":                          tp = TagDisplayDataType.Pointer;                          break;                      case "bool":                          tp = TagDisplayDataType.Bool;                          break;                      case "byte":                      case "bytearray":                          tp = TagDisplayDataType.ByteArray;                          break;                      case "datetime":                          tp = TagDisplayDataType.DateTime;                          break;                      case "date":                      case "s7date":                          tp = TagDisplayDataType.S7Date;                          break;                      case "s7timeofday":                      case "timeofday":                          tp = TagDisplayDataType.S7TimeOfDay;                          break;                      case "float":                      case "real":                          tp = TagDisplayDataType.Float;                          break;                      case "s5time":                          tp = TagDisplayDataType.S5Time;                          break;                      case "s7datetime":                      case "dateandtime":                          tp = TagDisplayDataType.S7DateTime;                          break;                      case "string":                      case "strg":                          tp = TagDisplayDataType.String;                          break;                      case "time":                      case "s7time":                          tp = TagDisplayDataType.Time;                          break;                      case "timespan":                          tp = TagDisplayDataType.TimeSpan;                          break;                  }
Missing Default,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTag.cs,_putControlValueIntoBuffer,The following switch statement is missing a default case: switch (this.TagDataType)                  {                      case TagDataType.Word:                          libnodave.putU16at(buff' startpos' Convert.ToUInt16(ctlValue));                          break;                      case TagDataType.String:                          libnodave.putS7Stringat(buff' startpos' ctlValue.ToString()' ArraySize);                          break;                      case TagDataType.CharArray:                          libnodave.putStringat(buff' startpos' ctlValue.ToString()' ArraySize);                          break;                      case TagDataType.ByteArray:                          {                              byte[] tmp = (byte[])ctlValue;                              for (int n = 0; n < ArraySize; n++)                              {                                  if (n > tmp.Length)                                      buff[startpos + n] = 0x00;                                  else                                      buff[startpos + n] = tmp[n];                              }                          }                          break;                      case TagDataType.BCDArray:                          {                              var tmp = (ulong)ctlValue;                                ulong faktor = 1;                              for (int n = 0; n < ArraySize - 1; n++)                              {                                  faktor *= 10;                              }                                for (int n = 0; n < ArraySize; n++)                              {                                  buff[startpos + n] = (byte)(tmp / faktor);                                  tmp -= buff[startpos + n] * faktor;                                  faktor /= 10;                              }                          }                          break;                      case TagDataType.Bool:                          bool tmp1 = false;                          try                          {                              tmp1 = Convert.ToBoolean(ctlValue);                          }                          catch (Exception)                          {                              tmp1 = Convert.ToBoolean(Convert.ToInt32(ctlValue));                          }                          buff[startpos] = Convert.ToByte(tmp1);                          break;                      case TagDataType.Byte:                          buff[startpos] = Convert.ToByte(ctlValue);                          break;                      case TagDataType.SByte:                          buff[startpos] = (Byte)Convert.ToSByte(ctlValue);                          break;                      case TagDataType.Time:                          libnodave.putTimeat(buff' startpos' (TimeSpan)ctlValue);                          break;                      case TagDataType.LTime:                          libnodave.putLTimeat(buff' startpos' (TimeSpan)ctlValue);                          break;                      case TagDataType.TimeOfDay:                          libnodave.putTimeOfDayat(buff' startpos' (DateTime)ctlValue);                          break;                      case TagDataType.LTimeOfDay:                          libnodave.putLTimeOfDayat(buff' startpos' (DateTime)ctlValue);                          break;                      case TagDataType.BCDByte:                          libnodave.putBCD8at(buff' startpos' Convert.ToInt32(ctlValue));                          break;                      case TagDataType.Int:                          libnodave.putS16at(buff' startpos' Convert.ToInt16(ctlValue));                          break;                      case TagDataType.S5Time:                          //if (Controlvalue.GetType() == typeof(TimeSpan))                          libnodave.putS5Timeat(buff' startpos' (TimeSpan)ctlValue);                          //else                          //    libnodave.putS5Timeat(buff' startpos' TimeSpan.Parse(Controlvalue.ToString()));                          break;                      case TagDataType.BCDWord:                          libnodave.putBCD16at(buff' startpos' Convert.ToInt32(ctlValue));                          break;                      case TagDataType.BCDDWord:                          libnodave.putBCD32at(buff' startpos' Convert.ToInt32(ctlValue));                          break;                      case TagDataType.Dint:                          libnodave.putS32at(buff' startpos' Convert.ToInt32(ctlValue));                          break;                      case TagDataType.Dword:                          libnodave.putU32at(buff' startpos' Convert.ToUInt32(ctlValue));                          break;                      case TagDataType.LInt:                          libnodave.putS64at(buff' startpos' Convert.ToInt64(ctlValue));                          break;                      case TagDataType.LWord:                          libnodave.putU64at(buff' startpos' Convert.ToUInt64(ctlValue));                          break;                      case TagDataType.Float:                          libnodave.putFloatat(buff' startpos' Convert.ToSingle(ctlValue));                          break;                      case TagDataType.LReal:                          libnodave.putDoubleat(buff' startpos' Convert.ToDouble(ctlValue));                          break;                      case TagDataType.DateTime:                          //if (Controlvalue.GetType() == typeof(DateTime))                          libnodave.putDateTimeat(buff' startpos' (DateTime)ctlValue);                          //else                          //    libnodave.putDateTimeat(buff' startpos' Convert.ToDateTime(Controlvalue));                          break;                      case TagDataType.Date:                          //if (Controlvalue.GetType() == typeof(DateTime))                          libnodave.putDateat(buff' startpos' (DateTime)ctlValue);                          //else                          //    libnodave.putDateTimeat(buff' startpos' Convert.ToDateTime(Controlvalue));                          break;                  }
Missing Default,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTag.cs,_readValueFromBuffer,The following switch statement is missing a default case: switch (this.TagDataType)                  {                      case TagDataType.String:                          {                              if (!(this is PLCNckTag))                              {                                  int maxsize = (int)buff[startpos];                                  int size = (int)buff[startpos + 1];                                    if (size > maxsize)                                      size = maxsize;                                  if (size > ArraySize)                                      size = ArraySize;                                    _setValueProp = Encoding.Default.GetString(buff' startpos + 2' size);                              }                              else                                  _setValueProp = Encoding.Default.GetString(buff' startpos' Math.Min(buff.Length - startpos' ArraySize)).Split('\0')[0];                          }                          break;                      case TagDataType.CharArray:                          {                              //var sb = new StringBuilder();                              //for (var n = 0; n < ((buff.Length - startpos) < ArraySize ? buff.Length - startpos : ArraySize); n++)                              //    sb.Append((char)buff[n + startpos]);                              //_setValueProp = sb.ToString();                                if (this is PLCNckTag) //BugFix für NCK v2.6                                  _setValueProp = Encoding.Default.GetString(buff' startpos' Math.Min(buff.Length - startpos' ArraySize)).Split('\0')[0];                              else                                  _setValueProp = Encoding.Default.GetString(buff' startpos' Math.Min(buff.Length - startpos' ArraySize)).Trim('\0');                          }                          break;                      case TagDataType.ByteArray:                          {                              var val = new Byte[ArraySize];                              Array.Copy(buff' startpos' val' 0' ArraySize);                                /*                              for (var n = 0; n < ArraySize; n++)                                  val[n] = buff[n + startpos];                              */                              _setValueProp = val;                          }                          break;                      case TagDataType.BCDArray:                          {                              ulong wrt = 0;                                for (int i = 0; i < ArraySize; i++)                              {                                  wrt *= 10;                                  wrt += (ulong)libnodave.getBCD8from(buff' startpos + i);                              }                                _setValueProp = wrt;                          }                          break;                        case TagDataType.Bool:                      case TagDataType.Byte:                      case TagDataType.SByte:                      case TagDataType.Time:                      case TagDataType.LTime:                      case TagDataType.Date:                      case TagDataType.TimeOfDay:                      case TagDataType.LTimeOfDay:                      case TagDataType.Word:                      case TagDataType.BCDByte:                      case TagDataType.Int:                      case TagDataType.S5Time:                      case TagDataType.BCDWord:                      case TagDataType.BCDDWord:                      case TagDataType.Dint:                      case TagDataType.Dword:                      case TagDataType.Float:                      case TagDataType.LInt:                      case TagDataType.LWord:                      case TagDataType.LReal:                      case TagDataType.DateTime:                          {                              if (ArraySize < 2)                              {                                  switch (this.TagDataType)                                  {                                      case TagDataType.Bool:                                          _setValueProp = libnodave.getBit(buff[startpos]' BitAddress);                                          break;                                      case TagDataType.Byte:                                          _setValueProp = buff[startpos];                                          break;                                      case TagDataType.SByte:                                          _setValueProp = libnodave.getS8from(buff' startpos);                                          break;                                      case TagDataType.Time:                                          _setValueProp = libnodave.getTimefrom(buff' startpos);                                          break;                                      case TagDataType.LTime:                                          _setValueProp = libnodave.getLTimefrom(buff' startpos);                                          break;                                      case TagDataType.Date:                                          _setValueProp = libnodave.getDatefrom(buff' startpos);                                          break;                                      case TagDataType.TimeOfDay:                                          _setValueProp = libnodave.getTimeOfDayfrom(buff' startpos);                                          break;                                      case TagDataType.LTimeOfDay:                                          _setValueProp = libnodave.getLTimeOfDayfrom(buff' startpos);                                          break;                                      case TagDataType.Word:                                          _setValueProp = libnodave.getU16from(buff' startpos);                                          break;                                      case TagDataType.BCDByte:                                          _setValueProp = libnodave.getBCD8from(buff' startpos);                                          break;                                      case TagDataType.Int:                                          _setValueProp = libnodave.getS16from(buff' startpos);                                          break;                                      case TagDataType.S5Time:                                          _setValueProp = libnodave.getS5Timefrom(buff' startpos);                                          break;                                      case TagDataType.BCDWord:                                          _setValueProp = libnodave.getBCD16from(buff' startpos);                                          break;                                      case TagDataType.BCDDWord:                                          _setValueProp = libnodave.getBCD32from(buff' startpos);                                          break;                                      case TagDataType.Dint:                                          _setValueProp = libnodave.getS32from(buff' startpos);                                          break;                                      case TagDataType.Dword:                                          _setValueProp = libnodave.getU32from(buff' startpos);                                          break;                                      case TagDataType.LWord:                                          _setValueProp = libnodave.getU64from(buff' startpos);                                          break;                                      case TagDataType.LInt:                                          _setValueProp = libnodave.getS64from(buff' startpos);                                          break;                                      case TagDataType.Float:                                          _setValueProp = libnodave.getFloatfrom(buff' startpos);                                          break;                                      case TagDataType.LReal:                                          _setValueProp = libnodave.getDoublefrom(buff' startpos);                                          break;                                      case TagDataType.DateTime:                                          _setValueProp = libnodave.getDateTimefrom(buff' startpos);                                          break;                                  }                              }                              else                              {                                  switch (this.TagDataType)                                  {                                      case TagDataType.Bool:                                          {                                              var values = new List<bool>();                                              var akBit = BitAddress;                                              var akbyte = startpos;                                              for (int n = 0; n < ArraySize; n++)                                              {                                                  values.Add(libnodave.getBit(buff[akbyte]' akBit));                                                  akBit++;                                                  if (akBit > 7)                                                  {                                                      akBit = 0;                                                      akbyte++;                                                  }                                              }                                                _setValueProp = values.ToArray();                                              break;                                          }                                      case TagDataType.Byte:                                          {                                              var values = new List<Byte>();                                              var mSize = _internalGetBaseTypeSize();                                              for (int n = 0; n < ArraySize; n++)                                                  values.Add(buff[startpos + n * mSize]);                                              _setValueProp = values.ToArray();                                              break;                                          }                                      case TagDataType.SByte:                                          {                                              var values = new List<SByte>();                                              var mSize = _internalGetBaseTypeSize();                                              for (int n = 0; n < ArraySize; n++)                                                  values.Add(libnodave.getS8from(buff' startpos + n * mSize));                                              _setValueProp = values.ToArray();                                              break;                                          }                                      case TagDataType.Time:                                          {                                              var values = new List<TimeSpan>();                                              var mSize = _internalGetBaseTypeSize();                                              for (int n = 0; n < ArraySize; n++)                                                  values.Add(libnodave.getTimefrom(buff' startpos + n * mSize));                                              _setValueProp = values.ToArray();                                              break;                                          }                                      case TagDataType.LTime:                                          {                                              var values = new List<TimeSpan>();                                              var mSize = _internalGetBaseTypeSize();                                              for (int n = 0; n < ArraySize; n++)                                                  values.Add(libnodave.getLTimefrom(buff' startpos + n * mSize));                                              _setValueProp = values.ToArray();                                              break;                                          }                                      case TagDataType.Date:                                          {                                              var values = new List<DateTime>();                                              var mSize = _internalGetBaseTypeSize();                                              for (int n = 0; n < ArraySize; n++)                                                  values.Add(libnodave.getDatefrom(buff' startpos + n * mSize));                                              _setValueProp = values.ToArray();                                              break;                                          }                                      case TagDataType.TimeOfDay:                                          {                                              var values = new List<DateTime>();                                              var mSize = _internalGetBaseTypeSize();                                              for (int n = 0; n < ArraySize; n++)                                                  values.Add(libnodave.getTimeOfDayfrom(buff' startpos + n * mSize));                                              _setValueProp = values.ToArray();                                              break;                                          }                                      case TagDataType.LTimeOfDay:                                          {                                              var values = new List<DateTime>();                                              var mSize = _internalGetBaseTypeSize();                                              for (int n = 0; n < ArraySize; n++)                                                  values.Add(libnodave.getLTimeOfDayfrom(buff' startpos + n * mSize));                                              _setValueProp = values.ToArray();                                              break;                                          }                                      case TagDataType.Word:                                          {                                              var values = new List<UInt16>();                                              var mSize = _internalGetBaseTypeSize();                                              for (int n = 0; n < ArraySize; n++)                                                  values.Add(libnodave.getU16from(buff' startpos + n * mSize));                                              _setValueProp = values.ToArray();                                              break;                                          }                                      case TagDataType.BCDByte:                                          {                                              var values = new List<int>();                                              var mSize = _internalGetBaseTypeSize();                                              for (int n = 0; n < ArraySize; n++)                                                  values.Add(libnodave.getBCD8from(buff' startpos + n * mSize));                                              _setValueProp = values.ToArray();                                              break;                                          }                                      case TagDataType.Int:                                          {                                              var values = new List<Int16>();                                              var mSize = _internalGetBaseTypeSize();                                              for (int n = 0; n < ArraySize; n++)                                                  values.Add(libnodave.getS16from(buff' startpos + n * mSize));                                              _setValueProp = values.ToArray();                                              break;                                          }                                      case TagDataType.S5Time:                                          {                                              var values = new List<TimeSpan>();                                              var mSize = _internalGetBaseTypeSize();                                              for (int n = 0; n < ArraySize; n++)                                                  values.Add(libnodave.getS5Timefrom(buff' startpos + n * mSize));                                              _setValueProp = values.ToArray();                                              break;                                          }                                      case TagDataType.BCDWord:                                          {                                              var values = new List<Int32>();                                              var mSize = _internalGetBaseTypeSize();                                              for (int n = 0; n < ArraySize; n++)                                                  values.Add(libnodave.getBCD16from(buff' startpos + n * mSize));                                              _setValueProp = values.ToArray();                                              break;                                          }                                      case TagDataType.BCDDWord:                                          {                                              var values = new List<Int32>();                                              var mSize = _internalGetBaseTypeSize();                                              for (int n = 0; n < ArraySize; n++)                                                  values.Add(libnodave.getBCD32from(buff' startpos + n * mSize));                                              _setValueProp = values.ToArray();                                              break;                                          }                                      case TagDataType.Dint:                                          {                                              var values = new List<Int32>();                                              var mSize = _internalGetBaseTypeSize();                                              for (int n = 0; n < ArraySize; n++)                                                  values.Add(libnodave.getS32from(buff' startpos + n * mSize));                                              _setValueProp = values.ToArray();                                              break;                                          }                                      case TagDataType.Dword:                                          {                                              var values = new List<UInt32>();                                              var mSize = _internalGetBaseTypeSize();                                              for (int n = 0; n < ArraySize; n++)                                                  values.Add(libnodave.getU32from(buff' startpos + n * mSize));                                              _setValueProp = values.ToArray();                                              break;                                          }                                      case TagDataType.Float:                                          {                                              var values = new List<float>();                                              var mSize = _internalGetBaseTypeSize();                                              for (int n = 0; n < ArraySize; n++)                                                  values.Add(libnodave.getFloatfrom(buff' startpos + n * mSize));                                              _setValueProp = values.ToArray();                                              break;                                          }                                      case TagDataType.LInt:                                          {                                              var values = new List<Int64>();                                              var mSize = _internalGetBaseTypeSize();                                              for (int n = 0; n < ArraySize; n++)                                                  values.Add(libnodave.getS64from(buff' startpos + n * mSize));                                              _setValueProp = values.ToArray();                                              break;                                          }                                      case TagDataType.LWord:                                          {                                              var values = new List<UInt64>();                                              var mSize = _internalGetBaseTypeSize();                                              for (int n = 0; n < ArraySize; n++)                                                  values.Add(libnodave.getU64from(buff' startpos + n * mSize));                                              _setValueProp = values.ToArray();                                              break;                                          }                                      case TagDataType.LReal:                                          {                                              var values = new List<double>();                                              var mSize = _internalGetBaseTypeSize();                                              for (int n = 0; n < ArraySize; n++)                                                  values.Add(libnodave.getDoublefrom(buff' startpos + n * mSize));                                              _setValueProp = values.ToArray();                                              break;                                          }                                      case TagDataType.DateTime:                                          {                                              var values = new List<DateTime>();                                              var mSize = _internalGetBaseTypeSize();                                              for (int n = 0; n < ArraySize; n++)                                                  values.Add(libnodave.getDateTimefrom(buff' startpos + n * mSize));                                              _setValueProp = values.ToArray();                                              break;                                          }                                  }                              }                          }                          break;                  }
Missing Default,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTag.cs,_readValueFromBuffer,The following switch statement is missing a default case: switch (this.TagDataType)                                  {                                      case TagDataType.Bool:                                          _setValueProp = libnodave.getBit(buff[startpos]' BitAddress);                                          break;                                      case TagDataType.Byte:                                          _setValueProp = buff[startpos];                                          break;                                      case TagDataType.SByte:                                          _setValueProp = libnodave.getS8from(buff' startpos);                                          break;                                      case TagDataType.Time:                                          _setValueProp = libnodave.getTimefrom(buff' startpos);                                          break;                                      case TagDataType.LTime:                                          _setValueProp = libnodave.getLTimefrom(buff' startpos);                                          break;                                      case TagDataType.Date:                                          _setValueProp = libnodave.getDatefrom(buff' startpos);                                          break;                                      case TagDataType.TimeOfDay:                                          _setValueProp = libnodave.getTimeOfDayfrom(buff' startpos);                                          break;                                      case TagDataType.LTimeOfDay:                                          _setValueProp = libnodave.getLTimeOfDayfrom(buff' startpos);                                          break;                                      case TagDataType.Word:                                          _setValueProp = libnodave.getU16from(buff' startpos);                                          break;                                      case TagDataType.BCDByte:                                          _setValueProp = libnodave.getBCD8from(buff' startpos);                                          break;                                      case TagDataType.Int:                                          _setValueProp = libnodave.getS16from(buff' startpos);                                          break;                                      case TagDataType.S5Time:                                          _setValueProp = libnodave.getS5Timefrom(buff' startpos);                                          break;                                      case TagDataType.BCDWord:                                          _setValueProp = libnodave.getBCD16from(buff' startpos);                                          break;                                      case TagDataType.BCDDWord:                                          _setValueProp = libnodave.getBCD32from(buff' startpos);                                          break;                                      case TagDataType.Dint:                                          _setValueProp = libnodave.getS32from(buff' startpos);                                          break;                                      case TagDataType.Dword:                                          _setValueProp = libnodave.getU32from(buff' startpos);                                          break;                                      case TagDataType.LWord:                                          _setValueProp = libnodave.getU64from(buff' startpos);                                          break;                                      case TagDataType.LInt:                                          _setValueProp = libnodave.getS64from(buff' startpos);                                          break;                                      case TagDataType.Float:                                          _setValueProp = libnodave.getFloatfrom(buff' startpos);                                          break;                                      case TagDataType.LReal:                                          _setValueProp = libnodave.getDoublefrom(buff' startpos);                                          break;                                      case TagDataType.DateTime:                                          _setValueProp = libnodave.getDateTimefrom(buff' startpos);                                          break;                                  }
Missing Default,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTag.cs,_readValueFromBuffer,The following switch statement is missing a default case: switch (this.TagDataType)                                  {                                      case TagDataType.Bool:                                          {                                              var values = new List<bool>();                                              var akBit = BitAddress;                                              var akbyte = startpos;                                              for (int n = 0; n < ArraySize; n++)                                              {                                                  values.Add(libnodave.getBit(buff[akbyte]' akBit));                                                  akBit++;                                                  if (akBit > 7)                                                  {                                                      akBit = 0;                                                      akbyte++;                                                  }                                              }                                                _setValueProp = values.ToArray();                                              break;                                          }                                      case TagDataType.Byte:                                          {                                              var values = new List<Byte>();                                              var mSize = _internalGetBaseTypeSize();                                              for (int n = 0; n < ArraySize; n++)                                                  values.Add(buff[startpos + n * mSize]);                                              _setValueProp = values.ToArray();                                              break;                                          }                                      case TagDataType.SByte:                                          {                                              var values = new List<SByte>();                                              var mSize = _internalGetBaseTypeSize();                                              for (int n = 0; n < ArraySize; n++)                                                  values.Add(libnodave.getS8from(buff' startpos + n * mSize));                                              _setValueProp = values.ToArray();                                              break;                                          }                                      case TagDataType.Time:                                          {                                              var values = new List<TimeSpan>();                                              var mSize = _internalGetBaseTypeSize();                                              for (int n = 0; n < ArraySize; n++)                                                  values.Add(libnodave.getTimefrom(buff' startpos + n * mSize));                                              _setValueProp = values.ToArray();                                              break;                                          }                                      case TagDataType.LTime:                                          {                                              var values = new List<TimeSpan>();                                              var mSize = _internalGetBaseTypeSize();                                              for (int n = 0; n < ArraySize; n++)                                                  values.Add(libnodave.getLTimefrom(buff' startpos + n * mSize));                                              _setValueProp = values.ToArray();                                              break;                                          }                                      case TagDataType.Date:                                          {                                              var values = new List<DateTime>();                                              var mSize = _internalGetBaseTypeSize();                                              for (int n = 0; n < ArraySize; n++)                                                  values.Add(libnodave.getDatefrom(buff' startpos + n * mSize));                                              _setValueProp = values.ToArray();                                              break;                                          }                                      case TagDataType.TimeOfDay:                                          {                                              var values = new List<DateTime>();                                              var mSize = _internalGetBaseTypeSize();                                              for (int n = 0; n < ArraySize; n++)                                                  values.Add(libnodave.getTimeOfDayfrom(buff' startpos + n * mSize));                                              _setValueProp = values.ToArray();                                              break;                                          }                                      case TagDataType.LTimeOfDay:                                          {                                              var values = new List<DateTime>();                                              var mSize = _internalGetBaseTypeSize();                                              for (int n = 0; n < ArraySize; n++)                                                  values.Add(libnodave.getLTimeOfDayfrom(buff' startpos + n * mSize));                                              _setValueProp = values.ToArray();                                              break;                                          }                                      case TagDataType.Word:                                          {                                              var values = new List<UInt16>();                                              var mSize = _internalGetBaseTypeSize();                                              for (int n = 0; n < ArraySize; n++)                                                  values.Add(libnodave.getU16from(buff' startpos + n * mSize));                                              _setValueProp = values.ToArray();                                              break;                                          }                                      case TagDataType.BCDByte:                                          {                                              var values = new List<int>();                                              var mSize = _internalGetBaseTypeSize();                                              for (int n = 0; n < ArraySize; n++)                                                  values.Add(libnodave.getBCD8from(buff' startpos + n * mSize));                                              _setValueProp = values.ToArray();                                              break;                                          }                                      case TagDataType.Int:                                          {                                              var values = new List<Int16>();                                              var mSize = _internalGetBaseTypeSize();                                              for (int n = 0; n < ArraySize; n++)                                                  values.Add(libnodave.getS16from(buff' startpos + n * mSize));                                              _setValueProp = values.ToArray();                                              break;                                          }                                      case TagDataType.S5Time:                                          {                                              var values = new List<TimeSpan>();                                              var mSize = _internalGetBaseTypeSize();                                              for (int n = 0; n < ArraySize; n++)                                                  values.Add(libnodave.getS5Timefrom(buff' startpos + n * mSize));                                              _setValueProp = values.ToArray();                                              break;                                          }                                      case TagDataType.BCDWord:                                          {                                              var values = new List<Int32>();                                              var mSize = _internalGetBaseTypeSize();                                              for (int n = 0; n < ArraySize; n++)                                                  values.Add(libnodave.getBCD16from(buff' startpos + n * mSize));                                              _setValueProp = values.ToArray();                                              break;                                          }                                      case TagDataType.BCDDWord:                                          {                                              var values = new List<Int32>();                                              var mSize = _internalGetBaseTypeSize();                                              for (int n = 0; n < ArraySize; n++)                                                  values.Add(libnodave.getBCD32from(buff' startpos + n * mSize));                                              _setValueProp = values.ToArray();                                              break;                                          }                                      case TagDataType.Dint:                                          {                                              var values = new List<Int32>();                                              var mSize = _internalGetBaseTypeSize();                                              for (int n = 0; n < ArraySize; n++)                                                  values.Add(libnodave.getS32from(buff' startpos + n * mSize));                                              _setValueProp = values.ToArray();                                              break;                                          }                                      case TagDataType.Dword:                                          {                                              var values = new List<UInt32>();                                              var mSize = _internalGetBaseTypeSize();                                              for (int n = 0; n < ArraySize; n++)                                                  values.Add(libnodave.getU32from(buff' startpos + n * mSize));                                              _setValueProp = values.ToArray();                                              break;                                          }                                      case TagDataType.Float:                                          {                                              var values = new List<float>();                                              var mSize = _internalGetBaseTypeSize();                                              for (int n = 0; n < ArraySize; n++)                                                  values.Add(libnodave.getFloatfrom(buff' startpos + n * mSize));                                              _setValueProp = values.ToArray();                                              break;                                          }                                      case TagDataType.LInt:                                          {                                              var values = new List<Int64>();                                              var mSize = _internalGetBaseTypeSize();                                              for (int n = 0; n < ArraySize; n++)                                                  values.Add(libnodave.getS64from(buff' startpos + n * mSize));                                              _setValueProp = values.ToArray();                                              break;                                          }                                      case TagDataType.LWord:                                          {                                              var values = new List<UInt64>();                                              var mSize = _internalGetBaseTypeSize();                                              for (int n = 0; n < ArraySize; n++)                                                  values.Add(libnodave.getU64from(buff' startpos + n * mSize));                                              _setValueProp = values.ToArray();                                              break;                                          }                                      case TagDataType.LReal:                                          {                                              var values = new List<double>();                                              var mSize = _internalGetBaseTypeSize();                                              for (int n = 0; n < ArraySize; n++)                                                  values.Add(libnodave.getDoublefrom(buff' startpos + n * mSize));                                              _setValueProp = values.ToArray();                                              break;                                          }                                      case TagDataType.DateTime:                                          {                                              var values = new List<DateTime>();                                              var mSize = _internalGetBaseTypeSize();                                              for (int n = 0; n < ArraySize; n++)                                                  values.Add(libnodave.getDateTimefrom(buff' startpos + n * mSize));                                              _setValueProp = values.ToArray();                                              break;                                          }                                  }
Missing Default,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTag.cs,_internalGetSize,The following switch statement is missing a default case: switch (this.TagDataType)              {                  case TagDataType.String:                      return ArraySize + 2;                  case TagDataType.CharArray:                  case TagDataType.ByteArray:                  case TagDataType.BCDArray:                      return ArraySize;                  case TagDataType.Byte:                  case TagDataType.SByte:                  case TagDataType.BCDByte:                  case TagDataType.Word:                  case TagDataType.BCDWord:                  case TagDataType.Int:                  case TagDataType.S5Time:                  case TagDataType.Date:                  case TagDataType.Dint:                  case TagDataType.LInt:                  case TagDataType.LReal:                  case TagDataType.LWord:                  case TagDataType.LTime:                  case TagDataType.LTimeOfDay:                  case TagDataType.Dword:                  case TagDataType.Time:                  case TagDataType.TimeOfDay:                  case TagDataType.Float:                  case TagDataType.BCDDWord:                  case TagDataType.DateTime:                      return _internalGetBaseTypeSize() * ArraySize;                  case TagDataType.Bool:                      {                          var akbyte = 1;                          var akBit = BitAddress;                          for (int i = 0; i < ArraySize; i++)                          {                              if (akBit > 7)                              {                                  akbyte++;                                  akBit = 0;                              }                              akBit++;                          }                          return akbyte;                      }              }
Missing Default,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTag.cs,_internalGetBaseTypeSize,The following switch statement is missing a default case: switch (this.TagDataType)              {                  case TagDataType.Bool:                  case TagDataType.Byte:                  case TagDataType.SByte:                  case TagDataType.BCDByte:                  case TagDataType.BCDArray:                  case TagDataType.CharArray:                  case TagDataType.ByteArray:                      return 1;                  case TagDataType.Word:                  case TagDataType.BCDWord:                  case TagDataType.Int:                  case TagDataType.S5Time:                  case TagDataType.Date:                      return 2;                  case TagDataType.Dint:                  case TagDataType.Dword:                  case TagDataType.Time:                  case TagDataType.TimeOfDay:                  case TagDataType.Float:                  case TagDataType.BCDDWord:                      return 4;                  case TagDataType.LInt:                  case TagDataType.LWord:                  case TagDataType.LReal:                  case TagDataType.LTime:                  case TagDataType.LTimeOfDay:                  case TagDataType.DateTime:                      return 8;              }
Missing Default,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag<T>,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTagGeneric.cs,FromBytes,The following switch statement is missing a default case: switch (info.FieldType.Name)                  {                      case "Boolean":                          // get the value                          bytePos = (int)Math.Floor(numBytes);                          bitPos = (int)((numBytes - (double)bytePos) / 0.125);                          if ((bytes[bytePos] & (int)Math.Pow(2' bitPos)) != 0)                              info.SetValue(structValue' true);                          else                              info.SetValue(structValue' false);                          numBytes += 0.125;                          break;                      case "Byte":                          numBytes = Math.Ceiling(numBytes);                          info.SetValue(structValue' (byte)(bytes[(int)numBytes]));                          numBytes++;                          break;                      case "String":                          {                              numBytes = Math.Ceiling(numBytes);                              if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                                  numBytes++;                                MarshalAsAttribute mAttr = null;                              object[] attr = info.GetCustomAttributes(typeof (MarshalAsAttribute)' false);                              if (attr.Length > 0)                                  mAttr = (MarshalAsAttribute) attr[0];                              if (mAttr == null || mAttr.Value != UnmanagedType.ByValTStr || mAttr.SizeConst <= 0)                                  throw new Exception("Strings in Structs need to be decorated with \"MarshalAs(UnmanagedType.ByValTStr' SizeConst = xx)\"");                                var sb = new StringBuilder();                              int size = mAttr.SizeConst > bytes[((int) numBytes) + 1] ? bytes[((int) numBytes) + 1] : mAttr.SizeConst;                              for (var n = 2; n < size+2; n++)                                  sb.Append((char) bytes[n + (int) numBytes]);                              info.SetValue(structValue' (String) sb.ToString());                                numBytes += 2 + mAttr.SizeConst;                          }                          break;                      case "Int16":                           numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' libnodave.getS16from(bytes' (int) numBytes));                          numBytes += 2;                          break;                      case "UInt16":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' libnodave.getU16from(bytes' (int) numBytes));                          numBytes += 2;                          break;                      case "Int32":                           numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' libnodave.getS32from(bytes' (int)numBytes));                          numBytes += 4;                          break;                      case "UInt32":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' libnodave.getU32from(bytes' (int)numBytes));                          numBytes += 4;                          break;                      case "Double":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          // hier auswerten                          info.SetValue(structValue' libnodave.getFloatfrom(bytes' (int)numBytes));                          numBytes += 4;                          break;                  }
Missing Default,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag<T>,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTagGeneric.cs,GetStructSize,The following switch statement is missing a default case: switch (info.FieldType.Name)                  {                      case "Boolean":                          numBytes += 0.125;                          break;                      case "Byte":                          numBytes = Math.Ceiling(numBytes);                          numBytes++;                          break;                      case "Int16":                      case "UInt16":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          numBytes += 2;                          break;                      case "Int32":                      case "UInt32":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          numBytes += 4;                          break;                      case "Float":                      case "Double":                          numBytes = Math.Ceiling(numBytes);                          if ((numBytes / 2 - Math.Floor(numBytes / 2.0)) > 0)                              numBytes++;                          numBytes += 4;                          break;                      case "String":                          {                              MarshalAsAttribute mAttr=null;                              object[] attr = info.GetCustomAttributes(typeof (MarshalAsAttribute)' false);                              if (attr.Length > 0)                                  mAttr = (MarshalAsAttribute) attr[0];                              if (mAttr == null || mAttr.Value != UnmanagedType.ByValTStr || mAttr.SizeConst <= 0)                                  throw new Exception("Strings in Structs need to be decorated with \"MarshalAs(UnmanagedType.ByValTStr' SizeConst = xx)\"");                                numBytes += mAttr.SizeConst + 2;                          }                          break;                          /*                       * Typen welche noch fehlen                       *                        *                       case Arrays von jedem Datentyp!                      struct of struct                      TimeSpan                       *                       case "DateTime":                      case "String": //   Look for: [MarshalAs(UnmanagedType.ByValTStr ' SizeConst = 7)]                          break;                            */                  }
Missing Default,DotNetSiemensPLCToolBoxLibrary.Communication,PLCTag<T>,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Communication\PLCTagGeneric.cs,ToBytes,The following switch statement is missing a default case: switch (info.FieldType.Name)                  {                      case "Boolean":                          // get the value                          bytePos = (int)Math.Floor(numBytes);                          bitPos = (int)((numBytes - (double)bytePos) / 0.125);                          if ((bool)info.GetValue(structValue))                              bytes[bytePos] |= (byte)Math.Pow(2' bitPos);            // is true                          else                              bytes[bytePos] &= (byte)(~(byte)Math.Pow(2' bitPos));   // is false                          numBytes += 0.125;                          break;                      case "Byte":                          numBytes = (int)Math.Ceiling(numBytes);                          bytePos = (int)numBytes;                          bytes[bytePos] = (byte)info.GetValue(structValue);                          numBytes++;                          break;                      case "String":                          {                              MarshalAsAttribute mAttr = null;                              object[] attr = info.GetCustomAttributes(typeof (MarshalAsAttribute)' false);                              if (attr.Length > 0)                                  mAttr = (MarshalAsAttribute) attr[0];                              if (mAttr == null || mAttr.Value != UnmanagedType.ByValTStr || mAttr.SizeConst <= 0)                                  throw new Exception("Strings in Structs need to be decorated with \"MarshalAs(UnmanagedType.ByValTStr' SizeConst = xx)\"");                                bytes2 = new byte[mAttr.SizeConst + 2];                              libnodave.putS7Stringat(bytes2' 0' (string)info.GetValue(structValue)' bytes2.Length);                              bytePos = (int)numBytes;                          }                          break;                      case "Int16":                          bytes2 = new byte[2];                          libnodave.putS16at(bytes2' 0' (Int16) info.GetValue(structValue));                          bytePos = (int)numBytes;                          break;                      case "UInt16":                          bytes2 = new byte[2];                          libnodave.putU16at(bytes2' 0' (UInt16) info.GetValue(structValue));                          bytePos = (int)numBytes;                          break;                      case "Int32":                          bytes2 = new byte[4];                          libnodave.putS32at(bytes2' 0' (Int32) info.GetValue(structValue));                          bytePos = (int)numBytes;                          break;                      case "UInt32":                          bytes2 = new byte[4];                          libnodave.putU32at(bytes2' 0' (UInt32) info.GetValue(structValue));                          bytePos = (int)numBytes;                          break;                      case "Double":                          bytes2 = new byte[4];                          libnodave.putFloatat(bytes2' 0' Convert.ToSingle((double)info.GetValue(structValue)));                          bytePos = (int)numBytes;                          break;                      case "Single":                          bytes2 = new byte[4];                          libnodave.putFloatat(bytes2' 0' (Single)info.GetValue(structValue));                          bytePos = (int)numBytes;                          break;                  }
Missing Default,DotNetSiemensPLCToolBoxLibrary.DataTypes,PLCBlockName,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DataTypes\PLCBlockName.cs,PLCBlockName,The following switch statement is missing a default case: switch (block)              {                  case "FC":                      blk = DataTypes.PLCBlockType.FC;                      break;                  case "FB":                      blk = DataTypes.PLCBlockType.FB;                      break;                  case "DB":                      blk = DataTypes.PLCBlockType.DB;                      break;                  case "OB":                      blk = DataTypes.PLCBlockType.OB;                      break;                  case "SDB":                      blk = DataTypes.PLCBlockType.SDB;                      break;              }
Missing Default,DotNetSiemensPLCToolBoxLibrary.DBF,ParseDBF,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DBF\ParseDBF.cs,ReadDBF,The following switch statement is missing a default case: switch (field.fieldType)                      {                          case dBaseType.N:                              if (dBaseConverter.N_IsDecimal(NumberByteArray)){                                  col = new DataColumn(field.fieldName' typeof(decimal));                              }else{                                  col = new DataColumn(field.fieldName' typeof(int));                              }                              break;                          case dBaseType.C:                              col = new DataColumn(field.fieldName' typeof(string));                              break;                          case dBaseType.T:                              col = new DataColumn(field.fieldName' typeof(DateTime));                              break;                          case dBaseType.D:                              col = new DataColumn(field.fieldName' typeof(DateTime));                              break;                          case dBaseType.L:                              col = new DataColumn(field.fieldName' typeof(bool));                              break;                          case dBaseType.F:                              col = new DataColumn(field.fieldName' typeof(Double));                              break;                          case dBaseType.M:                              //Field Type Memo...                              col = new DataColumn(field.fieldName' typeof(byte[]));                              break;                      }
Missing Default,DotNetSiemensPLCToolBoxLibrary.DBF,ParseDBF,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\DBF\ParseDBF.cs,ReadDBF,The following switch statement is missing a default case: switch (field.fieldType)                          {                              case dBaseType.N:  // Number                                  byte[] NumberBytes = recReader.ReadBytes(field.fieldLen);                                  if (dBaseConverter.N_IsDecimal(NumberBytes)) {                                      row[fieldIndex + 1] = dBaseConverter.N_ToDecimal(NumberBytes);                                  } else {                                      row[fieldIndex + 1] = dBaseConverter.N_ToInt(NumberBytes);                                  }                                  break;                                case dBaseType.C: // String  							    row[fieldIndex + 1] = dBaseConverter.C_ToString( recReader.ReadBytes(field.fieldLen)' encoding);  								break;                                case dBaseType.M: // Memo                                  row[fieldIndex + 1] = ReadMemoBlock(dBaseConverter.N_ToInt(recReader.ReadBytes(field.fieldLen)));                                  break;                                case dBaseType.D: // Date (YYYYMMDD)                                  DateTime DTFromFile = dBaseConverter.D_ToDateTime(recReader.ReadBytes(8));                                  if (DTFromFile == DateTime.MinValue) {                                      row[fieldIndex + 1] = System.DBNull.Value;                                  } else {                                      row[fieldIndex] = DTFromFile;                                  }                                  break;                                case dBaseType.T:                                  row[fieldIndex + 1] = dBaseConverter.T_ToDateTime(recReader.ReadBytes(8));                                  break;                                case dBaseType.L: // Boolean (Y/N)                                  row[fieldIndex + 1] = dBaseConverter.L_ToBool(recReader.ReadByte());                                  break;                                case dBaseType.F:                                  row[fieldIndex + 1] = dBaseConverter.F_ToDouble(recReader.ReadBytes(field.fieldLen));                                  break;                          }
Missing Default,DotNetSiemensPLCToolBoxLibrary.General,ChunkedMemoryStream,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\General\ChunkedMemoryStream.cs,Seek,The following switch statement is missing a default case: switch (origin)              {                  case SeekOrigin.Begin:                      Position = offset;                      break;                    case SeekOrigin.Current:                      Position += offset;                      break;                    case SeekOrigin.End:                      Position = Length + offset;                      break;              }
Missing Default,DotNetSiemensPLCToolBoxLibrary.PLCs.S5.MC5,MC5toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S5\MC5\MC5toAWL.cs,GetParameters,The following switch statement is missing a default case: switch (t1)                  {                      case 2:                          tmp.S5ParameterType = S5ParameterType.E;                          break;                      case 4:                          tmp.S5ParameterType = S5ParameterType.D;                          break;                      case 5:                          tmp.S5ParameterType = S5ParameterType.T;                          break;                      case 7:                          tmp.S5ParameterType = S5ParameterType.B;                          break;                      case 8:                          tmp.S5ParameterType = S5ParameterType.A;                          break;                  }
Missing Default,DotNetSiemensPLCToolBoxLibrary.PLCs.S5.MC5,MC5toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S5\MC5\MC5toAWL.cs,GetParameters,The following switch statement is missing a default case: switch (t2)                      {                          case 1:                              tmp.S5ParameterFormat = S5ParameterFormat.KZ;                              break;                          case 2:                              tmp.S5ParameterFormat = S5ParameterFormat.KT;                              break;                          case 4:                              tmp.S5ParameterFormat = S5ParameterFormat.KF;                              break;                          case 8:                              tmp.S5ParameterFormat = S5ParameterFormat.KG;                              break;                          case 16:                              tmp.S5ParameterFormat = S5ParameterFormat.KC;                              break;                          case 32:                              tmp.S5ParameterFormat = S5ParameterFormat.KY;                              break;                          case 64:                              tmp.S5ParameterFormat = S5ParameterFormat.KH;                              break;                          case 128:                              tmp.S5ParameterFormat = S5ParameterFormat.KM;                              break;                      }
Missing Default,DotNetSiemensPLCToolBoxLibrary.PLCs.S5.MC5,MC5toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S5\MC5\MC5toAWL.cs,GetParameters,The following switch statement is missing a default case: switch (t2)                      {                          case 16:                              tmp.S5ParameterFormat = S5ParameterFormat.D;                              break;                          case 32:                              tmp.S5ParameterFormat = S5ParameterFormat.W;                              break;                          case 64:                              tmp.S5ParameterFormat = S5ParameterFormat.BY;                              break;                          case 128:                              tmp.S5ParameterFormat = S5ParameterFormat.BI;                              break;                      }
Missing Default,DotNetSiemensPLCToolBoxLibrary.PLCs.S5.MC5,MC5toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S5\MC5\MC5toAWL.cs,GetMC5Rows,The following switch statement is missing a default case: switch ((string)((object[])sym[index])[printpar])                          {                              case null:                                  break;                              case "PrintNummer":                                  if (!string.IsNullOrEmpty(newRow.Parameter))                                      newRow.Parameter += " ";                                  Int16 wrt = (Int16)par;                                  if (wrt >= 0 && newRow.Parameter == "KF ")                                      newRow.Parameter += " +";                                  newRow.Parameter += wrt.ToString();                                  break;                              case "PrintKY":                                  newRow.Parameter += BitConverter.GetBytes(par)[1].ToString() + "'" +                                                      BitConverter.GetBytes(par)[0].ToString();                                  break;                              case "PrintChar":                                  if (!string.IsNullOrEmpty(newRow.Parameter))                                      newRow.Parameter += " ";                                  newRow.Parameter += ((char)(BitConverter.GetBytes((Int16)par)[0])).ToString() + ((char)(BitConverter.GetBytes((Int16)par)[1]));                                  break;                              case "PrintHEX4":                                  if (!string.IsNullOrEmpty(newRow.Parameter))                                      newRow.Parameter += " ";                                  newRow.Parameter += par.ToString("X").PadLeft(4' '0');                                  break;                              case "PrintGleitpunkt":                                  if (!string.IsNullOrEmpty(newRow.Parameter))                                      newRow.Parameter += " ";                                  newRow.Parameter += "gleit";                                  break;                              case "PrintHEX8":                                  if (!string.IsNullOrEmpty(newRow.Parameter))                                      newRow.Parameter += " ";                                  newRow.Parameter += par.ToString("X").PadLeft(4' '0');                                  break;                              case "PrintMerkerBit":                                  if (!string.IsNullOrEmpty(newRow.Parameter))                                      newRow.Parameter += " ";                                  newRow.Parameter += (par & 0x00FF).ToString() + "." + (par >> 8).ToString();                                  break;                              case "PrintSMerkerBit":                                  if (!string.IsNullOrEmpty(newRow.Parameter))                                      newRow.Parameter += " ";                                  newRow.Parameter += (par & 0x0FFF).ToString() + "." + (par >> 12).ToString();                                  break;                          }
Missing Default,DotNetSiemensPLCToolBoxLibrary.PLCs.S5.MC5,MC5toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S5\MC5\MC5toAWL.cs,GetMC5Rows,The following switch statement is missing a default case: switch (ber & 0xf0)                                                  {                                                      case 0x80:                                                          akOper += "M";                                                          break;                                                  }
Missing Default,DotNetSiemensPLCToolBoxLibrary.PLCs.S5.MC5,MC5toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S5\MC5\MC5toAWL.cs,GetMC5Rows,The following switch statement is missing a default case: switch (ber)                                                  {                                                      case 0x12:                                                          akOper += "MW";                                                          break;                                                      case 0x32:                                                          akOper += "DW";                                                          break;                                                  }
Missing Default,DotNetSiemensPLCToolBoxLibrary.PLCs.S5.MC5,MC5toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S5\MC5\MC5toAWL.cs,GetMC5Rows,The following switch statement is missing a default case: switch (bst)                                          {                                              case 0x20:                                                  akOper += "DB";                                                  break;                                          }
Missing Default,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,AWLtoMC7,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\AWLtoMC7.cs,GetMC7,The following switch statement is missing a default case: switch (myCmd.GetParameterType())                  {                      case PLCFunctionBlockAdressType.Direct:                          if (myCmd.Parameter.ToUpper().Contains("FB"))                              if (Helper.GetParameterValueInt(myCmd.Parameter) < 256)                                  return new byte[] { 0x75' Helper.GetParameterValueBytes(myCmd.Parameter)[0] };                              else                                  return new byte[] { 0xFB' 0x72' Helper.GetParameterValueBytes(myCmd.Parameter)[1]' Helper.GetParameterValueBytes(myCmd.Parameter)[0] };                          else if (myCmd.ExtParameter == null || myCmd.ExtParameter.Count == 0)                              if (Helper.GetParameterValueInt(myCmd.Parameter) < 256)                                  return new byte[] { 0x3D' Helper.GetParameterValueBytes(myCmd.Parameter)[0]' 0x70' 0x0B' 0x00' 0x02 };                              else                                  return new byte[] { 0xFB' 0x70' Helper.GetParameterValueBytes(myCmd.Parameter)[1]' Helper.GetParameterValueBytes(myCmd.Parameter)[0]' 0x70' 0x0B' 0x00' 0x02 };                          else                          {                              List<byte> myAddVal = new List<byte>();                              if (Helper.GetParameterValueInt(myCmd.Parameter) < 256)                                  myAddVal.AddRange(new byte[] { 0xFB' 0x70' 0x00' Helper.GetParameterValueBytes(myCmd.Parameter)[0]' 0x70' 0x0B' 0x00 });                              else                                  myAddVal.AddRange(new byte[] { 0xFB' 0x70' Helper.GetParameterValueBytes(myCmd.Parameter)[1]' Helper.GetParameterValueBytes(myCmd.Parameter)[0]' 0x70' 0x0B' 0x00 });                              myAddVal.Add(Convert.ToByte(myCmd.ExtParameter.Count * 2 + 2));                              foreach (string par in myCmd.ExtParameter)                                  myAddVal.AddRange(Helper.GetCallParameterByte(par));                              return myAddVal.ToArray();                          }                      case PLCFunctionBlockAdressType.Indirect:                          if (myCmd.Parameter.ToUpper().Contains("FB"))                              return new byte[] { 0xFB' Convert.ToByte(Helper.GetIndirectBytesWord(myCmd.Parameter)[2] | 0x02)' Helper.GetIndirectBytesWord(myCmd.Parameter)[1]' Helper.GetIndirectBytesWord(myCmd.Parameter)[0]' 0x70' 0x0B' 0x00' 0x02 };                          else                              return new byte[] { 0xFB' Convert.ToByte(Helper.GetIndirectBytesWord(myCmd.Parameter)[2] | 0x00)' Helper.GetIndirectBytesWord(myCmd.Parameter)[1]' Helper.GetIndirectBytesWord(myCmd.Parameter)[0]' 0x70' 0x0B' 0x00' 0x02 };                  }
Missing Default,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,AWLToSource,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\AWLToSource.cs,DataRowToSource,The following switch statement is missing a default case: switch (s7DataRow.DataType)                      {                          case S7DataRowType.DWORD:                          case S7DataRowType.WORD:                          case S7DataRowType.BYTE:                              valuePrefix = "16#";                              break;                      }
Missing Default,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,MemoryAreaToPointer,The following switch statement is missing a default case: switch (area)              {                  case MemoryArea.Inputs:                      return Mnemonic.adE[(int)language];                  case MemoryArea.Outputs:                      return Mnemonic.adA[(int)language];                  case MemoryArea.Timer:                      return Mnemonic.adT[(int)language];                  case MemoryArea.Flags:                      return Mnemonic.adM[(int)language];                  case MemoryArea.Counter:                      return Mnemonic.adZ[(int)language];                  case MemoryArea.Datablock:                      return Mnemonic.adDBX[(int)language];                  case MemoryArea.InstanceDatablock:                      return Mnemonic.adDIX[(int)language];              }
Missing Default,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetUIntFromHexString,The following switch statement is missing a default case: switch (tmp)                  {                      case '0':                      case '1':                      case '2':                      case '3':                      case '4':                      case '5':                      case '6':                      case '7':                      case '8':                      case '9':                          val += (uint)(tmp - '0');                          break;                      case 'a':                      case 'b':                      case 'c':                      case 'd':                      case 'e':                      case 'f':                          val += (uint)(tmp - 'a' + 10);                          break;                  }
Missing Default,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetIndirectBytesWord,The following switch statement is missing a default case: switch (tmp.Substring(0'2))              {                  case "PEW":                  case "PIW":                  case "PAW":                  case "POW":                      nr = Convert.ToInt32(tmp.Replace("PEW"' "").Replace("PAW"' "").Replace("PIW"' "").Replace("POW"' ""));                      nr2 = 0;                      break;                  case "EW":                  case "IW":                      nr = Convert.ToInt32(tmp.Replace("EW"' "").Replace("IW"' ""));                      nr2 = 10;                      break;                  case "AW":                  case "OW":                      nr = Convert.ToInt32(tmp.Replace("AW"' "").Replace("OW"' ""));                      nr2 = 20;                      break;                  case "MW":                      nr = Convert.ToInt32(tmp.Replace("MW"' ""));                      nr2 = 30;                      break;                  case "DBW":                      nr = Convert.ToInt32(tmp.Replace("DBW"' ""));                      nr2 = 40;                      break;                  case "DIW":                      nr = Convert.ToInt32(tmp.Replace("DIW"' ""));                      nr2 = 50;                      break;                  case "LW":                      nr = Convert.ToInt32(tmp.Replace("LW"' ""));                      nr2 = 60;                      break;              }
Missing Default,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetPLCBlockType,The following switch statement is missing a default case: switch (b)              {                  case 0x08:                      return DataTypes.PLCBlockType.OB;                  case 0x0A:                      return DataTypes.PLCBlockType.DB;                  case 0x0b:                      return DataTypes.PLCBlockType.SDB;                  case 0x0C:                      return DataTypes.PLCBlockType.FC;                  case 0x0D:                      return DataTypes.PLCBlockType.SFC;                  case 0x0E:                      return DataTypes.PLCBlockType.FB;                  case 0x0F:                      return DataTypes.PLCBlockType.SFB;              }
Missing Default,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetPLCBlockTypeForBlockList,The following switch statement is missing a default case: switch (myTP)              {                  case DataTypes.PLCBlockType.OB:                      return '8';                  case DataTypes.PLCBlockType.DB:                      return 'A';                  case DataTypes.PLCBlockType.SDB:                      return 'B';                  case DataTypes.PLCBlockType.FC:                      return 'C';                  case DataTypes.PLCBlockType.SFC:                      return 'D';                  case DataTypes.PLCBlockType.FB:                      return 'E';                  case DataTypes.PLCBlockType.SFB:                      return 'F';              }
Missing Default,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetS5Time,The following switch statement is missing a default case: switch ((b1 >> 4) & 0x03)              {                  case 0x00: ms = ms * 10; break;                  case 0x01: ms = ms * 100; break;                  case 0x02: ms = ms * 1000; break;                  case 0x03: ms = ms * 10000; break;              }
Missing Default,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,Helper,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\Helper.cs,GetPointer,The following switch statement is missing a default case: switch (BD[pos])                  {                      case 0x80:                          Result = Result + "P ";                          break;                      case 0x81:                          Result = Result + Mnemonic.adE[language] + " ";                          break;                      case 0x82:                          Result = Result + Mnemonic.adA[language] + " ";                          break;                      case 0x83:                          Result = Result + Mnemonic.adM[language] + " ";                          break;                      case 0x84:                          Result = Result + Mnemonic.adDBX[language] + " ";                          break;                      case 0x85:                          Result = Result + Mnemonic.adDIX[language] + " ";                          break;                      case 0x86:                          Result = Result + Mnemonic.adL[language] + " ";                          break;                      case 0x87:                          Result = Result + "V ";                          break;                      case 0x8f:                          Result = Result + "L ";                          Result = Result + Convert.ToString((BD[pos + 1] * 0x10000 + BD[pos + 2] * 0x100 + BD[pos + 3]) >> 3) + "." + Convert.ToString(BD[pos+3] & 0x07);                          return Result;                          break;                  }
Missing Default,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7toAWL.cs,GetAWL,The following switch statement is missing a default case: switch (BD[pos])                      {                          case (0x00):                              curr_op = HighByte < 0x90 ? Mnemonic.opU[MN] : Mnemonic.opUN[MN];                              break;                          case (0x01):                              curr_op = HighByte < 0x90 ? Mnemonic.opO[MN] : Mnemonic.opON[MN];                              break;                          case (0x05):                              curr_op = HighByte < 0x90 ? Mnemonic.opX[MN] : Mnemonic.opXN[MN];                              break;                          case (0x09):                              curr_op = HighByte < 0x90 ? Mnemonic.opS[MN] : Mnemonic.opR[MN];                              break;                          case (0x49):                              curr_op = HighByte < 0x90 ? Mnemonic.opFP[MN] : Mnemonic.opFN[MN];                              break;                      }
Missing Default,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7toAWL.cs,GetAWL,The following switch statement is missing a default case: switch (HighByte)                      {                          case (0x10):                          case (0x90):                              curr_ad = Mnemonic.adE[MN];                              break;                          case (0x20):                          case (0xA0):                              curr_ad = Mnemonic.adA[MN];                              break;                          case (0x30):                          case (0xB0):                              curr_ad = Mnemonic.adM[MN];                              break;                          case (0x40):                          case (0xC0):                              if (retVal[retVal.Count - 1].Command == Mnemonic.opAUF[MN] && !((S7FunctionBlockRow)retVal[retVal.Count - 1]).Parameter.Contains("["))// && CombineDBOpenAndCommand)                              {                                  ((S7FunctionBlockRow)retVal[retVal.Count - 1]).CombineDBAccess = true;                                                              }                              curr_ad = Mnemonic.adDBX[MN];                              break;                          case (0x50):                          case (0xD0):                              curr_ad = Mnemonic.adDIX[MN];                              break;                          case (0x60):                          case (0xE0):                              curr_ad = Mnemonic.adL[MN];                              break;                      }
Missing Default,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7toAWL.cs,GetAWL,The following switch statement is missing a default case: switch (BD[pos + 1])                                  {                                      case 0x20:                                          retVal.Add(new S7FunctionBlockRow() { Command = ">I" });                                          break;                                      case 0x40:                                          retVal.Add(new S7FunctionBlockRow() { Command = "<I" });                                          break;                                      case 0x60:                                          retVal.Add(new S7FunctionBlockRow() { Command = "<>I" });                                          break;                                      case 0x80:                                          retVal.Add(new S7FunctionBlockRow() { Command = "==I" });                                          break;                                      case 0xA0:                                          retVal.Add(new S7FunctionBlockRow() { Command = ">=I" });                                          break;                                      case 0xC0:                                          retVal.Add(new S7FunctionBlockRow() { Command = "<=I" });                                          break;                                  }
Missing Default,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7toAWL.cs,GetAWL,The following switch statement is missing a default case: switch (BD[pos + 1])                                  {                                      case 0x02:                                          par = "2#" + Helper.GetWordBool(BD[pos + 2]' BD[pos + 3]);                                          break;                                      case 0x03:                                          par = Convert.ToString(libnodave.getS16from(BD' pos + 2)); //Helper.GetInt(BD[pos + 2]' BD[pos + 3]));                                          break;                                      case 0x05:                                          par = Helper.GetS7String(pos + 2' 2' BD);                                          break;                                      case 0x06:                                          par = "B#(" + Convert.ToString(BD[pos + 2]) + "' " +                                                   Convert.ToString(BD[pos + 3]) + ")";                                          break;                                      case 0x00:                                      case 0x07:                                          par = "W#16#" + libnodave.getU16from(BD' pos + 2).ToString("X"); // Helper.GetWord(BD[pos + 2]' BD[pos + 3]).ToString("X");                                          break;                                      case 0x08:                                          par = "C#" + libnodave.getU16from(BD' pos + 2).ToString("X"); // Helper.GetWord(BD[pos + 2]' BD[pos + 3]).ToString("X");                                          break;                                      case 0x0A:                                          par = Helper.GetDate(BD[pos + 2]' BD[pos + 3]);                                          break;                                      case 0x0C:                                          par = Helper.GetS5Time(BD[pos + 2]' BD[pos + 3]);                                          break;                                  }
Missing Default,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7toAWL.cs,GetAWL,The following switch statement is missing a default case: switch (BD[pos + 1])                                  {                                      case 0x20:                                          retVal.Add(new S7FunctionBlockRow() { Command = ">R" });                                          break;                                      case 0x40:                                          retVal.Add(new S7FunctionBlockRow() { Command = "<R" });                                          break;                                      case 0x60:                                          retVal.Add(new S7FunctionBlockRow() { Command = "<>R" });                                          break;                                      case 0x80:                                          retVal.Add(new S7FunctionBlockRow() { Command = "==R" });                                          break;                                      case 0xA0:                                          retVal.Add(new S7FunctionBlockRow() { Command = ">=R" });                                          break;                                      case 0xC0:                                          retVal.Add(new S7FunctionBlockRow() { Command = "<=R" });                                          break;                                  }
Missing Default,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7toAWL.cs,GetAWL,The following switch statement is missing a default case: switch (BD[pos + 1])                                  {                                      case 0x01:                                          par = libnodave.getFloatfrom(BD' pos + 2).ToString("0.000000e+000"' numberFormat);                                          break;                                      case 0x02:                                          par = "2#" +                                                   Helper.GetDWordBool(BD[pos + 2]' BD[pos + 3]' BD[pos + 4]' BD[pos + 5]);                                          break;                                      case 0x03:                                          par = "L#" + Convert.ToString(libnodave.getS32from(BD' pos + 2));                                          break;                                      case 0x04:                                          par = Helper.GetPointer(BD' pos + 2' MN);                                          break;                                      case 0x05:                                          par = Helper.GetS7String(pos + 2' 4' BD);                                          break;                                      case 0x06:                                          par = "B#(" + Convert.ToString(BD[pos + 2]) + "' " +                                                   Convert.ToString(BD[pos + 3]) + "' " + Convert.ToString(BD[pos + 4]) +                                                   "' " +                                                   Convert.ToString(BD[pos + 5]) + ")";                                          break;                                      case 0x07:                                          par = "DW#16#" + libnodave.getU32from(BD' pos + 2).ToString("X");                                          break;                                      case 0x09:                                          par = Helper.GetDTime(BD' pos + 2);                                          break;                                      case 0x0b:                                          par = Helper.GetTOD(BD' pos + 2);                                          break;                                  }
Missing Default,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7toAWL.cs,GetAWL,The following switch statement is missing a default case: switch (BD[pos + 1])                                  {                                      case 0x20:                                          retVal.Add(new S7FunctionBlockRow() { Command = ">D" });                                          //Result = Result + ">D";                                          break;                                      case 0x40:                                          retVal.Add(new S7FunctionBlockRow() { Command = "<D" });                                          //Result = Result + "<D";                                          break;                                      case 0x60:                                          retVal.Add(new S7FunctionBlockRow() { Command = "<>D" });                                          //Result = Result + "<>D";                                          break;                                      case 0x80:                                          retVal.Add(new S7FunctionBlockRow() { Command = "==D" });                                          //Result = Result + "==D";                                          break;                                      case 0xA0:                                          retVal.Add(new S7FunctionBlockRow() { Command = ">=D" });                                          //Result = Result + ">=D";                                          break;                                      case 0xC0:                                          retVal.Add(new S7FunctionBlockRow() { Command = "<=D" });                                          //Result = Result + "<=D";                                          break;                                  }
Missing Default,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7toAWL.cs,GetAWL,The following switch statement is missing a default case: switch (BD[pos])                                      {                                          case 0x51:                                              cmd = Mnemonic.opXOW[MN];                                              retVal.Add(new S7FunctionBlockRow() { Command = cmd });                                              ((S7FunctionBlockRow)retVal[retVal.Count - 1]).MC7 = new byte[] { BD[pos]' BD[pos + 1] };                                              pos += 2;                                              break;                                          case 0x58:                                              cmd = Mnemonic.opPLU[MN];                                              retVal.Add(new S7FunctionBlockRow()                                                             {                                                                 Command = cmd'                                                                 Parameter = libnodave.getS16from(BD' pos + 2).ToString()                                                             });                                              ((S7FunctionBlockRow)retVal[retVal.Count - 1]).MC7 = new byte[]                                                                                 {                                                                                     BD[pos]' BD[pos + 1]' BD[pos + 2]'                                                                                     BD[pos + 3]                                                                                 };                                              pos += 4;                                              break;                                          case 0x59:                                              cmd = "-I";                                              retVal.Add(new S7FunctionBlockRow() { Command = cmd });                                              ((S7FunctionBlockRow)retVal[retVal.Count - 1]).MC7 = new byte[] { BD[pos]' BD[pos + 1] };                                              pos += 2;                                              break;                                      }
Missing Default,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7toAWL.cs,GetAWL,The following switch statement is missing a default case: switch (BD[pos])                                      {                                          case 0x51:                                              if (BD[pos + 1] < 0xb0)                                                  cmd = LowByte < 0x09 ? Mnemonic.opU[MN] : Mnemonic.opO[MN];                                              else                                                  cmd = LowByte < 0x09 ? Mnemonic.opUN[MN] : Mnemonic.opON[MN];                                              break;                                          case 0x58:                                              if (BD[pos + 1] < 0xb0)                                                  cmd = LowByte < 0x09 ? Mnemonic.opX[MN] : Mnemonic.opS[MN];                                              else                                                  cmd = LowByte < 0x09 ? Mnemonic.opXN[MN] : Mnemonic.opR[MN];                                              break;                                          case 0x59:                                              if (BD[pos + 1] < 0xb0)                                                  cmd = LowByte < 0x09 ? Mnemonic.opZUW[MN] : Mnemonic.opFP[MN];                                              else                                                  cmd = LowByte < 0x09 ? "err1" : Mnemonic.opFN[MN];//Don't know the Low Byte command                                              break;                                      }
Missing Default,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7toAWL.cs,GetAWL,The following switch statement is missing a default case: switch (BD[pos + 1] & 0x0F)                                      {                                          case 0x01:                                          case 0x09:                                              par = Mnemonic.adE[MN];                                              break;                                          case 0x02:                                          case 0x0A:                                              par = Mnemonic.adA[MN];                                              break;                                          case 0x03:                                          case 0x0B:                                              par = Mnemonic.adM[MN];                                              break;                                          case 0x04:                                          case 0x0C:                                              par = Mnemonic.adDBX[MN];                                              break;                                          case 0x05:                                          case 0x0D:                                              par = Mnemonic.adDIX[MN];                                              break;                                          case 0x06:                                          case 0x0E:                                              par = Mnemonic.adL[MN];                                              break;                                        }
Missing Default,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7toAWL.cs,GetAWL,The following switch statement is missing a default case: switch (BD[pos + 1] & 0xF0)                                      {                                            case 0x30:                                          case 0xb0:                                              par += Mnemonic.adMD[MN] + Convert.ToString(libnodave.getU16from(BD' pos + 2)) +                                                     "]";                                              break;                                          case 0x40:                                          case 0xc0:                                              par += Mnemonic.adDBD[MN] + Convert.ToString(libnodave.getU16from(BD' pos + 2)) +                                                     "]";                                              break;                                          case 0x50:                                          case 0xd0:                                              par += Mnemonic.adDID[MN] + Convert.ToString(libnodave.getU16from(BD' pos + 2)) +                                                     "]";                                              break;                                          case 0x60:                                          case 0xe0:                                              par += Mnemonic.adLD[MN] + Convert.ToString(libnodave.getU16from(BD' pos + 2)) +                                                     "]";                                              break;                                          case 0x70:                                          case 0xf0:                                              par += Mnemonic.adMD[MN] + Convert.ToString(libnodave.getU16from(BD' pos + 2)) +                                                     "]";                                              break;                                      }
Missing Default,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7toAWL.cs,GetAWL,The following switch statement is missing a default case: switch (BD[pos + 1])                                  {                                      case 0x00:                                          retVal.Add(new S7FunctionBlockRow() { Command = "/I" });                                          break;                                      case 0x01:                                          retVal.Add(new S7FunctionBlockRow() { Command = Mnemonic.opMOD[MN] });                                          break;                                      case 0x02:                                          retVal.Add(new S7FunctionBlockRow() { Command = Mnemonic.opABS[MN] });                                          break;                                      case 0x03:                                          retVal.Add(new S7FunctionBlockRow() { Command = "/R" });                                          break;                                      case 0x04:                                          retVal.Add(new S7FunctionBlockRow() { Command = "*I" });                                          break;                                      case 0x05:                                          {                                              retVal.Add(new S7FunctionBlockRow()                                                             {                                                                 Command = Mnemonic.opPLU[MN]'                                                                 Parameter = "L#" + Convert.ToString(libnodave.getS32from(BD' pos + 2))                                                             });                                              ((S7FunctionBlockRow)retVal[retVal.Count - 1]).MC7 = new byte[] { BD[pos]' BD[pos + 1]' BD[pos + 2]' BD[pos + 3]' BD[pos + 4]' BD[pos + 5] };                                              pos += 6;                                              goto brk2;                                          }                                          break;                                      case 0x06:                                          retVal.Add(new S7FunctionBlockRow() { Command = Mnemonic.opNEGR[MN] });                                          break;                                      case 0x07:                                          retVal.Add(new S7FunctionBlockRow() { Command = "*R" });                                          break;                                      case 0x08:                                          retVal.Add(new S7FunctionBlockRow() { Command = Mnemonic.opENT[MN] });                                          break;                                      case 0x09:                                          retVal.Add(new S7FunctionBlockRow() { Command = "-D" });                                          break;                                      case 0x0A:                                          retVal.Add(new S7FunctionBlockRow() { Command = "*D" });                                          break;                                      case 0x0b:                                          retVal.Add(new S7FunctionBlockRow() { Command = "-R" });                                          break;                                      case 0x0D:                                          retVal.Add(new S7FunctionBlockRow() { Command = "+D" });                                          break;                                      case 0x0E:                                          retVal.Add(new S7FunctionBlockRow() { Command = "/D" });                                          break;                                      case 0x0F:                                          retVal.Add(new S7FunctionBlockRow() { Command = "+R" });                                          break;                                      case 0x10:                                          retVal.Add(new S7FunctionBlockRow() { Command = Mnemonic.opSIN[MN] });                                          break;                                      case 0x11:                                          retVal.Add(new S7FunctionBlockRow() { Command = Mnemonic.opCOS[MN] });                                          break;                                      case 0x12:                                          retVal.Add(new S7FunctionBlockRow() { Command = Mnemonic.opTAN[MN] });                                          break;                                      case 0x13:                                          retVal.Add(new S7FunctionBlockRow() { Command = Mnemonic.opLN[MN] });                                          break;                                      case 0x14:                                          retVal.Add(new S7FunctionBlockRow() { Command = Mnemonic.opSQRT[MN] });                                          break;                                      case 0x18:                                          retVal.Add(new S7FunctionBlockRow() { Command = Mnemonic.opASIN[MN] });                                          break;                                      case 0x19:                                          retVal.Add(new S7FunctionBlockRow() { Command = Mnemonic.opACOS[MN] });                                          break;                                      case 0x1A:                                          retVal.Add(new S7FunctionBlockRow() { Command = Mnemonic.opATAN[MN] });                                          break;                                      case 0x1b:                                          retVal.Add(new S7FunctionBlockRow() { Command = Mnemonic.opEXP[MN] });                                          break;                                      case 0x1C:                                          retVal.Add(new S7FunctionBlockRow() { Command = Mnemonic.opSQR[MN] });                                          break;                                  }
Missing Default,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7toAWL.cs,GetAWL,The following switch statement is missing a default case: switch (BD[pos + 1])                                  {                                      case 0x00:                                          retVal.Add(new S7FunctionBlockRow() { Command = Mnemonic.opBE[MN] });                                          //Result = Result + Memnoic.opBE[MN];                                          break;                                      case 0x01:                                          retVal.Add(new S7FunctionBlockRow() { Command = Mnemonic.opBEA[MN] });                                          //Result = Result + Memnoic.opBEA[MN];                                          break;                                  }
Missing Default,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7toAWL.cs,GetAWL,The following switch statement is missing a default case: switch (LowByte)                                      {                                          case 0x00:                                          case 0x08:                                              cmd += (HighByte < 0x90) ? Mnemonic.opU[MN] : Mnemonic.opS[MN];                                              break;                                          case 0x01:                                          case 0x09:                                              cmd += (HighByte < 0x90) ? Mnemonic.opUN[MN] : Mnemonic.opR[MN];                                              break;                                          case 0x02:                                          case 0x0A:                                              cmd += (HighByte < 0x90) ? Mnemonic.opO[MN] : Mnemonic.opZUW[MN];                                              break;                                          case 0x03:                                          case 0x0B:                                              cmd += (HighByte < 0x90) ? Mnemonic.opON[MN] : "err5"; //Ther is no Value for this???                                              break;                                          case 0x04:                                          case 0x0C:                                              cmd += (HighByte < 0x90) ? Mnemonic.opX[MN] : Mnemonic.opFP[MN];                                              break;                                          case 0x05:                                          case 0x0D:                                              cmd += (HighByte < 0x90) ? Mnemonic.opXN[MN] : Mnemonic.opFN[MN];                                              break;                                      }
Missing Default,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7toAWL.cs,GetAWL,The following switch statement is missing a default case: switch (HighByte)                                      {                                          case 0x10:                                          case 0x90:                                              par += Mnemonic.adE[MN];                                              break;                                          case 0x20:                                          case 0xa0:                                              par += Mnemonic.adA[MN];                                              break;                                          case 0x30:                                          case 0xb0:                                              par += Mnemonic.adM[MN];                                              break;                                          case 0x40:                                          case 0xc0:                                              par += Mnemonic.adDBX[MN];                                              break;                                          case 0x50:                                          case 0xd0:                                              par += Mnemonic.adDIX[MN];                                              break;                                          case 0x60:                                          case 0xe0:                                              par += Mnemonic.adL[MN];                                              break;                                        }
Missing Default,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7toAWL.cs,GetAWL,The following switch statement is missing a default case: switch (HighByte)                                      {                                          case 0x00:                                              switch (LowByte)                                              {                                                  case 0x01:                                                  case 0x09:                                                      par += Mnemonic.adPEB[MN];                                                      break;                                                  case 0x02:                                                  case 0x0A:                                                      par += Mnemonic.adPEW[MN];                                                      break;                                                  case 0x03:                                                  case 0x0B:                                                      par += Mnemonic.adPED[MN];                                                      break;                                                  case 0x05:                                                  case 0x0D:                                                      par += Mnemonic.adPAB[MN];                                                      break;                                                  case 0x06:                                                  case 0x0E:                                                      par += Mnemonic.adPAW[MN];                                                      break;                                                  case 0x07:                                                  case 0x0F:                                                      par += Mnemonic.adPAD[MN];                                                      break;                                              }                                              break;                                          case 0x10:                                              switch (LowByte)                                              {                                                  case 0x01:                                                  case 0x05:                                                  case 0x09:                                                  case 0x0D:                                                      par += Mnemonic.adEB[MN];                                                      break;                                                  case 0x02:                                                  case 0x06:                                                  case 0x0A:                                                  case 0x0E:                                                      par += Mnemonic.adEW[MN];                                                      break;                                                  case 0x03:                                                  case 0x07:                                                  case 0x0B:                                                  case 0x0F:                                                      par += Mnemonic.adED[MN];                                                      break;                                              }                                              break;                                          case 0x20:                                              switch (LowByte)                                              {                                                  case 0x01:                                                  case 0x05:                                                  case 0x09:                                                  case 0x0D:                                                      par += Mnemonic.adAB[MN];                                                      break;                                                  case 0x02:                                                  case 0x06:                                                  case 0x0A:                                                  case 0x0E:                                                      par += Mnemonic.adAW[MN];                                                      break;                                                  case 0x03:                                                  case 0x07:                                                  case 0x0B:                                                  case 0x0F:                                                      par += Mnemonic.adAD[MN];                                                      break;                                              }                                              break;                                          case 0x30:                                              switch (LowByte)                                              {                                                  case 0x01:                                                  case 0x05:                                                  case 0x09:                                                  case 0x0D:                                                      par += Mnemonic.adMB[MN];                                                      break;                                                  case 0x02:                                                  case 0x06:                                                  case 0x0A:                                                  case 0x0E:                                                      par += Mnemonic.adMW[MN];                                                      break;                                                  case 0x03:                                                  case 0x07:                                                  case 0x0B:                                                  case 0x0F:                                                      par += Mnemonic.adMD[MN];                                                      break;                                              }                                              break;                                          case 0x40:                                              switch (LowByte)                                              {                                                  case 0x01:                                                  case 0x05:                                                  case 0x09:                                                  case 0x0D:                                                      par += Mnemonic.adDBB[MN];                                                      break;                                                  case 0x02:                                                  case 0x06:                                                  case 0x0A:                                                  case 0x0E:                                                      par += Mnemonic.adDBW[MN];                                                      break;                                                  case 0x03:                                                  case 0x07:                                                  case 0x0B:                                                  case 0x0F:                                                      par += Mnemonic.adDBD[MN];                                                      break;                                              }                                              break;                                          case 0x50:                                              switch (LowByte)                                              {                                                  case 0x01:                                                  case 0x05:                                                  case 0x09:                                                  case 0x0D:                                                      par += Mnemonic.adDIB[MN];                                                      break;                                                  case 0x02:                                                  case 0x06:                                                  case 0x0A:                                                  case 0x0E:                                                      par += Mnemonic.adDIW[MN];                                                      break;                                                  case 0x03:                                                  case 0x07:                                                  case 0x0B:                                                  case 0x0F:                                                      par += Mnemonic.adDID[MN];                                                      break;                                              }                                              break;                                          case 0x60:                                              switch (LowByte)                                              {                                                  case 0x01:                                                  case 0x05:                                                  case 0x09:                                                  case 0x0D:                                                      par += Mnemonic.adLB[MN];                                                      break;                                                  case 0x02:                                                  case 0x06:                                                  case 0x0A:                                                  case 0x0E:                                                      par += Mnemonic.adLW[MN];                                                      break;                                                  case 0x03:                                                  case 0x07:                                                  case 0x0B:                                                  case 0x0F:                                                      par += Mnemonic.adLD[MN];                                                      break;                                              }                                              break;                                      }
Missing Default,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7toAWL.cs,GetAWL,The following switch statement is missing a default case: switch (LowByte)                                              {                                                  case 0x01:                                                  case 0x09:                                                      par += Mnemonic.adPEB[MN];                                                      break;                                                  case 0x02:                                                  case 0x0A:                                                      par += Mnemonic.adPEW[MN];                                                      break;                                                  case 0x03:                                                  case 0x0B:                                                      par += Mnemonic.adPED[MN];                                                      break;                                                  case 0x05:                                                  case 0x0D:                                                      par += Mnemonic.adPAB[MN];                                                      break;                                                  case 0x06:                                                  case 0x0E:                                                      par += Mnemonic.adPAW[MN];                                                      break;                                                  case 0x07:                                                  case 0x0F:                                                      par += Mnemonic.adPAD[MN];                                                      break;                                              }
Missing Default,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7toAWL.cs,GetAWL,The following switch statement is missing a default case: switch (LowByte)                                              {                                                  case 0x01:                                                  case 0x05:                                                  case 0x09:                                                  case 0x0D:                                                      par += Mnemonic.adEB[MN];                                                      break;                                                  case 0x02:                                                  case 0x06:                                                  case 0x0A:                                                  case 0x0E:                                                      par += Mnemonic.adEW[MN];                                                      break;                                                  case 0x03:                                                  case 0x07:                                                  case 0x0B:                                                  case 0x0F:                                                      par += Mnemonic.adED[MN];                                                      break;                                              }
Missing Default,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7toAWL.cs,GetAWL,The following switch statement is missing a default case: switch (LowByte)                                              {                                                  case 0x01:                                                  case 0x05:                                                  case 0x09:                                                  case 0x0D:                                                      par += Mnemonic.adAB[MN];                                                      break;                                                  case 0x02:                                                  case 0x06:                                                  case 0x0A:                                                  case 0x0E:                                                      par += Mnemonic.adAW[MN];                                                      break;                                                  case 0x03:                                                  case 0x07:                                                  case 0x0B:                                                  case 0x0F:                                                      par += Mnemonic.adAD[MN];                                                      break;                                              }
Missing Default,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7toAWL.cs,GetAWL,The following switch statement is missing a default case: switch (LowByte)                                              {                                                  case 0x01:                                                  case 0x05:                                                  case 0x09:                                                  case 0x0D:                                                      par += Mnemonic.adMB[MN];                                                      break;                                                  case 0x02:                                                  case 0x06:                                                  case 0x0A:                                                  case 0x0E:                                                      par += Mnemonic.adMW[MN];                                                      break;                                                  case 0x03:                                                  case 0x07:                                                  case 0x0B:                                                  case 0x0F:                                                      par += Mnemonic.adMD[MN];                                                      break;                                              }
Missing Default,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7toAWL.cs,GetAWL,The following switch statement is missing a default case: switch (LowByte)                                              {                                                  case 0x01:                                                  case 0x05:                                                  case 0x09:                                                  case 0x0D:                                                      par += Mnemonic.adDBB[MN];                                                      break;                                                  case 0x02:                                                  case 0x06:                                                  case 0x0A:                                                  case 0x0E:                                                      par += Mnemonic.adDBW[MN];                                                      break;                                                  case 0x03:                                                  case 0x07:                                                  case 0x0B:                                                  case 0x0F:                                                      par += Mnemonic.adDBD[MN];                                                      break;                                              }
Missing Default,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7toAWL.cs,GetAWL,The following switch statement is missing a default case: switch (LowByte)                                              {                                                  case 0x01:                                                  case 0x05:                                                  case 0x09:                                                  case 0x0D:                                                      par += Mnemonic.adDIB[MN];                                                      break;                                                  case 0x02:                                                  case 0x06:                                                  case 0x0A:                                                  case 0x0E:                                                      par += Mnemonic.adDIW[MN];                                                      break;                                                  case 0x03:                                                  case 0x07:                                                  case 0x0B:                                                  case 0x0F:                                                      par += Mnemonic.adDID[MN];                                                      break;                                              }
Missing Default,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7toAWL.cs,GetAWL,The following switch statement is missing a default case: switch (LowByte)                                              {                                                  case 0x01:                                                  case 0x05:                                                  case 0x09:                                                  case 0x0D:                                                      par += Mnemonic.adLB[MN];                                                      break;                                                  case 0x02:                                                  case 0x06:                                                  case 0x0A:                                                  case 0x0E:                                                      par += Mnemonic.adLW[MN];                                                      break;                                                  case 0x03:                                                  case 0x07:                                                  case 0x0B:                                                  case 0x0F:                                                      par += Mnemonic.adLD[MN];                                                      break;                                              }
Missing Default,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7toAWL.cs,GetAWL,The following switch statement is missing a default case: switch (BD[pos])                                      {                                          case 0xBA:                                              cmd = cmd + Mnemonic.opUO[MN];                                              break;                                          case 0xBB:                                              cmd = cmd + Mnemonic.opOO[MN];                                              break;                                      }
Missing Default,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7toAWL.cs,GetAWL,The following switch statement is missing a default case: switch (BD[pos])                                      {                                          case 0xBA:                                              switch (LowByte)                                              {                                                  case 0x00:                                                      par += HighByte < 0x80 ? Mnemonic.adPEB[MN] : Mnemonic.adPAB[MN];                                                      break;                                                  case 0x01:                                                      par += Mnemonic.adEB[MN];                                                      break;                                                  case 0x02:                                                      par += Mnemonic.adAB[MN];                                                      break;                                                  case 0x03:                                                      par += Mnemonic.adMB[MN];                                                      break;                                                  case 0x04:                                                      par += Mnemonic.adDBB[MN];                                                      break;                                                  case 0x05:                                                      par += Mnemonic.adDIB[MN];                                                      break;                                                  case 0x06:                                                      par += Mnemonic.adLB[MN];                                                      break;                                              }                                              break;                                          case 0xBB:                                              switch (LowByte)                                              {                                                  case 0x00:                                                      par += HighByte < 0x80 ? Mnemonic.adPEW[MN] : Mnemonic.adPAW[MN];                                                      break;                                                  case 0x01:                                                      par += Mnemonic.adEW[MN];                                                      break;                                                  case 0x02:                                                      par += Mnemonic.adAW[MN];                                                      break;                                                  case 0x03:                                                      par += Mnemonic.adMW[MN];                                                      break;                                                  case 0x04:                                                      par += Mnemonic.adDBW[MN];                                                      break;                                                  case 0x05:                                                      par += Mnemonic.adDIW[MN];                                                      break;                                                  case 0x06:                                                      par += Mnemonic.adLW[MN];                                                      break;                                                  case 0x08:                                                      par += HighByte < 0x80 ? Mnemonic.adPED[MN] : Mnemonic.adPAD[MN];                                                      break;                                                  case 0x09:                                                      par += Mnemonic.adED[MN];                                                      break;                                                  case 0x0A:                                                      par += Mnemonic.adAD[MN];                                                      break;                                                  case 0x0B:                                                      par += Mnemonic.adMD[MN];                                                      break;                                                  case 0x0C:                                                      par += Mnemonic.adDBD[MN];                                                      break;                                                  case 0x0D:                                                      par += Mnemonic.adDID[MN];                                                      break;                                                  case 0x0E:                                                      par += Mnemonic.adLD[MN];                                                      break;                                              }                                              break;                                      }
Missing Default,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7toAWL.cs,GetAWL,The following switch statement is missing a default case: switch (LowByte)                                              {                                                  case 0x00:                                                      par += HighByte < 0x80 ? Mnemonic.adPEB[MN] : Mnemonic.adPAB[MN];                                                      break;                                                  case 0x01:                                                      par += Mnemonic.adEB[MN];                                                      break;                                                  case 0x02:                                                      par += Mnemonic.adAB[MN];                                                      break;                                                  case 0x03:                                                      par += Mnemonic.adMB[MN];                                                      break;                                                  case 0x04:                                                      par += Mnemonic.adDBB[MN];                                                      break;                                                  case 0x05:                                                      par += Mnemonic.adDIB[MN];                                                      break;                                                  case 0x06:                                                      par += Mnemonic.adLB[MN];                                                      break;                                              }
Missing Default,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7toAWL.cs,GetAWL,The following switch statement is missing a default case: switch (LowByte)                                              {                                                  case 0x00:                                                      par += HighByte < 0x80 ? Mnemonic.adPEW[MN] : Mnemonic.adPAW[MN];                                                      break;                                                  case 0x01:                                                      par += Mnemonic.adEW[MN];                                                      break;                                                  case 0x02:                                                      par += Mnemonic.adAW[MN];                                                      break;                                                  case 0x03:                                                      par += Mnemonic.adMW[MN];                                                      break;                                                  case 0x04:                                                      par += Mnemonic.adDBW[MN];                                                      break;                                                  case 0x05:                                                      par += Mnemonic.adDIW[MN];                                                      break;                                                  case 0x06:                                                      par += Mnemonic.adLW[MN];                                                      break;                                                  case 0x08:                                                      par += HighByte < 0x80 ? Mnemonic.adPED[MN] : Mnemonic.adPAD[MN];                                                      break;                                                  case 0x09:                                                      par += Mnemonic.adED[MN];                                                      break;                                                  case 0x0A:                                                      par += Mnemonic.adAD[MN];                                                      break;                                                  case 0x0B:                                                      par += Mnemonic.adMD[MN];                                                      break;                                                  case 0x0C:                                                      par += Mnemonic.adDBD[MN];                                                      break;                                                  case 0x0D:                                                      par += Mnemonic.adDID[MN];                                                      break;                                                  case 0x0E:                                                      par += Mnemonic.adLD[MN];                                                      break;                                              }
Missing Default,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7toAWL.cs,GetAWL,The following switch statement is missing a default case: switch (HighByte)                                      {                                          case 0x00: //Not from old programm' guessed Values!                                          case 0x80:                                              par += "[" + Mnemonic.adPED[MN] +                                                     Convert.ToString(libnodave.getU16from(BD' pos + 2)) +                                                     "]";                                              break;                                          case 0x10://Not from old programm' guessed Values!                                          case 0x90:                                              par += "[" + Mnemonic.adED[MN] +                                                     Convert.ToString(libnodave.getU16from(BD' pos + 2)) +                                                     "]";                                              break;                                          case 0x20://Not from old programm' guessed Values!                                          case 0xa0:                                              par += "[" + Mnemonic.adAD[MN] +                                                     Convert.ToString(libnodave.getU16from(BD' pos + 2)) +                                                     "]";                                              break;                                          case 0x30:                                          case 0xb0:                                              par += "[" + Mnemonic.adMD[MN] +                                                     Convert.ToString(libnodave.getU16from(BD' pos + 2)) +                                                     "]";                                              break;                                          case 0x40:                                          case 0xc0:                                              par += "[" + Mnemonic.adDBD[MN] +                                                     Convert.ToString(libnodave.getU16from(BD' pos + 2)) +                                                     "]";                                              break;                                          case 0x50:                                          case 0xd0:                                              par += "[" + Mnemonic.adDID[MN] +                                                     Convert.ToString(libnodave.getU16from(BD' pos + 2)) +                                                     "]";                                              break;                                          case 0x60:                                          case 0xe0:                                              par += "[" + Mnemonic.adLD[MN] +                                                     Convert.ToString(libnodave.getU16from(BD' pos + 2)) +                                                     "]";                                              break;                                      }
Missing Default,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7toAWL.cs,GetAWL,The following switch statement is missing a default case: switch (LowByte)                                      {                                          case 0x00:                                              cmd += Mnemonic.opU[MN];                                              break;                                          case 0x01:                                              cmd += Mnemonic.opUN[MN];                                              break;                                          case 0x02:                                              cmd += Mnemonic.opO[MN];                                              break;                                          case 0x03:                                              cmd += Mnemonic.opON[MN];                                              break;                                          case 0x04:                                              cmd += Mnemonic.opX[MN];                                              break;                                          case 0x05:                                              cmd += Mnemonic.opXN[MN];                                              break;                                          case 0x06:                                              cmd += Mnemonic.opL[MN];                                              break;                                          case 0x08:                                              cmd += Mnemonic.opFR[MN];                                              break;                                          case 0x09:                                              cmd += Mnemonic.opLC[MN];                                              break;                                          case 0x0A:                                              cmd += HighByte < 0x80 ? Mnemonic.opSA[MN] : Mnemonic.opZR[MN];                                              break;                                          case 0x0B:                                              cmd += HighByte < 0x80 ? Mnemonic.opSV[MN] : Mnemonic.opS[MN];                                              break;                                          case 0x0C:                                              cmd += Mnemonic.opSE[MN];                                              break;                                          case 0x0D:                                              cmd += HighByte < 0x80 ? Mnemonic.opSS[MN] : Mnemonic.opZV[MN];                                              break;                                          case 0x0E:                                              cmd += Mnemonic.opSI[MN];                                              break;                                          case 0x0F:                                              cmd += Mnemonic.opR[MN];                                              break;                                      }
Missing Default,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7toAWL.cs,GetAWL,The following switch statement is missing a default case: switch (HighByte)                                      {                                          case 0x00://Guessed Value' not from old PRG                                          case 0x80:                                              par += "[" + Mnemonic.adPEW[MN] +                                                       Convert.ToString(libnodave.getU16from(BD' pos + 2)) + "]";                                              break;                                          case 0x10://Guessed Value' not from old PRG                                          case 0x90:                                              par += "[" + Mnemonic.adEW[MN] +                                                       Convert.ToString(libnodave.getU16from(BD' pos + 2)) + "]";                                              break;                                          case 0x20://Guessed Value' not from old Prg                                          case 0xa0:                                              par += "[" + Mnemonic.adAW[MN] +                                                       Convert.ToString(libnodave.getU16from(BD' pos + 2)) + "]";                                              break;                                          case 0x30:                                          case 0xb0:                                              par += "[" + Mnemonic.adMW[MN] +                                                       Convert.ToString(libnodave.getU16from(BD' pos + 2)) + "]";                                              break;                                          case 0x40:                                          case 0xc0:                                              par += "[" + Mnemonic.adDBW[MN] +                                                       Convert.ToString(libnodave.getU16from(BD' pos + 2)) + "]";                                              break;                                          case 0x50:                                          case 0xd0:                                              par += "[" + Mnemonic.adDIW[MN] +                                                       Convert.ToString(libnodave.getU16from(BD' pos + 2)) + "]";                                              break;                                          case 0x60:                                          case 0xe0:                                              par += "[" + Mnemonic.adLW[MN] +                                                       Convert.ToString(libnodave.getU16from(BD' pos + 2)) + "]";                                              break;                                      }
Missing Default,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7toAWL.cs,GetAWL,The following switch statement is missing a default case: switch (BD[pos + 1] & 0xf0)                                              {                                                  case 0x30:                                                      par = Mnemonic.adMW[MN];                                                      break;                                                  case 0x40:                                                      par = Mnemonic.adDBW[MN];                                                      break;                                                  case 0x50:                                                      par = Mnemonic.adDIW[MN];                                                      break;                                                  case 0x60:                                                      par = Mnemonic.adLW[MN];                                                      break;                                              }
Missing Default,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7toAWL.cs,GetAWL,The following switch statement is missing a default case: switch (BD[pos + 1] & 0xf0)                                              {                                                  case 0x30:                                                      par = Mnemonic.adMW[MN];                                                      break;                                                  case 0x40:                                                      par = Mnemonic.adDBW[MN];                                                      break;                                                  case 0x60:                                                      par = Mnemonic.adLW[MN];                                                      break;                                                  case 0x50:                                                      par = Mnemonic.adDIW[MN];                                                      break;                                              }
Missing Default,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7toAWL.cs,GetAWL,The following switch statement is missing a default case: switch (BD[pos + 1])                                              {                                                  case 0x61:                                                      par = Mnemonic.adLW[MN];                                                      break;                                                  case 0x41:                                                      par = Mnemonic.adDBW[MN];                                                      break;                                                  case 0x51:                                                      par = Mnemonic.adDIW[MN];                                                      break;                                              }
Missing Default,DotNetSiemensPLCToolBoxLibrary.PLCs.S7_xxx.MC7,MC7toAWL,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\PLCs\S7_xxx\MC7\MC7toAWL.cs,GetAWL,The following switch statement is missing a default case: switch (BD[pos + 1] & 0xf0)                                              {                                                  case 0x60:                                                      par = Mnemonic.adLW[MN];                                                      break;                                                  case 0x40:                                                      par = Mnemonic.adDBW[MN];                                                      break;                                                  case 0x50:                                                      par = Mnemonic.adDIW[MN];                                                      break;                                              }
Missing Default,DotNetSiemensPLCToolBoxLibrary.Projectfiles,Step7ProjectV5,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Projectfiles\Step7ProjectV5.cs,LoadProject,The following switch statement is missing a default case: switch ((int)row["OBJTYP"])                              {                                  case objectType_Simatic300:                                      x.StationType = PLCType.Simatic300;                                      break;                                  case objectType_Simatic400:                                      x.StationType = PLCType.Simatic400;                                      break;                                  case objectType_Simatic400H:                                      x.StationType = PLCType.Simatic400H;                                      break;                              }
Missing Default,DotNetSiemensPLCToolBoxLibrary.Source,AWLSourceParser,D:\research\architectureSmells\repos\jogibear9988_DotNetSiemensPLCToolBoxLibrary\LibNoDaveConnectionLibrary\Source\AWLSourceParser.cs,CreateBlock,The following switch statement is missing a default case: switch (blockType.ToUpper())              {                  case ("TYPE"):                      {                          akBlock = new S7DataBlock() { BlockType = DataTypes.PLCBlockType.UDT' BlockLanguage = PLCLanguage.DB };                                              }                      break;                  case ("DATA_BLOCK"):                      {                          akBlock = new S7DataBlock() { BlockType = DataTypes.PLCBlockType.DB' BlockLanguage = PLCLanguage.DB };                                              }                      break;                  case ("FUNCTION"):                      {                          akBlock = new S7FunctionBlock() { BlockType = DataTypes.PLCBlockType.FC' BlockLanguage = PLCLanguage.AWL };                            S7DataRow parameterRoot = new S7DataRow("ROOTNODE"' S7DataRowType.STRUCT' akBlock);                          S7DataRow parameterIN = new S7DataRow("IN"' S7DataRowType.STRUCT' akBlock);                          S7DataRow parameterOUT = new S7DataRow("OUT"' S7DataRowType.STRUCT' akBlock);                          S7DataRow parameterINOUT = new S7DataRow("IN_OUT"' S7DataRowType.STRUCT' akBlock);                          S7DataRow parameterSTAT = new S7DataRow("STATIC"' S7DataRowType.STRUCT' akBlock);                          S7DataRow parameterTEMP = new S7DataRow("TEMP"' S7DataRowType.STRUCT' akBlock);                            parameterOUT.Add(new S7DataRow("RET_VAL"' (S7DataRowType)Enum.Parse(typeof(S7DataRowType)' type)' akBlock));                            parameterRoot.Children.Add(parameterIN);                          parameterRoot.Children.Add(parameterOUT);                          parameterRoot.Children.Add(parameterINOUT);                          parameterRoot.Children.Add(parameterSTAT);                          parameterRoot.Children.Add(parameterTEMP);                                              }                      break;                  case ("FUNCTION_BLOCK"):                      {                          akBlock = new S7FunctionBlock() { BlockType = DataTypes.PLCBlockType.FB' BlockLanguage = PLCLanguage.AWL };                            S7DataRow parameterRoot = new S7DataRow("ROOTNODE"' S7DataRowType.STRUCT' akBlock);                          S7DataRow parameterIN = new S7DataRow("IN"' S7DataRowType.STRUCT' akBlock);                          S7DataRow parameterOUT = new S7DataRow("OUT"' S7DataRowType.STRUCT' akBlock);                          S7DataRow parameterINOUT = new S7DataRow("IN_OUT"' S7DataRowType.STRUCT' akBlock);                          S7DataRow parameterTEMP = new S7DataRow("TEMP"' S7DataRowType.STRUCT' akBlock);                            parameterRoot.Children.Add(parameterIN);                          parameterRoot.Children.Add(parameterOUT);                          parameterRoot.Children.Add(parameterINOUT);                          parameterRoot.Children.Add(parameterTEMP);                      }                      break;              }
