Implementation smell,Namespace,Class,File,Method,Description
Complex Method,Castle.IO,PathInfo,F:\newReposMay17\castleproject_Castle.Transactions\src\Castle.IO\PathInfo.cs,IsParentOf,Cyclomatic complexity of the method is 18
Complex Method,Castle.IO.FileSystems.InMemory,InMemoryFile,F:\newReposMay17\castleproject_Castle.Transactions\src\Castle.IO\FileSystems\InMemory\InMemoryFile.cs,ValidateFileMode,Cyclomatic complexity of the method is 16
Complex Method,Castle.IO.Internal,LongPathCommon,F:\newReposMay17\castleproject_Castle.Transactions\src\Castle.IO\Internal\LongPathCommon.cs,GetExceptionFromWin32Error,Cyclomatic complexity of the method is 8
Complex Method,Castle.IO.Internal,LongPathDirectory,F:\newReposMay17\castleproject_Castle.Transactions\src\Castle.IO\Internal\LongPathDirectory.cs,EnumerateFileSystemIterator,Cyclomatic complexity of the method is 9
Long Parameter List,Castle.IO,IDirectory,F:\newReposMay17\castleproject_Castle.Transactions\src\Castle.IO\IDirectory.cs,FileChanges,The method has 6 parameters.
Long Parameter List,Castle.IO,PathInfo,F:\newReposMay17\castleproject_Castle.Transactions\src\Castle.IO\PathInfo.cs,PathInfo,The method has 16 parameters.
Long Parameter List,Castle.IO.Contracts,IDirectoryContract,F:\newReposMay17\castleproject_Castle.Transactions\src\Castle.IO\Contracts\IDirectoryContract.cs,FileChanges,The method has 6 parameters.
Long Parameter List,Castle.IO.FileSystems,FileSystemNotifier,F:\newReposMay17\castleproject_Castle.Transactions\src\Castle.IO\FileSystems\FileSystemNotifier.cs,RegisterNotification,The method has 7 parameters.
Long Parameter List,Castle.IO.FileSystems,IFileSystemNotifier,F:\newReposMay17\castleproject_Castle.Transactions\src\Castle.IO\FileSystems\IFileSystemNotifier.cs,RegisterNotification,The method has 7 parameters.
Long Parameter List,Castle.IO.FileSystems.InMemory,InMemoryDirectory,F:\newReposMay17\castleproject_Castle.Transactions\src\Castle.IO\FileSystems\InMemory\InMemoryDirectory.cs,FileChanges,The method has 6 parameters.
Long Parameter List,Castle.IO.FileSystems.Local,LocalDirectory,F:\newReposMay17\castleproject_Castle.Transactions\src\Castle.IO\FileSystems\Local\LocalDirectory.cs,FileChanges,The method has 6 parameters.
Long Parameter List,Castle.IO.FileSystems.Local,TemporaryDirectory,F:\newReposMay17\castleproject_Castle.Transactions\src\Castle.IO\FileSystems\Local\TemporaryDirectory.cs,FileChanges,The method has 6 parameters.
Long Parameter List,Castle.IO.FileSystems.Local.Win32.Interop,JunctionPoint,F:\newReposMay17\castleproject_Castle.Transactions\src\Castle.IO\FileSystems\Local\Win32\Interop\JunctionPoint.cs,DeviceIoControl,The method has 8 parameters.
Long Parameter List,Castle.IO.FileSystems.Local.Win32.Interop,JunctionPoint,F:\newReposMay17\castleproject_Castle.Transactions\src\Castle.IO\FileSystems\Local\Win32\Interop\JunctionPoint.cs,CreateFile,The method has 7 parameters.
Long Parameter List,Castle.IO.FileSystems.Local.Win32.Interop,NativeMethods,F:\newReposMay17\castleproject_Castle.Transactions\src\Castle.IO\FileSystems\Local\Win32\Interop\NativeMethods.cs,CreateFile,The method has 7 parameters.
Long Parameter List,Castle.IO.FileSystems.Local.Win32.Interop,NativeMethods,F:\newReposMay17\castleproject_Castle.Transactions\src\Castle.IO\FileSystems\Local\Win32\Interop\NativeMethods.cs,FormatMessage,The method has 7 parameters.
Long Parameter List,Castle.IO.Internal,LongPathFile,F:\newReposMay17\castleproject_Castle.Transactions\src\Castle.IO\Internal\LongPathFile.cs,Open,The method has 6 parameters.
Long Parameter List,Castle.IO.Internal,LongPathFile,F:\newReposMay17\castleproject_Castle.Transactions\src\Castle.IO\Internal\LongPathFile.cs,GetFileHandle,The method has 5 parameters.
Long Identifier,Castle.IO.Internal,LongPathDirectory,F:\newReposMay17\castleproject_Castle.Transactions\src\Castle.IO\Internal\LongPathDirectory.cs,BeginFind,The length of the parameter normalizedPathWithSearchPattern is 31.
Long Statement,Castle.IO,DirectoryExtensions,F:\newReposMay17\castleproject_Castle.Transactions\src\Castle.IO\DirectoryExtensions.cs,GetOrCreateDirectory,The length of the statement  "	return childDirectories.Aggregate (directory' (current' childDirectoryName) => current.GetDirectory (childDirectoryName).MustExist ()); " is 135.
Long Statement,Castle.IO,DirectoryExtensions,F:\newReposMay17\castleproject_Castle.Transactions\src\Castle.IO\DirectoryExtensions.cs,GetFileSpecCore,The length of the statement  "		return isNextToLastSegment ? directory.Files (segments [position + 1]' SearchScope.SubFolders) : directory.Directories (segments [position + 1]' SearchScope.SubFolders).SelectMany (x => GetFileSpecCore (x' segments' position + 2)); " is 231.
Long Statement,Castle.IO,DirectoryExtensions,F:\newReposMay17\castleproject_Castle.Transactions\src\Castle.IO\DirectoryExtensions.cs,GetFileSpecCore,The length of the statement  "	return directory.Directories (segment' SearchScope.CurrentOnly).SelectMany (x => GetFileSpecCore (x' segments' position + 1)); " is 126.
Long Statement,Castle.IO,DirectoryExtensions,F:\newReposMay17\castleproject_Castle.Transactions\src\Castle.IO\DirectoryExtensions.cs,GetDirectorySpecCore,The length of the statement  "		return isNextToLastSegment ? directory.Directories (segments [position + 1]' SearchScope.SubFolders) : directory.Directories (segments [position + 1]' SearchScope.SubFolders).SelectMany (x => GetDirectorySpecCore (x' segments' position + 2)); " is 242.
Long Statement,Castle.IO,DirectoryExtensions,F:\newReposMay17\castleproject_Castle.Transactions\src\Castle.IO\DirectoryExtensions.cs,GetDirectorySpecCore,The length of the statement  "	return directory.Directories (segment' SearchScope.CurrentOnly).SelectMany (x => GetDirectorySpecCore (x' segments' position + 1)); " is 131.
Long Statement,Castle.IO,Path,F:\newReposMay17\castleproject_Castle.Transactions\src\Castle.IO\Path Statics.cs,NormDirSepChars,The length of the statement  "	Contract.Assume (!string.IsNullOrEmpty (ret)' "because input was non-empty string and for every item in the string " + "we append to the string builder a non-whitespace char' so it can't be empty"); " is 198.
Long Statement,Castle.IO,PathExtensions,F:\newReposMay17\castleproject_Castle.Transactions\src\Castle.IO\PathExtensions.cs,AllowedToAccess,The length of the statement  "	if (!String.IsNullOrEmpty (chjailedRootPath.Info.DriveLetter) && other.Info.DriveLetter != chjailedRootPath.Info.DriveLetter) " is 125.
Long Statement,Castle.IO,PathInfo,F:\newReposMay17\castleproject_Castle.Transactions\src\Castle.IO\PathInfo.cs,Parse,The length of the statement  "	return new PathInfo (m ("root")' m ("UNC_prefix")' m ("UNC_literal")' m ("drive")' m ("drive_letter")' m ("server")' m ("ipv4")' m ("ipv6")' m ("server_name")' m ("device")' m ("dev_prefix")' m ("dev_name")' m ("dev_guid")' m ("nonrootpath")' m ("rel_drive")' m ("folders_files")); " is 281.
Long Statement,Castle.IO,PathInfo,F:\newReposMay17\castleproject_Castle.Transactions\src\Castle.IO\PathInfo.cs,RemoveParameterFromRoot,The length of the statement  "	Contract.Requires (FolderAndFiles.Length >= other.FolderAndFiles.Length' "The folders and files part of the parameter must be shorter or equal to in length' than that path you wish to subtract from."); " is 201.
Long Statement,Castle.IO,PathInfo,F:\newReposMay17\castleproject_Castle.Transactions\src\Castle.IO\PathInfo.cs,Equals,The length of the statement  "	return Equals (other.drive' drive) && Equals (other.driveLetter' driveLetter) && Equals (other.server' server) && Equals (other.iPv4' iPv4) && Equals (other.iPv6' iPv6) && Equals (other.serverName' serverName) && Equals (other.device' device) && Equals (other.devicePrefix' devicePrefix) && Equals (other.deviceName' deviceName) && Equals (other.deviceGuid' deviceGuid) && Equals (other.nonRootPath' nonRootPath) && Equals (other.relDrive' relDrive) && Equals (other.folderAndFiles' folderAndFiles); " is 499.
Long Statement,Castle.IO.FileSystems,AbstractDirectory,F:\newReposMay17\castleproject_Castle.Transactions\src\Castle.IO\FileSystems\AbstractDirectory.cs,NormalizeDirectoryPath,The length of the statement  "	if (!directoryPath.EndsWith (Path.DirectorySeparatorChar.ToString ()) && !directoryPath.EndsWith (Path.AltDirectorySeparatorChar.ToString ())) " is 142.
Long Statement,Castle.IO.FileSystems,Validate,F:\newReposMay17\castleproject_Castle.Transactions\src\Castle.IO\FileSystems\Validate.cs,FileAccess,The length of the statement  "		throw new ArgumentException (string.Format ("Can only open files in {0} mode when requesting FileAccess.Write access."' fileMode)); " is 131.
Long Statement,Castle.IO.FileSystems,FileSystemNotificationIdentifier,F:\newReposMay17\castleproject_Castle.Transactions\src\Castle.IO\FileSystems\FileSystemNotificationIdentifier.cs,Equals,The length of the statement  "	return other.IncludeSubDirectories.Equals (IncludeSubDirectories) && Equals (other.Path' Path) && Equals (other.Filter' Filter) && Equals (other.ChangeTypes' ChangeTypes); " is 171.
Long Statement,Castle.IO.FileSystems,FileSystemNotifier,F:\newReposMay17\castleproject_Castle.Transactions\src\Castle.IO\FileSystems\FileSystemNotifier.cs,RegisterNotification,The length of the statement  "	var id = new FileSystemNotificationIdentifier (path ?? new Path (Environment.CurrentDirectory)' watcher' filter ?? "*"' includeSubdirectories); " is 143.
Long Statement,Castle.IO.FileSystems.InMemory,InMemoryDirectory,F:\newReposMay17\castleproject_Castle.Transactions\src\Castle.IO\FileSystems\InMemory\InMemoryDirectory.cs,FileChanges,The length of the statement  "	return _fileSystem.Notifier.RegisterNotification (Path' filter' includeSubdirectories' created' modified' deleted' renamed); " is 124.
Long Statement,Castle.IO.FileSystems.InMemory,InMemoryDirectory,F:\newReposMay17\castleproject_Castle.Transactions\src\Castle.IO\FileSystems\InMemory\InMemoryDirectory.cs,Directories,The length of the statement  "		return scope == SearchScope.CurrentOnly ? immediateChildren.ToList () : immediateChildren.Concat (ChildDirectories.SelectMany (x => x.Directories (filter' scope))).ToList (); " is 174.
Long Statement,Castle.IO.FileSystems.InMemory,InMemoryDirectory,F:\newReposMay17\castleproject_Castle.Transactions\src\Castle.IO\FileSystems\InMemory\InMemoryDirectory.cs,Files,The length of the statement  "			return searchScope == SearchScope.CurrentOnly ? immediateChildren.ToList () : immediateChildren.Concat (ChildDirectories.SelectMany (x => x.Files (filter' searchScope))).ToList (); " is 180.
Long Statement,Castle.IO.FileSystems.InMemory,InMemoryFile,F:\newReposMay17\castleproject_Castle.Transactions\src\Castle.IO\FileSystems\InMemory\InMemoryFile.cs,ValidateFileLock,The length of the statement  "	if ((fileAccess == FileAccess.Read && !readAllowed) || (fileAccess == FileAccess.ReadWrite && !(readAllowed && writeAllowed)) || (fileAccess == FileAccess.Write && !writeAllowed)) " is 179.
Long Statement,Castle.IO.FileSystems.InMemory,InMemoryFileSystem,F:\newReposMay17\castleproject_Castle.Transactions\src\Castle.IO\FileSystems\InMemory\InMemoryFileSystem.cs,GetDirectory,The length of the statement  "	return segments.Skip (1).Aggregate ((IDirectory)GetRoot (segments.First ())' (current' segment) => current.GetDirectory (segment)); " is 131.
Long Statement,Castle.IO.FileSystems.InMemory,InMemoryFileSystem,F:\newReposMay17\castleproject_Castle.Transactions\src\Castle.IO\FileSystems\InMemory\InMemoryFileSystem.cs,EnsureTerminatedByDirectorySeparator,The length of the statement  "	return possibleDirectoryPath.IsDirectoryPath ? possibleDirectoryPath : new Path (possibleDirectoryPath.FullPath + Path.DirectorySeparatorChar); " is 143.
Long Statement,Castle.IO.FileSystems.InMemory,InMemoryFileSystem,F:\newReposMay17\castleproject_Castle.Transactions\src\Castle.IO\FileSystems\InMemory\InMemoryFileSystem.cs,GetFile,The length of the statement  "	var ownerFolder = pathSegments.Skip (1).Take (pathSegments.Count () - 2).Aggregate ((IDirectory)GetRoot (pathSegments.First ())' (current' segment) => current.GetDirectory (segment)); " is 183.
Long Statement,Castle.IO.FileSystems.InMemory,InMemoryFileSystemNotifier,F:\newReposMay17\castleproject_Castle.Transactions\src\Castle.IO\FileSystems\InMemory\InMemoryFileSystemNotifier.cs,NotifyCreation,The length of the statement  "			where value != null && (key.ChangeTypes & WatcherChangeTypes.Created) == WatcherChangeTypes.Created && PathMatches (key' file) && key.Filter.Wildcard ().IsMatch (file.Name) " is 172.
Long Statement,Castle.IO.FileSystems.InMemory,InMemoryFileSystemNotifier,F:\newReposMay17\castleproject_Castle.Transactions\src\Castle.IO\FileSystems\InMemory\InMemoryFileSystemNotifier.cs,PathMatches,The length of the statement  "	return key.IncludeSubDirectories ? file.Parent.Path.FullPath.StartsWith (key.Path.FullPath' StringComparison.OrdinalIgnoreCase) : file.Parent.Path == key.Path; " is 159.
Long Statement,Castle.IO.FileSystems.Local,LocalDirectory,F:\newReposMay17\castleproject_Castle.Transactions\src\Castle.IO\FileSystems\Local\LocalDirectory.cs,FileChanges,The length of the statement  "	return LocalFileSystemNotifier.Instance.RegisterNotification (Path' filter' includeSubdirectories' created' modified' deleted' renamed); " is 136.
Long Statement,Castle.IO.FileSystems.Local,LocalDirectory,F:\newReposMay17\castleproject_Castle.Transactions\src\Castle.IO\FileSystems\Local\LocalDirectory.cs,Directories,The length of the statement  "	return DirectoryInfo.GetDirectories (filter' scope == SearchScope.CurrentOnly ? SearchOption.TopDirectoryOnly : SearchOption.AllDirectories).Select (x => (IDirectory)CreateDirectory (x)); " is 187.
Long Statement,Castle.IO.FileSystems.Local,LocalDirectory,F:\newReposMay17\castleproject_Castle.Transactions\src\Castle.IO\FileSystems\Local\LocalDirectory.cs,Files,The length of the statement  "	return DirectoryInfo.GetFiles (filter' scope == SearchScope.CurrentOnly ? SearchOption.TopDirectoryOnly : SearchOption.AllDirectories).Select (x => new LocalFile (x.FullName' CreateDirectory)).Cast<IFile> (); " is 208.
Long Statement,Castle.IO.FileSystems.Local,LocalFileSystem,F:\newReposMay17\castleproject_Castle.Transactions\src\Castle.IO\FileSystems\Local\LocalFileSystem.cs,GetFile,The length of the statement  "	return new LocalFile (Path.GetFullPath (System.IO.Path.Combine (Environment.CurrentDirectory' filePath))' CreateDirectory); " is 123.
Long Statement,Castle.IO.FileSystems.Local.Win32.Interop,JunctionPoint,F:\newReposMay17\castleproject_Castle.Transactions\src\Castle.IO\FileSystems\Local\Win32\Interop\JunctionPoint.cs,Create,The length of the statement  "			var result = DeviceIoControl (handle.DangerousGetHandle ()' FSCTL_SET_REPARSE_POINT' inBuffer' targetDirBytes.Length + 20' IntPtr.Zero' 0' out bytesReturned' IntPtr.Zero); " is 171.
Long Statement,Castle.IO.FileSystems.Local.Win32.Interop,JunctionPoint,F:\newReposMay17\castleproject_Castle.Transactions\src\Castle.IO\FileSystems\Local\Win32\Interop\JunctionPoint.cs,Delete,The length of the statement  "			var result = DeviceIoControl (handle.DangerousGetHandle ()' FSCTL_DELETE_REPARSE_POINT' inBuffer' 8' IntPtr.Zero' 0' out bytesReturned' IntPtr.Zero); " is 149.
Long Statement,Castle.IO.FileSystems.Local.Win32.Interop,JunctionPoint,F:\newReposMay17\castleproject_Castle.Transactions\src\Castle.IO\FileSystems\Local\Win32\Interop\JunctionPoint.cs,InternalGetTarget,The length of the statement  "		var result = DeviceIoControl (handle.DangerousGetHandle ()' FSCTL_GET_REPARSE_POINT' IntPtr.Zero' 0' outBuffer' outBufferSize' out bytesReturned' IntPtr.Zero); " is 159.
Long Statement,Castle.IO.FileSystems.Local.Win32.Interop,JunctionPoint,F:\newReposMay17\castleproject_Castle.Transactions\src\Castle.IO\FileSystems\Local\Win32\Interop\JunctionPoint.cs,InternalGetTarget,The length of the statement  "		var targetDir = Encoding.Unicode.GetString (reparseDataBuffer.PathBuffer' reparseDataBuffer.SubstituteNameOffset' reparseDataBuffer.SubstituteNameLength); " is 154.
Long Statement,Castle.IO.FileSystems.Local.Win32.Interop,JunctionPoint,F:\newReposMay17\castleproject_Castle.Transactions\src\Castle.IO\FileSystems\Local\Win32\Interop\JunctionPoint.cs,OpenReparsePoint,The length of the statement  "	var reparsePointHandle = new SafeFileHandle (CreateFile (reparsePoint' accessMode' EFileShare.Read | EFileShare.Write | EFileShare.Delete' IntPtr.Zero' ECreationDisposition.OpenExisting' EFileAttributes.BackupSemantics | EFileAttributes.OpenReparsePoint' IntPtr.Zero)' true); " is 275.
Long Statement,Castle.IO.Internal,Directory,F:\newReposMay17\castleproject_Castle.Transactions\src\Castle.IO\Internal\Directory.cs,InitializeWith,The length of the statement  "		throw new InvalidOperationException ("This method cannot be called twice without resetting the class with Directory.Reset()."); " is 127.
Long Statement,Castle.IO.Internal,Directory,F:\newReposMay17\castleproject_Castle.Transactions\src\Castle.IO\Internal\Directory.cs,GetAdapter,The length of the statement  "		throw new InvalidOperationException ("If you call the Directory API you first need to call Directory.InitializeWith(IDirectoryAdapter)"); " is 137.
Long Statement,Castle.IO.Internal,LongPathCommon,F:\newReposMay17\castleproject_Castle.Transactions\src\Castle.IO\Internal\LongPathCommon.cs,NormalizeLongPath,The length of the statement  "		throw new ArgumentException (String.Format (CultureInfo.CurrentCulture' "'{0}' cannot be an empty string."' parameterName)' parameterName); " is 139.
Long Statement,Castle.IO.Internal,LongPathCommon,F:\newReposMay17\castleproject_Castle.Transactions\src\Castle.IO\Internal\LongPathCommon.cs,GetMessageFromErrorCode,The length of the statement  "	var bufferLength = NativeMethods.FormatMessage (NativeMethods.FORMAT_MESSAGE_IGNORE_INSERTS | NativeMethods.FORMAT_MESSAGE_FROM_SYSTEM | NativeMethods.FORMAT_MESSAGE_ARGUMENT_ARRAY' IntPtr.Zero' errorCode' 0' buffer' buffer.Capacity' IntPtr.Zero); " is 247.
Long Statement,Castle.IO.Internal,LongPathDirectory,F:\newReposMay17\castleproject_Castle.Transactions\src\Castle.IO\Internal\LongPathDirectory.cs,IsCurrentOrParentDirectory,The length of the statement  "	return directoryName.Equals ("."' StringComparison.OrdinalIgnoreCase) || directoryName.Equals (".."' StringComparison.OrdinalIgnoreCase); " is 137.
Long Statement,Castle.IO.Internal,LongPathFile,F:\newReposMay17\castleproject_Castle.Transactions\src\Castle.IO\Internal\LongPathFile.cs,Open,The length of the statement  "	var fileStream = new FileStream (handle' access' bufferSize' (options & FileOptions.Asynchronous) == FileOptions.Asynchronous); " is 127.
Long Statement,Castle.IO.Internal,LongPathFile,F:\newReposMay17\castleproject_Castle.Transactions\src\Castle.IO\Internal\LongPathFile.cs,GetFileHandle,The length of the statement  "	var handle = NativeMethods.CreateFile (normalizedPath' access.ToNative ()' share.ToNative ()' IntPtr.Zero' mode.ToNative ()' options.ToNative ()' IntPtr.Zero); " is 159.
Long Statement,Castle.IO.Internal,MapPathImpl,F:\newReposMay17\castleproject_Castle.Transactions\src\Castle.IO\Internal\MapPathImpl.cs,MapPath,The length of the statement  "		Contract.Assume (!string.IsNullOrEmpty (mapPath)' "This is a user-provided function' and code-contracts don't allow me to reason with the typed for Func in a Requires in c'tor."); " is 179.
Long Statement,Castle.IO.Internal,MapPathImpl,F:\newReposMay17\castleproject_Castle.Transactions\src\Castle.IO\Internal\MapPathImpl.cs,MapPath,The length of the statement  "	return path == string.Empty ? AppDomain.CurrentDomain.BaseDirectory : Path.GetFullPath (AppDomain.CurrentDomain.BaseDirectory.Combine (path)); " is 142.
Complex Conditional,Castle.IO.FileSystems,FileSystemNotifier,F:\newReposMay17\castleproject_Castle.Transactions\src\Castle.IO\FileSystems\FileSystemNotifier.cs,RegisterNotification,The conditional expression  "created == null && modified == null && renamed == null && deleted == null"  is complex.
Complex Conditional,Castle.IO.FileSystems.InMemory,InMemoryFile,F:\newReposMay17\castleproject_Castle.Transactions\src\Castle.IO\FileSystems\InMemory\InMemoryFile.cs,ValidateFileLock,The conditional expression  "(fileAccess == FileAccess.Read && !readAllowed) || (fileAccess == FileAccess.ReadWrite && !(readAllowed && writeAllowed)) || (fileAccess == FileAccess.Write && !writeAllowed)"  is complex.
Empty Catch Block,Castle.IO.Internal,LongPathCommon,F:\newReposMay17\castleproject_Castle.Transactions\src\Castle.IO\Internal\LongPathCommon.cs,TryNormalizeLongPath,The method has an empty catch block.
Empty Catch Block,Castle.IO.Internal,LongPathCommon,F:\newReposMay17\castleproject_Castle.Transactions\src\Castle.IO\Internal\LongPathCommon.cs,TryNormalizeLongPath,The method has an empty catch block.
Magic Number,Castle.IO,DirectoryExtensions,F:\newReposMay17\castleproject_Castle.Transactions\src\Castle.IO\DirectoryExtensions.cs,GetFileSpecCore,The following statement contains a magic number: if (segment == Subfolder) {  	var isNextToLastSegment = position + 1 == segments.Count - 1;  	return isNextToLastSegment ? directory.Files (segments [position + 1]' SearchScope.SubFolders) : directory.Directories (segments [position + 1]' SearchScope.SubFolders).SelectMany (x => GetFileSpecCore (x' segments' position + 2));  }  
Magic Number,Castle.IO,DirectoryExtensions,F:\newReposMay17\castleproject_Castle.Transactions\src\Castle.IO\DirectoryExtensions.cs,GetFileSpecCore,The following statement contains a magic number: return isNextToLastSegment ? directory.Files (segments [position + 1]' SearchScope.SubFolders) : directory.Directories (segments [position + 1]' SearchScope.SubFolders).SelectMany (x => GetFileSpecCore (x' segments' position + 2));  
Magic Number,Castle.IO,DirectoryExtensions,F:\newReposMay17\castleproject_Castle.Transactions\src\Castle.IO\DirectoryExtensions.cs,GetDirectorySpecCore,The following statement contains a magic number: if (segment == Subfolder) {  	var isNextToLastSegment = position + 1 == segments.Count - 1;  	return isNextToLastSegment ? directory.Directories (segments [position + 1]' SearchScope.SubFolders) : directory.Directories (segments [position + 1]' SearchScope.SubFolders).SelectMany (x => GetDirectorySpecCore (x' segments' position + 2));  }  
Magic Number,Castle.IO,DirectoryExtensions,F:\newReposMay17\castleproject_Castle.Transactions\src\Castle.IO\DirectoryExtensions.cs,GetDirectorySpecCore,The following statement contains a magic number: return isNextToLastSegment ? directory.Directories (segments [position + 1]' SearchScope.SubFolders) : directory.Directories (segments [position + 1]' SearchScope.SubFolders).SelectMany (x => GetDirectorySpecCore (x' segments' position + 2));  
Magic Number,Castle.IO,Path,F:\newReposMay17\castleproject_Castle.Transactions\src\Castle.IO\Path Statics.cs,GetPathWithoutLastBit,The following statement contains a magic number: Contract.Requires (path.Length >= 2);  
Magic Number,Castle.IO,PathInfo,F:\newReposMay17\castleproject_Castle.Transactions\src\Castle.IO\PathInfo.cs,GetHashCode,The following statement contains a magic number: unchecked {  	var result = drive.GetHashCode ();  	result = (result * 397) ^ driveLetter.GetHashCode ();  	result = (result * 397) ^ server.GetHashCode ();  	result = (result * 397) ^ iPv4.GetHashCode ();  	result = (result * 397) ^ iPv6.GetHashCode ();  	result = (result * 397) ^ serverName.GetHashCode ();  	result = (result * 397) ^ device.GetHashCode ();  	result = (result * 397) ^ devicePrefix.GetHashCode ();  	result = (result * 397) ^ deviceName.GetHashCode ();  	result = (result * 397) ^ deviceGuid.GetHashCode ();  	result = (result * 397) ^ nonRootPath.GetHashCode ();  	result = (result * 397) ^ relDrive.GetHashCode ();  	result = (result * 397) ^ folderAndFiles.GetHashCode ();  	return result;  }  
Magic Number,Castle.IO,PathInfo,F:\newReposMay17\castleproject_Castle.Transactions\src\Castle.IO\PathInfo.cs,GetHashCode,The following statement contains a magic number: unchecked {  	var result = drive.GetHashCode ();  	result = (result * 397) ^ driveLetter.GetHashCode ();  	result = (result * 397) ^ server.GetHashCode ();  	result = (result * 397) ^ iPv4.GetHashCode ();  	result = (result * 397) ^ iPv6.GetHashCode ();  	result = (result * 397) ^ serverName.GetHashCode ();  	result = (result * 397) ^ device.GetHashCode ();  	result = (result * 397) ^ devicePrefix.GetHashCode ();  	result = (result * 397) ^ deviceName.GetHashCode ();  	result = (result * 397) ^ deviceGuid.GetHashCode ();  	result = (result * 397) ^ nonRootPath.GetHashCode ();  	result = (result * 397) ^ relDrive.GetHashCode ();  	result = (result * 397) ^ folderAndFiles.GetHashCode ();  	return result;  }  
Magic Number,Castle.IO,PathInfo,F:\newReposMay17\castleproject_Castle.Transactions\src\Castle.IO\PathInfo.cs,GetHashCode,The following statement contains a magic number: unchecked {  	var result = drive.GetHashCode ();  	result = (result * 397) ^ driveLetter.GetHashCode ();  	result = (result * 397) ^ server.GetHashCode ();  	result = (result * 397) ^ iPv4.GetHashCode ();  	result = (result * 397) ^ iPv6.GetHashCode ();  	result = (result * 397) ^ serverName.GetHashCode ();  	result = (result * 397) ^ device.GetHashCode ();  	result = (result * 397) ^ devicePrefix.GetHashCode ();  	result = (result * 397) ^ deviceName.GetHashCode ();  	result = (result * 397) ^ deviceGuid.GetHashCode ();  	result = (result * 397) ^ nonRootPath.GetHashCode ();  	result = (result * 397) ^ relDrive.GetHashCode ();  	result = (result * 397) ^ folderAndFiles.GetHashCode ();  	return result;  }  
Magic Number,Castle.IO,PathInfo,F:\newReposMay17\castleproject_Castle.Transactions\src\Castle.IO\PathInfo.cs,GetHashCode,The following statement contains a magic number: unchecked {  	var result = drive.GetHashCode ();  	result = (result * 397) ^ driveLetter.GetHashCode ();  	result = (result * 397) ^ server.GetHashCode ();  	result = (result * 397) ^ iPv4.GetHashCode ();  	result = (result * 397) ^ iPv6.GetHashCode ();  	result = (result * 397) ^ serverName.GetHashCode ();  	result = (result * 397) ^ device.GetHashCode ();  	result = (result * 397) ^ devicePrefix.GetHashCode ();  	result = (result * 397) ^ deviceName.GetHashCode ();  	result = (result * 397) ^ deviceGuid.GetHashCode ();  	result = (result * 397) ^ nonRootPath.GetHashCode ();  	result = (result * 397) ^ relDrive.GetHashCode ();  	result = (result * 397) ^ folderAndFiles.GetHashCode ();  	return result;  }  
Magic Number,Castle.IO,PathInfo,F:\newReposMay17\castleproject_Castle.Transactions\src\Castle.IO\PathInfo.cs,GetHashCode,The following statement contains a magic number: unchecked {  	var result = drive.GetHashCode ();  	result = (result * 397) ^ driveLetter.GetHashCode ();  	result = (result * 397) ^ server.GetHashCode ();  	result = (result * 397) ^ iPv4.GetHashCode ();  	result = (result * 397) ^ iPv6.GetHashCode ();  	result = (result * 397) ^ serverName.GetHashCode ();  	result = (result * 397) ^ device.GetHashCode ();  	result = (result * 397) ^ devicePrefix.GetHashCode ();  	result = (result * 397) ^ deviceName.GetHashCode ();  	result = (result * 397) ^ deviceGuid.GetHashCode ();  	result = (result * 397) ^ nonRootPath.GetHashCode ();  	result = (result * 397) ^ relDrive.GetHashCode ();  	result = (result * 397) ^ folderAndFiles.GetHashCode ();  	return result;  }  
Magic Number,Castle.IO,PathInfo,F:\newReposMay17\castleproject_Castle.Transactions\src\Castle.IO\PathInfo.cs,GetHashCode,The following statement contains a magic number: unchecked {  	var result = drive.GetHashCode ();  	result = (result * 397) ^ driveLetter.GetHashCode ();  	result = (result * 397) ^ server.GetHashCode ();  	result = (result * 397) ^ iPv4.GetHashCode ();  	result = (result * 397) ^ iPv6.GetHashCode ();  	result = (result * 397) ^ serverName.GetHashCode ();  	result = (result * 397) ^ device.GetHashCode ();  	result = (result * 397) ^ devicePrefix.GetHashCode ();  	result = (result * 397) ^ deviceName.GetHashCode ();  	result = (result * 397) ^ deviceGuid.GetHashCode ();  	result = (result * 397) ^ nonRootPath.GetHashCode ();  	result = (result * 397) ^ relDrive.GetHashCode ();  	result = (result * 397) ^ folderAndFiles.GetHashCode ();  	return result;  }  
Magic Number,Castle.IO,PathInfo,F:\newReposMay17\castleproject_Castle.Transactions\src\Castle.IO\PathInfo.cs,GetHashCode,The following statement contains a magic number: unchecked {  	var result = drive.GetHashCode ();  	result = (result * 397) ^ driveLetter.GetHashCode ();  	result = (result * 397) ^ server.GetHashCode ();  	result = (result * 397) ^ iPv4.GetHashCode ();  	result = (result * 397) ^ iPv6.GetHashCode ();  	result = (result * 397) ^ serverName.GetHashCode ();  	result = (result * 397) ^ device.GetHashCode ();  	result = (result * 397) ^ devicePrefix.GetHashCode ();  	result = (result * 397) ^ deviceName.GetHashCode ();  	result = (result * 397) ^ deviceGuid.GetHashCode ();  	result = (result * 397) ^ nonRootPath.GetHashCode ();  	result = (result * 397) ^ relDrive.GetHashCode ();  	result = (result * 397) ^ folderAndFiles.GetHashCode ();  	return result;  }  
Magic Number,Castle.IO,PathInfo,F:\newReposMay17\castleproject_Castle.Transactions\src\Castle.IO\PathInfo.cs,GetHashCode,The following statement contains a magic number: unchecked {  	var result = drive.GetHashCode ();  	result = (result * 397) ^ driveLetter.GetHashCode ();  	result = (result * 397) ^ server.GetHashCode ();  	result = (result * 397) ^ iPv4.GetHashCode ();  	result = (result * 397) ^ iPv6.GetHashCode ();  	result = (result * 397) ^ serverName.GetHashCode ();  	result = (result * 397) ^ device.GetHashCode ();  	result = (result * 397) ^ devicePrefix.GetHashCode ();  	result = (result * 397) ^ deviceName.GetHashCode ();  	result = (result * 397) ^ deviceGuid.GetHashCode ();  	result = (result * 397) ^ nonRootPath.GetHashCode ();  	result = (result * 397) ^ relDrive.GetHashCode ();  	result = (result * 397) ^ folderAndFiles.GetHashCode ();  	return result;  }  
Magic Number,Castle.IO,PathInfo,F:\newReposMay17\castleproject_Castle.Transactions\src\Castle.IO\PathInfo.cs,GetHashCode,The following statement contains a magic number: unchecked {  	var result = drive.GetHashCode ();  	result = (result * 397) ^ driveLetter.GetHashCode ();  	result = (result * 397) ^ server.GetHashCode ();  	result = (result * 397) ^ iPv4.GetHashCode ();  	result = (result * 397) ^ iPv6.GetHashCode ();  	result = (result * 397) ^ serverName.GetHashCode ();  	result = (result * 397) ^ device.GetHashCode ();  	result = (result * 397) ^ devicePrefix.GetHashCode ();  	result = (result * 397) ^ deviceName.GetHashCode ();  	result = (result * 397) ^ deviceGuid.GetHashCode ();  	result = (result * 397) ^ nonRootPath.GetHashCode ();  	result = (result * 397) ^ relDrive.GetHashCode ();  	result = (result * 397) ^ folderAndFiles.GetHashCode ();  	return result;  }  
Magic Number,Castle.IO,PathInfo,F:\newReposMay17\castleproject_Castle.Transactions\src\Castle.IO\PathInfo.cs,GetHashCode,The following statement contains a magic number: unchecked {  	var result = drive.GetHashCode ();  	result = (result * 397) ^ driveLetter.GetHashCode ();  	result = (result * 397) ^ server.GetHashCode ();  	result = (result * 397) ^ iPv4.GetHashCode ();  	result = (result * 397) ^ iPv6.GetHashCode ();  	result = (result * 397) ^ serverName.GetHashCode ();  	result = (result * 397) ^ device.GetHashCode ();  	result = (result * 397) ^ devicePrefix.GetHashCode ();  	result = (result * 397) ^ deviceName.GetHashCode ();  	result = (result * 397) ^ deviceGuid.GetHashCode ();  	result = (result * 397) ^ nonRootPath.GetHashCode ();  	result = (result * 397) ^ relDrive.GetHashCode ();  	result = (result * 397) ^ folderAndFiles.GetHashCode ();  	return result;  }  
Magic Number,Castle.IO,PathInfo,F:\newReposMay17\castleproject_Castle.Transactions\src\Castle.IO\PathInfo.cs,GetHashCode,The following statement contains a magic number: unchecked {  	var result = drive.GetHashCode ();  	result = (result * 397) ^ driveLetter.GetHashCode ();  	result = (result * 397) ^ server.GetHashCode ();  	result = (result * 397) ^ iPv4.GetHashCode ();  	result = (result * 397) ^ iPv6.GetHashCode ();  	result = (result * 397) ^ serverName.GetHashCode ();  	result = (result * 397) ^ device.GetHashCode ();  	result = (result * 397) ^ devicePrefix.GetHashCode ();  	result = (result * 397) ^ deviceName.GetHashCode ();  	result = (result * 397) ^ deviceGuid.GetHashCode ();  	result = (result * 397) ^ nonRootPath.GetHashCode ();  	result = (result * 397) ^ relDrive.GetHashCode ();  	result = (result * 397) ^ folderAndFiles.GetHashCode ();  	return result;  }  
Magic Number,Castle.IO,PathInfo,F:\newReposMay17\castleproject_Castle.Transactions\src\Castle.IO\PathInfo.cs,GetHashCode,The following statement contains a magic number: unchecked {  	var result = drive.GetHashCode ();  	result = (result * 397) ^ driveLetter.GetHashCode ();  	result = (result * 397) ^ server.GetHashCode ();  	result = (result * 397) ^ iPv4.GetHashCode ();  	result = (result * 397) ^ iPv6.GetHashCode ();  	result = (result * 397) ^ serverName.GetHashCode ();  	result = (result * 397) ^ device.GetHashCode ();  	result = (result * 397) ^ devicePrefix.GetHashCode ();  	result = (result * 397) ^ deviceName.GetHashCode ();  	result = (result * 397) ^ deviceGuid.GetHashCode ();  	result = (result * 397) ^ nonRootPath.GetHashCode ();  	result = (result * 397) ^ relDrive.GetHashCode ();  	result = (result * 397) ^ folderAndFiles.GetHashCode ();  	return result;  }  
Magic Number,Castle.IO,PathInfo,F:\newReposMay17\castleproject_Castle.Transactions\src\Castle.IO\PathInfo.cs,GetHashCode,The following statement contains a magic number: result = (result * 397) ^ driveLetter.GetHashCode ();  
Magic Number,Castle.IO,PathInfo,F:\newReposMay17\castleproject_Castle.Transactions\src\Castle.IO\PathInfo.cs,GetHashCode,The following statement contains a magic number: result = (result * 397) ^ server.GetHashCode ();  
Magic Number,Castle.IO,PathInfo,F:\newReposMay17\castleproject_Castle.Transactions\src\Castle.IO\PathInfo.cs,GetHashCode,The following statement contains a magic number: result = (result * 397) ^ iPv4.GetHashCode ();  
Magic Number,Castle.IO,PathInfo,F:\newReposMay17\castleproject_Castle.Transactions\src\Castle.IO\PathInfo.cs,GetHashCode,The following statement contains a magic number: result = (result * 397) ^ iPv6.GetHashCode ();  
Magic Number,Castle.IO,PathInfo,F:\newReposMay17\castleproject_Castle.Transactions\src\Castle.IO\PathInfo.cs,GetHashCode,The following statement contains a magic number: result = (result * 397) ^ serverName.GetHashCode ();  
Magic Number,Castle.IO,PathInfo,F:\newReposMay17\castleproject_Castle.Transactions\src\Castle.IO\PathInfo.cs,GetHashCode,The following statement contains a magic number: result = (result * 397) ^ device.GetHashCode ();  
Magic Number,Castle.IO,PathInfo,F:\newReposMay17\castleproject_Castle.Transactions\src\Castle.IO\PathInfo.cs,GetHashCode,The following statement contains a magic number: result = (result * 397) ^ devicePrefix.GetHashCode ();  
Magic Number,Castle.IO,PathInfo,F:\newReposMay17\castleproject_Castle.Transactions\src\Castle.IO\PathInfo.cs,GetHashCode,The following statement contains a magic number: result = (result * 397) ^ deviceName.GetHashCode ();  
Magic Number,Castle.IO,PathInfo,F:\newReposMay17\castleproject_Castle.Transactions\src\Castle.IO\PathInfo.cs,GetHashCode,The following statement contains a magic number: result = (result * 397) ^ deviceGuid.GetHashCode ();  
Magic Number,Castle.IO,PathInfo,F:\newReposMay17\castleproject_Castle.Transactions\src\Castle.IO\PathInfo.cs,GetHashCode,The following statement contains a magic number: result = (result * 397) ^ nonRootPath.GetHashCode ();  
Magic Number,Castle.IO,PathInfo,F:\newReposMay17\castleproject_Castle.Transactions\src\Castle.IO\PathInfo.cs,GetHashCode,The following statement contains a magic number: result = (result * 397) ^ relDrive.GetHashCode ();  
Magic Number,Castle.IO,PathInfo,F:\newReposMay17\castleproject_Castle.Transactions\src\Castle.IO\PathInfo.cs,GetHashCode,The following statement contains a magic number: result = (result * 397) ^ folderAndFiles.GetHashCode ();  
Magic Number,Castle.IO.FileSystems,FileSystemNotificationIdentifier,F:\newReposMay17\castleproject_Castle.Transactions\src\Castle.IO\FileSystems\FileSystemNotificationIdentifier.cs,GetHashCode,The following statement contains a magic number: unchecked {  	var result = IncludeSubDirectories.GetHashCode ();  	result = (result * 397) ^ Path.GetHashCode ();  	result = (result * 397) ^ Filter.GetHashCode ();  	result = (result * 397) ^ ChangeTypes.GetHashCode ();  	return result;  }  
Magic Number,Castle.IO.FileSystems,FileSystemNotificationIdentifier,F:\newReposMay17\castleproject_Castle.Transactions\src\Castle.IO\FileSystems\FileSystemNotificationIdentifier.cs,GetHashCode,The following statement contains a magic number: unchecked {  	var result = IncludeSubDirectories.GetHashCode ();  	result = (result * 397) ^ Path.GetHashCode ();  	result = (result * 397) ^ Filter.GetHashCode ();  	result = (result * 397) ^ ChangeTypes.GetHashCode ();  	return result;  }  
Magic Number,Castle.IO.FileSystems,FileSystemNotificationIdentifier,F:\newReposMay17\castleproject_Castle.Transactions\src\Castle.IO\FileSystems\FileSystemNotificationIdentifier.cs,GetHashCode,The following statement contains a magic number: unchecked {  	var result = IncludeSubDirectories.GetHashCode ();  	result = (result * 397) ^ Path.GetHashCode ();  	result = (result * 397) ^ Filter.GetHashCode ();  	result = (result * 397) ^ ChangeTypes.GetHashCode ();  	return result;  }  
Magic Number,Castle.IO.FileSystems,FileSystemNotificationIdentifier,F:\newReposMay17\castleproject_Castle.Transactions\src\Castle.IO\FileSystems\FileSystemNotificationIdentifier.cs,GetHashCode,The following statement contains a magic number: result = (result * 397) ^ Path.GetHashCode ();  
Magic Number,Castle.IO.FileSystems,FileSystemNotificationIdentifier,F:\newReposMay17\castleproject_Castle.Transactions\src\Castle.IO\FileSystems\FileSystemNotificationIdentifier.cs,GetHashCode,The following statement contains a magic number: result = (result * 397) ^ Filter.GetHashCode ();  
Magic Number,Castle.IO.FileSystems,FileSystemNotificationIdentifier,F:\newReposMay17\castleproject_Castle.Transactions\src\Castle.IO\FileSystems\FileSystemNotificationIdentifier.cs,GetHashCode,The following statement contains a magic number: result = (result * 397) ^ ChangeTypes.GetHashCode ();  
Magic Number,Castle.IO.FileSystems.InMemory,InMemoryFile,F:\newReposMay17\castleproject_Castle.Transactions\src\Castle.IO\FileSystems\InMemory\InMemoryFile.cs,Resize,The following statement contains a magic number: lock (_contentLock) {  	if (_contentLength < offset)  		_contentLength = offset;  	if (_content.Length < _contentLength) {  		var buffer = new byte[_content.Length * 2];  		Buffer.BlockCopy (_content' 0' buffer' 0' _content.Length);  		_content = buffer;  	}  }  
Magic Number,Castle.IO.FileSystems.InMemory,InMemoryFile,F:\newReposMay17\castleproject_Castle.Transactions\src\Castle.IO\FileSystems\InMemory\InMemoryFile.cs,Resize,The following statement contains a magic number: if (_content.Length < _contentLength) {  	var buffer = new byte[_content.Length * 2];  	Buffer.BlockCopy (_content' 0' buffer' 0' _content.Length);  	_content = buffer;  }  
Magic Number,Castle.IO.FileSystems.Local,LocalFileSystem,F:\newReposMay17\castleproject_Castle.Transactions\src\Castle.IO\FileSystems\Local\LocalFileSystem.cs,CreatePlatformSpecificInstance,The following statement contains a magic number: if (platformId == 4 || platformId == 128 || platformId == (int)PlatformID.MacOSX)  	return UnixFileSystem ();  
Magic Number,Castle.IO.FileSystems.Local,LocalFileSystem,F:\newReposMay17\castleproject_Castle.Transactions\src\Castle.IO\FileSystems\Local\LocalFileSystem.cs,CreatePlatformSpecificInstance,The following statement contains a magic number: if (platformId == 4 || platformId == 128 || platformId == (int)PlatformID.MacOSX)  	return UnixFileSystem ();  
Magic Number,Castle.IO.FileSystems.Local.Win32.Interop,JunctionPoint,F:\newReposMay17\castleproject_Castle.Transactions\src\Castle.IO\FileSystems\Local\Win32\Interop\JunctionPoint.cs,Create,The following statement contains a magic number: using (var handle = OpenReparsePoint (junctionPoint.Path.FullPath' EFileAccess.GenericWrite)) {  	var targetDirBytes = Encoding.Unicode.GetBytes (NonInterpretedPathPrefix + Path.GetFullPath (targetDir));  	var reparseDataBuffer = new REPARSE_DATA_BUFFER ();  	reparseDataBuffer.ReparseTag = IO_REPARSE_TAG_MOUNT_POINT;  	reparseDataBuffer.ReparseDataLength = (ushort)(targetDirBytes.Length + 12);  	reparseDataBuffer.SubstituteNameOffset = 0;  	reparseDataBuffer.SubstituteNameLength = (ushort)targetDirBytes.Length;  	reparseDataBuffer.PrintNameOffset = (ushort)(targetDirBytes.Length + 2);  	reparseDataBuffer.PrintNameLength = 0;  	reparseDataBuffer.PathBuffer = new byte[0x3ff0];  	Array.Copy (targetDirBytes' reparseDataBuffer.PathBuffer' targetDirBytes.Length);  	var inBufferSize = Marshal.SizeOf (reparseDataBuffer);  	var inBuffer = Marshal.AllocHGlobal (inBufferSize);  	try {  		Marshal.StructureToPtr (reparseDataBuffer' inBuffer' false);  		int bytesReturned;  		var result = DeviceIoControl (handle.DangerousGetHandle ()' FSCTL_SET_REPARSE_POINT' inBuffer' targetDirBytes.Length + 20' IntPtr.Zero' 0' out bytesReturned' IntPtr.Zero);  		if (!result)  			ThrowLastWin32Error ("Unable to create junction point.");  	} finally {  		Marshal.FreeHGlobal (inBuffer);  	}  }  
Magic Number,Castle.IO.FileSystems.Local.Win32.Interop,JunctionPoint,F:\newReposMay17\castleproject_Castle.Transactions\src\Castle.IO\FileSystems\Local\Win32\Interop\JunctionPoint.cs,Create,The following statement contains a magic number: using (var handle = OpenReparsePoint (junctionPoint.Path.FullPath' EFileAccess.GenericWrite)) {  	var targetDirBytes = Encoding.Unicode.GetBytes (NonInterpretedPathPrefix + Path.GetFullPath (targetDir));  	var reparseDataBuffer = new REPARSE_DATA_BUFFER ();  	reparseDataBuffer.ReparseTag = IO_REPARSE_TAG_MOUNT_POINT;  	reparseDataBuffer.ReparseDataLength = (ushort)(targetDirBytes.Length + 12);  	reparseDataBuffer.SubstituteNameOffset = 0;  	reparseDataBuffer.SubstituteNameLength = (ushort)targetDirBytes.Length;  	reparseDataBuffer.PrintNameOffset = (ushort)(targetDirBytes.Length + 2);  	reparseDataBuffer.PrintNameLength = 0;  	reparseDataBuffer.PathBuffer = new byte[0x3ff0];  	Array.Copy (targetDirBytes' reparseDataBuffer.PathBuffer' targetDirBytes.Length);  	var inBufferSize = Marshal.SizeOf (reparseDataBuffer);  	var inBuffer = Marshal.AllocHGlobal (inBufferSize);  	try {  		Marshal.StructureToPtr (reparseDataBuffer' inBuffer' false);  		int bytesReturned;  		var result = DeviceIoControl (handle.DangerousGetHandle ()' FSCTL_SET_REPARSE_POINT' inBuffer' targetDirBytes.Length + 20' IntPtr.Zero' 0' out bytesReturned' IntPtr.Zero);  		if (!result)  			ThrowLastWin32Error ("Unable to create junction point.");  	} finally {  		Marshal.FreeHGlobal (inBuffer);  	}  }  
Magic Number,Castle.IO.FileSystems.Local.Win32.Interop,JunctionPoint,F:\newReposMay17\castleproject_Castle.Transactions\src\Castle.IO\FileSystems\Local\Win32\Interop\JunctionPoint.cs,Create,The following statement contains a magic number: using (var handle = OpenReparsePoint (junctionPoint.Path.FullPath' EFileAccess.GenericWrite)) {  	var targetDirBytes = Encoding.Unicode.GetBytes (NonInterpretedPathPrefix + Path.GetFullPath (targetDir));  	var reparseDataBuffer = new REPARSE_DATA_BUFFER ();  	reparseDataBuffer.ReparseTag = IO_REPARSE_TAG_MOUNT_POINT;  	reparseDataBuffer.ReparseDataLength = (ushort)(targetDirBytes.Length + 12);  	reparseDataBuffer.SubstituteNameOffset = 0;  	reparseDataBuffer.SubstituteNameLength = (ushort)targetDirBytes.Length;  	reparseDataBuffer.PrintNameOffset = (ushort)(targetDirBytes.Length + 2);  	reparseDataBuffer.PrintNameLength = 0;  	reparseDataBuffer.PathBuffer = new byte[0x3ff0];  	Array.Copy (targetDirBytes' reparseDataBuffer.PathBuffer' targetDirBytes.Length);  	var inBufferSize = Marshal.SizeOf (reparseDataBuffer);  	var inBuffer = Marshal.AllocHGlobal (inBufferSize);  	try {  		Marshal.StructureToPtr (reparseDataBuffer' inBuffer' false);  		int bytesReturned;  		var result = DeviceIoControl (handle.DangerousGetHandle ()' FSCTL_SET_REPARSE_POINT' inBuffer' targetDirBytes.Length + 20' IntPtr.Zero' 0' out bytesReturned' IntPtr.Zero);  		if (!result)  			ThrowLastWin32Error ("Unable to create junction point.");  	} finally {  		Marshal.FreeHGlobal (inBuffer);  	}  }  
Magic Number,Castle.IO.FileSystems.Local.Win32.Interop,JunctionPoint,F:\newReposMay17\castleproject_Castle.Transactions\src\Castle.IO\FileSystems\Local\Win32\Interop\JunctionPoint.cs,Create,The following statement contains a magic number: reparseDataBuffer.ReparseDataLength = (ushort)(targetDirBytes.Length + 12);  
Magic Number,Castle.IO.FileSystems.Local.Win32.Interop,JunctionPoint,F:\newReposMay17\castleproject_Castle.Transactions\src\Castle.IO\FileSystems\Local\Win32\Interop\JunctionPoint.cs,Create,The following statement contains a magic number: reparseDataBuffer.PrintNameOffset = (ushort)(targetDirBytes.Length + 2);  
Magic Number,Castle.IO.FileSystems.Local.Win32.Interop,JunctionPoint,F:\newReposMay17\castleproject_Castle.Transactions\src\Castle.IO\FileSystems\Local\Win32\Interop\JunctionPoint.cs,Create,The following statement contains a magic number: try {  	Marshal.StructureToPtr (reparseDataBuffer' inBuffer' false);  	int bytesReturned;  	var result = DeviceIoControl (handle.DangerousGetHandle ()' FSCTL_SET_REPARSE_POINT' inBuffer' targetDirBytes.Length + 20' IntPtr.Zero' 0' out bytesReturned' IntPtr.Zero);  	if (!result)  		ThrowLastWin32Error ("Unable to create junction point.");  } finally {  	Marshal.FreeHGlobal (inBuffer);  }  
Magic Number,Castle.IO.FileSystems.Local.Win32.Interop,JunctionPoint,F:\newReposMay17\castleproject_Castle.Transactions\src\Castle.IO\FileSystems\Local\Win32\Interop\JunctionPoint.cs,Delete,The following statement contains a magic number: using (var handle = OpenReparsePoint (junctionPoint' EFileAccess.GenericWrite)) {  	var reparseDataBuffer = new REPARSE_DATA_BUFFER ();  	reparseDataBuffer.ReparseTag = IO_REPARSE_TAG_MOUNT_POINT;  	reparseDataBuffer.ReparseDataLength = 0;  	reparseDataBuffer.PathBuffer = new byte[0x3ff0];  	var inBufferSize = Marshal.SizeOf (reparseDataBuffer);  	var inBuffer = Marshal.AllocHGlobal (inBufferSize);  	try {  		Marshal.StructureToPtr (reparseDataBuffer' inBuffer' false);  		int bytesReturned;  		var result = DeviceIoControl (handle.DangerousGetHandle ()' FSCTL_DELETE_REPARSE_POINT' inBuffer' 8' IntPtr.Zero' 0' out bytesReturned' IntPtr.Zero);  		if (!result)  			ThrowLastWin32Error ("Unable to delete junction point.");  	} finally {  		Marshal.FreeHGlobal (inBuffer);  	}  	try {  		Directory.Delete (junctionPoint);  	} catch (IOException ex) {  		throw new IOException ("Unable to delete junction point."' ex);  	}  }  
Magic Number,Castle.IO.FileSystems.Local.Win32.Interop,JunctionPoint,F:\newReposMay17\castleproject_Castle.Transactions\src\Castle.IO\FileSystems\Local\Win32\Interop\JunctionPoint.cs,Delete,The following statement contains a magic number: try {  	Marshal.StructureToPtr (reparseDataBuffer' inBuffer' false);  	int bytesReturned;  	var result = DeviceIoControl (handle.DangerousGetHandle ()' FSCTL_DELETE_REPARSE_POINT' inBuffer' 8' IntPtr.Zero' 0' out bytesReturned' IntPtr.Zero);  	if (!result)  		ThrowLastWin32Error ("Unable to delete junction point.");  } finally {  	Marshal.FreeHGlobal (inBuffer);  }  
Missing Default,Castle.IO,PathInfo,F:\newReposMay17\castleproject_Castle.Transactions\src\Castle.IO\PathInfo.cs,IsParentOf,The following switch statement is missing a default case: switch (Type) {  case PathType.Device:  	OK &= child.DeviceName.Equals (DeviceName' StringComparison.InvariantCultureIgnoreCase);  	break;  case PathType.Server:  	OK &= child.ServerName.Equals (ServerName' StringComparison.InvariantCultureIgnoreCase);  	break;  case PathType.IPv4:  	OK &= child.IPv4.Equals (IPv4);  	break;  case PathType.IPv6:  	OK &= child.IPv6.Equals (IPv6);  	break;  case PathType.Relative:  	throw new NotSupportedException ("Since root isn't empty we should never get relative paths.");  case PathType.Drive:  	OK &= DriveLetter.ToLowerInvariant () == child.DriveLetter.ToLowerInvariant ();  	break;  }  
Missing Default,Castle.IO.FileSystems.InMemory,InMemoryFile,F:\newReposMay17\castleproject_Castle.Transactions\src\Castle.IO\FileSystems\InMemory\InMemoryFile.cs,ValidateFileMode,The following switch statement is missing a default case: switch (fileMode) {  case FileMode.CreateNew:  	throw new IOException ("File already exists.");  case FileMode.Create:  case FileMode.Truncate:  	_contentLength = 0;  	return 0;  case FileMode.Open:  case FileMode.OpenOrCreate:  	return 0;  case FileMode.Append:  	return _contentLength;  }  
Missing Default,Castle.IO.FileSystems.InMemory,InMemoryFile,F:\newReposMay17\castleproject_Castle.Transactions\src\Castle.IO\FileSystems\InMemory\InMemoryFile.cs,ValidateFileMode,The following switch statement is missing a default case: switch (fileMode) {  case FileMode.Create:  case FileMode.Append:  case FileMode.CreateNew:  case FileMode.OpenOrCreate:  	EnsureExists ();  	return _contentLength;  case FileMode.Open:  case FileMode.Truncate:  	throw new FileNotFoundException ();  }  
