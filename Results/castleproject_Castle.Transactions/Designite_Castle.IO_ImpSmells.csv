Implementation smell,Namespace,Class,File,Method,Description
Long Parameter List,Castle.IO,IDirectory,C:\repos\castleproject_Castle.Transactions\src\Castle.IO\IDirectory.cs,FileChanges,The method has 6 parameters. Parameters: filter' includeSubdirectories' created' modified' deleted' renamed
Long Parameter List,Castle.IO,PathInfo,C:\repos\castleproject_Castle.Transactions\src\Castle.IO\PathInfo.cs,PathInfo,The method has 16 parameters. Parameters: root' uncPrefix' uncLiteral' drive' driveLetter' server' iPv4' iPv6' serverName' device' devicePrefix' deviceName' deviceGuid' nonRootPath' relDrive' folderAndFiles
Long Parameter List,Castle.IO.Contracts,IDirectoryContract,C:\repos\castleproject_Castle.Transactions\src\Castle.IO\Contracts\IDirectoryContract.cs,FileChanges,The method has 6 parameters. Parameters: filter' includeSubdirectories' created' modified' deleted' renamed
Long Parameter List,Castle.IO.FileSystems,FileSystemNotifier,C:\repos\castleproject_Castle.Transactions\src\Castle.IO\FileSystems\FileSystemNotifier.cs,RegisterNotification,The method has 7 parameters. Parameters: path' filter' includeSubdirectories' created' modified' deleted' renamed
Long Parameter List,Castle.IO.FileSystems,IFileSystemNotifier,C:\repos\castleproject_Castle.Transactions\src\Castle.IO\FileSystems\IFileSystemNotifier.cs,RegisterNotification,The method has 7 parameters. Parameters: path' filter' includeSubdirectories' created' modified' deleted' renamed
Long Parameter List,Castle.IO.FileSystems.InMemory,InMemoryDirectory,C:\repos\castleproject_Castle.Transactions\src\Castle.IO\FileSystems\InMemory\InMemoryDirectory.cs,FileChanges,The method has 6 parameters. Parameters: filter' includeSubdirectories' created' modified' deleted' renamed
Long Parameter List,Castle.IO.FileSystems.Local,LocalDirectory,C:\repos\castleproject_Castle.Transactions\src\Castle.IO\FileSystems\Local\LocalDirectory.cs,FileChanges,The method has 6 parameters. Parameters: filter' includeSubdirectories' created' modified' deleted' renamed
Long Parameter List,Castle.IO.FileSystems.Local,TemporaryDirectory,C:\repos\castleproject_Castle.Transactions\src\Castle.IO\FileSystems\Local\TemporaryDirectory.cs,FileChanges,The method has 6 parameters. Parameters: filter' includeSubdirectories' created' modified' deleted' renamed
Long Parameter List,Castle.IO.FileSystems.Local.Win32.Interop,JunctionPoint,C:\repos\castleproject_Castle.Transactions\src\Castle.IO\FileSystems\Local\Win32\Interop\JunctionPoint.cs,DeviceIoControl,The method has 8 parameters. Parameters: hDevice' dwIoControlCode' InBuffer' nInBufferSize' OutBuffer' nOutBufferSize' pBytesReturned' lpOverlapped
Long Parameter List,Castle.IO.FileSystems.Local.Win32.Interop,JunctionPoint,C:\repos\castleproject_Castle.Transactions\src\Castle.IO\FileSystems\Local\Win32\Interop\JunctionPoint.cs,CreateFile,The method has 7 parameters. Parameters: lpFileName' dwDesiredAccess' dwShareMode' lpSecurityAttributes' dwCreationDisposition' dwFlagsAndAttributes' hTemplateFile
Long Parameter List,Castle.IO.FileSystems.Local.Win32.Interop,NativeMethods,C:\repos\castleproject_Castle.Transactions\src\Castle.IO\FileSystems\Local\Win32\Interop\NativeMethods.cs,CreateFile,The method has 7 parameters. Parameters: lpFileName' dwDesiredAccess' dwShareMode' lpSecurityAttributes' dwCreationDisposition' dwFlagsAndAttributes' hTemplateFile
Long Parameter List,Castle.IO.FileSystems.Local.Win32.Interop,NativeMethods,C:\repos\castleproject_Castle.Transactions\src\Castle.IO\FileSystems\Local\Win32\Interop\NativeMethods.cs,FormatMessage,The method has 7 parameters. Parameters: dwFlags' lpSource' dwMessageId' dwLanguageId' lpBuffer' nSize' va_list_arguments
Long Parameter List,Castle.IO.Internal,LongPathFile,C:\repos\castleproject_Castle.Transactions\src\Castle.IO\Internal\LongPathFile.cs,Open,The method has 6 parameters. Parameters: path' mode' access' share' bufferSize' options
Long Parameter List,Castle.IO.Internal,LongPathFile,C:\repos\castleproject_Castle.Transactions\src\Castle.IO\Internal\LongPathFile.cs,GetFileHandle,The method has 5 parameters. Parameters: normalizedPath' mode' access' share' options
Long Identifier,Castle.IO.FileSystems.Local.Win32.Interop,JunctionPoint,C:\repos\castleproject_Castle.Transactions\src\Castle.IO\FileSystems\Local\Win32\Interop\JunctionPoint.cs,,The length of the parameter ERROR_REPARSE_ATTRIBUTE_CONFLICT is 32.
Long Identifier,Castle.IO.Internal,LongPathDirectory,C:\repos\castleproject_Castle.Transactions\src\Castle.IO\Internal\LongPathDirectory.cs,BeginFind,The length of the parameter normalizedPathWithSearchPattern is 31.
Long Statement,Castle.IO,Path,C:\repos\castleproject_Castle.Transactions\src\Castle.IO\Path Statics.cs,GetPathWithoutLastBit,The length of the statement  "						if (PathInfo.Parse(path.Substring(0' i + 1)).Root == path.Substring(0' i + 1)) return new Path(path.Substring(0' i + 1)); " is 121.
Long Statement,Castle.IO,PathExtensions,C:\repos\castleproject_Castle.Transactions\src\Castle.IO\PathExtensions.cs,AllowedToAccess,The length of the statement  "			if (!String.IsNullOrEmpty(chjailedRootPath.Info.DriveLetter) && other.Info.DriveLetter != chjailedRootPath.Info.DriveLetter) " is 124.
Long Statement,Castle.IO,PathInfo,C:\repos\castleproject_Castle.Transactions\src\Castle.IO\PathInfo.cs,RemoveParameterFromRoot,The length of the statement  "			                  "The folders and files part of the parameter must be shorter or equal to in length' than that path you wish to subtract from."); " is 128.
Long Statement,Castle.IO.FileSystems.Local,LocalFileSystem,C:\repos\castleproject_Castle.Transactions\src\Castle.IO\FileSystems\Local\LocalFileSystem.cs,GetFile,The length of the statement  "			return new LocalFile(Path.GetFullPath(System.IO.Path.Combine(Environment.CurrentDirectory' filePath))' CreateDirectory); " is 120.
Long Statement,Castle.IO.Internal,MapPathImpl,C:\repos\castleproject_Castle.Transactions\src\Castle.IO\Internal\MapPathImpl.cs,MapPath,The length of the statement  "				                "This is a user-provided function' and code-contracts don't allow me to reason with the typed for Func in a Requires in c'tor."); " is 129.
Complex Conditional,Castle.IO.FileSystems,FileSystemNotifier,C:\repos\castleproject_Castle.Transactions\src\Castle.IO\FileSystems\FileSystemNotifier.cs,RegisterNotification,The conditional expression  "created == null && modified == null && renamed == null && deleted == null"  is complex.
Complex Conditional,Castle.IO.FileSystems.InMemory,InMemoryFile,C:\repos\castleproject_Castle.Transactions\src\Castle.IO\FileSystems\InMemory\InMemoryFile.cs,ValidateFileLock,The conditional expression  "(fileAccess == FileAccess.Read && !readAllowed) ||  			    (fileAccess == FileAccess.ReadWrite && !(readAllowed && writeAllowed)) ||  			    (fileAccess == FileAccess.Write && !writeAllowed)"  is complex.
Empty Catch Block,Castle.IO.Internal,LongPathCommon,C:\repos\castleproject_Castle.Transactions\src\Castle.IO\Internal\LongPathCommon.cs,TryNormalizeLongPath,The method has an empty catch block.
Empty Catch Block,Castle.IO.Internal,LongPathCommon,C:\repos\castleproject_Castle.Transactions\src\Castle.IO\Internal\LongPathCommon.cs,TryNormalizeLongPath,The method has an empty catch block.
Magic Number,Castle.IO,DirectoryExtensions,C:\repos\castleproject_Castle.Transactions\src\Castle.IO\DirectoryExtensions.cs,GetFileSpecCore,The following statement contains a magic number: if (segment == Subfolder)  			{  				var isNextToLastSegment = position + 1 == segments.Count - 1;    				return isNextToLastSegment  				       	? directory.Files(segments[position + 1]' SearchScope.SubFolders)  				       	: directory.Directories(segments[position + 1]' SearchScope.SubFolders)  				       	  	.SelectMany(x => GetFileSpecCore(x' segments' position + 2));  			}
Magic Number,Castle.IO,DirectoryExtensions,C:\repos\castleproject_Castle.Transactions\src\Castle.IO\DirectoryExtensions.cs,GetDirectorySpecCore,The following statement contains a magic number: if (segment == Subfolder)  			{  				var isNextToLastSegment = position + 1 == segments.Count - 1;  				return isNextToLastSegment  				       	? directory.Directories(segments[position + 1]' SearchScope.SubFolders)  				       	: directory.Directories(segments[position + 1]' SearchScope.SubFolders)  				       	  	.SelectMany(x => GetDirectorySpecCore(x' segments' position + 2));  			}
Magic Number,Castle.IO,Path,C:\repos\castleproject_Castle.Transactions\src\Castle.IO\Path Statics.cs,GetPathWithoutLastBit,The following statement contains a magic number: Contract.Requires(path.Length >= 2);
Magic Number,Castle.IO,PathInfo,C:\repos\castleproject_Castle.Transactions\src\Castle.IO\PathInfo.cs,GetHashCode,The following statement contains a magic number: unchecked  			{  				var result = drive.GetHashCode();  				result = (result*397) ^ driveLetter.GetHashCode();  				result = (result*397) ^ server.GetHashCode();  				result = (result*397) ^ iPv4.GetHashCode();  				result = (result*397) ^ iPv6.GetHashCode();  				result = (result*397) ^ serverName.GetHashCode();  				result = (result*397) ^ device.GetHashCode();  				result = (result*397) ^ devicePrefix.GetHashCode();  				result = (result*397) ^ deviceName.GetHashCode();  				result = (result*397) ^ deviceGuid.GetHashCode();  				result = (result*397) ^ nonRootPath.GetHashCode();  				result = (result*397) ^ relDrive.GetHashCode();  				result = (result*397) ^ folderAndFiles.GetHashCode();  				return result;  			}
Magic Number,Castle.IO,PathInfo,C:\repos\castleproject_Castle.Transactions\src\Castle.IO\PathInfo.cs,GetHashCode,The following statement contains a magic number: unchecked  			{  				var result = drive.GetHashCode();  				result = (result*397) ^ driveLetter.GetHashCode();  				result = (result*397) ^ server.GetHashCode();  				result = (result*397) ^ iPv4.GetHashCode();  				result = (result*397) ^ iPv6.GetHashCode();  				result = (result*397) ^ serverName.GetHashCode();  				result = (result*397) ^ device.GetHashCode();  				result = (result*397) ^ devicePrefix.GetHashCode();  				result = (result*397) ^ deviceName.GetHashCode();  				result = (result*397) ^ deviceGuid.GetHashCode();  				result = (result*397) ^ nonRootPath.GetHashCode();  				result = (result*397) ^ relDrive.GetHashCode();  				result = (result*397) ^ folderAndFiles.GetHashCode();  				return result;  			}
Magic Number,Castle.IO,PathInfo,C:\repos\castleproject_Castle.Transactions\src\Castle.IO\PathInfo.cs,GetHashCode,The following statement contains a magic number: unchecked  			{  				var result = drive.GetHashCode();  				result = (result*397) ^ driveLetter.GetHashCode();  				result = (result*397) ^ server.GetHashCode();  				result = (result*397) ^ iPv4.GetHashCode();  				result = (result*397) ^ iPv6.GetHashCode();  				result = (result*397) ^ serverName.GetHashCode();  				result = (result*397) ^ device.GetHashCode();  				result = (result*397) ^ devicePrefix.GetHashCode();  				result = (result*397) ^ deviceName.GetHashCode();  				result = (result*397) ^ deviceGuid.GetHashCode();  				result = (result*397) ^ nonRootPath.GetHashCode();  				result = (result*397) ^ relDrive.GetHashCode();  				result = (result*397) ^ folderAndFiles.GetHashCode();  				return result;  			}
Magic Number,Castle.IO,PathInfo,C:\repos\castleproject_Castle.Transactions\src\Castle.IO\PathInfo.cs,GetHashCode,The following statement contains a magic number: unchecked  			{  				var result = drive.GetHashCode();  				result = (result*397) ^ driveLetter.GetHashCode();  				result = (result*397) ^ server.GetHashCode();  				result = (result*397) ^ iPv4.GetHashCode();  				result = (result*397) ^ iPv6.GetHashCode();  				result = (result*397) ^ serverName.GetHashCode();  				result = (result*397) ^ device.GetHashCode();  				result = (result*397) ^ devicePrefix.GetHashCode();  				result = (result*397) ^ deviceName.GetHashCode();  				result = (result*397) ^ deviceGuid.GetHashCode();  				result = (result*397) ^ nonRootPath.GetHashCode();  				result = (result*397) ^ relDrive.GetHashCode();  				result = (result*397) ^ folderAndFiles.GetHashCode();  				return result;  			}
Magic Number,Castle.IO,PathInfo,C:\repos\castleproject_Castle.Transactions\src\Castle.IO\PathInfo.cs,GetHashCode,The following statement contains a magic number: unchecked  			{  				var result = drive.GetHashCode();  				result = (result*397) ^ driveLetter.GetHashCode();  				result = (result*397) ^ server.GetHashCode();  				result = (result*397) ^ iPv4.GetHashCode();  				result = (result*397) ^ iPv6.GetHashCode();  				result = (result*397) ^ serverName.GetHashCode();  				result = (result*397) ^ device.GetHashCode();  				result = (result*397) ^ devicePrefix.GetHashCode();  				result = (result*397) ^ deviceName.GetHashCode();  				result = (result*397) ^ deviceGuid.GetHashCode();  				result = (result*397) ^ nonRootPath.GetHashCode();  				result = (result*397) ^ relDrive.GetHashCode();  				result = (result*397) ^ folderAndFiles.GetHashCode();  				return result;  			}
Magic Number,Castle.IO,PathInfo,C:\repos\castleproject_Castle.Transactions\src\Castle.IO\PathInfo.cs,GetHashCode,The following statement contains a magic number: unchecked  			{  				var result = drive.GetHashCode();  				result = (result*397) ^ driveLetter.GetHashCode();  				result = (result*397) ^ server.GetHashCode();  				result = (result*397) ^ iPv4.GetHashCode();  				result = (result*397) ^ iPv6.GetHashCode();  				result = (result*397) ^ serverName.GetHashCode();  				result = (result*397) ^ device.GetHashCode();  				result = (result*397) ^ devicePrefix.GetHashCode();  				result = (result*397) ^ deviceName.GetHashCode();  				result = (result*397) ^ deviceGuid.GetHashCode();  				result = (result*397) ^ nonRootPath.GetHashCode();  				result = (result*397) ^ relDrive.GetHashCode();  				result = (result*397) ^ folderAndFiles.GetHashCode();  				return result;  			}
Magic Number,Castle.IO,PathInfo,C:\repos\castleproject_Castle.Transactions\src\Castle.IO\PathInfo.cs,GetHashCode,The following statement contains a magic number: unchecked  			{  				var result = drive.GetHashCode();  				result = (result*397) ^ driveLetter.GetHashCode();  				result = (result*397) ^ server.GetHashCode();  				result = (result*397) ^ iPv4.GetHashCode();  				result = (result*397) ^ iPv6.GetHashCode();  				result = (result*397) ^ serverName.GetHashCode();  				result = (result*397) ^ device.GetHashCode();  				result = (result*397) ^ devicePrefix.GetHashCode();  				result = (result*397) ^ deviceName.GetHashCode();  				result = (result*397) ^ deviceGuid.GetHashCode();  				result = (result*397) ^ nonRootPath.GetHashCode();  				result = (result*397) ^ relDrive.GetHashCode();  				result = (result*397) ^ folderAndFiles.GetHashCode();  				return result;  			}
Magic Number,Castle.IO,PathInfo,C:\repos\castleproject_Castle.Transactions\src\Castle.IO\PathInfo.cs,GetHashCode,The following statement contains a magic number: unchecked  			{  				var result = drive.GetHashCode();  				result = (result*397) ^ driveLetter.GetHashCode();  				result = (result*397) ^ server.GetHashCode();  				result = (result*397) ^ iPv4.GetHashCode();  				result = (result*397) ^ iPv6.GetHashCode();  				result = (result*397) ^ serverName.GetHashCode();  				result = (result*397) ^ device.GetHashCode();  				result = (result*397) ^ devicePrefix.GetHashCode();  				result = (result*397) ^ deviceName.GetHashCode();  				result = (result*397) ^ deviceGuid.GetHashCode();  				result = (result*397) ^ nonRootPath.GetHashCode();  				result = (result*397) ^ relDrive.GetHashCode();  				result = (result*397) ^ folderAndFiles.GetHashCode();  				return result;  			}
Magic Number,Castle.IO,PathInfo,C:\repos\castleproject_Castle.Transactions\src\Castle.IO\PathInfo.cs,GetHashCode,The following statement contains a magic number: unchecked  			{  				var result = drive.GetHashCode();  				result = (result*397) ^ driveLetter.GetHashCode();  				result = (result*397) ^ server.GetHashCode();  				result = (result*397) ^ iPv4.GetHashCode();  				result = (result*397) ^ iPv6.GetHashCode();  				result = (result*397) ^ serverName.GetHashCode();  				result = (result*397) ^ device.GetHashCode();  				result = (result*397) ^ devicePrefix.GetHashCode();  				result = (result*397) ^ deviceName.GetHashCode();  				result = (result*397) ^ deviceGuid.GetHashCode();  				result = (result*397) ^ nonRootPath.GetHashCode();  				result = (result*397) ^ relDrive.GetHashCode();  				result = (result*397) ^ folderAndFiles.GetHashCode();  				return result;  			}
Magic Number,Castle.IO,PathInfo,C:\repos\castleproject_Castle.Transactions\src\Castle.IO\PathInfo.cs,GetHashCode,The following statement contains a magic number: unchecked  			{  				var result = drive.GetHashCode();  				result = (result*397) ^ driveLetter.GetHashCode();  				result = (result*397) ^ server.GetHashCode();  				result = (result*397) ^ iPv4.GetHashCode();  				result = (result*397) ^ iPv6.GetHashCode();  				result = (result*397) ^ serverName.GetHashCode();  				result = (result*397) ^ device.GetHashCode();  				result = (result*397) ^ devicePrefix.GetHashCode();  				result = (result*397) ^ deviceName.GetHashCode();  				result = (result*397) ^ deviceGuid.GetHashCode();  				result = (result*397) ^ nonRootPath.GetHashCode();  				result = (result*397) ^ relDrive.GetHashCode();  				result = (result*397) ^ folderAndFiles.GetHashCode();  				return result;  			}
Magic Number,Castle.IO,PathInfo,C:\repos\castleproject_Castle.Transactions\src\Castle.IO\PathInfo.cs,GetHashCode,The following statement contains a magic number: unchecked  			{  				var result = drive.GetHashCode();  				result = (result*397) ^ driveLetter.GetHashCode();  				result = (result*397) ^ server.GetHashCode();  				result = (result*397) ^ iPv4.GetHashCode();  				result = (result*397) ^ iPv6.GetHashCode();  				result = (result*397) ^ serverName.GetHashCode();  				result = (result*397) ^ device.GetHashCode();  				result = (result*397) ^ devicePrefix.GetHashCode();  				result = (result*397) ^ deviceName.GetHashCode();  				result = (result*397) ^ deviceGuid.GetHashCode();  				result = (result*397) ^ nonRootPath.GetHashCode();  				result = (result*397) ^ relDrive.GetHashCode();  				result = (result*397) ^ folderAndFiles.GetHashCode();  				return result;  			}
Magic Number,Castle.IO,PathInfo,C:\repos\castleproject_Castle.Transactions\src\Castle.IO\PathInfo.cs,GetHashCode,The following statement contains a magic number: unchecked  			{  				var result = drive.GetHashCode();  				result = (result*397) ^ driveLetter.GetHashCode();  				result = (result*397) ^ server.GetHashCode();  				result = (result*397) ^ iPv4.GetHashCode();  				result = (result*397) ^ iPv6.GetHashCode();  				result = (result*397) ^ serverName.GetHashCode();  				result = (result*397) ^ device.GetHashCode();  				result = (result*397) ^ devicePrefix.GetHashCode();  				result = (result*397) ^ deviceName.GetHashCode();  				result = (result*397) ^ deviceGuid.GetHashCode();  				result = (result*397) ^ nonRootPath.GetHashCode();  				result = (result*397) ^ relDrive.GetHashCode();  				result = (result*397) ^ folderAndFiles.GetHashCode();  				return result;  			}
Magic Number,Castle.IO,StreamExtensions,C:\repos\castleproject_Castle.Transactions\src\Castle.IO\StreamExtensions.cs,CopyTo,The following statement contains a magic number: var buffer = new byte[4096];
Magic Number,Castle.IO.FileSystems,FileSystemNotificationIdentifier,C:\repos\castleproject_Castle.Transactions\src\Castle.IO\FileSystems\FileSystemNotificationIdentifier.cs,GetHashCode,The following statement contains a magic number: unchecked  			{  				var result = IncludeSubDirectories.GetHashCode();  				result = (result*397) ^ Path.GetHashCode();  				result = (result*397) ^ Filter.GetHashCode();  				result = (result*397) ^ ChangeTypes.GetHashCode();  				return result;  			}
Magic Number,Castle.IO.FileSystems,FileSystemNotificationIdentifier,C:\repos\castleproject_Castle.Transactions\src\Castle.IO\FileSystems\FileSystemNotificationIdentifier.cs,GetHashCode,The following statement contains a magic number: unchecked  			{  				var result = IncludeSubDirectories.GetHashCode();  				result = (result*397) ^ Path.GetHashCode();  				result = (result*397) ^ Filter.GetHashCode();  				result = (result*397) ^ ChangeTypes.GetHashCode();  				return result;  			}
Magic Number,Castle.IO.FileSystems,FileSystemNotificationIdentifier,C:\repos\castleproject_Castle.Transactions\src\Castle.IO\FileSystems\FileSystemNotificationIdentifier.cs,GetHashCode,The following statement contains a magic number: unchecked  			{  				var result = IncludeSubDirectories.GetHashCode();  				result = (result*397) ^ Path.GetHashCode();  				result = (result*397) ^ Filter.GetHashCode();  				result = (result*397) ^ ChangeTypes.GetHashCode();  				return result;  			}
Magic Number,Castle.IO.FileSystems.InMemory,InMemoryFile,C:\repos\castleproject_Castle.Transactions\src\Castle.IO\FileSystems\InMemory\InMemoryFile.cs,Resize,The following statement contains a magic number: lock (_contentLock)  			{  				if (_contentLength < offset)  					_contentLength = offset;  				if (_content.Length < _contentLength)  				{  					var buffer = new byte[_content.Length*2];  					Buffer.BlockCopy(_content' 0' buffer' 0' _content.Length);  					_content = buffer;  				}  			}
Magic Number,Castle.IO.FileSystems.InMemory,InMemoryFileSystem,C:\repos\castleproject_Castle.Transactions\src\Castle.IO\FileSystems\InMemory\InMemoryFileSystem.cs,GetFile,The following statement contains a magic number: var ownerFolder = pathSegments  				.Skip(1).Take(pathSegments.Count() - 2)  				.Aggregate((IDirectory) GetRoot(pathSegments.First())'  				           (current' segment) => current.GetDirectory(segment));
Magic Number,Castle.IO.FileSystems.Local,LocalFileSystem,C:\repos\castleproject_Castle.Transactions\src\Castle.IO\FileSystems\Local\LocalFileSystem.cs,CreatePlatformSpecificInstance,The following statement contains a magic number: if (platformId == 4 || platformId == 128 || platformId == (int) PlatformID.MacOSX)  				return UnixFileSystem();
Magic Number,Castle.IO.FileSystems.Local,LocalFileSystem,C:\repos\castleproject_Castle.Transactions\src\Castle.IO\FileSystems\Local\LocalFileSystem.cs,CreatePlatformSpecificInstance,The following statement contains a magic number: if (platformId == 4 || platformId == 128 || platformId == (int) PlatformID.MacOSX)  				return UnixFileSystem();
Magic Number,Castle.IO.FileSystems.Local.Win32.Interop,JunctionPoint,C:\repos\castleproject_Castle.Transactions\src\Castle.IO\FileSystems\Local\Win32\Interop\JunctionPoint.cs,Create,The following statement contains a magic number: using (var handle = OpenReparsePoint(junctionPoint.Path.FullPath' EFileAccess.GenericWrite))  			{  				var targetDirBytes = Encoding.Unicode.GetBytes(NonInterpretedPathPrefix + Path.GetFullPath(targetDir));    				var reparseDataBuffer = new REPARSE_DATA_BUFFER();    				reparseDataBuffer.ReparseTag = IO_REPARSE_TAG_MOUNT_POINT;  				reparseDataBuffer.ReparseDataLength = (ushort) (targetDirBytes.Length + 12);  				reparseDataBuffer.SubstituteNameOffset = 0;  				reparseDataBuffer.SubstituteNameLength = (ushort) targetDirBytes.Length;  				reparseDataBuffer.PrintNameOffset = (ushort) (targetDirBytes.Length + 2);  				reparseDataBuffer.PrintNameLength = 0;  				reparseDataBuffer.PathBuffer = new byte[0x3ff0];  				Array.Copy(targetDirBytes' reparseDataBuffer.PathBuffer' targetDirBytes.Length);    				var inBufferSize = Marshal.SizeOf(reparseDataBuffer);  				var inBuffer = Marshal.AllocHGlobal(inBufferSize);    				try  				{  					Marshal.StructureToPtr(reparseDataBuffer' inBuffer' false);    					int bytesReturned;  					var result = DeviceIoControl(handle.DangerousGetHandle()' FSCTL_SET_REPARSE_POINT'  					                             inBuffer' targetDirBytes.Length + 20' IntPtr.Zero' 0' out bytesReturned' IntPtr.Zero);    					if (!result)  						ThrowLastWin32Error("Unable to create junction point.");  				}  				finally  				{  					Marshal.FreeHGlobal(inBuffer);  				}  			}
Magic Number,Castle.IO.FileSystems.Local.Win32.Interop,JunctionPoint,C:\repos\castleproject_Castle.Transactions\src\Castle.IO\FileSystems\Local\Win32\Interop\JunctionPoint.cs,Create,The following statement contains a magic number: using (var handle = OpenReparsePoint(junctionPoint.Path.FullPath' EFileAccess.GenericWrite))  			{  				var targetDirBytes = Encoding.Unicode.GetBytes(NonInterpretedPathPrefix + Path.GetFullPath(targetDir));    				var reparseDataBuffer = new REPARSE_DATA_BUFFER();    				reparseDataBuffer.ReparseTag = IO_REPARSE_TAG_MOUNT_POINT;  				reparseDataBuffer.ReparseDataLength = (ushort) (targetDirBytes.Length + 12);  				reparseDataBuffer.SubstituteNameOffset = 0;  				reparseDataBuffer.SubstituteNameLength = (ushort) targetDirBytes.Length;  				reparseDataBuffer.PrintNameOffset = (ushort) (targetDirBytes.Length + 2);  				reparseDataBuffer.PrintNameLength = 0;  				reparseDataBuffer.PathBuffer = new byte[0x3ff0];  				Array.Copy(targetDirBytes' reparseDataBuffer.PathBuffer' targetDirBytes.Length);    				var inBufferSize = Marshal.SizeOf(reparseDataBuffer);  				var inBuffer = Marshal.AllocHGlobal(inBufferSize);    				try  				{  					Marshal.StructureToPtr(reparseDataBuffer' inBuffer' false);    					int bytesReturned;  					var result = DeviceIoControl(handle.DangerousGetHandle()' FSCTL_SET_REPARSE_POINT'  					                             inBuffer' targetDirBytes.Length + 20' IntPtr.Zero' 0' out bytesReturned' IntPtr.Zero);    					if (!result)  						ThrowLastWin32Error("Unable to create junction point.");  				}  				finally  				{  					Marshal.FreeHGlobal(inBuffer);  				}  			}
Magic Number,Castle.IO.FileSystems.Local.Win32.Interop,JunctionPoint,C:\repos\castleproject_Castle.Transactions\src\Castle.IO\FileSystems\Local\Win32\Interop\JunctionPoint.cs,Create,The following statement contains a magic number: using (var handle = OpenReparsePoint(junctionPoint.Path.FullPath' EFileAccess.GenericWrite))  			{  				var targetDirBytes = Encoding.Unicode.GetBytes(NonInterpretedPathPrefix + Path.GetFullPath(targetDir));    				var reparseDataBuffer = new REPARSE_DATA_BUFFER();    				reparseDataBuffer.ReparseTag = IO_REPARSE_TAG_MOUNT_POINT;  				reparseDataBuffer.ReparseDataLength = (ushort) (targetDirBytes.Length + 12);  				reparseDataBuffer.SubstituteNameOffset = 0;  				reparseDataBuffer.SubstituteNameLength = (ushort) targetDirBytes.Length;  				reparseDataBuffer.PrintNameOffset = (ushort) (targetDirBytes.Length + 2);  				reparseDataBuffer.PrintNameLength = 0;  				reparseDataBuffer.PathBuffer = new byte[0x3ff0];  				Array.Copy(targetDirBytes' reparseDataBuffer.PathBuffer' targetDirBytes.Length);    				var inBufferSize = Marshal.SizeOf(reparseDataBuffer);  				var inBuffer = Marshal.AllocHGlobal(inBufferSize);    				try  				{  					Marshal.StructureToPtr(reparseDataBuffer' inBuffer' false);    					int bytesReturned;  					var result = DeviceIoControl(handle.DangerousGetHandle()' FSCTL_SET_REPARSE_POINT'  					                             inBuffer' targetDirBytes.Length + 20' IntPtr.Zero' 0' out bytesReturned' IntPtr.Zero);    					if (!result)  						ThrowLastWin32Error("Unable to create junction point.");  				}  				finally  				{  					Marshal.FreeHGlobal(inBuffer);  				}  			}
Magic Number,Castle.IO.FileSystems.Local.Win32.Interop,JunctionPoint,C:\repos\castleproject_Castle.Transactions\src\Castle.IO\FileSystems\Local\Win32\Interop\JunctionPoint.cs,Delete,The following statement contains a magic number: using (var handle = OpenReparsePoint(junctionPoint' EFileAccess.GenericWrite))  			{  				var reparseDataBuffer = new REPARSE_DATA_BUFFER();    				reparseDataBuffer.ReparseTag = IO_REPARSE_TAG_MOUNT_POINT;  				reparseDataBuffer.ReparseDataLength = 0;  				reparseDataBuffer.PathBuffer = new byte[0x3ff0];    				var inBufferSize = Marshal.SizeOf(reparseDataBuffer);  				var inBuffer = Marshal.AllocHGlobal(inBufferSize);  				try  				{  					Marshal.StructureToPtr(reparseDataBuffer' inBuffer' false);    					int bytesReturned;  					var result = DeviceIoControl(handle.DangerousGetHandle()' FSCTL_DELETE_REPARSE_POINT'  					                             inBuffer' 8' IntPtr.Zero' 0' out bytesReturned' IntPtr.Zero);    					if (!result)  						ThrowLastWin32Error("Unable to delete junction point.");  				}  				finally  				{  					Marshal.FreeHGlobal(inBuffer);  				}    				try  				{  					Directory.Delete(junctionPoint);  				}  				catch (IOException ex)  				{  					throw new IOException("Unable to delete junction point."' ex);  				}  			}
Magic Number,Castle.IO.Internal,LongPathCommon,C:\repos\castleproject_Castle.Transactions\src\Castle.IO\Internal\LongPathCommon.cs,GetMessageFromErrorCode,The following statement contains a magic number: var buffer = new StringBuilder(512);
Magic Number,Castle.IO.Internal,LongPathFile,C:\repos\castleproject_Castle.Transactions\src\Castle.IO\Internal\LongPathFile.cs,Open,The following statement contains a magic number: const int DefaultBufferSize = 1024;
Missing Default,Castle.IO,PathInfo,C:\repos\castleproject_Castle.Transactions\src\Castle.IO\PathInfo.cs,IsParentOf,The following switch statement is missing a default case: switch (Type)  			{  				case PathType.Device:  					OK &= child.DeviceName.Equals(DeviceName' StringComparison.InvariantCultureIgnoreCase);  					break;  				case PathType.Server:  					OK &= child.ServerName.Equals(ServerName' StringComparison.InvariantCultureIgnoreCase);  					break;  				case PathType.IPv4:  					OK &= child.IPv4.Equals(IPv4);  					break;  				case PathType.IPv6:  					OK &= child.IPv6.Equals(IPv6);  					break;  				case PathType.Relative:  					throw new NotSupportedException("Since root isn't empty we should never get relative paths.");    				case PathType.Drive:  					OK &= DriveLetter.ToLowerInvariant() == child.DriveLetter.ToLowerInvariant();  					break;  			}
Missing Default,Castle.IO.FileSystems.InMemory,InMemoryFile,C:\repos\castleproject_Castle.Transactions\src\Castle.IO\FileSystems\InMemory\InMemoryFile.cs,ValidateFileMode,The following switch statement is missing a default case: switch (fileMode)  				{  					case FileMode.CreateNew:  						throw new IOException("File already exists.");  					case FileMode.Create:  					case FileMode.Truncate:  						_contentLength = 0;  						return 0;  					case FileMode.Open:  					case FileMode.OpenOrCreate:  						return 0;  					case FileMode.Append:  						return _contentLength;  				}
Missing Default,Castle.IO.FileSystems.InMemory,InMemoryFile,C:\repos\castleproject_Castle.Transactions\src\Castle.IO\FileSystems\InMemory\InMemoryFile.cs,ValidateFileMode,The following switch statement is missing a default case: switch (fileMode)  				{  					case FileMode.Create:  					case FileMode.Append:  					case FileMode.CreateNew:  					case FileMode.OpenOrCreate:  						EnsureExists();  						return _contentLength;  					case FileMode.Open:  					case FileMode.Truncate:  						throw new FileNotFoundException();  				}
