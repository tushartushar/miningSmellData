Implementation smell,Namespace,Class,File,Method,Description
Complex Method,Gdl,DockItem,C:\repos\SuperTuxTeam_supertux-editor\Dock\DockItem.cs,OnButtonPressEvent,Cyclomatic complexity of the method is 16
Complex Method,Gdl,DockItem,C:\repos\SuperTuxTeam_supertux-editor\Dock\DockItem.cs,OnDockRequest,Cyclomatic complexity of the method is 29
Complex Method,Gdl,DockItem,C:\repos\SuperTuxTeam_supertux-editor\Dock\DockItem.cs,OnDocked,Cyclomatic complexity of the method is 23
Complex Method,Gdl,DockItemGrip,C:\repos\SuperTuxTeam_supertux-editor\Dock\DockItemGrip.cs,OnPropertyChanged,Cyclomatic complexity of the method is 18
Complex Method,Gdl,DockItemGrip,C:\repos\SuperTuxTeam_supertux-editor\Dock\DockItemGrip.cs,OnSizeAllocated,Cyclomatic complexity of the method is 8
Complex Method,Gdl,DockLayout,C:\repos\SuperTuxTeam_supertux-editor\Dock\DockLayout.cs,UpdateItemsModel,Cyclomatic complexity of the method is 10
Complex Method,Gdl,DockLayout,C:\repos\SuperTuxTeam_supertux-editor\Dock\DockLayout.cs,RecursiveBuild,Cyclomatic complexity of the method is 10
Complex Method,Gdl,DockMaster,C:\repos\SuperTuxTeam_supertux-editor\Dock\DockMaster.cs,Add,Cyclomatic complexity of the method is 9
Complex Method,Gdl,DockMaster,C:\repos\SuperTuxTeam_supertux-editor\Dock\DockMaster.cs,Remove,Cyclomatic complexity of the method is 14
Complex Method,Gdl,DockMaster,C:\repos\SuperTuxTeam_supertux-editor\Dock\DockMaster.cs,OnDragMotion,Cyclomatic complexity of the method is 15
Complex Method,Gdl,DockObject,C:\repos\SuperTuxTeam_supertux-editor\Dock\DockObject.cs,Dock,Cyclomatic complexity of the method is 8
Complex Method,Gdl,DockPaned,C:\repos\SuperTuxTeam_supertux-editor\Dock\DockPaned.cs,OnDocked,Cyclomatic complexity of the method is 11
Complex Method,Gdl,DockPaned,C:\repos\SuperTuxTeam_supertux-editor\Dock\DockPaned.cs,OnDockRequest,Cyclomatic complexity of the method is 14
Long Parameter List,Gdl,Dock,C:\repos\SuperTuxTeam_supertux-editor\Dock\Dock.cs,Dock,The method has 6 parameters.
Long Parameter List,Gdl,Dock,C:\repos\SuperTuxTeam_supertux-editor\Dock\Dock.cs,AddFloatingItem,The method has 5 parameters.
Long Statement,Gdl,Dock,C:\repos\SuperTuxTeam_supertux-editor\Dock\Dock.cs,OnDockRequest,The length of the statement  "	/* Check if coordinates are in GdlDock widget. */if (relX > 0 && relX < alloc.Width && relY > 0 && relY < alloc.Height) { " is 121.
Long Statement,Gdl,DockItem,C:\repos\SuperTuxTeam_supertux-editor\Dock\DockItem.cs,OnRealized,The length of the statement  "	attributes.EventMask = (int)(Events | Gdk.EventMask.ExposureMask | Gdk.EventMask.Button1MotionMask | Gdk.EventMask.ButtonPressMask | Gdk.EventMask.ButtonReleaseMask); " is 166.
Long Statement,Gdl,DockItem,C:\repos\SuperTuxTeam_supertux-editor\Dock\DockItem.cs,OnRealized,The length of the statement  "	Gdk.WindowAttributesType attributes_mask = Gdk.WindowAttributesType.X | Gdk.WindowAttributesType.Y | Gdk.WindowAttributesType.Colormap | Gdk.WindowAttributesType.Visual; " is 169.
Long Statement,Gdl,DockItem,C:\repos\SuperTuxTeam_supertux-editor\Dock\DockItem.cs,OnDockRequest,The length of the statement  "		/* these are for calculating the extra docking parameter */Requisition other = ((DockItem)request.Applicant).PreferredSize; " is 123.
Long Statement,Gdl,DockItemGrip,C:\repos\SuperTuxTeam_supertux-editor\Dock\DockItemGrip.cs,OnExposeEvent,The length of the statement  "			GdkWindow.DrawPixbuf (gc' icon' 0' 0' pixbufRect.X' pixbufRect.Y' pixbufRect.Width' pixbufRect.Height' Gdk.RgbDither.None' 0' 0); " is 129.
Long Statement,Gdl,DockItemGrip,C:\repos\SuperTuxTeam_supertux-editor\Dock\DockItemGrip.cs,OnRealized,The length of the statement  "		attributes.EventMask = (int)(Events | Gdk.EventMask.ButtonPressMask | Gdk.EventMask.ButtonReleaseMask | Gdk.EventMask.ButtonMotionMask); " is 136.
Long Statement,Gdl,DockItemGrip,C:\repos\SuperTuxTeam_supertux-editor\Dock\DockItemGrip.cs,OnRealized,The length of the statement  "		titleWindow = new Gdk.Window (ParentWindow' attributes' (int)(Gdk.WindowAttributesType.X | Gdk.WindowAttributesType.Y | Gdk.WindowAttributesType.Noredir)); " is 155.
Long Statement,Gdl,DockMaster,C:\repos\SuperTuxTeam_supertux-editor\Dock\DockMaster.cs,Add,The length of the statement  "				 * and add the item to the corresponding hash */item.PropertyChanged += new PropertyChangedHandler (OnItemPropertyChanged); " is 122.
Long Statement,Gdl,DockMaster,C:\repos\SuperTuxTeam_supertux-editor\Dock\DockMaster.cs,OnDragMotion,The length of the statement  "	if (!(myRequest.X == request.X && myRequest.Y == request.Y && myRequest.Width == request.Width && myRequest.Height == request.Height && dock == rectOwner)) { " is 157.
Long Statement,Gdl,DockPaned,C:\repos\SuperTuxTeam_supertux-editor\Dock\DockPaned.cs,OnDockRequest,The length of the statement  "	/* Check if coordinates are inside the widget. */if (relX > 0 && relX < alloc.Width && relY > 0 && relY < alloc.Height) { " is 121.
Long Statement,Gdl,DockPaned,C:\repos\SuperTuxTeam_supertux-editor\Dock\DockPaned.cs,OnDockRequest,The length of the statement  "		/* these are for calculating the extra docking parameter */Requisition other = ((DockItem)request.Applicant).PreferredSize; " is 123.
Long Statement,Gdl,DockPlaceholder,C:\repos\SuperTuxTeam_supertux-editor\Dock\DockPlaceholder.cs,OnHostDetached,The length of the statement  "			Console.WriteLine ("Something weird happened while getting the child placement for {0} from parent {1}"' host' newHost); " is 120.
Complex Conditional,Gdl,Dock,C:\repos\SuperTuxTeam_supertux-editor\Dock\Dock.cs,OnDockRequest,The conditional expression  "relX > 0 && relX < alloc.Width && relY > 0 && relY < alloc.Height"  is complex.
Complex Conditional,Gdl,DockItem,C:\repos\SuperTuxTeam_supertux-editor\Dock\DockItem.cs,OnDockRequest,The conditional expression  "relX > 0 && relX < alloc.Width && relY > 0 && relY < alloc.Height"  is complex.
Complex Conditional,Gdl,DockMaster,C:\repos\SuperTuxTeam_supertux-editor\Dock\DockMaster.cs,OnDragMotion,The conditional expression  "rootX >= winX && rootX < winX + winW && rootY >= winY && rootY < winY + winH"  is complex.
Complex Conditional,Gdl,DockMaster,C:\repos\SuperTuxTeam_supertux-editor\Dock\DockMaster.cs,OnDragMotion,The conditional expression  "!(myRequest.X == request.X && myRequest.Y == request.Y && myRequest.Width == request.Width && myRequest.Height == request.Height && dock == rectOwner)"  is complex.
Complex Conditional,Gdl,DockPaned,C:\repos\SuperTuxTeam_supertux-editor\Dock\DockPaned.cs,OnDockRequest,The conditional expression  "relX > 0 && relX < alloc.Width && relY > 0 && relY < alloc.Height"  is complex.
Complex Conditional,Gdl,DockPlaceholder,C:\repos\SuperTuxTeam_supertux-editor\Dock\DockPlaceholder.cs,DoExcursion,The conditional expression  "host != null && !Sticky && placementStack != null && placementStack.Count > 0 && host.IsCompound"  is complex.
Magic Number,Gdl,Dock,C:\repos\SuperTuxTeam_supertux-editor\Dock\Dock.cs,OnSizeRequested,The following statement contains a magic number: requisition.Width += 2 * (int)BorderWidth;  
Magic Number,Gdl,Dock,C:\repos\SuperTuxTeam_supertux-editor\Dock\Dock.cs,OnSizeRequested,The following statement contains a magic number: requisition.Height += 2 * (int)BorderWidth;  
Magic Number,Gdl,Dock,C:\repos\SuperTuxTeam_supertux-editor\Dock\Dock.cs,OnSizeAllocated,The following statement contains a magic number: allocation.Width = Math.Max (1' allocation.Width - 2 * bw);  
Magic Number,Gdl,Dock,C:\repos\SuperTuxTeam_supertux-editor\Dock\Dock.cs,OnSizeAllocated,The following statement contains a magic number: allocation.Height = Math.Max (1' allocation.Height - 2 * bw);  
Magic Number,Gdl,Dock,C:\repos\SuperTuxTeam_supertux-editor\Dock\Dock.cs,OnDockRequest,The following statement contains a magic number: if (relX > 0 && relX < alloc.Width && relY > 0 && relY < alloc.Height) {  	/* It's inside our area. */mayDock = true;  	/* Set docking indicator rectangle to the Dock size. */request.X = alloc.X + bw;  	request.Y = alloc.Y + bw;  	request.Width = alloc.Width - 2 * bw;  	request.Height = alloc.Height - 2 * bw;  	/* If Dock has no root item yet' set the dock 				   itself as possible target. */if (root == null) {  		request.Position = DockPlacement.Top;  		request.Target = this;  	}  	else {  		request.Target = root;  		/* See if it's in the BorderWidth band. */if (relX < bw) {  			request.Position = DockPlacement.Left;  			request.Width = (int)(request.Width * SplitRatio);  		}  		else if (relX > alloc.Width - bw) {  			request.Position = DockPlacement.Right;  			request.X += (int)(request.Width * (1 - SplitRatio));  			request.Width = (int)(request.Width * SplitRatio);  		}  		else if (relY < bw) {  			request.Position = DockPlacement.Top;  			request.Height = (int)(request.Height * SplitRatio);  		}  		else if (relY > alloc.Height - bw) {  			request.Position = DockPlacement.Bottom;  			request.Y += (int)(request.Height * (1 - SplitRatio));  			request.Height = (int)(request.Height * SplitRatio);  		}  		else {  			/* Otherwise try our children. *//* give them allocation coordinates 						   (we are a NoWindow widget) */mayDock = root.OnDockRequest (x' y' ref request);  		}  	}  }  
Magic Number,Gdl,Dock,C:\repos\SuperTuxTeam_supertux-editor\Dock\Dock.cs,OnDockRequest,The following statement contains a magic number: if (relX > 0 && relX < alloc.Width && relY > 0 && relY < alloc.Height) {  	/* It's inside our area. */mayDock = true;  	/* Set docking indicator rectangle to the Dock size. */request.X = alloc.X + bw;  	request.Y = alloc.Y + bw;  	request.Width = alloc.Width - 2 * bw;  	request.Height = alloc.Height - 2 * bw;  	/* If Dock has no root item yet' set the dock 				   itself as possible target. */if (root == null) {  		request.Position = DockPlacement.Top;  		request.Target = this;  	}  	else {  		request.Target = root;  		/* See if it's in the BorderWidth band. */if (relX < bw) {  			request.Position = DockPlacement.Left;  			request.Width = (int)(request.Width * SplitRatio);  		}  		else if (relX > alloc.Width - bw) {  			request.Position = DockPlacement.Right;  			request.X += (int)(request.Width * (1 - SplitRatio));  			request.Width = (int)(request.Width * SplitRatio);  		}  		else if (relY < bw) {  			request.Position = DockPlacement.Top;  			request.Height = (int)(request.Height * SplitRatio);  		}  		else if (relY > alloc.Height - bw) {  			request.Position = DockPlacement.Bottom;  			request.Y += (int)(request.Height * (1 - SplitRatio));  			request.Height = (int)(request.Height * SplitRatio);  		}  		else {  			/* Otherwise try our children. *//* give them allocation coordinates 						   (we are a NoWindow widget) */mayDock = root.OnDockRequest (x' y' ref request);  		}  	}  }  
Magic Number,Gdl,Dock,C:\repos\SuperTuxTeam_supertux-editor\Dock\Dock.cs,OnDockRequest,The following statement contains a magic number: request.Width = alloc.Width - 2 * bw;  
Magic Number,Gdl,Dock,C:\repos\SuperTuxTeam_supertux-editor\Dock\Dock.cs,OnDockRequest,The following statement contains a magic number: request.Height = alloc.Height - 2 * bw;  
Magic Number,Gdl,Dock,C:\repos\SuperTuxTeam_supertux-editor\Dock\Dock.cs,XorRect,The following statement contains a magic number: xorGC.SetDashes (1' new sbyte[] {  	1'  	1  }' 2);  
Magic Number,Gdl,Dock,C:\repos\SuperTuxTeam_supertux-editor\Dock\Dock.cs,XorRect,The following statement contains a magic number: xorGC.SetDashes (0' new sbyte[] {  	1'  	1  }' 2);  
Magic Number,Gdl,Dock,C:\repos\SuperTuxTeam_supertux-editor\Dock\Dock.cs,XorRect,The following statement contains a magic number: GdkWindow.DrawRectangle (xorGC' false' rect.X + 1' rect.Y + 1' rect.Width - 2' rect.Height - 2);  
Magic Number,Gdl,Dock,C:\repos\SuperTuxTeam_supertux-editor\Dock\Dock.cs,XorRect,The following statement contains a magic number: GdkWindow.DrawRectangle (xorGC' false' rect.X + 1' rect.Y + 1' rect.Width - 2' rect.Height - 2);  
Magic Number,Gdl,DockItem,C:\repos\SuperTuxTeam_supertux-editor\Dock\DockItem.cs,OnSizeRequested,The following statement contains a magic number: requisition.Width = ((int)BorderWidth + Style.XThickness) * 2;  
Magic Number,Gdl,DockItem,C:\repos\SuperTuxTeam_supertux-editor\Dock\DockItem.cs,OnSizeRequested,The following statement contains a magic number: requisition.Height = ((int)BorderWidth + Style.YThickness) * 2;  
Magic Number,Gdl,DockItem,C:\repos\SuperTuxTeam_supertux-editor\Dock\DockItem.cs,OnSizeRequested,The following statement contains a magic number: requisition.Width += (int)(this.BorderWidth + this.Style.XThickness) * 2;  
Magic Number,Gdl,DockItem,C:\repos\SuperTuxTeam_supertux-editor\Dock\DockItem.cs,OnSizeRequested,The following statement contains a magic number: requisition.Height += (int)(this.BorderWidth + this.Style.XThickness) * 2;  
Magic Number,Gdl,DockItem,C:\repos\SuperTuxTeam_supertux-editor\Dock\DockItem.cs,OnSizeAllocated,The following statement contains a magic number: if (Child != null && Child.Visible) {  	int bw = (int)BorderWidth;  	Gdk.Rectangle childAlloc;  	childAlloc.X = bw + Style.XThickness;  	childAlloc.Y = bw + Style.YThickness;  	childAlloc.Width = allocation.Width - 2 * (bw + Style.XThickness);  	childAlloc.Height = allocation.Height - 2 * (bw + Style.YThickness);  	if (GripShown) {  		Gdk.Rectangle gripAlloc = childAlloc;  		Requisition gripReq = grip.SizeRequest ();  		if (Orientation == Orientation.Horizontal) {  			childAlloc.X += gripReq.Width;  			childAlloc.Width -= gripReq.Width;  			gripAlloc.Width = gripReq.Width;  		}  		else {  			childAlloc.Y += gripReq.Height;  			childAlloc.Height -= gripReq.Height;  			gripAlloc.Height = gripReq.Height;  		}  		grip.SizeAllocate (gripAlloc);  	}  	Child.SizeAllocate (childAlloc);  }  
Magic Number,Gdl,DockItem,C:\repos\SuperTuxTeam_supertux-editor\Dock\DockItem.cs,OnSizeAllocated,The following statement contains a magic number: if (Child != null && Child.Visible) {  	int bw = (int)BorderWidth;  	Gdk.Rectangle childAlloc;  	childAlloc.X = bw + Style.XThickness;  	childAlloc.Y = bw + Style.YThickness;  	childAlloc.Width = allocation.Width - 2 * (bw + Style.XThickness);  	childAlloc.Height = allocation.Height - 2 * (bw + Style.YThickness);  	if (GripShown) {  		Gdk.Rectangle gripAlloc = childAlloc;  		Requisition gripReq = grip.SizeRequest ();  		if (Orientation == Orientation.Horizontal) {  			childAlloc.X += gripReq.Width;  			childAlloc.Width -= gripReq.Width;  			gripAlloc.Width = gripReq.Width;  		}  		else {  			childAlloc.Y += gripReq.Height;  			childAlloc.Height -= gripReq.Height;  			gripAlloc.Height = gripReq.Height;  		}  		grip.SizeAllocate (gripAlloc);  	}  	Child.SizeAllocate (childAlloc);  }  
Magic Number,Gdl,DockItem,C:\repos\SuperTuxTeam_supertux-editor\Dock\DockItem.cs,OnSizeAllocated,The following statement contains a magic number: childAlloc.Width = allocation.Width - 2 * (bw + Style.XThickness);  
Magic Number,Gdl,DockItem,C:\repos\SuperTuxTeam_supertux-editor\Dock\DockItem.cs,OnSizeAllocated,The following statement contains a magic number: childAlloc.Height = allocation.Height - 2 * (bw + Style.YThickness);  
Magic Number,Gdl,DockItem,C:\repos\SuperTuxTeam_supertux-editor\Dock\DockItem.cs,OnButtonPressEvent,The following statement contains a magic number: if (!Locked && evnt.Button == 1 && evnt.Type == Gdk.EventType.ButtonPress) {  	/* Set in_drag flag' grab pointer and call begin drag operation. */if (inHandle) {  		startX = (int)evnt.X;  		startY = (int)evnt.Y;  		DockObjectFlags |= DockObjectFlags.InPreDrag;  		cursor = new Gdk.Cursor (Display' Gdk.CursorType.Fleur);  		grip.TitleWindow.Cursor = cursor;  		eventHandled = true;  	}  }  else if (!Locked && evnt.Type == Gdk.EventType.ButtonRelease && evnt.Button == 1) {  	if (InDrag) {  		/* User dropped widget somewhere. */EndDrag (false);  		eventHandled = true;  	}  	else if (InPreDrag) {  		DockObjectFlags &= ~(DockObjectFlags.InPreDrag);  		eventHandled = true;  	}  	/* we check the window since if the item was redocked it's 				   been unrealized and maybe it's not realized again yet */if (grip.TitleWindow != null) {  		cursor = new Gdk.Cursor (Display' Gdk.CursorType.Hand2);  		grip.TitleWindow.Cursor = cursor;  	}  }  else if (evnt.Button == 3 && evnt.Type == Gdk.EventType.ButtonPress && inHandle) {  	DockPopupMenu (evnt.Button' evnt.Time);  	eventHandled = true;  }  
Magic Number,Gdl,DockItem,C:\repos\SuperTuxTeam_supertux-editor\Dock\DockItem.cs,OnButtonPressEvent,The following statement contains a magic number: if (!Locked && evnt.Type == Gdk.EventType.ButtonRelease && evnt.Button == 1) {  	if (InDrag) {  		/* User dropped widget somewhere. */EndDrag (false);  		eventHandled = true;  	}  	else if (InPreDrag) {  		DockObjectFlags &= ~(DockObjectFlags.InPreDrag);  		eventHandled = true;  	}  	/* we check the window since if the item was redocked it's 				   been unrealized and maybe it's not realized again yet */if (grip.TitleWindow != null) {  		cursor = new Gdk.Cursor (Display' Gdk.CursorType.Hand2);  		grip.TitleWindow.Cursor = cursor;  	}  }  else if (evnt.Button == 3 && evnt.Type == Gdk.EventType.ButtonPress && inHandle) {  	DockPopupMenu (evnt.Button' evnt.Time);  	eventHandled = true;  }  
Magic Number,Gdl,DockItem,C:\repos\SuperTuxTeam_supertux-editor\Dock\DockItem.cs,OnButtonPressEvent,The following statement contains a magic number: if (evnt.Button == 3 && evnt.Type == Gdk.EventType.ButtonPress && inHandle) {  	DockPopupMenu (evnt.Button' evnt.Time);  	eventHandled = true;  }  
Magic Number,Gdl,DockItem,C:\repos\SuperTuxTeam_supertux-editor\Dock\DockItem.cs,OnDockRequest,The following statement contains a magic number: if (relX > 0 && relX < alloc.Width && relY > 0 && relY < alloc.Height) {  	int divider = -1;  	/* these are for calculating the extra docking parameter */Requisition other = ((DockItem)request.Applicant).PreferredSize;  	Requisition my = PreferredSize;  	/* Calculate location in terms of the available space (0-100%). */float rx = (float)relX / alloc.Width;  	float ry = (float)relY / alloc.Height;  	/* Determine dock location. */if (rx < SplitRatio) {  		request.Position = DockPlacement.Left;  		divider = other.Width;  	}  	else if (rx > (1 - SplitRatio)) {  		request.Position = DockPlacement.Right;  		rx = 1 - rx;  		divider = Math.Max (0' my.Width - other.Width);  	}  	else if (ry < SplitRatio && ry < rx) {  		request.Position = DockPlacement.Top;  		divider = other.Height;  	}  	else if (ry > (1 - SplitRatio) && (1 - ry) < rx) {  		request.Position = DockPlacement.Bottom;  		divider = Math.Max (0' my.Height - other.Height);  	}  	else {  		request.Position = DockPlacement.Center;  	}  	/* Reset rectangle coordinates to entire item. */request.X = 0;  	request.Y = 0;  	request.Width = alloc.Width;  	request.Height = alloc.Height;  	/* Calculate docking indicator rectangle size for new locations. 				   Only do this when we're not over the item's current location. */if (request.Applicant != this) {  		switch (request.Position) {  		case DockPlacement.Top:  			request.Height = (int)(request.Height * SplitRatio);  			break;  		case DockPlacement.Bottom:  			request.Y += (int)(request.Height * (1 - SplitRatio));  			request.Height = (int)(request.Height * SplitRatio);  			break;  		case DockPlacement.Left:  			request.Width = (int)(request.Width * SplitRatio);  			break;  		case DockPlacement.Right:  			request.X += (int)(request.Width * (1 - SplitRatio));  			request.Width = (int)(request.Width * SplitRatio);  			break;  		case DockPlacement.Center:  			request.X = (int)(request.Width * SplitRatio / 2);  			request.Y = (int)(request.Height * SplitRatio / 2);  			request.Width = (int)(request.Width * (1 - SplitRatio / 2)) - request.X;  			request.Height = (int)(request.Height * (1 - SplitRatio / 2)) - request.Y;  			break;  		default:  			break;  		}  	}  	/* adjust returned coordinates so they have the same 				   origin as our window */request.X += alloc.X;  	request.Y += alloc.Y;  	/* Set possible target location and return true. */request.Target = this;  	/* fill-in other dock information */if (request.Position != DockPlacement.Center && divider >= 0)  		request.Extra = divider;  	return true;  }  else {  	/* No docking possible at this location. */return false;  }  
Magic Number,Gdl,DockItem,C:\repos\SuperTuxTeam_supertux-editor\Dock\DockItem.cs,OnDockRequest,The following statement contains a magic number: if (relX > 0 && relX < alloc.Width && relY > 0 && relY < alloc.Height) {  	int divider = -1;  	/* these are for calculating the extra docking parameter */Requisition other = ((DockItem)request.Applicant).PreferredSize;  	Requisition my = PreferredSize;  	/* Calculate location in terms of the available space (0-100%). */float rx = (float)relX / alloc.Width;  	float ry = (float)relY / alloc.Height;  	/* Determine dock location. */if (rx < SplitRatio) {  		request.Position = DockPlacement.Left;  		divider = other.Width;  	}  	else if (rx > (1 - SplitRatio)) {  		request.Position = DockPlacement.Right;  		rx = 1 - rx;  		divider = Math.Max (0' my.Width - other.Width);  	}  	else if (ry < SplitRatio && ry < rx) {  		request.Position = DockPlacement.Top;  		divider = other.Height;  	}  	else if (ry > (1 - SplitRatio) && (1 - ry) < rx) {  		request.Position = DockPlacement.Bottom;  		divider = Math.Max (0' my.Height - other.Height);  	}  	else {  		request.Position = DockPlacement.Center;  	}  	/* Reset rectangle coordinates to entire item. */request.X = 0;  	request.Y = 0;  	request.Width = alloc.Width;  	request.Height = alloc.Height;  	/* Calculate docking indicator rectangle size for new locations. 				   Only do this when we're not over the item's current location. */if (request.Applicant != this) {  		switch (request.Position) {  		case DockPlacement.Top:  			request.Height = (int)(request.Height * SplitRatio);  			break;  		case DockPlacement.Bottom:  			request.Y += (int)(request.Height * (1 - SplitRatio));  			request.Height = (int)(request.Height * SplitRatio);  			break;  		case DockPlacement.Left:  			request.Width = (int)(request.Width * SplitRatio);  			break;  		case DockPlacement.Right:  			request.X += (int)(request.Width * (1 - SplitRatio));  			request.Width = (int)(request.Width * SplitRatio);  			break;  		case DockPlacement.Center:  			request.X = (int)(request.Width * SplitRatio / 2);  			request.Y = (int)(request.Height * SplitRatio / 2);  			request.Width = (int)(request.Width * (1 - SplitRatio / 2)) - request.X;  			request.Height = (int)(request.Height * (1 - SplitRatio / 2)) - request.Y;  			break;  		default:  			break;  		}  	}  	/* adjust returned coordinates so they have the same 				   origin as our window */request.X += alloc.X;  	request.Y += alloc.Y;  	/* Set possible target location and return true. */request.Target = this;  	/* fill-in other dock information */if (request.Position != DockPlacement.Center && divider >= 0)  		request.Extra = divider;  	return true;  }  else {  	/* No docking possible at this location. */return false;  }  
Magic Number,Gdl,DockItem,C:\repos\SuperTuxTeam_supertux-editor\Dock\DockItem.cs,OnDockRequest,The following statement contains a magic number: if (relX > 0 && relX < alloc.Width && relY > 0 && relY < alloc.Height) {  	int divider = -1;  	/* these are for calculating the extra docking parameter */Requisition other = ((DockItem)request.Applicant).PreferredSize;  	Requisition my = PreferredSize;  	/* Calculate location in terms of the available space (0-100%). */float rx = (float)relX / alloc.Width;  	float ry = (float)relY / alloc.Height;  	/* Determine dock location. */if (rx < SplitRatio) {  		request.Position = DockPlacement.Left;  		divider = other.Width;  	}  	else if (rx > (1 - SplitRatio)) {  		request.Position = DockPlacement.Right;  		rx = 1 - rx;  		divider = Math.Max (0' my.Width - other.Width);  	}  	else if (ry < SplitRatio && ry < rx) {  		request.Position = DockPlacement.Top;  		divider = other.Height;  	}  	else if (ry > (1 - SplitRatio) && (1 - ry) < rx) {  		request.Position = DockPlacement.Bottom;  		divider = Math.Max (0' my.Height - other.Height);  	}  	else {  		request.Position = DockPlacement.Center;  	}  	/* Reset rectangle coordinates to entire item. */request.X = 0;  	request.Y = 0;  	request.Width = alloc.Width;  	request.Height = alloc.Height;  	/* Calculate docking indicator rectangle size for new locations. 				   Only do this when we're not over the item's current location. */if (request.Applicant != this) {  		switch (request.Position) {  		case DockPlacement.Top:  			request.Height = (int)(request.Height * SplitRatio);  			break;  		case DockPlacement.Bottom:  			request.Y += (int)(request.Height * (1 - SplitRatio));  			request.Height = (int)(request.Height * SplitRatio);  			break;  		case DockPlacement.Left:  			request.Width = (int)(request.Width * SplitRatio);  			break;  		case DockPlacement.Right:  			request.X += (int)(request.Width * (1 - SplitRatio));  			request.Width = (int)(request.Width * SplitRatio);  			break;  		case DockPlacement.Center:  			request.X = (int)(request.Width * SplitRatio / 2);  			request.Y = (int)(request.Height * SplitRatio / 2);  			request.Width = (int)(request.Width * (1 - SplitRatio / 2)) - request.X;  			request.Height = (int)(request.Height * (1 - SplitRatio / 2)) - request.Y;  			break;  		default:  			break;  		}  	}  	/* adjust returned coordinates so they have the same 				   origin as our window */request.X += alloc.X;  	request.Y += alloc.Y;  	/* Set possible target location and return true. */request.Target = this;  	/* fill-in other dock information */if (request.Position != DockPlacement.Center && divider >= 0)  		request.Extra = divider;  	return true;  }  else {  	/* No docking possible at this location. */return false;  }  
Magic Number,Gdl,DockItem,C:\repos\SuperTuxTeam_supertux-editor\Dock\DockItem.cs,OnDockRequest,The following statement contains a magic number: if (relX > 0 && relX < alloc.Width && relY > 0 && relY < alloc.Height) {  	int divider = -1;  	/* these are for calculating the extra docking parameter */Requisition other = ((DockItem)request.Applicant).PreferredSize;  	Requisition my = PreferredSize;  	/* Calculate location in terms of the available space (0-100%). */float rx = (float)relX / alloc.Width;  	float ry = (float)relY / alloc.Height;  	/* Determine dock location. */if (rx < SplitRatio) {  		request.Position = DockPlacement.Left;  		divider = other.Width;  	}  	else if (rx > (1 - SplitRatio)) {  		request.Position = DockPlacement.Right;  		rx = 1 - rx;  		divider = Math.Max (0' my.Width - other.Width);  	}  	else if (ry < SplitRatio && ry < rx) {  		request.Position = DockPlacement.Top;  		divider = other.Height;  	}  	else if (ry > (1 - SplitRatio) && (1 - ry) < rx) {  		request.Position = DockPlacement.Bottom;  		divider = Math.Max (0' my.Height - other.Height);  	}  	else {  		request.Position = DockPlacement.Center;  	}  	/* Reset rectangle coordinates to entire item. */request.X = 0;  	request.Y = 0;  	request.Width = alloc.Width;  	request.Height = alloc.Height;  	/* Calculate docking indicator rectangle size for new locations. 				   Only do this when we're not over the item's current location. */if (request.Applicant != this) {  		switch (request.Position) {  		case DockPlacement.Top:  			request.Height = (int)(request.Height * SplitRatio);  			break;  		case DockPlacement.Bottom:  			request.Y += (int)(request.Height * (1 - SplitRatio));  			request.Height = (int)(request.Height * SplitRatio);  			break;  		case DockPlacement.Left:  			request.Width = (int)(request.Width * SplitRatio);  			break;  		case DockPlacement.Right:  			request.X += (int)(request.Width * (1 - SplitRatio));  			request.Width = (int)(request.Width * SplitRatio);  			break;  		case DockPlacement.Center:  			request.X = (int)(request.Width * SplitRatio / 2);  			request.Y = (int)(request.Height * SplitRatio / 2);  			request.Width = (int)(request.Width * (1 - SplitRatio / 2)) - request.X;  			request.Height = (int)(request.Height * (1 - SplitRatio / 2)) - request.Y;  			break;  		default:  			break;  		}  	}  	/* adjust returned coordinates so they have the same 				   origin as our window */request.X += alloc.X;  	request.Y += alloc.Y;  	/* Set possible target location and return true. */request.Target = this;  	/* fill-in other dock information */if (request.Position != DockPlacement.Center && divider >= 0)  		request.Extra = divider;  	return true;  }  else {  	/* No docking possible at this location. */return false;  }  
Magic Number,Gdl,DockItem,C:\repos\SuperTuxTeam_supertux-editor\Dock\DockItem.cs,OnDockRequest,The following statement contains a magic number: if (request.Applicant != this) {  	switch (request.Position) {  	case DockPlacement.Top:  		request.Height = (int)(request.Height * SplitRatio);  		break;  	case DockPlacement.Bottom:  		request.Y += (int)(request.Height * (1 - SplitRatio));  		request.Height = (int)(request.Height * SplitRatio);  		break;  	case DockPlacement.Left:  		request.Width = (int)(request.Width * SplitRatio);  		break;  	case DockPlacement.Right:  		request.X += (int)(request.Width * (1 - SplitRatio));  		request.Width = (int)(request.Width * SplitRatio);  		break;  	case DockPlacement.Center:  		request.X = (int)(request.Width * SplitRatio / 2);  		request.Y = (int)(request.Height * SplitRatio / 2);  		request.Width = (int)(request.Width * (1 - SplitRatio / 2)) - request.X;  		request.Height = (int)(request.Height * (1 - SplitRatio / 2)) - request.Y;  		break;  	default:  		break;  	}  }  
Magic Number,Gdl,DockItem,C:\repos\SuperTuxTeam_supertux-editor\Dock\DockItem.cs,OnDockRequest,The following statement contains a magic number: if (request.Applicant != this) {  	switch (request.Position) {  	case DockPlacement.Top:  		request.Height = (int)(request.Height * SplitRatio);  		break;  	case DockPlacement.Bottom:  		request.Y += (int)(request.Height * (1 - SplitRatio));  		request.Height = (int)(request.Height * SplitRatio);  		break;  	case DockPlacement.Left:  		request.Width = (int)(request.Width * SplitRatio);  		break;  	case DockPlacement.Right:  		request.X += (int)(request.Width * (1 - SplitRatio));  		request.Width = (int)(request.Width * SplitRatio);  		break;  	case DockPlacement.Center:  		request.X = (int)(request.Width * SplitRatio / 2);  		request.Y = (int)(request.Height * SplitRatio / 2);  		request.Width = (int)(request.Width * (1 - SplitRatio / 2)) - request.X;  		request.Height = (int)(request.Height * (1 - SplitRatio / 2)) - request.Y;  		break;  	default:  		break;  	}  }  
Magic Number,Gdl,DockItem,C:\repos\SuperTuxTeam_supertux-editor\Dock\DockItem.cs,OnDockRequest,The following statement contains a magic number: if (request.Applicant != this) {  	switch (request.Position) {  	case DockPlacement.Top:  		request.Height = (int)(request.Height * SplitRatio);  		break;  	case DockPlacement.Bottom:  		request.Y += (int)(request.Height * (1 - SplitRatio));  		request.Height = (int)(request.Height * SplitRatio);  		break;  	case DockPlacement.Left:  		request.Width = (int)(request.Width * SplitRatio);  		break;  	case DockPlacement.Right:  		request.X += (int)(request.Width * (1 - SplitRatio));  		request.Width = (int)(request.Width * SplitRatio);  		break;  	case DockPlacement.Center:  		request.X = (int)(request.Width * SplitRatio / 2);  		request.Y = (int)(request.Height * SplitRatio / 2);  		request.Width = (int)(request.Width * (1 - SplitRatio / 2)) - request.X;  		request.Height = (int)(request.Height * (1 - SplitRatio / 2)) - request.Y;  		break;  	default:  		break;  	}  }  
Magic Number,Gdl,DockItem,C:\repos\SuperTuxTeam_supertux-editor\Dock\DockItem.cs,OnDockRequest,The following statement contains a magic number: if (request.Applicant != this) {  	switch (request.Position) {  	case DockPlacement.Top:  		request.Height = (int)(request.Height * SplitRatio);  		break;  	case DockPlacement.Bottom:  		request.Y += (int)(request.Height * (1 - SplitRatio));  		request.Height = (int)(request.Height * SplitRatio);  		break;  	case DockPlacement.Left:  		request.Width = (int)(request.Width * SplitRatio);  		break;  	case DockPlacement.Right:  		request.X += (int)(request.Width * (1 - SplitRatio));  		request.Width = (int)(request.Width * SplitRatio);  		break;  	case DockPlacement.Center:  		request.X = (int)(request.Width * SplitRatio / 2);  		request.Y = (int)(request.Height * SplitRatio / 2);  		request.Width = (int)(request.Width * (1 - SplitRatio / 2)) - request.X;  		request.Height = (int)(request.Height * (1 - SplitRatio / 2)) - request.Y;  		break;  	default:  		break;  	}  }  
Magic Number,Gdl,DockItem,C:\repos\SuperTuxTeam_supertux-editor\Dock\DockItem.cs,OnDockRequest,The following statement contains a magic number: switch (request.Position) {  case DockPlacement.Top:  	request.Height = (int)(request.Height * SplitRatio);  	break;  case DockPlacement.Bottom:  	request.Y += (int)(request.Height * (1 - SplitRatio));  	request.Height = (int)(request.Height * SplitRatio);  	break;  case DockPlacement.Left:  	request.Width = (int)(request.Width * SplitRatio);  	break;  case DockPlacement.Right:  	request.X += (int)(request.Width * (1 - SplitRatio));  	request.Width = (int)(request.Width * SplitRatio);  	break;  case DockPlacement.Center:  	request.X = (int)(request.Width * SplitRatio / 2);  	request.Y = (int)(request.Height * SplitRatio / 2);  	request.Width = (int)(request.Width * (1 - SplitRatio / 2)) - request.X;  	request.Height = (int)(request.Height * (1 - SplitRatio / 2)) - request.Y;  	break;  default:  	break;  }  
Magic Number,Gdl,DockItem,C:\repos\SuperTuxTeam_supertux-editor\Dock\DockItem.cs,OnDockRequest,The following statement contains a magic number: switch (request.Position) {  case DockPlacement.Top:  	request.Height = (int)(request.Height * SplitRatio);  	break;  case DockPlacement.Bottom:  	request.Y += (int)(request.Height * (1 - SplitRatio));  	request.Height = (int)(request.Height * SplitRatio);  	break;  case DockPlacement.Left:  	request.Width = (int)(request.Width * SplitRatio);  	break;  case DockPlacement.Right:  	request.X += (int)(request.Width * (1 - SplitRatio));  	request.Width = (int)(request.Width * SplitRatio);  	break;  case DockPlacement.Center:  	request.X = (int)(request.Width * SplitRatio / 2);  	request.Y = (int)(request.Height * SplitRatio / 2);  	request.Width = (int)(request.Width * (1 - SplitRatio / 2)) - request.X;  	request.Height = (int)(request.Height * (1 - SplitRatio / 2)) - request.Y;  	break;  default:  	break;  }  
Magic Number,Gdl,DockItem,C:\repos\SuperTuxTeam_supertux-editor\Dock\DockItem.cs,OnDockRequest,The following statement contains a magic number: switch (request.Position) {  case DockPlacement.Top:  	request.Height = (int)(request.Height * SplitRatio);  	break;  case DockPlacement.Bottom:  	request.Y += (int)(request.Height * (1 - SplitRatio));  	request.Height = (int)(request.Height * SplitRatio);  	break;  case DockPlacement.Left:  	request.Width = (int)(request.Width * SplitRatio);  	break;  case DockPlacement.Right:  	request.X += (int)(request.Width * (1 - SplitRatio));  	request.Width = (int)(request.Width * SplitRatio);  	break;  case DockPlacement.Center:  	request.X = (int)(request.Width * SplitRatio / 2);  	request.Y = (int)(request.Height * SplitRatio / 2);  	request.Width = (int)(request.Width * (1 - SplitRatio / 2)) - request.X;  	request.Height = (int)(request.Height * (1 - SplitRatio / 2)) - request.Y;  	break;  default:  	break;  }  
Magic Number,Gdl,DockItem,C:\repos\SuperTuxTeam_supertux-editor\Dock\DockItem.cs,OnDockRequest,The following statement contains a magic number: switch (request.Position) {  case DockPlacement.Top:  	request.Height = (int)(request.Height * SplitRatio);  	break;  case DockPlacement.Bottom:  	request.Y += (int)(request.Height * (1 - SplitRatio));  	request.Height = (int)(request.Height * SplitRatio);  	break;  case DockPlacement.Left:  	request.Width = (int)(request.Width * SplitRatio);  	break;  case DockPlacement.Right:  	request.X += (int)(request.Width * (1 - SplitRatio));  	request.Width = (int)(request.Width * SplitRatio);  	break;  case DockPlacement.Center:  	request.X = (int)(request.Width * SplitRatio / 2);  	request.Y = (int)(request.Height * SplitRatio / 2);  	request.Width = (int)(request.Width * (1 - SplitRatio / 2)) - request.X;  	request.Height = (int)(request.Height * (1 - SplitRatio / 2)) - request.Y;  	break;  default:  	break;  }  
Magic Number,Gdl,DockItem,C:\repos\SuperTuxTeam_supertux-editor\Dock\DockItem.cs,OnDockRequest,The following statement contains a magic number: request.X = (int)(request.Width * SplitRatio / 2);  
Magic Number,Gdl,DockItem,C:\repos\SuperTuxTeam_supertux-editor\Dock\DockItem.cs,OnDockRequest,The following statement contains a magic number: request.Y = (int)(request.Height * SplitRatio / 2);  
Magic Number,Gdl,DockItem,C:\repos\SuperTuxTeam_supertux-editor\Dock\DockItem.cs,OnDockRequest,The following statement contains a magic number: request.Width = (int)(request.Width * (1 - SplitRatio / 2)) - request.X;  
Magic Number,Gdl,DockItem,C:\repos\SuperTuxTeam_supertux-editor\Dock\DockItem.cs,OnDockRequest,The following statement contains a magic number: request.Height = (int)(request.Height * (1 - SplitRatio / 2)) - request.Y;  
Magic Number,Gdl,DockItemGrip,C:\repos\SuperTuxTeam_supertux-editor\Dock\DockItemGrip.cs,OnExposeEvent,The following statement contains a magic number: if (Icon != null) {  	Gdk.Rectangle pixbufRect;  	pixbufRect.Width = icon.Width;  	pixbufRect.Height = icon.Height;  	if (Direction == TextDirection.Rtl) {  		pixbufRect.X = titleArea.X + titleArea.Width - pixbufRect.Width;  	}  	else {  		pixbufRect.X = titleArea.X;  		titleArea.X += pixbufRect.Width + 4;  	}  	titleArea.Width -= pixbufRect.Width - 4;  	pixbufRect.Y = titleArea.Y + (titleArea.Height - pixbufRect.Height) / 2;  	if (evnt.Area.Intersect (pixbufRect' out exposeArea)) {  		Gdk.GC gc = Style.BackgroundGC (State);  		GdkWindow.DrawPixbuf (gc' icon' 0' 0' pixbufRect.X' pixbufRect.Y' pixbufRect.Width' pixbufRect.Height' Gdk.RgbDither.None' 0' 0);  	}  }  
Magic Number,Gdl,DockItemGrip,C:\repos\SuperTuxTeam_supertux-editor\Dock\DockItemGrip.cs,OnExposeEvent,The following statement contains a magic number: if (Icon != null) {  	Gdk.Rectangle pixbufRect;  	pixbufRect.Width = icon.Width;  	pixbufRect.Height = icon.Height;  	if (Direction == TextDirection.Rtl) {  		pixbufRect.X = titleArea.X + titleArea.Width - pixbufRect.Width;  	}  	else {  		pixbufRect.X = titleArea.X;  		titleArea.X += pixbufRect.Width + 4;  	}  	titleArea.Width -= pixbufRect.Width - 4;  	pixbufRect.Y = titleArea.Y + (titleArea.Height - pixbufRect.Height) / 2;  	if (evnt.Area.Intersect (pixbufRect' out exposeArea)) {  		Gdk.GC gc = Style.BackgroundGC (State);  		GdkWindow.DrawPixbuf (gc' icon' 0' 0' pixbufRect.X' pixbufRect.Y' pixbufRect.Width' pixbufRect.Height' Gdk.RgbDither.None' 0' 0);  	}  }  
Magic Number,Gdl,DockItemGrip,C:\repos\SuperTuxTeam_supertux-editor\Dock\DockItemGrip.cs,OnExposeEvent,The following statement contains a magic number: if (Icon != null) {  	Gdk.Rectangle pixbufRect;  	pixbufRect.Width = icon.Width;  	pixbufRect.Height = icon.Height;  	if (Direction == TextDirection.Rtl) {  		pixbufRect.X = titleArea.X + titleArea.Width - pixbufRect.Width;  	}  	else {  		pixbufRect.X = titleArea.X;  		titleArea.X += pixbufRect.Width + 4;  	}  	titleArea.Width -= pixbufRect.Width - 4;  	pixbufRect.Y = titleArea.Y + (titleArea.Height - pixbufRect.Height) / 2;  	if (evnt.Area.Intersect (pixbufRect' out exposeArea)) {  		Gdk.GC gc = Style.BackgroundGC (State);  		GdkWindow.DrawPixbuf (gc' icon' 0' 0' pixbufRect.X' pixbufRect.Y' pixbufRect.Width' pixbufRect.Height' Gdk.RgbDither.None' 0' 0);  	}  }  
Magic Number,Gdl,DockItemGrip,C:\repos\SuperTuxTeam_supertux-editor\Dock\DockItemGrip.cs,OnExposeEvent,The following statement contains a magic number: if (Direction == TextDirection.Rtl) {  	pixbufRect.X = titleArea.X + titleArea.Width - pixbufRect.Width;  }  else {  	pixbufRect.X = titleArea.X;  	titleArea.X += pixbufRect.Width + 4;  }  
Magic Number,Gdl,DockItemGrip,C:\repos\SuperTuxTeam_supertux-editor\Dock\DockItemGrip.cs,OnExposeEvent,The following statement contains a magic number: titleArea.X += pixbufRect.Width + 4;  
Magic Number,Gdl,DockItemGrip,C:\repos\SuperTuxTeam_supertux-editor\Dock\DockItemGrip.cs,OnExposeEvent,The following statement contains a magic number: titleArea.Width -= pixbufRect.Width - 4;  
Magic Number,Gdl,DockItemGrip,C:\repos\SuperTuxTeam_supertux-editor\Dock\DockItemGrip.cs,OnExposeEvent,The following statement contains a magic number: pixbufRect.Y = titleArea.Y + (titleArea.Height - pixbufRect.Height) / 2;  
Magic Number,Gdl,DockItemGrip,C:\repos\SuperTuxTeam_supertux-editor\Dock\DockItemGrip.cs,OnSizeRequested,The following statement contains a magic number: requisition.Width = (int)BorderWidth * 2;  
Magic Number,Gdl,DockItemGrip,C:\repos\SuperTuxTeam_supertux-editor\Dock\DockItemGrip.cs,OnSizeRequested,The following statement contains a magic number: requisition.Height = (int)BorderWidth * 2;  
Magic Number,Gdl,DockItemGrip,C:\repos\SuperTuxTeam_supertux-editor\Dock\DockItemGrip.cs,EllipsizeLayout,The following statement contains a magic number: if (line.XToIndex (width * 1024' out index' out trailing)) {  	// Console.WriteLine ("length: {0} index: {1} trailing: {2}"' layout.Text.Length' index' trailing);  	// FIXME: breaks on accented chars  	if (index < layout.Text.Length)  		layout.SetMarkup (layout.Text.Substring (0' index) + "...");  }  
Magic Number,Gdl,DockLayout,C:\repos\SuperTuxTeam_supertux-editor\Dock\DockLayout.cs,RunManager,The following statement contains a magic number: dialog.SetDefaultSize (-1' 300);  
Magic Number,Gdl,DockLayout,C:\repos\SuperTuxTeam_supertux-editor\Dock\DockLayout.cs,UpdateItemsModel,The following statement contains a magic number: if (itemsModel.GetIterFirst (out iter)) {  	bool valid = true;  	walk_start:  	while (valid) {  		DockItem item = itemsModel.GetValue (iter' 3) as DockItem;  		if (item != null) {  			// look for the object in the items list  			for (int i = 0; i < items.Count; i++) {  				// found' update data  				if (item == items [i]) {  					UpdateItemData (iter' item);  					items.RemoveAt (i);  					valid = itemsModel.IterNext (ref iter);  					goto walk_start;  				}  			}  			// FIXME: not found' skip it?  			valid = itemsModel.IterNext (ref iter);  		}  		else {  			// not a valid row  			valid = itemsModel.Remove (ref iter);  		}  	}  }  
Magic Number,Gdl,DockLayout,C:\repos\SuperTuxTeam_supertux-editor\Dock\DockLayout.cs,UpdateItemsModel,The following statement contains a magic number: while (valid) {  	DockItem item = itemsModel.GetValue (iter' 3) as DockItem;  	if (item != null) {  		// look for the object in the items list  		for (int i = 0; i < items.Count; i++) {  			// found' update data  			if (item == items [i]) {  				UpdateItemData (iter' item);  				items.RemoveAt (i);  				valid = itemsModel.IterNext (ref iter);  				goto walk_start;  			}  		}  		// FIXME: not found' skip it?  		valid = itemsModel.IterNext (ref iter);  	}  	else {  		// not a valid row  		valid = itemsModel.Remove (ref iter);  	}  }  
Magic Number,Gdl,DockMaster,C:\repos\SuperTuxTeam_supertux-editor\Dock\DockMaster.cs,XorRect,The following statement contains a magic number: rootXorGC.SetDashes (1' new sbyte[] {  	1'  	1  }' 2);  
Magic Number,Gdl,DockMaster,C:\repos\SuperTuxTeam_supertux-editor\Dock\DockMaster.cs,XorRect,The following statement contains a magic number: rootXorGC.SetDashes (0' new sbyte[] {  	1'  	1  }' 2);  
Magic Number,Gdl,DockMaster,C:\repos\SuperTuxTeam_supertux-editor\Dock\DockMaster.cs,XorRect,The following statement contains a magic number: window.DrawRectangle (rootXorGC' false' request.X + 1' request.Y + 1' request.Width - 2' request.Height - 2);  
Magic Number,Gdl,DockMaster,C:\repos\SuperTuxTeam_supertux-editor\Dock\DockMaster.cs,XorRect,The following statement contains a magic number: window.DrawRectangle (rootXorGC' false' request.X + 1' request.Y + 1' request.Width - 2' request.Height - 2);  
Magic Number,Gdl,DockPaned,C:\repos\SuperTuxTeam_supertux-editor\Dock\DockPaned.cs,OnDockRequest,The following statement contains a magic number: if (relX > 0 && relX < alloc.Width && relY > 0 && relY < alloc.Height) {  	int divider = -1;  	/* It's inside our area. */mayDock = true;  	/* these are for calculating the extra docking parameter */Requisition other = ((DockItem)request.Applicant).PreferredSize;  	Requisition my = PreferredSize;  	/* Set docking indicator rectangle to the Dock size. */request.X = bw;  	request.Y = bw;  	request.Width = alloc.Width - 2 * bw;  	request.Height = alloc.Height - 2 * bw;  	request.Target = this;  	/* See if it's in the BorderWidth band. */if (relX < bw) {  		request.Position = DockPlacement.Left;  		request.Width = (int)(request.Width * SplitRatio);  		divider = other.Width;  	}  	else if (relX > alloc.Width - bw) {  		request.Position = DockPlacement.Right;  		request.X += (int)(request.Width * (1 - SplitRatio));  		request.Width = (int)(request.Width * SplitRatio);  		divider = Math.Max (0' my.Width - other.Width);  	}  	else if (relY < bw) {  		request.Position = DockPlacement.Top;  		request.Height = (int)(request.Height * SplitRatio);  		divider = other.Height;  	}  	else if (relY > alloc.Height - bw) {  		request.Position = DockPlacement.Bottom;  		request.Y += (int)(request.Height * (1 - SplitRatio));  		request.Height = (int)(request.Height * SplitRatio);  		divider = Math.Max (0' my.Height - other.Height);  	}  	else {  		/* Otherwise try our children. */mayDock = false;  		DockRequest myRequest = new DockRequest (request);  		foreach (DockObject item in Children) {  			if (item.OnDockRequest (relX' relY' ref myRequest)) {  				mayDock = true;  				request = myRequest;  				break;  			}  		}  		if (!mayDock) {  			/* the pointer is on the handle' so snap 						   to top/bottom or left/right */mayDock = true;  			if (Orientation == Orientation.Horizontal) {  				if (relY < alloc.Height / 2) {  					request.Position = DockPlacement.Top;  					request.Height = (int)(request.Height * SplitRatio);  					divider = other.Height;  				}  				else {  					request.Position = DockPlacement.Bottom;  					request.Y += (int)(request.Height * (1 - SplitRatio));  					request.Height = (int)(request.Height * SplitRatio);  					divider = Math.Max (0' my.Height - other.Height);  				}  			}  			else {  				if (relX < alloc.Width / 2) {  					request.Position = DockPlacement.Left;  					request.Width = (int)(request.Width * SplitRatio);  					divider = other.Width;  				}  				else {  					request.Position = DockPlacement.Right;  					request.X += (int)(request.Width * (1 - SplitRatio));  					request.Width = (int)(request.Width * SplitRatio);  					divider = Math.Max (0' my.Width - other.Width);  				}  			}  		}  	}  	if (divider >= 0 && request.Position != DockPlacement.Center)  		request.Extra = divider;  	if (mayDock) {  		/* adjust returned coordinates so they are 					   relative to our allocation */request.X += alloc.X;  		request.Y += alloc.Y;  	}  }  
Magic Number,Gdl,DockPaned,C:\repos\SuperTuxTeam_supertux-editor\Dock\DockPaned.cs,OnDockRequest,The following statement contains a magic number: if (relX > 0 && relX < alloc.Width && relY > 0 && relY < alloc.Height) {  	int divider = -1;  	/* It's inside our area. */mayDock = true;  	/* these are for calculating the extra docking parameter */Requisition other = ((DockItem)request.Applicant).PreferredSize;  	Requisition my = PreferredSize;  	/* Set docking indicator rectangle to the Dock size. */request.X = bw;  	request.Y = bw;  	request.Width = alloc.Width - 2 * bw;  	request.Height = alloc.Height - 2 * bw;  	request.Target = this;  	/* See if it's in the BorderWidth band. */if (relX < bw) {  		request.Position = DockPlacement.Left;  		request.Width = (int)(request.Width * SplitRatio);  		divider = other.Width;  	}  	else if (relX > alloc.Width - bw) {  		request.Position = DockPlacement.Right;  		request.X += (int)(request.Width * (1 - SplitRatio));  		request.Width = (int)(request.Width * SplitRatio);  		divider = Math.Max (0' my.Width - other.Width);  	}  	else if (relY < bw) {  		request.Position = DockPlacement.Top;  		request.Height = (int)(request.Height * SplitRatio);  		divider = other.Height;  	}  	else if (relY > alloc.Height - bw) {  		request.Position = DockPlacement.Bottom;  		request.Y += (int)(request.Height * (1 - SplitRatio));  		request.Height = (int)(request.Height * SplitRatio);  		divider = Math.Max (0' my.Height - other.Height);  	}  	else {  		/* Otherwise try our children. */mayDock = false;  		DockRequest myRequest = new DockRequest (request);  		foreach (DockObject item in Children) {  			if (item.OnDockRequest (relX' relY' ref myRequest)) {  				mayDock = true;  				request = myRequest;  				break;  			}  		}  		if (!mayDock) {  			/* the pointer is on the handle' so snap 						   to top/bottom or left/right */mayDock = true;  			if (Orientation == Orientation.Horizontal) {  				if (relY < alloc.Height / 2) {  					request.Position = DockPlacement.Top;  					request.Height = (int)(request.Height * SplitRatio);  					divider = other.Height;  				}  				else {  					request.Position = DockPlacement.Bottom;  					request.Y += (int)(request.Height * (1 - SplitRatio));  					request.Height = (int)(request.Height * SplitRatio);  					divider = Math.Max (0' my.Height - other.Height);  				}  			}  			else {  				if (relX < alloc.Width / 2) {  					request.Position = DockPlacement.Left;  					request.Width = (int)(request.Width * SplitRatio);  					divider = other.Width;  				}  				else {  					request.Position = DockPlacement.Right;  					request.X += (int)(request.Width * (1 - SplitRatio));  					request.Width = (int)(request.Width * SplitRatio);  					divider = Math.Max (0' my.Width - other.Width);  				}  			}  		}  	}  	if (divider >= 0 && request.Position != DockPlacement.Center)  		request.Extra = divider;  	if (mayDock) {  		/* adjust returned coordinates so they are 					   relative to our allocation */request.X += alloc.X;  		request.Y += alloc.Y;  	}  }  
Magic Number,Gdl,DockPaned,C:\repos\SuperTuxTeam_supertux-editor\Dock\DockPaned.cs,OnDockRequest,The following statement contains a magic number: if (relX > 0 && relX < alloc.Width && relY > 0 && relY < alloc.Height) {  	int divider = -1;  	/* It's inside our area. */mayDock = true;  	/* these are for calculating the extra docking parameter */Requisition other = ((DockItem)request.Applicant).PreferredSize;  	Requisition my = PreferredSize;  	/* Set docking indicator rectangle to the Dock size. */request.X = bw;  	request.Y = bw;  	request.Width = alloc.Width - 2 * bw;  	request.Height = alloc.Height - 2 * bw;  	request.Target = this;  	/* See if it's in the BorderWidth band. */if (relX < bw) {  		request.Position = DockPlacement.Left;  		request.Width = (int)(request.Width * SplitRatio);  		divider = other.Width;  	}  	else if (relX > alloc.Width - bw) {  		request.Position = DockPlacement.Right;  		request.X += (int)(request.Width * (1 - SplitRatio));  		request.Width = (int)(request.Width * SplitRatio);  		divider = Math.Max (0' my.Width - other.Width);  	}  	else if (relY < bw) {  		request.Position = DockPlacement.Top;  		request.Height = (int)(request.Height * SplitRatio);  		divider = other.Height;  	}  	else if (relY > alloc.Height - bw) {  		request.Position = DockPlacement.Bottom;  		request.Y += (int)(request.Height * (1 - SplitRatio));  		request.Height = (int)(request.Height * SplitRatio);  		divider = Math.Max (0' my.Height - other.Height);  	}  	else {  		/* Otherwise try our children. */mayDock = false;  		DockRequest myRequest = new DockRequest (request);  		foreach (DockObject item in Children) {  			if (item.OnDockRequest (relX' relY' ref myRequest)) {  				mayDock = true;  				request = myRequest;  				break;  			}  		}  		if (!mayDock) {  			/* the pointer is on the handle' so snap 						   to top/bottom or left/right */mayDock = true;  			if (Orientation == Orientation.Horizontal) {  				if (relY < alloc.Height / 2) {  					request.Position = DockPlacement.Top;  					request.Height = (int)(request.Height * SplitRatio);  					divider = other.Height;  				}  				else {  					request.Position = DockPlacement.Bottom;  					request.Y += (int)(request.Height * (1 - SplitRatio));  					request.Height = (int)(request.Height * SplitRatio);  					divider = Math.Max (0' my.Height - other.Height);  				}  			}  			else {  				if (relX < alloc.Width / 2) {  					request.Position = DockPlacement.Left;  					request.Width = (int)(request.Width * SplitRatio);  					divider = other.Width;  				}  				else {  					request.Position = DockPlacement.Right;  					request.X += (int)(request.Width * (1 - SplitRatio));  					request.Width = (int)(request.Width * SplitRatio);  					divider = Math.Max (0' my.Width - other.Width);  				}  			}  		}  	}  	if (divider >= 0 && request.Position != DockPlacement.Center)  		request.Extra = divider;  	if (mayDock) {  		/* adjust returned coordinates so they are 					   relative to our allocation */request.X += alloc.X;  		request.Y += alloc.Y;  	}  }  
Magic Number,Gdl,DockPaned,C:\repos\SuperTuxTeam_supertux-editor\Dock\DockPaned.cs,OnDockRequest,The following statement contains a magic number: if (relX > 0 && relX < alloc.Width && relY > 0 && relY < alloc.Height) {  	int divider = -1;  	/* It's inside our area. */mayDock = true;  	/* these are for calculating the extra docking parameter */Requisition other = ((DockItem)request.Applicant).PreferredSize;  	Requisition my = PreferredSize;  	/* Set docking indicator rectangle to the Dock size. */request.X = bw;  	request.Y = bw;  	request.Width = alloc.Width - 2 * bw;  	request.Height = alloc.Height - 2 * bw;  	request.Target = this;  	/* See if it's in the BorderWidth band. */if (relX < bw) {  		request.Position = DockPlacement.Left;  		request.Width = (int)(request.Width * SplitRatio);  		divider = other.Width;  	}  	else if (relX > alloc.Width - bw) {  		request.Position = DockPlacement.Right;  		request.X += (int)(request.Width * (1 - SplitRatio));  		request.Width = (int)(request.Width * SplitRatio);  		divider = Math.Max (0' my.Width - other.Width);  	}  	else if (relY < bw) {  		request.Position = DockPlacement.Top;  		request.Height = (int)(request.Height * SplitRatio);  		divider = other.Height;  	}  	else if (relY > alloc.Height - bw) {  		request.Position = DockPlacement.Bottom;  		request.Y += (int)(request.Height * (1 - SplitRatio));  		request.Height = (int)(request.Height * SplitRatio);  		divider = Math.Max (0' my.Height - other.Height);  	}  	else {  		/* Otherwise try our children. */mayDock = false;  		DockRequest myRequest = new DockRequest (request);  		foreach (DockObject item in Children) {  			if (item.OnDockRequest (relX' relY' ref myRequest)) {  				mayDock = true;  				request = myRequest;  				break;  			}  		}  		if (!mayDock) {  			/* the pointer is on the handle' so snap 						   to top/bottom or left/right */mayDock = true;  			if (Orientation == Orientation.Horizontal) {  				if (relY < alloc.Height / 2) {  					request.Position = DockPlacement.Top;  					request.Height = (int)(request.Height * SplitRatio);  					divider = other.Height;  				}  				else {  					request.Position = DockPlacement.Bottom;  					request.Y += (int)(request.Height * (1 - SplitRatio));  					request.Height = (int)(request.Height * SplitRatio);  					divider = Math.Max (0' my.Height - other.Height);  				}  			}  			else {  				if (relX < alloc.Width / 2) {  					request.Position = DockPlacement.Left;  					request.Width = (int)(request.Width * SplitRatio);  					divider = other.Width;  				}  				else {  					request.Position = DockPlacement.Right;  					request.X += (int)(request.Width * (1 - SplitRatio));  					request.Width = (int)(request.Width * SplitRatio);  					divider = Math.Max (0' my.Width - other.Width);  				}  			}  		}  	}  	if (divider >= 0 && request.Position != DockPlacement.Center)  		request.Extra = divider;  	if (mayDock) {  		/* adjust returned coordinates so they are 					   relative to our allocation */request.X += alloc.X;  		request.Y += alloc.Y;  	}  }  
Magic Number,Gdl,DockPaned,C:\repos\SuperTuxTeam_supertux-editor\Dock\DockPaned.cs,OnDockRequest,The following statement contains a magic number: request.Width = alloc.Width - 2 * bw;  
Magic Number,Gdl,DockPaned,C:\repos\SuperTuxTeam_supertux-editor\Dock\DockPaned.cs,OnDockRequest,The following statement contains a magic number: request.Height = alloc.Height - 2 * bw;  
Magic Number,Gdl,DockPaned,C:\repos\SuperTuxTeam_supertux-editor\Dock\DockPaned.cs,OnDockRequest,The following statement contains a magic number: if (relX < bw) {  	request.Position = DockPlacement.Left;  	request.Width = (int)(request.Width * SplitRatio);  	divider = other.Width;  }  else if (relX > alloc.Width - bw) {  	request.Position = DockPlacement.Right;  	request.X += (int)(request.Width * (1 - SplitRatio));  	request.Width = (int)(request.Width * SplitRatio);  	divider = Math.Max (0' my.Width - other.Width);  }  else if (relY < bw) {  	request.Position = DockPlacement.Top;  	request.Height = (int)(request.Height * SplitRatio);  	divider = other.Height;  }  else if (relY > alloc.Height - bw) {  	request.Position = DockPlacement.Bottom;  	request.Y += (int)(request.Height * (1 - SplitRatio));  	request.Height = (int)(request.Height * SplitRatio);  	divider = Math.Max (0' my.Height - other.Height);  }  else {  	/* Otherwise try our children. */mayDock = false;  	DockRequest myRequest = new DockRequest (request);  	foreach (DockObject item in Children) {  		if (item.OnDockRequest (relX' relY' ref myRequest)) {  			mayDock = true;  			request = myRequest;  			break;  		}  	}  	if (!mayDock) {  		/* the pointer is on the handle' so snap 						   to top/bottom or left/right */mayDock = true;  		if (Orientation == Orientation.Horizontal) {  			if (relY < alloc.Height / 2) {  				request.Position = DockPlacement.Top;  				request.Height = (int)(request.Height * SplitRatio);  				divider = other.Height;  			}  			else {  				request.Position = DockPlacement.Bottom;  				request.Y += (int)(request.Height * (1 - SplitRatio));  				request.Height = (int)(request.Height * SplitRatio);  				divider = Math.Max (0' my.Height - other.Height);  			}  		}  		else {  			if (relX < alloc.Width / 2) {  				request.Position = DockPlacement.Left;  				request.Width = (int)(request.Width * SplitRatio);  				divider = other.Width;  			}  			else {  				request.Position = DockPlacement.Right;  				request.X += (int)(request.Width * (1 - SplitRatio));  				request.Width = (int)(request.Width * SplitRatio);  				divider = Math.Max (0' my.Width - other.Width);  			}  		}  	}  }  
Magic Number,Gdl,DockPaned,C:\repos\SuperTuxTeam_supertux-editor\Dock\DockPaned.cs,OnDockRequest,The following statement contains a magic number: if (relX < bw) {  	request.Position = DockPlacement.Left;  	request.Width = (int)(request.Width * SplitRatio);  	divider = other.Width;  }  else if (relX > alloc.Width - bw) {  	request.Position = DockPlacement.Right;  	request.X += (int)(request.Width * (1 - SplitRatio));  	request.Width = (int)(request.Width * SplitRatio);  	divider = Math.Max (0' my.Width - other.Width);  }  else if (relY < bw) {  	request.Position = DockPlacement.Top;  	request.Height = (int)(request.Height * SplitRatio);  	divider = other.Height;  }  else if (relY > alloc.Height - bw) {  	request.Position = DockPlacement.Bottom;  	request.Y += (int)(request.Height * (1 - SplitRatio));  	request.Height = (int)(request.Height * SplitRatio);  	divider = Math.Max (0' my.Height - other.Height);  }  else {  	/* Otherwise try our children. */mayDock = false;  	DockRequest myRequest = new DockRequest (request);  	foreach (DockObject item in Children) {  		if (item.OnDockRequest (relX' relY' ref myRequest)) {  			mayDock = true;  			request = myRequest;  			break;  		}  	}  	if (!mayDock) {  		/* the pointer is on the handle' so snap 						   to top/bottom or left/right */mayDock = true;  		if (Orientation == Orientation.Horizontal) {  			if (relY < alloc.Height / 2) {  				request.Position = DockPlacement.Top;  				request.Height = (int)(request.Height * SplitRatio);  				divider = other.Height;  			}  			else {  				request.Position = DockPlacement.Bottom;  				request.Y += (int)(request.Height * (1 - SplitRatio));  				request.Height = (int)(request.Height * SplitRatio);  				divider = Math.Max (0' my.Height - other.Height);  			}  		}  		else {  			if (relX < alloc.Width / 2) {  				request.Position = DockPlacement.Left;  				request.Width = (int)(request.Width * SplitRatio);  				divider = other.Width;  			}  			else {  				request.Position = DockPlacement.Right;  				request.X += (int)(request.Width * (1 - SplitRatio));  				request.Width = (int)(request.Width * SplitRatio);  				divider = Math.Max (0' my.Width - other.Width);  			}  		}  	}  }  
Magic Number,Gdl,DockPaned,C:\repos\SuperTuxTeam_supertux-editor\Dock\DockPaned.cs,OnDockRequest,The following statement contains a magic number: if (relX > alloc.Width - bw) {  	request.Position = DockPlacement.Right;  	request.X += (int)(request.Width * (1 - SplitRatio));  	request.Width = (int)(request.Width * SplitRatio);  	divider = Math.Max (0' my.Width - other.Width);  }  else if (relY < bw) {  	request.Position = DockPlacement.Top;  	request.Height = (int)(request.Height * SplitRatio);  	divider = other.Height;  }  else if (relY > alloc.Height - bw) {  	request.Position = DockPlacement.Bottom;  	request.Y += (int)(request.Height * (1 - SplitRatio));  	request.Height = (int)(request.Height * SplitRatio);  	divider = Math.Max (0' my.Height - other.Height);  }  else {  	/* Otherwise try our children. */mayDock = false;  	DockRequest myRequest = new DockRequest (request);  	foreach (DockObject item in Children) {  		if (item.OnDockRequest (relX' relY' ref myRequest)) {  			mayDock = true;  			request = myRequest;  			break;  		}  	}  	if (!mayDock) {  		/* the pointer is on the handle' so snap 						   to top/bottom or left/right */mayDock = true;  		if (Orientation == Orientation.Horizontal) {  			if (relY < alloc.Height / 2) {  				request.Position = DockPlacement.Top;  				request.Height = (int)(request.Height * SplitRatio);  				divider = other.Height;  			}  			else {  				request.Position = DockPlacement.Bottom;  				request.Y += (int)(request.Height * (1 - SplitRatio));  				request.Height = (int)(request.Height * SplitRatio);  				divider = Math.Max (0' my.Height - other.Height);  			}  		}  		else {  			if (relX < alloc.Width / 2) {  				request.Position = DockPlacement.Left;  				request.Width = (int)(request.Width * SplitRatio);  				divider = other.Width;  			}  			else {  				request.Position = DockPlacement.Right;  				request.X += (int)(request.Width * (1 - SplitRatio));  				request.Width = (int)(request.Width * SplitRatio);  				divider = Math.Max (0' my.Width - other.Width);  			}  		}  	}  }  
Magic Number,Gdl,DockPaned,C:\repos\SuperTuxTeam_supertux-editor\Dock\DockPaned.cs,OnDockRequest,The following statement contains a magic number: if (relX > alloc.Width - bw) {  	request.Position = DockPlacement.Right;  	request.X += (int)(request.Width * (1 - SplitRatio));  	request.Width = (int)(request.Width * SplitRatio);  	divider = Math.Max (0' my.Width - other.Width);  }  else if (relY < bw) {  	request.Position = DockPlacement.Top;  	request.Height = (int)(request.Height * SplitRatio);  	divider = other.Height;  }  else if (relY > alloc.Height - bw) {  	request.Position = DockPlacement.Bottom;  	request.Y += (int)(request.Height * (1 - SplitRatio));  	request.Height = (int)(request.Height * SplitRatio);  	divider = Math.Max (0' my.Height - other.Height);  }  else {  	/* Otherwise try our children. */mayDock = false;  	DockRequest myRequest = new DockRequest (request);  	foreach (DockObject item in Children) {  		if (item.OnDockRequest (relX' relY' ref myRequest)) {  			mayDock = true;  			request = myRequest;  			break;  		}  	}  	if (!mayDock) {  		/* the pointer is on the handle' so snap 						   to top/bottom or left/right */mayDock = true;  		if (Orientation == Orientation.Horizontal) {  			if (relY < alloc.Height / 2) {  				request.Position = DockPlacement.Top;  				request.Height = (int)(request.Height * SplitRatio);  				divider = other.Height;  			}  			else {  				request.Position = DockPlacement.Bottom;  				request.Y += (int)(request.Height * (1 - SplitRatio));  				request.Height = (int)(request.Height * SplitRatio);  				divider = Math.Max (0' my.Height - other.Height);  			}  		}  		else {  			if (relX < alloc.Width / 2) {  				request.Position = DockPlacement.Left;  				request.Width = (int)(request.Width * SplitRatio);  				divider = other.Width;  			}  			else {  				request.Position = DockPlacement.Right;  				request.X += (int)(request.Width * (1 - SplitRatio));  				request.Width = (int)(request.Width * SplitRatio);  				divider = Math.Max (0' my.Width - other.Width);  			}  		}  	}  }  
Magic Number,Gdl,DockPaned,C:\repos\SuperTuxTeam_supertux-editor\Dock\DockPaned.cs,OnDockRequest,The following statement contains a magic number: if (relY < bw) {  	request.Position = DockPlacement.Top;  	request.Height = (int)(request.Height * SplitRatio);  	divider = other.Height;  }  else if (relY > alloc.Height - bw) {  	request.Position = DockPlacement.Bottom;  	request.Y += (int)(request.Height * (1 - SplitRatio));  	request.Height = (int)(request.Height * SplitRatio);  	divider = Math.Max (0' my.Height - other.Height);  }  else {  	/* Otherwise try our children. */mayDock = false;  	DockRequest myRequest = new DockRequest (request);  	foreach (DockObject item in Children) {  		if (item.OnDockRequest (relX' relY' ref myRequest)) {  			mayDock = true;  			request = myRequest;  			break;  		}  	}  	if (!mayDock) {  		/* the pointer is on the handle' so snap 						   to top/bottom or left/right */mayDock = true;  		if (Orientation == Orientation.Horizontal) {  			if (relY < alloc.Height / 2) {  				request.Position = DockPlacement.Top;  				request.Height = (int)(request.Height * SplitRatio);  				divider = other.Height;  			}  			else {  				request.Position = DockPlacement.Bottom;  				request.Y += (int)(request.Height * (1 - SplitRatio));  				request.Height = (int)(request.Height * SplitRatio);  				divider = Math.Max (0' my.Height - other.Height);  			}  		}  		else {  			if (relX < alloc.Width / 2) {  				request.Position = DockPlacement.Left;  				request.Width = (int)(request.Width * SplitRatio);  				divider = other.Width;  			}  			else {  				request.Position = DockPlacement.Right;  				request.X += (int)(request.Width * (1 - SplitRatio));  				request.Width = (int)(request.Width * SplitRatio);  				divider = Math.Max (0' my.Width - other.Width);  			}  		}  	}  }  
Magic Number,Gdl,DockPaned,C:\repos\SuperTuxTeam_supertux-editor\Dock\DockPaned.cs,OnDockRequest,The following statement contains a magic number: if (relY < bw) {  	request.Position = DockPlacement.Top;  	request.Height = (int)(request.Height * SplitRatio);  	divider = other.Height;  }  else if (relY > alloc.Height - bw) {  	request.Position = DockPlacement.Bottom;  	request.Y += (int)(request.Height * (1 - SplitRatio));  	request.Height = (int)(request.Height * SplitRatio);  	divider = Math.Max (0' my.Height - other.Height);  }  else {  	/* Otherwise try our children. */mayDock = false;  	DockRequest myRequest = new DockRequest (request);  	foreach (DockObject item in Children) {  		if (item.OnDockRequest (relX' relY' ref myRequest)) {  			mayDock = true;  			request = myRequest;  			break;  		}  	}  	if (!mayDock) {  		/* the pointer is on the handle' so snap 						   to top/bottom or left/right */mayDock = true;  		if (Orientation == Orientation.Horizontal) {  			if (relY < alloc.Height / 2) {  				request.Position = DockPlacement.Top;  				request.Height = (int)(request.Height * SplitRatio);  				divider = other.Height;  			}  			else {  				request.Position = DockPlacement.Bottom;  				request.Y += (int)(request.Height * (1 - SplitRatio));  				request.Height = (int)(request.Height * SplitRatio);  				divider = Math.Max (0' my.Height - other.Height);  			}  		}  		else {  			if (relX < alloc.Width / 2) {  				request.Position = DockPlacement.Left;  				request.Width = (int)(request.Width * SplitRatio);  				divider = other.Width;  			}  			else {  				request.Position = DockPlacement.Right;  				request.X += (int)(request.Width * (1 - SplitRatio));  				request.Width = (int)(request.Width * SplitRatio);  				divider = Math.Max (0' my.Width - other.Width);  			}  		}  	}  }  
Magic Number,Gdl,DockPaned,C:\repos\SuperTuxTeam_supertux-editor\Dock\DockPaned.cs,OnDockRequest,The following statement contains a magic number: if (relY > alloc.Height - bw) {  	request.Position = DockPlacement.Bottom;  	request.Y += (int)(request.Height * (1 - SplitRatio));  	request.Height = (int)(request.Height * SplitRatio);  	divider = Math.Max (0' my.Height - other.Height);  }  else {  	/* Otherwise try our children. */mayDock = false;  	DockRequest myRequest = new DockRequest (request);  	foreach (DockObject item in Children) {  		if (item.OnDockRequest (relX' relY' ref myRequest)) {  			mayDock = true;  			request = myRequest;  			break;  		}  	}  	if (!mayDock) {  		/* the pointer is on the handle' so snap 						   to top/bottom or left/right */mayDock = true;  		if (Orientation == Orientation.Horizontal) {  			if (relY < alloc.Height / 2) {  				request.Position = DockPlacement.Top;  				request.Height = (int)(request.Height * SplitRatio);  				divider = other.Height;  			}  			else {  				request.Position = DockPlacement.Bottom;  				request.Y += (int)(request.Height * (1 - SplitRatio));  				request.Height = (int)(request.Height * SplitRatio);  				divider = Math.Max (0' my.Height - other.Height);  			}  		}  		else {  			if (relX < alloc.Width / 2) {  				request.Position = DockPlacement.Left;  				request.Width = (int)(request.Width * SplitRatio);  				divider = other.Width;  			}  			else {  				request.Position = DockPlacement.Right;  				request.X += (int)(request.Width * (1 - SplitRatio));  				request.Width = (int)(request.Width * SplitRatio);  				divider = Math.Max (0' my.Width - other.Width);  			}  		}  	}  }  
Magic Number,Gdl,DockPaned,C:\repos\SuperTuxTeam_supertux-editor\Dock\DockPaned.cs,OnDockRequest,The following statement contains a magic number: if (relY > alloc.Height - bw) {  	request.Position = DockPlacement.Bottom;  	request.Y += (int)(request.Height * (1 - SplitRatio));  	request.Height = (int)(request.Height * SplitRatio);  	divider = Math.Max (0' my.Height - other.Height);  }  else {  	/* Otherwise try our children. */mayDock = false;  	DockRequest myRequest = new DockRequest (request);  	foreach (DockObject item in Children) {  		if (item.OnDockRequest (relX' relY' ref myRequest)) {  			mayDock = true;  			request = myRequest;  			break;  		}  	}  	if (!mayDock) {  		/* the pointer is on the handle' so snap 						   to top/bottom or left/right */mayDock = true;  		if (Orientation == Orientation.Horizontal) {  			if (relY < alloc.Height / 2) {  				request.Position = DockPlacement.Top;  				request.Height = (int)(request.Height * SplitRatio);  				divider = other.Height;  			}  			else {  				request.Position = DockPlacement.Bottom;  				request.Y += (int)(request.Height * (1 - SplitRatio));  				request.Height = (int)(request.Height * SplitRatio);  				divider = Math.Max (0' my.Height - other.Height);  			}  		}  		else {  			if (relX < alloc.Width / 2) {  				request.Position = DockPlacement.Left;  				request.Width = (int)(request.Width * SplitRatio);  				divider = other.Width;  			}  			else {  				request.Position = DockPlacement.Right;  				request.X += (int)(request.Width * (1 - SplitRatio));  				request.Width = (int)(request.Width * SplitRatio);  				divider = Math.Max (0' my.Width - other.Width);  			}  		}  	}  }  
Magic Number,Gdl,DockPaned,C:\repos\SuperTuxTeam_supertux-editor\Dock\DockPaned.cs,OnDockRequest,The following statement contains a magic number: if (!mayDock) {  	/* the pointer is on the handle' so snap 						   to top/bottom or left/right */mayDock = true;  	if (Orientation == Orientation.Horizontal) {  		if (relY < alloc.Height / 2) {  			request.Position = DockPlacement.Top;  			request.Height = (int)(request.Height * SplitRatio);  			divider = other.Height;  		}  		else {  			request.Position = DockPlacement.Bottom;  			request.Y += (int)(request.Height * (1 - SplitRatio));  			request.Height = (int)(request.Height * SplitRatio);  			divider = Math.Max (0' my.Height - other.Height);  		}  	}  	else {  		if (relX < alloc.Width / 2) {  			request.Position = DockPlacement.Left;  			request.Width = (int)(request.Width * SplitRatio);  			divider = other.Width;  		}  		else {  			request.Position = DockPlacement.Right;  			request.X += (int)(request.Width * (1 - SplitRatio));  			request.Width = (int)(request.Width * SplitRatio);  			divider = Math.Max (0' my.Width - other.Width);  		}  	}  }  
Magic Number,Gdl,DockPaned,C:\repos\SuperTuxTeam_supertux-editor\Dock\DockPaned.cs,OnDockRequest,The following statement contains a magic number: if (!mayDock) {  	/* the pointer is on the handle' so snap 						   to top/bottom or left/right */mayDock = true;  	if (Orientation == Orientation.Horizontal) {  		if (relY < alloc.Height / 2) {  			request.Position = DockPlacement.Top;  			request.Height = (int)(request.Height * SplitRatio);  			divider = other.Height;  		}  		else {  			request.Position = DockPlacement.Bottom;  			request.Y += (int)(request.Height * (1 - SplitRatio));  			request.Height = (int)(request.Height * SplitRatio);  			divider = Math.Max (0' my.Height - other.Height);  		}  	}  	else {  		if (relX < alloc.Width / 2) {  			request.Position = DockPlacement.Left;  			request.Width = (int)(request.Width * SplitRatio);  			divider = other.Width;  		}  		else {  			request.Position = DockPlacement.Right;  			request.X += (int)(request.Width * (1 - SplitRatio));  			request.Width = (int)(request.Width * SplitRatio);  			divider = Math.Max (0' my.Width - other.Width);  		}  	}  }  
Magic Number,Gdl,DockPaned,C:\repos\SuperTuxTeam_supertux-editor\Dock\DockPaned.cs,OnDockRequest,The following statement contains a magic number: if (Orientation == Orientation.Horizontal) {  	if (relY < alloc.Height / 2) {  		request.Position = DockPlacement.Top;  		request.Height = (int)(request.Height * SplitRatio);  		divider = other.Height;  	}  	else {  		request.Position = DockPlacement.Bottom;  		request.Y += (int)(request.Height * (1 - SplitRatio));  		request.Height = (int)(request.Height * SplitRatio);  		divider = Math.Max (0' my.Height - other.Height);  	}  }  else {  	if (relX < alloc.Width / 2) {  		request.Position = DockPlacement.Left;  		request.Width = (int)(request.Width * SplitRatio);  		divider = other.Width;  	}  	else {  		request.Position = DockPlacement.Right;  		request.X += (int)(request.Width * (1 - SplitRatio));  		request.Width = (int)(request.Width * SplitRatio);  		divider = Math.Max (0' my.Width - other.Width);  	}  }  
Magic Number,Gdl,DockPaned,C:\repos\SuperTuxTeam_supertux-editor\Dock\DockPaned.cs,OnDockRequest,The following statement contains a magic number: if (Orientation == Orientation.Horizontal) {  	if (relY < alloc.Height / 2) {  		request.Position = DockPlacement.Top;  		request.Height = (int)(request.Height * SplitRatio);  		divider = other.Height;  	}  	else {  		request.Position = DockPlacement.Bottom;  		request.Y += (int)(request.Height * (1 - SplitRatio));  		request.Height = (int)(request.Height * SplitRatio);  		divider = Math.Max (0' my.Height - other.Height);  	}  }  else {  	if (relX < alloc.Width / 2) {  		request.Position = DockPlacement.Left;  		request.Width = (int)(request.Width * SplitRatio);  		divider = other.Width;  	}  	else {  		request.Position = DockPlacement.Right;  		request.X += (int)(request.Width * (1 - SplitRatio));  		request.Width = (int)(request.Width * SplitRatio);  		divider = Math.Max (0' my.Width - other.Width);  	}  }  
Magic Number,Gdl,DockPaned,C:\repos\SuperTuxTeam_supertux-editor\Dock\DockPaned.cs,OnDockRequest,The following statement contains a magic number: if (relY < alloc.Height / 2) {  	request.Position = DockPlacement.Top;  	request.Height = (int)(request.Height * SplitRatio);  	divider = other.Height;  }  else {  	request.Position = DockPlacement.Bottom;  	request.Y += (int)(request.Height * (1 - SplitRatio));  	request.Height = (int)(request.Height * SplitRatio);  	divider = Math.Max (0' my.Height - other.Height);  }  
Magic Number,Gdl,DockPaned,C:\repos\SuperTuxTeam_supertux-editor\Dock\DockPaned.cs,OnDockRequest,The following statement contains a magic number: if (relX < alloc.Width / 2) {  	request.Position = DockPlacement.Left;  	request.Width = (int)(request.Width * SplitRatio);  	divider = other.Width;  }  else {  	request.Position = DockPlacement.Right;  	request.X += (int)(request.Width * (1 - SplitRatio));  	request.Width = (int)(request.Width * SplitRatio);  	divider = Math.Max (0' my.Width - other.Width);  }  
Missing Default,Gdl,DockPaned,C:\repos\SuperTuxTeam_supertux-editor\Dock\DockPaned.cs,OnDocked,The following switch statement is missing a default case: switch (Orientation) {  case Orientation.Horizontal:  	if (paned.Child1 == null && position == DockPlacement.Left) {  		paned.Pack1 (requestor' false' false);  		done = true;  	}  	else if (paned.Child2 == null && position == DockPlacement.Right) {  		paned.Pack2 (requestor' true' true);  		done = true;  	}  	break;  case Orientation.Vertical:  	if (paned.Child1 == null && position == DockPlacement.Top) {  		paned.Pack1 (requestor' true' true);  		done = true;  	}  	else if (paned.Child2 == null && position == DockPlacement.Bottom) {  		paned.Pack2 (requestor' false' false);  		done = true;  	}  	break;  }  
