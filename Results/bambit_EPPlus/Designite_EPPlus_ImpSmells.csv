Implementation smell,Namespace,Class,File,Method,Description
Long Method,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingRuleFactory,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\ExcelConditionalFormattingRuleFactory.cs,Create,The method has 101 lines of code.
Long Method,OfficeOpenXml.Drawing.Chart,ExcelBarChart,C:\repos\bambit_EPPlus\EPPlus\Drawing\Chart\ExcelBarChart.cs,GetChartType,The method has 142 lines of code.
Long Method,OfficeOpenXml,ExcelStyles,C:\repos\bambit_EPPlus\EPPlus\ExcelStyles.cs,SetStyleAddress,The method has 128 lines of code.
Long Method,OfficeOpenXml,ExcelStyles,C:\repos\bambit_EPPlus\EPPlus\ExcelStyles.cs,UpdateXml,The method has 141 lines of code.
Long Method,OfficeOpenXml,ExcelWorksheet,C:\repos\bambit_EPPlus\EPPlus\ExcelWorksheet.cs,LoadCells,The method has 100 lines of code.
Long Method,OfficeOpenXml,ExcelWorksheet,C:\repos\bambit_EPPlus\EPPlus\ExcelWorksheet.cs,UpdateRowCellData,The method has 129 lines of code.
Long Method,OfficeOpenXml,XmlHelper,C:\repos\bambit_EPPlus\EPPlus\XmlHelper.cs,CreateComplexNode,The method has 141 lines of code.
Long Method,OfficeOpenXml,ExcelRangeBase,C:\repos\bambit_EPPlus\EPPlus\ExcelRangeBase.cs,AutoFitColumns,The method has 103 lines of code.
Long Method,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadDirStream,The method has 144 lines of code.
Long Method,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,CreateDirStream,The method has 124 lines of code.
Long Method,OfficeOpenXml.Style.XmlAccess,ExcelNumberFormatXml,C:\repos\bambit_EPPlus\EPPlus\Style\XmlAccess\ExcelNumberFormatXml.cs,AddBuildIn,The method has 116 lines of code.
Complex Method,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingCollection,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\ExcelConditionalFormattingCollection.cs,ExcelConditionalFormattingCollection,Cyclomatic complexity of the method is 8
Complex Method,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingOperatorType,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\ExcelConditionalFormattingOperatorType.cs,GetAttributeByType,Cyclomatic complexity of the method is 12
Complex Method,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingOperatorType,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\ExcelConditionalFormattingOperatorType.cs,GetTypeByAttribute,Cyclomatic complexity of the method is 12
Complex Method,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingRuleFactory,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\ExcelConditionalFormattingRuleFactory.cs,Create,Cyclomatic complexity of the method is 45
Complex Method,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingTimePeriodType,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\ExcelConditionalFormattingTimePeriodType.cs,GetAttributeByType,Cyclomatic complexity of the method is 10
Complex Method,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingTimePeriodType,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\ExcelConditionalFormattingTimePeriodType.cs,GetTypeByAttribute,Cyclomatic complexity of the method is 10
Complex Method,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingRuleType,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\ExcelConditionalFormattingRuleType.cs,GetTypeByAttrbiute,Cyclomatic complexity of the method is 18
Complex Method,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingRuleType,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\ExcelConditionalFormattingRuleType.cs,GetCellIs,Cyclomatic complexity of the method is 14
Complex Method,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingRuleType,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\ExcelConditionalFormattingRuleType.cs,GetTimePeriodType,Cyclomatic complexity of the method is 10
Complex Method,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingRuleType,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\ExcelConditionalFormattingRuleType.cs,GetAttributeByType,Cyclomatic complexity of the method is 45
Complex Method,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingIconSetBase,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\Rules\ExcelConditionalFormattingThreeIconSet.cs,ExcelConditionalFormattingIconSetBase,Cyclomatic complexity of the method is 8
Complex Method,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingIconSetBase,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\Rules\ExcelConditionalFormattingThreeIconSet.cs,GetIconSetString,Cyclomatic complexity of the method is 23
Complex Method,OfficeOpenXml.DataValidation,ExcelDataValidationFactory,C:\repos\bambit_EPPlus\EPPlus\DataValidation\ExcelDataValidationFactory.cs,Create,Cyclomatic complexity of the method is 9
Complex Method,OfficeOpenXml.DataValidation,ExcelDataValidationType,C:\repos\bambit_EPPlus\EPPlus\DataValidation\ExcelDataValidationType.cs,GetByValidationType,Cyclomatic complexity of the method is 9
Complex Method,OfficeOpenXml.DataValidation,ExcelDataValidationType,C:\repos\bambit_EPPlus\EPPlus\DataValidation\ExcelDataValidationType.cs,GetBySchemaName,Cyclomatic complexity of the method is 9
Complex Method,OfficeOpenXml.Drawing.Chart,ExcelChart,C:\repos\bambit_EPPlus\EPPlus\Drawing\Chart\ExcelChart.cs,GetChartType,Cyclomatic complexity of the method is 18
Complex Method,OfficeOpenXml.Drawing.Chart,ExcelChart,C:\repos\bambit_EPPlus\EPPlus\Drawing\Chart\ExcelChart.cs,GetChartNodeText,Cyclomatic complexity of the method is 67
Complex Method,OfficeOpenXml.Drawing.Chart,ExcelChart,C:\repos\bambit_EPPlus\EPPlus\Drawing\Chart\ExcelChart.cs,GetChart,Cyclomatic complexity of the method is 31
Complex Method,OfficeOpenXml.Drawing.Chart,ExcelChart,C:\repos\bambit_EPPlus\EPPlus\Drawing\Chart\ExcelChart.cs,GetNewChart,Cyclomatic complexity of the method is 55
Complex Method,OfficeOpenXml.Drawing.Chart,ExcelLineChart,C:\repos\bambit_EPPlus\EPPlus\Drawing\Chart\ExcelLineChart.cs,GetChartType,Cyclomatic complexity of the method is 8
Complex Method,OfficeOpenXml.Drawing.Chart,ExcelBarChart,C:\repos\bambit_EPPlus\EPPlus\Drawing\Chart\ExcelBarChart.cs,GetChartType,Cyclomatic complexity of the method is 38
Complex Method,OfficeOpenXml.Drawing.Chart,ExcelChartDataLabel,C:\repos\bambit_EPPlus\EPPlus\Drawing\Chart\ExcelChartDataLabel.cs,GetPosText,Cyclomatic complexity of the method is 9
Complex Method,OfficeOpenXml.Drawing.Chart,ExcelChartDataLabel,C:\repos\bambit_EPPlus\EPPlus\Drawing\Chart\ExcelChartDataLabel.cs,GetPosEnum,Cyclomatic complexity of the method is 9
Complex Method,OfficeOpenXml.Drawing.Chart,ExcelChartSeries,C:\repos\bambit_EPPlus\EPPlus\Drawing\Chart\ExcelChartSeries.cs,AddSeries,Cyclomatic complexity of the method is 32
Complex Method,OfficeOpenXml.Drawing,ExcelPicture,C:\repos\bambit_EPPlus\EPPlus\Drawing\ExcelPicture.cs,GetContentType,Cyclomatic complexity of the method is 14
Complex Method,OfficeOpenXml.Drawing,ExcelDrawingBorder,C:\repos\bambit_EPPlus\EPPlus\Drawing\ExcelDrawingBorder.cs,TranslateLineStyleText,Cyclomatic complexity of the method is 13
Complex Method,OfficeOpenXml.Drawing,ExcelDrawingBorder,C:\repos\bambit_EPPlus\EPPlus\Drawing\ExcelDrawingBorder.cs,TranslateLineStyle,Cyclomatic complexity of the method is 13
Complex Method,OfficeOpenXml,ExcelHeaderFooterText,C:\repos\bambit_EPPlus\EPPlus\ExcelHeaderFooter.cs,SetText,Cyclomatic complexity of the method is 9
Complex Method,OfficeOpenXml,ExcelHeaderFooterText,C:\repos\bambit_EPPlus\EPPlus\ExcelHeaderFooter.cs,ValidateImage,Cyclomatic complexity of the method is 11
Complex Method,OfficeOpenXml,ExcelHeaderFooter,C:\repos\bambit_EPPlus\EPPlus\ExcelHeaderFooter.cs,Save,Cyclomatic complexity of the method is 9
Complex Method,OfficeOpenXml,ExcelStyles,C:\repos\bambit_EPPlus\EPPlus\ExcelStyles.cs,LoadFromDocument,Cyclomatic complexity of the method is 15
Complex Method,OfficeOpenXml,ExcelStyles,C:\repos\bambit_EPPlus\EPPlus\ExcelStyles.cs,SetStyleAddress,Cyclomatic complexity of the method is 24
Complex Method,OfficeOpenXml,ExcelStyles,C:\repos\bambit_EPPlus\EPPlus\ExcelStyles.cs,UpdateXml,Cyclomatic complexity of the method is 26
Complex Method,OfficeOpenXml,ExcelStyles,C:\repos\bambit_EPPlus\EPPlus\ExcelStyles.cs,RemoveUnusedStyles,Cyclomatic complexity of the method is 17
Complex Method,OfficeOpenXml,ExcelStyles,C:\repos\bambit_EPPlus\EPPlus\ExcelStyles.cs,CloneStyle,Cyclomatic complexity of the method is 16
Complex Method,OfficeOpenXml,ExcelWorksheetView,C:\repos\bambit_EPPlus\EPPlus\ExcelWorksheetView.cs,FreezePanes,Cyclomatic complexity of the method is 13
Complex Method,OfficeOpenXml,OfficeProperties,C:\repos\bambit_EPPlus\EPPlus\OfficeProperties.cs,GetCustomPropertyValue,Cyclomatic complexity of the method is 18
Complex Method,OfficeOpenXml,OfficeProperties,C:\repos\bambit_EPPlus\EPPlus\OfficeProperties.cs,SetCustomPropertyValue,Cyclomatic complexity of the method is 13
Complex Method,OfficeOpenXml,ExcelWorkbook,C:\repos\bambit_EPPlus\EPPlus\ExcelWorkbook.cs,GetDefinedNames,Cyclomatic complexity of the method is 16
Complex Method,OfficeOpenXml,ExcelWorkbook,C:\repos\bambit_EPPlus\EPPlus\ExcelWorkbook.cs,Save,Cyclomatic complexity of the method is 10
Complex Method,OfficeOpenXml,ExcelWorkbook,C:\repos\bambit_EPPlus\EPPlus\ExcelWorkbook.cs,UpdateDefinedNamesXml,Cyclomatic complexity of the method is 12
Complex Method,OfficeOpenXml,ExcelWorksheet,C:\repos\bambit_EPPlus\EPPlus\ExcelWorksheet.cs,LoadHyperLinks,Cyclomatic complexity of the method is 10
Complex Method,OfficeOpenXml,ExcelWorksheet,C:\repos\bambit_EPPlus\EPPlus\ExcelWorksheet.cs,LoadCells,Cyclomatic complexity of the method is 18
Complex Method,OfficeOpenXml,ExcelWorksheet,C:\repos\bambit_EPPlus\EPPlus\ExcelWorksheet.cs,InsertRow,Cyclomatic complexity of the method is 8
Complex Method,OfficeOpenXml,ExcelWorksheet,C:\repos\bambit_EPPlus\EPPlus\ExcelWorksheet.cs,FixMergedCells,Cyclomatic complexity of the method is 8
Complex Method,OfficeOpenXml,ExcelWorksheet,C:\repos\bambit_EPPlus\EPPlus\ExcelWorksheet.cs,FixSharedFormulasRows,Cyclomatic complexity of the method is 12
Complex Method,OfficeOpenXml,ExcelWorksheet,C:\repos\bambit_EPPlus\EPPlus\ExcelWorksheet.cs,UpdateSharedFormulaRow,Cyclomatic complexity of the method is 11
Complex Method,OfficeOpenXml,ExcelWorksheet,C:\repos\bambit_EPPlus\EPPlus\ExcelWorksheet.cs,GetTypedValue,Cyclomatic complexity of the method is 19
Complex Method,OfficeOpenXml,ExcelWorksheet,C:\repos\bambit_EPPlus\EPPlus\ExcelWorksheet.cs,Save,Cyclomatic complexity of the method is 10
Complex Method,OfficeOpenXml,ExcelWorksheet,C:\repos\bambit_EPPlus\EPPlus\ExcelWorksheet.cs,SaveComments,Cyclomatic complexity of the method is 11
Complex Method,OfficeOpenXml,ExcelWorksheet,C:\repos\bambit_EPPlus\EPPlus\ExcelWorksheet.cs,SaveTables,Cyclomatic complexity of the method is 36
Complex Method,OfficeOpenXml,ExcelWorksheet,C:\repos\bambit_EPPlus\EPPlus\ExcelWorksheet.cs,UpdateColumnData,Cyclomatic complexity of the method is 9
Complex Method,OfficeOpenXml,ExcelWorksheet,C:\repos\bambit_EPPlus\EPPlus\ExcelWorksheet.cs,UpdateRowCellData,Cyclomatic complexity of the method is 25
Complex Method,OfficeOpenXml,ExcelWorksheet,C:\repos\bambit_EPPlus\EPPlus\ExcelWorksheet.cs,WriteRow,Cyclomatic complexity of the method is 11
Complex Method,OfficeOpenXml,ExcelWorksheets,C:\repos\bambit_EPPlus\EPPlus\ExcelWorksheets.cs,Add,Cyclomatic complexity of the method is 10
Complex Method,OfficeOpenXml,ExcelWorksheets,C:\repos\bambit_EPPlus\EPPlus\ExcelWorksheets.cs,CloneCells,Cyclomatic complexity of the method is 18
Complex Method,OfficeOpenXml,ExcelWorksheets,C:\repos\bambit_EPPlus\EPPlus\ExcelWorksheets.cs,ValidateFixSheetName,Cyclomatic complexity of the method is 10
Complex Method,OfficeOpenXml,ExcelWorksheets,C:\repos\bambit_EPPlus\EPPlus\ExcelWorksheets.cs,Move,Cyclomatic complexity of the method is 9
Complex Method,OfficeOpenXml,XmlHelper,C:\repos\bambit_EPPlus\EPPlus\XmlHelper.cs,CreateNode,Cyclomatic complexity of the method is 11
Complex Method,OfficeOpenXml,XmlHelper,C:\repos\bambit_EPPlus\EPPlus\XmlHelper.cs,CreateComplexNode,Cyclomatic complexity of the method is 31
Complex Method,OfficeOpenXml,ExcelAddressBase,C:\repos\bambit_EPPlus\EPPlus\ExcelAddress.cs,ExtractAddress,Cyclomatic complexity of the method is 9
Complex Method,OfficeOpenXml,ExcelAddressBase,C:\repos\bambit_EPPlus\EPPlus\ExcelAddress.cs,IsValid,Cyclomatic complexity of the method is 13
Complex Method,OfficeOpenXml,ExcelCellBase,C:\repos\bambit_EPPlus\EPPlus\ExcelCellBase.cs,AddToRowColumnTranslator,Cyclomatic complexity of the method is 8
Complex Method,OfficeOpenXml,ExcelCellBase,C:\repos\bambit_EPPlus\EPPlus\ExcelCellBase.cs,GetRowColFromAddress,Cyclomatic complexity of the method is 8
Complex Method,OfficeOpenXml,ExcelCellBase,C:\repos\bambit_EPPlus\EPPlus\ExcelCellBase.cs,GetRowCol,Cyclomatic complexity of the method is 12
Complex Method,OfficeOpenXml,ExcelRangeBase,C:\repos\bambit_EPPlus\EPPlus\ExcelRangeBase.cs,AutoFitColumns,Cyclomatic complexity of the method is 29
Complex Method,OfficeOpenXml,ExcelRangeBase,C:\repos\bambit_EPPlus\EPPlus\ExcelRangeBase.cs,GetFormatedText,Cyclomatic complexity of the method is 16
Complex Method,OfficeOpenXml,ExcelRangeBase,C:\repos\bambit_EPPlus\EPPlus\ExcelRangeBase.cs,SplitFormula,Cyclomatic complexity of the method is 14
Complex Method,OfficeOpenXml,ExcelRangeBase,C:\repos\bambit_EPPlus\EPPlus\ExcelRangeBase.cs,ConvertData,Cyclomatic complexity of the method is 15
Complex Method,OfficeOpenXml,ExcelRangeBase,C:\repos\bambit_EPPlus\EPPlus\ExcelRangeBase.cs,LoadFromCollection,Cyclomatic complexity of the method is 15
Complex Method,OfficeOpenXml,ExcelRangeBase,C:\repos\bambit_EPPlus\EPPlus\ExcelRangeBase.cs,LoadFromText,Cyclomatic complexity of the method is 15
Complex Method,OfficeOpenXml,ExcelRangeBase,C:\repos\bambit_EPPlus\EPPlus\ExcelRangeBase.cs,Copy,Cyclomatic complexity of the method is 14
Complex Method,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadProjectProperties,Cyclomatic complexity of the method is 47
Complex Method,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadDirStream,Cyclomatic complexity of the method is 129
Complex Method,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,Save,Cyclomatic complexity of the method is 9
Complex Method,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,CreateProjectStream,Cyclomatic complexity of the method is 8
Complex Method,OfficeOpenXml.VBA,ExcelVbaSignature,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaSignature.cs,GetSignature,Cyclomatic complexity of the method is 8
Complex Method,OfficeOpenXml.VBA,ExcelVbaSignature,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaSignature.cs,Save,Cyclomatic complexity of the method is 9
Complex Method,OfficeOpenXml.VBA,ExcelVbaSignature,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaSignature.cs,GetContentHash,Cyclomatic complexity of the method is 9
Complex Method,OfficeOpenXml.Utils,EncryptedPackageHandler,C:\repos\bambit_EPPlus\EPPlus\Utils\EncryptedPackageHandler.cs,GetStreamFromPackage,Cyclomatic complexity of the method is 13
Complex Method,OfficeOpenXml.Utils,EncryptedPackageHandler,C:\repos\bambit_EPPlus\EPPlus\Utils\EncryptedPackageHandler.cs,GetPasswordHash,Cyclomatic complexity of the method is 9
Complex Method,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,CompressChunk,Cyclomatic complexity of the method is 11
Complex Method,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetChunk,Cyclomatic complexity of the method is 9
Complex Method,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetLengthBits,Cyclomatic complexity of the method is 10
Complex Method,OfficeOpenXml.Style,ExcelColor,C:\repos\bambit_EPPlus\EPPlus\Style\ExcelColor.cs,GetSource,Cyclomatic complexity of the method is 10
Complex Method,OfficeOpenXml.Style,ExcelNumberFormat,C:\repos\bambit_EPPlus\EPPlus\Style\ExcelNumberFormat.cs,GetFromBuildInFromID,Cyclomatic complexity of the method is 29
Complex Method,OfficeOpenXml.Style,ExcelNumberFormat,C:\repos\bambit_EPPlus\EPPlus\Style\ExcelNumberFormat.cs,GetFromBuildIdFromFormat,Cyclomatic complexity of the method is 29
Complex Method,OfficeOpenXml.Style.XmlAccess,ExcelGradientFillXml,C:\repos\bambit_EPPlus\EPPlus\Style\XmlAccess\ExcelGradientFillXml.cs,CreateXmlNode,Cyclomatic complexity of the method is 8
Complex Method,OfficeOpenXml.Style.XmlAccess,ExcelXfs,C:\repos\bambit_EPPlus\EPPlus\Style\XmlAccess\ExcelXfsXml.cs,GetNewID,Cyclomatic complexity of the method is 33
Complex Method,OfficeOpenXml.Style.XmlAccess,ExcelXfs,C:\repos\bambit_EPPlus\EPPlus\Style\XmlAccess\ExcelXfsXml.cs,GetIdBorder,Cyclomatic complexity of the method is 23
Complex Method,OfficeOpenXml.Style.XmlAccess,ExcelXfs,C:\repos\bambit_EPPlus\EPPlus\Style\XmlAccess\ExcelXfsXml.cs,GetIdFill,Cyclomatic complexity of the method is 24
Complex Method,OfficeOpenXml.Style.XmlAccess,ExcelXfs,C:\repos\bambit_EPPlus\EPPlus\Style\XmlAccess\ExcelXfsXml.cs,GetIdGradientFill,Cyclomatic complexity of the method is 34
Complex Method,OfficeOpenXml.Style.XmlAccess,ExcelXfs,C:\repos\bambit_EPPlus\EPPlus\Style\XmlAccess\ExcelXfsXml.cs,GetIdFont,Cyclomatic complexity of the method is 30
Complex Method,OfficeOpenXml.Style.XmlAccess,ExcelXfs,C:\repos\bambit_EPPlus\EPPlus\Style\XmlAccess\ExcelXfsXml.cs,CreateXmlNode,Cyclomatic complexity of the method is 15
Complex Method,OfficeOpenXml.Style.XmlAccess,ExcelFontXml,C:\repos\bambit_EPPlus\EPPlus\Style\XmlAccess\ExcelFontXml.cs,CreateXmlNode,Cyclomatic complexity of the method is 12
Complex Method,OfficeOpenXml.Table.PivotTable,ExcelPivotTableRowColumnFieldCollection,C:\repos\bambit_EPPlus\EPPlus\Table\PivotTable\ExcelPivotTableFieldCollection.cs,SetFlag,Cyclomatic complexity of the method is 22
Complex Method,OfficeOpenXml.Table.PivotTable,ExcelPivotTableField,C:\repos\bambit_EPPlus\EPPlus\Table\PivotTable\ExcelPivotTableField.cs,AddDateGroupItems,Cyclomatic complexity of the method is 44
Complex Method,OfficeOpenXml.Table.PivotTable,ExcelPivotTableField,C:\repos\bambit_EPPlus\EPPlus\Table\PivotTable\ExcelPivotTableField.cs,AddDateGrouping,Cyclomatic complexity of the method is 12
Complex Method,OfficeOpenXml.Table.PivotTable,ExcelPivotTable,C:\repos\bambit_EPPlus\EPPlus\Table\PivotTable\ExcelPivotTable.cs,ExcelPivotTable,Cyclomatic complexity of the method is 9
Long Parameter List,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingIconDataBarValue,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\ExcelConditionalFormattingIconDataBarValue.cs,ExcelConditionalFormattingIconDataBarValue,The method has 9 parameters.
Long Parameter List,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingIconDataBarValue,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\ExcelConditionalFormattingIconDataBarValue.cs,ExcelConditionalFormattingIconDataBarValue,The method has 5 parameters.
Long Parameter List,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingIconDataBarValue,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\ExcelConditionalFormattingIconDataBarValue.cs,ExcelConditionalFormattingIconDataBarValue,The method has 8 parameters.
Long Parameter List,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingIconDataBarValue,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\ExcelConditionalFormattingIconDataBarValue.cs,ExcelConditionalFormattingIconDataBarValue,The method has 7 parameters.
Long Parameter List,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingDataBar,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\Rules\ExcelConditionalFormattingDataBar.cs,ExcelConditionalFormattingDataBar,The method has 6 parameters.
Long Parameter List,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingDataBar,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\Rules\ExcelConditionalFormattingDataBar.cs,ExcelConditionalFormattingDataBar,The method has 5 parameters.
Long Parameter List,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingFiveIconSet,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\Rules\ExcelConditionalFormattingFiveIconSet.cs,ExcelConditionalFormattingFiveIconSet,The method has 5 parameters.
Long Parameter List,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingFourIconSet,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\Rules\ExcelConditionalFormattingFourIconSet.cs,ExcelConditionalFormattingFourIconSet,The method has 5 parameters.
Long Parameter List,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingAboveStdDev,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\Rules\ExcelConditionalFormattingAboveStdDev.cs,ExcelConditionalFormattingAboveStdDev,The method has 5 parameters.
Long Parameter List,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingAboveOrEqualAverage,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\Rules\ExcelConditionalFormattingAboveOrEqualAverage.cs,ExcelConditionalFormattingAboveOrEqualAverage,The method has 5 parameters.
Long Parameter List,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingAverageGroup,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\Rules\ExcelConditionalFormattingAverageGroup.cs,ExcelConditionalFormattingAverageGroup,The method has 6 parameters.
Long Parameter List,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingAverageGroup,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\Rules\ExcelConditionalFormattingAverageGroup.cs,ExcelConditionalFormattingAverageGroup,The method has 5 parameters.
Long Parameter List,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingAboveAverage,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\Rules\ExcelConditionalFormattingAboveAverage.cs,ExcelConditionalFormattingAboveAverage,The method has 5 parameters.
Long Parameter List,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingRuleFactory,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\ExcelConditionalFormattingRuleFactory.cs,Create,The method has 5 parameters.
Long Parameter List,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingColorScaleValue,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\ExcelConditionalFormattingColorScaleValue.cs,ExcelConditionalFormattingColorScaleValue,The method has 11 parameters.
Long Parameter List,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingColorScaleValue,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\ExcelConditionalFormattingColorScaleValue.cs,ExcelConditionalFormattingColorScaleValue,The method has 10 parameters.
Long Parameter List,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingColorScaleValue,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\ExcelConditionalFormattingColorScaleValue.cs,ExcelConditionalFormattingColorScaleValue,The method has 8 parameters.
Long Parameter List,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingBeginsWith,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\Rules\ExcelConditionalFormattingBeginsWith.cs,ExcelConditionalFormattingBeginsWith,The method has 5 parameters.
Long Parameter List,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingBelowAverage,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\Rules\ExcelConditionalFormattingBelowAverage.cs,ExcelConditionalFormattingBelowAverage,The method has 5 parameters.
Long Parameter List,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingBelowOrEqualAverage,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\Rules\ExcelConditionalFormattingBelowOrEqualAverage.cs,ExcelConditionalFormattingBelowOrEqualAverage,The method has 5 parameters.
Long Parameter List,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingBelowStdDev,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\Rules\ExcelConditionalFormattingBelowStdDev.cs,ExcelConditionalFormattingBelowStdDev,The method has 5 parameters.
Long Parameter List,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingBetween,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\Rules\ExcelConditionalFormattingBetween.cs,ExcelConditionalFormattingBetween,The method has 5 parameters.
Long Parameter List,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingBottom,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\Rules\ExcelConditionalFormattingBottom.cs,ExcelConditionalFormattingBottom,The method has 5 parameters.
Long Parameter List,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingBottomPercent,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\Rules\ExcelConditionalFormattingBottomPercent.cs,ExcelConditionalFormattingBottomPercent,The method has 5 parameters.
Long Parameter List,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingContainsBlanks,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\Rules\ExcelConditionalFormattingContainsBlanks.cs,ExcelConditionalFormattingContainsBlanks,The method has 5 parameters.
Long Parameter List,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingContainsErrors,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\Rules\ExcelConditionalFormattingContainsErrors.cs,ExcelConditionalFormattingContainsErrors,The method has 5 parameters.
Long Parameter List,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingContainsText,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\Rules\ExcelConditionalFormattingContainsText.cs,ExcelConditionalFormattingContainsText,The method has 5 parameters.
Long Parameter List,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingDuplicateValues,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\Rules\ExcelConditionalFormattingDuplicateValues.cs,ExcelConditionalFormattingDuplicateValues,The method has 5 parameters.
Long Parameter List,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingEndsWith,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\Rules\ExcelConditionalFormattingEndsWith.cs,ExcelConditionalFormattingEndsWith,The method has 5 parameters.
Long Parameter List,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingEqual,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\Rules\ExcelConditionalFormattingEqual.cs,ExcelConditionalFormattingEqual,The method has 5 parameters.
Long Parameter List,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingExpression,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\Rules\ExcelConditionalFormattingExpression.cs,ExcelConditionalFormattingExpression,The method has 5 parameters.
Long Parameter List,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingGreaterThan,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\Rules\ExcelConditionalFormattingGreaterThan.cs,ExcelConditionalFormattingGreaterThan,The method has 5 parameters.
Long Parameter List,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingGreaterThanOrEqual,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\Rules\ExcelConditionalFormattingGreaterThanOrEqual.cs,ExcelConditionalFormattingGreaterThanOrEqual,The method has 5 parameters.
Long Parameter List,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingLast7Days,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\Rules\ExcelConditionalFormattingLast7Days.cs,ExcelConditionalFormattingLast7Days,The method has 5 parameters.
Long Parameter List,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingLastMonth,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\Rules\ExcelConditionalFormattingLastMonth.cs,ExcelConditionalFormattingLastMonth,The method has 5 parameters.
Long Parameter List,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingLastWeek,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\Rules\ExcelConditionalFormattingLastWeek.cs,ExcelConditionalFormattingLastWeek,The method has 5 parameters.
Long Parameter List,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingLessThan,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\Rules\ExcelConditionalFormattingLessThan.cs,ExcelConditionalFormattingLessThan,The method has 5 parameters.
Long Parameter List,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingLessThanOrEqual,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\Rules\ExcelConditionalFormattingLessThanOrEqual.cs,ExcelConditionalFormattingLessThanOrEqual,The method has 5 parameters.
Long Parameter List,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingNextMonth,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\Rules\ExcelConditionalFormattingNextMonth.cs,ExcelConditionalFormattingNextMonth,The method has 5 parameters.
Long Parameter List,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingNextWeek,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\Rules\ExcelConditionalFormattingNextWeek.cs,ExcelConditionalFormattingNextWeek,The method has 5 parameters.
Long Parameter List,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingNotBetween,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\Rules\ExcelConditionalFormattingNotBetween.cs,ExcelConditionalFormattingNotBetween,The method has 5 parameters.
Long Parameter List,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingNotContainsBlanks,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\Rules\ExcelConditionalFormattingNotContainsBlanks.cs,ExcelConditionalFormattingNotContainsBlanks,The method has 5 parameters.
Long Parameter List,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingNotContainsErrors,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\Rules\ExcelConditionalFormattingNotContainsErrors.cs,ExcelConditionalFormattingNotContainsErrors,The method has 5 parameters.
Long Parameter List,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingNotContainsText,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\Rules\ExcelConditionalFormattingNotContainsText.cs,ExcelConditionalFormattingNotContainsText,The method has 5 parameters.
Long Parameter List,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingNotEqual,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\Rules\ExcelConditionalFormattingNotEqual.cs,ExcelConditionalFormattingNotEqual,The method has 5 parameters.
Long Parameter List,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingRule,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\Rules\ExcelConditionalFormattingRule.cs,ExcelConditionalFormattingRule,The method has 6 parameters.
Long Parameter List,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingRule,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\Rules\ExcelConditionalFormattingRule.cs,ExcelConditionalFormattingRule,The method has 5 parameters.
Long Parameter List,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingThisMonth,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\Rules\ExcelConditionalFormattingThisMonth.cs,ExcelConditionalFormattingThisMonth,The method has 5 parameters.
Long Parameter List,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingThisWeek,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\Rules\ExcelConditionalFormattingThisWeek.cs,ExcelConditionalFormattingThisWeek,The method has 5 parameters.
Long Parameter List,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingThreeColorScale,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\Rules\ExcelConditionalFormattingThreeColorScale.cs,ExcelConditionalFormattingThreeColorScale,The method has 5 parameters.
Long Parameter List,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingThreeIconSet,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\Rules\ExcelConditionalFormattingThreeIconSet.cs,ExcelConditionalFormattingThreeIconSet,The method has 5 parameters.
Long Parameter List,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingIconSetBase,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\Rules\ExcelConditionalFormattingThreeIconSet.cs,ExcelConditionalFormattingIconSetBase,The method has 6 parameters.
Long Parameter List,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingIconSetBase,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\Rules\ExcelConditionalFormattingThreeIconSet.cs,ExcelConditionalFormattingIconSetBase,The method has 5 parameters.
Long Parameter List,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingTimePeriodGroup,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\Rules\ExcelConditionalFormattingTimePeriodGroup.cs,ExcelConditionalFormattingTimePeriodGroup,The method has 6 parameters.
Long Parameter List,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingTimePeriodGroup,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\Rules\ExcelConditionalFormattingTimePeriodGroup.cs,ExcelConditionalFormattingTimePeriodGroup,The method has 5 parameters.
Long Parameter List,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingToday,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\Rules\ExcelConditionalFormattingToday.cs,ExcelConditionalFormattingToday,The method has 5 parameters.
Long Parameter List,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingTomorrow,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\Rules\ExcelConditionalFormattingTomorrow.cs,ExcelConditionalFormattingTomorrow,The method has 5 parameters.
Long Parameter List,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingTop,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\Rules\ExcelConditionalFormattingTop.cs,ExcelConditionalFormattingTop,The method has 5 parameters.
Long Parameter List,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingTopPercent,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\Rules\ExcelConditionalFormattingTopPercent.cs,ExcelConditionalFormattingTopPercent,The method has 5 parameters.
Long Parameter List,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingTwoColorScale,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\Rules\ExcelConditionalFormattingTwoColorScale.cs,ExcelConditionalFormattingTwoColorScale,The method has 5 parameters.
Long Parameter List,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingUniqueValues,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\Rules\ExcelConditionalFormattingUniqueValues.cs,ExcelConditionalFormattingUniqueValues,The method has 5 parameters.
Long Parameter List,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingYesterday,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\Rules\ExcelConditionalFormattingYesterday.cs,ExcelConditionalFormattingYesterday,The method has 5 parameters.
Long Parameter List,OfficeOpenXml.DataValidation,ExcelDataValidationCustom,C:\repos\bambit_EPPlus\EPPlus\DataValidation\ExcelDataValidationCustom.cs,ExcelDataValidationCustom,The method has 5 parameters.
Long Parameter List,OfficeOpenXml.DataValidation,ExcelDataValidationDateTime,C:\repos\bambit_EPPlus\EPPlus\DataValidation\ExcelDataValidationDateTime.cs,ExcelDataValidationDateTime,The method has 5 parameters.
Long Parameter List,OfficeOpenXml.DataValidation,ExcelDataValidationTime,C:\repos\bambit_EPPlus\EPPlus\DataValidation\ExcelDataValidationTime.cs,ExcelDataValidationTime,The method has 5 parameters.
Long Parameter List,OfficeOpenXml.DataValidation,ExcelDataValidationWithFormula,C:\repos\bambit_EPPlus\EPPlus\DataValidation\ExcelDataValidationWithFormula.cs,ExcelDataValidationWithFormula,The method has 5 parameters.
Long Parameter List,OfficeOpenXml.DataValidation,ExcelDataValidationWithFormula2,C:\repos\bambit_EPPlus\EPPlus\DataValidation\ExcelDataValidationWithFormula2.cs,ExcelDataValidationWithFormula2,The method has 5 parameters.
Long Parameter List,OfficeOpenXml.DataValidation,ExcelDataValidationDecimal,C:\repos\bambit_EPPlus\EPPlus\DataValidation\ExcelDataValidationDecimal.cs,ExcelDataValidationDecimal,The method has 5 parameters.
Long Parameter List,OfficeOpenXml.DataValidation,ExcelDataValidationList,C:\repos\bambit_EPPlus\EPPlus\DataValidation\ExcelDataValidationList.cs,ExcelDataValidationList,The method has 5 parameters.
Long Parameter List,OfficeOpenXml.DataValidation,ExcelDataValidationInt,C:\repos\bambit_EPPlus\EPPlus\DataValidation\ExcelDataValidationInt.cs,ExcelDataValidationInt,The method has 5 parameters.
Long Parameter List,OfficeOpenXml.DataValidation,ExcelDataValidation,C:\repos\bambit_EPPlus\EPPlus\DataValidation\ExcelDataValidation.cs,ExcelDataValidation,The method has 5 parameters.
Long Parameter List,OfficeOpenXml.Drawing.Chart,ExcelChart,C:\repos\bambit_EPPlus\EPPlus\Drawing\Chart\ExcelChart.cs,ExcelChart,The method has 5 parameters.
Long Parameter List,OfficeOpenXml.Drawing.Chart,ExcelChart,C:\repos\bambit_EPPlus\EPPlus\Drawing\Chart\ExcelChart.cs,ExcelChart,The method has 6 parameters.
Long Parameter List,OfficeOpenXml.Drawing.Chart,ExcelChart,C:\repos\bambit_EPPlus\EPPlus\Drawing\Chart\ExcelChart.cs,GetChart,The method has 7 parameters.
Long Parameter List,OfficeOpenXml.Drawing.Chart,ExcelChart,C:\repos\bambit_EPPlus\EPPlus\Drawing\Chart\ExcelChart.cs,GetNewChart,The method has 5 parameters.
Long Parameter List,OfficeOpenXml.Drawing.Chart,ExcelLineChart,C:\repos\bambit_EPPlus\EPPlus\Drawing\Chart\ExcelLineChart.cs,ExcelLineChart,The method has 6 parameters.
Long Parameter List,OfficeOpenXml.Drawing.Chart,ExcelLineChart,C:\repos\bambit_EPPlus\EPPlus\Drawing\Chart\ExcelLineChart.cs,ExcelLineChart,The method has 5 parameters.
Long Parameter List,OfficeOpenXml.Drawing.Chart,ExcelOfPieChart,C:\repos\bambit_EPPlus\EPPlus\Drawing\Chart\ExcelOfPieChart.cs,ExcelOfPieChart,The method has 5 parameters.
Long Parameter List,OfficeOpenXml.Drawing.Chart,ExcelOfPieChart,C:\repos\bambit_EPPlus\EPPlus\Drawing\Chart\ExcelOfPieChart.cs,ExcelOfPieChart,The method has 6 parameters.
Long Parameter List,OfficeOpenXml.Drawing.Chart,ExcelBarChart,C:\repos\bambit_EPPlus\EPPlus\Drawing\Chart\ExcelBarChart.cs,ExcelBarChart,The method has 5 parameters.
Long Parameter List,OfficeOpenXml.Drawing.Chart,ExcelBarChart,C:\repos\bambit_EPPlus\EPPlus\Drawing\Chart\ExcelBarChart.cs,ExcelBarChart,The method has 6 parameters.
Long Parameter List,OfficeOpenXml.Drawing.Chart,ExcelDoughnutChart,C:\repos\bambit_EPPlus\EPPlus\Drawing\Chart\ExcelDoughnutChart.cs,ExcelDoughnutChart,The method has 5 parameters.
Long Parameter List,OfficeOpenXml.Drawing.Chart,ExcelDoughnutChart,C:\repos\bambit_EPPlus\EPPlus\Drawing\Chart\ExcelDoughnutChart.cs,ExcelDoughnutChart,The method has 6 parameters.
Long Parameter List,OfficeOpenXml.Drawing.Chart,ExcelPieChart,C:\repos\bambit_EPPlus\EPPlus\Drawing\Chart\ExcelPieChart.cs,ExcelPieChart,The method has 5 parameters.
Long Parameter List,OfficeOpenXml.Drawing.Chart,ExcelPieChart,C:\repos\bambit_EPPlus\EPPlus\Drawing\Chart\ExcelPieChart.cs,ExcelPieChart,The method has 6 parameters.
Long Parameter List,OfficeOpenXml.Drawing.Chart,ExcelScatterChart,C:\repos\bambit_EPPlus\EPPlus\Drawing\Chart\ExcelScatterChart.cs,ExcelScatterChart,The method has 5 parameters.
Long Parameter List,OfficeOpenXml.Drawing.Chart,ExcelScatterChart,C:\repos\bambit_EPPlus\EPPlus\Drawing\Chart\ExcelScatterChart.cs,ExcelScatterChart,The method has 6 parameters.
Long Parameter List,OfficeOpenXml.Drawing.Vml,ExcelVmlDrawingPictureCollection,C:\repos\bambit_EPPlus\EPPlus\Drawing\Vml\ExcelVmlDrawingPictureCollection.cs,Add,The method has 5 parameters.
Long Parameter List,OfficeOpenXml.Drawing.Vml,ExcelVmlDrawingPictureCollection,C:\repos\bambit_EPPlus\EPPlus\Drawing\Vml\ExcelVmlDrawingPictureCollection.cs,AddImage,The method has 5 parameters.
Long Parameter List,OfficeOpenXml,ExcelRange,C:\repos\bambit_EPPlus\EPPlus\ExcelRange.cs,ExcelRange,The method has 5 parameters.
Long Parameter List,OfficeOpenXml,ExcelStyles,C:\repos\bambit_EPPlus\EPPlus\ExcelStyles.cs,SetStyleAddress,The method has 5 parameters.
Long Parameter List,OfficeOpenXml,ExcelWorksheet,C:\repos\bambit_EPPlus\EPPlus\ExcelWorksheet.cs,ExcelWorksheet,The method has 8 parameters.
Long Parameter List,OfficeOpenXml,XmlHelper,C:\repos\bambit_EPPlus\EPPlus\XmlHelper.cs,SetXmlNodeString,The method has 5 parameters.
Long Parameter List,OfficeOpenXml,ExcelCellBase,C:\repos\bambit_EPPlus\EPPlus\ExcelCellBase.cs,Translate,The method has 6 parameters.
Long Parameter List,OfficeOpenXml,ExcelCellBase,C:\repos\bambit_EPPlus\EPPlus\ExcelCellBase.cs,ToR1C1,The method has 5 parameters.
Long Parameter List,OfficeOpenXml,ExcelCellBase,C:\repos\bambit_EPPlus\EPPlus\ExcelCellBase.cs,ToAbs,The method has 5 parameters.
Long Parameter List,OfficeOpenXml,ExcelCellBase,C:\repos\bambit_EPPlus\EPPlus\ExcelCellBase.cs,AddToRowColumnTranslator,The method has 5 parameters.
Long Parameter List,OfficeOpenXml,ExcelCellBase,C:\repos\bambit_EPPlus\EPPlus\ExcelCellBase.cs,GetRowColFromAddress,The method has 5 parameters.
Long Parameter List,OfficeOpenXml,ExcelCellBase,C:\repos\bambit_EPPlus\EPPlus\ExcelCellBase.cs,GetAddress,The method has 5 parameters.
Long Parameter List,OfficeOpenXml,ExcelCellBase,C:\repos\bambit_EPPlus\EPPlus\ExcelCellBase.cs,UpdateFormulaReferences,The method has 5 parameters.
Long Parameter List,OfficeOpenXml,ExcelRangeBase,C:\repos\bambit_EPPlus\EPPlus\ExcelRangeBase.cs,LoadFromCollection,The method has 5 parameters.
Long Parameter List,OfficeOpenXml,ExcelRangeBase,C:\repos\bambit_EPPlus\EPPlus\ExcelRangeBase.cs,IsMerged,The method has 6 parameters.
Long Parameter List,OfficeOpenXml.Utils,EncryptedPackageHandler,C:\repos\bambit_EPPlus\EPPlus\Utils\EncryptedPackageHandler.cs,StgOpenStorage,The method has 6 parameters.
Long Parameter List,OfficeOpenXml.Utils,EncryptedPackageHandler,C:\repos\bambit_EPPlus\EPPlus\Utils\EncryptedPackageHandler.cs,StgOpenStorageOnILockBytes,The method has 6 parameters.
Long Parameter List,OfficeOpenXml.Utils,IStorage,C:\repos\bambit_EPPlus\EPPlus\Utils\EncryptedPackageHandler.cs,CreateStream,The method has 5 parameters.
Long Parameter List,OfficeOpenXml.Utils,IStorage,C:\repos\bambit_EPPlus\EPPlus\Utils\EncryptedPackageHandler.cs,OpenStream,The method has 5 parameters.
Long Parameter List,OfficeOpenXml.Utils,IStorage,C:\repos\bambit_EPPlus\EPPlus\Utils\EncryptedPackageHandler.cs,CreateStorage,The method has 5 parameters.
Long Parameter List,OfficeOpenXml.Utils,IStorage,C:\repos\bambit_EPPlus\EPPlus\Utils\EncryptedPackageHandler.cs,OpenStorage,The method has 6 parameters.
Long Parameter List,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,StgOpenStorage,The method has 6 parameters.
Long Parameter List,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,StgOpenStorageOnILockBytes,The method has 6 parameters.
Long Parameter List,OfficeOpenXml.Style,ExcelGradientFill,C:\repos\bambit_EPPlus\EPPlus\Style\ExcelGradientFill.cs,ExcelGradientFill,The method has 5 parameters.
Long Parameter List,OfficeOpenXml.Style,StyleChangeEventArgs,C:\repos\bambit_EPPlus\EPPlus\Style\StyleChangeEventArgs.cs,StyleChangeEventArgs,The method has 5 parameters.
Long Parameter List,OfficeOpenXml.Style,Border,C:\repos\bambit_EPPlus\EPPlus\Style\ExcelBorder.cs,Border,The method has 5 parameters.
Long Parameter List,OfficeOpenXml.Style,ExcelBorderItem,C:\repos\bambit_EPPlus\EPPlus\Style\ExcelBorderItem.cs,ExcelBorderItem,The method has 6 parameters.
Long Parameter List,OfficeOpenXml.Style,ExcelColor,C:\repos\bambit_EPPlus\EPPlus\Style\ExcelColor.cs,ExcelColor,The method has 6 parameters.
Long Parameter List,OfficeOpenXml.Style,ExcelFill,C:\repos\bambit_EPPlus\EPPlus\Style\ExcelFill.cs,ExcelFill,The method has 5 parameters.
Long Parameter List,OfficeOpenXml.Style,ExcelStyle,C:\repos\bambit_EPPlus\EPPlus\Style\ExcelStyle.cs,ExcelStyle,The method has 5 parameters.
Long Parameter List,OfficeOpenXml.Style,ExcelFont,C:\repos\bambit_EPPlus\EPPlus\Style\ExcelFont.cs,ExcelFont,The method has 5 parameters.
Long Parameter List,OfficeOpenXml.Style,ExcelNumberFormat,C:\repos\bambit_EPPlus\EPPlus\Style\ExcelNumberFormat.cs,ExcelNumberFormat,The method has 5 parameters.
Long Parameter List,OfficeOpenXml.Style.XmlAccess,ExcelXfs,C:\repos\bambit_EPPlus\EPPlus\Style\XmlAccess\ExcelXfsXml.cs,GetNewID,The method has 5 parameters.
Long Parameter List,OfficeOpenXml.Table.PivotTable,ExcelPivotTableField,C:\repos\bambit_EPPlus\EPPlus\Table\PivotTable\ExcelPivotTableField.cs,ExcelPivotTableField,The method has 5 parameters.
Long Parameter List,OfficeOpenXml.Table.PivotTable,ExcelPivotTableField,C:\repos\bambit_EPPlus\EPPlus\Table\PivotTable\ExcelPivotTableField.cs,AddDateGroupItems,The method has 5 parameters.
Long Parameter List,OfficeOpenXml.Table.PivotTable,ExcelPivotTableField,C:\repos\bambit_EPPlus\EPPlus\Table\PivotTable\ExcelPivotTableField.cs,AddField,The method has 5 parameters.
Long Parameter List,OfficeOpenXml.Table.PivotTable,ExcelPivotTable,C:\repos\bambit_EPPlus\EPPlus\Table\PivotTable\ExcelPivotTable.cs,ExcelPivotTable,The method has 5 parameters.
Long Identifier,OfficeOpenXml.Utils,EncryptedPackageHandler,C:\repos\bambit_EPPlus\EPPlus\Utils\EncryptedPackageHandler.cs,CreateDataSpaces,The length of the parameter strongEncryptionDataSpaceStream is 31.
Long Statement,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingCollection,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\ExcelConditionalFormattingCollection.cs,RemoveAll,The length of the statement  "	var conditionalFormattingNodes = TopNode.SelectNodes ("//" + ExcelConditionalFormattingConstants.Paths.ConditionalFormatting' _worksheet.NameSpaceManager); " is 155.
Long Statement,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingCollection,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\ExcelConditionalFormattingCollection.cs,AddRule,The length of the statement  "	IExcelConditionalFormattingRule cfRule = ExcelConditionalFormattingRuleFactory.Create (type' address' GetNextPriority ()' _worksheet' null); " is 140.
Long Statement,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingCollection,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\ExcelConditionalFormattingCollection.cs,AddAboveOrEqualAverage,The length of the statement  "	return (IExcelConditionalFormattingAverageGroup)AddRule (eExcelConditionalFormattingRuleType.AboveOrEqualAverage' address); " is 123.
Long Statement,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingCollection,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\ExcelConditionalFormattingCollection.cs,AddBelowOrEqualAverage,The length of the statement  "	return (IExcelConditionalFormattingAverageGroup)AddRule (eExcelConditionalFormattingRuleType.BelowOrEqualAverage' address); " is 123.
Long Statement,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingCollection,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\ExcelConditionalFormattingCollection.cs,AddContainsBlanks,The length of the statement  "	return (IExcelConditionalFormattingContainsBlanks)AddRule (eExcelConditionalFormattingRuleType.ContainsBlanks' address); " is 120.
Long Statement,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingCollection,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\ExcelConditionalFormattingCollection.cs,AddContainsErrors,The length of the statement  "	return (IExcelConditionalFormattingContainsErrors)AddRule (eExcelConditionalFormattingRuleType.ContainsErrors' address); " is 120.
Long Statement,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingCollection,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\ExcelConditionalFormattingCollection.cs,AddDuplicateValues,The length of the statement  "	return (IExcelConditionalFormattingDuplicateValues)AddRule (eExcelConditionalFormattingRuleType.DuplicateValues' address); " is 122.
Long Statement,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingCollection,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\ExcelConditionalFormattingCollection.cs,AddGreaterThanOrEqual,The length of the statement  "	return (IExcelConditionalFormattingGreaterThanOrEqual)AddRule (eExcelConditionalFormattingRuleType.GreaterThanOrEqual' address); " is 128.
Long Statement,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingCollection,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\ExcelConditionalFormattingCollection.cs,AddLessThanOrEqual,The length of the statement  "	return (IExcelConditionalFormattingLessThanOrEqual)AddRule (eExcelConditionalFormattingRuleType.LessThanOrEqual' address); " is 122.
Long Statement,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingCollection,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\ExcelConditionalFormattingCollection.cs,AddNotContainsBlanks,The length of the statement  "	return (IExcelConditionalFormattingNotContainsBlanks)AddRule (eExcelConditionalFormattingRuleType.NotContainsBlanks' address); " is 126.
Long Statement,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingCollection,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\ExcelConditionalFormattingCollection.cs,AddNotContainsErrors,The length of the statement  "	return (IExcelConditionalFormattingNotContainsErrors)AddRule (eExcelConditionalFormattingRuleType.NotContainsErrors' address); " is 126.
Long Statement,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingCollection,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\ExcelConditionalFormattingCollection.cs,AddNotContainsText,The length of the statement  "	return (IExcelConditionalFormattingNotContainsText)AddRule (eExcelConditionalFormattingRuleType.NotContainsText' address); " is 122.
Long Statement,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingCollection,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\ExcelConditionalFormattingCollection.cs,AddThreeColorScale,The length of the statement  "	return (IExcelConditionalFormattingThreeColorScale)AddRule (eExcelConditionalFormattingRuleType.ThreeColorScale' address); " is 122.
Long Statement,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingCollection,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\ExcelConditionalFormattingCollection.cs,AddThreeIconSet,The length of the statement  "	var icon = (IExcelConditionalFormattingThreeIconSet<eExcelconditionalFormatting3IconsSetType>)AddRule (eExcelConditionalFormattingRuleType.ThreeIconSet' Address); " is 162.
Long Statement,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingCollection,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\ExcelConditionalFormattingCollection.cs,AddFourIconSet,The length of the statement  "	var icon = (IExcelConditionalFormattingFourIconSet<eExcelconditionalFormatting4IconsSetType>)AddRule (eExcelConditionalFormattingRuleType.FourIconSet' Address); " is 160.
Long Statement,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingRuleFactory,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\ExcelConditionalFormattingRuleFactory.cs,Create,The length of the statement  "		return new ExcelConditionalFormattingDataBar (eExcelConditionalFormattingRuleType.DataBar' address' priority' worksheet' itemElementNode' null); " is 144.
Long Statement,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingRuleFactory,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\ExcelConditionalFormattingRuleFactory.cs,Create,The length of the statement  "	throw new InvalidOperationException (string.Format (ExcelConditionalFormattingConstants.Errors.NonSupportedRuleType' type.ToString ())); " is 136.
Long Statement,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingRuleType,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\ExcelConditionalFormattingRuleType.cs,GetColorScaleType,The length of the statement  "	var cfvoNodes = topNode.SelectNodes (string.Format ("{0}/{1}"' ExcelConditionalFormattingConstants.Paths.ColorScale' ExcelConditionalFormattingConstants.Paths.Cfvo)' nameSpaceManager); " is 184.
Long Statement,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingRuleType,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\ExcelConditionalFormattingRuleType.cs,GetColorScaleType,The length of the statement  "	var colorNodes = topNode.SelectNodes (string.Format ("{0}/{1}"' ExcelConditionalFormattingConstants.Paths.ColorScale' ExcelConditionalFormattingConstants.Paths.Color)' nameSpaceManager); " is 186.
Long Statement,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingRuleType,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\ExcelConditionalFormattingRuleType.cs,GetColorScaleType,The length of the statement  "	if ((cfvoNodes == null) || (cfvoNodes.Count < 2) || (cfvoNodes.Count > 3) || (colorNodes == null) || (colorNodes.Count < 2) || (colorNodes.Count > 3) || (cfvoNodes.Count != colorNodes.Count)) { " is 193.
Long Statement,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingRuleType,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\ExcelConditionalFormattingRuleType.cs,GetColorScaleType,The length of the statement  "	return (cfvoNodes.Count == 2) ? eExcelConditionalFormattingRuleType.TwoColorScale : eExcelConditionalFormattingRuleType.ThreeColorScale; " is 136.
Long Statement,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingRuleType,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\ExcelConditionalFormattingRuleType.cs,GetAboveAverageType,The length of the statement  "	int? stdDev = ExcelConditionalFormattingHelper.GetAttributeIntNullable (topNode' ExcelConditionalFormattingConstants.Attributes.StdDev); " is 136.
Long Statement,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingRuleType,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\ExcelConditionalFormattingRuleType.cs,GetAboveAverageType,The length of the statement  "	bool? isAboveAverage = ExcelConditionalFormattingHelper.GetAttributeBoolNullable (topNode' ExcelConditionalFormattingConstants.Attributes.AboveAverage); " is 152.
Long Statement,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingRuleType,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\ExcelConditionalFormattingRuleType.cs,GetAboveAverageType,The length of the statement  "	bool? isEqualAverage = ExcelConditionalFormattingHelper.GetAttributeBoolNullable (topNode' ExcelConditionalFormattingConstants.Attributes.EqualAverage); " is 152.
Long Statement,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingRuleType,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\ExcelConditionalFormattingRuleType.cs,GetTop10Type,The length of the statement  "	bool? isBottom = ExcelConditionalFormattingHelper.GetAttributeBoolNullable (topNode' ExcelConditionalFormattingConstants.Attributes.Bottom); " is 140.
Long Statement,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingRuleType,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\ExcelConditionalFormattingRuleType.cs,GetTop10Type,The length of the statement  "	bool? isPercent = ExcelConditionalFormattingHelper.GetAttributeBoolNullable (topNode' ExcelConditionalFormattingConstants.Attributes.Percent); " is 142.
Long Statement,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingRuleType,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\ExcelConditionalFormattingRuleType.cs,GetTimePeriodType,The length of the statement  "	eExcelConditionalFormattingTimePeriodType timePeriod = ExcelConditionalFormattingTimePeriodType.GetTypeByAttribute (ExcelConditionalFormattingHelper.GetAttributeString (topNode' ExcelConditionalFormattingConstants.Attributes.TimePeriod)); " is 238.
Long Statement,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingHelper,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\ExcelConditionalFormattingHelper.cs,EncodeXML,The length of the statement  "	return s.Replace ("&"' "&amp;").Replace ("<"' "&lt;").Replace (">"' "&gt;").Replace ("\""' "&quot;").Replace ("'"' "&apos;"); " is 125.
Long Statement,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingHelper,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\ExcelConditionalFormattingHelper.cs,DecodeXML,The length of the statement  "	return s.Replace ("'"' "&apos;").Replace ("\""' "&quot;").Replace (">"' "&gt;").Replace ("<"' "&lt;").Replace ("&"' "&amp;"); " is 125.
Long Statement,OfficeOpenXml.ConditionalFormatting,RangeConditionalFormatting,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\RangeConditionalFormatting.cs,AddThreeColorScale,The length of the statement  "	return (IExcelConditionalFormattingThreeColorScale)(_worksheet.ConditionalFormatting.AddRule (eExcelConditionalFormattingRuleType.ThreeColorScale' _address)); " is 158.
Long Statement,OfficeOpenXml.ConditionalFormatting,RangeConditionalFormatting,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\RangeConditionalFormatting.cs,AddTwoColorScale,The length of the statement  "	return (IExcelConditionalFormattingTwoColorScale)(_worksheet.ConditionalFormatting.AddRule (eExcelConditionalFormattingRuleType.TwoColorScale' _address)); " is 154.
Long Statement,OfficeOpenXml.ConditionalFormatting,RangeConditionalFormatting,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\RangeConditionalFormatting.cs,AddThreeIconSet,The length of the statement  "	var rule = (IExcelConditionalFormattingThreeIconSet<eExcelconditionalFormatting3IconsSetType>)(_worksheet.ConditionalFormatting.AddRule (eExcelConditionalFormattingRuleType.ThreeIconSet' _address)); " is 198.
Long Statement,OfficeOpenXml.ConditionalFormatting,RangeConditionalFormatting,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\RangeConditionalFormatting.cs,AddFourIconSet,The length of the statement  "	var rule = (IExcelConditionalFormattingFourIconSet<eExcelconditionalFormatting4IconsSetType>)(_worksheet.ConditionalFormatting.AddRule (eExcelConditionalFormattingRuleType.FourIconSet' _address)); " is 196.
Long Statement,OfficeOpenXml.ConditionalFormatting,RangeConditionalFormatting,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\RangeConditionalFormatting.cs,AddFiveIconSet,The length of the statement  "	var rule = (IExcelConditionalFormattingFiveIconSet)(_worksheet.ConditionalFormatting.AddRule (eExcelConditionalFormattingRuleType.FiveIconSet' _address)); " is 154.
Long Statement,OfficeOpenXml.ConditionalFormatting,RangeConditionalFormatting,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\RangeConditionalFormatting.cs,AddDatabar,The length of the statement  "	var rule = (IExcelConditionalFormattingDataBarGroup)(_worksheet.ConditionalFormatting.AddRule (eExcelConditionalFormattingRuleType.DataBar' _address)); " is 151.
Long Statement,OfficeOpenXml.DataValidation,ExcelDataValidationWithFormula,C:\repos\bambit_EPPlus\EPPlus\DataValidation\ExcelDataValidationWithFormula.cs,Validate,The length of the statement  "			throw new InvalidOperationException ("Validation of " + Address.Address + " failed: Formula2 must be set if operator is 'between' or 'notBetween'"); " is 148.
Long Statement,OfficeOpenXml.DataValidation,ExcelTime,C:\repos\bambit_EPPlus\EPPlus\DataValidation\ExcelTime.cs,ToString,The length of the statement  "	return string.Format ("{0}:{1}:{2}"' Hour < 10 ? "0" + Hour.ToString () : Hour.ToString ()' Minute < 10 ? "0" + Minute.ToString () : Minute.ToString ()' second < 10 ? "0" + second.ToString () : second.ToString ()); " is 214.
Long Statement,OfficeOpenXml.DataValidation,ExcelDataValidationCollection,C:\repos\bambit_EPPlus\EPPlus\DataValidation\ExcelDataValidationCollection.cs,ValidateAddress,The length of the statement  "				throw new InvalidOperationException (string.Format ("The address ({0}) collides with an existing validation ({1})"' address' validation.Address.Address)); " is 154.
Long Statement,OfficeOpenXml.DataValidation,ExcelDataValidationCollection,C:\repos\bambit_EPPlus\EPPlus\DataValidation\ExcelDataValidationCollection.cs,RemoveAll,The length of the statement  "		TopNode.SelectSingleNode (DataValidationPath.TrimStart ('/')' NameSpaceManager).RemoveChild (((ExcelDataValidation)m).TopNode); " is 127.
Long Statement,OfficeOpenXml.Drawing.Chart,ExcelChart,C:\repos\bambit_EPPlus\EPPlus\Drawing\Chart\ExcelChart.cs,InitChartLoad,The length of the statement  "	_chartSeries = new ExcelChartSeries (this' drawings.NameSpaceManager' _chartNode' isPivot/*ChartXml.SelectSingleNode(_chartPath' drawings.NameSpaceManager)*/); " is 159.
Long Statement,OfficeOpenXml.Drawing.Chart,ExcelChart,C:\repos\bambit_EPPlus\EPPlus\Drawing\Chart\ExcelChart.cs,CreateNewChart,The length of the statement  "		graphFrame.InnerXml = string.Format ("<xdr:nvGraphicFramePr><xdr:cNvPr id=\"{0}\" name=\"Chart 1\" /><xdr:cNvGraphicFramePr /></xdr:nvGraphicFramePr><xdr:xfrm><a:off x=\"0\" y=\"0\" /> <a:ext cx=\"0\" cy=\"0\" /></xdr:xfrm><a:graphic><a:graphicData uri=\"http://schemas.openxmlformats.org/drawingml/2006/chart\"><c:chart xmlns:c=\"http://schemas.openxmlformats.org/drawingml/2006/chart\" xmlns:r=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships\" r:id=\"rId1\" />   </a:graphicData>  </a:graphic>"' _id); " is 525.
Long Statement,OfficeOpenXml.Drawing.Chart,ExcelChart,C:\repos\bambit_EPPlus\EPPlus\Drawing\Chart\ExcelChart.cs,CreateNewChart,The length of the statement  "		Part = package.CreatePart (UriChart' "application/vnd.openxmlformats-officedocument.drawingml.chart+xml"' _drawings._package.Compression); " is 138.
Long Statement,OfficeOpenXml.Drawing.Chart,ExcelChart,C:\repos\bambit_EPPlus\EPPlus\Drawing\Chart\ExcelChart.cs,CreateNewChart,The length of the statement  "		PackageRelationship chartRelation = drawings.Part.CreateRelationship (PackUriHelper.GetRelativeUri (drawings.UriDrawing' UriChart)' TargetMode.Internal' ExcelPackage.schemaRelationships + "/chart"); " is 198.
Long Statement,OfficeOpenXml.Drawing.Chart,ExcelChart,C:\repos\bambit_EPPlus\EPPlus\Drawing\Chart\ExcelChart.cs,CreateNewChart,The length of the statement  "		graphFrame.SelectSingleNode ("a:graphic/a:graphicData/c:chart"' NameSpaceManager).Attributes ["r:id"].Value = chartRelation.Id; " is 127.
Long Statement,OfficeOpenXml.Drawing.Chart,ExcelChart,C:\repos\bambit_EPPlus\EPPlus\Drawing\Chart\ExcelChart.cs,CreateNewChart,The length of the statement  "		_chartNode = ChartXml.SelectSingleNode (string.Format ("c:chartSpace/c:chart/c:plotArea/{0}"' GetChartNodeText ())' NameSpaceManager); " is 134.
Long Statement,OfficeOpenXml.Drawing.Chart,ExcelChart,C:\repos\bambit_EPPlus\EPPlus\Drawing\Chart\ExcelChart.cs,ChartStartXml,The length of the statement  "	xml.AppendFormat ("<c:chartSpace xmlns:c=\"{0}\" xmlns:a=\"{1}\" xmlns:r=\"{2}\">"' ExcelPackage.schemaChart' ExcelPackage.schemaDrawings' ExcelPackage.schemaRelationships); " is 173.
Long Statement,OfficeOpenXml.Drawing.Chart,ExcelChart,C:\repos\bambit_EPPlus\EPPlus\Drawing\Chart\ExcelChart.cs,ChartStartXml,The length of the statement  "			xml.AppendFormat ("<c:valAx><c:axId val=\"{0}\"/><c:scaling><c:orientation val=\"minMax\"/></c:scaling><c:delete val=\"0\"/><c:axPos val=\"b\"/><c:tickLblPos val=\"nextTo\"/><c:crossAx val=\"{1}\"/><c:crosses val=\"autoZero\"/></c:valAx>"' axID' xAxID); " is 253.
Long Statement,OfficeOpenXml.Drawing.Chart,ExcelChart,C:\repos\bambit_EPPlus\EPPlus\Drawing\Chart\ExcelChart.cs,ChartStartXml,The length of the statement  "			xml.AppendFormat ("<c:catAx><c:axId val=\"{0}\"/><c:scaling><c:orientation val=\"minMax\"/></c:scaling><c:delete val=\"0\"/><c:axPos val=\"b\"/><c:tickLblPos val=\"nextTo\"/><c:crossAx val=\"{1}\"/><c:crosses val=\"autoZero\"/><c:auto val=\"1\"/><c:lblAlgn val=\"ctr\"/><c:lblOffset val=\"100\"/></c:catAx>"' axID' xAxID); " is 322.
Long Statement,OfficeOpenXml.Drawing.Chart,ExcelChart,C:\repos\bambit_EPPlus\EPPlus\Drawing\Chart\ExcelChart.cs,ChartStartXml,The length of the statement  "		xml.AppendFormat ("<c:valAx><c:axId val=\"{1}\"/><c:scaling><c:orientation val=\"minMax\"/></c:scaling><c:delete val=\"0\"/><c:axPos val=\"l\"/><c:majorGridlines/><c:tickLblPos val=\"nextTo\"/><c:crossAx val=\"1\"/><c:crosses val=\"autoZero\"/><c:crossBetween val=\"between\"/></c:valAx>"' axID' xAxID); " is 303.
Long Statement,OfficeOpenXml.Drawing.Chart,ExcelChart,C:\repos\bambit_EPPlus\EPPlus\Drawing\Chart\ExcelChart.cs,ChartStartXml,The length of the statement  "	xml.AppendFormat ("</c:plotArea><c:legend><c:legendPos val=\"r\"/><c:layout/><c:overlay val=\"0\" /></c:legend><c:plotVisOnly val=\"1\"/></c:chart>"' axID' xAxID); " is 163.
Long Statement,OfficeOpenXml.Drawing.Chart,ExcelChart,C:\repos\bambit_EPPlus\EPPlus\Drawing\Chart\ExcelChart.cs,ChartStartXml,The length of the statement  "	xml.Append ("<c:printSettings><c:headerFooter/><c:pageMargins b=\"0.75\" l=\"0.7\" r=\"0.7\" t=\"0.75\" header=\"0.3\" footer=\"0.3\"/><c:pageSetup/></c:printSettings></c:chartSpace>"); " is 185.
Long Statement,OfficeOpenXml.Drawing.Chart,ExcelChart,C:\repos\bambit_EPPlus\EPPlus\Drawing\Chart\ExcelChart.cs,GetChartSerieStartXml,The length of the statement  "	if (ChartType == eChartType.BarStacked100 || ChartType == eChartType.BarStacked || ChartType == eChartType.ColumnStacked || ChartType == eChartType.ColumnStacked100) { " is 167.
Long Statement,OfficeOpenXml.Drawing.Chart,ExcelChart,C:\repos\bambit_EPPlus\EPPlus\Drawing\Chart\ExcelChart.cs,AddScatterType,The length of the statement  "	if (type == eChartType.XYScatter || type == eChartType.XYScatterLines || type == eChartType.XYScatterLinesNoMarkers || type == eChartType.XYScatterSmooth || type == eChartType.XYScatterSmoothNoMarkers) { " is 203.
Long Statement,OfficeOpenXml.Drawing.Chart,ExcelChart,C:\repos\bambit_EPPlus\EPPlus\Drawing\Chart\ExcelChart.cs,AddHasMarker,The length of the statement  "	if (type == eChartType.LineMarkers || type == eChartType.LineMarkersStacked || type == eChartType.LineMarkersStacked100/*||" is 123.
Long Statement,OfficeOpenXml.Drawing.Chart,ExcelChart,C:\repos\bambit_EPPlus\EPPlus\Drawing\Chart\ExcelChart.cs,IsType3D,The length of the statement  "	return chartType == eChartType.Area3D || chartType == eChartType.AreaStacked3D || chartType == eChartType.AreaStacked1003D || chartType == eChartType.BarClustered3D || chartType == eChartType.BarStacked3D || chartType == eChartType.BarStacked1003D || chartType == eChartType.Column3D || chartType == eChartType.ColumnClustered3D || chartType == eChartType.ColumnStacked3D || chartType == eChartType.ColumnStacked1003D || chartType == eChartType.Line3D || chartType == eChartType.Pie3D || chartType == eChartType.PieExploded3D || chartType == eChartType.Bubble3DEffect || chartType == eChartType.ConeBarClustered || chartType == eChartType.ConeBarStacked || chartType == eChartType.ConeBarStacked100 || chartType == eChartType.ConeCol || chartType == eChartType.ConeColClustered || chartType == eChartType.ConeColStacked || chartType == eChartType.ConeColStacked100 || chartType == eChartType.CylinderBarClustered || chartType == eChartType.CylinderBarStacked || chartType == eChartType.CylinderBarStacked100 || chartType == eChartType.CylinderCol || chartType == eChartType.CylinderColClustered || chartType == eChartType.CylinderColStacked || chartType == eChartType.CylinderColStacked100 || chartType == eChartType.PyramidBarClustered || chartType == eChartType.PyramidBarStacked || chartType == eChartType.PyramidBarStacked100 || chartType == eChartType.PyramidCol || chartType == eChartType.PyramidColClustered || chartType == eChartType.PyramidColStacked || chartType == eChartType.PyramidColStacked100/*||" is 1511.
Long Statement,OfficeOpenXml.Drawing.Chart,ExcelChart,C:\repos\bambit_EPPlus\EPPlus\Drawing\Chart\ExcelChart.cs,IsTypeLine,The length of the statement  "	return ChartType == eChartType.Line || ChartType == eChartType.LineMarkers || ChartType == eChartType.LineMarkersStacked100 || ChartType == eChartType.LineStacked || ChartType == eChartType.LineStacked100 || ChartType == eChartType.Line3D; " is 239.
Long Statement,OfficeOpenXml.Drawing.Chart,ExcelChart,C:\repos\bambit_EPPlus\EPPlus\Drawing\Chart\ExcelChart.cs,IsTypeScatter,The length of the statement  "	return ChartType == eChartType.XYScatter || ChartType == eChartType.XYScatterLines || ChartType == eChartType.XYScatterLinesNoMarkers || ChartType == eChartType.XYScatterSmooth || ChartType == eChartType.XYScatterSmoothNoMarkers; " is 229.
Long Statement,OfficeOpenXml.Drawing.Chart,ExcelChart,C:\repos\bambit_EPPlus\EPPlus\Drawing\Chart\ExcelChart.cs,IsTypeShape,The length of the statement  "	return ChartType == eChartType.BarClustered3D || ChartType == eChartType.BarStacked3D || ChartType == eChartType.BarStacked1003D || ChartType == eChartType.BarClustered3D || ChartType == eChartType.BarStacked3D || ChartType == eChartType.BarStacked1003D || ChartType == eChartType.Column3D || ChartType == eChartType.ColumnClustered3D || ChartType == eChartType.ColumnStacked3D || ChartType == eChartType.ColumnStacked1003D || //ChartType == eChartType.3DPie || " is 461.
Long Statement,OfficeOpenXml.Drawing.Chart,ExcelChart,C:\repos\bambit_EPPlus\EPPlus\Drawing\Chart\ExcelChart.cs,IsTypeShape,The length of the statement  "	ChartType == eChartType.Bubble3DEffect || ChartType == eChartType.ConeBarClustered || ChartType == eChartType.ConeBarStacked || ChartType == eChartType.ConeBarStacked100 || ChartType == eChartType.ConeCol || ChartType == eChartType.ConeColClustered || ChartType == eChartType.ConeColStacked || ChartType == eChartType.ConeColStacked100 || ChartType == eChartType.CylinderBarClustered || ChartType == eChartType.CylinderBarStacked || ChartType == eChartType.CylinderBarStacked100 || ChartType == eChartType.CylinderCol || ChartType == eChartType.CylinderColClustered || ChartType == eChartType.CylinderColStacked || ChartType == eChartType.CylinderColStacked100 || ChartType == eChartType.PyramidBarClustered || ChartType == eChartType.PyramidBarStacked || ChartType == eChartType.PyramidBarStacked100 || ChartType == eChartType.PyramidCol || ChartType == eChartType.PyramidColClustered || ChartType == eChartType.PyramidColStacked || ChartType == eChartType.PyramidColStacked100; " is 979.
Long Statement,OfficeOpenXml.Drawing.Chart,ExcelChart,C:\repos\bambit_EPPlus\EPPlus\Drawing\Chart\ExcelChart.cs,IsTypePercentStacked,The length of the statement  "	return ChartType == eChartType.AreaStacked100 || ChartType == eChartType.BarStacked100 || ChartType == eChartType.BarStacked1003D || ChartType == eChartType.ColumnStacked100 || ChartType == eChartType.ColumnStacked1003D || ChartType == eChartType.ConeBarStacked100 || ChartType == eChartType.ConeColStacked100 || ChartType == eChartType.CylinderBarStacked100 || ChartType == eChartType.CylinderColStacked || ChartType == eChartType.LineMarkersStacked100 || ChartType == eChartType.LineStacked100 || ChartType == eChartType.PyramidBarStacked100 || ChartType == eChartType.PyramidColStacked100; " is 592.
Long Statement,OfficeOpenXml.Drawing.Chart,ExcelChart,C:\repos\bambit_EPPlus\EPPlus\Drawing\Chart\ExcelChart.cs,IsTypeStacked,The length of the statement  "	return ChartType == eChartType.AreaStacked || ChartType == eChartType.AreaStacked3D || ChartType == eChartType.BarStacked || ChartType == eChartType.BarStacked3D || ChartType == eChartType.ColumnStacked3D || ChartType == eChartType.ColumnStacked || ChartType == eChartType.ConeBarStacked || ChartType == eChartType.ConeColStacked || ChartType == eChartType.CylinderBarStacked || ChartType == eChartType.CylinderColStacked || ChartType == eChartType.LineMarkersStacked || ChartType == eChartType.LineStacked || ChartType == eChartType.PyramidBarStacked || ChartType == eChartType.PyramidColStacked; " is 597.
Long Statement,OfficeOpenXml.Drawing.Chart,ExcelChart,C:\repos\bambit_EPPlus\EPPlus\Drawing\Chart\ExcelChart.cs,IsTypeClustered,The length of the statement  "	return ChartType == eChartType.BarClustered || ChartType == eChartType.BarClustered3D || ChartType == eChartType.ColumnClustered3D || ChartType == eChartType.ColumnClustered || ChartType == eChartType.ConeBarClustered || ChartType == eChartType.ConeColClustered || ChartType == eChartType.CylinderBarClustered || ChartType == eChartType.CylinderColClustered || ChartType == eChartType.PyramidBarClustered || ChartType == eChartType.PyramidColClustered; " is 452.
Long Statement,OfficeOpenXml.Drawing.Chart,ExcelChart,C:\repos\bambit_EPPlus\EPPlus\Drawing\Chart\ExcelChart.cs,IsTypePieDoughnut,The length of the statement  "	return ChartType == eChartType.Pie || ChartType == eChartType.PieExploded || ChartType == eChartType.PieOfPie || ChartType == eChartType.Pie3D || ChartType == eChartType.PieExploded3D || ChartType == eChartType.BarOfPie || ChartType == eChartType.Doughnut || ChartType == eChartType.DoughnutExploded; " is 300.
Long Statement,OfficeOpenXml.Drawing.Chart,ExcelChart,C:\repos\bambit_EPPlus\EPPlus\Drawing\Chart\ExcelChart.cs,AddAxis,The length of the statement  "		axID = int.Parse (_axis [0].Id) < int.Parse (_axis [1].Id) ? int.Parse (_axis [1].Id) + 1 : int.Parse (_axis [0].Id) + 1; " is 121.
Long Statement,OfficeOpenXml.Drawing.Chart,ExcelChart,C:\repos\bambit_EPPlus\EPPlus\Drawing\Chart\ExcelChart.cs,AddAxis,The length of the statement  "		catAx.InnerXml = string.Format ("<c:axId val=\"{0}\"/><c:scaling><c:orientation val=\"minMax\"/></c:scaling><c:delete val=\"0\" /><c:axPos val=\"b\"/><c:tickLblPos val=\"nextTo\"/><c:crossAx val=\"{1}\"/><c:crosses val=\"autoZero\"/><c:auto val=\"1\"/><c:lblAlgn val=\"ctr\"/><c:lblOffset val=\"100\"/>"' axID' axID + 1); " is 321.
Long Statement,OfficeOpenXml.Drawing.Chart,ExcelChart,C:\repos\bambit_EPPlus\EPPlus\Drawing\Chart\ExcelChart.cs,AddAxis,The length of the statement  "		valAx.InnerXml = string.Format ("<c:axId val=\"{1}\"/><c:scaling><c:orientation val=\"minMax\"/></c:scaling><c:delete val=\"0\" /><c:axPos val=\"l\"/><c:majorGridlines/><c:tickLblPos val=\"nextTo\"/><c:crossAx val=\"{0}\"/><c:crosses val=\"autoZero\"/><c:crossBetween val=\"between\"/>"' axID' axID + 1); " is 304.
Long Statement,OfficeOpenXml.Drawing.Chart,ExcelChart,C:\repos\bambit_EPPlus\EPPlus\Drawing\Chart\ExcelChart.cs,AddAxis,The length of the statement  "		catAx.InnerXml = string.Format ("<c:axId val=\"{0}\"/><c:scaling><c:orientation val=\"minMax\"/></c:scaling><c:delete val=\"1\" /><c:axPos val=\"b\"/><c:tickLblPos val=\"none\"/><c:crossAx val=\"{1}\"/><c:crosses val=\"autoZero\"/>"' axID' axID + 1); " is 250.
Long Statement,OfficeOpenXml.Drawing.Chart,ExcelChart,C:\repos\bambit_EPPlus\EPPlus\Drawing\Chart\ExcelChart.cs,AddAxis,The length of the statement  "		valAx.InnerXml = string.Format ("<c:axId val=\"{0}\"/><c:scaling><c:orientation val=\"minMax\"/></c:scaling><c:delete val=\"0\" /><c:axPos val=\"r\"/><c:tickLblPos val=\"nextTo\"/><c:crossAx val=\"{1}\"/><c:crosses val=\"max\"/><c:crossBetween val=\"between\"/>"' axID + 1' axID); " is 280.
Long Statement,OfficeOpenXml.Drawing.Chart,ExcelChart,C:\repos\bambit_EPPlus\EPPlus\Drawing\Chart\ExcelChart.cs,ExistsAxis,The length of the statement  "			if (chartType.XAxis.AxisPosition == excelChartAxis.AxisPosition || chartType.YAxis.AxisPosition == excelChartAxis.AxisPosition) { " is 129.
Long Statement,OfficeOpenXml.Drawing.Chart,ExcelChart,C:\repos\bambit_EPPlus\EPPlus\Drawing\Chart\ExcelChart.cs,GetChart,The length of the statement  "	XmlNode chartNode = node.SelectSingleNode ("xdr:graphicFrame/a:graphic/a:graphicData/c:chart"' drawings.NameSpaceManager); " is 122.
Long Statement,OfficeOpenXml.Drawing.Chart,ExcelChart,C:\repos\bambit_EPPlus\EPPlus\Drawing\Chart\ExcelChart.cs,SetPivotSource,The length of the statement  "	pivotSource.InnerXml = string.Format ("<c:name>[]{0}!{1}</c:name><c:fmtId val=\"0\"/>"' PivotTableSource.WorkSheet.Name' pivotTableSource.Name); " is 144.
Long Statement,OfficeOpenXml.Drawing.Chart,ExcelChartCollection,C:\repos\bambit_EPPlus\EPPlus\Drawing\Chart\ExcelChartCollection.cs,Add,The length of the statement  "	ExcelChart chart = ExcelChart.GetNewChart (_topChart.WorkSheet.Drawings' _topChart.TopNode' chartType' _topChart' null); " is 120.
Long Statement,OfficeOpenXml.Drawing.Chart,ExcelChartTrendlineCollection,C:\repos\bambit_EPPlus\EPPlus\Drawing\Chart\ExcelChartTrendline.cs,Add,The length of the statement  "	if (_serie._chartSeries._chart.IsType3D () || _serie._chartSeries._chart.IsTypePercentStacked () || _serie._chartSeries._chart.IsTypeStacked () || _serie._chartSeries._chart.IsTypePieDoughnut ()) { " is 197.
Long Statement,OfficeOpenXml.Drawing.Chart,ExcelBarChart,C:\repos\bambit_EPPlus\EPPlus\Drawing\Chart\ExcelBarChart.cs,SetTypeProperties,The length of the statement  "	/******* Bar direction *******/if (type == eChartType.BarClustered || type == eChartType.BarStacked || type == eChartType.BarStacked100 || type == eChartType.BarClustered3D || type == eChartType.BarStacked3D || type == eChartType.BarStacked1003D || type == eChartType.ConeBarClustered || type == eChartType.ConeBarStacked || type == eChartType.ConeBarStacked100 || type == eChartType.CylinderBarClustered || type == eChartType.CylinderBarStacked || type == eChartType.CylinderBarStacked100 || type == eChartType.PyramidBarClustered || type == eChartType.PyramidBarStacked || type == eChartType.PyramidBarStacked100) { " is 617.
Long Statement,OfficeOpenXml.Drawing.Chart,ExcelBarChart,C:\repos\bambit_EPPlus\EPPlus\Drawing\Chart\ExcelBarChart.cs,SetTypeProperties,The length of the statement  "	else if (type == eChartType.ColumnClustered || type == eChartType.ColumnStacked || type == eChartType.ColumnStacked100 || type == eChartType.Column3D || type == eChartType.ColumnClustered3D || type == eChartType.ColumnStacked3D || type == eChartType.ColumnStacked1003D || type == eChartType.ConeCol || type == eChartType.ConeColClustered || type == eChartType.ConeColStacked || type == eChartType.ConeColStacked100 || type == eChartType.CylinderCol || type == eChartType.CylinderColClustered || type == eChartType.CylinderColStacked || type == eChartType.CylinderColStacked100 || type == eChartType.PyramidCol || type == eChartType.PyramidColClustered || type == eChartType.PyramidColStacked || type == eChartType.PyramidColStacked100) { " is 737.
Long Statement,OfficeOpenXml.Drawing.Chart,ExcelBarChart,C:\repos\bambit_EPPlus\EPPlus\Drawing\Chart\ExcelBarChart.cs,SetTypeProperties,The length of the statement  "                type == eChartType.ColumnStacked100 ||*/type == eChartType.Column3D || type == eChartType.ColumnClustered3D || type == eChartType.ColumnStacked3D || type == eChartType.ColumnStacked1003D || /*type == eChartType.BarClustered ||" is 226.
Long Statement,OfficeOpenXml.Drawing.Chart,ExcelBarChart,C:\repos\bambit_EPPlus\EPPlus\Drawing\Chart\ExcelBarChart.cs,SetTypeProperties,The length of the statement  "                type == eChartType.BarStacked100 ||*/type == eChartType.BarClustered3D || type == eChartType.BarStacked3D || type == eChartType.BarStacked1003D) { " is 146.
Long Statement,OfficeOpenXml.Drawing.Chart,ExcelBarChart,C:\repos\bambit_EPPlus\EPPlus\Drawing\Chart\ExcelBarChart.cs,SetTypeProperties,The length of the statement  "	else if (type == eChartType.CylinderBarClustered || type == eChartType.CylinderBarStacked || type == eChartType.CylinderBarStacked100 || type == eChartType.CylinderCol || type == eChartType.CylinderColClustered || type == eChartType.CylinderColStacked || type == eChartType.CylinderColStacked100) { " is 298.
Long Statement,OfficeOpenXml.Drawing.Chart,ExcelBarChart,C:\repos\bambit_EPPlus\EPPlus\Drawing\Chart\ExcelBarChart.cs,SetTypeProperties,The length of the statement  "	else if (type == eChartType.ConeBarClustered || type == eChartType.ConeBarStacked || type == eChartType.ConeBarStacked100 || type == eChartType.ConeCol || type == eChartType.ConeColClustered || type == eChartType.ConeColStacked || type == eChartType.ConeColStacked100) { " is 270.
Long Statement,OfficeOpenXml.Drawing.Chart,ExcelBarChart,C:\repos\bambit_EPPlus\EPPlus\Drawing\Chart\ExcelBarChart.cs,SetTypeProperties,The length of the statement  "	else if (type == eChartType.PyramidBarClustered || type == eChartType.PyramidBarStacked || type == eChartType.PyramidBarStacked100 || type == eChartType.PyramidCol || type == eChartType.PyramidColClustered || type == eChartType.PyramidColStacked || type == eChartType.PyramidColStacked100) { " is 291.
Long Statement,OfficeOpenXml.Drawing.Chart,ExcelChartSeries,C:\repos\bambit_EPPlus\EPPlus\Drawing\Chart\ExcelChartSeries.cs,AddSeries,The length of the statement  "	ser.InnerXml = string.Format ("<c:idx val=\"{1}\" /><c:order val=\"{1}\" /><c:tx><c:strRef><c:f></c:f><c:strCache><c:ptCount val=\"1\" /></c:strCache></c:strRef></c:tx>{5}{0}{2}{3}{4}"' AddExplosion (Chart.ChartType)' idx' AddScatterPoint (Chart.ChartType)' AddAxisNodes (Chart.ChartType)' AddSmooth (Chart.ChartType)' AddMarker (Chart.ChartType)); " is 348.
Long Statement,OfficeOpenXml.Drawing.Chart,ExcelChartSeries,C:\repos\bambit_EPPlus\EPPlus\Drawing\Chart\ExcelChartSeries.cs,AddSeries,The length of the statement  "		if (Chart.ChartType == eChartType.LineMarkers || Chart.ChartType == eChartType.LineMarkersStacked || Chart.ChartType == eChartType.LineMarkersStacked100) { " is 155.
Long Statement,OfficeOpenXml.Drawing.Chart,ExcelChartSeries,C:\repos\bambit_EPPlus\EPPlus\Drawing\Chart\ExcelChartSeries.cs,AddPivotSerie,The length of the statement  "	AddSeries (r.Offset (0' 1' r._toRow - r._fromRow + 1' 1).FullAddressAbsolute' r.Offset (0' 0' r._toRow - r._fromRow + 1' 1).FullAddressAbsolute); " is 145.
Long Statement,OfficeOpenXml.Drawing.Chart,ExcelChartSeries,C:\repos\bambit_EPPlus\EPPlus\Drawing\Chart\ExcelChartSeries.cs,AddMarker,The length of the statement  "	if (chartType == eChartType.Line || chartType == eChartType.LineStacked || chartType == eChartType.LineStacked100 || chartType == eChartType.XYScatterLines || chartType == eChartType.XYScatterSmooth || chartType == eChartType.XYScatterLinesNoMarkers || chartType == eChartType.XYScatterSmoothNoMarkers) { " is 304.
Long Statement,OfficeOpenXml.Drawing.Chart,ExcelChartSeries,C:\repos\bambit_EPPlus\EPPlus\Drawing\Chart\ExcelChartSeries.cs,AddAxisNodes,The length of the statement  "	if (chartType == eChartType.XYScatter || chartType == eChartType.XYScatterLines || chartType == eChartType.XYScatterLinesNoMarkers || chartType == eChartType.XYScatterSmooth || chartType == eChartType.XYScatterSmoothNoMarkers) { " is 228.
Long Statement,OfficeOpenXml.Drawing.Chart,ExcelChartSeries,C:\repos\bambit_EPPlus\EPPlus\Drawing\Chart\ExcelChartSeries.cs,AddExplosion,The length of the statement  "	if (chartType == eChartType.PieExploded3D || chartType == eChartType.PieExploded || chartType == eChartType.DoughnutExploded) { " is 127.
Long Statement,OfficeOpenXml.Drawing.Chart,ExcelScatterChart,C:\repos\bambit_EPPlus\EPPlus\Drawing\Chart\ExcelScatterChart.cs,SetTypeProperties,The length of the statement  "	/***** ScatterStyle *****/if (ChartType == eChartType.XYScatter || ChartType == eChartType.XYScatterLines || ChartType == eChartType.XYScatterLinesNoMarkers) { " is 159.
Long Statement,OfficeOpenXml.Drawing,ExcelDrawing,C:\repos\bambit_EPPlus\EPPlus\Drawing\ExcelDrawingBase.cs,SetPixelWidth,The length of the statement  "	int pixOff = (int)pixels - ((int)decimal.Truncate (((256 * GetColumnWidth (From.Column + 1) + decimal.Truncate (128 / (decimal)mdw)) / 256) * mdw) - From.ColumnOff / EMU_PER_PIXEL); " is 181.
Long Statement,OfficeOpenXml.Drawing,ExcelPicture,C:\repos\bambit_EPPlus\EPPlus\Drawing\ExcelPicture.cs,SavePicture,The length of the statement  "	RelPic = _drawings.Part.CreateRelationship (PackUriHelper.GetRelativeUri (_drawings.UriDrawing' UriPic)' TargetMode.Internal' ExcelPackage.schemaRelationships + "/image"); " is 171.
Long Statement,OfficeOpenXml.Drawing,ExcelPicture,C:\repos\bambit_EPPlus\EPPlus\Drawing\ExcelPicture.cs,PicStartXml,The length of the statement  "				xml.AppendFormat ("<a:hlinkClick xmlns:r=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships\" r:id=\"{0}\" tooltip=\"{1}\"/>"' HypRel.Id' ((ExcelHyperLink)_hyperlink).ToolTip); " is 195.
Long Statement,OfficeOpenXml.Drawing,ExcelPicture,C:\repos\bambit_EPPlus\EPPlus\Drawing\ExcelPicture.cs,PicStartXml,The length of the statement  "				xml.AppendFormat ("<a:hlinkClick xmlns:r=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships\" r:id=\"{0}\" />"' HypRel.Id); " is 142.
Long Statement,OfficeOpenXml.Drawing,ExcelPicture,C:\repos\bambit_EPPlus\EPPlus\Drawing\ExcelPicture.cs,PicStartXml,The length of the statement  "	xml.Append ("<xdr:cNvPicPr><a:picLocks noChangeAspect=\"1\" /></xdr:cNvPicPr></xdr:nvPicPr><xdr:blipFill><a:blip xmlns:r=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships\" r:embed=\"\" cstate=\"print\" /><a:stretch><a:fillRect /> </a:stretch> </xdr:blipFill> <xdr:spPr> <a:xfrm> <a:off x=\"0\" y=\"0\" />  <a:ext cx=\"0\" cy=\"0\" /> </a:xfrm> <a:prstGeom prst=\"rect\"> <a:avLst /> </a:prstGeom> </xdr:spPr>"); " is 432.
Long Statement,OfficeOpenXml.Drawing,ExcelDrawings,C:\repos\bambit_EPPlus\EPPlus\Drawing\ExcelDrawings.cs,AddChart,The length of the statement  "	if (ChartType == eChartType.Bubble || ChartType == eChartType.Bubble3DEffect || ChartType == eChartType.Radar || ChartType == eChartType.RadarFilled || ChartType == eChartType.RadarMarkers || ChartType == eChartType.StockHLC || ChartType == eChartType.StockOHLC || ChartType == eChartType.StockVOHLC || ChartType == eChartType.Surface || ChartType == eChartType.SurfaceTopView || ChartType == eChartType.SurfaceTopViewWireframe || ChartType == eChartType.SurfaceWireframe) { " is 474.
Long Statement,OfficeOpenXml.Drawing,ExcelDrawings,C:\repos\bambit_EPPlus\EPPlus\Drawing\ExcelDrawings.cs,CreateDrawingXml,The length of the statement  "		DrawingXml.LoadXml (string.Format ("<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?><xdr:wsDr xmlns:xdr=\"{0}\" xmlns:a=\"{1}\" />"' ExcelPackage.schemaSheetDrawings' ExcelPackage.schemaDrawings)); " is 210.
Long Statement,OfficeOpenXml.Drawing,ExcelDrawings,C:\repos\bambit_EPPlus\EPPlus\Drawing\ExcelDrawings.cs,CreateDrawingXml,The length of the statement  "		_part = package.CreatePart (_uriDrawing' "application/vnd.openxmlformats-officedocument.drawing+xml"' _package.Compression); " is 124.
Long Statement,OfficeOpenXml.Drawing,ExcelDrawings,C:\repos\bambit_EPPlus\EPPlus\Drawing\ExcelDrawings.cs,CreateDrawingXml,The length of the statement  "		_drawingRelation = Worksheet.Part.CreateRelationship (PackUriHelper.GetRelativeUri (Worksheet.WorksheetUri' _uriDrawing)' TargetMode.Internal' ExcelPackage.schemaRelationships + "/drawing"); " is 190.
Long Statement,OfficeOpenXml.Drawing,ExcelShape,C:\repos\bambit_EPPlus\EPPlus\Drawing\ExcelShape.cs,ShapeStartXml,The length of the statement  "	xml.AppendFormat ("<xdr:nvSpPr><xdr:cNvPr id=\"{0}\" name=\"{1}\" /><xdr:cNvSpPr /></xdr:nvSpPr><xdr:spPr><a:prstGeom prst=\"rect\"><a:avLst /></a:prstGeom></xdr:spPr><xdr:style><a:lnRef idx=\"2\"><a:schemeClr val=\"accent1\"><a:shade val=\"50000\" /></a:schemeClr></a:lnRef><a:fillRef idx=\"1\"><a:schemeClr val=\"accent1\" /></a:fillRef><a:effectRef idx=\"0\"><a:schemeClr val=\"accent1\" /></a:effectRef><a:fontRef idx=\"minor\"><a:schemeClr val=\"lt1\" /></a:fontRef></xdr:style><xdr:txBody><a:bodyPr vertOverflow=\"clip\" rtlCol=\"0\" anchor=\"ctr\" /><a:lstStyle /><a:p></a:p></xdr:txBody>"' _id' Name); " is 609.
Long Statement,OfficeOpenXml.Drawing.Vml,ExcelVmlDrawingPictureCollection,C:\repos\bambit_EPPlus\EPPlus\Drawing\Vml\ExcelVmlDrawingPictureCollection.cs,CreateVmlDrawings,The length of the statement  "	string vml = string.Format ("<xml xmlns:v=\"{0}\" xmlns:o=\"{1}\" xmlns:x=\"{2}\">"' ExcelPackage.schemaMicrosoftVml' ExcelPackage.schemaMicrosoftOffice' ExcelPackage.schemaMicrosoftExcel); " is 189.
Long Statement,OfficeOpenXml.Drawing.Vml,ExcelVmlDrawingPictureCollection,C:\repos\bambit_EPPlus\EPPlus\Drawing\Vml\ExcelVmlDrawingPictureCollection.cs,AddImage,The length of the statement  "	node.SetAttribute ("style"' string.Format ("position:absolute;margin-left:0;margin-top:0;width:{0}pt;height:{1}pt;z-index:1"' width.ToString (CultureInfo.InvariantCulture)' height.ToString (CultureInfo.InvariantCulture))); " is 222.
Long Statement,OfficeOpenXml.Drawing.Vml,ExcelVmlDrawingPictureCollection,C:\repos\bambit_EPPlus\EPPlus\Drawing\Vml\ExcelVmlDrawingPictureCollection.cs,AddImage,The length of the statement  "	node.InnerXml = string.Format ("<v:imagedata o:relid=\"\" o:title=\"{0}\"/><o:lock v:ext=\"edit\" rotation=\"t\"/>"' Name); " is 123.
Long Statement,OfficeOpenXml.Drawing.Vml,ExcelVmlDrawingCommentCollection,C:\repos\bambit_EPPlus\EPPlus\Drawing\Vml\ExcelVmlDrawingCommentCollection.cs,CreateVmlDrawings,The length of the statement  "	string vml = string.Format ("<xml xmlns:v=\"{0}\" xmlns:o=\"{1}\" xmlns:x=\"{2}\">"' ExcelPackage.schemaMicrosoftVml' ExcelPackage.schemaMicrosoftOffice' ExcelPackage.schemaMicrosoftExcel); " is 189.
Long Statement,OfficeOpenXml.Drawing.Vml,ExcelVmlDrawingCommentCollection,C:\repos\bambit_EPPlus\EPPlus\Drawing\Vml\ExcelVmlDrawingCommentCollection.cs,AddDrawing,The length of the statement  "	//node.SetAttribute("style"' "position:absolute; margin-left:59.25pt;margin-top:1.5pt;width:108pt;height:59.25pt;z-index:1; visibility:hidden");  " is 144.
Long Statement,OfficeOpenXml,ExcelBackgroundImage,C:\repos\bambit_EPPlus\EPPlus\ExcelBackgroundImage.cs,SetFromFile,The length of the statement  "	var imageURI = XmlHelper.GetNewUri (_workSheet._package.Package' "/xl/media/" + PictureFile.Name.Substring (0' PictureFile.Name.Length - PictureFile.Extension.Length) + "{0}" + PictureFile.Extension); " is 200.
Long Statement,OfficeOpenXml,ExcelBackgroundImage,C:\repos\bambit_EPPlus\EPPlus\ExcelBackgroundImage.cs,SetFromFile,The length of the statement  "	if (_workSheet.Part.Package.PartExists (imageURI) && ii.RefCount == 1)//The file exists with another content' overwrite it. " is 123.
Long Statement,OfficeOpenXml,ExcelBackgroundImage,C:\repos\bambit_EPPlus\EPPlus\ExcelBackgroundImage.cs,SetFromFile,The length of the statement  "	var rel = _workSheet.Part.CreateRelationship (imageURI' TargetMode.Internal' ExcelPackage.schemaRelationships + "/image"); " is 122.
Long Statement,OfficeOpenXml,ExcelProtectedRangeCollection,C:\repos\bambit_EPPlus\EPPlus\ExcelProtectedRangeCollection.cs,Remove,The length of the statement  "	DeleteAllNode ("d:protectedRanges/d:protectedRange[@name='" + item.Name + "' and @sqref='" + item.Address.Address + "']"); " is 122.
Long Statement,OfficeOpenXml,ExcelHeaderFooterText,C:\repos\bambit_EPPlus\EPPlus\ExcelHeaderFooter.cs,InsertPicture,The length of the statement  "	var uriPic = XmlHelper.GetNewUri (_ws._package.Package' "/xl/media/" + PictureFile.Name.Substring (0' PictureFile.Name.Length - PictureFile.Extension.Length) + "{0}" + PictureFile.Extension); " is 191.
Long Statement,OfficeOpenXml,ExcelHeaderFooter,C:\repos\bambit_EPPlus\EPPlus\ExcelHeaderFooter.cs,SaveHeaderFooterImages,The length of the statement  "				_vmlDrawingsHF.Part = _ws._package.Package.CreatePart (_vmlDrawingsHF.Uri' "application/vnd.openxmlformats-officedocument.vmlDrawing"' _ws._package.Compression); " is 161.
Long Statement,OfficeOpenXml,ExcelHeaderFooter,C:\repos\bambit_EPPlus\EPPlus\ExcelHeaderFooter.cs,SaveHeaderFooterImages,The length of the statement  "				var rel = _ws.Part.CreateRelationship (PackUriHelper.GetRelativeUri (_ws.WorksheetUri' _vmlDrawingsHF.Uri)' TargetMode.Internal' ExcelPackage.schemaRelationships + "/vmlDrawing"); " is 179.
Long Statement,OfficeOpenXml,ExcelHeaderFooter,C:\repos\bambit_EPPlus\EPPlus\ExcelHeaderFooter.cs,SaveHeaderFooterImages,The length of the statement  "					rel = _vmlDrawingsHF.Part.CreateRelationship (PackUriHelper.GetRelativeUri (_vmlDrawingsHF.Uri' draw.ImageUri)' TargetMode.Internal' ExcelPackage.schemaRelationships + "/image"); " is 178.
Long Statement,OfficeOpenXml,ExcelPackage,C:\repos\bambit_EPPlus\EPPlus\ExcelPackage.cs,CreateFromTemplate,The length of the statement  "				throw new Exception ("Can not open the package. Package is an OLE compound document. If this is an encrypted package' please supply the password"' ex); " is 151.
Long Statement,OfficeOpenXml,ExcelPackage,C:\repos\bambit_EPPlus\EPPlus\ExcelPackage.cs,ConstructNewFile,The length of the statement  "				throw new Exception ("Can not open the package. Package is an OLE compound document. If this is an encrypted package' please supply the password"' ex); " is 151.
Long Statement,OfficeOpenXml,ExcelPackage,C:\repos\bambit_EPPlus\EPPlus\ExcelPackage.cs,CreateBlankWb,The length of the statement  "	_package.CreateRelationship (PackUriHelper.GetRelativeUri (new Uri ("/xl"' UriKind.Relative)' Workbook.WorkbookUri)' TargetMode.Internal' schemaRelationships + "/officeDocument"); " is 179.
Long Statement,OfficeOpenXml,ExcelPackage,C:\repos\bambit_EPPlus\EPPlus\ExcelPackage.cs,Load,The length of the statement  "			throw new Exception ("Can not open the package. Package is an OLE compound document. If this is an encrypted package' please supply the password"' ex); " is 151.
Long Statement,OfficeOpenXml,ExcelStyles,C:\repos\bambit_EPPlus\EPPlus\ExcelStyles.cs,NamedStylePropertyChange,The length of the statement  "		int newId = CellStyleXfs [NamedStyles [index].StyleXfId].GetNewID (CellStyleXfs' sender' e.StyleClass' e.StyleProperty' e.Value); " is 129.
Long Statement,OfficeOpenXml,ExcelProtection,C:\repos\bambit_EPPlus\EPPlus\ExcelProtection.cs,SetPassword,The length of the statement  "		SetXmlNodeString (workbookPasswordPath' ((int)EncryptedPackageHandler.CalculatePasswordHash (Password)).ToString ("x")); " is 120.
Long Statement,OfficeOpenXml,OfficeProperties,C:\repos\bambit_EPPlus\EPPlus\OfficeProperties.cs,GetXmlDocument,The length of the statement  "		_package.Package.CreateRelationship (PackUriHelper.GetRelativeUri (new Uri ("/xl"' UriKind.Relative)' uri)' TargetMode.Internal' relationship); " is 143.
Long Statement,OfficeOpenXml,OfficeProperties,C:\repos\bambit_EPPlus\EPPlus\OfficeProperties.cs,SetCustomPropertyValue,The length of the statement  "		var MaxNode = CustomPropertiesXml.SelectSingleNode ("ctp:Properties/ctp:property[not(@pid <= preceding-sibling::ctp:property/@pid) and not(@pid <= following-sibling::ctp:property/@pid)]"' NameSpaceManager); " is 206.
Long Statement,OfficeOpenXml,ExcelWorkbook,C:\repos\bambit_EPPlus\EPPlus\ExcelWorkbook.cs,GetDefinedNames,The length of the statement  "							fullAddress = fullAddress.Substring (0' start) + "[" + _externalReferences [index - 1] + "]" + fullAddress.Substring (end + 1); " is 127.
Long Statement,OfficeOpenXml,ExcelWorkbook,C:\repos\bambit_EPPlus\EPPlus\ExcelWorkbook.cs,GetDefinedNames,The length of the statement  "			if (addressType == ExcelAddressBase.AddressType.Invalid || addressType == ExcelAddressBase.AddressType.InternalName || addressType == ExcelAddressBase.AddressType.ExternalName)//A value or a formula " is 198.
Long Statement,OfficeOpenXml,ExcelWorkbook,C:\repos\bambit_EPPlus\EPPlus\ExcelWorkbook.cs,GetDefinedNames,The length of the statement  "						namedRange = Worksheets [localSheetID + 1].Names.Add (elem.GetAttribute ("name")' new ExcelRangeBase (this' Worksheets [localSheetID + 1]' fullAddress' false)); " is 160.
Long Statement,OfficeOpenXml,ExcelWorkbook,C:\repos\bambit_EPPlus\EPPlus\ExcelWorkbook.cs,GetDefinedNames,The length of the statement  "						namedRange = Worksheets [localSheetID + 1].Names.Add (elem.GetAttribute ("name")' new ExcelRangeBase (this' Worksheets [addr._ws]' fullAddress' false)); " is 152.
Long Statement,OfficeOpenXml,ExcelWorkbook,C:\repos\bambit_EPPlus\EPPlus\ExcelWorkbook.cs,CreateWorkbookXml,The length of the statement  "		PackagePart partWorkbook = _package.Package.CreatePart (WorkbookUri' @"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml"' _package.Compression); " is 170.
Long Statement,OfficeOpenXml,ExcelWorkbook,C:\repos\bambit_EPPlus\EPPlus\ExcelWorkbook.cs,ChangeContentTypeWorkbook,The length of the statement  "			var sheetNode = (XmlElement)WorkbookXml.SelectSingleNode (string.Format ("d:workbook/d:sheets/d:sheet[@r:id='{0}']"' rel.Id)' NameSpaceManager); " is 144.
Long Statement,OfficeOpenXml,ExcelWorkbook,C:\repos\bambit_EPPlus\EPPlus\ExcelWorkbook.cs,ChangeContentTypeWorkbook,The length of the statement  "			var sheetNode = (XmlElement)WorkbookXml.SelectSingleNode (string.Format ("d:workbook/d:pivotCaches/d:pivotCache[@r:id='{0}']"' rel.Id)' NameSpaceManager); " is 154.
Long Statement,OfficeOpenXml,ExcelWorkbook,C:\repos\bambit_EPPlus\EPPlus\ExcelWorkbook.cs,UpdateSharedStringsXml,The length of the statement  "		stringPart = _package.Package.CreatePart (SharedStringsUri' @"application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml"' _package.Compression); " is 164.
Long Statement,OfficeOpenXml,ExcelWorkbook,C:\repos\bambit_EPPlus\EPPlus\ExcelWorkbook.cs,UpdateSharedStringsXml,The length of the statement  "		Part.CreateRelationship (PackUriHelper.GetRelativeUri (WorkbookUri' SharedStringsUri)' TargetMode.Internal' ExcelPackage.schemaRelationships + "/sharedStrings"); " is 161.
Long Statement,OfficeOpenXml,ExcelWorkbook,C:\repos\bambit_EPPlus\EPPlus\ExcelWorkbook.cs,UpdateSharedStringsXml,The length of the statement  "	sw.Write ("<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\" ?><sst xmlns=\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\" count=\"{0}\" uniqueCount=\"{0}\">"' _sharedStrings.Count); " is 205.
Long Statement,OfficeOpenXml,ExcelWorkbook,C:\repos\bambit_EPPlus\EPPlus\ExcelWorkbook.cs,SetNameElement,The length of the statement  "				elem.InnerText = Convert.ToDouble (name.NameValue' CultureInfo.InvariantCulture).ToString ("g15"' CultureInfo.InvariantCulture); " is 128.
Long Statement,OfficeOpenXml,ExcelWorkbook,C:\repos\bambit_EPPlus\EPPlus\ExcelWorkbook.cs,AddPivotTable,The length of the statement  "	var rel = Part.CreateRelationship (PackUriHelper.ResolvePartUri (WorkbookUri' defUri)' TargetMode.Internal' ExcelPackage.schemaRelationships + "/pivotCacheDefinition"); " is 168.
Long Statement,OfficeOpenXml,ExcelWorksheet,C:\repos\bambit_EPPlus\EPPlus\ExcelWorksheet.cs,LoadColumns,The length of the statement  "				col.Width = xr.GetAttribute ("width") == null ? 0 : double.Parse (xr.GetAttribute ("width")' CultureInfo.InvariantCulture); " is 123.
Long Statement,OfficeOpenXml,ExcelWorksheet,C:\repos\bambit_EPPlus\EPPlus\ExcelWorksheet.cs,LoadColumns,The length of the statement  "				col.OutlineLevel = xr.GetAttribute ("outlineLevel") == null ? 0 : int.Parse (xr.GetAttribute ("outlineLevel")' CultureInfo.InvariantCulture); " is 141.
Long Statement,OfficeOpenXml,ExcelWorksheet,C:\repos\bambit_EPPlus\EPPlus\ExcelWorksheet.cs,AddRow,The length of the statement  "	r.OutlineLevel = xr.GetAttribute ("outlineLevel") == null ? 0 : int.Parse (xr.GetAttribute ("outlineLevel")' CultureInfo.InvariantCulture); " is 139.
Long Statement,OfficeOpenXml,ExcelWorksheet,C:\repos\bambit_EPPlus\EPPlus\ExcelWorksheet.cs,Select,The length of the statement  "	string selAddress = ExcelCellBase.GetAddress (Address.Start.Row' Address.Start.Column) + ":" + ExcelCellBase.GetAddress (Address.End.Row' Address.End.Column); " is 158.
Long Statement,OfficeOpenXml,ExcelWorksheet,C:\repos\bambit_EPPlus\EPPlus\ExcelWorksheet.cs,Select,The length of the statement  "			selAddress += " " + ExcelCellBase.GetAddress (a.Start.Row' a.Start.Column) + ":" + ExcelCellBase.GetAddress (a.End.Row' a.End.Column); " is 134.
Long Statement,OfficeOpenXml,ExcelWorksheet,C:\repos\bambit_EPPlus\EPPlus\ExcelWorksheet.cs,FixSharedFormulasRows,The length of the statement  "					newF.Formula = ExcelCell.TranslateFromR1C1 (ExcelCell.TranslateToR1C1 (f.Formula' f.StartRow' f.StartCol)' position' f.StartCol); " is 129.
Long Statement,OfficeOpenXml,ExcelWorksheet,C:\repos\bambit_EPPlus\EPPlus\ExcelWorksheet.cs,UpdateSharedFormulaRow,The length of the statement  "				newFormula = ExcelCellBase.UpdateFormulaReferences (ExcelCell.TranslateFromR1C1 (formualR1C1' row' col)' rows' 0' startRow' 0); " is 127.
Long Statement,OfficeOpenXml,ExcelWorksheet,C:\repos\bambit_EPPlus\EPPlus\ExcelWorksheet.cs,UpdateSharedFormulaRow,The length of the statement  "				newFormula = ExcelCellBase.UpdateFormulaReferences (ExcelCell.TranslateFromR1C1 (formualR1C1' row - rows' col)' rows' 0' startRow' 0); " is 134.
Long Statement,OfficeOpenXml,ExcelWorksheet,C:\repos\bambit_EPPlus\EPPlus\ExcelWorksheet.cs,UpdateSharedFormulaRow,The length of the statement  "						newFormulas [newFormulas.Count - 1].Address = ExcelCellBase.GetAddress (newFormulas [newFormulas.Count - 1].StartRow' newFormulas [newFormulas.Count - 1].StartCol' row - 1' col); " is 178.
Long Statement,OfficeOpenXml,ExcelWorksheet,C:\repos\bambit_EPPlus\EPPlus\ExcelWorksheet.cs,UpdateSharedFormulaRow,The length of the statement  "			//                            newFormulas[newFormulas.Count - 1].Address = ExcelCellBase.GetAddress(newFormulas[newFormulas.Count - 1].StartRow' newFormulas[0].StartCol' row - 1' col); " is 184.
Long Statement,OfficeOpenXml,ExcelWorksheet,C:\repos\bambit_EPPlus\EPPlus\ExcelWorksheet.cs,UpdateSharedFormulaRow,The length of the statement  "		newFormulas [newFormulas.Count - 1].Address = ExcelCellBase.GetAddress (newFormulas [newFormulas.Count - 1].StartRow' newFormulas [newFormulas.Count - 1].StartCol' toRow' toCol); " is 178.
Long Statement,OfficeOpenXml,ExcelWorksheet,C:\repos\bambit_EPPlus\EPPlus\ExcelWorksheet.cs,SaveComments,The length of the statement  "				_comments.Part = _package.Package.CreatePart (_comments.Uri' "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml"' _package.Compression); " is 159.
Long Statement,OfficeOpenXml,ExcelWorksheet,C:\repos\bambit_EPPlus\EPPlus\ExcelWorksheet.cs,SaveComments,The length of the statement  "				var rel = Part.CreateRelationship (PackUriHelper.GetRelativeUri (WorksheetUri' _comments.Uri)' TargetMode.Internal' ExcelPackage.schemaRelationships + "/comments"); " is 164.
Long Statement,OfficeOpenXml,ExcelWorksheet,C:\repos\bambit_EPPlus\EPPlus\ExcelWorksheet.cs,SaveComments,The length of the statement  "				_vmlDrawings.Part = _package.Package.CreatePart (_vmlDrawings.Uri' "application/vnd.openxmlformats-officedocument.vmlDrawing"' _package.Compression); " is 149.
Long Statement,OfficeOpenXml,ExcelWorksheet,C:\repos\bambit_EPPlus\EPPlus\ExcelWorksheet.cs,SaveComments,The length of the statement  "				var rel = Part.CreateRelationship (PackUriHelper.GetRelativeUri (WorksheetUri' _vmlDrawings.Uri)' TargetMode.Internal' ExcelPackage.schemaRelationships + "/vmlDrawing"); " is 169.
Long Statement,OfficeOpenXml,ExcelWorksheet,C:\repos\bambit_EPPlus\EPPlus\ExcelWorksheet.cs,SaveTables,The length of the statement  "			tbl.Part = _package.Package.CreatePart (tbl.TableUri' "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml"' Workbook._package.Compression); " is 158.
Long Statement,OfficeOpenXml,ExcelWorksheet,C:\repos\bambit_EPPlus\EPPlus\ExcelWorksheet.cs,SaveTables,The length of the statement  "			var rel = Part.CreateRelationship (PackUriHelper.GetRelativeUri (WorksheetUri' tbl.TableUri)' TargetMode.Internal' ExcelPackage.schemaRelationships + "/table"); " is 160.
Long Statement,OfficeOpenXml,ExcelWorksheet,C:\repos\bambit_EPPlus\EPPlus\ExcelWorksheet.cs,UpdateColBreaks,The length of the statement  "		sw.Write (string.Format ("<colBreaks count=\"{0}\" manualBreakCount=\"{0}\">{1}</colBreaks>"' count' breaks.ToString ())); " is 122.
Long Statement,OfficeOpenXml,ExcelWorksheet,C:\repos\bambit_EPPlus\EPPlus\ExcelWorksheet.cs,UpdateRowBreaks,The length of the statement  "		sw.Write (string.Format ("<rowBreaks count=\"{0}\" manualBreakCount=\"{0}\">{1}</rowBreaks>"' count' breaks.ToString ())); " is 122.
Long Statement,OfficeOpenXml,ExcelWorksheet,C:\repos\bambit_EPPlus\EPPlus\ExcelWorksheet.cs,UpdateRowCellData,The length of the statement  "							sw.Write ("<c r=\"{0}\" s=\"{1}\"><f ref=\"{2}\" t=\"array\">{3}</f></c>"' cell.CellAddress' styleID < 0 ? 0 : styleID' f.Address' SecurityElement.Escape (f.Formula)); " is 167.
Long Statement,OfficeOpenXml,ExcelWorksheet,C:\repos\bambit_EPPlus\EPPlus\ExcelWorksheet.cs,UpdateRowCellData,The length of the statement  "							sw.Write ("<c r=\"{0}\" s=\"{1}\"><f ref=\"{2}\" t=\"shared\"  si=\"{3}\">{4}</f></c>"' cell.CellAddress' styleID < 0 ? 0 : styleID' f.Address' cell.SharedFormulaID' SecurityElement.Escape (f.Formula)); " is 202.
Long Statement,OfficeOpenXml,ExcelWorksheet,C:\repos\bambit_EPPlus\EPPlus\ExcelWorksheet.cs,UpdateRowCellData,The length of the statement  "						sw.Write ("<c r=\"{0}\" s=\"{1}\"><f t=\"shared\" si=\"{2}\" /></c>"' cell.CellAddress' styleID < 0 ? 0 : styleID' cell.SharedFormulaID); " is 137.
Long Statement,OfficeOpenXml,ExcelWorksheet,C:\repos\bambit_EPPlus\EPPlus\ExcelWorksheet.cs,UpdateRowCellData,The length of the statement  "						sw.Write ("<c r=\"{0}\" s=\"{1}\"><f ref=\"{2}\" t=\"array\">{3}</f></c>"' cell.CellAddress' styleID < 0 ? 0 : styleID' string.Format ("{0}:{1}"' f.Address' f.Address)' SecurityElement.Escape (f.Formula)); " is 205.
Long Statement,OfficeOpenXml,ExcelWorksheet,C:\repos\bambit_EPPlus\EPPlus\ExcelWorksheet.cs,UpdateRowCellData,The length of the statement  "					if ((cell._value.GetType ().IsPrimitive || cell._value is double || cell._value is decimal || cell._value is DateTime || cell._value is TimeSpan) && cell.DataType != "s") { " is 172.
Long Statement,OfficeOpenXml,ExcelWorksheet,C:\repos\bambit_EPPlus\EPPlus\ExcelWorksheet.cs,UpdateHyperLinks,The length of the statement  "			sw.Write ("<hyperlink ref=\"{0}\" location=\"{1}\" {2}{3}/>"' Cells [cell.Row' cell.Column' cell.Row + hl.RowSpann' cell.Column + hl.ColSpann].Address' ExcelCell.GetFullAddress (Name' hl.ReferenceAddress)' string.IsNullOrEmpty (hl.Display) ? "" : "display=\"" + SecurityElement.Escape (hl.Display) + "\" "' string.IsNullOrEmpty (hl.ToolTip) ? "" : "tooltip=\"" + SecurityElement.Escape (hl.ToolTip) + "\" "); " is 408.
Long Statement,OfficeOpenXml,ExcelWorksheet,C:\repos\bambit_EPPlus\EPPlus\ExcelWorksheet.cs,UpdateHyperLinks,The length of the statement  "					sw.Write ("<hyperlink ref=\"{0}\" {2}{3}r:id=\"{1}\" />"' cell.CellAddress' relationship.Id' string.IsNullOrEmpty (hl.Display) ? "" : "display=\"" + SecurityElement.Escape (hl.Display) + "\" "' string.IsNullOrEmpty (hl.ToolTip) ? "" : "tooltip=\"" + SecurityElement.Escape (hl.ToolTip) + "\" "); " is 295.
Long Statement,OfficeOpenXml,ExcelWorksheet,C:\repos\bambit_EPPlus\EPPlus\ExcelWorksheet.cs,RemoveLegacyDrawingRel,The length of the statement  "	var n = WorksheetXml.DocumentElement.SelectSingleNode (string.Format ("d:legacyDrawing[@r:id=\"{0}\"]"' relID)' NameSpaceManager); " is 130.
Long Statement,OfficeOpenXml,ExcelWorksheets,C:\repos\bambit_EPPlus\EPPlus\ExcelWorksheets.cs,Add,The length of the statement  "	ExcelWorksheet worksheet = new ExcelWorksheet (_namespaceManager' _pck' rel' uriWorksheet' Name' sheetID' positionID' eWorkSheetHidden.Visible); " is 144.
Long Statement,OfficeOpenXml,ExcelWorksheets,C:\repos\bambit_EPPlus\EPPlus\ExcelWorksheets.cs,Add,The length of the statement  "	ExcelWorksheet added = new ExcelWorksheet (_namespaceManager' _pck' relID' uriWorksheet' Name' sheetID' _worksheets.Count + 1' eWorkSheetHidden.Visible); " is 153.
Long Statement,OfficeOpenXml,ExcelWorksheets,C:\repos\bambit_EPPlus\EPPlus\ExcelWorksheets.cs,CopyTable,The length of the statement  "		var part = _pck.Package.CreatePart (uriTbl' "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml"' _pck.Compression); " is 135.
Long Statement,OfficeOpenXml,ExcelWorksheets,C:\repos\bambit_EPPlus\EPPlus\ExcelWorksheets.cs,CopyTable,The length of the statement  "		var rel = added.Part.CreateRelationship (PackUriHelper.GetRelativeUri (added.WorksheetUri' uriTbl)' TargetMode.Internal' ExcelPackage.schemaRelationships + "/table"); " is 166.
Long Statement,OfficeOpenXml,ExcelWorksheets,C:\repos\bambit_EPPlus\EPPlus\ExcelWorksheets.cs,CopyTable,The length of the statement  "			relAtt = added.WorksheetXml.SelectSingleNode (string.Format ("//d:tableParts/d:tablePart/@r:id[.='{0}']"' tbl.RelationshipID)' tbl.NameSpaceManager) as XmlAttribute; " is 165.
Long Statement,OfficeOpenXml,ExcelWorksheets,C:\repos\bambit_EPPlus\EPPlus\ExcelWorksheets.cs,CopyPivotTable,The length of the statement  "		added.Part.CreateRelationship (PackUriHelper.ResolvePartUri (added.WorksheetUri' uriTbl)' TargetMode.Internal' ExcelPackage.schemaRelationships + "/pivotTable"); " is 161.
Long Statement,OfficeOpenXml,ExcelWorksheets,C:\repos\bambit_EPPlus\EPPlus\ExcelWorksheets.cs,CopyPivotTable,The length of the statement  "		part.CreateRelationship (PackUriHelper.ResolvePartUri (tbl.Relationship.SourceUri' tbl.CacheDefinition.Relationship.TargetUri)' tbl.CacheDefinition.Relationship.TargetMode' tbl.CacheDefinition.Relationship.RelationshipType); " is 224.
Long Statement,OfficeOpenXml,ExcelWorksheets,C:\repos\bambit_EPPlus\EPPlus\ExcelWorksheets.cs,CopyHeaderFooterPictures,The length of the statement  "		var part = _pck.Package.CreatePart (dest' "application/vnd.openxmlformats-officedocument.vmlDrawing"' _pck.Compression); " is 120.
Long Statement,OfficeOpenXml,ExcelWorksheets,C:\repos\bambit_EPPlus\EPPlus\ExcelWorksheets.cs,CopyComment,The length of the statement  "	var part = _pck.Package.CreatePart (uriComment' "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml"' _pck.Compression); " is 142.
Long Statement,OfficeOpenXml,ExcelWorksheets,C:\repos\bambit_EPPlus\EPPlus\ExcelWorksheets.cs,CopyComment,The length of the statement  "	PackageRelationship commentRelation = workSheet.Part.CreateRelationship (PackUriHelper.GetRelativeUri (workSheet.WorksheetUri' uriComment)' TargetMode.Internal' ExcelPackage.schemaRelationships + "/comments"); " is 209.
Long Statement,OfficeOpenXml,ExcelWorksheets,C:\repos\bambit_EPPlus\EPPlus\ExcelWorksheets.cs,CopyComment,The length of the statement  "	var vmlPart = _pck.Package.CreatePart (uriVml' "application/vnd.openxmlformats-officedocument.vmlDrawing"' _pck.Compression); " is 125.
Long Statement,OfficeOpenXml,ExcelWorksheets,C:\repos\bambit_EPPlus\EPPlus\ExcelWorksheets.cs,CopyComment,The length of the statement  "	PackageRelationship newVmlRel = workSheet.Part.CreateRelationship (PackUriHelper.GetRelativeUri (workSheet.WorksheetUri' uriVml)' TargetMode.Internal' ExcelPackage.schemaRelationships + "/vmlDrawing"); " is 201.
Long Statement,OfficeOpenXml,ExcelWorksheets,C:\repos\bambit_EPPlus\EPPlus\ExcelWorksheets.cs,CopyDrawing,The length of the statement  "	var part = _pck.Package.CreatePart (uriDraw' "application/vnd.openxmlformats-officedocument.drawing+xml"' _pck.Compression); " is 124.
Long Statement,OfficeOpenXml,ExcelWorksheets,C:\repos\bambit_EPPlus\EPPlus\ExcelWorksheets.cs,CopyDrawing,The length of the statement  "	PackageRelationship drawRelation = workSheet.Part.CreateRelationship (PackUriHelper.GetRelativeUri (workSheet.WorksheetUri' uriDraw)' TargetMode.Internal' ExcelPackage.schemaRelationships + "/drawing"); " is 202.
Long Statement,OfficeOpenXml,ExcelWorksheets,C:\repos\bambit_EPPlus\EPPlus\ExcelWorksheets.cs,CopyDrawing,The length of the statement  "			var chartPart = _pck.Package.CreatePart (UriChart' "application/vnd.openxmlformats-officedocument.drawingml.chart+xml"' _pck.Compression); " is 138.
Long Statement,OfficeOpenXml,ExcelWorksheets,C:\repos\bambit_EPPlus\EPPlus\ExcelWorksheets.cs,CopyDrawing,The length of the statement  "			var prevRelID = draw.TopNode.SelectSingleNode ("xdr:graphicFrame/a:graphic/a:graphicData/c:chart/@r:id"' Copy.Drawings.NameSpaceManager).Value; " is 143.
Long Statement,OfficeOpenXml,ExcelWorksheets,C:\repos\bambit_EPPlus\EPPlus\ExcelWorksheets.cs,CopyDrawing,The length of the statement  "			var rel = part.CreateRelationship (PackUriHelper.GetRelativeUri (uriDraw' UriChart)' TargetMode.Internal' ExcelPackage.schemaRelationships + "/chart"); " is 151.
Long Statement,OfficeOpenXml,ExcelWorksheets,C:\repos\bambit_EPPlus\EPPlus\ExcelWorksheets.cs,CopyDrawing,The length of the statement  "			XmlAttribute relAtt = drawXml.SelectSingleNode (string.Format ("//c:chart/@r:id[.='{0}']"' prevRelID)' Copy.Drawings.NameSpaceManager) as XmlAttribute; " is 151.
Long Statement,OfficeOpenXml,ExcelWorksheets,C:\repos\bambit_EPPlus\EPPlus\ExcelWorksheets.cs,CopyDrawing,The length of the statement  "			var prevRelID = draw.TopNode.SelectSingleNode ("xdr:pic/xdr:blipFill/a:blip/@r:embed"' Copy.Drawings.NameSpaceManager).Value; " is 125.
Long Statement,OfficeOpenXml,ExcelWorksheets,C:\repos\bambit_EPPlus\EPPlus\ExcelWorksheets.cs,CopyDrawing,The length of the statement  "			var rel = part.CreateRelationship (PackUriHelper.GetRelativeUri (workSheet.WorksheetUri' uri)' TargetMode.Internal' ExcelPackage.schemaRelationships + "/image"); " is 161.
Long Statement,OfficeOpenXml,ExcelWorksheets,C:\repos\bambit_EPPlus\EPPlus\ExcelWorksheets.cs,CopyDrawing,The length of the statement  "			XmlAttribute relAtt = drawXml.SelectSingleNode (string.Format ("//xdr:pic/xdr:blipFill/a:blip/@r:embed[.='{0}']"' prevRelID)' Copy.Drawings.NameSpaceManager) as XmlAttribute; " is 174.
Long Statement,OfficeOpenXml,ExcelWorksheets,C:\repos\bambit_EPPlus\EPPlus\ExcelWorksheets.cs,CopyVmlDrawing,The length of the statement  "	var part = _pck.Package.CreatePart (vmlUri' "application/vnd.openxmlformats-officedocument.vmlDrawing"' _pck.Compression); " is 122.
Long Statement,OfficeOpenXml,ExcelWorksheets,C:\repos\bambit_EPPlus\EPPlus\ExcelWorksheets.cs,CopyVmlDrawing,The length of the statement  "	PackageRelationship vmlRelation = newSheet.Part.CreateRelationship (PackUriHelper.GetRelativeUri (newSheet.WorksheetUri' vmlUri)' TargetMode.Internal' ExcelPackage.schemaRelationships + "/vmlDrawing"); " is 201.
Long Statement,OfficeOpenXml,ExcelWorksheets,C:\repos\bambit_EPPlus\EPPlus\ExcelWorksheets.cs,CopyVmlDrawing,The length of the statement  "		e = newSheet.WorksheetXml.CreateNode (XmlNodeType.Entity' "//d:legacyDrawing"' _namespaceManager.LookupNamespace ("d")) as XmlElement; " is 134.
Long Statement,OfficeOpenXml,ExcelWorksheets,C:\repos\bambit_EPPlus\EPPlus\ExcelWorksheets.cs,CreateWorkbookRel,The length of the statement  "	PackageRelationship rel = _pck.Workbook.Part.CreateRelationship (PackUriHelper.GetRelativeUri (_pck.Workbook.WorkbookUri' uriWorksheet)' TargetMode.Internal' ExcelPackage.schemaRelationships + "/worksheet"); " is 207.
Long Statement,OfficeOpenXml,ExcelWorksheets,C:\repos\bambit_EPPlus\EPPlus\ExcelWorksheets.cs,Delete,The length of the statement  "		XmlNode sheetNode = sheetsNode.SelectSingleNode (string.Format ("./d:sheet[@sheetId={0}]"' worksheet.SheetID)' _namespaceManager); " is 130.
Long Statement,OfficeOpenXml,ExcelWorksheets,C:\repos\bambit_EPPlus\EPPlus\ExcelWorksheets.cs,Move,The length of the statement  "		throw new Exception (string.Format ("Move worksheet error: Could not find worksheet at position '{0}'"' sourcePositionId)); " is 123.
Long Statement,OfficeOpenXml,ExcelWorksheets,C:\repos\bambit_EPPlus\EPPlus\ExcelWorksheets.cs,Move,The length of the statement  "		throw new Exception (string.Format ("Move worksheet error: Could not find worksheet at position '{0}'"' targetPositionId)); " is 123.
Long Statement,OfficeOpenXml,ExcelWorksheets,C:\repos\bambit_EPPlus\EPPlus\ExcelWorksheets.cs,MoveSheetXmlNode,The length of the statement  "	var sourceNode = TopNode.SelectSingleNode (string.Format ("d:sheet[@sheetId = '{0}']"' sourceSheet.SheetID)' _namespaceManager); " is 128.
Long Statement,OfficeOpenXml,ExcelWorksheets,C:\repos\bambit_EPPlus\EPPlus\ExcelWorksheets.cs,MoveSheetXmlNode,The length of the statement  "	var targetNode = TopNode.SelectSingleNode (string.Format ("d:sheet[@sheetId = '{0}']"' targetSheet.SheetID)' _namespaceManager); " is 128.
Long Statement,OfficeOpenXml,XmlHelper,C:\repos\bambit_EPPlus\EPPlus\XmlHelper.cs,CreateNode,The length of the statement  "					if (nodePrefix == "" || (node.OwnerDocument != null && node.OwnerDocument.DocumentElement != null && node.OwnerDocument.DocumentElement.NamespaceURI == nameSpaceURI && node.OwnerDocument.DocumentElement.Prefix == "")) { " is 219.
Long Statement,OfficeOpenXml,XmlHelper,C:\repos\bambit_EPPlus\EPPlus\XmlHelper.cs,CreateComplexNode,The length of the statement  "						if (node.OwnerDocument != null && node.OwnerDocument.DocumentElement != null && node.OwnerDocument.DocumentElement.NamespaceURI == nameSpaceURI && node.OwnerDocument.DocumentElement.Prefix == string.Empty) { " is 207.
Long Statement,OfficeOpenXml,ExcelAddressBase,C:\repos\bambit_EPPlus\EPPlus\ExcelAddress.cs,Collide,The length of the statement  "	else if (address._fromRow == _fromRow && address._fromCol == _fromCol && address._toRow == _toRow && address._toCol == _toCol) { " is 128.
Long Statement,OfficeOpenXml,ExcelAddressBase,C:\repos\bambit_EPPlus\EPPlus\ExcelAddress.cs,Collide,The length of the statement  "	else if (address._fromRow >= _fromRow && address._toRow <= _toRow && address._fromCol >= _fromCol && address._toCol <= _toCol) { " is 128.
Long Statement,OfficeOpenXml,ExcelComment,C:\repos\bambit_EPPlus\EPPlus\ExcelComment.cs,GetAuthor,The length of the statement  "	foreach (XmlElement node in _commentHelper.TopNode.OwnerDocument.SelectNodes (AUTHOR_PATH' _commentHelper.NameSpaceManager)) { " is 126.
Long Statement,OfficeOpenXml,ExcelComment,C:\repos\bambit_EPPlus\EPPlus\ExcelComment.cs,GetAuthor,The length of the statement  "		_commentHelper.TopNode.OwnerDocument.SelectSingleNode (AUTHORS_PATH' _commentHelper.NameSpaceManager).AppendChild (elem); " is 121.
Long Statement,OfficeOpenXml,ExcelCommentCollection,C:\repos\bambit_EPPlus\EPPlus\ExcelCommentCollection.cs,CreateXml,The length of the statement  "		CommentXml.LoadXml ("<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\" ?><comments xmlns=\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\"><authors /><commentList /></comments>"); " is 201.
Long Statement,OfficeOpenXml,ExcelCellBase,C:\repos\bambit_EPPlus\EPPlus\ExcelCellBase.cs,Translate,The length of the statement  "			if ((c == '-' || c == '+' || c == '*' || c == '/' || c == '=' || c == '^' || c == ''' || c == ':' || c == '<' || c == '>' || c == '(' || c == ')' || c == '!' || c == ' ' || c == '&' || c == '%') && (pos == 0 || value [pos - 1] != '['))//Last part to allow for R1C1 style [-x] " is 275.
Long Statement,OfficeOpenXml,ExcelCellBase,C:\repos\bambit_EPPlus\EPPlus\ExcelCellBase.cs,GetFullAddress,The length of the statement  "			if ((a._fromRow == 1 && a._toRow == ExcelPackage.MaxRows) || (a._fromCol == 1 && a._toCol == ExcelPackage.MaxColumns)) { " is 120.
Long Statement,OfficeOpenXml,ExcelCellBase,C:\repos\bambit_EPPlus\EPPlus\ExcelCellBase.cs,GetFullAddress,The length of the statement  "				address = string.Format ("'{0}'!{1}{2}:{3}{4}"' worksheetName' ExcelAddress.GetColumnLetter (a._fromCol)' a._fromRow' ExcelAddress.GetColumnLetter (a._toCol)' a._toRow); " is 169.
Long Statement,OfficeOpenXml,ExcelRangeBase,C:\repos\bambit_EPPlus\EPPlus\ExcelRangeBase.cs,SetValueAddress,The length of the statement  "	if (_fromRow == 1 && _fromCol == 1 && _toRow == ExcelPackage.MaxRows && _toCol == ExcelPackage.MaxColumns)//Full sheet (ex ws.Cells.Value=0). Set value for A1 only to avoid hanging  " is 180.
Long Statement,OfficeOpenXml,ExcelRangeBase,C:\repos\bambit_EPPlus\EPPlus\ExcelRangeBase.cs,Set_SharedFormula,The length of the statement  "	if (_fromRow == 1 && _fromCol == 1 && _toRow == ExcelPackage.MaxRows && _toCol == ExcelPackage.MaxColumns)//Full sheet (ex ws.Cells.Value=0). Set value for A1 only to avoid hanging  " is 180.
Long Statement,OfficeOpenXml,ExcelRangeBase,C:\repos\bambit_EPPlus\EPPlus\ExcelRangeBase.cs,Set_SharedFormula,The length of the statement  "	else if (address.Start.Row == address.End.Row && address.Start.Column == address.End.Column && !IsArray)//is it really a shared formula? Arrayformulas can be one cell only " is 171.
Long Statement,OfficeOpenXml,ExcelRangeBase,C:\repos\bambit_EPPlus\EPPlus\ExcelRangeBase.cs,Exists_Comment,The length of the statement  "		throw (new InvalidOperationException (string.Format ("Cell {0} already contain a comment."' new ExcelCellAddress (row' col).Address))); " is 135.
Long Statement,OfficeOpenXml,ExcelRangeBase,C:\repos\bambit_EPPlus\EPPlus\ExcelRangeBase.cs,IsInfinityValue,The length of the statement  "	if (valueAsDouble.HasValue && (double.IsNegativeInfinity (valueAsDouble.Value) || double.IsPositiveInfinity (valueAsDouble.Value))) { " is 133.
Long Statement,OfficeOpenXml,ExcelRangeBase,C:\repos\bambit_EPPlus\EPPlus\ExcelRangeBase.cs,AutoFitColumns,The length of the statement  "		afAddr.Add (new ExcelAddressBase (_worksheet.AutoFilterAddress._fromRow' _worksheet.AutoFilterAddress._fromCol' _worksheet.AutoFilterAddress._fromRow' _worksheet.AutoFilterAddress._toCol)); " is 189.
Long Statement,OfficeOpenXml,ExcelRangeBase,C:\repos\bambit_EPPlus\EPPlus\ExcelRangeBase.cs,AutoFitColumns,The length of the statement  "			afAddr.Add (new ExcelAddressBase (tbl.AutoFilterAddress._fromRow' tbl.AutoFilterAddress._fromCol' tbl.AutoFilterAddress._fromRow' tbl.AutoFilterAddress._toCol)); " is 161.
Long Statement,OfficeOpenXml,ExcelRangeBase,C:\repos\bambit_EPPlus\EPPlus\ExcelRangeBase.cs,AutoFitColumns,The length of the statement  "					width = (((size.Width - size.Height) * Math.Abs (System.Math.Cos (System.Math.PI * r / 180.0)) + size.Height) + 5) / normalSize; " is 128.
Long Statement,OfficeOpenXml,ExcelRangeBase,C:\repos\bambit_EPPlus\EPPlus\ExcelRangeBase.cs,GetRichText,The length of the statement  "			XmlHelper.LoadXmlSafe (xml' "<d:si xmlns:d=\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\" >" + cell.Value.ToString () + "</d:si>"' Encoding.UTF8); " is 161.
Long Statement,OfficeOpenXml,ExcelRangeBase,C:\repos\bambit_EPPlus\EPPlus\ExcelRangeBase.cs,GetRichText,The length of the statement  "			xml.LoadXml ("<d:si xmlns:d=\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\" ><d:r><d:t>" + SecurityElement.Escape (cell.Value.ToString ()) + "</d:t></d:r></d:si>"); " is 178.
Long Statement,OfficeOpenXml,ExcelRangeBase,C:\repos\bambit_EPPlus\EPPlus\ExcelRangeBase.cs,GetRichText,The length of the statement  "	var rtc = new ExcelRichTextCollection (_worksheet.NameSpaceManager' xml.SelectSingleNode ("d:si"' _worksheet.NameSpaceManager)' this); " is 134.
Long Statement,OfficeOpenXml,ExcelRangeBase,C:\repos\bambit_EPPlus\EPPlus\ExcelRangeBase.cs,SetValueRichText,The length of the statement  "	if (_fromRow == 1 && _fromCol == 1 && _toRow == ExcelPackage.MaxRows && _toCol == ExcelPackage.MaxColumns)//Full sheet (ex ws.Cells.Value=0). Set value for A1 only to avoid hanging  " is 180.
Long Statement,OfficeOpenXml,ExcelRangeBase,C:\repos\bambit_EPPlus\EPPlus\ExcelRangeBase.cs,RemoveFormuls,The length of the statement  "		if (((fFromCol >= address.Start.Column && fFromCol <= address.End.Column) || (fToCol >= address.Start.Column && fToCol <= address.End.Column)) && ((fFromRow >= address.Start.Row && fFromRow <= address.End.Row) || (fToRow >= address.Start.Row && fToRow <= address.End.Row))) { " is 275.
Long Statement,OfficeOpenXml,ExcelRangeBase,C:\repos\bambit_EPPlus\EPPlus\ExcelRangeBase.cs,SplitFormulas,The length of the statement  "				if (_worksheet._sharedFormulas [id].IsArray && Collide (_worksheet.Cells [_worksheet._sharedFormulas [id].Address]) == eAddressCollition.Partly)// If the formula is an array formula and its on inside the overwriting range throw an exception " is 240.
Long Statement,OfficeOpenXml,ExcelRangeBase,C:\repos\bambit_EPPlus\EPPlus\ExcelRangeBase.cs,LoadFromDataTable,The length of the statement  "		var tbl = _worksheet.Tables.Add (new ExcelAddressBase (_fromRow' _fromCol' _fromRow + (rows == 0 ? 1 : rows)' _fromCol + Table.Columns.Count - 1)' Table.TableName); " is 164.
Long Statement,OfficeOpenXml,ExcelRangeBase,C:\repos\bambit_EPPlus\EPPlus\ExcelRangeBase.cs,LoadFromCollection,The length of the statement  "	return LoadFromCollection<T> (Collection' PrintHeaders' TableStyles.None' BindingFlags.Public | BindingFlags.Instance' null); " is 125.
Long Statement,OfficeOpenXml,ExcelRangeBase,C:\repos\bambit_EPPlus\EPPlus\ExcelRangeBase.cs,Offset,The length of the statement  "	if (_fromRow + RowOffset < 1 || _fromCol + ColumnOffset < 1 || _fromRow + RowOffset > ExcelPackage.MaxRows || _fromCol + ColumnOffset > ExcelPackage.MaxColumns) { " is 162.
Long Statement,OfficeOpenXml,ExcelRangeBase,C:\repos\bambit_EPPlus\EPPlus\ExcelRangeBase.cs,Offset,The length of the statement  "	if (_fromRow + RowOffset < 1 || _fromCol + ColumnOffset < 1 || _fromRow + RowOffset > ExcelPackage.MaxRows || _fromCol + ColumnOffset > ExcelPackage.MaxColumns || _fromRow + RowOffset + NumberOfRows < 1 || _fromCol + ColumnOffset + NumberOfColumns < 1 || _fromRow + RowOffset + NumberOfRows > ExcelPackage.MaxRows || _fromCol + ColumnOffset + NumberOfColumns > ExcelPackage.MaxColumns) { " is 387.
Long Statement,OfficeOpenXml,ExcelRangeBase,C:\repos\bambit_EPPlus\EPPlus\ExcelRangeBase.cs,Offset,The length of the statement  "	string address = GetAddress (_fromRow + RowOffset' _fromCol + ColumnOffset' _fromRow + RowOffset + NumberOfRows' _fromCol + ColumnOffset + NumberOfColumns); " is 156.
Long Statement,OfficeOpenXml,ExcelRangeBase,C:\repos\bambit_EPPlus\EPPlus\ExcelRangeBase.cs,Copy,The length of the statement  "		var newCell = copiedCell.Clone (Destination._worksheet' Destination._fromRow + (copiedCell.Row - _fromRow)' Destination._fromCol + (copiedCell.Column - _fromCol)); " is 163.
Long Statement,OfficeOpenXml,ExcelRangeBase,C:\repos\bambit_EPPlus\EPPlus\ExcelRangeBase.cs,Copy,The length of the statement  "			newCell.Formula = ExcelCell.UpdateFormulaReferences (newCell.Formula' newCell.Row - copiedCell.Row' (newCell.Column - copiedCell.Column)' 1' 1); " is 144.
Long Statement,OfficeOpenXml,ExcelRangeBase,C:\repos\bambit_EPPlus\EPPlus\ExcelRangeBase.cs,MoveNext,The length of the statement  "				GetStartIndexEnum (Addresses [0].Start.Row' Addresses [0].Start.Column' Addresses [0].End.Row' Addresses [0].End.Column); " is 121.
Long Statement,OfficeOpenXml,ExcelRangeBase,C:\repos\bambit_EPPlus\EPPlus\ExcelRangeBase.cs,MoveNext,The length of the statement  "		GetNextIndexEnum (Addresses [_enumAddressIx].Start.Row' Addresses [_enumAddressIx].Start.Column' Addresses [_enumAddressIx].End.Row' Addresses [_enumAddressIx].End.Column); " is 172.
Long Statement,OfficeOpenXml,ExcelRangeBase,C:\repos\bambit_EPPlus\EPPlus\ExcelRangeBase.cs,MoveNext,The length of the statement  "				GetStartIndexEnum (Addresses [_enumAddressIx].Start.Row' Addresses [_enumAddressIx].Start.Column' Addresses [_enumAddressIx].End.Row' Addresses [_enumAddressIx].End.Column); " is 173.
Long Statement,OfficeOpenXml.VBA,ExcelVBACollectionBase,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaModuleCollection.cs,Exists,The length of the statement  "	return _list.Exists (f => f.GetType ().GetProperty ("Name").GetValue (f' null).ToString ().ToLower () == Name.ToLower ()); " is 122.
Long Statement,OfficeOpenXml.VBA,ExcelVbaModuleAttributesCollection,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaModuleCollection.cs,GetAttributeText,The length of the statement  "		sb.AppendFormat ("Attribute {0} = {1}\r\n"' attr.Name' attr.DataType == eAttributeDataType.String ? "\"" + attr.Value + "\"" : attr.Value); " is 139.
Long Statement,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,Save,The length of the statement  "			store.DataStreams.Add (module.Name' CompoundDocument.CompressPart (Encoding.GetEncoding (CodePage).GetBytes (module.Attributes.GetAttributeText () + module.Code))); " is 164.
Long Statement,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,WriteProtectionStat,The length of the statement  "	int stat = (_protection.UserProtected ? 1 : 0) | (_protection.HostProtected ? 2 : 0) | (_protection.VbeProtected ? 4 : 0); " is 122.
Long Statement,OfficeOpenXml.VBA,ExcelVbaSignature,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaSignature.cs,Save,The length of the statement  "		proj.Part.CreateRelationship (PackUriHelper.ResolvePartUri (proj.Uri' Uri)' TargetMode.Internal' schemaRelVbaSignature); " is 120.
Long Statement,OfficeOpenXml.VBA,ExcelVbaSignature,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaSignature.cs,GetCertFromStore,The length of the statement  "			var storeCert = store.Certificates.Find (X509FindType.FindByThumbprint' Certificate.Thumbprint' true).OfType<X509Certificate2> ().FirstOrDefault (); " is 148.
Long Statement,OfficeOpenXml.VBA,ExcelVbaSignature,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaSignature.cs,GetContentHash,The length of the statement  "			foreach (byte b in BitConverter.GetBytes ((uint)reference.Libid.Length))//Length will never be an UInt with 4 bytes that aren't 0 (> 0x00FFFFFF)' so no need for the rest of the properties. " is 188.
Long Statement,OfficeOpenXml.Utils,EncryptedPackageHandler,C:\repos\bambit_EPPlus\EPPlus\Utils\EncryptedPackageHandler.cs,DecryptPackage,The length of the statement  "		if (StgOpenStorage (fi.FullName' null' STGM.DIRECT | STGM.READ | STGM.SHARE_EXCLUSIVE' IntPtr.Zero' 0' out storage) == 0) { " is 123.
Long Statement,OfficeOpenXml.Utils,EncryptedPackageHandler,C:\repos\bambit_EPPlus\EPPlus\Utils\EncryptedPackageHandler.cs,DecryptPackage,The length of the statement  "		if (StgOpenStorageOnILockBytes (lb' null' STGM.DIRECT | STGM.READ | STGM.SHARE_EXCLUSIVE' IntPtr.Zero' 0' out storage) == 0) { " is 126.
Long Statement,OfficeOpenXml.Utils,EncryptedPackageHandler,C:\repos\bambit_EPPlus\EPPlus\Utils\EncryptedPackageHandler.cs,EncryptPackage,The length of the statement  "	var encryptionInfo = CreateEncryptionInfo (encryption.Password' encryption.Algorithm == EncryptionAlgorithm.AES128 ? AlgorithmID.AES128 : encryption.Algorithm == EncryptionAlgorithm.AES192 ? AlgorithmID.AES192 : AlgorithmID.AES256' out encryptionKey); " is 251.
Long Statement,OfficeOpenXml.Utils,EncryptedPackageHandler,C:\repos\bambit_EPPlus\EPPlus\Utils\EncryptedPackageHandler.cs,EncryptPackage,The length of the statement  "	if (StgCreateDocfileOnILockBytes (lb' STGM.CREATE | STGM.READWRITE | STGM.SHARE_EXCLUSIVE | STGM.TRANSACTED' 0' out storage) == 0) { " is 132.
Long Statement,OfficeOpenXml.Utils,EncryptedPackageHandler,C:\repos\bambit_EPPlus\EPPlus\Utils\EncryptedPackageHandler.cs,EncryptPackage,The length of the statement  "		storage.CreateStream ("EncryptionInfo"' (uint)(STGM.CREATE | STGM.WRITE | STGM.DIRECT | STGM.SHARE_EXCLUSIVE)' (uint)0' (uint)0' out stream); " is 141.
Long Statement,OfficeOpenXml.Utils,EncryptedPackageHandler,C:\repos\bambit_EPPlus\EPPlus\Utils\EncryptedPackageHandler.cs,EncryptPackage,The length of the statement  "		storage.CreateStream ("EncryptedPackage"' (uint)(STGM.CREATE | STGM.WRITE | STGM.DIRECT | STGM.SHARE_EXCLUSIVE)' (uint)0' (uint)0' out stream); " is 143.
Long Statement,OfficeOpenXml.Utils,EncryptedPackageHandler,C:\repos\bambit_EPPlus\EPPlus\Utils\EncryptedPackageHandler.cs,CreateDataSpaces,The length of the statement  "	storage.CreateStorage ("\x06" + "DataSpaces"' (uint)(STGM.CREATE | STGM.WRITE | STGM.DIRECT | STGM.SHARE_EXCLUSIVE)' 0' 0' out dataSpaces); " is 139.
Long Statement,OfficeOpenXml.Utils,EncryptedPackageHandler,C:\repos\bambit_EPPlus\EPPlus\Utils\EncryptedPackageHandler.cs,CreateDataSpaces,The length of the statement  "	dataSpaces.CreateStream ("Version"' (uint)(STGM.CREATE | STGM.WRITE | STGM.DIRECT | STGM.SHARE_EXCLUSIVE)' 0' 0' out versionStream); " is 132.
Long Statement,OfficeOpenXml.Utils,EncryptedPackageHandler,C:\repos\bambit_EPPlus\EPPlus\Utils\EncryptedPackageHandler.cs,CreateDataSpaces,The length of the statement  "	dataSpaces.CreateStream ("DataSpaceMap"' (uint)(STGM.CREATE | STGM.WRITE | STGM.DIRECT | STGM.SHARE_EXCLUSIVE)' 0' 0' out dataSpaceMapStream); " is 142.
Long Statement,OfficeOpenXml.Utils,EncryptedPackageHandler,C:\repos\bambit_EPPlus\EPPlus\Utils\EncryptedPackageHandler.cs,CreateDataSpaces,The length of the statement  "	dataSpaces.CreateStorage ("DataSpaceInfo"' (uint)(STGM.CREATE | STGM.WRITE | STGM.DIRECT | STGM.SHARE_EXCLUSIVE)' 0' 0' out dataSpaceInfo); " is 139.
Long Statement,OfficeOpenXml.Utils,EncryptedPackageHandler,C:\repos\bambit_EPPlus\EPPlus\Utils\EncryptedPackageHandler.cs,CreateDataSpaces,The length of the statement  "	dataSpaceInfo.CreateStream ("StrongEncryptionDataSpace"' (uint)(STGM.CREATE | STGM.WRITE | STGM.DIRECT | STGM.SHARE_EXCLUSIVE)' 0' 0' out strongEncryptionDataSpaceStream); " is 171.
Long Statement,OfficeOpenXml.Utils,EncryptedPackageHandler,C:\repos\bambit_EPPlus\EPPlus\Utils\EncryptedPackageHandler.cs,CreateDataSpaces,The length of the statement  "	dataSpaces.CreateStorage ("TransformInfo"' (uint)(STGM.CREATE | STGM.WRITE | STGM.DIRECT | STGM.SHARE_EXCLUSIVE)' 0' 0' out tranformInfo); " is 138.
Long Statement,OfficeOpenXml.Utils,EncryptedPackageHandler,C:\repos\bambit_EPPlus\EPPlus\Utils\EncryptedPackageHandler.cs,CreateDataSpaces,The length of the statement  "	tranformInfo.CreateStorage ("StrongEncryptionTransform"' (uint)(STGM.CREATE | STGM.WRITE | STGM.DIRECT | STGM.SHARE_EXCLUSIVE)' 0' 0' out strongEncryptionTransform); " is 165.
Long Statement,OfficeOpenXml.Utils,EncryptedPackageHandler,C:\repos\bambit_EPPlus\EPPlus\Utils\EncryptedPackageHandler.cs,CreateDataSpaces,The length of the statement  "	strongEncryptionTransform.CreateStream ("\x06Primary"' (uint)(STGM.CREATE | STGM.WRITE | STGM.DIRECT | STGM.SHARE_EXCLUSIVE)' 0' 0' out primaryStream); " is 151.
Long Statement,OfficeOpenXml.Utils,EncryptedPackageHandler,C:\repos\bambit_EPPlus\EPPlus\Utils\EncryptedPackageHandler.cs,GetStreamFromPackage,The length of the statement  "				encryption.Algorithm = encryptionInfo.Header.AlgID == AlgorithmID.AES128 ? EncryptionAlgorithm.AES128 : encryptionInfo.Header.AlgID == AlgorithmID.AES192 ? EncryptionAlgorithm.AES192 : EncryptionAlgorithm.AES256; " is 212.
Long Statement,OfficeOpenXml.Utils,EncryptedPackageHandler,C:\repos\bambit_EPPlus\EPPlus\Utils\EncryptedPackageHandler.cs,DecryptDocument,The length of the statement  "	if (encryptionInfo.Header.AlgID == AlgorithmID.AES128 || (encryptionInfo.Header.AlgID == AlgorithmID.Flags && ((encryptionInfo.Flags & (Flags.fAES | Flags.fExternal | Flags.fCryptoAPI)) == (Flags.fAES | Flags.fCryptoAPI))) || encryptionInfo.Header.AlgID == AlgorithmID.AES192 || encryptionInfo.Header.AlgID == AlgorithmID.AES256) { " is 331.
Long Statement,OfficeOpenXml.Utils,EncryptedPackageHandler,C:\repos\bambit_EPPlus\EPPlus\Utils\EncryptedPackageHandler.cs,GetPasswordHash,The length of the statement  "		if (encryptionInfo.Header.AlgIDHash == AlgorithmHashID.SHA1 || encryptionInfo.Header.AlgIDHash == AlgorithmHashID.App && (encryptionInfo.Flags & Flags.fExternal) == 0) { " is 169.
Long Statement,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,ReadParts,The length of the statement  "				storage.OpenStorage (item.pwcsName' null' STGM.DIRECT | STGM.READ | STGM.SHARE_EXCLUSIVE' IntPtr.Zero' 0' out subStorage); " is 122.
Long Statement,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,Save,The length of the statement  "	if (StgCreateDocfileOnILockBytes (lb' STGM.CREATE | STGM.READWRITE | STGM.SHARE_EXCLUSIVE | STGM.TRANSACTED' 0' out storage) == 0) { " is 132.
Long Statement,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,CreateStore,The length of the statement  "	storage.CreateStorage (name' (uint)(STGM.CREATE | STGM.WRITE | STGM.DIRECT | STGM.SHARE_EXCLUSIVE)' 0' 0' out subStorage); " is 122.
Long Statement,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,CreateStreams,The length of the statement  "		subStorage.CreateStream (ds.Key' (uint)(STGM.CREATE | STGM.WRITE | STGM.DIRECT | STGM.SHARE_EXCLUSIVE)' 0' 0' out stream); " is 122.
Long Statement,OfficeOpenXml.Style.Dxf,ExcelDxfStyleConditionalFormatting,C:\repos\bambit_EPPlus\EPPlus\Style\Dxf\ExcelDxfStyle.cs,GetColor,The length of the statement  "		ret.Color = Color.FromArgb (int.Parse (rgb.Substring (0' 2)' System.Globalization.NumberStyles.AllowHexSpecifier)' int.Parse (rgb.Substring (2' 2)' System.Globalization.NumberStyles.AllowHexSpecifier)' int.Parse (rgb.Substring (4' 2)' System.Globalization.NumberStyles.AllowHexSpecifier)' int.Parse (rgb.Substring (6' 2)' System.Globalization.NumberStyles.AllowHexSpecifier)); " is 376.
Long Statement,OfficeOpenXml.Style,Border,C:\repos\bambit_EPPlus\EPPlus\Style\ExcelBorder.cs,BorderAround,The length of the statement  "	_ChangedEvent (this' new StyleChangeEventArgs (eStyleClass.BorderTop' eStyleProperty.Color' Color.ToArgb ().ToString ("X")' _positionID' new ExcelAddress (addr._fromRow' addr._fromCol' addr._fromRow' addr._toCol).Address)); " is 223.
Long Statement,OfficeOpenXml.Style,Border,C:\repos\bambit_EPPlus\EPPlus\Style\ExcelBorder.cs,BorderAround,The length of the statement  "	_ChangedEvent (this' new StyleChangeEventArgs (eStyleClass.BorderBottom' eStyleProperty.Color' Color.ToArgb ().ToString ("X")' _positionID' new ExcelAddress (addr._toRow' addr._fromCol' addr._toRow' addr._toCol).Address)); " is 222.
Long Statement,OfficeOpenXml.Style,Border,C:\repos\bambit_EPPlus\EPPlus\Style\ExcelBorder.cs,BorderAround,The length of the statement  "	_ChangedEvent (this' new StyleChangeEventArgs (eStyleClass.BorderLeft' eStyleProperty.Color' Color.ToArgb ().ToString ("X")' _positionID' new ExcelAddress (addr._fromRow' addr._fromCol' addr._toRow' addr._fromCol).Address)); " is 224.
Long Statement,OfficeOpenXml.Style,Border,C:\repos\bambit_EPPlus\EPPlus\Style\ExcelBorder.cs,BorderAround,The length of the statement  "	_ChangedEvent (this' new StyleChangeEventArgs (eStyleClass.BorderRight' eStyleProperty.Color' Color.ToArgb ().ToString ("X")' _positionID' new ExcelAddress (addr._fromRow' addr._toCol' addr._toRow' addr._toCol).Address)); " is 221.
Long Statement,OfficeOpenXml.Style,Border,C:\repos\bambit_EPPlus\EPPlus\Style\ExcelBorder.cs,SetBorderAroundStyle,The length of the statement  "	_ChangedEvent (this' new StyleChangeEventArgs (eStyleClass.BorderTop' eStyleProperty.Style' Style' _positionID' new ExcelAddress (addr._fromRow' addr._fromCol' addr._fromRow' addr._toCol).Address)); " is 198.
Long Statement,OfficeOpenXml.Style,Border,C:\repos\bambit_EPPlus\EPPlus\Style\ExcelBorder.cs,SetBorderAroundStyle,The length of the statement  "	_ChangedEvent (this' new StyleChangeEventArgs (eStyleClass.BorderBottom' eStyleProperty.Style' Style' _positionID' new ExcelAddress (addr._toRow' addr._fromCol' addr._toRow' addr._toCol).Address)); " is 197.
Long Statement,OfficeOpenXml.Style,Border,C:\repos\bambit_EPPlus\EPPlus\Style\ExcelBorder.cs,SetBorderAroundStyle,The length of the statement  "	_ChangedEvent (this' new StyleChangeEventArgs (eStyleClass.BorderLeft' eStyleProperty.Style' Style' _positionID' new ExcelAddress (addr._fromRow' addr._fromCol' addr._toRow' addr._fromCol).Address)); " is 199.
Long Statement,OfficeOpenXml.Style,Border,C:\repos\bambit_EPPlus\EPPlus\Style\ExcelBorder.cs,SetBorderAroundStyle,The length of the statement  "	_ChangedEvent (this' new StyleChangeEventArgs (eStyleClass.BorderRight' eStyleProperty.Style' Style' _positionID' new ExcelAddress (addr._fromRow' addr._toCol' addr._toRow' addr._toCol).Address)); " is 196.
Long Statement,OfficeOpenXml.Style.XmlAccess,ExcelXfs,C:\repos\bambit_EPPlus\EPPlus\Style\XmlAccess\ExcelXfsXml.cs,SetBorderItem,The length of the statement  "	else if (styleProperty == eStyleProperty.Color || styleProperty == eStyleProperty.Tint || styleProperty == eStyleProperty.IndexedColor) { " is 137.
Long Statement,OfficeOpenXml.Style.XmlAccess,ExcelXfs,C:\repos\bambit_EPPlus\EPPlus\Style\XmlAccess\ExcelXfsXml.cs,GetIdFont,The length of the statement  "		fnt.VerticalAlign = ((ExcelVerticalAlignmentFont)value) == ExcelVerticalAlignmentFont.None ? "" : value.ToString ().ToLower (); " is 127.
Long Statement,OfficeOpenXml.Table.PivotTable,ExcelPivotTableFieldCollection,C:\repos\bambit_EPPlus\EPPlus\Table\PivotTable\ExcelPivotTableFieldCollection.cs,GetDateGroupField,The length of the statement  "		if (fld.Grouping is ExcelPivotTableFieldDateGroup && (((ExcelPivotTableFieldDateGroup)fld.Grouping).GroupBy) == GroupBy) { " is 122.
Long Statement,OfficeOpenXml.Table.PivotTable,ExcelPivotTableRowColumnFieldCollection,C:\repos\bambit_EPPlus\EPPlus\Table\PivotTable\ExcelPivotTableFieldCollection.cs,SetFlag,The length of the statement  "			throw (new Exception (string.Format ("A pivot table with page fields must be located above row 3. Currenct location is {0}"' _table.Address.Address))); " is 151.
Long Statement,OfficeOpenXml.Table.PivotTable,ExcelPivotTableDataFieldCollection,C:\repos\bambit_EPPlus\EPPlus\Table\PivotTable\ExcelPivotTableFieldCollection.cs,ExistsDfName,The length of the statement  "		if (((!string.IsNullOrEmpty (df.Name) && df.Name.ToLower () == name) || (string.IsNullOrEmpty (df.Name) && df.Field.Name.ToLower () == name)) && datafield != df) { " is 163.
Long Statement,OfficeOpenXml.Table.PivotTable,ExcelPivotTableDataFieldCollection,C:\repos\bambit_EPPlus\EPPlus\Table\PivotTable\ExcelPivotTableFieldCollection.cs,Remove,The length of the statement  "	XmlElement node = dataField.Field.TopNode.SelectSingleNode (string.Format ("../../d:dataFields/d:dataField[@fld={0}]"' dataField.Index)' dataField.NameSpaceManager) as XmlElement; " is 179.
Long Statement,OfficeOpenXml.Table.PivotTable,ExcelPivotCacheDefinition,C:\repos\bambit_EPPlus\EPPlus\Table\PivotTable\ExcelPivotCacheDefinition.cs,GetStartXml,The length of the statement  "	string xml = "<pivotCacheDefinition xmlns=\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\" xmlns:r=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships\" r:id=\"\" refreshOnLoad=\"1\" refreshedBy=\"SomeUser\" refreshedDate=\"40504.582403125001\" createdVersion=\"1\" refreshedVersion=\"3\" recordCount=\"5\" upgradeOnRefresh=\"1\">"; " is 363.
Long Statement,OfficeOpenXml.Table.PivotTable,ExcelPivotCacheDefinition,C:\repos\bambit_EPPlus\EPPlus\Table\PivotTable\ExcelPivotCacheDefinition.cs,GetStartXml,The length of the statement  "	xml += string.Format ("<worksheetSource ref=\"{0}\" sheet=\"{1}\" /> "' sourceAddress.Address' sourceAddress.WorkSheet); " is 120.
Long Statement,OfficeOpenXml.Table.PivotTable,ExcelPivotCacheDefinition,C:\repos\bambit_EPPlus\EPPlus\Table\PivotTable\ExcelPivotCacheDefinition.cs,GetStartXml,The length of the statement  "		if (sourceWorksheet == null || sourceWorksheet.Cell (sourceAddress._fromRow' col).Value == null || sourceWorksheet.Cell (sourceAddress._fromRow' col).Value.ToString ().Trim () == "") { " is 184.
Long Statement,OfficeOpenXml.Table.PivotTable,ExcelPivotCacheDefinition,C:\repos\bambit_EPPlus\EPPlus\Table\PivotTable\ExcelPivotCacheDefinition.cs,GetStartXml,The length of the statement  "			xml += string.Format ("<cacheField name=\"{0}\" numFmtId=\"0\">"' sourceWorksheet.Cell (sourceAddress._fromRow' col).Value); " is 124.
Long Statement,OfficeOpenXml.Table.PivotTable,ExcelPivotTableField,C:\repos\bambit_EPPlus\EPPlus\Table\PivotTable\ExcelPivotTableField.cs,SetDateGroup,The length of the statement  "	group.TopNode.InnerXml += string.Format ("<fieldGroup base=\"{0}\"><rangePr groupBy=\"{1}\" /><groupItems /></fieldGroup>"' BaseIndex' GroupBy.ToString ().ToLower ()); " is 167.
Long Statement,OfficeOpenXml.Table.PivotTable,ExcelPivotTableField,C:\repos\bambit_EPPlus\EPPlus\Table\PivotTable\ExcelPivotTableField.cs,SetDateGroup,The length of the statement  "		_cacheFieldHelper.SetXmlNodeString ("d:fieldGroup/d:rangePr/@startDate"' StartDate.ToString ("s"' CultureInfo.InvariantCulture)); " is 129.
Long Statement,OfficeOpenXml.Table.PivotTable,ExcelPivotTableField,C:\repos\bambit_EPPlus\EPPlus\Table\PivotTable\ExcelPivotTableField.cs,SetDateGroup,The length of the statement  "		_cacheFieldHelper.SetXmlNodeString ("d:fieldGroup/d:rangePr/@endDate"' EndDate.ToString ("s"' CultureInfo.InvariantCulture)); " is 125.
Long Statement,OfficeOpenXml.Table.PivotTable,ExcelPivotTableField,C:\repos\bambit_EPPlus\EPPlus\Table\PivotTable\ExcelPivotTableField.cs,SetNumericGroup,The length of the statement  "	group.TopNode.InnerXml += string.Format ("<fieldGroup base=\"{0}\"><rangePr autoStart=\"0\" autoEnd=\"0\" startNum=\"{1}\" endNum=\"{2}\" groupInterval=\"{3}\"/><groupItems /></fieldGroup>"' BaseIndex' start.ToString (CultureInfo.InvariantCulture)' end.ToString (CultureInfo.InvariantCulture)' interval.ToString (CultureInfo.InvariantCulture)); " is 344.
Long Statement,OfficeOpenXml.Table.PivotTable,ExcelPivotTableField,C:\repos\bambit_EPPlus\EPPlus\Table\PivotTable\ExcelPivotTableField.cs,AddNumericGroupItems,The length of the statement  "	XmlElement groupItems = group.TopNode.SelectSingleNode ("d:fieldGroup/d:groupItems"' group.NameSpaceManager) as XmlElement; " is 123.
Long Statement,OfficeOpenXml.Table.PivotTable,ExcelPivotTableField,C:\repos\bambit_EPPlus\EPPlus\Table\PivotTable\ExcelPivotTableField.cs,AddNumericGroupItems,The length of the statement  "		AddGroupItem (groupItems' string.Format ("{0}-{1}"' index.ToString (CultureInfo.InvariantCulture)' nextIndex.ToString (CultureInfo.InvariantCulture))); " is 151.
Long Statement,OfficeOpenXml.Table.PivotTable,ExcelPivotTableField,C:\repos\bambit_EPPlus\EPPlus\Table\PivotTable\ExcelPivotTableField.cs,AddDateGroupItems,The length of the statement  "	XmlElement groupItems = group.TopNode.SelectSingleNode ("d:fieldGroup/d:groupItems"' group.NameSpaceManager) as XmlElement; " is 123.
Long Statement,OfficeOpenXml.Table.PivotTable,ExcelPivotTableField,C:\repos\bambit_EPPlus\EPPlus\Table\PivotTable\ExcelPivotTableField.cs,AddCacheField,The length of the statement  "	var cacheTopNode = _table.CacheDefinition.CacheDefinitionXml.SelectSingleNode ("//d:cacheFields"' _table.NameSpaceManager); " is 123.
Long Statement,OfficeOpenXml.Table.PivotTable,ExcelPivotTable,C:\repos\bambit_EPPlus\EPPlus\Table\PivotTable\ExcelPivotTable.cs,LoadFields,The length of the statement  "	foreach (XmlElement fieldElem in _cacheDefinition.TopNode.SelectNodes ("d:cacheFields/d:cacheField"' NameSpaceManager)) { " is 121.
Long Statement,OfficeOpenXml.Table.PivotTable,ExcelPivotTable,C:\repos\bambit_EPPlus\EPPlus\Table\PivotTable\ExcelPivotTable.cs,GetStartXml,The length of the statement  "	string xml = string.Format ("<pivotTableDefinition xmlns=\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\" name=\"{0}\" cacheId=\"{1}\" dataOnRows=\"1\" applyNumberFormats=\"0\" applyBorderFormats=\"0\" applyFontFormats=\"0\" applyPatternFormats=\"0\" applyAlignmentFormats=\"0\" applyWidthHeightFormats=\"1\" dataCaption=\"Data\"  createdVersion=\"4\" showMemberPropertyTips=\"0\" useAutoFormatting=\"1\" itemPrintTitles=\"1\" indent=\"0\" compact=\"0\" compactData=\"0\" gridDropZones=\"1\">"' name' id); " is 518.
Long Statement,OfficeOpenXml.Table.PivotTable,ExcelPivotTable,C:\repos\bambit_EPPlus\EPPlus\Table\PivotTable\ExcelPivotTable.cs,GetStartXml,The length of the statement  "	xml += string.Format ("<location ref=\"{0}\" firstHeaderRow=\"1\" firstDataRow=\"1\" firstDataCol=\"1\" /> "' address.FirstAddress); " is 132.
Long Statement,OfficeOpenXml.Table.PivotTable,ExcelPivotTable,C:\repos\bambit_EPPlus\EPPlus\Table\PivotTable\ExcelPivotTable.cs,GetStartXml,The length of the statement  "	xml += "<pivotTableStyleInfo name=\"PivotStyleMedium9\" showRowHeaders=\"1\" showColHeaders=\"1\" showRowStripes=\"0\" showColStripes=\"0\" showLastColumn=\"1\" />"; " is 165.
Long Statement,OfficeOpenXml.Table,ExcelTable,C:\repos\bambit_EPPlus\EPPlus\Table\ExcelTable.cs,GetStartXml,The length of the statement  "	xml += string.Format ("<table xmlns=\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\" id=\"{0}\" name=\"{1}\" displayName=\"{2}\" ref=\"{3}\" headerRowCount=\"1\">"' tblId' name' cleanDisplayName (name)' Address.Address); " is 233.
Long Statement,OfficeOpenXml.Table,ExcelTable,C:\repos\bambit_EPPlus\EPPlus\Table\ExcelTable.cs,GetStartXml,The length of the statement  "	xml += "<tableStyleInfo name=\"TableStyleMedium9\" showFirstColumn=\"0\" showLastColumn=\"0\" showRowStripes=\"1\" showColumnStripes=\"0\" /> "; " is 144.
Complex Conditional,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingRuleType,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\ExcelConditionalFormattingRuleType.cs,GetColorScaleType,The conditional expression  "(cfvoNodes == null) || (cfvoNodes.Count < 2) || (cfvoNodes.Count > 3) || (colorNodes == null) || (colorNodes.Count < 2) || (colorNodes.Count > 3) || (cfvoNodes.Count != colorNodes.Count)"  is complex.
Complex Conditional,OfficeOpenXml.Drawing.Chart,ExcelChart,C:\repos\bambit_EPPlus\EPPlus\Drawing\Chart\ExcelChart.cs,GetChartSerieStartXml,The conditional expression  "ChartType == eChartType.BarStacked100 || ChartType == eChartType.BarStacked || ChartType == eChartType.ColumnStacked || ChartType == eChartType.ColumnStacked100"  is complex.
Complex Conditional,OfficeOpenXml.Drawing.Chart,ExcelChart,C:\repos\bambit_EPPlus\EPPlus\Drawing\Chart\ExcelChart.cs,AddScatterType,The conditional expression  "type == eChartType.XYScatter || type == eChartType.XYScatterLines || type == eChartType.XYScatterLinesNoMarkers || type == eChartType.XYScatterSmooth || type == eChartType.XYScatterSmoothNoMarkers"  is complex.
Complex Conditional,OfficeOpenXml.Drawing.Chart,ExcelChartTrendlineCollection,C:\repos\bambit_EPPlus\EPPlus\Drawing\Chart\ExcelChartTrendline.cs,Add,The conditional expression  "_serie._chartSeries._chart.IsType3D () || _serie._chartSeries._chart.IsTypePercentStacked () || _serie._chartSeries._chart.IsTypeStacked () || _serie._chartSeries._chart.IsTypePieDoughnut ()"  is complex.
Complex Conditional,OfficeOpenXml.Drawing.Chart,ExcelBarChart,C:\repos\bambit_EPPlus\EPPlus\Drawing\Chart\ExcelBarChart.cs,SetTypeProperties,The conditional expression  "type == eChartType.BarClustered || type == eChartType.BarStacked || type == eChartType.BarStacked100 || type == eChartType.BarClustered3D || type == eChartType.BarStacked3D || type == eChartType.BarStacked1003D || type == eChartType.ConeBarClustered || type == eChartType.ConeBarStacked || type == eChartType.ConeBarStacked100 || type == eChartType.CylinderBarClustered || type == eChartType.CylinderBarStacked || type == eChartType.CylinderBarStacked100 || type == eChartType.PyramidBarClustered || type == eChartType.PyramidBarStacked || type == eChartType.PyramidBarStacked100"  is complex.
Complex Conditional,OfficeOpenXml.Drawing.Chart,ExcelBarChart,C:\repos\bambit_EPPlus\EPPlus\Drawing\Chart\ExcelBarChart.cs,SetTypeProperties,The conditional expression  "type == eChartType.ColumnClustered || type == eChartType.ColumnStacked || type == eChartType.ColumnStacked100 || type == eChartType.Column3D || type == eChartType.ColumnClustered3D || type == eChartType.ColumnStacked3D || type == eChartType.ColumnStacked1003D || type == eChartType.ConeCol || type == eChartType.ConeColClustered || type == eChartType.ConeColStacked || type == eChartType.ConeColStacked100 || type == eChartType.CylinderCol || type == eChartType.CylinderColClustered || type == eChartType.CylinderColStacked || type == eChartType.CylinderColStacked100 || type == eChartType.PyramidCol || type == eChartType.PyramidColClustered || type == eChartType.PyramidColStacked || type == eChartType.PyramidColStacked100"  is complex.
Complex Conditional,OfficeOpenXml.Drawing.Chart,ExcelBarChart,C:\repos\bambit_EPPlus\EPPlus\Drawing\Chart\ExcelBarChart.cs,SetTypeProperties,The conditional expression  "type == eChartType.Column3D || type == eChartType.ColumnClustered3D || type == eChartType.ColumnStacked3D || type == eChartType.ColumnStacked1003D || /*type == eChartType.BarClustered ||                 type == eChartType.BarStacked ||                 type == eChartType.BarStacked100 ||*/type == eChartType.BarClustered3D || type == eChartType.BarStacked3D || type == eChartType.BarStacked1003D"  is complex.
Complex Conditional,OfficeOpenXml.Drawing.Chart,ExcelBarChart,C:\repos\bambit_EPPlus\EPPlus\Drawing\Chart\ExcelBarChart.cs,SetTypeProperties,The conditional expression  "type == eChartType.CylinderBarClustered || type == eChartType.CylinderBarStacked || type == eChartType.CylinderBarStacked100 || type == eChartType.CylinderCol || type == eChartType.CylinderColClustered || type == eChartType.CylinderColStacked || type == eChartType.CylinderColStacked100"  is complex.
Complex Conditional,OfficeOpenXml.Drawing.Chart,ExcelBarChart,C:\repos\bambit_EPPlus\EPPlus\Drawing\Chart\ExcelBarChart.cs,SetTypeProperties,The conditional expression  "type == eChartType.ConeBarClustered || type == eChartType.ConeBarStacked || type == eChartType.ConeBarStacked100 || type == eChartType.ConeCol || type == eChartType.ConeColClustered || type == eChartType.ConeColStacked || type == eChartType.ConeColStacked100"  is complex.
Complex Conditional,OfficeOpenXml.Drawing.Chart,ExcelBarChart,C:\repos\bambit_EPPlus\EPPlus\Drawing\Chart\ExcelBarChart.cs,SetTypeProperties,The conditional expression  "type == eChartType.PyramidBarClustered || type == eChartType.PyramidBarStacked || type == eChartType.PyramidBarStacked100 || type == eChartType.PyramidCol || type == eChartType.PyramidColClustered || type == eChartType.PyramidColStacked || type == eChartType.PyramidColStacked100"  is complex.
Complex Conditional,OfficeOpenXml.Drawing.Chart,ExcelChartSerie,C:\repos\bambit_EPPlus\EPPlus\Drawing\Chart\ExcelChartSerie.cs,ExcelChartSerie,The conditional expression  "chartSeries.Chart.ChartType == eChartType.XYScatter || chartSeries.Chart.ChartType == eChartType.XYScatterLines || chartSeries.Chart.ChartType == eChartType.XYScatterLinesNoMarkers || chartSeries.Chart.ChartType == eChartType.XYScatterSmooth || chartSeries.Chart.ChartType == eChartType.XYScatterSmoothNoMarkers"  is complex.
Complex Conditional,OfficeOpenXml.Drawing.Chart,ExcelChartSeries,C:\repos\bambit_EPPlus\EPPlus\Drawing\Chart\ExcelChartSeries.cs,ExcelChartSeries,The conditional expression  "chart.ChartNode.LocalName == "pieChart" || chart.ChartNode.LocalName == "ofPieChart" || chart.ChartNode.LocalName == "pie3DChart" || chart.ChartNode.LocalName == "doughnutChart""  is complex.
Complex Conditional,OfficeOpenXml.Drawing.Chart,ExcelChartSeries,C:\repos\bambit_EPPlus\EPPlus\Drawing\Chart\ExcelChartSeries.cs,AddMarker,The conditional expression  "chartType == eChartType.Line || chartType == eChartType.LineStacked || chartType == eChartType.LineStacked100 || chartType == eChartType.XYScatterLines || chartType == eChartType.XYScatterSmooth || chartType == eChartType.XYScatterLinesNoMarkers || chartType == eChartType.XYScatterSmoothNoMarkers"  is complex.
Complex Conditional,OfficeOpenXml.Drawing.Chart,ExcelChartSeries,C:\repos\bambit_EPPlus\EPPlus\Drawing\Chart\ExcelChartSeries.cs,AddAxisNodes,The conditional expression  "chartType == eChartType.XYScatter || chartType == eChartType.XYScatterLines || chartType == eChartType.XYScatterLinesNoMarkers || chartType == eChartType.XYScatterSmooth || chartType == eChartType.XYScatterSmoothNoMarkers"  is complex.
Complex Conditional,OfficeOpenXml.Drawing,ExcelDrawings,C:\repos\bambit_EPPlus\EPPlus\Drawing\ExcelDrawings.cs,AddChart,The conditional expression  "ChartType == eChartType.Bubble || ChartType == eChartType.Bubble3DEffect || ChartType == eChartType.Radar || ChartType == eChartType.RadarFilled || ChartType == eChartType.RadarMarkers || ChartType == eChartType.StockHLC || ChartType == eChartType.StockOHLC || ChartType == eChartType.StockVOHLC || ChartType == eChartType.Surface || ChartType == eChartType.SurfaceTopView || ChartType == eChartType.SurfaceTopViewWireframe || ChartType == eChartType.SurfaceWireframe"  is complex.
Complex Conditional,OfficeOpenXml,OfficeProperties,C:\repos\bambit_EPPlus\EPPlus\OfficeProperties.cs,SetCustomPropertyValue,The conditional expression  "value is double || value is decimal || value is float || value is long"  is complex.
Complex Conditional,OfficeOpenXml,ExcelWorkbook,C:\repos\bambit_EPPlus\EPPlus\ExcelWorkbook.cs,UpdateSharedStringsXml,The conditional expression  "t.Length > 0 && (t [0] == ' ' || t [t.Length - 1] == ' ' || t.Contains ("  ") || t.Contains ("\t"))"  is complex.
Complex Conditional,OfficeOpenXml,ExcelWorkbook,C:\repos\bambit_EPPlus\EPPlus\ExcelWorkbook.cs,ExcelEncodeString,The conditional expression  "t [i] <= 0x1f && t [i] != '\t' && t [i] != '\n' && t [i] != '\r'"  is complex.
Complex Conditional,OfficeOpenXml,ExcelWorksheet,C:\repos\bambit_EPPlus\EPPlus\ExcelWorksheet.cs,GetValueFromXml,The conditional expression  "(n >= 14 && n <= 22) || (n >= 45 && n <= 47)"  is complex.
Complex Conditional,OfficeOpenXml,ExcelWorksheet,C:\repos\bambit_EPPlus\EPPlus\ExcelWorksheet.cs,SetValue,The conditional expression  "row < 1 || col < 1 || row > ExcelPackage.MaxRows && col > ExcelPackage.MaxColumns"  is complex.
Complex Conditional,OfficeOpenXml,ExcelWorksheet,C:\repos\bambit_EPPlus\EPPlus\ExcelWorksheet.cs,UpdateRowCellData,The conditional expression  "(cell._value.GetType ().IsPrimitive || cell._value is double || cell._value is decimal || cell._value is DateTime || cell._value is TimeSpan) && cell.DataType != "s""  is complex.
Complex Conditional,OfficeOpenXml,XmlHelper,C:\repos\bambit_EPPlus\EPPlus\XmlHelper.cs,CreateNode,The conditional expression  "nodePrefix == "" || (node.OwnerDocument != null && node.OwnerDocument.DocumentElement != null && node.OwnerDocument.DocumentElement.NamespaceURI == nameSpaceURI && node.OwnerDocument.DocumentElement.Prefix == "")"  is complex.
Complex Conditional,OfficeOpenXml,XmlHelper,C:\repos\bambit_EPPlus\EPPlus\XmlHelper.cs,CreateComplexNode,The conditional expression  "node.OwnerDocument != null && node.OwnerDocument.DocumentElement != null && node.OwnerDocument.DocumentElement.NamespaceURI == nameSpaceURI && node.OwnerDocument.DocumentElement.Prefix == string.Empty"  is complex.
Complex Conditional,OfficeOpenXml,ExcelAddressBase,C:\repos\bambit_EPPlus\EPPlus\ExcelAddress.cs,ExtractAddress,The conditional expression  "c == '!' && !isText && !first.EndsWith ("#REF") && !second.EndsWith ("#REF")"  is complex.
Complex Conditional,OfficeOpenXml,ExcelAddressBase,C:\repos\bambit_EPPlus\EPPlus\ExcelAddress.cs,Collide,The conditional expression  "address._fromRow > _toRow || address._fromCol > _toCol || _fromRow > address._toRow || _fromCol > address._toCol"  is complex.
Complex Conditional,OfficeOpenXml,ExcelAddressBase,C:\repos\bambit_EPPlus\EPPlus\ExcelAddress.cs,Collide,The conditional expression  "address._fromRow == _fromRow && address._fromCol == _fromCol && address._toRow == _toRow && address._toCol == _toCol"  is complex.
Complex Conditional,OfficeOpenXml,ExcelAddressBase,C:\repos\bambit_EPPlus\EPPlus\ExcelAddress.cs,Collide,The conditional expression  "address._fromRow >= _fromRow && address._toRow <= _toRow && address._fromCol >= _fromCol && address._toCol <= _toCol"  is complex.
Complex Conditional,OfficeOpenXml,ExcelAddressBase,C:\repos\bambit_EPPlus\EPPlus\ExcelAddress.cs,IsValid,The conditional expression  "_fromRow > 0 && _fromCol > 0 && _toRow <= ExcelPackage.MaxRows && _toCol <= ExcelPackage.MaxColumns"  is complex.
Complex Conditional,OfficeOpenXml,ExcelCellBase,C:\repos\bambit_EPPlus\EPPlus\ExcelCellBase.cs,Translate,The conditional expression  "(c == '-' || c == '+' || c == '*' || c == '/' || c == '=' || c == '^' || c == ''' || c == ':' || c == '<' || c == '>' || c == '(' || c == ')' || c == '!' || c == ' ' || c == '&' || c == '%') && (pos == 0 || value [pos - 1] != '[')"  is complex.
Complex Conditional,OfficeOpenXml,ExcelCellBase,C:\repos\bambit_EPPlus\EPPlus\ExcelCellBase.cs,AddToRowColumnTranslator,The conditional expression  "rowIncr != 0 && row != 0 && fromRow >= row && Address.IndexOf ('$'' 1) == -1"  is complex.
Complex Conditional,OfficeOpenXml,ExcelCellBase,C:\repos\bambit_EPPlus\EPPlus\ExcelCellBase.cs,AddToRowColumnTranslator,The conditional expression  "colIncr != 0 && col != 0 && fromCol >= col && Address.StartsWith ("$") == false"  is complex.
Complex Conditional,OfficeOpenXml,ExcelCellBase,C:\repos\bambit_EPPlus\EPPlus\ExcelCellBase.cs,GetRowCol,The conditional expression  "(address [i] >= 'A' && address [i] <= 'Z') && colPart && sCol.Length <= 3"  is complex.
Complex Conditional,OfficeOpenXml,ExcelCellBase,C:\repos\bambit_EPPlus\EPPlus\ExcelCellBase.cs,GetFullAddress,The conditional expression  "(a._fromRow == 1 && a._toRow == ExcelPackage.MaxRows) || (a._fromCol == 1 && a._toCol == ExcelPackage.MaxColumns)"  is complex.
Complex Conditional,OfficeOpenXml,ExcelCellBase,C:\repos\bambit_EPPlus\EPPlus\ExcelCellBase.cs,IsValidCellAddress,The conditional expression  "row > 0 && col > 0 && row <= ExcelPackage.MaxRows && col <= ExcelPackage.MaxColumns"  is complex.
Complex Conditional,OfficeOpenXml,ExcelRangeBase,C:\repos\bambit_EPPlus\EPPlus\ExcelRangeBase.cs,SetValueAddress,The conditional expression  "_fromRow == 1 && _fromCol == 1 && _toRow == ExcelPackage.MaxRows && _toCol == ExcelPackage.MaxColumns"  is complex.
Complex Conditional,OfficeOpenXml,ExcelRangeBase,C:\repos\bambit_EPPlus\EPPlus\ExcelRangeBase.cs,Set_SharedFormula,The conditional expression  "_fromRow == 1 && _fromCol == 1 && _toRow == ExcelPackage.MaxRows && _toCol == ExcelPackage.MaxColumns"  is complex.
Complex Conditional,OfficeOpenXml,ExcelRangeBase,C:\repos\bambit_EPPlus\EPPlus\ExcelRangeBase.cs,GetValueArray,The conditional expression  "_fromRow == 1 && _fromCol == 1 && _toRow == ExcelPackage.MaxRows && _toCol == ExcelPackage.MaxColumns"  is complex.
Complex Conditional,OfficeOpenXml,ExcelRangeBase,C:\repos\bambit_EPPlus\EPPlus\ExcelRangeBase.cs,GetAddressDim,The conditional expression  "addr._fromCol == fromRow && addr._fromCol == addr._fromCol && addr._toRow == toRow && addr._toCol == _toCol"  is complex.
Complex Conditional,OfficeOpenXml,ExcelRangeBase,C:\repos\bambit_EPPlus\EPPlus\ExcelRangeBase.cs,SetValueRichText,The conditional expression  "_fromRow == 1 && _fromCol == 1 && _toRow == ExcelPackage.MaxRows && _toCol == ExcelPackage.MaxColumns"  is complex.
Complex Conditional,OfficeOpenXml,ExcelRangeBase,C:\repos\bambit_EPPlus\EPPlus\ExcelRangeBase.cs,RemoveFormuls,The conditional expression  "((fFromCol >= address.Start.Column && fFromCol <= address.End.Column) || (fToCol >= address.Start.Column && fToCol <= address.End.Column)) && ((fFromRow >= address.Start.Row && fFromRow <= address.End.Row) || (fToRow >= address.Start.Row && fToRow <= address.End.Row))"  is complex.
Complex Conditional,OfficeOpenXml,ExcelRangeBase,C:\repos\bambit_EPPlus\EPPlus\ExcelRangeBase.cs,LoadFromCollection,The conditional expression  "item is string || item is decimal || item is DateTime || item.GetType ().IsPrimitive"  is complex.
Complex Conditional,OfficeOpenXml,ExcelRangeBase,C:\repos\bambit_EPPlus\EPPlus\ExcelRangeBase.cs,Offset,The conditional expression  "_fromRow + RowOffset < 1 || _fromCol + ColumnOffset < 1 || _fromRow + RowOffset > ExcelPackage.MaxRows || _fromCol + ColumnOffset > ExcelPackage.MaxColumns"  is complex.
Complex Conditional,OfficeOpenXml,ExcelRangeBase,C:\repos\bambit_EPPlus\EPPlus\ExcelRangeBase.cs,Offset,The conditional expression  "_fromRow + RowOffset < 1 || _fromCol + ColumnOffset < 1 || _fromRow + RowOffset > ExcelPackage.MaxRows || _fromCol + ColumnOffset > ExcelPackage.MaxColumns || _fromRow + RowOffset + NumberOfRows < 1 || _fromCol + ColumnOffset + NumberOfColumns < 1 || _fromRow + RowOffset + NumberOfRows > ExcelPackage.MaxRows || _fromCol + ColumnOffset + NumberOfColumns > ExcelPackage.MaxColumns"  is complex.
Complex Conditional,OfficeOpenXml.Utils,EncryptedPackageHandler,C:\repos\bambit_EPPlus\EPPlus\Utils\EncryptedPackageHandler.cs,DecryptDocument,The conditional expression  "encryptionInfo.Header.AlgID == AlgorithmID.AES128 || (encryptionInfo.Header.AlgID == AlgorithmID.Flags && ((encryptionInfo.Flags & (Flags.fAES | Flags.fExternal | Flags.fCryptoAPI)) == (Flags.fAES | Flags.fCryptoAPI))) || encryptionInfo.Header.AlgID == AlgorithmID.AES192 || encryptionInfo.Header.AlgID == AlgorithmID.AES256"  is complex.
Complex Conditional,OfficeOpenXml.Table.PivotTable,ExcelPivotTableDataFieldCollection,C:\repos\bambit_EPPlus\EPPlus\Table\PivotTable\ExcelPivotTableFieldCollection.cs,ExistsDfName,The conditional expression  "((!string.IsNullOrEmpty (df.Name) && df.Name.ToLower () == name) || (string.IsNullOrEmpty (df.Name) && df.Field.Name.ToLower () == name)) && datafield != df"  is complex.
Empty Catch Block,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingCollection,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\ExcelConditionalFormattingCollection.cs,RemoveByPriority,The method has an empty catch block.
Empty Catch Block,OfficeOpenXml,ExcelWorksheet,C:\repos\bambit_EPPlus\EPPlus\ExcelWorksheet.cs,LoadHyperLinks,The method has an empty catch block.
Empty Catch Block,OfficeOpenXml,ExcelCellBase,C:\repos\bambit_EPPlus\EPPlus\ExcelCellBase.cs,IsValidCellAddress,The method has an empty catch block.
Magic Number,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingFiveIconSet,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\Rules\ExcelConditionalFormattingFiveIconSet.cs,ExcelConditionalFormattingFiveIconSet,The following statement contains a magic number: if (itemElementNode != null && itemElementNode.HasChildNodes) {  	XmlNode iconNode4 = TopNode.SelectSingleNode ("d:iconSet/d:cfvo[position()=4]"' NameSpaceManager);  	Icon4 = new ExcelConditionalFormattingIconDataBarValue (eExcelConditionalFormattingRuleType.FiveIconSet' address' worksheet' iconNode4' namespaceManager);  	XmlNode iconNode5 = TopNode.SelectSingleNode ("d:iconSet/d:cfvo[position()=5]"' NameSpaceManager);  	Icon5 = new ExcelConditionalFormattingIconDataBarValue (eExcelConditionalFormattingRuleType.FiveIconSet' address' worksheet' iconNode5' namespaceManager);  }  else {  	XmlNode iconSetNode = TopNode.SelectSingleNode ("d:iconSet"' NameSpaceManager);  	var iconNode4 = iconSetNode.OwnerDocument.CreateElement (ExcelConditionalFormattingConstants.Paths.Cfvo' ExcelPackage.schemaMain);  	iconSetNode.AppendChild (iconNode4);  	Icon4 = new ExcelConditionalFormattingIconDataBarValue (eExcelConditionalFormattingValueObjectType.Percent' 60' ""' eExcelConditionalFormattingRuleType.ThreeIconSet' address' priority' worksheet' iconNode4' namespaceManager);  	var iconNode5 = iconSetNode.OwnerDocument.CreateElement (ExcelConditionalFormattingConstants.Paths.Cfvo' ExcelPackage.schemaMain);  	iconSetNode.AppendChild (iconNode5);  	Icon5 = new ExcelConditionalFormattingIconDataBarValue (eExcelConditionalFormattingValueObjectType.Percent' 80' ""' eExcelConditionalFormattingRuleType.ThreeIconSet' address' priority' worksheet' iconNode5' namespaceManager);  }  
Magic Number,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingFiveIconSet,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\Rules\ExcelConditionalFormattingFiveIconSet.cs,ExcelConditionalFormattingFiveIconSet,The following statement contains a magic number: if (itemElementNode != null && itemElementNode.HasChildNodes) {  	XmlNode iconNode4 = TopNode.SelectSingleNode ("d:iconSet/d:cfvo[position()=4]"' NameSpaceManager);  	Icon4 = new ExcelConditionalFormattingIconDataBarValue (eExcelConditionalFormattingRuleType.FiveIconSet' address' worksheet' iconNode4' namespaceManager);  	XmlNode iconNode5 = TopNode.SelectSingleNode ("d:iconSet/d:cfvo[position()=5]"' NameSpaceManager);  	Icon5 = new ExcelConditionalFormattingIconDataBarValue (eExcelConditionalFormattingRuleType.FiveIconSet' address' worksheet' iconNode5' namespaceManager);  }  else {  	XmlNode iconSetNode = TopNode.SelectSingleNode ("d:iconSet"' NameSpaceManager);  	var iconNode4 = iconSetNode.OwnerDocument.CreateElement (ExcelConditionalFormattingConstants.Paths.Cfvo' ExcelPackage.schemaMain);  	iconSetNode.AppendChild (iconNode4);  	Icon4 = new ExcelConditionalFormattingIconDataBarValue (eExcelConditionalFormattingValueObjectType.Percent' 60' ""' eExcelConditionalFormattingRuleType.ThreeIconSet' address' priority' worksheet' iconNode4' namespaceManager);  	var iconNode5 = iconSetNode.OwnerDocument.CreateElement (ExcelConditionalFormattingConstants.Paths.Cfvo' ExcelPackage.schemaMain);  	iconSetNode.AppendChild (iconNode5);  	Icon5 = new ExcelConditionalFormattingIconDataBarValue (eExcelConditionalFormattingValueObjectType.Percent' 80' ""' eExcelConditionalFormattingRuleType.ThreeIconSet' address' priority' worksheet' iconNode5' namespaceManager);  }  
Magic Number,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingFiveIconSet,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\Rules\ExcelConditionalFormattingFiveIconSet.cs,ExcelConditionalFormattingFiveIconSet,The following statement contains a magic number: Icon4 = new ExcelConditionalFormattingIconDataBarValue (eExcelConditionalFormattingValueObjectType.Percent' 60' ""' eExcelConditionalFormattingRuleType.ThreeIconSet' address' priority' worksheet' iconNode4' namespaceManager);  
Magic Number,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingFiveIconSet,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\Rules\ExcelConditionalFormattingFiveIconSet.cs,ExcelConditionalFormattingFiveIconSet,The following statement contains a magic number: Icon5 = new ExcelConditionalFormattingIconDataBarValue (eExcelConditionalFormattingValueObjectType.Percent' 80' ""' eExcelConditionalFormattingRuleType.ThreeIconSet' address' priority' worksheet' iconNode5' namespaceManager);  
Magic Number,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingFourIconSet,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\Rules\ExcelConditionalFormattingFourIconSet.cs,ExcelConditionalFormattingFourIconSet,The following statement contains a magic number: if (itemElementNode != null && itemElementNode.HasChildNodes) {  	XmlNode iconNode4 = TopNode.SelectSingleNode ("d:iconSet/d:cfvo[position()=4]"' NameSpaceManager);  	Icon4 = new ExcelConditionalFormattingIconDataBarValue (eExcelConditionalFormattingRuleType.FourIconSet' address' worksheet' iconNode4' namespaceManager);  }  else {  	XmlNode iconSetNode = TopNode.SelectSingleNode ("d:iconSet"' NameSpaceManager);  	var iconNode4 = iconSetNode.OwnerDocument.CreateElement (ExcelConditionalFormattingConstants.Paths.Cfvo' ExcelPackage.schemaMain);  	iconSetNode.AppendChild (iconNode4);  	Icon4 = new ExcelConditionalFormattingIconDataBarValue (eExcelConditionalFormattingValueObjectType.Percent' 75' ""' eExcelConditionalFormattingRuleType.ThreeIconSet' address' priority' worksheet' iconNode4' namespaceManager);  }  
Magic Number,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingFourIconSet,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\Rules\ExcelConditionalFormattingFourIconSet.cs,ExcelConditionalFormattingFourIconSet,The following statement contains a magic number: Icon4 = new ExcelConditionalFormattingIconDataBarValue (eExcelConditionalFormattingValueObjectType.Percent' 75' ""' eExcelConditionalFormattingRuleType.ThreeIconSet' address' priority' worksheet' iconNode4' namespaceManager);  
Magic Number,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingValueObjectType,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\ExcelConditionalFormattingValueObjectType.cs,GetOrderByPosition,The following statement contains a magic number: switch (position) {  case eExcelConditionalFormattingValueObjectPosition.Low:  	return 1;  case eExcelConditionalFormattingValueObjectPosition.Middle:  	return 2;  case eExcelConditionalFormattingValueObjectPosition.High:  	// Check if the rule type is TwoColorScale.  	if (ruleType == eExcelConditionalFormattingRuleType.TwoColorScale) {  		// There are only "Low" and "High". So "High" is the second  		return 2;  	}  	// There are "Low"' "Middle" and "High". So "High" is the third  	return 3;  }  
Magic Number,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingValueObjectType,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\ExcelConditionalFormattingValueObjectType.cs,GetOrderByPosition,The following statement contains a magic number: switch (position) {  case eExcelConditionalFormattingValueObjectPosition.Low:  	return 1;  case eExcelConditionalFormattingValueObjectPosition.Middle:  	return 2;  case eExcelConditionalFormattingValueObjectPosition.High:  	// Check if the rule type is TwoColorScale.  	if (ruleType == eExcelConditionalFormattingRuleType.TwoColorScale) {  		// There are only "Low" and "High". So "High" is the second  		return 2;  	}  	// There are "Low"' "Middle" and "High". So "High" is the third  	return 3;  }  
Magic Number,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingValueObjectType,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\ExcelConditionalFormattingValueObjectType.cs,GetOrderByPosition,The following statement contains a magic number: switch (position) {  case eExcelConditionalFormattingValueObjectPosition.Low:  	return 1;  case eExcelConditionalFormattingValueObjectPosition.Middle:  	return 2;  case eExcelConditionalFormattingValueObjectPosition.High:  	// Check if the rule type is TwoColorScale.  	if (ruleType == eExcelConditionalFormattingRuleType.TwoColorScale) {  		// There are only "Low" and "High". So "High" is the second  		return 2;  	}  	// There are "Low"' "Middle" and "High". So "High" is the third  	return 3;  }  
Magic Number,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingValueObjectType,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\ExcelConditionalFormattingValueObjectType.cs,GetOrderByPosition,The following statement contains a magic number: return 2;  
Magic Number,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingValueObjectType,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\ExcelConditionalFormattingValueObjectType.cs,GetOrderByPosition,The following statement contains a magic number: if (ruleType == eExcelConditionalFormattingRuleType.TwoColorScale) {  	// There are only "Low" and "High". So "High" is the second  	return 2;  }  
Magic Number,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingValueObjectType,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\ExcelConditionalFormattingValueObjectType.cs,GetOrderByPosition,The following statement contains a magic number: return 2;  
Magic Number,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingValueObjectType,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\ExcelConditionalFormattingValueObjectType.cs,GetOrderByPosition,The following statement contains a magic number: return 3;  
Magic Number,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingBottom,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\Rules\ExcelConditionalFormattingBottom.cs,ExcelConditionalFormattingBottom,The following statement contains a magic number: if (itemElementNode == null)//Set default values and create attributes if needed   {  	Bottom = true;  	Percent = false;  	Rank = 10;  	// Last 10 values  }  
Magic Number,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingBottom,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\Rules\ExcelConditionalFormattingBottom.cs,ExcelConditionalFormattingBottom,The following statement contains a magic number: Rank = 10;  
Magic Number,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingBottomPercent,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\Rules\ExcelConditionalFormattingBottomPercent.cs,ExcelConditionalFormattingBottomPercent,The following statement contains a magic number: if (itemElementNode == null)//Set default values and create attributes if needed   {  	Bottom = true;  	Percent = true;  	Rank = 10;  	// Last 10 percent  }  
Magic Number,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingBottomPercent,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\Rules\ExcelConditionalFormattingBottomPercent.cs,ExcelConditionalFormattingBottomPercent,The following statement contains a magic number: Rank = 10;  
Magic Number,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingRuleType,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\ExcelConditionalFormattingRuleType.cs,GetColorScaleType,The following statement contains a magic number: if ((cfvoNodes == null) || (cfvoNodes.Count < 2) || (cfvoNodes.Count > 3) || (colorNodes == null) || (colorNodes.Count < 2) || (colorNodes.Count > 3) || (cfvoNodes.Count != colorNodes.Count)) {  	throw new Exception (ExcelConditionalFormattingConstants.Errors.WrongNumberCfvoColorNodes);  }  
Magic Number,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingRuleType,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\ExcelConditionalFormattingRuleType.cs,GetColorScaleType,The following statement contains a magic number: if ((cfvoNodes == null) || (cfvoNodes.Count < 2) || (cfvoNodes.Count > 3) || (colorNodes == null) || (colorNodes.Count < 2) || (colorNodes.Count > 3) || (cfvoNodes.Count != colorNodes.Count)) {  	throw new Exception (ExcelConditionalFormattingConstants.Errors.WrongNumberCfvoColorNodes);  }  
Magic Number,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingRuleType,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\ExcelConditionalFormattingRuleType.cs,GetColorScaleType,The following statement contains a magic number: if ((cfvoNodes == null) || (cfvoNodes.Count < 2) || (cfvoNodes.Count > 3) || (colorNodes == null) || (colorNodes.Count < 2) || (colorNodes.Count > 3) || (cfvoNodes.Count != colorNodes.Count)) {  	throw new Exception (ExcelConditionalFormattingConstants.Errors.WrongNumberCfvoColorNodes);  }  
Magic Number,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingRuleType,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\ExcelConditionalFormattingRuleType.cs,GetColorScaleType,The following statement contains a magic number: if ((cfvoNodes == null) || (cfvoNodes.Count < 2) || (cfvoNodes.Count > 3) || (colorNodes == null) || (colorNodes.Count < 2) || (colorNodes.Count > 3) || (cfvoNodes.Count != colorNodes.Count)) {  	throw new Exception (ExcelConditionalFormattingConstants.Errors.WrongNumberCfvoColorNodes);  }  
Magic Number,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingRuleType,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\ExcelConditionalFormattingRuleType.cs,GetColorScaleType,The following statement contains a magic number: return (cfvoNodes.Count == 2) ? eExcelConditionalFormattingRuleType.TwoColorScale : eExcelConditionalFormattingRuleType.ThreeColorScale;  
Magic Number,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingThreeColorScale,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\Rules\ExcelConditionalFormattingThreeColorScale.cs,ExcelConditionalFormattingThreeColorScale,The following statement contains a magic number: MiddleValue = new ExcelConditionalFormattingColorScaleValue (eExcelConditionalFormattingValueObjectPosition.Middle' eExcelConditionalFormattingValueObjectType.Percent' ColorTranslator.FromHtml (ExcelConditionalFormattingConstants.Colors.CfvoMiddleValue)' 50' string.Empty' eExcelConditionalFormattingRuleType.ThreeColorScale' address' priority' worksheet' NameSpaceManager);  
Magic Number,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingIconSetBase,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\Rules\ExcelConditionalFormattingThreeIconSet.cs,ExcelConditionalFormattingIconSetBase,The following statement contains a magic number: if (itemElementNode != null && itemElementNode.HasChildNodes) {  	int pos = 1;  	foreach (XmlNode node in itemElementNode.SelectNodes ("d:iconSet/d:cfvo"' NameSpaceManager)) {  		if (pos == 1) {  			Icon1 = new ExcelConditionalFormattingIconDataBarValue (type' address' worksheet' node' namespaceManager);  		}  		else if (pos == 2) {  			Icon2 = new ExcelConditionalFormattingIconDataBarValue (type' address' worksheet' node' namespaceManager);  		}  		else if (pos == 3) {  			Icon3 = new ExcelConditionalFormattingIconDataBarValue (type' address' worksheet' node' namespaceManager);  		}  		else {  			break;  		}  		pos++;  	}  }  else {  	var iconSetNode = CreateComplexNode (Node' ExcelConditionalFormattingConstants.Paths.IconSet);  	//Create the <iconSet> node inside the <cfRule> node  	double spann;  	if (type == eExcelConditionalFormattingRuleType.ThreeIconSet) {  		spann = 3;  	}  	else if (type == eExcelConditionalFormattingRuleType.FourIconSet) {  		spann = 4;  	}  	else {  		spann = 5;  	}  	var iconNode1 = iconSetNode.OwnerDocument.CreateElement (ExcelConditionalFormattingConstants.Paths.Cfvo' ExcelPackage.schemaMain);  	iconSetNode.AppendChild (iconNode1);  	Icon1 = new ExcelConditionalFormattingIconDataBarValue (eExcelConditionalFormattingValueObjectType.Percent' 0' ""' eExcelConditionalFormattingRuleType.ThreeIconSet' address' priority' worksheet' iconNode1' namespaceManager);  	var iconNode2 = iconSetNode.OwnerDocument.CreateElement (ExcelConditionalFormattingConstants.Paths.Cfvo' ExcelPackage.schemaMain);  	iconSetNode.AppendChild (iconNode2);  	Icon2 = new ExcelConditionalFormattingIconDataBarValue (eExcelConditionalFormattingValueObjectType.Percent' Math.Round (100D / spann' 0)' ""' eExcelConditionalFormattingRuleType.ThreeIconSet' address' priority' worksheet' iconNode2' namespaceManager);  	var iconNode3 = iconSetNode.OwnerDocument.CreateElement (ExcelConditionalFormattingConstants.Paths.Cfvo' ExcelPackage.schemaMain);  	iconSetNode.AppendChild (iconNode3);  	Icon3 = new ExcelConditionalFormattingIconDataBarValue (eExcelConditionalFormattingValueObjectType.Percent' Math.Round (100D * (2D / spann)' 0)' ""' eExcelConditionalFormattingRuleType.ThreeIconSet' address' priority' worksheet' iconNode3' namespaceManager);  	Type = type;  }  
Magic Number,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingIconSetBase,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\Rules\ExcelConditionalFormattingThreeIconSet.cs,ExcelConditionalFormattingIconSetBase,The following statement contains a magic number: if (itemElementNode != null && itemElementNode.HasChildNodes) {  	int pos = 1;  	foreach (XmlNode node in itemElementNode.SelectNodes ("d:iconSet/d:cfvo"' NameSpaceManager)) {  		if (pos == 1) {  			Icon1 = new ExcelConditionalFormattingIconDataBarValue (type' address' worksheet' node' namespaceManager);  		}  		else if (pos == 2) {  			Icon2 = new ExcelConditionalFormattingIconDataBarValue (type' address' worksheet' node' namespaceManager);  		}  		else if (pos == 3) {  			Icon3 = new ExcelConditionalFormattingIconDataBarValue (type' address' worksheet' node' namespaceManager);  		}  		else {  			break;  		}  		pos++;  	}  }  else {  	var iconSetNode = CreateComplexNode (Node' ExcelConditionalFormattingConstants.Paths.IconSet);  	//Create the <iconSet> node inside the <cfRule> node  	double spann;  	if (type == eExcelConditionalFormattingRuleType.ThreeIconSet) {  		spann = 3;  	}  	else if (type == eExcelConditionalFormattingRuleType.FourIconSet) {  		spann = 4;  	}  	else {  		spann = 5;  	}  	var iconNode1 = iconSetNode.OwnerDocument.CreateElement (ExcelConditionalFormattingConstants.Paths.Cfvo' ExcelPackage.schemaMain);  	iconSetNode.AppendChild (iconNode1);  	Icon1 = new ExcelConditionalFormattingIconDataBarValue (eExcelConditionalFormattingValueObjectType.Percent' 0' ""' eExcelConditionalFormattingRuleType.ThreeIconSet' address' priority' worksheet' iconNode1' namespaceManager);  	var iconNode2 = iconSetNode.OwnerDocument.CreateElement (ExcelConditionalFormattingConstants.Paths.Cfvo' ExcelPackage.schemaMain);  	iconSetNode.AppendChild (iconNode2);  	Icon2 = new ExcelConditionalFormattingIconDataBarValue (eExcelConditionalFormattingValueObjectType.Percent' Math.Round (100D / spann' 0)' ""' eExcelConditionalFormattingRuleType.ThreeIconSet' address' priority' worksheet' iconNode2' namespaceManager);  	var iconNode3 = iconSetNode.OwnerDocument.CreateElement (ExcelConditionalFormattingConstants.Paths.Cfvo' ExcelPackage.schemaMain);  	iconSetNode.AppendChild (iconNode3);  	Icon3 = new ExcelConditionalFormattingIconDataBarValue (eExcelConditionalFormattingValueObjectType.Percent' Math.Round (100D * (2D / spann)' 0)' ""' eExcelConditionalFormattingRuleType.ThreeIconSet' address' priority' worksheet' iconNode3' namespaceManager);  	Type = type;  }  
Magic Number,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingIconSetBase,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\Rules\ExcelConditionalFormattingThreeIconSet.cs,ExcelConditionalFormattingIconSetBase,The following statement contains a magic number: if (itemElementNode != null && itemElementNode.HasChildNodes) {  	int pos = 1;  	foreach (XmlNode node in itemElementNode.SelectNodes ("d:iconSet/d:cfvo"' NameSpaceManager)) {  		if (pos == 1) {  			Icon1 = new ExcelConditionalFormattingIconDataBarValue (type' address' worksheet' node' namespaceManager);  		}  		else if (pos == 2) {  			Icon2 = new ExcelConditionalFormattingIconDataBarValue (type' address' worksheet' node' namespaceManager);  		}  		else if (pos == 3) {  			Icon3 = new ExcelConditionalFormattingIconDataBarValue (type' address' worksheet' node' namespaceManager);  		}  		else {  			break;  		}  		pos++;  	}  }  else {  	var iconSetNode = CreateComplexNode (Node' ExcelConditionalFormattingConstants.Paths.IconSet);  	//Create the <iconSet> node inside the <cfRule> node  	double spann;  	if (type == eExcelConditionalFormattingRuleType.ThreeIconSet) {  		spann = 3;  	}  	else if (type == eExcelConditionalFormattingRuleType.FourIconSet) {  		spann = 4;  	}  	else {  		spann = 5;  	}  	var iconNode1 = iconSetNode.OwnerDocument.CreateElement (ExcelConditionalFormattingConstants.Paths.Cfvo' ExcelPackage.schemaMain);  	iconSetNode.AppendChild (iconNode1);  	Icon1 = new ExcelConditionalFormattingIconDataBarValue (eExcelConditionalFormattingValueObjectType.Percent' 0' ""' eExcelConditionalFormattingRuleType.ThreeIconSet' address' priority' worksheet' iconNode1' namespaceManager);  	var iconNode2 = iconSetNode.OwnerDocument.CreateElement (ExcelConditionalFormattingConstants.Paths.Cfvo' ExcelPackage.schemaMain);  	iconSetNode.AppendChild (iconNode2);  	Icon2 = new ExcelConditionalFormattingIconDataBarValue (eExcelConditionalFormattingValueObjectType.Percent' Math.Round (100D / spann' 0)' ""' eExcelConditionalFormattingRuleType.ThreeIconSet' address' priority' worksheet' iconNode2' namespaceManager);  	var iconNode3 = iconSetNode.OwnerDocument.CreateElement (ExcelConditionalFormattingConstants.Paths.Cfvo' ExcelPackage.schemaMain);  	iconSetNode.AppendChild (iconNode3);  	Icon3 = new ExcelConditionalFormattingIconDataBarValue (eExcelConditionalFormattingValueObjectType.Percent' Math.Round (100D * (2D / spann)' 0)' ""' eExcelConditionalFormattingRuleType.ThreeIconSet' address' priority' worksheet' iconNode3' namespaceManager);  	Type = type;  }  
Magic Number,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingIconSetBase,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\Rules\ExcelConditionalFormattingThreeIconSet.cs,ExcelConditionalFormattingIconSetBase,The following statement contains a magic number: if (itemElementNode != null && itemElementNode.HasChildNodes) {  	int pos = 1;  	foreach (XmlNode node in itemElementNode.SelectNodes ("d:iconSet/d:cfvo"' NameSpaceManager)) {  		if (pos == 1) {  			Icon1 = new ExcelConditionalFormattingIconDataBarValue (type' address' worksheet' node' namespaceManager);  		}  		else if (pos == 2) {  			Icon2 = new ExcelConditionalFormattingIconDataBarValue (type' address' worksheet' node' namespaceManager);  		}  		else if (pos == 3) {  			Icon3 = new ExcelConditionalFormattingIconDataBarValue (type' address' worksheet' node' namespaceManager);  		}  		else {  			break;  		}  		pos++;  	}  }  else {  	var iconSetNode = CreateComplexNode (Node' ExcelConditionalFormattingConstants.Paths.IconSet);  	//Create the <iconSet> node inside the <cfRule> node  	double spann;  	if (type == eExcelConditionalFormattingRuleType.ThreeIconSet) {  		spann = 3;  	}  	else if (type == eExcelConditionalFormattingRuleType.FourIconSet) {  		spann = 4;  	}  	else {  		spann = 5;  	}  	var iconNode1 = iconSetNode.OwnerDocument.CreateElement (ExcelConditionalFormattingConstants.Paths.Cfvo' ExcelPackage.schemaMain);  	iconSetNode.AppendChild (iconNode1);  	Icon1 = new ExcelConditionalFormattingIconDataBarValue (eExcelConditionalFormattingValueObjectType.Percent' 0' ""' eExcelConditionalFormattingRuleType.ThreeIconSet' address' priority' worksheet' iconNode1' namespaceManager);  	var iconNode2 = iconSetNode.OwnerDocument.CreateElement (ExcelConditionalFormattingConstants.Paths.Cfvo' ExcelPackage.schemaMain);  	iconSetNode.AppendChild (iconNode2);  	Icon2 = new ExcelConditionalFormattingIconDataBarValue (eExcelConditionalFormattingValueObjectType.Percent' Math.Round (100D / spann' 0)' ""' eExcelConditionalFormattingRuleType.ThreeIconSet' address' priority' worksheet' iconNode2' namespaceManager);  	var iconNode3 = iconSetNode.OwnerDocument.CreateElement (ExcelConditionalFormattingConstants.Paths.Cfvo' ExcelPackage.schemaMain);  	iconSetNode.AppendChild (iconNode3);  	Icon3 = new ExcelConditionalFormattingIconDataBarValue (eExcelConditionalFormattingValueObjectType.Percent' Math.Round (100D * (2D / spann)' 0)' ""' eExcelConditionalFormattingRuleType.ThreeIconSet' address' priority' worksheet' iconNode3' namespaceManager);  	Type = type;  }  
Magic Number,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingIconSetBase,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\Rules\ExcelConditionalFormattingThreeIconSet.cs,ExcelConditionalFormattingIconSetBase,The following statement contains a magic number: if (itemElementNode != null && itemElementNode.HasChildNodes) {  	int pos = 1;  	foreach (XmlNode node in itemElementNode.SelectNodes ("d:iconSet/d:cfvo"' NameSpaceManager)) {  		if (pos == 1) {  			Icon1 = new ExcelConditionalFormattingIconDataBarValue (type' address' worksheet' node' namespaceManager);  		}  		else if (pos == 2) {  			Icon2 = new ExcelConditionalFormattingIconDataBarValue (type' address' worksheet' node' namespaceManager);  		}  		else if (pos == 3) {  			Icon3 = new ExcelConditionalFormattingIconDataBarValue (type' address' worksheet' node' namespaceManager);  		}  		else {  			break;  		}  		pos++;  	}  }  else {  	var iconSetNode = CreateComplexNode (Node' ExcelConditionalFormattingConstants.Paths.IconSet);  	//Create the <iconSet> node inside the <cfRule> node  	double spann;  	if (type == eExcelConditionalFormattingRuleType.ThreeIconSet) {  		spann = 3;  	}  	else if (type == eExcelConditionalFormattingRuleType.FourIconSet) {  		spann = 4;  	}  	else {  		spann = 5;  	}  	var iconNode1 = iconSetNode.OwnerDocument.CreateElement (ExcelConditionalFormattingConstants.Paths.Cfvo' ExcelPackage.schemaMain);  	iconSetNode.AppendChild (iconNode1);  	Icon1 = new ExcelConditionalFormattingIconDataBarValue (eExcelConditionalFormattingValueObjectType.Percent' 0' ""' eExcelConditionalFormattingRuleType.ThreeIconSet' address' priority' worksheet' iconNode1' namespaceManager);  	var iconNode2 = iconSetNode.OwnerDocument.CreateElement (ExcelConditionalFormattingConstants.Paths.Cfvo' ExcelPackage.schemaMain);  	iconSetNode.AppendChild (iconNode2);  	Icon2 = new ExcelConditionalFormattingIconDataBarValue (eExcelConditionalFormattingValueObjectType.Percent' Math.Round (100D / spann' 0)' ""' eExcelConditionalFormattingRuleType.ThreeIconSet' address' priority' worksheet' iconNode2' namespaceManager);  	var iconNode3 = iconSetNode.OwnerDocument.CreateElement (ExcelConditionalFormattingConstants.Paths.Cfvo' ExcelPackage.schemaMain);  	iconSetNode.AppendChild (iconNode3);  	Icon3 = new ExcelConditionalFormattingIconDataBarValue (eExcelConditionalFormattingValueObjectType.Percent' Math.Round (100D * (2D / spann)' 0)' ""' eExcelConditionalFormattingRuleType.ThreeIconSet' address' priority' worksheet' iconNode3' namespaceManager);  	Type = type;  }  
Magic Number,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingIconSetBase,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\Rules\ExcelConditionalFormattingThreeIconSet.cs,ExcelConditionalFormattingIconSetBase,The following statement contains a magic number: foreach (XmlNode node in itemElementNode.SelectNodes ("d:iconSet/d:cfvo"' NameSpaceManager)) {  	if (pos == 1) {  		Icon1 = new ExcelConditionalFormattingIconDataBarValue (type' address' worksheet' node' namespaceManager);  	}  	else if (pos == 2) {  		Icon2 = new ExcelConditionalFormattingIconDataBarValue (type' address' worksheet' node' namespaceManager);  	}  	else if (pos == 3) {  		Icon3 = new ExcelConditionalFormattingIconDataBarValue (type' address' worksheet' node' namespaceManager);  	}  	else {  		break;  	}  	pos++;  }  
Magic Number,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingIconSetBase,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\Rules\ExcelConditionalFormattingThreeIconSet.cs,ExcelConditionalFormattingIconSetBase,The following statement contains a magic number: foreach (XmlNode node in itemElementNode.SelectNodes ("d:iconSet/d:cfvo"' NameSpaceManager)) {  	if (pos == 1) {  		Icon1 = new ExcelConditionalFormattingIconDataBarValue (type' address' worksheet' node' namespaceManager);  	}  	else if (pos == 2) {  		Icon2 = new ExcelConditionalFormattingIconDataBarValue (type' address' worksheet' node' namespaceManager);  	}  	else if (pos == 3) {  		Icon3 = new ExcelConditionalFormattingIconDataBarValue (type' address' worksheet' node' namespaceManager);  	}  	else {  		break;  	}  	pos++;  }  
Magic Number,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingIconSetBase,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\Rules\ExcelConditionalFormattingThreeIconSet.cs,ExcelConditionalFormattingIconSetBase,The following statement contains a magic number: if (pos == 1) {  	Icon1 = new ExcelConditionalFormattingIconDataBarValue (type' address' worksheet' node' namespaceManager);  }  else if (pos == 2) {  	Icon2 = new ExcelConditionalFormattingIconDataBarValue (type' address' worksheet' node' namespaceManager);  }  else if (pos == 3) {  	Icon3 = new ExcelConditionalFormattingIconDataBarValue (type' address' worksheet' node' namespaceManager);  }  else {  	break;  }  
Magic Number,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingIconSetBase,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\Rules\ExcelConditionalFormattingThreeIconSet.cs,ExcelConditionalFormattingIconSetBase,The following statement contains a magic number: if (pos == 1) {  	Icon1 = new ExcelConditionalFormattingIconDataBarValue (type' address' worksheet' node' namespaceManager);  }  else if (pos == 2) {  	Icon2 = new ExcelConditionalFormattingIconDataBarValue (type' address' worksheet' node' namespaceManager);  }  else if (pos == 3) {  	Icon3 = new ExcelConditionalFormattingIconDataBarValue (type' address' worksheet' node' namespaceManager);  }  else {  	break;  }  
Magic Number,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingIconSetBase,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\Rules\ExcelConditionalFormattingThreeIconSet.cs,ExcelConditionalFormattingIconSetBase,The following statement contains a magic number: if (pos == 2) {  	Icon2 = new ExcelConditionalFormattingIconDataBarValue (type' address' worksheet' node' namespaceManager);  }  else if (pos == 3) {  	Icon3 = new ExcelConditionalFormattingIconDataBarValue (type' address' worksheet' node' namespaceManager);  }  else {  	break;  }  
Magic Number,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingIconSetBase,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\Rules\ExcelConditionalFormattingThreeIconSet.cs,ExcelConditionalFormattingIconSetBase,The following statement contains a magic number: if (pos == 2) {  	Icon2 = new ExcelConditionalFormattingIconDataBarValue (type' address' worksheet' node' namespaceManager);  }  else if (pos == 3) {  	Icon3 = new ExcelConditionalFormattingIconDataBarValue (type' address' worksheet' node' namespaceManager);  }  else {  	break;  }  
Magic Number,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingIconSetBase,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\Rules\ExcelConditionalFormattingThreeIconSet.cs,ExcelConditionalFormattingIconSetBase,The following statement contains a magic number: if (pos == 3) {  	Icon3 = new ExcelConditionalFormattingIconDataBarValue (type' address' worksheet' node' namespaceManager);  }  else {  	break;  }  
Magic Number,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingIconSetBase,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\Rules\ExcelConditionalFormattingThreeIconSet.cs,ExcelConditionalFormattingIconSetBase,The following statement contains a magic number: if (type == eExcelConditionalFormattingRuleType.ThreeIconSet) {  	spann = 3;  }  else if (type == eExcelConditionalFormattingRuleType.FourIconSet) {  	spann = 4;  }  else {  	spann = 5;  }  
Magic Number,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingIconSetBase,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\Rules\ExcelConditionalFormattingThreeIconSet.cs,ExcelConditionalFormattingIconSetBase,The following statement contains a magic number: if (type == eExcelConditionalFormattingRuleType.ThreeIconSet) {  	spann = 3;  }  else if (type == eExcelConditionalFormattingRuleType.FourIconSet) {  	spann = 4;  }  else {  	spann = 5;  }  
Magic Number,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingIconSetBase,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\Rules\ExcelConditionalFormattingThreeIconSet.cs,ExcelConditionalFormattingIconSetBase,The following statement contains a magic number: if (type == eExcelConditionalFormattingRuleType.ThreeIconSet) {  	spann = 3;  }  else if (type == eExcelConditionalFormattingRuleType.FourIconSet) {  	spann = 4;  }  else {  	spann = 5;  }  
Magic Number,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingIconSetBase,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\Rules\ExcelConditionalFormattingThreeIconSet.cs,ExcelConditionalFormattingIconSetBase,The following statement contains a magic number: spann = 3;  
Magic Number,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingIconSetBase,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\Rules\ExcelConditionalFormattingThreeIconSet.cs,ExcelConditionalFormattingIconSetBase,The following statement contains a magic number: if (type == eExcelConditionalFormattingRuleType.FourIconSet) {  	spann = 4;  }  else {  	spann = 5;  }  
Magic Number,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingIconSetBase,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\Rules\ExcelConditionalFormattingThreeIconSet.cs,ExcelConditionalFormattingIconSetBase,The following statement contains a magic number: if (type == eExcelConditionalFormattingRuleType.FourIconSet) {  	spann = 4;  }  else {  	spann = 5;  }  
Magic Number,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingIconSetBase,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\Rules\ExcelConditionalFormattingThreeIconSet.cs,ExcelConditionalFormattingIconSetBase,The following statement contains a magic number: spann = 4;  
Magic Number,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingIconSetBase,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\Rules\ExcelConditionalFormattingThreeIconSet.cs,ExcelConditionalFormattingIconSetBase,The following statement contains a magic number: spann = 5;  
Magic Number,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingTop,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\Rules\ExcelConditionalFormattingTop.cs,ExcelConditionalFormattingTop,The following statement contains a magic number: if (itemElementNode == null)//Set default values and create attributes if needed   {  	Bottom = false;  	Percent = false;  	Rank = 10;  	// First 10 values  }  
Magic Number,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingTop,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\Rules\ExcelConditionalFormattingTop.cs,ExcelConditionalFormattingTop,The following statement contains a magic number: Rank = 10;  
Magic Number,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingTopPercent,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\Rules\ExcelConditionalFormattingTopPercent.cs,ExcelConditionalFormattingTopPercent,The following statement contains a magic number: if (itemElementNode == null)//Set default values and create attributes if needed   {  	Bottom = false;  	Percent = true;  	Rank = 10;  	// First 10 percent  }  
Magic Number,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingTopPercent,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\Rules\ExcelConditionalFormattingTopPercent.cs,ExcelConditionalFormattingTopPercent,The following statement contains a magic number: Rank = 10;  
Magic Number,OfficeOpenXml.DataValidation,ExcelTime,C:\repos\bambit_EPPlus\EPPlus\DataValidation\ExcelTime.cs,SetSecond,The following statement contains a magic number: if (value == 60) {  	Second = 0;  	var minute = Minute + 1;  	SetMinute (minute);  }  else {  	Second = value;  }  
Magic Number,OfficeOpenXml.DataValidation,ExcelTime,C:\repos\bambit_EPPlus\EPPlus\DataValidation\ExcelTime.cs,SetMinute,The following statement contains a magic number: if (value == 60) {  	Minute = 0;  	var hour = Hour + 1;  	SetHour (hour);  }  else {  	Minute = value;  }  
Magic Number,OfficeOpenXml.DataValidation,ExcelTime,C:\repos\bambit_EPPlus\EPPlus\DataValidation\ExcelTime.cs,SetHour,The following statement contains a magic number: if (value == 24) {  	Hour = 0;  }  
Magic Number,OfficeOpenXml.DataValidation,ExcelTime,C:\repos\bambit_EPPlus\EPPlus\DataValidation\ExcelTime.cs,ToString,The following statement contains a magic number: return string.Format ("{0}:{1}:{2}"' Hour < 10 ? "0" + Hour.ToString () : Hour.ToString ()' Minute < 10 ? "0" + Minute.ToString () : Minute.ToString ()' second < 10 ? "0" + second.ToString () : second.ToString ());  
Magic Number,OfficeOpenXml.DataValidation,ExcelTime,C:\repos\bambit_EPPlus\EPPlus\DataValidation\ExcelTime.cs,ToString,The following statement contains a magic number: return string.Format ("{0}:{1}:{2}"' Hour < 10 ? "0" + Hour.ToString () : Hour.ToString ()' Minute < 10 ? "0" + Minute.ToString () : Minute.ToString ()' second < 10 ? "0" + second.ToString () : second.ToString ());  
Magic Number,OfficeOpenXml.DataValidation,ExcelTime,C:\repos\bambit_EPPlus\EPPlus\DataValidation\ExcelTime.cs,ToString,The following statement contains a magic number: return string.Format ("{0}:{1}:{2}"' Hour < 10 ? "0" + Hour.ToString () : Hour.ToString ()' Minute < 10 ? "0" + Minute.ToString () : Minute.ToString ()' second < 10 ? "0" + second.ToString () : second.ToString ());  
Magic Number,OfficeOpenXml.Drawing.Chart,ExcelChart,C:\repos\bambit_EPPlus\EPPlus\Drawing\Chart\ExcelChart.cs,SetTypeProperties,The following statement contains a magic number: if (IsType3D ()) {  	View3D.RotY = 20;  	View3D.Perspective = 30;  	//Default to 30  	if (IsTypePieDoughnut ()) {  		View3D.RotX = 30;  	}  	else {  		View3D.RotX = 15;  	}  }  
Magic Number,OfficeOpenXml.Drawing.Chart,ExcelChart,C:\repos\bambit_EPPlus\EPPlus\Drawing\Chart\ExcelChart.cs,SetTypeProperties,The following statement contains a magic number: if (IsType3D ()) {  	View3D.RotY = 20;  	View3D.Perspective = 30;  	//Default to 30  	if (IsTypePieDoughnut ()) {  		View3D.RotX = 30;  	}  	else {  		View3D.RotX = 15;  	}  }  
Magic Number,OfficeOpenXml.Drawing.Chart,ExcelChart,C:\repos\bambit_EPPlus\EPPlus\Drawing\Chart\ExcelChart.cs,SetTypeProperties,The following statement contains a magic number: if (IsType3D ()) {  	View3D.RotY = 20;  	View3D.Perspective = 30;  	//Default to 30  	if (IsTypePieDoughnut ()) {  		View3D.RotX = 30;  	}  	else {  		View3D.RotX = 15;  	}  }  
Magic Number,OfficeOpenXml.Drawing.Chart,ExcelChart,C:\repos\bambit_EPPlus\EPPlus\Drawing\Chart\ExcelChart.cs,SetTypeProperties,The following statement contains a magic number: if (IsType3D ()) {  	View3D.RotY = 20;  	View3D.Perspective = 30;  	//Default to 30  	if (IsTypePieDoughnut ()) {  		View3D.RotX = 30;  	}  	else {  		View3D.RotX = 15;  	}  }  
Magic Number,OfficeOpenXml.Drawing.Chart,ExcelChart,C:\repos\bambit_EPPlus\EPPlus\Drawing\Chart\ExcelChart.cs,SetTypeProperties,The following statement contains a magic number: View3D.RotY = 20;  
Magic Number,OfficeOpenXml.Drawing.Chart,ExcelChart,C:\repos\bambit_EPPlus\EPPlus\Drawing\Chart\ExcelChart.cs,SetTypeProperties,The following statement contains a magic number: View3D.Perspective = 30;  
Magic Number,OfficeOpenXml.Drawing.Chart,ExcelChart,C:\repos\bambit_EPPlus\EPPlus\Drawing\Chart\ExcelChart.cs,SetTypeProperties,The following statement contains a magic number: if (IsTypePieDoughnut ()) {  	View3D.RotX = 30;  }  else {  	View3D.RotX = 15;  }  
Magic Number,OfficeOpenXml.Drawing.Chart,ExcelChart,C:\repos\bambit_EPPlus\EPPlus\Drawing\Chart\ExcelChart.cs,SetTypeProperties,The following statement contains a magic number: if (IsTypePieDoughnut ()) {  	View3D.RotX = 30;  }  else {  	View3D.RotX = 15;  }  
Magic Number,OfficeOpenXml.Drawing.Chart,ExcelChart,C:\repos\bambit_EPPlus\EPPlus\Drawing\Chart\ExcelChart.cs,SetTypeProperties,The following statement contains a magic number: View3D.RotX = 30;  
Magic Number,OfficeOpenXml.Drawing.Chart,ExcelChart,C:\repos\bambit_EPPlus\EPPlus\Drawing\Chart\ExcelChart.cs,SetTypeProperties,The following statement contains a magic number: View3D.RotX = 15;  
Magic Number,OfficeOpenXml.Drawing.Chart,ExcelChart,C:\repos\bambit_EPPlus\EPPlus\Drawing\Chart\ExcelChart.cs,AddAxis,The following statement contains a magic number: if (_axis.Length == 0) {  	_axis = new ExcelChartAxis[2];  }  else {  	ExcelChartAxis[] newAxis = new ExcelChartAxis[_axis.Length + 2];  	Array.Copy (_axis' newAxis' _axis.Length);  	_axis = newAxis;  }  
Magic Number,OfficeOpenXml.Drawing.Chart,ExcelChart,C:\repos\bambit_EPPlus\EPPlus\Drawing\Chart\ExcelChart.cs,AddAxis,The following statement contains a magic number: if (_axis.Length == 0) {  	_axis = new ExcelChartAxis[2];  }  else {  	ExcelChartAxis[] newAxis = new ExcelChartAxis[_axis.Length + 2];  	Array.Copy (_axis' newAxis' _axis.Length);  	_axis = newAxis;  }  
Magic Number,OfficeOpenXml.Drawing.Chart,ExcelChart,C:\repos\bambit_EPPlus\EPPlus\Drawing\Chart\ExcelChart.cs,AddAxis,The following statement contains a magic number: _axis = new ExcelChartAxis[2];  
Magic Number,OfficeOpenXml.Drawing.Chart,ExcelChart,C:\repos\bambit_EPPlus\EPPlus\Drawing\Chart\ExcelChart.cs,AddAxis,The following statement contains a magic number: _axis [_axis.Length - 2] = new ExcelChartAxis (NameSpaceManager' catAx);  
Magic Number,OfficeOpenXml.Drawing,ExcelDrawing,C:\repos\bambit_EPPlus\EPPlus\Drawing\ExcelDrawingBase.cs,GetPixelLeft,The following statement contains a magic number: for (int col = 0; col < From.Column; col++) {  	pix += (int)decimal.Truncate (((256 * GetColumnWidth (col + 1) + decimal.Truncate (128 / (decimal)mdw)) / 256) * mdw);  }  
Magic Number,OfficeOpenXml.Drawing,ExcelDrawing,C:\repos\bambit_EPPlus\EPPlus\Drawing\ExcelDrawingBase.cs,GetPixelLeft,The following statement contains a magic number: for (int col = 0; col < From.Column; col++) {  	pix += (int)decimal.Truncate (((256 * GetColumnWidth (col + 1) + decimal.Truncate (128 / (decimal)mdw)) / 256) * mdw);  }  
Magic Number,OfficeOpenXml.Drawing,ExcelDrawing,C:\repos\bambit_EPPlus\EPPlus\Drawing\ExcelDrawingBase.cs,GetPixelLeft,The following statement contains a magic number: for (int col = 0; col < From.Column; col++) {  	pix += (int)decimal.Truncate (((256 * GetColumnWidth (col + 1) + decimal.Truncate (128 / (decimal)mdw)) / 256) * mdw);  }  
Magic Number,OfficeOpenXml.Drawing,ExcelDrawing,C:\repos\bambit_EPPlus\EPPlus\Drawing\ExcelDrawingBase.cs,GetPixelLeft,The following statement contains a magic number: pix += (int)decimal.Truncate (((256 * GetColumnWidth (col + 1) + decimal.Truncate (128 / (decimal)mdw)) / 256) * mdw);  
Magic Number,OfficeOpenXml.Drawing,ExcelDrawing,C:\repos\bambit_EPPlus\EPPlus\Drawing\ExcelDrawingBase.cs,GetPixelLeft,The following statement contains a magic number: pix += (int)decimal.Truncate (((256 * GetColumnWidth (col + 1) + decimal.Truncate (128 / (decimal)mdw)) / 256) * mdw);  
Magic Number,OfficeOpenXml.Drawing,ExcelDrawing,C:\repos\bambit_EPPlus\EPPlus\Drawing\ExcelDrawingBase.cs,GetPixelLeft,The following statement contains a magic number: pix += (int)decimal.Truncate (((256 * GetColumnWidth (col + 1) + decimal.Truncate (128 / (decimal)mdw)) / 256) * mdw);  
Magic Number,OfficeOpenXml.Drawing,ExcelDrawing,C:\repos\bambit_EPPlus\EPPlus\Drawing\ExcelDrawingBase.cs,GetPixelTop,The following statement contains a magic number: for (int row = 0; row < From.Row; row++) {  	pix += (int)(GetRowWidth (row + 1) / 0.75);  }  
Magic Number,OfficeOpenXml.Drawing,ExcelDrawing,C:\repos\bambit_EPPlus\EPPlus\Drawing\ExcelDrawingBase.cs,GetPixelTop,The following statement contains a magic number: pix += (int)(GetRowWidth (row + 1) / 0.75);  
Magic Number,OfficeOpenXml.Drawing,ExcelDrawing,C:\repos\bambit_EPPlus\EPPlus\Drawing\ExcelDrawingBase.cs,GetPixelWidth,The following statement contains a magic number: for (int col = From.Column + 1; col <= To.Column; col++) {  	pix += (int)decimal.Truncate (((256 * GetColumnWidth (col) + decimal.Truncate (128 / (decimal)mdw)) / 256) * mdw);  }  
Magic Number,OfficeOpenXml.Drawing,ExcelDrawing,C:\repos\bambit_EPPlus\EPPlus\Drawing\ExcelDrawingBase.cs,GetPixelWidth,The following statement contains a magic number: for (int col = From.Column + 1; col <= To.Column; col++) {  	pix += (int)decimal.Truncate (((256 * GetColumnWidth (col) + decimal.Truncate (128 / (decimal)mdw)) / 256) * mdw);  }  
Magic Number,OfficeOpenXml.Drawing,ExcelDrawing,C:\repos\bambit_EPPlus\EPPlus\Drawing\ExcelDrawingBase.cs,GetPixelWidth,The following statement contains a magic number: for (int col = From.Column + 1; col <= To.Column; col++) {  	pix += (int)decimal.Truncate (((256 * GetColumnWidth (col) + decimal.Truncate (128 / (decimal)mdw)) / 256) * mdw);  }  
Magic Number,OfficeOpenXml.Drawing,ExcelDrawing,C:\repos\bambit_EPPlus\EPPlus\Drawing\ExcelDrawingBase.cs,GetPixelWidth,The following statement contains a magic number: pix += (int)decimal.Truncate (((256 * GetColumnWidth (col) + decimal.Truncate (128 / (decimal)mdw)) / 256) * mdw);  
Magic Number,OfficeOpenXml.Drawing,ExcelDrawing,C:\repos\bambit_EPPlus\EPPlus\Drawing\ExcelDrawingBase.cs,GetPixelWidth,The following statement contains a magic number: pix += (int)decimal.Truncate (((256 * GetColumnWidth (col) + decimal.Truncate (128 / (decimal)mdw)) / 256) * mdw);  
Magic Number,OfficeOpenXml.Drawing,ExcelDrawing,C:\repos\bambit_EPPlus\EPPlus\Drawing\ExcelDrawingBase.cs,GetPixelWidth,The following statement contains a magic number: pix += (int)decimal.Truncate (((256 * GetColumnWidth (col) + decimal.Truncate (128 / (decimal)mdw)) / 256) * mdw);  
Magic Number,OfficeOpenXml.Drawing,ExcelDrawing,C:\repos\bambit_EPPlus\EPPlus\Drawing\ExcelDrawingBase.cs,GetPixelHeight,The following statement contains a magic number: for (int row = From.Row + 1; row <= To.Row; row++) {  	pix += (int)(GetRowWidth (row) / 0.75);  }  
Magic Number,OfficeOpenXml.Drawing,ExcelDrawing,C:\repos\bambit_EPPlus\EPPlus\Drawing\ExcelDrawingBase.cs,GetPixelHeight,The following statement contains a magic number: pix += (int)(GetRowWidth (row) / 0.75);  
Magic Number,OfficeOpenXml.Drawing,ExcelDrawing,C:\repos\bambit_EPPlus\EPPlus\Drawing\ExcelDrawingBase.cs,SetPixelTop,The following statement contains a magic number: while (pix < pixels) {  	prevPix = pix;  	pix += (int)(GetRowWidth (row++) / 0.75);  }  
Magic Number,OfficeOpenXml.Drawing,ExcelDrawing,C:\repos\bambit_EPPlus\EPPlus\Drawing\ExcelDrawingBase.cs,SetPixelTop,The following statement contains a magic number: pix += (int)(GetRowWidth (row++) / 0.75);  
Magic Number,OfficeOpenXml.Drawing,ExcelDrawing,C:\repos\bambit_EPPlus\EPPlus\Drawing\ExcelDrawingBase.cs,SetPixelTop,The following statement contains a magic number: if (pix == pixels) {  	From.Row = row - 1;  	From.RowOff = 0;  }  else {  	From.Row = row - 2;  	From.RowOff = (pixels - prevPix) * EMU_PER_PIXEL;  }  
Magic Number,OfficeOpenXml.Drawing,ExcelDrawing,C:\repos\bambit_EPPlus\EPPlus\Drawing\ExcelDrawingBase.cs,SetPixelTop,The following statement contains a magic number: From.Row = row - 2;  
Magic Number,OfficeOpenXml.Drawing,ExcelDrawing,C:\repos\bambit_EPPlus\EPPlus\Drawing\ExcelDrawingBase.cs,SetPixelLeft,The following statement contains a magic number: while (pix < pixels) {  	prevPix = pix;  	pix += (int)decimal.Truncate (((256 * GetColumnWidth (col++) + decimal.Truncate (128 / (decimal)mdw)) / 256) * mdw);  }  
Magic Number,OfficeOpenXml.Drawing,ExcelDrawing,C:\repos\bambit_EPPlus\EPPlus\Drawing\ExcelDrawingBase.cs,SetPixelLeft,The following statement contains a magic number: while (pix < pixels) {  	prevPix = pix;  	pix += (int)decimal.Truncate (((256 * GetColumnWidth (col++) + decimal.Truncate (128 / (decimal)mdw)) / 256) * mdw);  }  
Magic Number,OfficeOpenXml.Drawing,ExcelDrawing,C:\repos\bambit_EPPlus\EPPlus\Drawing\ExcelDrawingBase.cs,SetPixelLeft,The following statement contains a magic number: while (pix < pixels) {  	prevPix = pix;  	pix += (int)decimal.Truncate (((256 * GetColumnWidth (col++) + decimal.Truncate (128 / (decimal)mdw)) / 256) * mdw);  }  
Magic Number,OfficeOpenXml.Drawing,ExcelDrawing,C:\repos\bambit_EPPlus\EPPlus\Drawing\ExcelDrawingBase.cs,SetPixelLeft,The following statement contains a magic number: pix += (int)decimal.Truncate (((256 * GetColumnWidth (col++) + decimal.Truncate (128 / (decimal)mdw)) / 256) * mdw);  
Magic Number,OfficeOpenXml.Drawing,ExcelDrawing,C:\repos\bambit_EPPlus\EPPlus\Drawing\ExcelDrawingBase.cs,SetPixelLeft,The following statement contains a magic number: pix += (int)decimal.Truncate (((256 * GetColumnWidth (col++) + decimal.Truncate (128 / (decimal)mdw)) / 256) * mdw);  
Magic Number,OfficeOpenXml.Drawing,ExcelDrawing,C:\repos\bambit_EPPlus\EPPlus\Drawing\ExcelDrawingBase.cs,SetPixelLeft,The following statement contains a magic number: pix += (int)decimal.Truncate (((256 * GetColumnWidth (col++) + decimal.Truncate (128 / (decimal)mdw)) / 256) * mdw);  
Magic Number,OfficeOpenXml.Drawing,ExcelDrawing,C:\repos\bambit_EPPlus\EPPlus\Drawing\ExcelDrawingBase.cs,SetPixelLeft,The following statement contains a magic number: if (pix == pixels) {  	From.Column = col - 1;  	From.ColumnOff = 0;  }  else {  	From.Column = col - 2;  	From.ColumnOff = (pixels - prevPix) * EMU_PER_PIXEL;  }  
Magic Number,OfficeOpenXml.Drawing,ExcelDrawing,C:\repos\bambit_EPPlus\EPPlus\Drawing\ExcelDrawingBase.cs,SetPixelLeft,The following statement contains a magic number: From.Column = col - 2;  
Magic Number,OfficeOpenXml.Drawing,ExcelDrawing,C:\repos\bambit_EPPlus\EPPlus\Drawing\ExcelDrawingBase.cs,SetPixelHeight,The following statement contains a magic number: pixels = (int)(pixels / (dpi / STANDARD_DPI) + .5);  
Magic Number,OfficeOpenXml.Drawing,ExcelDrawing,C:\repos\bambit_EPPlus\EPPlus\Drawing\ExcelDrawingBase.cs,SetPixelHeight,The following statement contains a magic number: while (pixOff >= 0) {  	prevPixOff = pixOff;  	pixOff -= (int)(GetRowWidth (++row) / 0.75);  }  
Magic Number,OfficeOpenXml.Drawing,ExcelDrawing,C:\repos\bambit_EPPlus\EPPlus\Drawing\ExcelDrawingBase.cs,SetPixelHeight,The following statement contains a magic number: pixOff -= (int)(GetRowWidth (++row) / 0.75);  
Magic Number,OfficeOpenXml.Drawing,ExcelDrawing,C:\repos\bambit_EPPlus\EPPlus\Drawing\ExcelDrawingBase.cs,SetPixelWidth,The following statement contains a magic number: pixels = (int)(pixels / (dpi / STANDARD_DPI) + .5);  
Magic Number,OfficeOpenXml.Drawing,ExcelDrawing,C:\repos\bambit_EPPlus\EPPlus\Drawing\ExcelDrawingBase.cs,SetPixelWidth,The following statement contains a magic number: while (pixOff >= 0) {  	prevPixOff = pixOff;  	pixOff -= (int)decimal.Truncate (((256 * GetColumnWidth (col++) + decimal.Truncate (128 / (decimal)mdw)) / 256) * mdw);  }  
Magic Number,OfficeOpenXml.Drawing,ExcelDrawing,C:\repos\bambit_EPPlus\EPPlus\Drawing\ExcelDrawingBase.cs,SetPixelWidth,The following statement contains a magic number: while (pixOff >= 0) {  	prevPixOff = pixOff;  	pixOff -= (int)decimal.Truncate (((256 * GetColumnWidth (col++) + decimal.Truncate (128 / (decimal)mdw)) / 256) * mdw);  }  
Magic Number,OfficeOpenXml.Drawing,ExcelDrawing,C:\repos\bambit_EPPlus\EPPlus\Drawing\ExcelDrawingBase.cs,SetPixelWidth,The following statement contains a magic number: while (pixOff >= 0) {  	prevPixOff = pixOff;  	pixOff -= (int)decimal.Truncate (((256 * GetColumnWidth (col++) + decimal.Truncate (128 / (decimal)mdw)) / 256) * mdw);  }  
Magic Number,OfficeOpenXml.Drawing,ExcelDrawing,C:\repos\bambit_EPPlus\EPPlus\Drawing\ExcelDrawingBase.cs,SetPixelWidth,The following statement contains a magic number: pixOff -= (int)decimal.Truncate (((256 * GetColumnWidth (col++) + decimal.Truncate (128 / (decimal)mdw)) / 256) * mdw);  
Magic Number,OfficeOpenXml.Drawing,ExcelDrawing,C:\repos\bambit_EPPlus\EPPlus\Drawing\ExcelDrawingBase.cs,SetPixelWidth,The following statement contains a magic number: pixOff -= (int)decimal.Truncate (((256 * GetColumnWidth (col++) + decimal.Truncate (128 / (decimal)mdw)) / 256) * mdw);  
Magic Number,OfficeOpenXml.Drawing,ExcelDrawing,C:\repos\bambit_EPPlus\EPPlus\Drawing\ExcelDrawingBase.cs,SetPixelWidth,The following statement contains a magic number: pixOff -= (int)decimal.Truncate (((256 * GetColumnWidth (col++) + decimal.Truncate (128 / (decimal)mdw)) / 256) * mdw);  
Magic Number,OfficeOpenXml.Drawing,ExcelDrawing,C:\repos\bambit_EPPlus\EPPlus\Drawing\ExcelDrawingBase.cs,SetPixelWidth,The following statement contains a magic number: To.Column = col - 2;  
Magic Number,OfficeOpenXml.Drawing,ExcelDrawing,C:\repos\bambit_EPPlus\EPPlus\Drawing\ExcelDrawingBase.cs,SetSize,The following statement contains a magic number: width = (int)(width * ((decimal)Percent / 100));  
Magic Number,OfficeOpenXml.Drawing,ExcelDrawing,C:\repos\bambit_EPPlus\EPPlus\Drawing\ExcelDrawingBase.cs,SetSize,The following statement contains a magic number: height = (int)(height * ((decimal)Percent / 100));  
Magic Number,OfficeOpenXml.Drawing,ExcelDrawing,C:\repos\bambit_EPPlus\EPPlus\Drawing\ExcelDrawingBase.cs,SetSize,The following statement contains a magic number: SetPixelWidth (width' 96);  
Magic Number,OfficeOpenXml.Drawing,ExcelDrawing,C:\repos\bambit_EPPlus\EPPlus\Drawing\ExcelDrawingBase.cs,SetSize,The following statement contains a magic number: SetPixelHeight (height' 96);  
Magic Number,OfficeOpenXml.Drawing,ExcelPicture,C:\repos\bambit_EPPlus\EPPlus\Drawing\ExcelPicture.cs,SetSize,The following statement contains a magic number: if (Image == null) {  	base.SetSize (Percent);  }  else {  	int width = Image.Width;  	int height = Image.Height;  	width = (int)(width * ((decimal)Percent / 100));  	height = (int)(height * ((decimal)Percent / 100));  	SetPixelWidth (width' Image.HorizontalResolution);  	SetPixelHeight (height' Image.VerticalResolution);  }  
Magic Number,OfficeOpenXml.Drawing,ExcelPicture,C:\repos\bambit_EPPlus\EPPlus\Drawing\ExcelPicture.cs,SetSize,The following statement contains a magic number: if (Image == null) {  	base.SetSize (Percent);  }  else {  	int width = Image.Width;  	int height = Image.Height;  	width = (int)(width * ((decimal)Percent / 100));  	height = (int)(height * ((decimal)Percent / 100));  	SetPixelWidth (width' Image.HorizontalResolution);  	SetPixelHeight (height' Image.VerticalResolution);  }  
Magic Number,OfficeOpenXml.Drawing,ExcelPicture,C:\repos\bambit_EPPlus\EPPlus\Drawing\ExcelPicture.cs,SetSize,The following statement contains a magic number: width = (int)(width * ((decimal)Percent / 100));  
Magic Number,OfficeOpenXml.Drawing,ExcelPicture,C:\repos\bambit_EPPlus\EPPlus\Drawing\ExcelPicture.cs,SetSize,The following statement contains a magic number: height = (int)(height * ((decimal)Percent / 100));  
Magic Number,OfficeOpenXml.Drawing,ExcelDrawingBorder,C:\repos\bambit_EPPlus\EPPlus\Drawing\ExcelDrawingBorder.cs,TranslateLineStyleText,The following statement contains a magic number: switch (value) {  case eLineStyle.Dash:  case eLineStyle.Dot:  case eLineStyle.DashDot:  case eLineStyle.Solid:  	return text.Substring (0' 1).ToLower () + text.Substring (1' text.Length - 1);  //First to Lower case.  case eLineStyle.LongDash:  case eLineStyle.LongDashDot:  case eLineStyle.LongDashDotDot:  	return "lg" + text.Substring (4' text.Length - 4);  case eLineStyle.SystemDash:  case eLineStyle.SystemDashDot:  case eLineStyle.SystemDashDotDot:  case eLineStyle.SystemDot:  	return "sys" + text.Substring (6' text.Length - 6);  default:  	throw (new Exception ("Invalid Linestyle"));  }  
Magic Number,OfficeOpenXml.Drawing,ExcelDrawingBorder,C:\repos\bambit_EPPlus\EPPlus\Drawing\ExcelDrawingBorder.cs,TranslateLineStyleText,The following statement contains a magic number: switch (value) {  case eLineStyle.Dash:  case eLineStyle.Dot:  case eLineStyle.DashDot:  case eLineStyle.Solid:  	return text.Substring (0' 1).ToLower () + text.Substring (1' text.Length - 1);  //First to Lower case.  case eLineStyle.LongDash:  case eLineStyle.LongDashDot:  case eLineStyle.LongDashDotDot:  	return "lg" + text.Substring (4' text.Length - 4);  case eLineStyle.SystemDash:  case eLineStyle.SystemDashDot:  case eLineStyle.SystemDashDotDot:  case eLineStyle.SystemDot:  	return "sys" + text.Substring (6' text.Length - 6);  default:  	throw (new Exception ("Invalid Linestyle"));  }  
Magic Number,OfficeOpenXml.Drawing,ExcelDrawingBorder,C:\repos\bambit_EPPlus\EPPlus\Drawing\ExcelDrawingBorder.cs,TranslateLineStyleText,The following statement contains a magic number: switch (value) {  case eLineStyle.Dash:  case eLineStyle.Dot:  case eLineStyle.DashDot:  case eLineStyle.Solid:  	return text.Substring (0' 1).ToLower () + text.Substring (1' text.Length - 1);  //First to Lower case.  case eLineStyle.LongDash:  case eLineStyle.LongDashDot:  case eLineStyle.LongDashDotDot:  	return "lg" + text.Substring (4' text.Length - 4);  case eLineStyle.SystemDash:  case eLineStyle.SystemDashDot:  case eLineStyle.SystemDashDotDot:  case eLineStyle.SystemDot:  	return "sys" + text.Substring (6' text.Length - 6);  default:  	throw (new Exception ("Invalid Linestyle"));  }  
Magic Number,OfficeOpenXml.Drawing,ExcelDrawingBorder,C:\repos\bambit_EPPlus\EPPlus\Drawing\ExcelDrawingBorder.cs,TranslateLineStyleText,The following statement contains a magic number: switch (value) {  case eLineStyle.Dash:  case eLineStyle.Dot:  case eLineStyle.DashDot:  case eLineStyle.Solid:  	return text.Substring (0' 1).ToLower () + text.Substring (1' text.Length - 1);  //First to Lower case.  case eLineStyle.LongDash:  case eLineStyle.LongDashDot:  case eLineStyle.LongDashDotDot:  	return "lg" + text.Substring (4' text.Length - 4);  case eLineStyle.SystemDash:  case eLineStyle.SystemDashDot:  case eLineStyle.SystemDashDotDot:  case eLineStyle.SystemDot:  	return "sys" + text.Substring (6' text.Length - 6);  default:  	throw (new Exception ("Invalid Linestyle"));  }  
Magic Number,OfficeOpenXml.Drawing,ExcelDrawingBorder,C:\repos\bambit_EPPlus\EPPlus\Drawing\ExcelDrawingBorder.cs,TranslateLineStyleText,The following statement contains a magic number: return "lg" + text.Substring (4' text.Length - 4);  
Magic Number,OfficeOpenXml.Drawing,ExcelDrawingBorder,C:\repos\bambit_EPPlus\EPPlus\Drawing\ExcelDrawingBorder.cs,TranslateLineStyleText,The following statement contains a magic number: return "lg" + text.Substring (4' text.Length - 4);  
Magic Number,OfficeOpenXml.Drawing,ExcelDrawingBorder,C:\repos\bambit_EPPlus\EPPlus\Drawing\ExcelDrawingBorder.cs,TranslateLineStyleText,The following statement contains a magic number: return "sys" + text.Substring (6' text.Length - 6);  
Magic Number,OfficeOpenXml.Drawing,ExcelDrawingBorder,C:\repos\bambit_EPPlus\EPPlus\Drawing\ExcelDrawingBorder.cs,TranslateLineStyleText,The following statement contains a magic number: return "sys" + text.Substring (6' text.Length - 6);  
Magic Number,OfficeOpenXml.Drawing,ExcelDrawingBorder,C:\repos\bambit_EPPlus\EPPlus\Drawing\ExcelDrawingBorder.cs,TranslateLineStyle,The following statement contains a magic number: switch (text) {  case "dash":  case "dot":  case "dashDot":  case "solid":  	return (eLineStyle)Enum.Parse (typeof(eLineStyle)' text' true);  case "lgDash":  case "lgDashDot":  case "lgDashDotDot":  	return (eLineStyle)Enum.Parse (typeof(eLineStyle)' "Long" + text.Substring (2' text.Length - 2));  case "sysDash":  case "sysDashDot":  case "sysDashDotDot":  case "sysDot":  	return (eLineStyle)Enum.Parse (typeof(eLineStyle)' "System" + text.Substring (3' text.Length - 3));  default:  	throw (new Exception ("Invalid Linestyle"));  }  
Magic Number,OfficeOpenXml.Drawing,ExcelDrawingBorder,C:\repos\bambit_EPPlus\EPPlus\Drawing\ExcelDrawingBorder.cs,TranslateLineStyle,The following statement contains a magic number: switch (text) {  case "dash":  case "dot":  case "dashDot":  case "solid":  	return (eLineStyle)Enum.Parse (typeof(eLineStyle)' text' true);  case "lgDash":  case "lgDashDot":  case "lgDashDotDot":  	return (eLineStyle)Enum.Parse (typeof(eLineStyle)' "Long" + text.Substring (2' text.Length - 2));  case "sysDash":  case "sysDashDot":  case "sysDashDotDot":  case "sysDot":  	return (eLineStyle)Enum.Parse (typeof(eLineStyle)' "System" + text.Substring (3' text.Length - 3));  default:  	throw (new Exception ("Invalid Linestyle"));  }  
Magic Number,OfficeOpenXml.Drawing,ExcelDrawingBorder,C:\repos\bambit_EPPlus\EPPlus\Drawing\ExcelDrawingBorder.cs,TranslateLineStyle,The following statement contains a magic number: switch (text) {  case "dash":  case "dot":  case "dashDot":  case "solid":  	return (eLineStyle)Enum.Parse (typeof(eLineStyle)' text' true);  case "lgDash":  case "lgDashDot":  case "lgDashDotDot":  	return (eLineStyle)Enum.Parse (typeof(eLineStyle)' "Long" + text.Substring (2' text.Length - 2));  case "sysDash":  case "sysDashDot":  case "sysDashDotDot":  case "sysDot":  	return (eLineStyle)Enum.Parse (typeof(eLineStyle)' "System" + text.Substring (3' text.Length - 3));  default:  	throw (new Exception ("Invalid Linestyle"));  }  
Magic Number,OfficeOpenXml.Drawing,ExcelDrawingBorder,C:\repos\bambit_EPPlus\EPPlus\Drawing\ExcelDrawingBorder.cs,TranslateLineStyle,The following statement contains a magic number: switch (text) {  case "dash":  case "dot":  case "dashDot":  case "solid":  	return (eLineStyle)Enum.Parse (typeof(eLineStyle)' text' true);  case "lgDash":  case "lgDashDot":  case "lgDashDotDot":  	return (eLineStyle)Enum.Parse (typeof(eLineStyle)' "Long" + text.Substring (2' text.Length - 2));  case "sysDash":  case "sysDashDot":  case "sysDashDotDot":  case "sysDot":  	return (eLineStyle)Enum.Parse (typeof(eLineStyle)' "System" + text.Substring (3' text.Length - 3));  default:  	throw (new Exception ("Invalid Linestyle"));  }  
Magic Number,OfficeOpenXml.Drawing,ExcelDrawingBorder,C:\repos\bambit_EPPlus\EPPlus\Drawing\ExcelDrawingBorder.cs,TranslateLineStyle,The following statement contains a magic number: return (eLineStyle)Enum.Parse (typeof(eLineStyle)' "Long" + text.Substring (2' text.Length - 2));  
Magic Number,OfficeOpenXml.Drawing,ExcelDrawingBorder,C:\repos\bambit_EPPlus\EPPlus\Drawing\ExcelDrawingBorder.cs,TranslateLineStyle,The following statement contains a magic number: return (eLineStyle)Enum.Parse (typeof(eLineStyle)' "Long" + text.Substring (2' text.Length - 2));  
Magic Number,OfficeOpenXml.Drawing,ExcelDrawingBorder,C:\repos\bambit_EPPlus\EPPlus\Drawing\ExcelDrawingBorder.cs,TranslateLineStyle,The following statement contains a magic number: return (eLineStyle)Enum.Parse (typeof(eLineStyle)' "System" + text.Substring (3' text.Length - 3));  
Magic Number,OfficeOpenXml.Drawing,ExcelDrawingBorder,C:\repos\bambit_EPPlus\EPPlus\Drawing\ExcelDrawingBorder.cs,TranslateLineStyle,The following statement contains a magic number: return (eLineStyle)Enum.Parse (typeof(eLineStyle)' "System" + text.Substring (3' text.Length - 3));  
Magic Number,OfficeOpenXml.Drawing.Vml,ExcelVmlDrawingPictureCollection,C:\repos\bambit_EPPlus\EPPlus\Drawing\Vml\ExcelVmlDrawingPictureCollection.cs,GetNewId,The following statement contains a magic number: if (_nextID == 0) {  	foreach (ExcelVmlDrawingComment draw in this) {  		if (draw.Id.Length > 3 && draw.Id.StartsWith ("vml")) {  			int id;  			if (int.TryParse (draw.Id.Substring (3' draw.Id.Length - 3)' out id)) {  				if (id > _nextID) {  					_nextID = id;  				}  			}  		}  	}  }  
Magic Number,OfficeOpenXml.Drawing.Vml,ExcelVmlDrawingPictureCollection,C:\repos\bambit_EPPlus\EPPlus\Drawing\Vml\ExcelVmlDrawingPictureCollection.cs,GetNewId,The following statement contains a magic number: if (_nextID == 0) {  	foreach (ExcelVmlDrawingComment draw in this) {  		if (draw.Id.Length > 3 && draw.Id.StartsWith ("vml")) {  			int id;  			if (int.TryParse (draw.Id.Substring (3' draw.Id.Length - 3)' out id)) {  				if (id > _nextID) {  					_nextID = id;  				}  			}  		}  	}  }  
Magic Number,OfficeOpenXml.Drawing.Vml,ExcelVmlDrawingPictureCollection,C:\repos\bambit_EPPlus\EPPlus\Drawing\Vml\ExcelVmlDrawingPictureCollection.cs,GetNewId,The following statement contains a magic number: if (_nextID == 0) {  	foreach (ExcelVmlDrawingComment draw in this) {  		if (draw.Id.Length > 3 && draw.Id.StartsWith ("vml")) {  			int id;  			if (int.TryParse (draw.Id.Substring (3' draw.Id.Length - 3)' out id)) {  				if (id > _nextID) {  					_nextID = id;  				}  			}  		}  	}  }  
Magic Number,OfficeOpenXml.Drawing.Vml,ExcelVmlDrawingPictureCollection,C:\repos\bambit_EPPlus\EPPlus\Drawing\Vml\ExcelVmlDrawingPictureCollection.cs,GetNewId,The following statement contains a magic number: foreach (ExcelVmlDrawingComment draw in this) {  	if (draw.Id.Length > 3 && draw.Id.StartsWith ("vml")) {  		int id;  		if (int.TryParse (draw.Id.Substring (3' draw.Id.Length - 3)' out id)) {  			if (id > _nextID) {  				_nextID = id;  			}  		}  	}  }  
Magic Number,OfficeOpenXml.Drawing.Vml,ExcelVmlDrawingPictureCollection,C:\repos\bambit_EPPlus\EPPlus\Drawing\Vml\ExcelVmlDrawingPictureCollection.cs,GetNewId,The following statement contains a magic number: foreach (ExcelVmlDrawingComment draw in this) {  	if (draw.Id.Length > 3 && draw.Id.StartsWith ("vml")) {  		int id;  		if (int.TryParse (draw.Id.Substring (3' draw.Id.Length - 3)' out id)) {  			if (id > _nextID) {  				_nextID = id;  			}  		}  	}  }  
Magic Number,OfficeOpenXml.Drawing.Vml,ExcelVmlDrawingPictureCollection,C:\repos\bambit_EPPlus\EPPlus\Drawing\Vml\ExcelVmlDrawingPictureCollection.cs,GetNewId,The following statement contains a magic number: foreach (ExcelVmlDrawingComment draw in this) {  	if (draw.Id.Length > 3 && draw.Id.StartsWith ("vml")) {  		int id;  		if (int.TryParse (draw.Id.Substring (3' draw.Id.Length - 3)' out id)) {  			if (id > _nextID) {  				_nextID = id;  			}  		}  	}  }  
Magic Number,OfficeOpenXml.Drawing.Vml,ExcelVmlDrawingPictureCollection,C:\repos\bambit_EPPlus\EPPlus\Drawing\Vml\ExcelVmlDrawingPictureCollection.cs,GetNewId,The following statement contains a magic number: if (draw.Id.Length > 3 && draw.Id.StartsWith ("vml")) {  	int id;  	if (int.TryParse (draw.Id.Substring (3' draw.Id.Length - 3)' out id)) {  		if (id > _nextID) {  			_nextID = id;  		}  	}  }  
Magic Number,OfficeOpenXml.Drawing.Vml,ExcelVmlDrawingPictureCollection,C:\repos\bambit_EPPlus\EPPlus\Drawing\Vml\ExcelVmlDrawingPictureCollection.cs,GetNewId,The following statement contains a magic number: if (draw.Id.Length > 3 && draw.Id.StartsWith ("vml")) {  	int id;  	if (int.TryParse (draw.Id.Substring (3' draw.Id.Length - 3)' out id)) {  		if (id > _nextID) {  			_nextID = id;  		}  	}  }  
Magic Number,OfficeOpenXml.Drawing.Vml,ExcelVmlDrawingPictureCollection,C:\repos\bambit_EPPlus\EPPlus\Drawing\Vml\ExcelVmlDrawingPictureCollection.cs,GetNewId,The following statement contains a magic number: if (draw.Id.Length > 3 && draw.Id.StartsWith ("vml")) {  	int id;  	if (int.TryParse (draw.Id.Substring (3' draw.Id.Length - 3)' out id)) {  		if (id > _nextID) {  			_nextID = id;  		}  	}  }  
Magic Number,OfficeOpenXml.Drawing.Vml,ExcelVmlDrawingPictureCollection,C:\repos\bambit_EPPlus\EPPlus\Drawing\Vml\ExcelVmlDrawingPictureCollection.cs,GetNewId,The following statement contains a magic number: if (int.TryParse (draw.Id.Substring (3' draw.Id.Length - 3)' out id)) {  	if (id > _nextID) {  		_nextID = id;  	}  }  
Magic Number,OfficeOpenXml.Drawing.Vml,ExcelVmlDrawingPictureCollection,C:\repos\bambit_EPPlus\EPPlus\Drawing\Vml\ExcelVmlDrawingPictureCollection.cs,GetNewId,The following statement contains a magic number: if (int.TryParse (draw.Id.Substring (3' draw.Id.Length - 3)' out id)) {  	if (id > _nextID) {  		_nextID = id;  	}  }  
Magic Number,OfficeOpenXml.Drawing.Vml,ExcelVmlDrawingCommentCollection,C:\repos\bambit_EPPlus\EPPlus\Drawing\Vml\ExcelVmlDrawingCommentCollection.cs,AddDrawing,The following statement contains a magic number: vml += string.Format ("<x:Anchor>{0}' 15' {1}' 2' {2}' 31' {3}' 1</x:Anchor>"' col' row - 1' col + 2' row + 3);  
Magic Number,OfficeOpenXml.Drawing.Vml,ExcelVmlDrawingCommentCollection,C:\repos\bambit_EPPlus\EPPlus\Drawing\Vml\ExcelVmlDrawingCommentCollection.cs,AddDrawing,The following statement contains a magic number: vml += string.Format ("<x:Anchor>{0}' 15' {1}' 2' {2}' 31' {3}' 1</x:Anchor>"' col' row - 1' col + 2' row + 3);  
Magic Number,OfficeOpenXml.Drawing.Vml,ExcelVmlDrawingCommentCollection,C:\repos\bambit_EPPlus\EPPlus\Drawing\Vml\ExcelVmlDrawingCommentCollection.cs,GetNewId,The following statement contains a magic number: if (_nextID == 0) {  	foreach (ExcelVmlDrawingComment draw in this) {  		if (draw.Id.Length > 3 && draw.Id.StartsWith ("vml")) {  			int id;  			if (int.TryParse (draw.Id.Substring (3' draw.Id.Length - 3)' out id)) {  				if (id > _nextID) {  					_nextID = id;  				}  			}  		}  	}  }  
Magic Number,OfficeOpenXml.Drawing.Vml,ExcelVmlDrawingCommentCollection,C:\repos\bambit_EPPlus\EPPlus\Drawing\Vml\ExcelVmlDrawingCommentCollection.cs,GetNewId,The following statement contains a magic number: if (_nextID == 0) {  	foreach (ExcelVmlDrawingComment draw in this) {  		if (draw.Id.Length > 3 && draw.Id.StartsWith ("vml")) {  			int id;  			if (int.TryParse (draw.Id.Substring (3' draw.Id.Length - 3)' out id)) {  				if (id > _nextID) {  					_nextID = id;  				}  			}  		}  	}  }  
Magic Number,OfficeOpenXml.Drawing.Vml,ExcelVmlDrawingCommentCollection,C:\repos\bambit_EPPlus\EPPlus\Drawing\Vml\ExcelVmlDrawingCommentCollection.cs,GetNewId,The following statement contains a magic number: if (_nextID == 0) {  	foreach (ExcelVmlDrawingComment draw in this) {  		if (draw.Id.Length > 3 && draw.Id.StartsWith ("vml")) {  			int id;  			if (int.TryParse (draw.Id.Substring (3' draw.Id.Length - 3)' out id)) {  				if (id > _nextID) {  					_nextID = id;  				}  			}  		}  	}  }  
Magic Number,OfficeOpenXml.Drawing.Vml,ExcelVmlDrawingCommentCollection,C:\repos\bambit_EPPlus\EPPlus\Drawing\Vml\ExcelVmlDrawingCommentCollection.cs,GetNewId,The following statement contains a magic number: foreach (ExcelVmlDrawingComment draw in this) {  	if (draw.Id.Length > 3 && draw.Id.StartsWith ("vml")) {  		int id;  		if (int.TryParse (draw.Id.Substring (3' draw.Id.Length - 3)' out id)) {  			if (id > _nextID) {  				_nextID = id;  			}  		}  	}  }  
Magic Number,OfficeOpenXml.Drawing.Vml,ExcelVmlDrawingCommentCollection,C:\repos\bambit_EPPlus\EPPlus\Drawing\Vml\ExcelVmlDrawingCommentCollection.cs,GetNewId,The following statement contains a magic number: foreach (ExcelVmlDrawingComment draw in this) {  	if (draw.Id.Length > 3 && draw.Id.StartsWith ("vml")) {  		int id;  		if (int.TryParse (draw.Id.Substring (3' draw.Id.Length - 3)' out id)) {  			if (id > _nextID) {  				_nextID = id;  			}  		}  	}  }  
Magic Number,OfficeOpenXml.Drawing.Vml,ExcelVmlDrawingCommentCollection,C:\repos\bambit_EPPlus\EPPlus\Drawing\Vml\ExcelVmlDrawingCommentCollection.cs,GetNewId,The following statement contains a magic number: foreach (ExcelVmlDrawingComment draw in this) {  	if (draw.Id.Length > 3 && draw.Id.StartsWith ("vml")) {  		int id;  		if (int.TryParse (draw.Id.Substring (3' draw.Id.Length - 3)' out id)) {  			if (id > _nextID) {  				_nextID = id;  			}  		}  	}  }  
Magic Number,OfficeOpenXml.Drawing.Vml,ExcelVmlDrawingCommentCollection,C:\repos\bambit_EPPlus\EPPlus\Drawing\Vml\ExcelVmlDrawingCommentCollection.cs,GetNewId,The following statement contains a magic number: if (draw.Id.Length > 3 && draw.Id.StartsWith ("vml")) {  	int id;  	if (int.TryParse (draw.Id.Substring (3' draw.Id.Length - 3)' out id)) {  		if (id > _nextID) {  			_nextID = id;  		}  	}  }  
Magic Number,OfficeOpenXml.Drawing.Vml,ExcelVmlDrawingCommentCollection,C:\repos\bambit_EPPlus\EPPlus\Drawing\Vml\ExcelVmlDrawingCommentCollection.cs,GetNewId,The following statement contains a magic number: if (draw.Id.Length > 3 && draw.Id.StartsWith ("vml")) {  	int id;  	if (int.TryParse (draw.Id.Substring (3' draw.Id.Length - 3)' out id)) {  		if (id > _nextID) {  			_nextID = id;  		}  	}  }  
Magic Number,OfficeOpenXml.Drawing.Vml,ExcelVmlDrawingCommentCollection,C:\repos\bambit_EPPlus\EPPlus\Drawing\Vml\ExcelVmlDrawingCommentCollection.cs,GetNewId,The following statement contains a magic number: if (draw.Id.Length > 3 && draw.Id.StartsWith ("vml")) {  	int id;  	if (int.TryParse (draw.Id.Substring (3' draw.Id.Length - 3)' out id)) {  		if (id > _nextID) {  			_nextID = id;  		}  	}  }  
Magic Number,OfficeOpenXml.Drawing.Vml,ExcelVmlDrawingCommentCollection,C:\repos\bambit_EPPlus\EPPlus\Drawing\Vml\ExcelVmlDrawingCommentCollection.cs,GetNewId,The following statement contains a magic number: if (int.TryParse (draw.Id.Substring (3' draw.Id.Length - 3)' out id)) {  	if (id > _nextID) {  		_nextID = id;  	}  }  
Magic Number,OfficeOpenXml.Drawing.Vml,ExcelVmlDrawingCommentCollection,C:\repos\bambit_EPPlus\EPPlus\Drawing\Vml\ExcelVmlDrawingCommentCollection.cs,GetNewId,The following statement contains a magic number: if (int.TryParse (draw.Id.Substring (3' draw.Id.Length - 3)' out id)) {  	if (id > _nextID) {  		_nextID = id;  	}  }  
Magic Number,OfficeOpenXml.Drawing.Vml,ExcelVmlDrawingPicture,C:\repos\bambit_EPPlus\EPPlus\Drawing\Vml\ExcelVmlDrawingPicture.cs,GetFracDT,The following statement contains a magic number: if (v.EndsWith ("f")) {  	v = v.Substring (0' v.Length - 1);  	if (double.TryParse (v' out d)) {  		d /= 65535;  	}  	else {  		d = def;  	}  }  else {  	if (!double.TryParse (v' out d)) {  		d = def;  	}  }  
Magic Number,OfficeOpenXml.Drawing.Vml,ExcelVmlDrawingPicture,C:\repos\bambit_EPPlus\EPPlus\Drawing\Vml\ExcelVmlDrawingPicture.cs,GetFracDT,The following statement contains a magic number: if (double.TryParse (v' out d)) {  	d /= 65535;  }  else {  	d = def;  }  
Magic Number,OfficeOpenXml.Drawing.Vml,ExcelVmlDrawingPicture,C:\repos\bambit_EPPlus\EPPlus\Drawing\Vml\ExcelVmlDrawingPicture.cs,GetFracDT,The following statement contains a magic number: d /= 65535;  
Magic Number,OfficeOpenXml.Drawing.Vml,ExcelVmlDrawingPicture,C:\repos\bambit_EPPlus\EPPlus\Drawing\Vml\ExcelVmlDrawingPicture.cs,GetStyleProp,The following statement contains a magic number: foreach (string prop in style.Split (';')) {  	string[] split = prop.Split (':');  	if (split [0] == propertyName && split.Length > 1) {  		string value = split [1].EndsWith ("pt") ? split [1].Substring (0' split [1].Length - 2) : split [1];  		double ret;  		if (double.TryParse (value' out ret)) {  			return ret;  		}  		else {  			return 0;  		}  	}  }  
Magic Number,OfficeOpenXml.Drawing.Vml,ExcelVmlDrawingPicture,C:\repos\bambit_EPPlus\EPPlus\Drawing\Vml\ExcelVmlDrawingPicture.cs,GetStyleProp,The following statement contains a magic number: if (split [0] == propertyName && split.Length > 1) {  	string value = split [1].EndsWith ("pt") ? split [1].Substring (0' split [1].Length - 2) : split [1];  	double ret;  	if (double.TryParse (value' out ret)) {  		return ret;  	}  	else {  		return 0;  	}  }  
Magic Number,OfficeOpenXml.Drawing.Vml,ExcelVmlDrawingPosition,C:\repos\bambit_EPPlus\EPPlus\Drawing\Vml\ExcelVmlDrawingPosition.cs,SetNumber,The following statement contains a magic number: if (numbers.Length == 8) {  	numbers [_startPos + pos] = value.ToString ();  }  else {  	throw (new Exception ("Anchor element is invalid in vmlDrawing"));  }  
Magic Number,OfficeOpenXml.Drawing.Vml,ExcelVmlDrawingPosition,C:\repos\bambit_EPPlus\EPPlus\Drawing\Vml\ExcelVmlDrawingPosition.cs,GetNumber,The following statement contains a magic number: if (numbers.Length == 8) {  	int ret;  	if (int.TryParse (numbers [_startPos + pos]' out ret)) {  		return ret;  	}  }  
Magic Number,OfficeOpenXml,ExcelProtectedRange,C:\repos\bambit_EPPlus\EPPlus\ExcelProtectedRange.cs,SetPassword,The following statement contains a magic number: SpinCount = SpinCount < 100000 ? 100000 : SpinCount;  
Magic Number,OfficeOpenXml,ExcelProtectedRange,C:\repos\bambit_EPPlus\EPPlus\ExcelProtectedRange.cs,SetPassword,The following statement contains a magic number: SpinCount = SpinCount < 100000 ? 100000 : SpinCount;  
Magic Number,OfficeOpenXml,ExcelProtectedRange,C:\repos\bambit_EPPlus\EPPlus\ExcelProtectedRange.cs,SetPassword,The following statement contains a magic number: Array.Copy (byPwd' 0' buffer' 16' byPwd.Length);  
Magic Number,OfficeOpenXml,ExcelProtectedRange,C:\repos\bambit_EPPlus\EPPlus\ExcelProtectedRange.cs,SetPassword,The following statement contains a magic number: for (var i = 0; i < SpinCount; i++) {  	buffer = new byte[hash.Length + 4];  	Array.Copy (hash' buffer' hash.Length);  	Array.Copy (BitConverter.GetBytes (i)' 0' buffer' hash.Length' 4);  	hash = hp.ComputeHash (buffer);  }  
Magic Number,OfficeOpenXml,ExcelProtectedRange,C:\repos\bambit_EPPlus\EPPlus\ExcelProtectedRange.cs,SetPassword,The following statement contains a magic number: for (var i = 0; i < SpinCount; i++) {  	buffer = new byte[hash.Length + 4];  	Array.Copy (hash' buffer' hash.Length);  	Array.Copy (BitConverter.GetBytes (i)' 0' buffer' hash.Length' 4);  	hash = hp.ComputeHash (buffer);  }  
Magic Number,OfficeOpenXml,ExcelProtectedRange,C:\repos\bambit_EPPlus\EPPlus\ExcelProtectedRange.cs,SetPassword,The following statement contains a magic number: buffer = new byte[hash.Length + 4];  
Magic Number,OfficeOpenXml,ExcelProtectedRange,C:\repos\bambit_EPPlus\EPPlus\ExcelProtectedRange.cs,SetPassword,The following statement contains a magic number: Array.Copy (BitConverter.GetBytes (i)' 0' buffer' hash.Length' 4);  
Magic Number,OfficeOpenXml,ExcelColumn,C:\repos\bambit_EPPlus\EPPlus\ExcelColumn.cs,GetColumnID,The following statement contains a magic number: return ((ulong)sheetID) + (((ulong)column) << 15);  
Magic Number,OfficeOpenXml,ExcelHeaderFooterText,C:\repos\bambit_EPPlus\EPPlus\ExcelHeaderFooter.cs,ExcelHeaderFooterText,The following statement contains a magic number: for (int pos = startPos; pos < text.Length - 2; pos++) {  	string newCode = text.Substring (pos' 2);  	if (newCode == "&C" || newCode == "&R") {  		SetText (code' text.Substring (startPos' pos - startPos));  		startPos = pos + 2;  		pos = startPos;  		code = newCode;  	}  }  
Magic Number,OfficeOpenXml,ExcelHeaderFooterText,C:\repos\bambit_EPPlus\EPPlus\ExcelHeaderFooter.cs,ExcelHeaderFooterText,The following statement contains a magic number: for (int pos = startPos; pos < text.Length - 2; pos++) {  	string newCode = text.Substring (pos' 2);  	if (newCode == "&C" || newCode == "&R") {  		SetText (code' text.Substring (startPos' pos - startPos));  		startPos = pos + 2;  		pos = startPos;  		code = newCode;  	}  }  
Magic Number,OfficeOpenXml,ExcelHeaderFooterText,C:\repos\bambit_EPPlus\EPPlus\ExcelHeaderFooter.cs,ExcelHeaderFooterText,The following statement contains a magic number: for (int pos = startPos; pos < text.Length - 2; pos++) {  	string newCode = text.Substring (pos' 2);  	if (newCode == "&C" || newCode == "&R") {  		SetText (code' text.Substring (startPos' pos - startPos));  		startPos = pos + 2;  		pos = startPos;  		code = newCode;  	}  }  
Magic Number,OfficeOpenXml,ExcelHeaderFooterText,C:\repos\bambit_EPPlus\EPPlus\ExcelHeaderFooter.cs,ExcelHeaderFooterText,The following statement contains a magic number: if (newCode == "&C" || newCode == "&R") {  	SetText (code' text.Substring (startPos' pos - startPos));  	startPos = pos + 2;  	pos = startPos;  	code = newCode;  }  
Magic Number,OfficeOpenXml,ExcelHeaderFooterText,C:\repos\bambit_EPPlus\EPPlus\ExcelHeaderFooter.cs,ExcelHeaderFooterText,The following statement contains a magic number: startPos = pos + 2;  
Magic Number,OfficeOpenXml,ExcelRow,C:\repos\bambit_EPPlus\EPPlus\ExcelRow.cs,GetRowID,The following statement contains a magic number: return ((ulong)sheetID) + (((ulong)row) << 29);  
Magic Number,OfficeOpenXml,ExcelStyles,C:\repos\bambit_EPPlus\EPPlus\ExcelStyles.cs,UpdateXml,The following statement contains a magic number: if (NamedStyles.Count > 0 && normalIx >= 0 && NamedStyles [normalIx].Style.Numberformat.NumFmtID >= 164) {  	ExcelNumberFormatXml nf = NumberFormats [NumberFormats.FindIndexByID (NamedStyles [normalIx].Style.Numberformat.Id)];  	nfNode.AppendChild (nf.CreateXmlNode (_styleXml.CreateElement ("numFmt"' ExcelPackage.schemaMain)));  	nf.newID = count++;  }  
Magic Number,OfficeOpenXml,OfficeProperties,C:\repos\bambit_EPPlus\EPPlus\OfficeProperties.cs,SetCustomPropertyValue,The following statement contains a magic number: if (node == null) {  	int pid;  	var MaxNode = CustomPropertiesXml.SelectSingleNode ("ctp:Properties/ctp:property[not(@pid <= preceding-sibling::ctp:property/@pid) and not(@pid <= following-sibling::ctp:property/@pid)]"' NameSpaceManager);  	if (MaxNode == null) {  		pid = 2;  	}  	else {  		if (!int.TryParse (MaxNode.Attributes ["pid"].Value' out pid)) {  			pid = 2;  		}  		pid++;  	}  	node = CustomPropertiesXml.CreateElement ("property"' ExcelPackage.schemaCustom);  	node.SetAttribute ("fmtid"' "{D5CDD505-2E9C-101B-9397-08002B2CF9AE}");  	node.SetAttribute ("pid"' pid.ToString ());  	// custom property pid  	node.SetAttribute ("name"' propertyName);  	allProps.AppendChild (node);  }  else {  	while (node.ChildNodes.Count > 0)  		node.RemoveChild (node.ChildNodes [0]);  }  
Magic Number,OfficeOpenXml,OfficeProperties,C:\repos\bambit_EPPlus\EPPlus\OfficeProperties.cs,SetCustomPropertyValue,The following statement contains a magic number: if (node == null) {  	int pid;  	var MaxNode = CustomPropertiesXml.SelectSingleNode ("ctp:Properties/ctp:property[not(@pid <= preceding-sibling::ctp:property/@pid) and not(@pid <= following-sibling::ctp:property/@pid)]"' NameSpaceManager);  	if (MaxNode == null) {  		pid = 2;  	}  	else {  		if (!int.TryParse (MaxNode.Attributes ["pid"].Value' out pid)) {  			pid = 2;  		}  		pid++;  	}  	node = CustomPropertiesXml.CreateElement ("property"' ExcelPackage.schemaCustom);  	node.SetAttribute ("fmtid"' "{D5CDD505-2E9C-101B-9397-08002B2CF9AE}");  	node.SetAttribute ("pid"' pid.ToString ());  	// custom property pid  	node.SetAttribute ("name"' propertyName);  	allProps.AppendChild (node);  }  else {  	while (node.ChildNodes.Count > 0)  		node.RemoveChild (node.ChildNodes [0]);  }  
Magic Number,OfficeOpenXml,OfficeProperties,C:\repos\bambit_EPPlus\EPPlus\OfficeProperties.cs,SetCustomPropertyValue,The following statement contains a magic number: if (MaxNode == null) {  	pid = 2;  }  else {  	if (!int.TryParse (MaxNode.Attributes ["pid"].Value' out pid)) {  		pid = 2;  	}  	pid++;  }  
Magic Number,OfficeOpenXml,OfficeProperties,C:\repos\bambit_EPPlus\EPPlus\OfficeProperties.cs,SetCustomPropertyValue,The following statement contains a magic number: if (MaxNode == null) {  	pid = 2;  }  else {  	if (!int.TryParse (MaxNode.Attributes ["pid"].Value' out pid)) {  		pid = 2;  	}  	pid++;  }  
Magic Number,OfficeOpenXml,OfficeProperties,C:\repos\bambit_EPPlus\EPPlus\OfficeProperties.cs,SetCustomPropertyValue,The following statement contains a magic number: pid = 2;  
Magic Number,OfficeOpenXml,OfficeProperties,C:\repos\bambit_EPPlus\EPPlus\OfficeProperties.cs,SetCustomPropertyValue,The following statement contains a magic number: if (!int.TryParse (MaxNode.Attributes ["pid"].Value' out pid)) {  	pid = 2;  }  
Magic Number,OfficeOpenXml,OfficeProperties,C:\repos\bambit_EPPlus\EPPlus\OfficeProperties.cs,SetCustomPropertyValue,The following statement contains a magic number: pid = 2;  
Magic Number,OfficeOpenXml,ExcelWorkbook,C:\repos\bambit_EPPlus\EPPlus\ExcelWorkbook.cs,GetDefinedNames,The following statement contains a magic number: if (nl != null) {  	foreach (XmlElement elem in nl) {  		string fullAddress = elem.InnerText;  		int localSheetID;  		ExcelWorksheet nameWorksheet;  		if (!int.TryParse (elem.GetAttribute ("localSheetId")' out localSheetID)) {  			localSheetID = -1;  			nameWorksheet = null;  		}  		else {  			nameWorksheet = Worksheets [localSheetID + 1];  		}  		var addressType = ExcelAddressBase.IsValid (fullAddress);  		ExcelRangeBase range;  		ExcelNamedRange namedRange;  		if (fullAddress.IndexOf ("[") > -1) {  			int start = fullAddress.IndexOf ("[");  			int end = fullAddress.IndexOf ("]"' start);  			if (start >= 0 && end >= 0) {  				string externalIndex = fullAddress.Substring (start + 1' end - start - 1);  				int index;  				if (int.TryParse (externalIndex' out index)) {  					if (index > 0 && index <= _externalReferences.Count) {  						fullAddress = fullAddress.Substring (0' start) + "[" + _externalReferences [index - 1] + "]" + fullAddress.Substring (end + 1);  					}  				}  			}  		}  		if (addressType == ExcelAddressBase.AddressType.Invalid || addressType == ExcelAddressBase.AddressType.InternalName || addressType == ExcelAddressBase.AddressType.ExternalName)//A value or a formula  		 {  			double value;  			range = new ExcelRangeBase (this' nameWorksheet' elem.GetAttribute ("name")' true);  			if (nameWorksheet == null) {  				namedRange = _names.Add (elem.GetAttribute ("name")' range);  			}  			else {  				namedRange = nameWorksheet.Names.Add (elem.GetAttribute ("name")' range);  			}  			if (fullAddress.StartsWith ("\""))//String value  			 {  				namedRange.NameValue = fullAddress.Substring (1' fullAddress.Length - 2);  			}  			else if (double.TryParse (fullAddress' NumberStyles.Any' CultureInfo.InvariantCulture' out value)) {  				namedRange.NameValue = value;  			}  			else {  				namedRange.NameFormula = fullAddress;  			}  		}  		else {  			ExcelAddress addr = new ExcelAddress (fullAddress);  			if (localSheetID > -1) {  				if (string.IsNullOrEmpty (addr._ws)) {  					namedRange = Worksheets [localSheetID + 1].Names.Add (elem.GetAttribute ("name")' new ExcelRangeBase (this' Worksheets [localSheetID + 1]' fullAddress' false));  				}  				else {  					namedRange = Worksheets [localSheetID + 1].Names.Add (elem.GetAttribute ("name")' new ExcelRangeBase (this' Worksheets [addr._ws]' fullAddress' false));  				}  			}  			else {  				var ws = Worksheets [addr._ws];  				namedRange = _names.Add (elem.GetAttribute ("name")' new ExcelRangeBase (this' ws' fullAddress' false));  			}  		}  		if (elem.GetAttribute ("hidden") == "1" && namedRange != null)  			namedRange.IsNameHidden = true;  		if (!string.IsNullOrEmpty (elem.GetAttribute ("comment")))  			namedRange.NameComment = elem.GetAttribute ("comment");  	}  }  
Magic Number,OfficeOpenXml,ExcelWorkbook,C:\repos\bambit_EPPlus\EPPlus\ExcelWorkbook.cs,GetDefinedNames,The following statement contains a magic number: foreach (XmlElement elem in nl) {  	string fullAddress = elem.InnerText;  	int localSheetID;  	ExcelWorksheet nameWorksheet;  	if (!int.TryParse (elem.GetAttribute ("localSheetId")' out localSheetID)) {  		localSheetID = -1;  		nameWorksheet = null;  	}  	else {  		nameWorksheet = Worksheets [localSheetID + 1];  	}  	var addressType = ExcelAddressBase.IsValid (fullAddress);  	ExcelRangeBase range;  	ExcelNamedRange namedRange;  	if (fullAddress.IndexOf ("[") > -1) {  		int start = fullAddress.IndexOf ("[");  		int end = fullAddress.IndexOf ("]"' start);  		if (start >= 0 && end >= 0) {  			string externalIndex = fullAddress.Substring (start + 1' end - start - 1);  			int index;  			if (int.TryParse (externalIndex' out index)) {  				if (index > 0 && index <= _externalReferences.Count) {  					fullAddress = fullAddress.Substring (0' start) + "[" + _externalReferences [index - 1] + "]" + fullAddress.Substring (end + 1);  				}  			}  		}  	}  	if (addressType == ExcelAddressBase.AddressType.Invalid || addressType == ExcelAddressBase.AddressType.InternalName || addressType == ExcelAddressBase.AddressType.ExternalName)//A value or a formula  	 {  		double value;  		range = new ExcelRangeBase (this' nameWorksheet' elem.GetAttribute ("name")' true);  		if (nameWorksheet == null) {  			namedRange = _names.Add (elem.GetAttribute ("name")' range);  		}  		else {  			namedRange = nameWorksheet.Names.Add (elem.GetAttribute ("name")' range);  		}  		if (fullAddress.StartsWith ("\""))//String value  		 {  			namedRange.NameValue = fullAddress.Substring (1' fullAddress.Length - 2);  		}  		else if (double.TryParse (fullAddress' NumberStyles.Any' CultureInfo.InvariantCulture' out value)) {  			namedRange.NameValue = value;  		}  		else {  			namedRange.NameFormula = fullAddress;  		}  	}  	else {  		ExcelAddress addr = new ExcelAddress (fullAddress);  		if (localSheetID > -1) {  			if (string.IsNullOrEmpty (addr._ws)) {  				namedRange = Worksheets [localSheetID + 1].Names.Add (elem.GetAttribute ("name")' new ExcelRangeBase (this' Worksheets [localSheetID + 1]' fullAddress' false));  			}  			else {  				namedRange = Worksheets [localSheetID + 1].Names.Add (elem.GetAttribute ("name")' new ExcelRangeBase (this' Worksheets [addr._ws]' fullAddress' false));  			}  		}  		else {  			var ws = Worksheets [addr._ws];  			namedRange = _names.Add (elem.GetAttribute ("name")' new ExcelRangeBase (this' ws' fullAddress' false));  		}  	}  	if (elem.GetAttribute ("hidden") == "1" && namedRange != null)  		namedRange.IsNameHidden = true;  	if (!string.IsNullOrEmpty (elem.GetAttribute ("comment")))  		namedRange.NameComment = elem.GetAttribute ("comment");  }  
Magic Number,OfficeOpenXml,ExcelWorkbook,C:\repos\bambit_EPPlus\EPPlus\ExcelWorkbook.cs,GetDefinedNames,The following statement contains a magic number: if (addressType == ExcelAddressBase.AddressType.Invalid || addressType == ExcelAddressBase.AddressType.InternalName || addressType == ExcelAddressBase.AddressType.ExternalName)//A value or a formula   {  	double value;  	range = new ExcelRangeBase (this' nameWorksheet' elem.GetAttribute ("name")' true);  	if (nameWorksheet == null) {  		namedRange = _names.Add (elem.GetAttribute ("name")' range);  	}  	else {  		namedRange = nameWorksheet.Names.Add (elem.GetAttribute ("name")' range);  	}  	if (fullAddress.StartsWith ("\""))//String value  	 {  		namedRange.NameValue = fullAddress.Substring (1' fullAddress.Length - 2);  	}  	else if (double.TryParse (fullAddress' NumberStyles.Any' CultureInfo.InvariantCulture' out value)) {  		namedRange.NameValue = value;  	}  	else {  		namedRange.NameFormula = fullAddress;  	}  }  else {  	ExcelAddress addr = new ExcelAddress (fullAddress);  	if (localSheetID > -1) {  		if (string.IsNullOrEmpty (addr._ws)) {  			namedRange = Worksheets [localSheetID + 1].Names.Add (elem.GetAttribute ("name")' new ExcelRangeBase (this' Worksheets [localSheetID + 1]' fullAddress' false));  		}  		else {  			namedRange = Worksheets [localSheetID + 1].Names.Add (elem.GetAttribute ("name")' new ExcelRangeBase (this' Worksheets [addr._ws]' fullAddress' false));  		}  	}  	else {  		var ws = Worksheets [addr._ws];  		namedRange = _names.Add (elem.GetAttribute ("name")' new ExcelRangeBase (this' ws' fullAddress' false));  	}  }  
Magic Number,OfficeOpenXml,ExcelWorkbook,C:\repos\bambit_EPPlus\EPPlus\ExcelWorkbook.cs,GetDefinedNames,The following statement contains a magic number: if (fullAddress.StartsWith ("\""))//String value   {  	namedRange.NameValue = fullAddress.Substring (1' fullAddress.Length - 2);  }  else if (double.TryParse (fullAddress' NumberStyles.Any' CultureInfo.InvariantCulture' out value)) {  	namedRange.NameValue = value;  }  else {  	namedRange.NameFormula = fullAddress;  }  
Magic Number,OfficeOpenXml,ExcelWorkbook,C:\repos\bambit_EPPlus\EPPlus\ExcelWorkbook.cs,GetDefinedNames,The following statement contains a magic number: namedRange.NameValue = fullAddress.Substring (1' fullAddress.Length - 2);  
Magic Number,OfficeOpenXml,ExcelWorkbook,C:\repos\bambit_EPPlus\EPPlus\ExcelWorkbook.cs,ExcelEncodeString,The following statement contains a magic number: if (Regex.IsMatch (t' "(_x[0-9A-F]{4'4}_)")) {  	var match = Regex.Match (t' "(_x[0-9A-F]{4'4}_)");  	int indexAdd = 0;  	while (match.Success) {  		t = t.Insert (match.Index + indexAdd' "_x005F");  		indexAdd += 6;  		match = match.NextMatch ();  	}  }  
Magic Number,OfficeOpenXml,ExcelWorkbook,C:\repos\bambit_EPPlus\EPPlus\ExcelWorkbook.cs,ExcelEncodeString,The following statement contains a magic number: while (match.Success) {  	t = t.Insert (match.Index + indexAdd' "_x005F");  	indexAdd += 6;  	match = match.NextMatch ();  }  
Magic Number,OfficeOpenXml,ExcelWorkbook,C:\repos\bambit_EPPlus\EPPlus\ExcelWorkbook.cs,ExcelEncodeString,The following statement contains a magic number: indexAdd += 6;  
Magic Number,OfficeOpenXml,ExcelWorkbook,C:\repos\bambit_EPPlus\EPPlus\ExcelWorkbook.cs,ExcelDecodeString,The following statement contains a magic number: while (match.Success) {  	if (prevIndex < match.Index)  		ret.Append (t.Substring (prevIndex' match.Index - prevIndex));  	if (!useNextValue && match.Value == "_x005F") {  		useNextValue = true;  	}  	else {  		if (useNextValue) {  			ret.Append (match.Value);  			useNextValue = false;  		}  		else {  			ret.Append ((char)int.Parse (match.Value.Substring (2' 4)' NumberStyles.AllowHexSpecifier));  		}  	}  	prevIndex = match.Index + match.Length;  	match = match.NextMatch ();  }  
Magic Number,OfficeOpenXml,ExcelWorkbook,C:\repos\bambit_EPPlus\EPPlus\ExcelWorkbook.cs,ExcelDecodeString,The following statement contains a magic number: while (match.Success) {  	if (prevIndex < match.Index)  		ret.Append (t.Substring (prevIndex' match.Index - prevIndex));  	if (!useNextValue && match.Value == "_x005F") {  		useNextValue = true;  	}  	else {  		if (useNextValue) {  			ret.Append (match.Value);  			useNextValue = false;  		}  		else {  			ret.Append ((char)int.Parse (match.Value.Substring (2' 4)' NumberStyles.AllowHexSpecifier));  		}  	}  	prevIndex = match.Index + match.Length;  	match = match.NextMatch ();  }  
Magic Number,OfficeOpenXml,ExcelWorkbook,C:\repos\bambit_EPPlus\EPPlus\ExcelWorkbook.cs,ExcelDecodeString,The following statement contains a magic number: if (!useNextValue && match.Value == "_x005F") {  	useNextValue = true;  }  else {  	if (useNextValue) {  		ret.Append (match.Value);  		useNextValue = false;  	}  	else {  		ret.Append ((char)int.Parse (match.Value.Substring (2' 4)' NumberStyles.AllowHexSpecifier));  	}  }  
Magic Number,OfficeOpenXml,ExcelWorkbook,C:\repos\bambit_EPPlus\EPPlus\ExcelWorkbook.cs,ExcelDecodeString,The following statement contains a magic number: if (!useNextValue && match.Value == "_x005F") {  	useNextValue = true;  }  else {  	if (useNextValue) {  		ret.Append (match.Value);  		useNextValue = false;  	}  	else {  		ret.Append ((char)int.Parse (match.Value.Substring (2' 4)' NumberStyles.AllowHexSpecifier));  	}  }  
Magic Number,OfficeOpenXml,ExcelWorkbook,C:\repos\bambit_EPPlus\EPPlus\ExcelWorkbook.cs,ExcelDecodeString,The following statement contains a magic number: if (useNextValue) {  	ret.Append (match.Value);  	useNextValue = false;  }  else {  	ret.Append ((char)int.Parse (match.Value.Substring (2' 4)' NumberStyles.AllowHexSpecifier));  }  
Magic Number,OfficeOpenXml,ExcelWorkbook,C:\repos\bambit_EPPlus\EPPlus\ExcelWorkbook.cs,ExcelDecodeString,The following statement contains a magic number: if (useNextValue) {  	ret.Append (match.Value);  	useNextValue = false;  }  else {  	ret.Append ((char)int.Parse (match.Value.Substring (2' 4)' NumberStyles.AllowHexSpecifier));  }  
Magic Number,OfficeOpenXml,ExcelWorkbook,C:\repos\bambit_EPPlus\EPPlus\ExcelWorkbook.cs,ExcelDecodeString,The following statement contains a magic number: ret.Append ((char)int.Parse (match.Value.Substring (2' 4)' NumberStyles.AllowHexSpecifier));  
Magic Number,OfficeOpenXml,ExcelWorkbook,C:\repos\bambit_EPPlus\EPPlus\ExcelWorkbook.cs,ExcelDecodeString,The following statement contains a magic number: ret.Append ((char)int.Parse (match.Value.Substring (2' 4)' NumberStyles.AllowHexSpecifier));  
Magic Number,OfficeOpenXml,ExcelWorksheet,C:\repos\bambit_EPPlus\EPPlus\ExcelWorksheet.cs,GetWorkSheetXml,The following statement contains a magic number: do {  	int size = stream.Length < BLOCKSIZE ? (int)stream.Length : BLOCKSIZE;  	block = new char[size];  	pos = sr.ReadBlock (block' 0' size);  	sb.Append (block' 0' pos);  	length += size;  }  while (length < start + 20 && length < end);  
Magic Number,OfficeOpenXml,ExcelWorksheet,C:\repos\bambit_EPPlus\EPPlus\ExcelWorksheet.cs,GetWorkSheetXml,The following statement contains a magic number: if (!startmMatch.Success)//Not found   {  	encoding = sr.CurrentEncoding;  	return sb.ToString ();  }  else {  	string s = sb.ToString ();  	string xml = s.Substring (0' startmMatch.Index);  	if (startmMatch.Value.EndsWith ("/>")) {  		xml += s.Substring (startmMatch.Index' s.Length - startmMatch.Index);  	}  	else {  		if (sr.Peek () != -1) {  			if (end - BLOCKSIZE > 0) {  				long endSeekStart = end - BLOCKSIZE - 4096 < 0 ? 0 : (end - BLOCKSIZE - 4096);  				stream.Seek (endSeekStart' SeekOrigin.Begin);  				int size = (int)(stream.Length - endSeekStart);  				block = new char[size];  				sr = new StreamReader (stream);  				pos = sr.ReadBlock (block' 0' size);  				sb = new StringBuilder ();  				sb.Append (block' 0' pos);  				s = sb.ToString ();  			}  		}  		endMatch = Regex.Match (s' string.Format ("(</[^>]*{0}[^>]*>)"' "sheetData"));  		xml += "<sheetData/>" + s.Substring (endMatch.Index + endMatch.Length' s.Length - (endMatch.Index + endMatch.Length));  	}  	if (sr.Peek () > -1) {  		xml += sr.ReadToEnd ();  	}  	encoding = sr.CurrentEncoding;  	return xml;  }  
Magic Number,OfficeOpenXml,ExcelWorksheet,C:\repos\bambit_EPPlus\EPPlus\ExcelWorksheet.cs,GetWorkSheetXml,The following statement contains a magic number: if (!startmMatch.Success)//Not found   {  	encoding = sr.CurrentEncoding;  	return sb.ToString ();  }  else {  	string s = sb.ToString ();  	string xml = s.Substring (0' startmMatch.Index);  	if (startmMatch.Value.EndsWith ("/>")) {  		xml += s.Substring (startmMatch.Index' s.Length - startmMatch.Index);  	}  	else {  		if (sr.Peek () != -1) {  			if (end - BLOCKSIZE > 0) {  				long endSeekStart = end - BLOCKSIZE - 4096 < 0 ? 0 : (end - BLOCKSIZE - 4096);  				stream.Seek (endSeekStart' SeekOrigin.Begin);  				int size = (int)(stream.Length - endSeekStart);  				block = new char[size];  				sr = new StreamReader (stream);  				pos = sr.ReadBlock (block' 0' size);  				sb = new StringBuilder ();  				sb.Append (block' 0' pos);  				s = sb.ToString ();  			}  		}  		endMatch = Regex.Match (s' string.Format ("(</[^>]*{0}[^>]*>)"' "sheetData"));  		xml += "<sheetData/>" + s.Substring (endMatch.Index + endMatch.Length' s.Length - (endMatch.Index + endMatch.Length));  	}  	if (sr.Peek () > -1) {  		xml += sr.ReadToEnd ();  	}  	encoding = sr.CurrentEncoding;  	return xml;  }  
Magic Number,OfficeOpenXml,ExcelWorksheet,C:\repos\bambit_EPPlus\EPPlus\ExcelWorksheet.cs,GetWorkSheetXml,The following statement contains a magic number: if (startmMatch.Value.EndsWith ("/>")) {  	xml += s.Substring (startmMatch.Index' s.Length - startmMatch.Index);  }  else {  	if (sr.Peek () != -1) {  		if (end - BLOCKSIZE > 0) {  			long endSeekStart = end - BLOCKSIZE - 4096 < 0 ? 0 : (end - BLOCKSIZE - 4096);  			stream.Seek (endSeekStart' SeekOrigin.Begin);  			int size = (int)(stream.Length - endSeekStart);  			block = new char[size];  			sr = new StreamReader (stream);  			pos = sr.ReadBlock (block' 0' size);  			sb = new StringBuilder ();  			sb.Append (block' 0' pos);  			s = sb.ToString ();  		}  	}  	endMatch = Regex.Match (s' string.Format ("(</[^>]*{0}[^>]*>)"' "sheetData"));  	xml += "<sheetData/>" + s.Substring (endMatch.Index + endMatch.Length' s.Length - (endMatch.Index + endMatch.Length));  }  
Magic Number,OfficeOpenXml,ExcelWorksheet,C:\repos\bambit_EPPlus\EPPlus\ExcelWorksheet.cs,GetWorkSheetXml,The following statement contains a magic number: if (startmMatch.Value.EndsWith ("/>")) {  	xml += s.Substring (startmMatch.Index' s.Length - startmMatch.Index);  }  else {  	if (sr.Peek () != -1) {  		if (end - BLOCKSIZE > 0) {  			long endSeekStart = end - BLOCKSIZE - 4096 < 0 ? 0 : (end - BLOCKSIZE - 4096);  			stream.Seek (endSeekStart' SeekOrigin.Begin);  			int size = (int)(stream.Length - endSeekStart);  			block = new char[size];  			sr = new StreamReader (stream);  			pos = sr.ReadBlock (block' 0' size);  			sb = new StringBuilder ();  			sb.Append (block' 0' pos);  			s = sb.ToString ();  		}  	}  	endMatch = Regex.Match (s' string.Format ("(</[^>]*{0}[^>]*>)"' "sheetData"));  	xml += "<sheetData/>" + s.Substring (endMatch.Index + endMatch.Length' s.Length - (endMatch.Index + endMatch.Length));  }  
Magic Number,OfficeOpenXml,ExcelWorksheet,C:\repos\bambit_EPPlus\EPPlus\ExcelWorksheet.cs,GetWorkSheetXml,The following statement contains a magic number: if (sr.Peek () != -1) {  	if (end - BLOCKSIZE > 0) {  		long endSeekStart = end - BLOCKSIZE - 4096 < 0 ? 0 : (end - BLOCKSIZE - 4096);  		stream.Seek (endSeekStart' SeekOrigin.Begin);  		int size = (int)(stream.Length - endSeekStart);  		block = new char[size];  		sr = new StreamReader (stream);  		pos = sr.ReadBlock (block' 0' size);  		sb = new StringBuilder ();  		sb.Append (block' 0' pos);  		s = sb.ToString ();  	}  }  
Magic Number,OfficeOpenXml,ExcelWorksheet,C:\repos\bambit_EPPlus\EPPlus\ExcelWorksheet.cs,GetWorkSheetXml,The following statement contains a magic number: if (sr.Peek () != -1) {  	if (end - BLOCKSIZE > 0) {  		long endSeekStart = end - BLOCKSIZE - 4096 < 0 ? 0 : (end - BLOCKSIZE - 4096);  		stream.Seek (endSeekStart' SeekOrigin.Begin);  		int size = (int)(stream.Length - endSeekStart);  		block = new char[size];  		sr = new StreamReader (stream);  		pos = sr.ReadBlock (block' 0' size);  		sb = new StringBuilder ();  		sb.Append (block' 0' pos);  		s = sb.ToString ();  	}  }  
Magic Number,OfficeOpenXml,ExcelWorksheet,C:\repos\bambit_EPPlus\EPPlus\ExcelWorksheet.cs,GetWorkSheetXml,The following statement contains a magic number: if (end - BLOCKSIZE > 0) {  	long endSeekStart = end - BLOCKSIZE - 4096 < 0 ? 0 : (end - BLOCKSIZE - 4096);  	stream.Seek (endSeekStart' SeekOrigin.Begin);  	int size = (int)(stream.Length - endSeekStart);  	block = new char[size];  	sr = new StreamReader (stream);  	pos = sr.ReadBlock (block' 0' size);  	sb = new StringBuilder ();  	sb.Append (block' 0' pos);  	s = sb.ToString ();  }  
Magic Number,OfficeOpenXml,ExcelWorksheet,C:\repos\bambit_EPPlus\EPPlus\ExcelWorksheet.cs,GetWorkSheetXml,The following statement contains a magic number: if (end - BLOCKSIZE > 0) {  	long endSeekStart = end - BLOCKSIZE - 4096 < 0 ? 0 : (end - BLOCKSIZE - 4096);  	stream.Seek (endSeekStart' SeekOrigin.Begin);  	int size = (int)(stream.Length - endSeekStart);  	block = new char[size];  	sr = new StreamReader (stream);  	pos = sr.ReadBlock (block' 0' size);  	sb = new StringBuilder ();  	sb.Append (block' 0' pos);  	s = sb.ToString ();  }  
Magic Number,OfficeOpenXml,ExcelWorksheet,C:\repos\bambit_EPPlus\EPPlus\ExcelWorksheet.cs,GetBlockPos,The following statement contains a magic number: if (startmMatch.Value.Substring (startmMatch.Value.Length - 2' 1) == "/") {  	end = startPos + startmMatch.Length;  }  else {  	endMatch = Regex.Match (xml.Substring (start)' string.Format ("(</[^>]*{0}[^>]*>)"' tag));  	if (endMatch.Success) {  		end = endMatch.Index + endMatch.Length + start;  	}  }  
Magic Number,OfficeOpenXml,ExcelWorksheet,C:\repos\bambit_EPPlus\EPPlus\ExcelWorksheet.cs,LoadCells,The following statement contains a magic number: while (!xr.EOF) {  	while (xr.NodeType == XmlNodeType.EndElement) {  		xr.Read ();  	}  	if (xr.LocalName == "row") {  		int row = Convert.ToInt32 (xr.GetAttribute ("r"));  		if (xr.AttributeCount > 2 || (xr.AttributeCount == 2 && xr.GetAttribute ("spans") != null)) {  			rowList.Add (AddRow (xr' row));  		}  		xr.Read ();  	}  	else if (xr.LocalName == "c") {  		if (cell != null)  			cellList.Add (cell);  		cell = new ExcelCell (this' xr.GetAttribute ("r"));  		if (xr.GetAttribute ("t") != null)  			cell.DataType = xr.GetAttribute ("t");  		cell.StyleID = xr.GetAttribute ("s") == null ? 0 : int.Parse (xr.GetAttribute ("s"));  		xr.Read ();  	}  	else if (xr.LocalName == "v") {  		cell._value = GetValueFromXml (cell' xr);  		xr.Read ();  	}  	else if (xr.LocalName == "f") {  		string t = xr.GetAttribute ("t");  		if (t == null) {  			cell._formula = xr.ReadElementContentAsString ();  			formulaList.Add (cell);  		}  		else if (t == "shared") {  			string si = xr.GetAttribute ("si");  			if (si != null) {  				cell._sharedFormulaID = int.Parse (si);  				string address = xr.GetAttribute ("ref");  				string formula = xr.ReadElementContentAsString ();  				if (formula != "") {  					_sharedFormulas.Add (cell.SharedFormulaID' new Formulas () {  						Index = cell.SharedFormulaID'  						Formula = formula'  						Address = address'  						StartRow = cell.Row'  						StartCol = cell.Column  					});  				}  			}  			else {  				xr.Read ();  				//Something is wrong in the sheet' read next  			}  		}  		else if (t == "array")//TODO: Array functions are not support yet. Read the formula for the start cell only.  		 {  			string address = xr.GetAttribute ("ref");  			cell._formula = xr.ReadElementContentAsString ();  			cell._sharedFormulaID = GetMaxShareFunctionIndex (true);  			//We use the shared formula id here' just so we can use the same dictionary for both Array and Shared forulas.  			_sharedFormulas.Add (cell._sharedFormulaID' new Formulas () {  				Index = cell._sharedFormulaID'  				Formula = cell._formula'  				Address = address'  				StartRow = cell.Row'  				StartCol = cell.Column'  				IsArray = true  			});  		}  		else// ??? some other type  		 {  			xr.Read ();  			//Something is wrong in the sheet' read next  		}  	}  	else if (xr.LocalName == "is")//Inline string  	 {  		xr.Read ();  		if (xr.LocalName == "t") {  			cell._value = xr.ReadInnerXml ();  		}  		else {  			cell._value = xr.ReadOuterXml ();  			cell.IsRichText = true;  		}  	}  	else {  		break;  	}  }  
Magic Number,OfficeOpenXml,ExcelWorksheet,C:\repos\bambit_EPPlus\EPPlus\ExcelWorksheet.cs,LoadCells,The following statement contains a magic number: while (!xr.EOF) {  	while (xr.NodeType == XmlNodeType.EndElement) {  		xr.Read ();  	}  	if (xr.LocalName == "row") {  		int row = Convert.ToInt32 (xr.GetAttribute ("r"));  		if (xr.AttributeCount > 2 || (xr.AttributeCount == 2 && xr.GetAttribute ("spans") != null)) {  			rowList.Add (AddRow (xr' row));  		}  		xr.Read ();  	}  	else if (xr.LocalName == "c") {  		if (cell != null)  			cellList.Add (cell);  		cell = new ExcelCell (this' xr.GetAttribute ("r"));  		if (xr.GetAttribute ("t") != null)  			cell.DataType = xr.GetAttribute ("t");  		cell.StyleID = xr.GetAttribute ("s") == null ? 0 : int.Parse (xr.GetAttribute ("s"));  		xr.Read ();  	}  	else if (xr.LocalName == "v") {  		cell._value = GetValueFromXml (cell' xr);  		xr.Read ();  	}  	else if (xr.LocalName == "f") {  		string t = xr.GetAttribute ("t");  		if (t == null) {  			cell._formula = xr.ReadElementContentAsString ();  			formulaList.Add (cell);  		}  		else if (t == "shared") {  			string si = xr.GetAttribute ("si");  			if (si != null) {  				cell._sharedFormulaID = int.Parse (si);  				string address = xr.GetAttribute ("ref");  				string formula = xr.ReadElementContentAsString ();  				if (formula != "") {  					_sharedFormulas.Add (cell.SharedFormulaID' new Formulas () {  						Index = cell.SharedFormulaID'  						Formula = formula'  						Address = address'  						StartRow = cell.Row'  						StartCol = cell.Column  					});  				}  			}  			else {  				xr.Read ();  				//Something is wrong in the sheet' read next  			}  		}  		else if (t == "array")//TODO: Array functions are not support yet. Read the formula for the start cell only.  		 {  			string address = xr.GetAttribute ("ref");  			cell._formula = xr.ReadElementContentAsString ();  			cell._sharedFormulaID = GetMaxShareFunctionIndex (true);  			//We use the shared formula id here' just so we can use the same dictionary for both Array and Shared forulas.  			_sharedFormulas.Add (cell._sharedFormulaID' new Formulas () {  				Index = cell._sharedFormulaID'  				Formula = cell._formula'  				Address = address'  				StartRow = cell.Row'  				StartCol = cell.Column'  				IsArray = true  			});  		}  		else// ??? some other type  		 {  			xr.Read ();  			//Something is wrong in the sheet' read next  		}  	}  	else if (xr.LocalName == "is")//Inline string  	 {  		xr.Read ();  		if (xr.LocalName == "t") {  			cell._value = xr.ReadInnerXml ();  		}  		else {  			cell._value = xr.ReadOuterXml ();  			cell.IsRichText = true;  		}  	}  	else {  		break;  	}  }  
Magic Number,OfficeOpenXml,ExcelWorksheet,C:\repos\bambit_EPPlus\EPPlus\ExcelWorksheet.cs,LoadCells,The following statement contains a magic number: if (xr.LocalName == "row") {  	int row = Convert.ToInt32 (xr.GetAttribute ("r"));  	if (xr.AttributeCount > 2 || (xr.AttributeCount == 2 && xr.GetAttribute ("spans") != null)) {  		rowList.Add (AddRow (xr' row));  	}  	xr.Read ();  }  else if (xr.LocalName == "c") {  	if (cell != null)  		cellList.Add (cell);  	cell = new ExcelCell (this' xr.GetAttribute ("r"));  	if (xr.GetAttribute ("t") != null)  		cell.DataType = xr.GetAttribute ("t");  	cell.StyleID = xr.GetAttribute ("s") == null ? 0 : int.Parse (xr.GetAttribute ("s"));  	xr.Read ();  }  else if (xr.LocalName == "v") {  	cell._value = GetValueFromXml (cell' xr);  	xr.Read ();  }  else if (xr.LocalName == "f") {  	string t = xr.GetAttribute ("t");  	if (t == null) {  		cell._formula = xr.ReadElementContentAsString ();  		formulaList.Add (cell);  	}  	else if (t == "shared") {  		string si = xr.GetAttribute ("si");  		if (si != null) {  			cell._sharedFormulaID = int.Parse (si);  			string address = xr.GetAttribute ("ref");  			string formula = xr.ReadElementContentAsString ();  			if (formula != "") {  				_sharedFormulas.Add (cell.SharedFormulaID' new Formulas () {  					Index = cell.SharedFormulaID'  					Formula = formula'  					Address = address'  					StartRow = cell.Row'  					StartCol = cell.Column  				});  			}  		}  		else {  			xr.Read ();  			//Something is wrong in the sheet' read next  		}  	}  	else if (t == "array")//TODO: Array functions are not support yet. Read the formula for the start cell only.  	 {  		string address = xr.GetAttribute ("ref");  		cell._formula = xr.ReadElementContentAsString ();  		cell._sharedFormulaID = GetMaxShareFunctionIndex (true);  		//We use the shared formula id here' just so we can use the same dictionary for both Array and Shared forulas.  		_sharedFormulas.Add (cell._sharedFormulaID' new Formulas () {  			Index = cell._sharedFormulaID'  			Formula = cell._formula'  			Address = address'  			StartRow = cell.Row'  			StartCol = cell.Column'  			IsArray = true  		});  	}  	else// ??? some other type  	 {  		xr.Read ();  		//Something is wrong in the sheet' read next  	}  }  else if (xr.LocalName == "is")//Inline string   {  	xr.Read ();  	if (xr.LocalName == "t") {  		cell._value = xr.ReadInnerXml ();  	}  	else {  		cell._value = xr.ReadOuterXml ();  		cell.IsRichText = true;  	}  }  else {  	break;  }  
Magic Number,OfficeOpenXml,ExcelWorksheet,C:\repos\bambit_EPPlus\EPPlus\ExcelWorksheet.cs,LoadCells,The following statement contains a magic number: if (xr.LocalName == "row") {  	int row = Convert.ToInt32 (xr.GetAttribute ("r"));  	if (xr.AttributeCount > 2 || (xr.AttributeCount == 2 && xr.GetAttribute ("spans") != null)) {  		rowList.Add (AddRow (xr' row));  	}  	xr.Read ();  }  else if (xr.LocalName == "c") {  	if (cell != null)  		cellList.Add (cell);  	cell = new ExcelCell (this' xr.GetAttribute ("r"));  	if (xr.GetAttribute ("t") != null)  		cell.DataType = xr.GetAttribute ("t");  	cell.StyleID = xr.GetAttribute ("s") == null ? 0 : int.Parse (xr.GetAttribute ("s"));  	xr.Read ();  }  else if (xr.LocalName == "v") {  	cell._value = GetValueFromXml (cell' xr);  	xr.Read ();  }  else if (xr.LocalName == "f") {  	string t = xr.GetAttribute ("t");  	if (t == null) {  		cell._formula = xr.ReadElementContentAsString ();  		formulaList.Add (cell);  	}  	else if (t == "shared") {  		string si = xr.GetAttribute ("si");  		if (si != null) {  			cell._sharedFormulaID = int.Parse (si);  			string address = xr.GetAttribute ("ref");  			string formula = xr.ReadElementContentAsString ();  			if (formula != "") {  				_sharedFormulas.Add (cell.SharedFormulaID' new Formulas () {  					Index = cell.SharedFormulaID'  					Formula = formula'  					Address = address'  					StartRow = cell.Row'  					StartCol = cell.Column  				});  			}  		}  		else {  			xr.Read ();  			//Something is wrong in the sheet' read next  		}  	}  	else if (t == "array")//TODO: Array functions are not support yet. Read the formula for the start cell only.  	 {  		string address = xr.GetAttribute ("ref");  		cell._formula = xr.ReadElementContentAsString ();  		cell._sharedFormulaID = GetMaxShareFunctionIndex (true);  		//We use the shared formula id here' just so we can use the same dictionary for both Array and Shared forulas.  		_sharedFormulas.Add (cell._sharedFormulaID' new Formulas () {  			Index = cell._sharedFormulaID'  			Formula = cell._formula'  			Address = address'  			StartRow = cell.Row'  			StartCol = cell.Column'  			IsArray = true  		});  	}  	else// ??? some other type  	 {  		xr.Read ();  		//Something is wrong in the sheet' read next  	}  }  else if (xr.LocalName == "is")//Inline string   {  	xr.Read ();  	if (xr.LocalName == "t") {  		cell._value = xr.ReadInnerXml ();  	}  	else {  		cell._value = xr.ReadOuterXml ();  		cell.IsRichText = true;  	}  }  else {  	break;  }  
Magic Number,OfficeOpenXml,ExcelWorksheet,C:\repos\bambit_EPPlus\EPPlus\ExcelWorksheet.cs,LoadCells,The following statement contains a magic number: if (xr.AttributeCount > 2 || (xr.AttributeCount == 2 && xr.GetAttribute ("spans") != null)) {  	rowList.Add (AddRow (xr' row));  }  
Magic Number,OfficeOpenXml,ExcelWorksheet,C:\repos\bambit_EPPlus\EPPlus\ExcelWorksheet.cs,LoadCells,The following statement contains a magic number: if (xr.AttributeCount > 2 || (xr.AttributeCount == 2 && xr.GetAttribute ("spans") != null)) {  	rowList.Add (AddRow (xr' row));  }  
Magic Number,OfficeOpenXml,ExcelWorksheet,C:\repos\bambit_EPPlus\EPPlus\ExcelWorksheet.cs,GetValueFromXml,The following statement contains a magic number: if (cell.DataType == "s") {  	int ix = xr.ReadElementContentAsInt ();  	value = _package.Workbook._sharedStringsList [ix].Text;  	cell.IsRichText = _package.Workbook._sharedStringsList [ix].isRichText;  }  else if (cell.DataType == "str") {  	value = xr.ReadElementContentAsString ();  }  else if (cell.DataType == "b") {  	value = (xr.ReadElementContentAsString () != "0");  }  else {  	int n = cell.Style.Numberformat.NumFmtID;  	string v = xr.ReadElementContentAsString ();  	if ((n >= 14 && n <= 22) || (n >= 45 && n <= 47)) {  		double res;  		if (double.TryParse (v' NumberStyles.Any' CultureInfo.InvariantCulture' out res)) {  			value = DateTime.FromOADate (res);  		}  		else {  			value = "";  		}  	}  	else {  		double d;  		if (double.TryParse (v' NumberStyles.Any' CultureInfo.InvariantCulture' out d)) {  			value = d;  		}  		else {  			value = double.NaN;  		}  	}  }  
Magic Number,OfficeOpenXml,ExcelWorksheet,C:\repos\bambit_EPPlus\EPPlus\ExcelWorksheet.cs,GetValueFromXml,The following statement contains a magic number: if (cell.DataType == "s") {  	int ix = xr.ReadElementContentAsInt ();  	value = _package.Workbook._sharedStringsList [ix].Text;  	cell.IsRichText = _package.Workbook._sharedStringsList [ix].isRichText;  }  else if (cell.DataType == "str") {  	value = xr.ReadElementContentAsString ();  }  else if (cell.DataType == "b") {  	value = (xr.ReadElementContentAsString () != "0");  }  else {  	int n = cell.Style.Numberformat.NumFmtID;  	string v = xr.ReadElementContentAsString ();  	if ((n >= 14 && n <= 22) || (n >= 45 && n <= 47)) {  		double res;  		if (double.TryParse (v' NumberStyles.Any' CultureInfo.InvariantCulture' out res)) {  			value = DateTime.FromOADate (res);  		}  		else {  			value = "";  		}  	}  	else {  		double d;  		if (double.TryParse (v' NumberStyles.Any' CultureInfo.InvariantCulture' out d)) {  			value = d;  		}  		else {  			value = double.NaN;  		}  	}  }  
Magic Number,OfficeOpenXml,ExcelWorksheet,C:\repos\bambit_EPPlus\EPPlus\ExcelWorksheet.cs,GetValueFromXml,The following statement contains a magic number: if (cell.DataType == "s") {  	int ix = xr.ReadElementContentAsInt ();  	value = _package.Workbook._sharedStringsList [ix].Text;  	cell.IsRichText = _package.Workbook._sharedStringsList [ix].isRichText;  }  else if (cell.DataType == "str") {  	value = xr.ReadElementContentAsString ();  }  else if (cell.DataType == "b") {  	value = (xr.ReadElementContentAsString () != "0");  }  else {  	int n = cell.Style.Numberformat.NumFmtID;  	string v = xr.ReadElementContentAsString ();  	if ((n >= 14 && n <= 22) || (n >= 45 && n <= 47)) {  		double res;  		if (double.TryParse (v' NumberStyles.Any' CultureInfo.InvariantCulture' out res)) {  			value = DateTime.FromOADate (res);  		}  		else {  			value = "";  		}  	}  	else {  		double d;  		if (double.TryParse (v' NumberStyles.Any' CultureInfo.InvariantCulture' out d)) {  			value = d;  		}  		else {  			value = double.NaN;  		}  	}  }  
Magic Number,OfficeOpenXml,ExcelWorksheet,C:\repos\bambit_EPPlus\EPPlus\ExcelWorksheet.cs,GetValueFromXml,The following statement contains a magic number: if (cell.DataType == "s") {  	int ix = xr.ReadElementContentAsInt ();  	value = _package.Workbook._sharedStringsList [ix].Text;  	cell.IsRichText = _package.Workbook._sharedStringsList [ix].isRichText;  }  else if (cell.DataType == "str") {  	value = xr.ReadElementContentAsString ();  }  else if (cell.DataType == "b") {  	value = (xr.ReadElementContentAsString () != "0");  }  else {  	int n = cell.Style.Numberformat.NumFmtID;  	string v = xr.ReadElementContentAsString ();  	if ((n >= 14 && n <= 22) || (n >= 45 && n <= 47)) {  		double res;  		if (double.TryParse (v' NumberStyles.Any' CultureInfo.InvariantCulture' out res)) {  			value = DateTime.FromOADate (res);  		}  		else {  			value = "";  		}  	}  	else {  		double d;  		if (double.TryParse (v' NumberStyles.Any' CultureInfo.InvariantCulture' out d)) {  			value = d;  		}  		else {  			value = double.NaN;  		}  	}  }  
Magic Number,OfficeOpenXml,ExcelWorksheet,C:\repos\bambit_EPPlus\EPPlus\ExcelWorksheet.cs,GetValueFromXml,The following statement contains a magic number: if (cell.DataType == "str") {  	value = xr.ReadElementContentAsString ();  }  else if (cell.DataType == "b") {  	value = (xr.ReadElementContentAsString () != "0");  }  else {  	int n = cell.Style.Numberformat.NumFmtID;  	string v = xr.ReadElementContentAsString ();  	if ((n >= 14 && n <= 22) || (n >= 45 && n <= 47)) {  		double res;  		if (double.TryParse (v' NumberStyles.Any' CultureInfo.InvariantCulture' out res)) {  			value = DateTime.FromOADate (res);  		}  		else {  			value = "";  		}  	}  	else {  		double d;  		if (double.TryParse (v' NumberStyles.Any' CultureInfo.InvariantCulture' out d)) {  			value = d;  		}  		else {  			value = double.NaN;  		}  	}  }  
Magic Number,OfficeOpenXml,ExcelWorksheet,C:\repos\bambit_EPPlus\EPPlus\ExcelWorksheet.cs,GetValueFromXml,The following statement contains a magic number: if (cell.DataType == "str") {  	value = xr.ReadElementContentAsString ();  }  else if (cell.DataType == "b") {  	value = (xr.ReadElementContentAsString () != "0");  }  else {  	int n = cell.Style.Numberformat.NumFmtID;  	string v = xr.ReadElementContentAsString ();  	if ((n >= 14 && n <= 22) || (n >= 45 && n <= 47)) {  		double res;  		if (double.TryParse (v' NumberStyles.Any' CultureInfo.InvariantCulture' out res)) {  			value = DateTime.FromOADate (res);  		}  		else {  			value = "";  		}  	}  	else {  		double d;  		if (double.TryParse (v' NumberStyles.Any' CultureInfo.InvariantCulture' out d)) {  			value = d;  		}  		else {  			value = double.NaN;  		}  	}  }  
Magic Number,OfficeOpenXml,ExcelWorksheet,C:\repos\bambit_EPPlus\EPPlus\ExcelWorksheet.cs,GetValueFromXml,The following statement contains a magic number: if (cell.DataType == "str") {  	value = xr.ReadElementContentAsString ();  }  else if (cell.DataType == "b") {  	value = (xr.ReadElementContentAsString () != "0");  }  else {  	int n = cell.Style.Numberformat.NumFmtID;  	string v = xr.ReadElementContentAsString ();  	if ((n >= 14 && n <= 22) || (n >= 45 && n <= 47)) {  		double res;  		if (double.TryParse (v' NumberStyles.Any' CultureInfo.InvariantCulture' out res)) {  			value = DateTime.FromOADate (res);  		}  		else {  			value = "";  		}  	}  	else {  		double d;  		if (double.TryParse (v' NumberStyles.Any' CultureInfo.InvariantCulture' out d)) {  			value = d;  		}  		else {  			value = double.NaN;  		}  	}  }  
Magic Number,OfficeOpenXml,ExcelWorksheet,C:\repos\bambit_EPPlus\EPPlus\ExcelWorksheet.cs,GetValueFromXml,The following statement contains a magic number: if (cell.DataType == "str") {  	value = xr.ReadElementContentAsString ();  }  else if (cell.DataType == "b") {  	value = (xr.ReadElementContentAsString () != "0");  }  else {  	int n = cell.Style.Numberformat.NumFmtID;  	string v = xr.ReadElementContentAsString ();  	if ((n >= 14 && n <= 22) || (n >= 45 && n <= 47)) {  		double res;  		if (double.TryParse (v' NumberStyles.Any' CultureInfo.InvariantCulture' out res)) {  			value = DateTime.FromOADate (res);  		}  		else {  			value = "";  		}  	}  	else {  		double d;  		if (double.TryParse (v' NumberStyles.Any' CultureInfo.InvariantCulture' out d)) {  			value = d;  		}  		else {  			value = double.NaN;  		}  	}  }  
Magic Number,OfficeOpenXml,ExcelWorksheet,C:\repos\bambit_EPPlus\EPPlus\ExcelWorksheet.cs,GetValueFromXml,The following statement contains a magic number: if (cell.DataType == "b") {  	value = (xr.ReadElementContentAsString () != "0");  }  else {  	int n = cell.Style.Numberformat.NumFmtID;  	string v = xr.ReadElementContentAsString ();  	if ((n >= 14 && n <= 22) || (n >= 45 && n <= 47)) {  		double res;  		if (double.TryParse (v' NumberStyles.Any' CultureInfo.InvariantCulture' out res)) {  			value = DateTime.FromOADate (res);  		}  		else {  			value = "";  		}  	}  	else {  		double d;  		if (double.TryParse (v' NumberStyles.Any' CultureInfo.InvariantCulture' out d)) {  			value = d;  		}  		else {  			value = double.NaN;  		}  	}  }  
Magic Number,OfficeOpenXml,ExcelWorksheet,C:\repos\bambit_EPPlus\EPPlus\ExcelWorksheet.cs,GetValueFromXml,The following statement contains a magic number: if (cell.DataType == "b") {  	value = (xr.ReadElementContentAsString () != "0");  }  else {  	int n = cell.Style.Numberformat.NumFmtID;  	string v = xr.ReadElementContentAsString ();  	if ((n >= 14 && n <= 22) || (n >= 45 && n <= 47)) {  		double res;  		if (double.TryParse (v' NumberStyles.Any' CultureInfo.InvariantCulture' out res)) {  			value = DateTime.FromOADate (res);  		}  		else {  			value = "";  		}  	}  	else {  		double d;  		if (double.TryParse (v' NumberStyles.Any' CultureInfo.InvariantCulture' out d)) {  			value = d;  		}  		else {  			value = double.NaN;  		}  	}  }  
Magic Number,OfficeOpenXml,ExcelWorksheet,C:\repos\bambit_EPPlus\EPPlus\ExcelWorksheet.cs,GetValueFromXml,The following statement contains a magic number: if (cell.DataType == "b") {  	value = (xr.ReadElementContentAsString () != "0");  }  else {  	int n = cell.Style.Numberformat.NumFmtID;  	string v = xr.ReadElementContentAsString ();  	if ((n >= 14 && n <= 22) || (n >= 45 && n <= 47)) {  		double res;  		if (double.TryParse (v' NumberStyles.Any' CultureInfo.InvariantCulture' out res)) {  			value = DateTime.FromOADate (res);  		}  		else {  			value = "";  		}  	}  	else {  		double d;  		if (double.TryParse (v' NumberStyles.Any' CultureInfo.InvariantCulture' out d)) {  			value = d;  		}  		else {  			value = double.NaN;  		}  	}  }  
Magic Number,OfficeOpenXml,ExcelWorksheet,C:\repos\bambit_EPPlus\EPPlus\ExcelWorksheet.cs,GetValueFromXml,The following statement contains a magic number: if (cell.DataType == "b") {  	value = (xr.ReadElementContentAsString () != "0");  }  else {  	int n = cell.Style.Numberformat.NumFmtID;  	string v = xr.ReadElementContentAsString ();  	if ((n >= 14 && n <= 22) || (n >= 45 && n <= 47)) {  		double res;  		if (double.TryParse (v' NumberStyles.Any' CultureInfo.InvariantCulture' out res)) {  			value = DateTime.FromOADate (res);  		}  		else {  			value = "";  		}  	}  	else {  		double d;  		if (double.TryParse (v' NumberStyles.Any' CultureInfo.InvariantCulture' out d)) {  			value = d;  		}  		else {  			value = double.NaN;  		}  	}  }  
Magic Number,OfficeOpenXml,ExcelWorksheet,C:\repos\bambit_EPPlus\EPPlus\ExcelWorksheet.cs,GetValueFromXml,The following statement contains a magic number: if ((n >= 14 && n <= 22) || (n >= 45 && n <= 47)) {  	double res;  	if (double.TryParse (v' NumberStyles.Any' CultureInfo.InvariantCulture' out res)) {  		value = DateTime.FromOADate (res);  	}  	else {  		value = "";  	}  }  else {  	double d;  	if (double.TryParse (v' NumberStyles.Any' CultureInfo.InvariantCulture' out d)) {  		value = d;  	}  	else {  		value = double.NaN;  	}  }  
Magic Number,OfficeOpenXml,ExcelWorksheet,C:\repos\bambit_EPPlus\EPPlus\ExcelWorksheet.cs,GetValueFromXml,The following statement contains a magic number: if ((n >= 14 && n <= 22) || (n >= 45 && n <= 47)) {  	double res;  	if (double.TryParse (v' NumberStyles.Any' CultureInfo.InvariantCulture' out res)) {  		value = DateTime.FromOADate (res);  	}  	else {  		value = "";  	}  }  else {  	double d;  	if (double.TryParse (v' NumberStyles.Any' CultureInfo.InvariantCulture' out d)) {  		value = d;  	}  	else {  		value = double.NaN;  	}  }  
Magic Number,OfficeOpenXml,ExcelWorksheet,C:\repos\bambit_EPPlus\EPPlus\ExcelWorksheet.cs,GetValueFromXml,The following statement contains a magic number: if ((n >= 14 && n <= 22) || (n >= 45 && n <= 47)) {  	double res;  	if (double.TryParse (v' NumberStyles.Any' CultureInfo.InvariantCulture' out res)) {  		value = DateTime.FromOADate (res);  	}  	else {  		value = "";  	}  }  else {  	double d;  	if (double.TryParse (v' NumberStyles.Any' CultureInfo.InvariantCulture' out d)) {  		value = d;  	}  	else {  		value = double.NaN;  	}  }  
Magic Number,OfficeOpenXml,ExcelWorksheet,C:\repos\bambit_EPPlus\EPPlus\ExcelWorksheet.cs,GetValueFromXml,The following statement contains a magic number: if ((n >= 14 && n <= 22) || (n >= 45 && n <= 47)) {  	double res;  	if (double.TryParse (v' NumberStyles.Any' CultureInfo.InvariantCulture' out res)) {  		value = DateTime.FromOADate (res);  	}  	else {  		value = "";  	}  }  else {  	double d;  	if (double.TryParse (v' NumberStyles.Any' CultureInfo.InvariantCulture' out d)) {  		value = d;  	}  	else {  		value = double.NaN;  	}  }  
Magic Number,OfficeOpenXml,ExcelWorksheets,C:\repos\bambit_EPPlus\EPPlus\ExcelWorksheets.cs,CopyTable,The following statement contains a magic number: foreach (var tbl in Copy.Tables) {  	string xml = tbl.TableXml.OuterXml;  	int Id = _pck.Workbook._nextTableID++;  	string name;  	if (prevName == "") {  		name = Copy.Tables.GetNewTableName ();  	}  	else {  		int ix = int.Parse (prevName.Substring (5)) + 1;  		name = string.Format ("Table{0}"' ix);  		while (_pck.Workbook.ExistsPivotTableName (name)) {  			name = string.Format ("Table{0}"' ++ix);  		}  	}  	prevName = name;  	XmlDocument xmlDoc = new XmlDocument ();  	xmlDoc.LoadXml (xml);  	xmlDoc.SelectSingleNode ("//d:table/@id"' tbl.NameSpaceManager).Value = Id.ToString ();  	xmlDoc.SelectSingleNode ("//d:table/@name"' tbl.NameSpaceManager).Value = name;  	xmlDoc.SelectSingleNode ("//d:table/@displayName"' tbl.NameSpaceManager).Value = name;  	xml = xmlDoc.OuterXml;  	var uriTbl = new Uri (string.Format ("/xl/tables/table{0}.xml"' Id)' UriKind.Relative);  	var part = _pck.Package.CreatePart (uriTbl' "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml"' _pck.Compression);  	StreamWriter streamTbl = new StreamWriter (part.GetStream (FileMode.Create' FileAccess.Write));  	streamTbl.Write (xml);  	streamTbl.Close ();  	//create the relationship and add the ID to the worksheet xml.  	var rel = added.Part.CreateRelationship (PackUriHelper.GetRelativeUri (added.WorksheetUri' uriTbl)' TargetMode.Internal' ExcelPackage.schemaRelationships + "/table");  	if (tbl.RelationshipID == null) {  		var topNode = added.WorksheetXml.SelectSingleNode ("//d:tableParts"' tbl.NameSpaceManager);  		if (topNode == null) {  			added.CreateNode ("d:tableParts");  			topNode = added.WorksheetXml.SelectSingleNode ("//d:tableParts"' tbl.NameSpaceManager);  		}  		XmlElement elem = added.WorksheetXml.CreateElement ("tablePart"' ExcelPackage.schemaMain);  		topNode.AppendChild (elem);  		elem.SetAttribute ("id"' ExcelPackage.schemaRelationships' rel.Id);  	}  	else {  		XmlAttribute relAtt;  		relAtt = added.WorksheetXml.SelectSingleNode (string.Format ("//d:tableParts/d:tablePart/@r:id[.='{0}']"' tbl.RelationshipID)' tbl.NameSpaceManager) as XmlAttribute;  		relAtt.Value = rel.Id;  	}  }  
Magic Number,OfficeOpenXml,ExcelWorksheets,C:\repos\bambit_EPPlus\EPPlus\ExcelWorksheets.cs,CopyTable,The following statement contains a magic number: if (prevName == "") {  	name = Copy.Tables.GetNewTableName ();  }  else {  	int ix = int.Parse (prevName.Substring (5)) + 1;  	name = string.Format ("Table{0}"' ix);  	while (_pck.Workbook.ExistsPivotTableName (name)) {  		name = string.Format ("Table{0}"' ++ix);  	}  }  
Magic Number,OfficeOpenXml,ExcelWorksheets,C:\repos\bambit_EPPlus\EPPlus\ExcelWorksheets.cs,CopyPivotTable,The following statement contains a magic number: foreach (var tbl in Copy.PivotTables) {  	string xml = tbl.PivotTableXml.OuterXml;  	int Id = _pck.Workbook._nextPivotTableID++;  	string name;  	if (prevName == "") {  		name = Copy.PivotTables.GetNewTableName ();  	}  	else {  		int ix = int.Parse (prevName.Substring (10)) + 1;  		name = string.Format ("PivotTable{0}"' ix);  		while (_pck.Workbook.ExistsPivotTableName (name)) {  			name = string.Format ("PivotTable{0}"' ++ix);  		}  	}  	prevName = name;  	XmlDocument xmlDoc = new XmlDocument ();  	Copy.Save ();  	//Save the worksheet first  	xmlDoc.LoadXml (xml);  	//xmlDoc.SelectSingleNode("//d:table/@id"' tbl.NameSpaceManager).Value = Id.ToString();  	xmlDoc.SelectSingleNode ("//d:pivotTableDefinition/@name"' tbl.NameSpaceManager).Value = name;  	xml = xmlDoc.OuterXml;  	var uriTbl = new Uri (string.Format ("/xl/pivotTables/pivotTable{0}.xml"' Id)' UriKind.Relative);  	var part = _pck.Package.CreatePart (uriTbl' ExcelPackage.schemaPivotTable' _pck.Compression);  	StreamWriter streamTbl = new StreamWriter (part.GetStream (FileMode.Create' FileAccess.Write));  	streamTbl.Write (xml);  	streamTbl.Close ();  	//create the relationship and add the ID to the worksheet xml.  	added.Part.CreateRelationship (PackUriHelper.ResolvePartUri (added.WorksheetUri' uriTbl)' TargetMode.Internal' ExcelPackage.schemaRelationships + "/pivotTable");  	part.CreateRelationship (PackUriHelper.ResolvePartUri (tbl.Relationship.SourceUri' tbl.CacheDefinition.Relationship.TargetUri)' tbl.CacheDefinition.Relationship.TargetMode' tbl.CacheDefinition.Relationship.RelationshipType);  }  
Magic Number,OfficeOpenXml,ExcelWorksheets,C:\repos\bambit_EPPlus\EPPlus\ExcelWorksheets.cs,CopyPivotTable,The following statement contains a magic number: if (prevName == "") {  	name = Copy.PivotTables.GetNewTableName ();  }  else {  	int ix = int.Parse (prevName.Substring (10)) + 1;  	name = string.Format ("PivotTable{0}"' ix);  	while (_pck.Workbook.ExistsPivotTableName (name)) {  		name = string.Format ("PivotTable{0}"' ++ix);  	}  }  
Magic Number,OfficeOpenXml,ExcelWorksheets,C:\repos\bambit_EPPlus\EPPlus\ExcelWorksheets.cs,ValidateFixSheetName,The following statement contains a magic number: if (Name.Length > 31)  	Name = Name.Substring (0' 31);  
Magic Number,OfficeOpenXml,ExcelWorksheets,C:\repos\bambit_EPPlus\EPPlus\ExcelWorksheets.cs,ValidateFixSheetName,The following statement contains a magic number: if (Name.Length > 31)  	Name = Name.Substring (0' 31);  
Magic Number,OfficeOpenXml,ExcelWorksheets,C:\repos\bambit_EPPlus\EPPlus\ExcelWorksheets.cs,ValidateFixSheetName,The following statement contains a magic number: Name = Name.Substring (0' 31);  
Magic Number,OfficeOpenXml,ExcelWorksheets,C:\repos\bambit_EPPlus\EPPlus\ExcelWorksheets.cs,Move,The following statement contains a magic number: if (_worksheets.Count < 2) {  	return;  	//--- no reason to attempt to re-arrange a single item with itself  }  
Magic Number,OfficeOpenXml,ExcelAddressBase,C:\repos\bambit_EPPlus\EPPlus\ExcelAddress.cs,SetAddress,The following statement contains a magic number: if (address.StartsWith ("'")) {  	int pos = address.IndexOf ("'"' 1);  	SetWbWs (address.Substring (1' pos - 1).Replace ("''"' "'"));  	_address = address.Substring (pos + 2);  }  else if (address.StartsWith ("["))//Remove any external reference   {  	SetWbWs (address);  }  else {  	_address = address;  }  
Magic Number,OfficeOpenXml,ExcelAddressBase,C:\repos\bambit_EPPlus\EPPlus\ExcelAddress.cs,SetAddress,The following statement contains a magic number: _address = address.Substring (pos + 2);  
Magic Number,OfficeOpenXml,ExcelAddressBase,C:\repos\bambit_EPPlus\EPPlus\ExcelAddress.cs,IsValid,The following statement contains a magic number: if (Address.StartsWith ("'")) {  	int ix = Address.IndexOf ('\''' 1);  	if (ix > -1) {  		ws = Address.Substring (1' ix - 1);  		Address = Address.Substring (ix + 2);  	}  }  
Magic Number,OfficeOpenXml,ExcelAddressBase,C:\repos\bambit_EPPlus\EPPlus\ExcelAddress.cs,IsValid,The following statement contains a magic number: if (ix > -1) {  	ws = Address.Substring (1' ix - 1);  	Address = Address.Substring (ix + 2);  }  
Magic Number,OfficeOpenXml,ExcelAddressBase,C:\repos\bambit_EPPlus\EPPlus\ExcelAddress.cs,IsValid,The following statement contains a magic number: Address = Address.Substring (ix + 2);  
Magic Number,OfficeOpenXml,ExcelAddressBase,C:\repos\bambit_EPPlus\EPPlus\ExcelAddress.cs,IsValid,The following statement contains a magic number: if (Address.IndexOf ('!') > 0) {  	string[] split = Address.Split ('!');  	if (split.Length == 2) {  		ws = split [0];  		Address = split [1];  	}  	else if (split.Length == 3 && split [1] == "#REF" && split [2] == "") {  		ws = split [0];  		Address = "#REF!";  		if (ws.StartsWith ("[") && ws.IndexOf ("]") > 1) {  			return AddressType.ExternalAddress;  		}  		else {  			return AddressType.InternalAddress;  		}  	}  	else {  		return AddressType.Invalid;  	}  }  
Magic Number,OfficeOpenXml,ExcelAddressBase,C:\repos\bambit_EPPlus\EPPlus\ExcelAddress.cs,IsValid,The following statement contains a magic number: if (Address.IndexOf ('!') > 0) {  	string[] split = Address.Split ('!');  	if (split.Length == 2) {  		ws = split [0];  		Address = split [1];  	}  	else if (split.Length == 3 && split [1] == "#REF" && split [2] == "") {  		ws = split [0];  		Address = "#REF!";  		if (ws.StartsWith ("[") && ws.IndexOf ("]") > 1) {  			return AddressType.ExternalAddress;  		}  		else {  			return AddressType.InternalAddress;  		}  	}  	else {  		return AddressType.Invalid;  	}  }  
Magic Number,OfficeOpenXml,ExcelAddressBase,C:\repos\bambit_EPPlus\EPPlus\ExcelAddress.cs,IsValid,The following statement contains a magic number: if (Address.IndexOf ('!') > 0) {  	string[] split = Address.Split ('!');  	if (split.Length == 2) {  		ws = split [0];  		Address = split [1];  	}  	else if (split.Length == 3 && split [1] == "#REF" && split [2] == "") {  		ws = split [0];  		Address = "#REF!";  		if (ws.StartsWith ("[") && ws.IndexOf ("]") > 1) {  			return AddressType.ExternalAddress;  		}  		else {  			return AddressType.InternalAddress;  		}  	}  	else {  		return AddressType.Invalid;  	}  }  
Magic Number,OfficeOpenXml,ExcelAddressBase,C:\repos\bambit_EPPlus\EPPlus\ExcelAddress.cs,IsValid,The following statement contains a magic number: if (split.Length == 2) {  	ws = split [0];  	Address = split [1];  }  else if (split.Length == 3 && split [1] == "#REF" && split [2] == "") {  	ws = split [0];  	Address = "#REF!";  	if (ws.StartsWith ("[") && ws.IndexOf ("]") > 1) {  		return AddressType.ExternalAddress;  	}  	else {  		return AddressType.InternalAddress;  	}  }  else {  	return AddressType.Invalid;  }  
Magic Number,OfficeOpenXml,ExcelAddressBase,C:\repos\bambit_EPPlus\EPPlus\ExcelAddress.cs,IsValid,The following statement contains a magic number: if (split.Length == 2) {  	ws = split [0];  	Address = split [1];  }  else if (split.Length == 3 && split [1] == "#REF" && split [2] == "") {  	ws = split [0];  	Address = "#REF!";  	if (ws.StartsWith ("[") && ws.IndexOf ("]") > 1) {  		return AddressType.ExternalAddress;  	}  	else {  		return AddressType.InternalAddress;  	}  }  else {  	return AddressType.Invalid;  }  
Magic Number,OfficeOpenXml,ExcelAddressBase,C:\repos\bambit_EPPlus\EPPlus\ExcelAddress.cs,IsValid,The following statement contains a magic number: if (split.Length == 2) {  	ws = split [0];  	Address = split [1];  }  else if (split.Length == 3 && split [1] == "#REF" && split [2] == "") {  	ws = split [0];  	Address = "#REF!";  	if (ws.StartsWith ("[") && ws.IndexOf ("]") > 1) {  		return AddressType.ExternalAddress;  	}  	else {  		return AddressType.InternalAddress;  	}  }  else {  	return AddressType.Invalid;  }  
Magic Number,OfficeOpenXml,ExcelAddressBase,C:\repos\bambit_EPPlus\EPPlus\ExcelAddress.cs,IsValid,The following statement contains a magic number: if (split.Length == 3 && split [1] == "#REF" && split [2] == "") {  	ws = split [0];  	Address = "#REF!";  	if (ws.StartsWith ("[") && ws.IndexOf ("]") > 1) {  		return AddressType.ExternalAddress;  	}  	else {  		return AddressType.InternalAddress;  	}  }  else {  	return AddressType.Invalid;  }  
Magic Number,OfficeOpenXml,ExcelAddressBase,C:\repos\bambit_EPPlus\EPPlus\ExcelAddress.cs,IsValid,The following statement contains a magic number: if (split.Length == 3 && split [1] == "#REF" && split [2] == "") {  	ws = split [0];  	Address = "#REF!";  	if (ws.StartsWith ("[") && ws.IndexOf ("]") > 1) {  		return AddressType.ExternalAddress;  	}  	else {  		return AddressType.InternalAddress;  	}  }  else {  	return AddressType.Invalid;  }  
Magic Number,OfficeOpenXml,RangeCollection,C:\repos\bambit_EPPlus\EPPlus\RangeCollection.cs,InitSize,The following statement contains a magic number: _size = 128;  
Magic Number,OfficeOpenXml,ExcelCellBase,C:\repos\bambit_EPPlus\EPPlus\ExcelCellBase.cs,SplitCellID,The following statement contains a magic number: col = ((int)(cellID >> 15) & 0x3FF);  
Magic Number,OfficeOpenXml,ExcelCellBase,C:\repos\bambit_EPPlus\EPPlus\ExcelCellBase.cs,SplitCellID,The following statement contains a magic number: row = ((int)(cellID >> 29));  
Magic Number,OfficeOpenXml,ExcelCellBase,C:\repos\bambit_EPPlus\EPPlus\ExcelCellBase.cs,GetCellID,The following statement contains a magic number: return ((ulong)SheetID) + (((ulong)col) << 15) + (((ulong)row) << 29);  
Magic Number,OfficeOpenXml,ExcelCellBase,C:\repos\bambit_EPPlus\EPPlus\ExcelCellBase.cs,GetCellID,The following statement contains a magic number: return ((ulong)SheetID) + (((ulong)col) << 15) + (((ulong)row) << 29);  
Magic Number,OfficeOpenXml,ExcelCellBase,C:\repos\bambit_EPPlus\EPPlus\ExcelCellBase.cs,GetRC,The following statement contains a magic number: if (value [0] == '[' && value [value.Length - 1] == ']')//Offset?                   {  	fixedAddr = false;  	if (int.TryParse (value.Substring (1' value.Length - 2)' out num)) {  		return (OffsetValue + num);  	}  	else {  		return int.MinValue;  	}  }  else {  	fixedAddr = true;  	if (int.TryParse (value' out num)) {  		return num;  	}  	else {  		return int.MinValue;  	}  }  
Magic Number,OfficeOpenXml,ExcelCellBase,C:\repos\bambit_EPPlus\EPPlus\ExcelCellBase.cs,GetRC,The following statement contains a magic number: if (int.TryParse (value.Substring (1' value.Length - 2)' out num)) {  	return (OffsetValue + num);  }  else {  	return int.MinValue;  }  
Magic Number,OfficeOpenXml,ExcelCellBase,C:\repos\bambit_EPPlus\EPPlus\ExcelCellBase.cs,GetColumnLetter,The following statement contains a magic number: do {  	sCol = ((char)('A' + ((iColumnNumber - 1) % 26))) + sCol;  	iColumnNumber = (iColumnNumber - ((iColumnNumber - 1) % 26)) / 26;  }  while (iColumnNumber > 0);  
Magic Number,OfficeOpenXml,ExcelCellBase,C:\repos\bambit_EPPlus\EPPlus\ExcelCellBase.cs,GetColumnLetter,The following statement contains a magic number: do {  	sCol = ((char)('A' + ((iColumnNumber - 1) % 26))) + sCol;  	iColumnNumber = (iColumnNumber - ((iColumnNumber - 1) % 26)) / 26;  }  while (iColumnNumber > 0);  
Magic Number,OfficeOpenXml,ExcelCellBase,C:\repos\bambit_EPPlus\EPPlus\ExcelCellBase.cs,GetColumnLetter,The following statement contains a magic number: do {  	sCol = ((char)('A' + ((iColumnNumber - 1) % 26))) + sCol;  	iColumnNumber = (iColumnNumber - ((iColumnNumber - 1) % 26)) / 26;  }  while (iColumnNumber > 0);  
Magic Number,OfficeOpenXml,ExcelCellBase,C:\repos\bambit_EPPlus\EPPlus\ExcelCellBase.cs,GetColumnLetter,The following statement contains a magic number: sCol = ((char)('A' + ((iColumnNumber - 1) % 26))) + sCol;  
Magic Number,OfficeOpenXml,ExcelCellBase,C:\repos\bambit_EPPlus\EPPlus\ExcelCellBase.cs,GetColumnLetter,The following statement contains a magic number: iColumnNumber = (iColumnNumber - ((iColumnNumber - 1) % 26)) / 26;  
Magic Number,OfficeOpenXml,ExcelCellBase,C:\repos\bambit_EPPlus\EPPlus\ExcelCellBase.cs,GetColumnLetter,The following statement contains a magic number: iColumnNumber = (iColumnNumber - ((iColumnNumber - 1) % 26)) / 26;  
Magic Number,OfficeOpenXml,ExcelCellBase,C:\repos\bambit_EPPlus\EPPlus\ExcelCellBase.cs,GetRowCol,The following statement contains a magic number: for (int i = 0; i < address.Length; i++) {  	if ((address [i] >= 'A' && address [i] <= 'Z') && colPart && sCol.Length <= 3) {  		sCol += address [i];  	}  	else if (address [i] >= '0' && address [i] <= '9') {  		sRow += address [i];  		colPart = false;  	}  	else if (address [i] != '$')// $ is ignored here  	 {  		if (throwException) {  			throw (new Exception (string.Format ("Invalid Address format {0}"' address)));  		}  		else {  			row = 0;  			col = 0;  			return false;  		}  	}  }  
Magic Number,OfficeOpenXml,ExcelCellBase,C:\repos\bambit_EPPlus\EPPlus\ExcelCellBase.cs,GetRowCol,The following statement contains a magic number: if ((address [i] >= 'A' && address [i] <= 'Z') && colPart && sCol.Length <= 3) {  	sCol += address [i];  }  else if (address [i] >= '0' && address [i] <= '9') {  	sRow += address [i];  	colPart = false;  }  else if (address [i] != '$')// $ is ignored here   {  	if (throwException) {  		throw (new Exception (string.Format ("Invalid Address format {0}"' address)));  	}  	else {  		row = 0;  		col = 0;  		return false;  	}  }  
Magic Number,OfficeOpenXml,ExcelCellBase,C:\repos\bambit_EPPlus\EPPlus\ExcelCellBase.cs,GetRowCol,The following statement contains a magic number: if (sCol != "") {  	int len = sCol.Length - 1;  	for (int i = len; i >= 0; i--) {  		col += (((int)sCol [i]) - 64) * (int)(Math.Pow (26' len - i));  	}  }  else {  	col = 0;  	int.TryParse (sRow' out row);  	return row > 0;  }  
Magic Number,OfficeOpenXml,ExcelCellBase,C:\repos\bambit_EPPlus\EPPlus\ExcelCellBase.cs,GetRowCol,The following statement contains a magic number: if (sCol != "") {  	int len = sCol.Length - 1;  	for (int i = len; i >= 0; i--) {  		col += (((int)sCol [i]) - 64) * (int)(Math.Pow (26' len - i));  	}  }  else {  	col = 0;  	int.TryParse (sRow' out row);  	return row > 0;  }  
Magic Number,OfficeOpenXml,ExcelCellBase,C:\repos\bambit_EPPlus\EPPlus\ExcelCellBase.cs,GetRowCol,The following statement contains a magic number: for (int i = len; i >= 0; i--) {  	col += (((int)sCol [i]) - 64) * (int)(Math.Pow (26' len - i));  }  
Magic Number,OfficeOpenXml,ExcelCellBase,C:\repos\bambit_EPPlus\EPPlus\ExcelCellBase.cs,GetRowCol,The following statement contains a magic number: for (int i = len; i >= 0; i--) {  	col += (((int)sCol [i]) - 64) * (int)(Math.Pow (26' len - i));  }  
Magic Number,OfficeOpenXml,ExcelCellBase,C:\repos\bambit_EPPlus\EPPlus\ExcelCellBase.cs,GetRowCol,The following statement contains a magic number: col += (((int)sCol [i]) - 64) * (int)(Math.Pow (26' len - i));  
Magic Number,OfficeOpenXml,ExcelCellBase,C:\repos\bambit_EPPlus\EPPlus\ExcelCellBase.cs,GetRowCol,The following statement contains a magic number: col += (((int)sCol [i]) - 64) * (int)(Math.Pow (26' len - i));  
Magic Number,OfficeOpenXml,ExcelRangeBase,C:\repos\bambit_EPPlus\EPPlus\ExcelRangeBase.cs,AutoFitColumns,The following statement contains a magic number: using (Bitmap b = new Bitmap (1' 1)) {  	using (Graphics g = Graphics.FromImage (b)) {  		float normalSize = (float)Math.Truncate (g.MeasureString ("00"' nfont).Width - g.MeasureString ("0"' nfont).Width);  		g.PageUnit = GraphicsUnit.Pixel;  		foreach (var cell in this) {  			if (cell.Merge == true || cell.Style.WrapText)  				continue;  			var fntID = styles.CellXfs [cell.StyleID].FontId;  			if (fontCache.ContainsKey (fntID)) {  				f = fontCache [fntID];  			}  			else {  				var fnt = styles.Fonts [fntID];  				fs = FontStyle.Regular;  				if (fnt.Bold)  					fs |= FontStyle.Bold;  				if (fnt.UnderLine)  					fs |= FontStyle.Underline;  				if (fnt.Italic)  					fs |= FontStyle.Italic;  				if (fnt.Strike)  					fs |= FontStyle.Strikeout;  				f = new Font (fnt.Name' fnt.Size' fs);  				fontCache.Add (fntID' f);  			}  			//Truncate(({pixels}-5)/{Maximum Digit Width} * 100+0.5)/100  			var size = g.MeasureString (cell.TextForWidth' f);  			double width;  			double r = styles.CellXfs [cell.StyleID].TextRotation;  			if (r <= 0) {  				width = (size.Width + 5) / normalSize;  			}  			else {  				r = (r <= 90 ? r : r - 90);  				width = (((size.Width - size.Height) * Math.Abs (System.Math.Cos (System.Math.PI * r / 180.0)) + size.Height) + 5) / normalSize;  			}  			foreach (var a in afAddr) {  				if (a.Collide (cell) != eAddressCollition.No) {  					width += 2.25;  					break;  				}  			}  			if (width > _worksheet.Column (cell._fromCol).Width) {  				_worksheet.Column (cell._fromCol).Width = width > MaximumWidth ? MaximumWidth : width;  			}  		}  	}  }  
Magic Number,OfficeOpenXml,ExcelRangeBase,C:\repos\bambit_EPPlus\EPPlus\ExcelRangeBase.cs,AutoFitColumns,The following statement contains a magic number: using (Bitmap b = new Bitmap (1' 1)) {  	using (Graphics g = Graphics.FromImage (b)) {  		float normalSize = (float)Math.Truncate (g.MeasureString ("00"' nfont).Width - g.MeasureString ("0"' nfont).Width);  		g.PageUnit = GraphicsUnit.Pixel;  		foreach (var cell in this) {  			if (cell.Merge == true || cell.Style.WrapText)  				continue;  			var fntID = styles.CellXfs [cell.StyleID].FontId;  			if (fontCache.ContainsKey (fntID)) {  				f = fontCache [fntID];  			}  			else {  				var fnt = styles.Fonts [fntID];  				fs = FontStyle.Regular;  				if (fnt.Bold)  					fs |= FontStyle.Bold;  				if (fnt.UnderLine)  					fs |= FontStyle.Underline;  				if (fnt.Italic)  					fs |= FontStyle.Italic;  				if (fnt.Strike)  					fs |= FontStyle.Strikeout;  				f = new Font (fnt.Name' fnt.Size' fs);  				fontCache.Add (fntID' f);  			}  			//Truncate(({pixels}-5)/{Maximum Digit Width} * 100+0.5)/100  			var size = g.MeasureString (cell.TextForWidth' f);  			double width;  			double r = styles.CellXfs [cell.StyleID].TextRotation;  			if (r <= 0) {  				width = (size.Width + 5) / normalSize;  			}  			else {  				r = (r <= 90 ? r : r - 90);  				width = (((size.Width - size.Height) * Math.Abs (System.Math.Cos (System.Math.PI * r / 180.0)) + size.Height) + 5) / normalSize;  			}  			foreach (var a in afAddr) {  				if (a.Collide (cell) != eAddressCollition.No) {  					width += 2.25;  					break;  				}  			}  			if (width > _worksheet.Column (cell._fromCol).Width) {  				_worksheet.Column (cell._fromCol).Width = width > MaximumWidth ? MaximumWidth : width;  			}  		}  	}  }  
Magic Number,OfficeOpenXml,ExcelRangeBase,C:\repos\bambit_EPPlus\EPPlus\ExcelRangeBase.cs,AutoFitColumns,The following statement contains a magic number: using (Bitmap b = new Bitmap (1' 1)) {  	using (Graphics g = Graphics.FromImage (b)) {  		float normalSize = (float)Math.Truncate (g.MeasureString ("00"' nfont).Width - g.MeasureString ("0"' nfont).Width);  		g.PageUnit = GraphicsUnit.Pixel;  		foreach (var cell in this) {  			if (cell.Merge == true || cell.Style.WrapText)  				continue;  			var fntID = styles.CellXfs [cell.StyleID].FontId;  			if (fontCache.ContainsKey (fntID)) {  				f = fontCache [fntID];  			}  			else {  				var fnt = styles.Fonts [fntID];  				fs = FontStyle.Regular;  				if (fnt.Bold)  					fs |= FontStyle.Bold;  				if (fnt.UnderLine)  					fs |= FontStyle.Underline;  				if (fnt.Italic)  					fs |= FontStyle.Italic;  				if (fnt.Strike)  					fs |= FontStyle.Strikeout;  				f = new Font (fnt.Name' fnt.Size' fs);  				fontCache.Add (fntID' f);  			}  			//Truncate(({pixels}-5)/{Maximum Digit Width} * 100+0.5)/100  			var size = g.MeasureString (cell.TextForWidth' f);  			double width;  			double r = styles.CellXfs [cell.StyleID].TextRotation;  			if (r <= 0) {  				width = (size.Width + 5) / normalSize;  			}  			else {  				r = (r <= 90 ? r : r - 90);  				width = (((size.Width - size.Height) * Math.Abs (System.Math.Cos (System.Math.PI * r / 180.0)) + size.Height) + 5) / normalSize;  			}  			foreach (var a in afAddr) {  				if (a.Collide (cell) != eAddressCollition.No) {  					width += 2.25;  					break;  				}  			}  			if (width > _worksheet.Column (cell._fromCol).Width) {  				_worksheet.Column (cell._fromCol).Width = width > MaximumWidth ? MaximumWidth : width;  			}  		}  	}  }  
Magic Number,OfficeOpenXml,ExcelRangeBase,C:\repos\bambit_EPPlus\EPPlus\ExcelRangeBase.cs,AutoFitColumns,The following statement contains a magic number: using (Bitmap b = new Bitmap (1' 1)) {  	using (Graphics g = Graphics.FromImage (b)) {  		float normalSize = (float)Math.Truncate (g.MeasureString ("00"' nfont).Width - g.MeasureString ("0"' nfont).Width);  		g.PageUnit = GraphicsUnit.Pixel;  		foreach (var cell in this) {  			if (cell.Merge == true || cell.Style.WrapText)  				continue;  			var fntID = styles.CellXfs [cell.StyleID].FontId;  			if (fontCache.ContainsKey (fntID)) {  				f = fontCache [fntID];  			}  			else {  				var fnt = styles.Fonts [fntID];  				fs = FontStyle.Regular;  				if (fnt.Bold)  					fs |= FontStyle.Bold;  				if (fnt.UnderLine)  					fs |= FontStyle.Underline;  				if (fnt.Italic)  					fs |= FontStyle.Italic;  				if (fnt.Strike)  					fs |= FontStyle.Strikeout;  				f = new Font (fnt.Name' fnt.Size' fs);  				fontCache.Add (fntID' f);  			}  			//Truncate(({pixels}-5)/{Maximum Digit Width} * 100+0.5)/100  			var size = g.MeasureString (cell.TextForWidth' f);  			double width;  			double r = styles.CellXfs [cell.StyleID].TextRotation;  			if (r <= 0) {  				width = (size.Width + 5) / normalSize;  			}  			else {  				r = (r <= 90 ? r : r - 90);  				width = (((size.Width - size.Height) * Math.Abs (System.Math.Cos (System.Math.PI * r / 180.0)) + size.Height) + 5) / normalSize;  			}  			foreach (var a in afAddr) {  				if (a.Collide (cell) != eAddressCollition.No) {  					width += 2.25;  					break;  				}  			}  			if (width > _worksheet.Column (cell._fromCol).Width) {  				_worksheet.Column (cell._fromCol).Width = width > MaximumWidth ? MaximumWidth : width;  			}  		}  	}  }  
Magic Number,OfficeOpenXml,ExcelRangeBase,C:\repos\bambit_EPPlus\EPPlus\ExcelRangeBase.cs,AutoFitColumns,The following statement contains a magic number: using (Bitmap b = new Bitmap (1' 1)) {  	using (Graphics g = Graphics.FromImage (b)) {  		float normalSize = (float)Math.Truncate (g.MeasureString ("00"' nfont).Width - g.MeasureString ("0"' nfont).Width);  		g.PageUnit = GraphicsUnit.Pixel;  		foreach (var cell in this) {  			if (cell.Merge == true || cell.Style.WrapText)  				continue;  			var fntID = styles.CellXfs [cell.StyleID].FontId;  			if (fontCache.ContainsKey (fntID)) {  				f = fontCache [fntID];  			}  			else {  				var fnt = styles.Fonts [fntID];  				fs = FontStyle.Regular;  				if (fnt.Bold)  					fs |= FontStyle.Bold;  				if (fnt.UnderLine)  					fs |= FontStyle.Underline;  				if (fnt.Italic)  					fs |= FontStyle.Italic;  				if (fnt.Strike)  					fs |= FontStyle.Strikeout;  				f = new Font (fnt.Name' fnt.Size' fs);  				fontCache.Add (fntID' f);  			}  			//Truncate(({pixels}-5)/{Maximum Digit Width} * 100+0.5)/100  			var size = g.MeasureString (cell.TextForWidth' f);  			double width;  			double r = styles.CellXfs [cell.StyleID].TextRotation;  			if (r <= 0) {  				width = (size.Width + 5) / normalSize;  			}  			else {  				r = (r <= 90 ? r : r - 90);  				width = (((size.Width - size.Height) * Math.Abs (System.Math.Cos (System.Math.PI * r / 180.0)) + size.Height) + 5) / normalSize;  			}  			foreach (var a in afAddr) {  				if (a.Collide (cell) != eAddressCollition.No) {  					width += 2.25;  					break;  				}  			}  			if (width > _worksheet.Column (cell._fromCol).Width) {  				_worksheet.Column (cell._fromCol).Width = width > MaximumWidth ? MaximumWidth : width;  			}  		}  	}  }  
Magic Number,OfficeOpenXml,ExcelRangeBase,C:\repos\bambit_EPPlus\EPPlus\ExcelRangeBase.cs,AutoFitColumns,The following statement contains a magic number: using (Bitmap b = new Bitmap (1' 1)) {  	using (Graphics g = Graphics.FromImage (b)) {  		float normalSize = (float)Math.Truncate (g.MeasureString ("00"' nfont).Width - g.MeasureString ("0"' nfont).Width);  		g.PageUnit = GraphicsUnit.Pixel;  		foreach (var cell in this) {  			if (cell.Merge == true || cell.Style.WrapText)  				continue;  			var fntID = styles.CellXfs [cell.StyleID].FontId;  			if (fontCache.ContainsKey (fntID)) {  				f = fontCache [fntID];  			}  			else {  				var fnt = styles.Fonts [fntID];  				fs = FontStyle.Regular;  				if (fnt.Bold)  					fs |= FontStyle.Bold;  				if (fnt.UnderLine)  					fs |= FontStyle.Underline;  				if (fnt.Italic)  					fs |= FontStyle.Italic;  				if (fnt.Strike)  					fs |= FontStyle.Strikeout;  				f = new Font (fnt.Name' fnt.Size' fs);  				fontCache.Add (fntID' f);  			}  			//Truncate(({pixels}-5)/{Maximum Digit Width} * 100+0.5)/100  			var size = g.MeasureString (cell.TextForWidth' f);  			double width;  			double r = styles.CellXfs [cell.StyleID].TextRotation;  			if (r <= 0) {  				width = (size.Width + 5) / normalSize;  			}  			else {  				r = (r <= 90 ? r : r - 90);  				width = (((size.Width - size.Height) * Math.Abs (System.Math.Cos (System.Math.PI * r / 180.0)) + size.Height) + 5) / normalSize;  			}  			foreach (var a in afAddr) {  				if (a.Collide (cell) != eAddressCollition.No) {  					width += 2.25;  					break;  				}  			}  			if (width > _worksheet.Column (cell._fromCol).Width) {  				_worksheet.Column (cell._fromCol).Width = width > MaximumWidth ? MaximumWidth : width;  			}  		}  	}  }  
Magic Number,OfficeOpenXml,ExcelRangeBase,C:\repos\bambit_EPPlus\EPPlus\ExcelRangeBase.cs,AutoFitColumns,The following statement contains a magic number: using (Graphics g = Graphics.FromImage (b)) {  	float normalSize = (float)Math.Truncate (g.MeasureString ("00"' nfont).Width - g.MeasureString ("0"' nfont).Width);  	g.PageUnit = GraphicsUnit.Pixel;  	foreach (var cell in this) {  		if (cell.Merge == true || cell.Style.WrapText)  			continue;  		var fntID = styles.CellXfs [cell.StyleID].FontId;  		if (fontCache.ContainsKey (fntID)) {  			f = fontCache [fntID];  		}  		else {  			var fnt = styles.Fonts [fntID];  			fs = FontStyle.Regular;  			if (fnt.Bold)  				fs |= FontStyle.Bold;  			if (fnt.UnderLine)  				fs |= FontStyle.Underline;  			if (fnt.Italic)  				fs |= FontStyle.Italic;  			if (fnt.Strike)  				fs |= FontStyle.Strikeout;  			f = new Font (fnt.Name' fnt.Size' fs);  			fontCache.Add (fntID' f);  		}  		//Truncate(({pixels}-5)/{Maximum Digit Width} * 100+0.5)/100  		var size = g.MeasureString (cell.TextForWidth' f);  		double width;  		double r = styles.CellXfs [cell.StyleID].TextRotation;  		if (r <= 0) {  			width = (size.Width + 5) / normalSize;  		}  		else {  			r = (r <= 90 ? r : r - 90);  			width = (((size.Width - size.Height) * Math.Abs (System.Math.Cos (System.Math.PI * r / 180.0)) + size.Height) + 5) / normalSize;  		}  		foreach (var a in afAddr) {  			if (a.Collide (cell) != eAddressCollition.No) {  				width += 2.25;  				break;  			}  		}  		if (width > _worksheet.Column (cell._fromCol).Width) {  			_worksheet.Column (cell._fromCol).Width = width > MaximumWidth ? MaximumWidth : width;  		}  	}  }  
Magic Number,OfficeOpenXml,ExcelRangeBase,C:\repos\bambit_EPPlus\EPPlus\ExcelRangeBase.cs,AutoFitColumns,The following statement contains a magic number: using (Graphics g = Graphics.FromImage (b)) {  	float normalSize = (float)Math.Truncate (g.MeasureString ("00"' nfont).Width - g.MeasureString ("0"' nfont).Width);  	g.PageUnit = GraphicsUnit.Pixel;  	foreach (var cell in this) {  		if (cell.Merge == true || cell.Style.WrapText)  			continue;  		var fntID = styles.CellXfs [cell.StyleID].FontId;  		if (fontCache.ContainsKey (fntID)) {  			f = fontCache [fntID];  		}  		else {  			var fnt = styles.Fonts [fntID];  			fs = FontStyle.Regular;  			if (fnt.Bold)  				fs |= FontStyle.Bold;  			if (fnt.UnderLine)  				fs |= FontStyle.Underline;  			if (fnt.Italic)  				fs |= FontStyle.Italic;  			if (fnt.Strike)  				fs |= FontStyle.Strikeout;  			f = new Font (fnt.Name' fnt.Size' fs);  			fontCache.Add (fntID' f);  		}  		//Truncate(({pixels}-5)/{Maximum Digit Width} * 100+0.5)/100  		var size = g.MeasureString (cell.TextForWidth' f);  		double width;  		double r = styles.CellXfs [cell.StyleID].TextRotation;  		if (r <= 0) {  			width = (size.Width + 5) / normalSize;  		}  		else {  			r = (r <= 90 ? r : r - 90);  			width = (((size.Width - size.Height) * Math.Abs (System.Math.Cos (System.Math.PI * r / 180.0)) + size.Height) + 5) / normalSize;  		}  		foreach (var a in afAddr) {  			if (a.Collide (cell) != eAddressCollition.No) {  				width += 2.25;  				break;  			}  		}  		if (width > _worksheet.Column (cell._fromCol).Width) {  			_worksheet.Column (cell._fromCol).Width = width > MaximumWidth ? MaximumWidth : width;  		}  	}  }  
Magic Number,OfficeOpenXml,ExcelRangeBase,C:\repos\bambit_EPPlus\EPPlus\ExcelRangeBase.cs,AutoFitColumns,The following statement contains a magic number: using (Graphics g = Graphics.FromImage (b)) {  	float normalSize = (float)Math.Truncate (g.MeasureString ("00"' nfont).Width - g.MeasureString ("0"' nfont).Width);  	g.PageUnit = GraphicsUnit.Pixel;  	foreach (var cell in this) {  		if (cell.Merge == true || cell.Style.WrapText)  			continue;  		var fntID = styles.CellXfs [cell.StyleID].FontId;  		if (fontCache.ContainsKey (fntID)) {  			f = fontCache [fntID];  		}  		else {  			var fnt = styles.Fonts [fntID];  			fs = FontStyle.Regular;  			if (fnt.Bold)  				fs |= FontStyle.Bold;  			if (fnt.UnderLine)  				fs |= FontStyle.Underline;  			if (fnt.Italic)  				fs |= FontStyle.Italic;  			if (fnt.Strike)  				fs |= FontStyle.Strikeout;  			f = new Font (fnt.Name' fnt.Size' fs);  			fontCache.Add (fntID' f);  		}  		//Truncate(({pixels}-5)/{Maximum Digit Width} * 100+0.5)/100  		var size = g.MeasureString (cell.TextForWidth' f);  		double width;  		double r = styles.CellXfs [cell.StyleID].TextRotation;  		if (r <= 0) {  			width = (size.Width + 5) / normalSize;  		}  		else {  			r = (r <= 90 ? r : r - 90);  			width = (((size.Width - size.Height) * Math.Abs (System.Math.Cos (System.Math.PI * r / 180.0)) + size.Height) + 5) / normalSize;  		}  		foreach (var a in afAddr) {  			if (a.Collide (cell) != eAddressCollition.No) {  				width += 2.25;  				break;  			}  		}  		if (width > _worksheet.Column (cell._fromCol).Width) {  			_worksheet.Column (cell._fromCol).Width = width > MaximumWidth ? MaximumWidth : width;  		}  	}  }  
Magic Number,OfficeOpenXml,ExcelRangeBase,C:\repos\bambit_EPPlus\EPPlus\ExcelRangeBase.cs,AutoFitColumns,The following statement contains a magic number: using (Graphics g = Graphics.FromImage (b)) {  	float normalSize = (float)Math.Truncate (g.MeasureString ("00"' nfont).Width - g.MeasureString ("0"' nfont).Width);  	g.PageUnit = GraphicsUnit.Pixel;  	foreach (var cell in this) {  		if (cell.Merge == true || cell.Style.WrapText)  			continue;  		var fntID = styles.CellXfs [cell.StyleID].FontId;  		if (fontCache.ContainsKey (fntID)) {  			f = fontCache [fntID];  		}  		else {  			var fnt = styles.Fonts [fntID];  			fs = FontStyle.Regular;  			if (fnt.Bold)  				fs |= FontStyle.Bold;  			if (fnt.UnderLine)  				fs |= FontStyle.Underline;  			if (fnt.Italic)  				fs |= FontStyle.Italic;  			if (fnt.Strike)  				fs |= FontStyle.Strikeout;  			f = new Font (fnt.Name' fnt.Size' fs);  			fontCache.Add (fntID' f);  		}  		//Truncate(({pixels}-5)/{Maximum Digit Width} * 100+0.5)/100  		var size = g.MeasureString (cell.TextForWidth' f);  		double width;  		double r = styles.CellXfs [cell.StyleID].TextRotation;  		if (r <= 0) {  			width = (size.Width + 5) / normalSize;  		}  		else {  			r = (r <= 90 ? r : r - 90);  			width = (((size.Width - size.Height) * Math.Abs (System.Math.Cos (System.Math.PI * r / 180.0)) + size.Height) + 5) / normalSize;  		}  		foreach (var a in afAddr) {  			if (a.Collide (cell) != eAddressCollition.No) {  				width += 2.25;  				break;  			}  		}  		if (width > _worksheet.Column (cell._fromCol).Width) {  			_worksheet.Column (cell._fromCol).Width = width > MaximumWidth ? MaximumWidth : width;  		}  	}  }  
Magic Number,OfficeOpenXml,ExcelRangeBase,C:\repos\bambit_EPPlus\EPPlus\ExcelRangeBase.cs,AutoFitColumns,The following statement contains a magic number: using (Graphics g = Graphics.FromImage (b)) {  	float normalSize = (float)Math.Truncate (g.MeasureString ("00"' nfont).Width - g.MeasureString ("0"' nfont).Width);  	g.PageUnit = GraphicsUnit.Pixel;  	foreach (var cell in this) {  		if (cell.Merge == true || cell.Style.WrapText)  			continue;  		var fntID = styles.CellXfs [cell.StyleID].FontId;  		if (fontCache.ContainsKey (fntID)) {  			f = fontCache [fntID];  		}  		else {  			var fnt = styles.Fonts [fntID];  			fs = FontStyle.Regular;  			if (fnt.Bold)  				fs |= FontStyle.Bold;  			if (fnt.UnderLine)  				fs |= FontStyle.Underline;  			if (fnt.Italic)  				fs |= FontStyle.Italic;  			if (fnt.Strike)  				fs |= FontStyle.Strikeout;  			f = new Font (fnt.Name' fnt.Size' fs);  			fontCache.Add (fntID' f);  		}  		//Truncate(({pixels}-5)/{Maximum Digit Width} * 100+0.5)/100  		var size = g.MeasureString (cell.TextForWidth' f);  		double width;  		double r = styles.CellXfs [cell.StyleID].TextRotation;  		if (r <= 0) {  			width = (size.Width + 5) / normalSize;  		}  		else {  			r = (r <= 90 ? r : r - 90);  			width = (((size.Width - size.Height) * Math.Abs (System.Math.Cos (System.Math.PI * r / 180.0)) + size.Height) + 5) / normalSize;  		}  		foreach (var a in afAddr) {  			if (a.Collide (cell) != eAddressCollition.No) {  				width += 2.25;  				break;  			}  		}  		if (width > _worksheet.Column (cell._fromCol).Width) {  			_worksheet.Column (cell._fromCol).Width = width > MaximumWidth ? MaximumWidth : width;  		}  	}  }  
Magic Number,OfficeOpenXml,ExcelRangeBase,C:\repos\bambit_EPPlus\EPPlus\ExcelRangeBase.cs,AutoFitColumns,The following statement contains a magic number: using (Graphics g = Graphics.FromImage (b)) {  	float normalSize = (float)Math.Truncate (g.MeasureString ("00"' nfont).Width - g.MeasureString ("0"' nfont).Width);  	g.PageUnit = GraphicsUnit.Pixel;  	foreach (var cell in this) {  		if (cell.Merge == true || cell.Style.WrapText)  			continue;  		var fntID = styles.CellXfs [cell.StyleID].FontId;  		if (fontCache.ContainsKey (fntID)) {  			f = fontCache [fntID];  		}  		else {  			var fnt = styles.Fonts [fntID];  			fs = FontStyle.Regular;  			if (fnt.Bold)  				fs |= FontStyle.Bold;  			if (fnt.UnderLine)  				fs |= FontStyle.Underline;  			if (fnt.Italic)  				fs |= FontStyle.Italic;  			if (fnt.Strike)  				fs |= FontStyle.Strikeout;  			f = new Font (fnt.Name' fnt.Size' fs);  			fontCache.Add (fntID' f);  		}  		//Truncate(({pixels}-5)/{Maximum Digit Width} * 100+0.5)/100  		var size = g.MeasureString (cell.TextForWidth' f);  		double width;  		double r = styles.CellXfs [cell.StyleID].TextRotation;  		if (r <= 0) {  			width = (size.Width + 5) / normalSize;  		}  		else {  			r = (r <= 90 ? r : r - 90);  			width = (((size.Width - size.Height) * Math.Abs (System.Math.Cos (System.Math.PI * r / 180.0)) + size.Height) + 5) / normalSize;  		}  		foreach (var a in afAddr) {  			if (a.Collide (cell) != eAddressCollition.No) {  				width += 2.25;  				break;  			}  		}  		if (width > _worksheet.Column (cell._fromCol).Width) {  			_worksheet.Column (cell._fromCol).Width = width > MaximumWidth ? MaximumWidth : width;  		}  	}  }  
Magic Number,OfficeOpenXml,ExcelRangeBase,C:\repos\bambit_EPPlus\EPPlus\ExcelRangeBase.cs,AutoFitColumns,The following statement contains a magic number: foreach (var cell in this) {  	if (cell.Merge == true || cell.Style.WrapText)  		continue;  	var fntID = styles.CellXfs [cell.StyleID].FontId;  	if (fontCache.ContainsKey (fntID)) {  		f = fontCache [fntID];  	}  	else {  		var fnt = styles.Fonts [fntID];  		fs = FontStyle.Regular;  		if (fnt.Bold)  			fs |= FontStyle.Bold;  		if (fnt.UnderLine)  			fs |= FontStyle.Underline;  		if (fnt.Italic)  			fs |= FontStyle.Italic;  		if (fnt.Strike)  			fs |= FontStyle.Strikeout;  		f = new Font (fnt.Name' fnt.Size' fs);  		fontCache.Add (fntID' f);  	}  	//Truncate(({pixels}-5)/{Maximum Digit Width} * 100+0.5)/100  	var size = g.MeasureString (cell.TextForWidth' f);  	double width;  	double r = styles.CellXfs [cell.StyleID].TextRotation;  	if (r <= 0) {  		width = (size.Width + 5) / normalSize;  	}  	else {  		r = (r <= 90 ? r : r - 90);  		width = (((size.Width - size.Height) * Math.Abs (System.Math.Cos (System.Math.PI * r / 180.0)) + size.Height) + 5) / normalSize;  	}  	foreach (var a in afAddr) {  		if (a.Collide (cell) != eAddressCollition.No) {  			width += 2.25;  			break;  		}  	}  	if (width > _worksheet.Column (cell._fromCol).Width) {  		_worksheet.Column (cell._fromCol).Width = width > MaximumWidth ? MaximumWidth : width;  	}  }  
Magic Number,OfficeOpenXml,ExcelRangeBase,C:\repos\bambit_EPPlus\EPPlus\ExcelRangeBase.cs,AutoFitColumns,The following statement contains a magic number: foreach (var cell in this) {  	if (cell.Merge == true || cell.Style.WrapText)  		continue;  	var fntID = styles.CellXfs [cell.StyleID].FontId;  	if (fontCache.ContainsKey (fntID)) {  		f = fontCache [fntID];  	}  	else {  		var fnt = styles.Fonts [fntID];  		fs = FontStyle.Regular;  		if (fnt.Bold)  			fs |= FontStyle.Bold;  		if (fnt.UnderLine)  			fs |= FontStyle.Underline;  		if (fnt.Italic)  			fs |= FontStyle.Italic;  		if (fnt.Strike)  			fs |= FontStyle.Strikeout;  		f = new Font (fnt.Name' fnt.Size' fs);  		fontCache.Add (fntID' f);  	}  	//Truncate(({pixels}-5)/{Maximum Digit Width} * 100+0.5)/100  	var size = g.MeasureString (cell.TextForWidth' f);  	double width;  	double r = styles.CellXfs [cell.StyleID].TextRotation;  	if (r <= 0) {  		width = (size.Width + 5) / normalSize;  	}  	else {  		r = (r <= 90 ? r : r - 90);  		width = (((size.Width - size.Height) * Math.Abs (System.Math.Cos (System.Math.PI * r / 180.0)) + size.Height) + 5) / normalSize;  	}  	foreach (var a in afAddr) {  		if (a.Collide (cell) != eAddressCollition.No) {  			width += 2.25;  			break;  		}  	}  	if (width > _worksheet.Column (cell._fromCol).Width) {  		_worksheet.Column (cell._fromCol).Width = width > MaximumWidth ? MaximumWidth : width;  	}  }  
Magic Number,OfficeOpenXml,ExcelRangeBase,C:\repos\bambit_EPPlus\EPPlus\ExcelRangeBase.cs,AutoFitColumns,The following statement contains a magic number: foreach (var cell in this) {  	if (cell.Merge == true || cell.Style.WrapText)  		continue;  	var fntID = styles.CellXfs [cell.StyleID].FontId;  	if (fontCache.ContainsKey (fntID)) {  		f = fontCache [fntID];  	}  	else {  		var fnt = styles.Fonts [fntID];  		fs = FontStyle.Regular;  		if (fnt.Bold)  			fs |= FontStyle.Bold;  		if (fnt.UnderLine)  			fs |= FontStyle.Underline;  		if (fnt.Italic)  			fs |= FontStyle.Italic;  		if (fnt.Strike)  			fs |= FontStyle.Strikeout;  		f = new Font (fnt.Name' fnt.Size' fs);  		fontCache.Add (fntID' f);  	}  	//Truncate(({pixels}-5)/{Maximum Digit Width} * 100+0.5)/100  	var size = g.MeasureString (cell.TextForWidth' f);  	double width;  	double r = styles.CellXfs [cell.StyleID].TextRotation;  	if (r <= 0) {  		width = (size.Width + 5) / normalSize;  	}  	else {  		r = (r <= 90 ? r : r - 90);  		width = (((size.Width - size.Height) * Math.Abs (System.Math.Cos (System.Math.PI * r / 180.0)) + size.Height) + 5) / normalSize;  	}  	foreach (var a in afAddr) {  		if (a.Collide (cell) != eAddressCollition.No) {  			width += 2.25;  			break;  		}  	}  	if (width > _worksheet.Column (cell._fromCol).Width) {  		_worksheet.Column (cell._fromCol).Width = width > MaximumWidth ? MaximumWidth : width;  	}  }  
Magic Number,OfficeOpenXml,ExcelRangeBase,C:\repos\bambit_EPPlus\EPPlus\ExcelRangeBase.cs,AutoFitColumns,The following statement contains a magic number: foreach (var cell in this) {  	if (cell.Merge == true || cell.Style.WrapText)  		continue;  	var fntID = styles.CellXfs [cell.StyleID].FontId;  	if (fontCache.ContainsKey (fntID)) {  		f = fontCache [fntID];  	}  	else {  		var fnt = styles.Fonts [fntID];  		fs = FontStyle.Regular;  		if (fnt.Bold)  			fs |= FontStyle.Bold;  		if (fnt.UnderLine)  			fs |= FontStyle.Underline;  		if (fnt.Italic)  			fs |= FontStyle.Italic;  		if (fnt.Strike)  			fs |= FontStyle.Strikeout;  		f = new Font (fnt.Name' fnt.Size' fs);  		fontCache.Add (fntID' f);  	}  	//Truncate(({pixels}-5)/{Maximum Digit Width} * 100+0.5)/100  	var size = g.MeasureString (cell.TextForWidth' f);  	double width;  	double r = styles.CellXfs [cell.StyleID].TextRotation;  	if (r <= 0) {  		width = (size.Width + 5) / normalSize;  	}  	else {  		r = (r <= 90 ? r : r - 90);  		width = (((size.Width - size.Height) * Math.Abs (System.Math.Cos (System.Math.PI * r / 180.0)) + size.Height) + 5) / normalSize;  	}  	foreach (var a in afAddr) {  		if (a.Collide (cell) != eAddressCollition.No) {  			width += 2.25;  			break;  		}  	}  	if (width > _worksheet.Column (cell._fromCol).Width) {  		_worksheet.Column (cell._fromCol).Width = width > MaximumWidth ? MaximumWidth : width;  	}  }  
Magic Number,OfficeOpenXml,ExcelRangeBase,C:\repos\bambit_EPPlus\EPPlus\ExcelRangeBase.cs,AutoFitColumns,The following statement contains a magic number: foreach (var cell in this) {  	if (cell.Merge == true || cell.Style.WrapText)  		continue;  	var fntID = styles.CellXfs [cell.StyleID].FontId;  	if (fontCache.ContainsKey (fntID)) {  		f = fontCache [fntID];  	}  	else {  		var fnt = styles.Fonts [fntID];  		fs = FontStyle.Regular;  		if (fnt.Bold)  			fs |= FontStyle.Bold;  		if (fnt.UnderLine)  			fs |= FontStyle.Underline;  		if (fnt.Italic)  			fs |= FontStyle.Italic;  		if (fnt.Strike)  			fs |= FontStyle.Strikeout;  		f = new Font (fnt.Name' fnt.Size' fs);  		fontCache.Add (fntID' f);  	}  	//Truncate(({pixels}-5)/{Maximum Digit Width} * 100+0.5)/100  	var size = g.MeasureString (cell.TextForWidth' f);  	double width;  	double r = styles.CellXfs [cell.StyleID].TextRotation;  	if (r <= 0) {  		width = (size.Width + 5) / normalSize;  	}  	else {  		r = (r <= 90 ? r : r - 90);  		width = (((size.Width - size.Height) * Math.Abs (System.Math.Cos (System.Math.PI * r / 180.0)) + size.Height) + 5) / normalSize;  	}  	foreach (var a in afAddr) {  		if (a.Collide (cell) != eAddressCollition.No) {  			width += 2.25;  			break;  		}  	}  	if (width > _worksheet.Column (cell._fromCol).Width) {  		_worksheet.Column (cell._fromCol).Width = width > MaximumWidth ? MaximumWidth : width;  	}  }  
Magic Number,OfficeOpenXml,ExcelRangeBase,C:\repos\bambit_EPPlus\EPPlus\ExcelRangeBase.cs,AutoFitColumns,The following statement contains a magic number: foreach (var cell in this) {  	if (cell.Merge == true || cell.Style.WrapText)  		continue;  	var fntID = styles.CellXfs [cell.StyleID].FontId;  	if (fontCache.ContainsKey (fntID)) {  		f = fontCache [fntID];  	}  	else {  		var fnt = styles.Fonts [fntID];  		fs = FontStyle.Regular;  		if (fnt.Bold)  			fs |= FontStyle.Bold;  		if (fnt.UnderLine)  			fs |= FontStyle.Underline;  		if (fnt.Italic)  			fs |= FontStyle.Italic;  		if (fnt.Strike)  			fs |= FontStyle.Strikeout;  		f = new Font (fnt.Name' fnt.Size' fs);  		fontCache.Add (fntID' f);  	}  	//Truncate(({pixels}-5)/{Maximum Digit Width} * 100+0.5)/100  	var size = g.MeasureString (cell.TextForWidth' f);  	double width;  	double r = styles.CellXfs [cell.StyleID].TextRotation;  	if (r <= 0) {  		width = (size.Width + 5) / normalSize;  	}  	else {  		r = (r <= 90 ? r : r - 90);  		width = (((size.Width - size.Height) * Math.Abs (System.Math.Cos (System.Math.PI * r / 180.0)) + size.Height) + 5) / normalSize;  	}  	foreach (var a in afAddr) {  		if (a.Collide (cell) != eAddressCollition.No) {  			width += 2.25;  			break;  		}  	}  	if (width > _worksheet.Column (cell._fromCol).Width) {  		_worksheet.Column (cell._fromCol).Width = width > MaximumWidth ? MaximumWidth : width;  	}  }  
Magic Number,OfficeOpenXml,ExcelRangeBase,C:\repos\bambit_EPPlus\EPPlus\ExcelRangeBase.cs,AutoFitColumns,The following statement contains a magic number: if (r <= 0) {  	width = (size.Width + 5) / normalSize;  }  else {  	r = (r <= 90 ? r : r - 90);  	width = (((size.Width - size.Height) * Math.Abs (System.Math.Cos (System.Math.PI * r / 180.0)) + size.Height) + 5) / normalSize;  }  
Magic Number,OfficeOpenXml,ExcelRangeBase,C:\repos\bambit_EPPlus\EPPlus\ExcelRangeBase.cs,AutoFitColumns,The following statement contains a magic number: if (r <= 0) {  	width = (size.Width + 5) / normalSize;  }  else {  	r = (r <= 90 ? r : r - 90);  	width = (((size.Width - size.Height) * Math.Abs (System.Math.Cos (System.Math.PI * r / 180.0)) + size.Height) + 5) / normalSize;  }  
Magic Number,OfficeOpenXml,ExcelRangeBase,C:\repos\bambit_EPPlus\EPPlus\ExcelRangeBase.cs,AutoFitColumns,The following statement contains a magic number: if (r <= 0) {  	width = (size.Width + 5) / normalSize;  }  else {  	r = (r <= 90 ? r : r - 90);  	width = (((size.Width - size.Height) * Math.Abs (System.Math.Cos (System.Math.PI * r / 180.0)) + size.Height) + 5) / normalSize;  }  
Magic Number,OfficeOpenXml,ExcelRangeBase,C:\repos\bambit_EPPlus\EPPlus\ExcelRangeBase.cs,AutoFitColumns,The following statement contains a magic number: if (r <= 0) {  	width = (size.Width + 5) / normalSize;  }  else {  	r = (r <= 90 ? r : r - 90);  	width = (((size.Width - size.Height) * Math.Abs (System.Math.Cos (System.Math.PI * r / 180.0)) + size.Height) + 5) / normalSize;  }  
Magic Number,OfficeOpenXml,ExcelRangeBase,C:\repos\bambit_EPPlus\EPPlus\ExcelRangeBase.cs,AutoFitColumns,The following statement contains a magic number: if (r <= 0) {  	width = (size.Width + 5) / normalSize;  }  else {  	r = (r <= 90 ? r : r - 90);  	width = (((size.Width - size.Height) * Math.Abs (System.Math.Cos (System.Math.PI * r / 180.0)) + size.Height) + 5) / normalSize;  }  
Magic Number,OfficeOpenXml,ExcelRangeBase,C:\repos\bambit_EPPlus\EPPlus\ExcelRangeBase.cs,AutoFitColumns,The following statement contains a magic number: width = (size.Width + 5) / normalSize;  
Magic Number,OfficeOpenXml,ExcelRangeBase,C:\repos\bambit_EPPlus\EPPlus\ExcelRangeBase.cs,AutoFitColumns,The following statement contains a magic number: r = (r <= 90 ? r : r - 90);  
Magic Number,OfficeOpenXml,ExcelRangeBase,C:\repos\bambit_EPPlus\EPPlus\ExcelRangeBase.cs,AutoFitColumns,The following statement contains a magic number: r = (r <= 90 ? r : r - 90);  
Magic Number,OfficeOpenXml,ExcelRangeBase,C:\repos\bambit_EPPlus\EPPlus\ExcelRangeBase.cs,AutoFitColumns,The following statement contains a magic number: width = (((size.Width - size.Height) * Math.Abs (System.Math.Cos (System.Math.PI * r / 180.0)) + size.Height) + 5) / normalSize;  
Magic Number,OfficeOpenXml,ExcelRangeBase,C:\repos\bambit_EPPlus\EPPlus\ExcelRangeBase.cs,AutoFitColumns,The following statement contains a magic number: width = (((size.Width - size.Height) * Math.Abs (System.Math.Cos (System.Math.PI * r / 180.0)) + size.Height) + 5) / normalSize;  
Magic Number,OfficeOpenXml,ExcelRangeBase,C:\repos\bambit_EPPlus\EPPlus\ExcelRangeBase.cs,AutoFitColumns,The following statement contains a magic number: foreach (var a in afAddr) {  	if (a.Collide (cell) != eAddressCollition.No) {  		width += 2.25;  		break;  	}  }  
Magic Number,OfficeOpenXml,ExcelRangeBase,C:\repos\bambit_EPPlus\EPPlus\ExcelRangeBase.cs,AutoFitColumns,The following statement contains a magic number: if (a.Collide (cell) != eAddressCollition.No) {  	width += 2.25;  	break;  }  
Magic Number,OfficeOpenXml,ExcelRangeBase,C:\repos\bambit_EPPlus\EPPlus\ExcelRangeBase.cs,AutoFitColumns,The following statement contains a magic number: width += 2.25;  
Magic Number,OfficeOpenXml,ExcelRangeBase,C:\repos\bambit_EPPlus\EPPlus\ExcelRangeBase.cs,ConvertData,The following statement contains a magic number: if (Format.DataTypes == null || Format.DataTypes.Length < col || Format.DataTypes [col] == eDataTypes.Unknown) {  	string v2 = v.EndsWith ("%") ? v.Substring (0' v.Length - 1) : v;  	if (double.TryParse (v2' NumberStyles.Any' Format.Culture' out d)) {  		if (v2 == v) {  			return d;  		}  		else {  			return d / 100;  		}  	}  	if (DateTime.TryParse (v' Format.Culture' DateTimeStyles.None' out dt)) {  		return dt;  	}  	else {  		return v;  	}  }  else {  	switch (Format.DataTypes [col]) {  	case eDataTypes.Number:  		if (double.TryParse (v' NumberStyles.Any' Format.Culture' out d)) {  			return d;  		}  		else {  			return v;  		}  	case eDataTypes.DateTime:  		if (DateTime.TryParse (v' Format.Culture' DateTimeStyles.None' out dt)) {  			return dt;  		}  		else {  			return v;  		}  	case eDataTypes.Percent:  		string v2 = v.EndsWith ("%") ? v.Substring (0' v.Length - 1) : v;  		if (double.TryParse (v2' NumberStyles.Any' Format.Culture' out d)) {  			return d / 100;  		}  		else {  			return v;  		}  	default:  		return v;  	}  }  
Magic Number,OfficeOpenXml,ExcelRangeBase,C:\repos\bambit_EPPlus\EPPlus\ExcelRangeBase.cs,ConvertData,The following statement contains a magic number: if (Format.DataTypes == null || Format.DataTypes.Length < col || Format.DataTypes [col] == eDataTypes.Unknown) {  	string v2 = v.EndsWith ("%") ? v.Substring (0' v.Length - 1) : v;  	if (double.TryParse (v2' NumberStyles.Any' Format.Culture' out d)) {  		if (v2 == v) {  			return d;  		}  		else {  			return d / 100;  		}  	}  	if (DateTime.TryParse (v' Format.Culture' DateTimeStyles.None' out dt)) {  		return dt;  	}  	else {  		return v;  	}  }  else {  	switch (Format.DataTypes [col]) {  	case eDataTypes.Number:  		if (double.TryParse (v' NumberStyles.Any' Format.Culture' out d)) {  			return d;  		}  		else {  			return v;  		}  	case eDataTypes.DateTime:  		if (DateTime.TryParse (v' Format.Culture' DateTimeStyles.None' out dt)) {  			return dt;  		}  		else {  			return v;  		}  	case eDataTypes.Percent:  		string v2 = v.EndsWith ("%") ? v.Substring (0' v.Length - 1) : v;  		if (double.TryParse (v2' NumberStyles.Any' Format.Culture' out d)) {  			return d / 100;  		}  		else {  			return v;  		}  	default:  		return v;  	}  }  
Magic Number,OfficeOpenXml,ExcelRangeBase,C:\repos\bambit_EPPlus\EPPlus\ExcelRangeBase.cs,ConvertData,The following statement contains a magic number: if (double.TryParse (v2' NumberStyles.Any' Format.Culture' out d)) {  	if (v2 == v) {  		return d;  	}  	else {  		return d / 100;  	}  }  
Magic Number,OfficeOpenXml,ExcelRangeBase,C:\repos\bambit_EPPlus\EPPlus\ExcelRangeBase.cs,ConvertData,The following statement contains a magic number: if (v2 == v) {  	return d;  }  else {  	return d / 100;  }  
Magic Number,OfficeOpenXml,ExcelRangeBase,C:\repos\bambit_EPPlus\EPPlus\ExcelRangeBase.cs,ConvertData,The following statement contains a magic number: return d / 100;  
Magic Number,OfficeOpenXml,ExcelRangeBase,C:\repos\bambit_EPPlus\EPPlus\ExcelRangeBase.cs,ConvertData,The following statement contains a magic number: switch (Format.DataTypes [col]) {  case eDataTypes.Number:  	if (double.TryParse (v' NumberStyles.Any' Format.Culture' out d)) {  		return d;  	}  	else {  		return v;  	}  case eDataTypes.DateTime:  	if (DateTime.TryParse (v' Format.Culture' DateTimeStyles.None' out dt)) {  		return dt;  	}  	else {  		return v;  	}  case eDataTypes.Percent:  	string v2 = v.EndsWith ("%") ? v.Substring (0' v.Length - 1) : v;  	if (double.TryParse (v2' NumberStyles.Any' Format.Culture' out d)) {  		return d / 100;  	}  	else {  		return v;  	}  default:  	return v;  }  
Magic Number,OfficeOpenXml,ExcelRangeBase,C:\repos\bambit_EPPlus\EPPlus\ExcelRangeBase.cs,ConvertData,The following statement contains a magic number: if (double.TryParse (v2' NumberStyles.Any' Format.Culture' out d)) {  	return d / 100;  }  else {  	return v;  }  
Magic Number,OfficeOpenXml,ExcelRangeBase,C:\repos\bambit_EPPlus\EPPlus\ExcelRangeBase.cs,ConvertData,The following statement contains a magic number: return d / 100;  
Magic Number,OfficeOpenXml,ExcelRangeBase,C:\repos\bambit_EPPlus\EPPlus\ExcelRangeBase.cs,LoadFromText,The following statement contains a magic number: foreach (string line in lines) {  	if (lineNo > Format.SkipLinesBeginning && lineNo <= lines.Length - Format.SkipLinesEnd) {  		col = _fromCol;  		string v = "";  		bool isText = false' isQualifier = false;  		int QCount = 0;  		foreach (char c in line) {  			if (Format.TextQualifier != 0 && c == Format.TextQualifier) {  				if (!isText && v != "") {  					throw (new Exception (string.Format ("Invalid Text Qualifier in line : {0}"' line)));  				}  				isQualifier = !isQualifier;  				QCount += 1;  				isText = true;  			}  			else {  				if (QCount > 1 && !string.IsNullOrEmpty (v)) {  					v += new string (Format.TextQualifier' QCount / 2);  				}  				else if (QCount > 2 && string.IsNullOrEmpty (v)) {  					v += new string (Format.TextQualifier' (QCount - 1) / 2);  				}  				if (isQualifier) {  					v += c;  				}  				else {  					if (c == Format.Delimiter) {  						_worksheet.Cell (row' col).Value = ConvertData (Format' v' col - _fromCol' isText);  						v = "";  						isText = false;  						col++;  					}  					else {  						if (QCount % 2 == 1) {  							throw (new Exception (string.Format ("Text delimiter is not closed in line : {0}"' line)));  						}  						v += c;  					}  				}  				QCount = 0;  			}  		}  		if (QCount > 1) {  			v += new string (Format.TextQualifier' QCount / 2);  		}  		_worksheet.Cell (row' col).Value = ConvertData (Format' v' col - _fromCol' isText);  		if (col > maxCol)  			maxCol = col;  		row++;  	}  	lineNo++;  }  
Magic Number,OfficeOpenXml,ExcelRangeBase,C:\repos\bambit_EPPlus\EPPlus\ExcelRangeBase.cs,LoadFromText,The following statement contains a magic number: foreach (string line in lines) {  	if (lineNo > Format.SkipLinesBeginning && lineNo <= lines.Length - Format.SkipLinesEnd) {  		col = _fromCol;  		string v = "";  		bool isText = false' isQualifier = false;  		int QCount = 0;  		foreach (char c in line) {  			if (Format.TextQualifier != 0 && c == Format.TextQualifier) {  				if (!isText && v != "") {  					throw (new Exception (string.Format ("Invalid Text Qualifier in line : {0}"' line)));  				}  				isQualifier = !isQualifier;  				QCount += 1;  				isText = true;  			}  			else {  				if (QCount > 1 && !string.IsNullOrEmpty (v)) {  					v += new string (Format.TextQualifier' QCount / 2);  				}  				else if (QCount > 2 && string.IsNullOrEmpty (v)) {  					v += new string (Format.TextQualifier' (QCount - 1) / 2);  				}  				if (isQualifier) {  					v += c;  				}  				else {  					if (c == Format.Delimiter) {  						_worksheet.Cell (row' col).Value = ConvertData (Format' v' col - _fromCol' isText);  						v = "";  						isText = false;  						col++;  					}  					else {  						if (QCount % 2 == 1) {  							throw (new Exception (string.Format ("Text delimiter is not closed in line : {0}"' line)));  						}  						v += c;  					}  				}  				QCount = 0;  			}  		}  		if (QCount > 1) {  			v += new string (Format.TextQualifier' QCount / 2);  		}  		_worksheet.Cell (row' col).Value = ConvertData (Format' v' col - _fromCol' isText);  		if (col > maxCol)  			maxCol = col;  		row++;  	}  	lineNo++;  }  
Magic Number,OfficeOpenXml,ExcelRangeBase,C:\repos\bambit_EPPlus\EPPlus\ExcelRangeBase.cs,LoadFromText,The following statement contains a magic number: foreach (string line in lines) {  	if (lineNo > Format.SkipLinesBeginning && lineNo <= lines.Length - Format.SkipLinesEnd) {  		col = _fromCol;  		string v = "";  		bool isText = false' isQualifier = false;  		int QCount = 0;  		foreach (char c in line) {  			if (Format.TextQualifier != 0 && c == Format.TextQualifier) {  				if (!isText && v != "") {  					throw (new Exception (string.Format ("Invalid Text Qualifier in line : {0}"' line)));  				}  				isQualifier = !isQualifier;  				QCount += 1;  				isText = true;  			}  			else {  				if (QCount > 1 && !string.IsNullOrEmpty (v)) {  					v += new string (Format.TextQualifier' QCount / 2);  				}  				else if (QCount > 2 && string.IsNullOrEmpty (v)) {  					v += new string (Format.TextQualifier' (QCount - 1) / 2);  				}  				if (isQualifier) {  					v += c;  				}  				else {  					if (c == Format.Delimiter) {  						_worksheet.Cell (row' col).Value = ConvertData (Format' v' col - _fromCol' isText);  						v = "";  						isText = false;  						col++;  					}  					else {  						if (QCount % 2 == 1) {  							throw (new Exception (string.Format ("Text delimiter is not closed in line : {0}"' line)));  						}  						v += c;  					}  				}  				QCount = 0;  			}  		}  		if (QCount > 1) {  			v += new string (Format.TextQualifier' QCount / 2);  		}  		_worksheet.Cell (row' col).Value = ConvertData (Format' v' col - _fromCol' isText);  		if (col > maxCol)  			maxCol = col;  		row++;  	}  	lineNo++;  }  
Magic Number,OfficeOpenXml,ExcelRangeBase,C:\repos\bambit_EPPlus\EPPlus\ExcelRangeBase.cs,LoadFromText,The following statement contains a magic number: foreach (string line in lines) {  	if (lineNo > Format.SkipLinesBeginning && lineNo <= lines.Length - Format.SkipLinesEnd) {  		col = _fromCol;  		string v = "";  		bool isText = false' isQualifier = false;  		int QCount = 0;  		foreach (char c in line) {  			if (Format.TextQualifier != 0 && c == Format.TextQualifier) {  				if (!isText && v != "") {  					throw (new Exception (string.Format ("Invalid Text Qualifier in line : {0}"' line)));  				}  				isQualifier = !isQualifier;  				QCount += 1;  				isText = true;  			}  			else {  				if (QCount > 1 && !string.IsNullOrEmpty (v)) {  					v += new string (Format.TextQualifier' QCount / 2);  				}  				else if (QCount > 2 && string.IsNullOrEmpty (v)) {  					v += new string (Format.TextQualifier' (QCount - 1) / 2);  				}  				if (isQualifier) {  					v += c;  				}  				else {  					if (c == Format.Delimiter) {  						_worksheet.Cell (row' col).Value = ConvertData (Format' v' col - _fromCol' isText);  						v = "";  						isText = false;  						col++;  					}  					else {  						if (QCount % 2 == 1) {  							throw (new Exception (string.Format ("Text delimiter is not closed in line : {0}"' line)));  						}  						v += c;  					}  				}  				QCount = 0;  			}  		}  		if (QCount > 1) {  			v += new string (Format.TextQualifier' QCount / 2);  		}  		_worksheet.Cell (row' col).Value = ConvertData (Format' v' col - _fromCol' isText);  		if (col > maxCol)  			maxCol = col;  		row++;  	}  	lineNo++;  }  
Magic Number,OfficeOpenXml,ExcelRangeBase,C:\repos\bambit_EPPlus\EPPlus\ExcelRangeBase.cs,LoadFromText,The following statement contains a magic number: foreach (string line in lines) {  	if (lineNo > Format.SkipLinesBeginning && lineNo <= lines.Length - Format.SkipLinesEnd) {  		col = _fromCol;  		string v = "";  		bool isText = false' isQualifier = false;  		int QCount = 0;  		foreach (char c in line) {  			if (Format.TextQualifier != 0 && c == Format.TextQualifier) {  				if (!isText && v != "") {  					throw (new Exception (string.Format ("Invalid Text Qualifier in line : {0}"' line)));  				}  				isQualifier = !isQualifier;  				QCount += 1;  				isText = true;  			}  			else {  				if (QCount > 1 && !string.IsNullOrEmpty (v)) {  					v += new string (Format.TextQualifier' QCount / 2);  				}  				else if (QCount > 2 && string.IsNullOrEmpty (v)) {  					v += new string (Format.TextQualifier' (QCount - 1) / 2);  				}  				if (isQualifier) {  					v += c;  				}  				else {  					if (c == Format.Delimiter) {  						_worksheet.Cell (row' col).Value = ConvertData (Format' v' col - _fromCol' isText);  						v = "";  						isText = false;  						col++;  					}  					else {  						if (QCount % 2 == 1) {  							throw (new Exception (string.Format ("Text delimiter is not closed in line : {0}"' line)));  						}  						v += c;  					}  				}  				QCount = 0;  			}  		}  		if (QCount > 1) {  			v += new string (Format.TextQualifier' QCount / 2);  		}  		_worksheet.Cell (row' col).Value = ConvertData (Format' v' col - _fromCol' isText);  		if (col > maxCol)  			maxCol = col;  		row++;  	}  	lineNo++;  }  
Magic Number,OfficeOpenXml,ExcelRangeBase,C:\repos\bambit_EPPlus\EPPlus\ExcelRangeBase.cs,LoadFromText,The following statement contains a magic number: if (lineNo > Format.SkipLinesBeginning && lineNo <= lines.Length - Format.SkipLinesEnd) {  	col = _fromCol;  	string v = "";  	bool isText = false' isQualifier = false;  	int QCount = 0;  	foreach (char c in line) {  		if (Format.TextQualifier != 0 && c == Format.TextQualifier) {  			if (!isText && v != "") {  				throw (new Exception (string.Format ("Invalid Text Qualifier in line : {0}"' line)));  			}  			isQualifier = !isQualifier;  			QCount += 1;  			isText = true;  		}  		else {  			if (QCount > 1 && !string.IsNullOrEmpty (v)) {  				v += new string (Format.TextQualifier' QCount / 2);  			}  			else if (QCount > 2 && string.IsNullOrEmpty (v)) {  				v += new string (Format.TextQualifier' (QCount - 1) / 2);  			}  			if (isQualifier) {  				v += c;  			}  			else {  				if (c == Format.Delimiter) {  					_worksheet.Cell (row' col).Value = ConvertData (Format' v' col - _fromCol' isText);  					v = "";  					isText = false;  					col++;  				}  				else {  					if (QCount % 2 == 1) {  						throw (new Exception (string.Format ("Text delimiter is not closed in line : {0}"' line)));  					}  					v += c;  				}  			}  			QCount = 0;  		}  	}  	if (QCount > 1) {  		v += new string (Format.TextQualifier' QCount / 2);  	}  	_worksheet.Cell (row' col).Value = ConvertData (Format' v' col - _fromCol' isText);  	if (col > maxCol)  		maxCol = col;  	row++;  }  
Magic Number,OfficeOpenXml,ExcelRangeBase,C:\repos\bambit_EPPlus\EPPlus\ExcelRangeBase.cs,LoadFromText,The following statement contains a magic number: if (lineNo > Format.SkipLinesBeginning && lineNo <= lines.Length - Format.SkipLinesEnd) {  	col = _fromCol;  	string v = "";  	bool isText = false' isQualifier = false;  	int QCount = 0;  	foreach (char c in line) {  		if (Format.TextQualifier != 0 && c == Format.TextQualifier) {  			if (!isText && v != "") {  				throw (new Exception (string.Format ("Invalid Text Qualifier in line : {0}"' line)));  			}  			isQualifier = !isQualifier;  			QCount += 1;  			isText = true;  		}  		else {  			if (QCount > 1 && !string.IsNullOrEmpty (v)) {  				v += new string (Format.TextQualifier' QCount / 2);  			}  			else if (QCount > 2 && string.IsNullOrEmpty (v)) {  				v += new string (Format.TextQualifier' (QCount - 1) / 2);  			}  			if (isQualifier) {  				v += c;  			}  			else {  				if (c == Format.Delimiter) {  					_worksheet.Cell (row' col).Value = ConvertData (Format' v' col - _fromCol' isText);  					v = "";  					isText = false;  					col++;  				}  				else {  					if (QCount % 2 == 1) {  						throw (new Exception (string.Format ("Text delimiter is not closed in line : {0}"' line)));  					}  					v += c;  				}  			}  			QCount = 0;  		}  	}  	if (QCount > 1) {  		v += new string (Format.TextQualifier' QCount / 2);  	}  	_worksheet.Cell (row' col).Value = ConvertData (Format' v' col - _fromCol' isText);  	if (col > maxCol)  		maxCol = col;  	row++;  }  
Magic Number,OfficeOpenXml,ExcelRangeBase,C:\repos\bambit_EPPlus\EPPlus\ExcelRangeBase.cs,LoadFromText,The following statement contains a magic number: if (lineNo > Format.SkipLinesBeginning && lineNo <= lines.Length - Format.SkipLinesEnd) {  	col = _fromCol;  	string v = "";  	bool isText = false' isQualifier = false;  	int QCount = 0;  	foreach (char c in line) {  		if (Format.TextQualifier != 0 && c == Format.TextQualifier) {  			if (!isText && v != "") {  				throw (new Exception (string.Format ("Invalid Text Qualifier in line : {0}"' line)));  			}  			isQualifier = !isQualifier;  			QCount += 1;  			isText = true;  		}  		else {  			if (QCount > 1 && !string.IsNullOrEmpty (v)) {  				v += new string (Format.TextQualifier' QCount / 2);  			}  			else if (QCount > 2 && string.IsNullOrEmpty (v)) {  				v += new string (Format.TextQualifier' (QCount - 1) / 2);  			}  			if (isQualifier) {  				v += c;  			}  			else {  				if (c == Format.Delimiter) {  					_worksheet.Cell (row' col).Value = ConvertData (Format' v' col - _fromCol' isText);  					v = "";  					isText = false;  					col++;  				}  				else {  					if (QCount % 2 == 1) {  						throw (new Exception (string.Format ("Text delimiter is not closed in line : {0}"' line)));  					}  					v += c;  				}  			}  			QCount = 0;  		}  	}  	if (QCount > 1) {  		v += new string (Format.TextQualifier' QCount / 2);  	}  	_worksheet.Cell (row' col).Value = ConvertData (Format' v' col - _fromCol' isText);  	if (col > maxCol)  		maxCol = col;  	row++;  }  
Magic Number,OfficeOpenXml,ExcelRangeBase,C:\repos\bambit_EPPlus\EPPlus\ExcelRangeBase.cs,LoadFromText,The following statement contains a magic number: if (lineNo > Format.SkipLinesBeginning && lineNo <= lines.Length - Format.SkipLinesEnd) {  	col = _fromCol;  	string v = "";  	bool isText = false' isQualifier = false;  	int QCount = 0;  	foreach (char c in line) {  		if (Format.TextQualifier != 0 && c == Format.TextQualifier) {  			if (!isText && v != "") {  				throw (new Exception (string.Format ("Invalid Text Qualifier in line : {0}"' line)));  			}  			isQualifier = !isQualifier;  			QCount += 1;  			isText = true;  		}  		else {  			if (QCount > 1 && !string.IsNullOrEmpty (v)) {  				v += new string (Format.TextQualifier' QCount / 2);  			}  			else if (QCount > 2 && string.IsNullOrEmpty (v)) {  				v += new string (Format.TextQualifier' (QCount - 1) / 2);  			}  			if (isQualifier) {  				v += c;  			}  			else {  				if (c == Format.Delimiter) {  					_worksheet.Cell (row' col).Value = ConvertData (Format' v' col - _fromCol' isText);  					v = "";  					isText = false;  					col++;  				}  				else {  					if (QCount % 2 == 1) {  						throw (new Exception (string.Format ("Text delimiter is not closed in line : {0}"' line)));  					}  					v += c;  				}  			}  			QCount = 0;  		}  	}  	if (QCount > 1) {  		v += new string (Format.TextQualifier' QCount / 2);  	}  	_worksheet.Cell (row' col).Value = ConvertData (Format' v' col - _fromCol' isText);  	if (col > maxCol)  		maxCol = col;  	row++;  }  
Magic Number,OfficeOpenXml,ExcelRangeBase,C:\repos\bambit_EPPlus\EPPlus\ExcelRangeBase.cs,LoadFromText,The following statement contains a magic number: if (lineNo > Format.SkipLinesBeginning && lineNo <= lines.Length - Format.SkipLinesEnd) {  	col = _fromCol;  	string v = "";  	bool isText = false' isQualifier = false;  	int QCount = 0;  	foreach (char c in line) {  		if (Format.TextQualifier != 0 && c == Format.TextQualifier) {  			if (!isText && v != "") {  				throw (new Exception (string.Format ("Invalid Text Qualifier in line : {0}"' line)));  			}  			isQualifier = !isQualifier;  			QCount += 1;  			isText = true;  		}  		else {  			if (QCount > 1 && !string.IsNullOrEmpty (v)) {  				v += new string (Format.TextQualifier' QCount / 2);  			}  			else if (QCount > 2 && string.IsNullOrEmpty (v)) {  				v += new string (Format.TextQualifier' (QCount - 1) / 2);  			}  			if (isQualifier) {  				v += c;  			}  			else {  				if (c == Format.Delimiter) {  					_worksheet.Cell (row' col).Value = ConvertData (Format' v' col - _fromCol' isText);  					v = "";  					isText = false;  					col++;  				}  				else {  					if (QCount % 2 == 1) {  						throw (new Exception (string.Format ("Text delimiter is not closed in line : {0}"' line)));  					}  					v += c;  				}  			}  			QCount = 0;  		}  	}  	if (QCount > 1) {  		v += new string (Format.TextQualifier' QCount / 2);  	}  	_worksheet.Cell (row' col).Value = ConvertData (Format' v' col - _fromCol' isText);  	if (col > maxCol)  		maxCol = col;  	row++;  }  
Magic Number,OfficeOpenXml,ExcelRangeBase,C:\repos\bambit_EPPlus\EPPlus\ExcelRangeBase.cs,LoadFromText,The following statement contains a magic number: foreach (char c in line) {  	if (Format.TextQualifier != 0 && c == Format.TextQualifier) {  		if (!isText && v != "") {  			throw (new Exception (string.Format ("Invalid Text Qualifier in line : {0}"' line)));  		}  		isQualifier = !isQualifier;  		QCount += 1;  		isText = true;  	}  	else {  		if (QCount > 1 && !string.IsNullOrEmpty (v)) {  			v += new string (Format.TextQualifier' QCount / 2);  		}  		else if (QCount > 2 && string.IsNullOrEmpty (v)) {  			v += new string (Format.TextQualifier' (QCount - 1) / 2);  		}  		if (isQualifier) {  			v += c;  		}  		else {  			if (c == Format.Delimiter) {  				_worksheet.Cell (row' col).Value = ConvertData (Format' v' col - _fromCol' isText);  				v = "";  				isText = false;  				col++;  			}  			else {  				if (QCount % 2 == 1) {  					throw (new Exception (string.Format ("Text delimiter is not closed in line : {0}"' line)));  				}  				v += c;  			}  		}  		QCount = 0;  	}  }  
Magic Number,OfficeOpenXml,ExcelRangeBase,C:\repos\bambit_EPPlus\EPPlus\ExcelRangeBase.cs,LoadFromText,The following statement contains a magic number: foreach (char c in line) {  	if (Format.TextQualifier != 0 && c == Format.TextQualifier) {  		if (!isText && v != "") {  			throw (new Exception (string.Format ("Invalid Text Qualifier in line : {0}"' line)));  		}  		isQualifier = !isQualifier;  		QCount += 1;  		isText = true;  	}  	else {  		if (QCount > 1 && !string.IsNullOrEmpty (v)) {  			v += new string (Format.TextQualifier' QCount / 2);  		}  		else if (QCount > 2 && string.IsNullOrEmpty (v)) {  			v += new string (Format.TextQualifier' (QCount - 1) / 2);  		}  		if (isQualifier) {  			v += c;  		}  		else {  			if (c == Format.Delimiter) {  				_worksheet.Cell (row' col).Value = ConvertData (Format' v' col - _fromCol' isText);  				v = "";  				isText = false;  				col++;  			}  			else {  				if (QCount % 2 == 1) {  					throw (new Exception (string.Format ("Text delimiter is not closed in line : {0}"' line)));  				}  				v += c;  			}  		}  		QCount = 0;  	}  }  
Magic Number,OfficeOpenXml,ExcelRangeBase,C:\repos\bambit_EPPlus\EPPlus\ExcelRangeBase.cs,LoadFromText,The following statement contains a magic number: foreach (char c in line) {  	if (Format.TextQualifier != 0 && c == Format.TextQualifier) {  		if (!isText && v != "") {  			throw (new Exception (string.Format ("Invalid Text Qualifier in line : {0}"' line)));  		}  		isQualifier = !isQualifier;  		QCount += 1;  		isText = true;  	}  	else {  		if (QCount > 1 && !string.IsNullOrEmpty (v)) {  			v += new string (Format.TextQualifier' QCount / 2);  		}  		else if (QCount > 2 && string.IsNullOrEmpty (v)) {  			v += new string (Format.TextQualifier' (QCount - 1) / 2);  		}  		if (isQualifier) {  			v += c;  		}  		else {  			if (c == Format.Delimiter) {  				_worksheet.Cell (row' col).Value = ConvertData (Format' v' col - _fromCol' isText);  				v = "";  				isText = false;  				col++;  			}  			else {  				if (QCount % 2 == 1) {  					throw (new Exception (string.Format ("Text delimiter is not closed in line : {0}"' line)));  				}  				v += c;  			}  		}  		QCount = 0;  	}  }  
Magic Number,OfficeOpenXml,ExcelRangeBase,C:\repos\bambit_EPPlus\EPPlus\ExcelRangeBase.cs,LoadFromText,The following statement contains a magic number: foreach (char c in line) {  	if (Format.TextQualifier != 0 && c == Format.TextQualifier) {  		if (!isText && v != "") {  			throw (new Exception (string.Format ("Invalid Text Qualifier in line : {0}"' line)));  		}  		isQualifier = !isQualifier;  		QCount += 1;  		isText = true;  	}  	else {  		if (QCount > 1 && !string.IsNullOrEmpty (v)) {  			v += new string (Format.TextQualifier' QCount / 2);  		}  		else if (QCount > 2 && string.IsNullOrEmpty (v)) {  			v += new string (Format.TextQualifier' (QCount - 1) / 2);  		}  		if (isQualifier) {  			v += c;  		}  		else {  			if (c == Format.Delimiter) {  				_worksheet.Cell (row' col).Value = ConvertData (Format' v' col - _fromCol' isText);  				v = "";  				isText = false;  				col++;  			}  			else {  				if (QCount % 2 == 1) {  					throw (new Exception (string.Format ("Text delimiter is not closed in line : {0}"' line)));  				}  				v += c;  			}  		}  		QCount = 0;  	}  }  
Magic Number,OfficeOpenXml,ExcelRangeBase,C:\repos\bambit_EPPlus\EPPlus\ExcelRangeBase.cs,LoadFromText,The following statement contains a magic number: if (Format.TextQualifier != 0 && c == Format.TextQualifier) {  	if (!isText && v != "") {  		throw (new Exception (string.Format ("Invalid Text Qualifier in line : {0}"' line)));  	}  	isQualifier = !isQualifier;  	QCount += 1;  	isText = true;  }  else {  	if (QCount > 1 && !string.IsNullOrEmpty (v)) {  		v += new string (Format.TextQualifier' QCount / 2);  	}  	else if (QCount > 2 && string.IsNullOrEmpty (v)) {  		v += new string (Format.TextQualifier' (QCount - 1) / 2);  	}  	if (isQualifier) {  		v += c;  	}  	else {  		if (c == Format.Delimiter) {  			_worksheet.Cell (row' col).Value = ConvertData (Format' v' col - _fromCol' isText);  			v = "";  			isText = false;  			col++;  		}  		else {  			if (QCount % 2 == 1) {  				throw (new Exception (string.Format ("Text delimiter is not closed in line : {0}"' line)));  			}  			v += c;  		}  	}  	QCount = 0;  }  
Magic Number,OfficeOpenXml,ExcelRangeBase,C:\repos\bambit_EPPlus\EPPlus\ExcelRangeBase.cs,LoadFromText,The following statement contains a magic number: if (Format.TextQualifier != 0 && c == Format.TextQualifier) {  	if (!isText && v != "") {  		throw (new Exception (string.Format ("Invalid Text Qualifier in line : {0}"' line)));  	}  	isQualifier = !isQualifier;  	QCount += 1;  	isText = true;  }  else {  	if (QCount > 1 && !string.IsNullOrEmpty (v)) {  		v += new string (Format.TextQualifier' QCount / 2);  	}  	else if (QCount > 2 && string.IsNullOrEmpty (v)) {  		v += new string (Format.TextQualifier' (QCount - 1) / 2);  	}  	if (isQualifier) {  		v += c;  	}  	else {  		if (c == Format.Delimiter) {  			_worksheet.Cell (row' col).Value = ConvertData (Format' v' col - _fromCol' isText);  			v = "";  			isText = false;  			col++;  		}  		else {  			if (QCount % 2 == 1) {  				throw (new Exception (string.Format ("Text delimiter is not closed in line : {0}"' line)));  			}  			v += c;  		}  	}  	QCount = 0;  }  
Magic Number,OfficeOpenXml,ExcelRangeBase,C:\repos\bambit_EPPlus\EPPlus\ExcelRangeBase.cs,LoadFromText,The following statement contains a magic number: if (Format.TextQualifier != 0 && c == Format.TextQualifier) {  	if (!isText && v != "") {  		throw (new Exception (string.Format ("Invalid Text Qualifier in line : {0}"' line)));  	}  	isQualifier = !isQualifier;  	QCount += 1;  	isText = true;  }  else {  	if (QCount > 1 && !string.IsNullOrEmpty (v)) {  		v += new string (Format.TextQualifier' QCount / 2);  	}  	else if (QCount > 2 && string.IsNullOrEmpty (v)) {  		v += new string (Format.TextQualifier' (QCount - 1) / 2);  	}  	if (isQualifier) {  		v += c;  	}  	else {  		if (c == Format.Delimiter) {  			_worksheet.Cell (row' col).Value = ConvertData (Format' v' col - _fromCol' isText);  			v = "";  			isText = false;  			col++;  		}  		else {  			if (QCount % 2 == 1) {  				throw (new Exception (string.Format ("Text delimiter is not closed in line : {0}"' line)));  			}  			v += c;  		}  	}  	QCount = 0;  }  
Magic Number,OfficeOpenXml,ExcelRangeBase,C:\repos\bambit_EPPlus\EPPlus\ExcelRangeBase.cs,LoadFromText,The following statement contains a magic number: if (Format.TextQualifier != 0 && c == Format.TextQualifier) {  	if (!isText && v != "") {  		throw (new Exception (string.Format ("Invalid Text Qualifier in line : {0}"' line)));  	}  	isQualifier = !isQualifier;  	QCount += 1;  	isText = true;  }  else {  	if (QCount > 1 && !string.IsNullOrEmpty (v)) {  		v += new string (Format.TextQualifier' QCount / 2);  	}  	else if (QCount > 2 && string.IsNullOrEmpty (v)) {  		v += new string (Format.TextQualifier' (QCount - 1) / 2);  	}  	if (isQualifier) {  		v += c;  	}  	else {  		if (c == Format.Delimiter) {  			_worksheet.Cell (row' col).Value = ConvertData (Format' v' col - _fromCol' isText);  			v = "";  			isText = false;  			col++;  		}  		else {  			if (QCount % 2 == 1) {  				throw (new Exception (string.Format ("Text delimiter is not closed in line : {0}"' line)));  			}  			v += c;  		}  	}  	QCount = 0;  }  
Magic Number,OfficeOpenXml,ExcelRangeBase,C:\repos\bambit_EPPlus\EPPlus\ExcelRangeBase.cs,LoadFromText,The following statement contains a magic number: if (QCount > 1 && !string.IsNullOrEmpty (v)) {  	v += new string (Format.TextQualifier' QCount / 2);  }  else if (QCount > 2 && string.IsNullOrEmpty (v)) {  	v += new string (Format.TextQualifier' (QCount - 1) / 2);  }  
Magic Number,OfficeOpenXml,ExcelRangeBase,C:\repos\bambit_EPPlus\EPPlus\ExcelRangeBase.cs,LoadFromText,The following statement contains a magic number: if (QCount > 1 && !string.IsNullOrEmpty (v)) {  	v += new string (Format.TextQualifier' QCount / 2);  }  else if (QCount > 2 && string.IsNullOrEmpty (v)) {  	v += new string (Format.TextQualifier' (QCount - 1) / 2);  }  
Magic Number,OfficeOpenXml,ExcelRangeBase,C:\repos\bambit_EPPlus\EPPlus\ExcelRangeBase.cs,LoadFromText,The following statement contains a magic number: if (QCount > 1 && !string.IsNullOrEmpty (v)) {  	v += new string (Format.TextQualifier' QCount / 2);  }  else if (QCount > 2 && string.IsNullOrEmpty (v)) {  	v += new string (Format.TextQualifier' (QCount - 1) / 2);  }  
Magic Number,OfficeOpenXml,ExcelRangeBase,C:\repos\bambit_EPPlus\EPPlus\ExcelRangeBase.cs,LoadFromText,The following statement contains a magic number: v += new string (Format.TextQualifier' QCount / 2);  
Magic Number,OfficeOpenXml,ExcelRangeBase,C:\repos\bambit_EPPlus\EPPlus\ExcelRangeBase.cs,LoadFromText,The following statement contains a magic number: if (QCount > 2 && string.IsNullOrEmpty (v)) {  	v += new string (Format.TextQualifier' (QCount - 1) / 2);  }  
Magic Number,OfficeOpenXml,ExcelRangeBase,C:\repos\bambit_EPPlus\EPPlus\ExcelRangeBase.cs,LoadFromText,The following statement contains a magic number: if (QCount > 2 && string.IsNullOrEmpty (v)) {  	v += new string (Format.TextQualifier' (QCount - 1) / 2);  }  
Magic Number,OfficeOpenXml,ExcelRangeBase,C:\repos\bambit_EPPlus\EPPlus\ExcelRangeBase.cs,LoadFromText,The following statement contains a magic number: v += new string (Format.TextQualifier' (QCount - 1) / 2);  
Magic Number,OfficeOpenXml,ExcelRangeBase,C:\repos\bambit_EPPlus\EPPlus\ExcelRangeBase.cs,LoadFromText,The following statement contains a magic number: if (isQualifier) {  	v += c;  }  else {  	if (c == Format.Delimiter) {  		_worksheet.Cell (row' col).Value = ConvertData (Format' v' col - _fromCol' isText);  		v = "";  		isText = false;  		col++;  	}  	else {  		if (QCount % 2 == 1) {  			throw (new Exception (string.Format ("Text delimiter is not closed in line : {0}"' line)));  		}  		v += c;  	}  }  
Magic Number,OfficeOpenXml,ExcelRangeBase,C:\repos\bambit_EPPlus\EPPlus\ExcelRangeBase.cs,LoadFromText,The following statement contains a magic number: if (c == Format.Delimiter) {  	_worksheet.Cell (row' col).Value = ConvertData (Format' v' col - _fromCol' isText);  	v = "";  	isText = false;  	col++;  }  else {  	if (QCount % 2 == 1) {  		throw (new Exception (string.Format ("Text delimiter is not closed in line : {0}"' line)));  	}  	v += c;  }  
Magic Number,OfficeOpenXml,ExcelRangeBase,C:\repos\bambit_EPPlus\EPPlus\ExcelRangeBase.cs,LoadFromText,The following statement contains a magic number: if (QCount % 2 == 1) {  	throw (new Exception (string.Format ("Text delimiter is not closed in line : {0}"' line)));  }  
Magic Number,OfficeOpenXml,ExcelRangeBase,C:\repos\bambit_EPPlus\EPPlus\ExcelRangeBase.cs,LoadFromText,The following statement contains a magic number: if (QCount > 1) {  	v += new string (Format.TextQualifier' QCount / 2);  }  
Magic Number,OfficeOpenXml,ExcelRangeBase,C:\repos\bambit_EPPlus\EPPlus\ExcelRangeBase.cs,LoadFromText,The following statement contains a magic number: v += new string (Format.TextQualifier' QCount / 2);  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadModules,The following statement contains a magic number: foreach (var modul in Modules) {  	var stream = Document.Storage.SubStorage ["VBA"].DataStreams [modul.streamName];  	var byCode = CompoundDocument.DecompressPart (stream' (int)modul.ModuleOffset);  	string code = Encoding.GetEncoding (CodePage).GetString (byCode);  	int pos = 0;  	while (pos + 9 < code.Length && code.Substring (pos' 9) == "Attribute") {  		int linePos = code.IndexOf ("\r\n"' pos);  		string[] lineSplit;  		if (linePos > 0) {  			lineSplit = code.Substring (pos + 9' linePos - pos - 9).Split ('=');  		}  		else {  			lineSplit = code.Substring (pos + 9).Split (new char[] {  				'='  			}' 1);  		}  		if (lineSplit.Length > 1) {  			lineSplit [1] = lineSplit [1].Trim ();  			var attr = new ExcelVbaModuleAttribute () {  				Name = lineSplit [0].Trim ()'  				DataType = lineSplit [1].StartsWith ("\"") ? eAttributeDataType.String : eAttributeDataType.NonString'  				Value = lineSplit [1].StartsWith ("\"") ? lineSplit [1].Substring (1' lineSplit [1].Length - 2) : lineSplit [1]  			};  			modul.Attributes._list.Add (attr);  		}  		pos = linePos + 2;  	}  	modul.Code = code.Substring (pos);  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadModules,The following statement contains a magic number: foreach (var modul in Modules) {  	var stream = Document.Storage.SubStorage ["VBA"].DataStreams [modul.streamName];  	var byCode = CompoundDocument.DecompressPart (stream' (int)modul.ModuleOffset);  	string code = Encoding.GetEncoding (CodePage).GetString (byCode);  	int pos = 0;  	while (pos + 9 < code.Length && code.Substring (pos' 9) == "Attribute") {  		int linePos = code.IndexOf ("\r\n"' pos);  		string[] lineSplit;  		if (linePos > 0) {  			lineSplit = code.Substring (pos + 9' linePos - pos - 9).Split ('=');  		}  		else {  			lineSplit = code.Substring (pos + 9).Split (new char[] {  				'='  			}' 1);  		}  		if (lineSplit.Length > 1) {  			lineSplit [1] = lineSplit [1].Trim ();  			var attr = new ExcelVbaModuleAttribute () {  				Name = lineSplit [0].Trim ()'  				DataType = lineSplit [1].StartsWith ("\"") ? eAttributeDataType.String : eAttributeDataType.NonString'  				Value = lineSplit [1].StartsWith ("\"") ? lineSplit [1].Substring (1' lineSplit [1].Length - 2) : lineSplit [1]  			};  			modul.Attributes._list.Add (attr);  		}  		pos = linePos + 2;  	}  	modul.Code = code.Substring (pos);  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadModules,The following statement contains a magic number: foreach (var modul in Modules) {  	var stream = Document.Storage.SubStorage ["VBA"].DataStreams [modul.streamName];  	var byCode = CompoundDocument.DecompressPart (stream' (int)modul.ModuleOffset);  	string code = Encoding.GetEncoding (CodePage).GetString (byCode);  	int pos = 0;  	while (pos + 9 < code.Length && code.Substring (pos' 9) == "Attribute") {  		int linePos = code.IndexOf ("\r\n"' pos);  		string[] lineSplit;  		if (linePos > 0) {  			lineSplit = code.Substring (pos + 9' linePos - pos - 9).Split ('=');  		}  		else {  			lineSplit = code.Substring (pos + 9).Split (new char[] {  				'='  			}' 1);  		}  		if (lineSplit.Length > 1) {  			lineSplit [1] = lineSplit [1].Trim ();  			var attr = new ExcelVbaModuleAttribute () {  				Name = lineSplit [0].Trim ()'  				DataType = lineSplit [1].StartsWith ("\"") ? eAttributeDataType.String : eAttributeDataType.NonString'  				Value = lineSplit [1].StartsWith ("\"") ? lineSplit [1].Substring (1' lineSplit [1].Length - 2) : lineSplit [1]  			};  			modul.Attributes._list.Add (attr);  		}  		pos = linePos + 2;  	}  	modul.Code = code.Substring (pos);  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadModules,The following statement contains a magic number: foreach (var modul in Modules) {  	var stream = Document.Storage.SubStorage ["VBA"].DataStreams [modul.streamName];  	var byCode = CompoundDocument.DecompressPart (stream' (int)modul.ModuleOffset);  	string code = Encoding.GetEncoding (CodePage).GetString (byCode);  	int pos = 0;  	while (pos + 9 < code.Length && code.Substring (pos' 9) == "Attribute") {  		int linePos = code.IndexOf ("\r\n"' pos);  		string[] lineSplit;  		if (linePos > 0) {  			lineSplit = code.Substring (pos + 9' linePos - pos - 9).Split ('=');  		}  		else {  			lineSplit = code.Substring (pos + 9).Split (new char[] {  				'='  			}' 1);  		}  		if (lineSplit.Length > 1) {  			lineSplit [1] = lineSplit [1].Trim ();  			var attr = new ExcelVbaModuleAttribute () {  				Name = lineSplit [0].Trim ()'  				DataType = lineSplit [1].StartsWith ("\"") ? eAttributeDataType.String : eAttributeDataType.NonString'  				Value = lineSplit [1].StartsWith ("\"") ? lineSplit [1].Substring (1' lineSplit [1].Length - 2) : lineSplit [1]  			};  			modul.Attributes._list.Add (attr);  		}  		pos = linePos + 2;  	}  	modul.Code = code.Substring (pos);  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadModules,The following statement contains a magic number: foreach (var modul in Modules) {  	var stream = Document.Storage.SubStorage ["VBA"].DataStreams [modul.streamName];  	var byCode = CompoundDocument.DecompressPart (stream' (int)modul.ModuleOffset);  	string code = Encoding.GetEncoding (CodePage).GetString (byCode);  	int pos = 0;  	while (pos + 9 < code.Length && code.Substring (pos' 9) == "Attribute") {  		int linePos = code.IndexOf ("\r\n"' pos);  		string[] lineSplit;  		if (linePos > 0) {  			lineSplit = code.Substring (pos + 9' linePos - pos - 9).Split ('=');  		}  		else {  			lineSplit = code.Substring (pos + 9).Split (new char[] {  				'='  			}' 1);  		}  		if (lineSplit.Length > 1) {  			lineSplit [1] = lineSplit [1].Trim ();  			var attr = new ExcelVbaModuleAttribute () {  				Name = lineSplit [0].Trim ()'  				DataType = lineSplit [1].StartsWith ("\"") ? eAttributeDataType.String : eAttributeDataType.NonString'  				Value = lineSplit [1].StartsWith ("\"") ? lineSplit [1].Substring (1' lineSplit [1].Length - 2) : lineSplit [1]  			};  			modul.Attributes._list.Add (attr);  		}  		pos = linePos + 2;  	}  	modul.Code = code.Substring (pos);  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadModules,The following statement contains a magic number: foreach (var modul in Modules) {  	var stream = Document.Storage.SubStorage ["VBA"].DataStreams [modul.streamName];  	var byCode = CompoundDocument.DecompressPart (stream' (int)modul.ModuleOffset);  	string code = Encoding.GetEncoding (CodePage).GetString (byCode);  	int pos = 0;  	while (pos + 9 < code.Length && code.Substring (pos' 9) == "Attribute") {  		int linePos = code.IndexOf ("\r\n"' pos);  		string[] lineSplit;  		if (linePos > 0) {  			lineSplit = code.Substring (pos + 9' linePos - pos - 9).Split ('=');  		}  		else {  			lineSplit = code.Substring (pos + 9).Split (new char[] {  				'='  			}' 1);  		}  		if (lineSplit.Length > 1) {  			lineSplit [1] = lineSplit [1].Trim ();  			var attr = new ExcelVbaModuleAttribute () {  				Name = lineSplit [0].Trim ()'  				DataType = lineSplit [1].StartsWith ("\"") ? eAttributeDataType.String : eAttributeDataType.NonString'  				Value = lineSplit [1].StartsWith ("\"") ? lineSplit [1].Substring (1' lineSplit [1].Length - 2) : lineSplit [1]  			};  			modul.Attributes._list.Add (attr);  		}  		pos = linePos + 2;  	}  	modul.Code = code.Substring (pos);  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadModules,The following statement contains a magic number: foreach (var modul in Modules) {  	var stream = Document.Storage.SubStorage ["VBA"].DataStreams [modul.streamName];  	var byCode = CompoundDocument.DecompressPart (stream' (int)modul.ModuleOffset);  	string code = Encoding.GetEncoding (CodePage).GetString (byCode);  	int pos = 0;  	while (pos + 9 < code.Length && code.Substring (pos' 9) == "Attribute") {  		int linePos = code.IndexOf ("\r\n"' pos);  		string[] lineSplit;  		if (linePos > 0) {  			lineSplit = code.Substring (pos + 9' linePos - pos - 9).Split ('=');  		}  		else {  			lineSplit = code.Substring (pos + 9).Split (new char[] {  				'='  			}' 1);  		}  		if (lineSplit.Length > 1) {  			lineSplit [1] = lineSplit [1].Trim ();  			var attr = new ExcelVbaModuleAttribute () {  				Name = lineSplit [0].Trim ()'  				DataType = lineSplit [1].StartsWith ("\"") ? eAttributeDataType.String : eAttributeDataType.NonString'  				Value = lineSplit [1].StartsWith ("\"") ? lineSplit [1].Substring (1' lineSplit [1].Length - 2) : lineSplit [1]  			};  			modul.Attributes._list.Add (attr);  		}  		pos = linePos + 2;  	}  	modul.Code = code.Substring (pos);  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadModules,The following statement contains a magic number: while (pos + 9 < code.Length && code.Substring (pos' 9) == "Attribute") {  	int linePos = code.IndexOf ("\r\n"' pos);  	string[] lineSplit;  	if (linePos > 0) {  		lineSplit = code.Substring (pos + 9' linePos - pos - 9).Split ('=');  	}  	else {  		lineSplit = code.Substring (pos + 9).Split (new char[] {  			'='  		}' 1);  	}  	if (lineSplit.Length > 1) {  		lineSplit [1] = lineSplit [1].Trim ();  		var attr = new ExcelVbaModuleAttribute () {  			Name = lineSplit [0].Trim ()'  			DataType = lineSplit [1].StartsWith ("\"") ? eAttributeDataType.String : eAttributeDataType.NonString'  			Value = lineSplit [1].StartsWith ("\"") ? lineSplit [1].Substring (1' lineSplit [1].Length - 2) : lineSplit [1]  		};  		modul.Attributes._list.Add (attr);  	}  	pos = linePos + 2;  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadModules,The following statement contains a magic number: while (pos + 9 < code.Length && code.Substring (pos' 9) == "Attribute") {  	int linePos = code.IndexOf ("\r\n"' pos);  	string[] lineSplit;  	if (linePos > 0) {  		lineSplit = code.Substring (pos + 9' linePos - pos - 9).Split ('=');  	}  	else {  		lineSplit = code.Substring (pos + 9).Split (new char[] {  			'='  		}' 1);  	}  	if (lineSplit.Length > 1) {  		lineSplit [1] = lineSplit [1].Trim ();  		var attr = new ExcelVbaModuleAttribute () {  			Name = lineSplit [0].Trim ()'  			DataType = lineSplit [1].StartsWith ("\"") ? eAttributeDataType.String : eAttributeDataType.NonString'  			Value = lineSplit [1].StartsWith ("\"") ? lineSplit [1].Substring (1' lineSplit [1].Length - 2) : lineSplit [1]  		};  		modul.Attributes._list.Add (attr);  	}  	pos = linePos + 2;  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadModules,The following statement contains a magic number: while (pos + 9 < code.Length && code.Substring (pos' 9) == "Attribute") {  	int linePos = code.IndexOf ("\r\n"' pos);  	string[] lineSplit;  	if (linePos > 0) {  		lineSplit = code.Substring (pos + 9' linePos - pos - 9).Split ('=');  	}  	else {  		lineSplit = code.Substring (pos + 9).Split (new char[] {  			'='  		}' 1);  	}  	if (lineSplit.Length > 1) {  		lineSplit [1] = lineSplit [1].Trim ();  		var attr = new ExcelVbaModuleAttribute () {  			Name = lineSplit [0].Trim ()'  			DataType = lineSplit [1].StartsWith ("\"") ? eAttributeDataType.String : eAttributeDataType.NonString'  			Value = lineSplit [1].StartsWith ("\"") ? lineSplit [1].Substring (1' lineSplit [1].Length - 2) : lineSplit [1]  		};  		modul.Attributes._list.Add (attr);  	}  	pos = linePos + 2;  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadModules,The following statement contains a magic number: while (pos + 9 < code.Length && code.Substring (pos' 9) == "Attribute") {  	int linePos = code.IndexOf ("\r\n"' pos);  	string[] lineSplit;  	if (linePos > 0) {  		lineSplit = code.Substring (pos + 9' linePos - pos - 9).Split ('=');  	}  	else {  		lineSplit = code.Substring (pos + 9).Split (new char[] {  			'='  		}' 1);  	}  	if (lineSplit.Length > 1) {  		lineSplit [1] = lineSplit [1].Trim ();  		var attr = new ExcelVbaModuleAttribute () {  			Name = lineSplit [0].Trim ()'  			DataType = lineSplit [1].StartsWith ("\"") ? eAttributeDataType.String : eAttributeDataType.NonString'  			Value = lineSplit [1].StartsWith ("\"") ? lineSplit [1].Substring (1' lineSplit [1].Length - 2) : lineSplit [1]  		};  		modul.Attributes._list.Add (attr);  	}  	pos = linePos + 2;  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadModules,The following statement contains a magic number: while (pos + 9 < code.Length && code.Substring (pos' 9) == "Attribute") {  	int linePos = code.IndexOf ("\r\n"' pos);  	string[] lineSplit;  	if (linePos > 0) {  		lineSplit = code.Substring (pos + 9' linePos - pos - 9).Split ('=');  	}  	else {  		lineSplit = code.Substring (pos + 9).Split (new char[] {  			'='  		}' 1);  	}  	if (lineSplit.Length > 1) {  		lineSplit [1] = lineSplit [1].Trim ();  		var attr = new ExcelVbaModuleAttribute () {  			Name = lineSplit [0].Trim ()'  			DataType = lineSplit [1].StartsWith ("\"") ? eAttributeDataType.String : eAttributeDataType.NonString'  			Value = lineSplit [1].StartsWith ("\"") ? lineSplit [1].Substring (1' lineSplit [1].Length - 2) : lineSplit [1]  		};  		modul.Attributes._list.Add (attr);  	}  	pos = linePos + 2;  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadModules,The following statement contains a magic number: while (pos + 9 < code.Length && code.Substring (pos' 9) == "Attribute") {  	int linePos = code.IndexOf ("\r\n"' pos);  	string[] lineSplit;  	if (linePos > 0) {  		lineSplit = code.Substring (pos + 9' linePos - pos - 9).Split ('=');  	}  	else {  		lineSplit = code.Substring (pos + 9).Split (new char[] {  			'='  		}' 1);  	}  	if (lineSplit.Length > 1) {  		lineSplit [1] = lineSplit [1].Trim ();  		var attr = new ExcelVbaModuleAttribute () {  			Name = lineSplit [0].Trim ()'  			DataType = lineSplit [1].StartsWith ("\"") ? eAttributeDataType.String : eAttributeDataType.NonString'  			Value = lineSplit [1].StartsWith ("\"") ? lineSplit [1].Substring (1' lineSplit [1].Length - 2) : lineSplit [1]  		};  		modul.Attributes._list.Add (attr);  	}  	pos = linePos + 2;  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadModules,The following statement contains a magic number: while (pos + 9 < code.Length && code.Substring (pos' 9) == "Attribute") {  	int linePos = code.IndexOf ("\r\n"' pos);  	string[] lineSplit;  	if (linePos > 0) {  		lineSplit = code.Substring (pos + 9' linePos - pos - 9).Split ('=');  	}  	else {  		lineSplit = code.Substring (pos + 9).Split (new char[] {  			'='  		}' 1);  	}  	if (lineSplit.Length > 1) {  		lineSplit [1] = lineSplit [1].Trim ();  		var attr = new ExcelVbaModuleAttribute () {  			Name = lineSplit [0].Trim ()'  			DataType = lineSplit [1].StartsWith ("\"") ? eAttributeDataType.String : eAttributeDataType.NonString'  			Value = lineSplit [1].StartsWith ("\"") ? lineSplit [1].Substring (1' lineSplit [1].Length - 2) : lineSplit [1]  		};  		modul.Attributes._list.Add (attr);  	}  	pos = linePos + 2;  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadModules,The following statement contains a magic number: if (linePos > 0) {  	lineSplit = code.Substring (pos + 9' linePos - pos - 9).Split ('=');  }  else {  	lineSplit = code.Substring (pos + 9).Split (new char[] {  		'='  	}' 1);  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadModules,The following statement contains a magic number: if (linePos > 0) {  	lineSplit = code.Substring (pos + 9' linePos - pos - 9).Split ('=');  }  else {  	lineSplit = code.Substring (pos + 9).Split (new char[] {  		'='  	}' 1);  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadModules,The following statement contains a magic number: if (linePos > 0) {  	lineSplit = code.Substring (pos + 9' linePos - pos - 9).Split ('=');  }  else {  	lineSplit = code.Substring (pos + 9).Split (new char[] {  		'='  	}' 1);  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadModules,The following statement contains a magic number: lineSplit = code.Substring (pos + 9' linePos - pos - 9).Split ('=');  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadModules,The following statement contains a magic number: lineSplit = code.Substring (pos + 9' linePos - pos - 9).Split ('=');  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadModules,The following statement contains a magic number: lineSplit = code.Substring (pos + 9).Split (new char[] {  	'='  }' 1);  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadModules,The following statement contains a magic number: if (lineSplit.Length > 1) {  	lineSplit [1] = lineSplit [1].Trim ();  	var attr = new ExcelVbaModuleAttribute () {  		Name = lineSplit [0].Trim ()'  		DataType = lineSplit [1].StartsWith ("\"") ? eAttributeDataType.String : eAttributeDataType.NonString'  		Value = lineSplit [1].StartsWith ("\"") ? lineSplit [1].Substring (1' lineSplit [1].Length - 2) : lineSplit [1]  	};  	modul.Attributes._list.Add (attr);  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadModules,The following statement contains a magic number: pos = linePos + 2;  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadProjectProperties,The following statement contains a magic number: foreach (string line in lines) {  	if (line.StartsWith ("[")) {  	}  	else {  		var split = line.Split ('=');  		if (split.Length > 1 && split [1].Length > 1 && split [1].StartsWith ("\""))//Remove any double qouates  		 {  			split [1] = split [1].Substring (1' split [1].Length - 2);  		}  		switch (split [0]) {  		case "ID":  			ProjectID = split [1];  			break;  		case "Document":  			string mn = split [1].Substring (0' split [1].IndexOf ("/&H"));  			Modules [mn].Type = eModuleType.Document;  			break;  		case "Package":  			prevPackage = split [1];  			break;  		case "BaseClass":  			Modules [split [1]].Type = eModuleType.Designer;  			Modules [split [1]].ClassID = prevPackage;  			break;  		case "Module":  			Modules [split [1]].Type = eModuleType.Module;  			break;  		case "Class":  			Modules [split [1]].Type = eModuleType.Class;  			break;  		case "HelpFile":  		case "Name":  		case "HelpContextID":  		case "Description":  		case "VersionCompatible32":  			break;  		//393222000"  		case "CMG":  			byte[] cmg = Decrypt (split [1]);  			_protection.UserProtected = (cmg [0] & 1) != 0;  			_protection.HostProtected = (cmg [0] & 2) != 0;  			_protection.VbeProtected = (cmg [0] & 4) != 0;  			break;  		case "DPB":  			byte[] dpb = Decrypt (split [1]);  			if (dpb.Length >= 28) {  				byte reserved = dpb [0];  				var flags = new byte[3];  				Array.Copy (dpb' 1' flags' 0' 3);  				var keyNoNulls = new byte[4];  				_protection.PasswordKey = new byte[4];  				Array.Copy (dpb' 4' keyNoNulls' 0' 4);  				var hashNoNulls = new byte[20];  				_protection.PasswordHash = new byte[20];  				Array.Copy (dpb' 8' hashNoNulls' 0' 20);  				//Handle 0x00 bitwise 2.4.4.3   				for (int i = 0; i < 24; i++) {  					int bit = 128 >> (int)((i % 8));  					if (i < 4) {  						if ((int)(flags [0] & bit) == 0) {  							_protection.PasswordKey [i] = 0;  						}  						else {  							_protection.PasswordKey [i] = keyNoNulls [i];  						}  					}  					else {  						int flagIndex = (i - i % 8) / 8;  						if ((int)(flags [flagIndex] & bit) == 0) {  							_protection.PasswordHash [i - 4] = 0;  						}  						else {  							_protection.PasswordHash [i - 4] = hashNoNulls [i - 4];  						}  					}  				}  			}  			break;  		case "GC":  			_protection.VisibilityState = Decrypt (split [1]) [0] == 0xFF;  			break;  		}  	}  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadProjectProperties,The following statement contains a magic number: foreach (string line in lines) {  	if (line.StartsWith ("[")) {  	}  	else {  		var split = line.Split ('=');  		if (split.Length > 1 && split [1].Length > 1 && split [1].StartsWith ("\""))//Remove any double qouates  		 {  			split [1] = split [1].Substring (1' split [1].Length - 2);  		}  		switch (split [0]) {  		case "ID":  			ProjectID = split [1];  			break;  		case "Document":  			string mn = split [1].Substring (0' split [1].IndexOf ("/&H"));  			Modules [mn].Type = eModuleType.Document;  			break;  		case "Package":  			prevPackage = split [1];  			break;  		case "BaseClass":  			Modules [split [1]].Type = eModuleType.Designer;  			Modules [split [1]].ClassID = prevPackage;  			break;  		case "Module":  			Modules [split [1]].Type = eModuleType.Module;  			break;  		case "Class":  			Modules [split [1]].Type = eModuleType.Class;  			break;  		case "HelpFile":  		case "Name":  		case "HelpContextID":  		case "Description":  		case "VersionCompatible32":  			break;  		//393222000"  		case "CMG":  			byte[] cmg = Decrypt (split [1]);  			_protection.UserProtected = (cmg [0] & 1) != 0;  			_protection.HostProtected = (cmg [0] & 2) != 0;  			_protection.VbeProtected = (cmg [0] & 4) != 0;  			break;  		case "DPB":  			byte[] dpb = Decrypt (split [1]);  			if (dpb.Length >= 28) {  				byte reserved = dpb [0];  				var flags = new byte[3];  				Array.Copy (dpb' 1' flags' 0' 3);  				var keyNoNulls = new byte[4];  				_protection.PasswordKey = new byte[4];  				Array.Copy (dpb' 4' keyNoNulls' 0' 4);  				var hashNoNulls = new byte[20];  				_protection.PasswordHash = new byte[20];  				Array.Copy (dpb' 8' hashNoNulls' 0' 20);  				//Handle 0x00 bitwise 2.4.4.3   				for (int i = 0; i < 24; i++) {  					int bit = 128 >> (int)((i % 8));  					if (i < 4) {  						if ((int)(flags [0] & bit) == 0) {  							_protection.PasswordKey [i] = 0;  						}  						else {  							_protection.PasswordKey [i] = keyNoNulls [i];  						}  					}  					else {  						int flagIndex = (i - i % 8) / 8;  						if ((int)(flags [flagIndex] & bit) == 0) {  							_protection.PasswordHash [i - 4] = 0;  						}  						else {  							_protection.PasswordHash [i - 4] = hashNoNulls [i - 4];  						}  					}  				}  			}  			break;  		case "GC":  			_protection.VisibilityState = Decrypt (split [1]) [0] == 0xFF;  			break;  		}  	}  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadProjectProperties,The following statement contains a magic number: foreach (string line in lines) {  	if (line.StartsWith ("[")) {  	}  	else {  		var split = line.Split ('=');  		if (split.Length > 1 && split [1].Length > 1 && split [1].StartsWith ("\""))//Remove any double qouates  		 {  			split [1] = split [1].Substring (1' split [1].Length - 2);  		}  		switch (split [0]) {  		case "ID":  			ProjectID = split [1];  			break;  		case "Document":  			string mn = split [1].Substring (0' split [1].IndexOf ("/&H"));  			Modules [mn].Type = eModuleType.Document;  			break;  		case "Package":  			prevPackage = split [1];  			break;  		case "BaseClass":  			Modules [split [1]].Type = eModuleType.Designer;  			Modules [split [1]].ClassID = prevPackage;  			break;  		case "Module":  			Modules [split [1]].Type = eModuleType.Module;  			break;  		case "Class":  			Modules [split [1]].Type = eModuleType.Class;  			break;  		case "HelpFile":  		case "Name":  		case "HelpContextID":  		case "Description":  		case "VersionCompatible32":  			break;  		//393222000"  		case "CMG":  			byte[] cmg = Decrypt (split [1]);  			_protection.UserProtected = (cmg [0] & 1) != 0;  			_protection.HostProtected = (cmg [0] & 2) != 0;  			_protection.VbeProtected = (cmg [0] & 4) != 0;  			break;  		case "DPB":  			byte[] dpb = Decrypt (split [1]);  			if (dpb.Length >= 28) {  				byte reserved = dpb [0];  				var flags = new byte[3];  				Array.Copy (dpb' 1' flags' 0' 3);  				var keyNoNulls = new byte[4];  				_protection.PasswordKey = new byte[4];  				Array.Copy (dpb' 4' keyNoNulls' 0' 4);  				var hashNoNulls = new byte[20];  				_protection.PasswordHash = new byte[20];  				Array.Copy (dpb' 8' hashNoNulls' 0' 20);  				//Handle 0x00 bitwise 2.4.4.3   				for (int i = 0; i < 24; i++) {  					int bit = 128 >> (int)((i % 8));  					if (i < 4) {  						if ((int)(flags [0] & bit) == 0) {  							_protection.PasswordKey [i] = 0;  						}  						else {  							_protection.PasswordKey [i] = keyNoNulls [i];  						}  					}  					else {  						int flagIndex = (i - i % 8) / 8;  						if ((int)(flags [flagIndex] & bit) == 0) {  							_protection.PasswordHash [i - 4] = 0;  						}  						else {  							_protection.PasswordHash [i - 4] = hashNoNulls [i - 4];  						}  					}  				}  			}  			break;  		case "GC":  			_protection.VisibilityState = Decrypt (split [1]) [0] == 0xFF;  			break;  		}  	}  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadProjectProperties,The following statement contains a magic number: foreach (string line in lines) {  	if (line.StartsWith ("[")) {  	}  	else {  		var split = line.Split ('=');  		if (split.Length > 1 && split [1].Length > 1 && split [1].StartsWith ("\""))//Remove any double qouates  		 {  			split [1] = split [1].Substring (1' split [1].Length - 2);  		}  		switch (split [0]) {  		case "ID":  			ProjectID = split [1];  			break;  		case "Document":  			string mn = split [1].Substring (0' split [1].IndexOf ("/&H"));  			Modules [mn].Type = eModuleType.Document;  			break;  		case "Package":  			prevPackage = split [1];  			break;  		case "BaseClass":  			Modules [split [1]].Type = eModuleType.Designer;  			Modules [split [1]].ClassID = prevPackage;  			break;  		case "Module":  			Modules [split [1]].Type = eModuleType.Module;  			break;  		case "Class":  			Modules [split [1]].Type = eModuleType.Class;  			break;  		case "HelpFile":  		case "Name":  		case "HelpContextID":  		case "Description":  		case "VersionCompatible32":  			break;  		//393222000"  		case "CMG":  			byte[] cmg = Decrypt (split [1]);  			_protection.UserProtected = (cmg [0] & 1) != 0;  			_protection.HostProtected = (cmg [0] & 2) != 0;  			_protection.VbeProtected = (cmg [0] & 4) != 0;  			break;  		case "DPB":  			byte[] dpb = Decrypt (split [1]);  			if (dpb.Length >= 28) {  				byte reserved = dpb [0];  				var flags = new byte[3];  				Array.Copy (dpb' 1' flags' 0' 3);  				var keyNoNulls = new byte[4];  				_protection.PasswordKey = new byte[4];  				Array.Copy (dpb' 4' keyNoNulls' 0' 4);  				var hashNoNulls = new byte[20];  				_protection.PasswordHash = new byte[20];  				Array.Copy (dpb' 8' hashNoNulls' 0' 20);  				//Handle 0x00 bitwise 2.4.4.3   				for (int i = 0; i < 24; i++) {  					int bit = 128 >> (int)((i % 8));  					if (i < 4) {  						if ((int)(flags [0] & bit) == 0) {  							_protection.PasswordKey [i] = 0;  						}  						else {  							_protection.PasswordKey [i] = keyNoNulls [i];  						}  					}  					else {  						int flagIndex = (i - i % 8) / 8;  						if ((int)(flags [flagIndex] & bit) == 0) {  							_protection.PasswordHash [i - 4] = 0;  						}  						else {  							_protection.PasswordHash [i - 4] = hashNoNulls [i - 4];  						}  					}  				}  			}  			break;  		case "GC":  			_protection.VisibilityState = Decrypt (split [1]) [0] == 0xFF;  			break;  		}  	}  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadProjectProperties,The following statement contains a magic number: foreach (string line in lines) {  	if (line.StartsWith ("[")) {  	}  	else {  		var split = line.Split ('=');  		if (split.Length > 1 && split [1].Length > 1 && split [1].StartsWith ("\""))//Remove any double qouates  		 {  			split [1] = split [1].Substring (1' split [1].Length - 2);  		}  		switch (split [0]) {  		case "ID":  			ProjectID = split [1];  			break;  		case "Document":  			string mn = split [1].Substring (0' split [1].IndexOf ("/&H"));  			Modules [mn].Type = eModuleType.Document;  			break;  		case "Package":  			prevPackage = split [1];  			break;  		case "BaseClass":  			Modules [split [1]].Type = eModuleType.Designer;  			Modules [split [1]].ClassID = prevPackage;  			break;  		case "Module":  			Modules [split [1]].Type = eModuleType.Module;  			break;  		case "Class":  			Modules [split [1]].Type = eModuleType.Class;  			break;  		case "HelpFile":  		case "Name":  		case "HelpContextID":  		case "Description":  		case "VersionCompatible32":  			break;  		//393222000"  		case "CMG":  			byte[] cmg = Decrypt (split [1]);  			_protection.UserProtected = (cmg [0] & 1) != 0;  			_protection.HostProtected = (cmg [0] & 2) != 0;  			_protection.VbeProtected = (cmg [0] & 4) != 0;  			break;  		case "DPB":  			byte[] dpb = Decrypt (split [1]);  			if (dpb.Length >= 28) {  				byte reserved = dpb [0];  				var flags = new byte[3];  				Array.Copy (dpb' 1' flags' 0' 3);  				var keyNoNulls = new byte[4];  				_protection.PasswordKey = new byte[4];  				Array.Copy (dpb' 4' keyNoNulls' 0' 4);  				var hashNoNulls = new byte[20];  				_protection.PasswordHash = new byte[20];  				Array.Copy (dpb' 8' hashNoNulls' 0' 20);  				//Handle 0x00 bitwise 2.4.4.3   				for (int i = 0; i < 24; i++) {  					int bit = 128 >> (int)((i % 8));  					if (i < 4) {  						if ((int)(flags [0] & bit) == 0) {  							_protection.PasswordKey [i] = 0;  						}  						else {  							_protection.PasswordKey [i] = keyNoNulls [i];  						}  					}  					else {  						int flagIndex = (i - i % 8) / 8;  						if ((int)(flags [flagIndex] & bit) == 0) {  							_protection.PasswordHash [i - 4] = 0;  						}  						else {  							_protection.PasswordHash [i - 4] = hashNoNulls [i - 4];  						}  					}  				}  			}  			break;  		case "GC":  			_protection.VisibilityState = Decrypt (split [1]) [0] == 0xFF;  			break;  		}  	}  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadProjectProperties,The following statement contains a magic number: foreach (string line in lines) {  	if (line.StartsWith ("[")) {  	}  	else {  		var split = line.Split ('=');  		if (split.Length > 1 && split [1].Length > 1 && split [1].StartsWith ("\""))//Remove any double qouates  		 {  			split [1] = split [1].Substring (1' split [1].Length - 2);  		}  		switch (split [0]) {  		case "ID":  			ProjectID = split [1];  			break;  		case "Document":  			string mn = split [1].Substring (0' split [1].IndexOf ("/&H"));  			Modules [mn].Type = eModuleType.Document;  			break;  		case "Package":  			prevPackage = split [1];  			break;  		case "BaseClass":  			Modules [split [1]].Type = eModuleType.Designer;  			Modules [split [1]].ClassID = prevPackage;  			break;  		case "Module":  			Modules [split [1]].Type = eModuleType.Module;  			break;  		case "Class":  			Modules [split [1]].Type = eModuleType.Class;  			break;  		case "HelpFile":  		case "Name":  		case "HelpContextID":  		case "Description":  		case "VersionCompatible32":  			break;  		//393222000"  		case "CMG":  			byte[] cmg = Decrypt (split [1]);  			_protection.UserProtected = (cmg [0] & 1) != 0;  			_protection.HostProtected = (cmg [0] & 2) != 0;  			_protection.VbeProtected = (cmg [0] & 4) != 0;  			break;  		case "DPB":  			byte[] dpb = Decrypt (split [1]);  			if (dpb.Length >= 28) {  				byte reserved = dpb [0];  				var flags = new byte[3];  				Array.Copy (dpb' 1' flags' 0' 3);  				var keyNoNulls = new byte[4];  				_protection.PasswordKey = new byte[4];  				Array.Copy (dpb' 4' keyNoNulls' 0' 4);  				var hashNoNulls = new byte[20];  				_protection.PasswordHash = new byte[20];  				Array.Copy (dpb' 8' hashNoNulls' 0' 20);  				//Handle 0x00 bitwise 2.4.4.3   				for (int i = 0; i < 24; i++) {  					int bit = 128 >> (int)((i % 8));  					if (i < 4) {  						if ((int)(flags [0] & bit) == 0) {  							_protection.PasswordKey [i] = 0;  						}  						else {  							_protection.PasswordKey [i] = keyNoNulls [i];  						}  					}  					else {  						int flagIndex = (i - i % 8) / 8;  						if ((int)(flags [flagIndex] & bit) == 0) {  							_protection.PasswordHash [i - 4] = 0;  						}  						else {  							_protection.PasswordHash [i - 4] = hashNoNulls [i - 4];  						}  					}  				}  			}  			break;  		case "GC":  			_protection.VisibilityState = Decrypt (split [1]) [0] == 0xFF;  			break;  		}  	}  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadProjectProperties,The following statement contains a magic number: foreach (string line in lines) {  	if (line.StartsWith ("[")) {  	}  	else {  		var split = line.Split ('=');  		if (split.Length > 1 && split [1].Length > 1 && split [1].StartsWith ("\""))//Remove any double qouates  		 {  			split [1] = split [1].Substring (1' split [1].Length - 2);  		}  		switch (split [0]) {  		case "ID":  			ProjectID = split [1];  			break;  		case "Document":  			string mn = split [1].Substring (0' split [1].IndexOf ("/&H"));  			Modules [mn].Type = eModuleType.Document;  			break;  		case "Package":  			prevPackage = split [1];  			break;  		case "BaseClass":  			Modules [split [1]].Type = eModuleType.Designer;  			Modules [split [1]].ClassID = prevPackage;  			break;  		case "Module":  			Modules [split [1]].Type = eModuleType.Module;  			break;  		case "Class":  			Modules [split [1]].Type = eModuleType.Class;  			break;  		case "HelpFile":  		case "Name":  		case "HelpContextID":  		case "Description":  		case "VersionCompatible32":  			break;  		//393222000"  		case "CMG":  			byte[] cmg = Decrypt (split [1]);  			_protection.UserProtected = (cmg [0] & 1) != 0;  			_protection.HostProtected = (cmg [0] & 2) != 0;  			_protection.VbeProtected = (cmg [0] & 4) != 0;  			break;  		case "DPB":  			byte[] dpb = Decrypt (split [1]);  			if (dpb.Length >= 28) {  				byte reserved = dpb [0];  				var flags = new byte[3];  				Array.Copy (dpb' 1' flags' 0' 3);  				var keyNoNulls = new byte[4];  				_protection.PasswordKey = new byte[4];  				Array.Copy (dpb' 4' keyNoNulls' 0' 4);  				var hashNoNulls = new byte[20];  				_protection.PasswordHash = new byte[20];  				Array.Copy (dpb' 8' hashNoNulls' 0' 20);  				//Handle 0x00 bitwise 2.4.4.3   				for (int i = 0; i < 24; i++) {  					int bit = 128 >> (int)((i % 8));  					if (i < 4) {  						if ((int)(flags [0] & bit) == 0) {  							_protection.PasswordKey [i] = 0;  						}  						else {  							_protection.PasswordKey [i] = keyNoNulls [i];  						}  					}  					else {  						int flagIndex = (i - i % 8) / 8;  						if ((int)(flags [flagIndex] & bit) == 0) {  							_protection.PasswordHash [i - 4] = 0;  						}  						else {  							_protection.PasswordHash [i - 4] = hashNoNulls [i - 4];  						}  					}  				}  			}  			break;  		case "GC":  			_protection.VisibilityState = Decrypt (split [1]) [0] == 0xFF;  			break;  		}  	}  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadProjectProperties,The following statement contains a magic number: foreach (string line in lines) {  	if (line.StartsWith ("[")) {  	}  	else {  		var split = line.Split ('=');  		if (split.Length > 1 && split [1].Length > 1 && split [1].StartsWith ("\""))//Remove any double qouates  		 {  			split [1] = split [1].Substring (1' split [1].Length - 2);  		}  		switch (split [0]) {  		case "ID":  			ProjectID = split [1];  			break;  		case "Document":  			string mn = split [1].Substring (0' split [1].IndexOf ("/&H"));  			Modules [mn].Type = eModuleType.Document;  			break;  		case "Package":  			prevPackage = split [1];  			break;  		case "BaseClass":  			Modules [split [1]].Type = eModuleType.Designer;  			Modules [split [1]].ClassID = prevPackage;  			break;  		case "Module":  			Modules [split [1]].Type = eModuleType.Module;  			break;  		case "Class":  			Modules [split [1]].Type = eModuleType.Class;  			break;  		case "HelpFile":  		case "Name":  		case "HelpContextID":  		case "Description":  		case "VersionCompatible32":  			break;  		//393222000"  		case "CMG":  			byte[] cmg = Decrypt (split [1]);  			_protection.UserProtected = (cmg [0] & 1) != 0;  			_protection.HostProtected = (cmg [0] & 2) != 0;  			_protection.VbeProtected = (cmg [0] & 4) != 0;  			break;  		case "DPB":  			byte[] dpb = Decrypt (split [1]);  			if (dpb.Length >= 28) {  				byte reserved = dpb [0];  				var flags = new byte[3];  				Array.Copy (dpb' 1' flags' 0' 3);  				var keyNoNulls = new byte[4];  				_protection.PasswordKey = new byte[4];  				Array.Copy (dpb' 4' keyNoNulls' 0' 4);  				var hashNoNulls = new byte[20];  				_protection.PasswordHash = new byte[20];  				Array.Copy (dpb' 8' hashNoNulls' 0' 20);  				//Handle 0x00 bitwise 2.4.4.3   				for (int i = 0; i < 24; i++) {  					int bit = 128 >> (int)((i % 8));  					if (i < 4) {  						if ((int)(flags [0] & bit) == 0) {  							_protection.PasswordKey [i] = 0;  						}  						else {  							_protection.PasswordKey [i] = keyNoNulls [i];  						}  					}  					else {  						int flagIndex = (i - i % 8) / 8;  						if ((int)(flags [flagIndex] & bit) == 0) {  							_protection.PasswordHash [i - 4] = 0;  						}  						else {  							_protection.PasswordHash [i - 4] = hashNoNulls [i - 4];  						}  					}  				}  			}  			break;  		case "GC":  			_protection.VisibilityState = Decrypt (split [1]) [0] == 0xFF;  			break;  		}  	}  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadProjectProperties,The following statement contains a magic number: foreach (string line in lines) {  	if (line.StartsWith ("[")) {  	}  	else {  		var split = line.Split ('=');  		if (split.Length > 1 && split [1].Length > 1 && split [1].StartsWith ("\""))//Remove any double qouates  		 {  			split [1] = split [1].Substring (1' split [1].Length - 2);  		}  		switch (split [0]) {  		case "ID":  			ProjectID = split [1];  			break;  		case "Document":  			string mn = split [1].Substring (0' split [1].IndexOf ("/&H"));  			Modules [mn].Type = eModuleType.Document;  			break;  		case "Package":  			prevPackage = split [1];  			break;  		case "BaseClass":  			Modules [split [1]].Type = eModuleType.Designer;  			Modules [split [1]].ClassID = prevPackage;  			break;  		case "Module":  			Modules [split [1]].Type = eModuleType.Module;  			break;  		case "Class":  			Modules [split [1]].Type = eModuleType.Class;  			break;  		case "HelpFile":  		case "Name":  		case "HelpContextID":  		case "Description":  		case "VersionCompatible32":  			break;  		//393222000"  		case "CMG":  			byte[] cmg = Decrypt (split [1]);  			_protection.UserProtected = (cmg [0] & 1) != 0;  			_protection.HostProtected = (cmg [0] & 2) != 0;  			_protection.VbeProtected = (cmg [0] & 4) != 0;  			break;  		case "DPB":  			byte[] dpb = Decrypt (split [1]);  			if (dpb.Length >= 28) {  				byte reserved = dpb [0];  				var flags = new byte[3];  				Array.Copy (dpb' 1' flags' 0' 3);  				var keyNoNulls = new byte[4];  				_protection.PasswordKey = new byte[4];  				Array.Copy (dpb' 4' keyNoNulls' 0' 4);  				var hashNoNulls = new byte[20];  				_protection.PasswordHash = new byte[20];  				Array.Copy (dpb' 8' hashNoNulls' 0' 20);  				//Handle 0x00 bitwise 2.4.4.3   				for (int i = 0; i < 24; i++) {  					int bit = 128 >> (int)((i % 8));  					if (i < 4) {  						if ((int)(flags [0] & bit) == 0) {  							_protection.PasswordKey [i] = 0;  						}  						else {  							_protection.PasswordKey [i] = keyNoNulls [i];  						}  					}  					else {  						int flagIndex = (i - i % 8) / 8;  						if ((int)(flags [flagIndex] & bit) == 0) {  							_protection.PasswordHash [i - 4] = 0;  						}  						else {  							_protection.PasswordHash [i - 4] = hashNoNulls [i - 4];  						}  					}  				}  			}  			break;  		case "GC":  			_protection.VisibilityState = Decrypt (split [1]) [0] == 0xFF;  			break;  		}  	}  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadProjectProperties,The following statement contains a magic number: foreach (string line in lines) {  	if (line.StartsWith ("[")) {  	}  	else {  		var split = line.Split ('=');  		if (split.Length > 1 && split [1].Length > 1 && split [1].StartsWith ("\""))//Remove any double qouates  		 {  			split [1] = split [1].Substring (1' split [1].Length - 2);  		}  		switch (split [0]) {  		case "ID":  			ProjectID = split [1];  			break;  		case "Document":  			string mn = split [1].Substring (0' split [1].IndexOf ("/&H"));  			Modules [mn].Type = eModuleType.Document;  			break;  		case "Package":  			prevPackage = split [1];  			break;  		case "BaseClass":  			Modules [split [1]].Type = eModuleType.Designer;  			Modules [split [1]].ClassID = prevPackage;  			break;  		case "Module":  			Modules [split [1]].Type = eModuleType.Module;  			break;  		case "Class":  			Modules [split [1]].Type = eModuleType.Class;  			break;  		case "HelpFile":  		case "Name":  		case "HelpContextID":  		case "Description":  		case "VersionCompatible32":  			break;  		//393222000"  		case "CMG":  			byte[] cmg = Decrypt (split [1]);  			_protection.UserProtected = (cmg [0] & 1) != 0;  			_protection.HostProtected = (cmg [0] & 2) != 0;  			_protection.VbeProtected = (cmg [0] & 4) != 0;  			break;  		case "DPB":  			byte[] dpb = Decrypt (split [1]);  			if (dpb.Length >= 28) {  				byte reserved = dpb [0];  				var flags = new byte[3];  				Array.Copy (dpb' 1' flags' 0' 3);  				var keyNoNulls = new byte[4];  				_protection.PasswordKey = new byte[4];  				Array.Copy (dpb' 4' keyNoNulls' 0' 4);  				var hashNoNulls = new byte[20];  				_protection.PasswordHash = new byte[20];  				Array.Copy (dpb' 8' hashNoNulls' 0' 20);  				//Handle 0x00 bitwise 2.4.4.3   				for (int i = 0; i < 24; i++) {  					int bit = 128 >> (int)((i % 8));  					if (i < 4) {  						if ((int)(flags [0] & bit) == 0) {  							_protection.PasswordKey [i] = 0;  						}  						else {  							_protection.PasswordKey [i] = keyNoNulls [i];  						}  					}  					else {  						int flagIndex = (i - i % 8) / 8;  						if ((int)(flags [flagIndex] & bit) == 0) {  							_protection.PasswordHash [i - 4] = 0;  						}  						else {  							_protection.PasswordHash [i - 4] = hashNoNulls [i - 4];  						}  					}  				}  			}  			break;  		case "GC":  			_protection.VisibilityState = Decrypt (split [1]) [0] == 0xFF;  			break;  		}  	}  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadProjectProperties,The following statement contains a magic number: foreach (string line in lines) {  	if (line.StartsWith ("[")) {  	}  	else {  		var split = line.Split ('=');  		if (split.Length > 1 && split [1].Length > 1 && split [1].StartsWith ("\""))//Remove any double qouates  		 {  			split [1] = split [1].Substring (1' split [1].Length - 2);  		}  		switch (split [0]) {  		case "ID":  			ProjectID = split [1];  			break;  		case "Document":  			string mn = split [1].Substring (0' split [1].IndexOf ("/&H"));  			Modules [mn].Type = eModuleType.Document;  			break;  		case "Package":  			prevPackage = split [1];  			break;  		case "BaseClass":  			Modules [split [1]].Type = eModuleType.Designer;  			Modules [split [1]].ClassID = prevPackage;  			break;  		case "Module":  			Modules [split [1]].Type = eModuleType.Module;  			break;  		case "Class":  			Modules [split [1]].Type = eModuleType.Class;  			break;  		case "HelpFile":  		case "Name":  		case "HelpContextID":  		case "Description":  		case "VersionCompatible32":  			break;  		//393222000"  		case "CMG":  			byte[] cmg = Decrypt (split [1]);  			_protection.UserProtected = (cmg [0] & 1) != 0;  			_protection.HostProtected = (cmg [0] & 2) != 0;  			_protection.VbeProtected = (cmg [0] & 4) != 0;  			break;  		case "DPB":  			byte[] dpb = Decrypt (split [1]);  			if (dpb.Length >= 28) {  				byte reserved = dpb [0];  				var flags = new byte[3];  				Array.Copy (dpb' 1' flags' 0' 3);  				var keyNoNulls = new byte[4];  				_protection.PasswordKey = new byte[4];  				Array.Copy (dpb' 4' keyNoNulls' 0' 4);  				var hashNoNulls = new byte[20];  				_protection.PasswordHash = new byte[20];  				Array.Copy (dpb' 8' hashNoNulls' 0' 20);  				//Handle 0x00 bitwise 2.4.4.3   				for (int i = 0; i < 24; i++) {  					int bit = 128 >> (int)((i % 8));  					if (i < 4) {  						if ((int)(flags [0] & bit) == 0) {  							_protection.PasswordKey [i] = 0;  						}  						else {  							_protection.PasswordKey [i] = keyNoNulls [i];  						}  					}  					else {  						int flagIndex = (i - i % 8) / 8;  						if ((int)(flags [flagIndex] & bit) == 0) {  							_protection.PasswordHash [i - 4] = 0;  						}  						else {  							_protection.PasswordHash [i - 4] = hashNoNulls [i - 4];  						}  					}  				}  			}  			break;  		case "GC":  			_protection.VisibilityState = Decrypt (split [1]) [0] == 0xFF;  			break;  		}  	}  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadProjectProperties,The following statement contains a magic number: foreach (string line in lines) {  	if (line.StartsWith ("[")) {  	}  	else {  		var split = line.Split ('=');  		if (split.Length > 1 && split [1].Length > 1 && split [1].StartsWith ("\""))//Remove any double qouates  		 {  			split [1] = split [1].Substring (1' split [1].Length - 2);  		}  		switch (split [0]) {  		case "ID":  			ProjectID = split [1];  			break;  		case "Document":  			string mn = split [1].Substring (0' split [1].IndexOf ("/&H"));  			Modules [mn].Type = eModuleType.Document;  			break;  		case "Package":  			prevPackage = split [1];  			break;  		case "BaseClass":  			Modules [split [1]].Type = eModuleType.Designer;  			Modules [split [1]].ClassID = prevPackage;  			break;  		case "Module":  			Modules [split [1]].Type = eModuleType.Module;  			break;  		case "Class":  			Modules [split [1]].Type = eModuleType.Class;  			break;  		case "HelpFile":  		case "Name":  		case "HelpContextID":  		case "Description":  		case "VersionCompatible32":  			break;  		//393222000"  		case "CMG":  			byte[] cmg = Decrypt (split [1]);  			_protection.UserProtected = (cmg [0] & 1) != 0;  			_protection.HostProtected = (cmg [0] & 2) != 0;  			_protection.VbeProtected = (cmg [0] & 4) != 0;  			break;  		case "DPB":  			byte[] dpb = Decrypt (split [1]);  			if (dpb.Length >= 28) {  				byte reserved = dpb [0];  				var flags = new byte[3];  				Array.Copy (dpb' 1' flags' 0' 3);  				var keyNoNulls = new byte[4];  				_protection.PasswordKey = new byte[4];  				Array.Copy (dpb' 4' keyNoNulls' 0' 4);  				var hashNoNulls = new byte[20];  				_protection.PasswordHash = new byte[20];  				Array.Copy (dpb' 8' hashNoNulls' 0' 20);  				//Handle 0x00 bitwise 2.4.4.3   				for (int i = 0; i < 24; i++) {  					int bit = 128 >> (int)((i % 8));  					if (i < 4) {  						if ((int)(flags [0] & bit) == 0) {  							_protection.PasswordKey [i] = 0;  						}  						else {  							_protection.PasswordKey [i] = keyNoNulls [i];  						}  					}  					else {  						int flagIndex = (i - i % 8) / 8;  						if ((int)(flags [flagIndex] & bit) == 0) {  							_protection.PasswordHash [i - 4] = 0;  						}  						else {  							_protection.PasswordHash [i - 4] = hashNoNulls [i - 4];  						}  					}  				}  			}  			break;  		case "GC":  			_protection.VisibilityState = Decrypt (split [1]) [0] == 0xFF;  			break;  		}  	}  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadProjectProperties,The following statement contains a magic number: foreach (string line in lines) {  	if (line.StartsWith ("[")) {  	}  	else {  		var split = line.Split ('=');  		if (split.Length > 1 && split [1].Length > 1 && split [1].StartsWith ("\""))//Remove any double qouates  		 {  			split [1] = split [1].Substring (1' split [1].Length - 2);  		}  		switch (split [0]) {  		case "ID":  			ProjectID = split [1];  			break;  		case "Document":  			string mn = split [1].Substring (0' split [1].IndexOf ("/&H"));  			Modules [mn].Type = eModuleType.Document;  			break;  		case "Package":  			prevPackage = split [1];  			break;  		case "BaseClass":  			Modules [split [1]].Type = eModuleType.Designer;  			Modules [split [1]].ClassID = prevPackage;  			break;  		case "Module":  			Modules [split [1]].Type = eModuleType.Module;  			break;  		case "Class":  			Modules [split [1]].Type = eModuleType.Class;  			break;  		case "HelpFile":  		case "Name":  		case "HelpContextID":  		case "Description":  		case "VersionCompatible32":  			break;  		//393222000"  		case "CMG":  			byte[] cmg = Decrypt (split [1]);  			_protection.UserProtected = (cmg [0] & 1) != 0;  			_protection.HostProtected = (cmg [0] & 2) != 0;  			_protection.VbeProtected = (cmg [0] & 4) != 0;  			break;  		case "DPB":  			byte[] dpb = Decrypt (split [1]);  			if (dpb.Length >= 28) {  				byte reserved = dpb [0];  				var flags = new byte[3];  				Array.Copy (dpb' 1' flags' 0' 3);  				var keyNoNulls = new byte[4];  				_protection.PasswordKey = new byte[4];  				Array.Copy (dpb' 4' keyNoNulls' 0' 4);  				var hashNoNulls = new byte[20];  				_protection.PasswordHash = new byte[20];  				Array.Copy (dpb' 8' hashNoNulls' 0' 20);  				//Handle 0x00 bitwise 2.4.4.3   				for (int i = 0; i < 24; i++) {  					int bit = 128 >> (int)((i % 8));  					if (i < 4) {  						if ((int)(flags [0] & bit) == 0) {  							_protection.PasswordKey [i] = 0;  						}  						else {  							_protection.PasswordKey [i] = keyNoNulls [i];  						}  					}  					else {  						int flagIndex = (i - i % 8) / 8;  						if ((int)(flags [flagIndex] & bit) == 0) {  							_protection.PasswordHash [i - 4] = 0;  						}  						else {  							_protection.PasswordHash [i - 4] = hashNoNulls [i - 4];  						}  					}  				}  			}  			break;  		case "GC":  			_protection.VisibilityState = Decrypt (split [1]) [0] == 0xFF;  			break;  		}  	}  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadProjectProperties,The following statement contains a magic number: foreach (string line in lines) {  	if (line.StartsWith ("[")) {  	}  	else {  		var split = line.Split ('=');  		if (split.Length > 1 && split [1].Length > 1 && split [1].StartsWith ("\""))//Remove any double qouates  		 {  			split [1] = split [1].Substring (1' split [1].Length - 2);  		}  		switch (split [0]) {  		case "ID":  			ProjectID = split [1];  			break;  		case "Document":  			string mn = split [1].Substring (0' split [1].IndexOf ("/&H"));  			Modules [mn].Type = eModuleType.Document;  			break;  		case "Package":  			prevPackage = split [1];  			break;  		case "BaseClass":  			Modules [split [1]].Type = eModuleType.Designer;  			Modules [split [1]].ClassID = prevPackage;  			break;  		case "Module":  			Modules [split [1]].Type = eModuleType.Module;  			break;  		case "Class":  			Modules [split [1]].Type = eModuleType.Class;  			break;  		case "HelpFile":  		case "Name":  		case "HelpContextID":  		case "Description":  		case "VersionCompatible32":  			break;  		//393222000"  		case "CMG":  			byte[] cmg = Decrypt (split [1]);  			_protection.UserProtected = (cmg [0] & 1) != 0;  			_protection.HostProtected = (cmg [0] & 2) != 0;  			_protection.VbeProtected = (cmg [0] & 4) != 0;  			break;  		case "DPB":  			byte[] dpb = Decrypt (split [1]);  			if (dpb.Length >= 28) {  				byte reserved = dpb [0];  				var flags = new byte[3];  				Array.Copy (dpb' 1' flags' 0' 3);  				var keyNoNulls = new byte[4];  				_protection.PasswordKey = new byte[4];  				Array.Copy (dpb' 4' keyNoNulls' 0' 4);  				var hashNoNulls = new byte[20];  				_protection.PasswordHash = new byte[20];  				Array.Copy (dpb' 8' hashNoNulls' 0' 20);  				//Handle 0x00 bitwise 2.4.4.3   				for (int i = 0; i < 24; i++) {  					int bit = 128 >> (int)((i % 8));  					if (i < 4) {  						if ((int)(flags [0] & bit) == 0) {  							_protection.PasswordKey [i] = 0;  						}  						else {  							_protection.PasswordKey [i] = keyNoNulls [i];  						}  					}  					else {  						int flagIndex = (i - i % 8) / 8;  						if ((int)(flags [flagIndex] & bit) == 0) {  							_protection.PasswordHash [i - 4] = 0;  						}  						else {  							_protection.PasswordHash [i - 4] = hashNoNulls [i - 4];  						}  					}  				}  			}  			break;  		case "GC":  			_protection.VisibilityState = Decrypt (split [1]) [0] == 0xFF;  			break;  		}  	}  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadProjectProperties,The following statement contains a magic number: foreach (string line in lines) {  	if (line.StartsWith ("[")) {  	}  	else {  		var split = line.Split ('=');  		if (split.Length > 1 && split [1].Length > 1 && split [1].StartsWith ("\""))//Remove any double qouates  		 {  			split [1] = split [1].Substring (1' split [1].Length - 2);  		}  		switch (split [0]) {  		case "ID":  			ProjectID = split [1];  			break;  		case "Document":  			string mn = split [1].Substring (0' split [1].IndexOf ("/&H"));  			Modules [mn].Type = eModuleType.Document;  			break;  		case "Package":  			prevPackage = split [1];  			break;  		case "BaseClass":  			Modules [split [1]].Type = eModuleType.Designer;  			Modules [split [1]].ClassID = prevPackage;  			break;  		case "Module":  			Modules [split [1]].Type = eModuleType.Module;  			break;  		case "Class":  			Modules [split [1]].Type = eModuleType.Class;  			break;  		case "HelpFile":  		case "Name":  		case "HelpContextID":  		case "Description":  		case "VersionCompatible32":  			break;  		//393222000"  		case "CMG":  			byte[] cmg = Decrypt (split [1]);  			_protection.UserProtected = (cmg [0] & 1) != 0;  			_protection.HostProtected = (cmg [0] & 2) != 0;  			_protection.VbeProtected = (cmg [0] & 4) != 0;  			break;  		case "DPB":  			byte[] dpb = Decrypt (split [1]);  			if (dpb.Length >= 28) {  				byte reserved = dpb [0];  				var flags = new byte[3];  				Array.Copy (dpb' 1' flags' 0' 3);  				var keyNoNulls = new byte[4];  				_protection.PasswordKey = new byte[4];  				Array.Copy (dpb' 4' keyNoNulls' 0' 4);  				var hashNoNulls = new byte[20];  				_protection.PasswordHash = new byte[20];  				Array.Copy (dpb' 8' hashNoNulls' 0' 20);  				//Handle 0x00 bitwise 2.4.4.3   				for (int i = 0; i < 24; i++) {  					int bit = 128 >> (int)((i % 8));  					if (i < 4) {  						if ((int)(flags [0] & bit) == 0) {  							_protection.PasswordKey [i] = 0;  						}  						else {  							_protection.PasswordKey [i] = keyNoNulls [i];  						}  					}  					else {  						int flagIndex = (i - i % 8) / 8;  						if ((int)(flags [flagIndex] & bit) == 0) {  							_protection.PasswordHash [i - 4] = 0;  						}  						else {  							_protection.PasswordHash [i - 4] = hashNoNulls [i - 4];  						}  					}  				}  			}  			break;  		case "GC":  			_protection.VisibilityState = Decrypt (split [1]) [0] == 0xFF;  			break;  		}  	}  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadProjectProperties,The following statement contains a magic number: foreach (string line in lines) {  	if (line.StartsWith ("[")) {  	}  	else {  		var split = line.Split ('=');  		if (split.Length > 1 && split [1].Length > 1 && split [1].StartsWith ("\""))//Remove any double qouates  		 {  			split [1] = split [1].Substring (1' split [1].Length - 2);  		}  		switch (split [0]) {  		case "ID":  			ProjectID = split [1];  			break;  		case "Document":  			string mn = split [1].Substring (0' split [1].IndexOf ("/&H"));  			Modules [mn].Type = eModuleType.Document;  			break;  		case "Package":  			prevPackage = split [1];  			break;  		case "BaseClass":  			Modules [split [1]].Type = eModuleType.Designer;  			Modules [split [1]].ClassID = prevPackage;  			break;  		case "Module":  			Modules [split [1]].Type = eModuleType.Module;  			break;  		case "Class":  			Modules [split [1]].Type = eModuleType.Class;  			break;  		case "HelpFile":  		case "Name":  		case "HelpContextID":  		case "Description":  		case "VersionCompatible32":  			break;  		//393222000"  		case "CMG":  			byte[] cmg = Decrypt (split [1]);  			_protection.UserProtected = (cmg [0] & 1) != 0;  			_protection.HostProtected = (cmg [0] & 2) != 0;  			_protection.VbeProtected = (cmg [0] & 4) != 0;  			break;  		case "DPB":  			byte[] dpb = Decrypt (split [1]);  			if (dpb.Length >= 28) {  				byte reserved = dpb [0];  				var flags = new byte[3];  				Array.Copy (dpb' 1' flags' 0' 3);  				var keyNoNulls = new byte[4];  				_protection.PasswordKey = new byte[4];  				Array.Copy (dpb' 4' keyNoNulls' 0' 4);  				var hashNoNulls = new byte[20];  				_protection.PasswordHash = new byte[20];  				Array.Copy (dpb' 8' hashNoNulls' 0' 20);  				//Handle 0x00 bitwise 2.4.4.3   				for (int i = 0; i < 24; i++) {  					int bit = 128 >> (int)((i % 8));  					if (i < 4) {  						if ((int)(flags [0] & bit) == 0) {  							_protection.PasswordKey [i] = 0;  						}  						else {  							_protection.PasswordKey [i] = keyNoNulls [i];  						}  					}  					else {  						int flagIndex = (i - i % 8) / 8;  						if ((int)(flags [flagIndex] & bit) == 0) {  							_protection.PasswordHash [i - 4] = 0;  						}  						else {  							_protection.PasswordHash [i - 4] = hashNoNulls [i - 4];  						}  					}  				}  			}  			break;  		case "GC":  			_protection.VisibilityState = Decrypt (split [1]) [0] == 0xFF;  			break;  		}  	}  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadProjectProperties,The following statement contains a magic number: foreach (string line in lines) {  	if (line.StartsWith ("[")) {  	}  	else {  		var split = line.Split ('=');  		if (split.Length > 1 && split [1].Length > 1 && split [1].StartsWith ("\""))//Remove any double qouates  		 {  			split [1] = split [1].Substring (1' split [1].Length - 2);  		}  		switch (split [0]) {  		case "ID":  			ProjectID = split [1];  			break;  		case "Document":  			string mn = split [1].Substring (0' split [1].IndexOf ("/&H"));  			Modules [mn].Type = eModuleType.Document;  			break;  		case "Package":  			prevPackage = split [1];  			break;  		case "BaseClass":  			Modules [split [1]].Type = eModuleType.Designer;  			Modules [split [1]].ClassID = prevPackage;  			break;  		case "Module":  			Modules [split [1]].Type = eModuleType.Module;  			break;  		case "Class":  			Modules [split [1]].Type = eModuleType.Class;  			break;  		case "HelpFile":  		case "Name":  		case "HelpContextID":  		case "Description":  		case "VersionCompatible32":  			break;  		//393222000"  		case "CMG":  			byte[] cmg = Decrypt (split [1]);  			_protection.UserProtected = (cmg [0] & 1) != 0;  			_protection.HostProtected = (cmg [0] & 2) != 0;  			_protection.VbeProtected = (cmg [0] & 4) != 0;  			break;  		case "DPB":  			byte[] dpb = Decrypt (split [1]);  			if (dpb.Length >= 28) {  				byte reserved = dpb [0];  				var flags = new byte[3];  				Array.Copy (dpb' 1' flags' 0' 3);  				var keyNoNulls = new byte[4];  				_protection.PasswordKey = new byte[4];  				Array.Copy (dpb' 4' keyNoNulls' 0' 4);  				var hashNoNulls = new byte[20];  				_protection.PasswordHash = new byte[20];  				Array.Copy (dpb' 8' hashNoNulls' 0' 20);  				//Handle 0x00 bitwise 2.4.4.3   				for (int i = 0; i < 24; i++) {  					int bit = 128 >> (int)((i % 8));  					if (i < 4) {  						if ((int)(flags [0] & bit) == 0) {  							_protection.PasswordKey [i] = 0;  						}  						else {  							_protection.PasswordKey [i] = keyNoNulls [i];  						}  					}  					else {  						int flagIndex = (i - i % 8) / 8;  						if ((int)(flags [flagIndex] & bit) == 0) {  							_protection.PasswordHash [i - 4] = 0;  						}  						else {  							_protection.PasswordHash [i - 4] = hashNoNulls [i - 4];  						}  					}  				}  			}  			break;  		case "GC":  			_protection.VisibilityState = Decrypt (split [1]) [0] == 0xFF;  			break;  		}  	}  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadProjectProperties,The following statement contains a magic number: foreach (string line in lines) {  	if (line.StartsWith ("[")) {  	}  	else {  		var split = line.Split ('=');  		if (split.Length > 1 && split [1].Length > 1 && split [1].StartsWith ("\""))//Remove any double qouates  		 {  			split [1] = split [1].Substring (1' split [1].Length - 2);  		}  		switch (split [0]) {  		case "ID":  			ProjectID = split [1];  			break;  		case "Document":  			string mn = split [1].Substring (0' split [1].IndexOf ("/&H"));  			Modules [mn].Type = eModuleType.Document;  			break;  		case "Package":  			prevPackage = split [1];  			break;  		case "BaseClass":  			Modules [split [1]].Type = eModuleType.Designer;  			Modules [split [1]].ClassID = prevPackage;  			break;  		case "Module":  			Modules [split [1]].Type = eModuleType.Module;  			break;  		case "Class":  			Modules [split [1]].Type = eModuleType.Class;  			break;  		case "HelpFile":  		case "Name":  		case "HelpContextID":  		case "Description":  		case "VersionCompatible32":  			break;  		//393222000"  		case "CMG":  			byte[] cmg = Decrypt (split [1]);  			_protection.UserProtected = (cmg [0] & 1) != 0;  			_protection.HostProtected = (cmg [0] & 2) != 0;  			_protection.VbeProtected = (cmg [0] & 4) != 0;  			break;  		case "DPB":  			byte[] dpb = Decrypt (split [1]);  			if (dpb.Length >= 28) {  				byte reserved = dpb [0];  				var flags = new byte[3];  				Array.Copy (dpb' 1' flags' 0' 3);  				var keyNoNulls = new byte[4];  				_protection.PasswordKey = new byte[4];  				Array.Copy (dpb' 4' keyNoNulls' 0' 4);  				var hashNoNulls = new byte[20];  				_protection.PasswordHash = new byte[20];  				Array.Copy (dpb' 8' hashNoNulls' 0' 20);  				//Handle 0x00 bitwise 2.4.4.3   				for (int i = 0; i < 24; i++) {  					int bit = 128 >> (int)((i % 8));  					if (i < 4) {  						if ((int)(flags [0] & bit) == 0) {  							_protection.PasswordKey [i] = 0;  						}  						else {  							_protection.PasswordKey [i] = keyNoNulls [i];  						}  					}  					else {  						int flagIndex = (i - i % 8) / 8;  						if ((int)(flags [flagIndex] & bit) == 0) {  							_protection.PasswordHash [i - 4] = 0;  						}  						else {  							_protection.PasswordHash [i - 4] = hashNoNulls [i - 4];  						}  					}  				}  			}  			break;  		case "GC":  			_protection.VisibilityState = Decrypt (split [1]) [0] == 0xFF;  			break;  		}  	}  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadProjectProperties,The following statement contains a magic number: foreach (string line in lines) {  	if (line.StartsWith ("[")) {  	}  	else {  		var split = line.Split ('=');  		if (split.Length > 1 && split [1].Length > 1 && split [1].StartsWith ("\""))//Remove any double qouates  		 {  			split [1] = split [1].Substring (1' split [1].Length - 2);  		}  		switch (split [0]) {  		case "ID":  			ProjectID = split [1];  			break;  		case "Document":  			string mn = split [1].Substring (0' split [1].IndexOf ("/&H"));  			Modules [mn].Type = eModuleType.Document;  			break;  		case "Package":  			prevPackage = split [1];  			break;  		case "BaseClass":  			Modules [split [1]].Type = eModuleType.Designer;  			Modules [split [1]].ClassID = prevPackage;  			break;  		case "Module":  			Modules [split [1]].Type = eModuleType.Module;  			break;  		case "Class":  			Modules [split [1]].Type = eModuleType.Class;  			break;  		case "HelpFile":  		case "Name":  		case "HelpContextID":  		case "Description":  		case "VersionCompatible32":  			break;  		//393222000"  		case "CMG":  			byte[] cmg = Decrypt (split [1]);  			_protection.UserProtected = (cmg [0] & 1) != 0;  			_protection.HostProtected = (cmg [0] & 2) != 0;  			_protection.VbeProtected = (cmg [0] & 4) != 0;  			break;  		case "DPB":  			byte[] dpb = Decrypt (split [1]);  			if (dpb.Length >= 28) {  				byte reserved = dpb [0];  				var flags = new byte[3];  				Array.Copy (dpb' 1' flags' 0' 3);  				var keyNoNulls = new byte[4];  				_protection.PasswordKey = new byte[4];  				Array.Copy (dpb' 4' keyNoNulls' 0' 4);  				var hashNoNulls = new byte[20];  				_protection.PasswordHash = new byte[20];  				Array.Copy (dpb' 8' hashNoNulls' 0' 20);  				//Handle 0x00 bitwise 2.4.4.3   				for (int i = 0; i < 24; i++) {  					int bit = 128 >> (int)((i % 8));  					if (i < 4) {  						if ((int)(flags [0] & bit) == 0) {  							_protection.PasswordKey [i] = 0;  						}  						else {  							_protection.PasswordKey [i] = keyNoNulls [i];  						}  					}  					else {  						int flagIndex = (i - i % 8) / 8;  						if ((int)(flags [flagIndex] & bit) == 0) {  							_protection.PasswordHash [i - 4] = 0;  						}  						else {  							_protection.PasswordHash [i - 4] = hashNoNulls [i - 4];  						}  					}  				}  			}  			break;  		case "GC":  			_protection.VisibilityState = Decrypt (split [1]) [0] == 0xFF;  			break;  		}  	}  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadProjectProperties,The following statement contains a magic number: foreach (string line in lines) {  	if (line.StartsWith ("[")) {  	}  	else {  		var split = line.Split ('=');  		if (split.Length > 1 && split [1].Length > 1 && split [1].StartsWith ("\""))//Remove any double qouates  		 {  			split [1] = split [1].Substring (1' split [1].Length - 2);  		}  		switch (split [0]) {  		case "ID":  			ProjectID = split [1];  			break;  		case "Document":  			string mn = split [1].Substring (0' split [1].IndexOf ("/&H"));  			Modules [mn].Type = eModuleType.Document;  			break;  		case "Package":  			prevPackage = split [1];  			break;  		case "BaseClass":  			Modules [split [1]].Type = eModuleType.Designer;  			Modules [split [1]].ClassID = prevPackage;  			break;  		case "Module":  			Modules [split [1]].Type = eModuleType.Module;  			break;  		case "Class":  			Modules [split [1]].Type = eModuleType.Class;  			break;  		case "HelpFile":  		case "Name":  		case "HelpContextID":  		case "Description":  		case "VersionCompatible32":  			break;  		//393222000"  		case "CMG":  			byte[] cmg = Decrypt (split [1]);  			_protection.UserProtected = (cmg [0] & 1) != 0;  			_protection.HostProtected = (cmg [0] & 2) != 0;  			_protection.VbeProtected = (cmg [0] & 4) != 0;  			break;  		case "DPB":  			byte[] dpb = Decrypt (split [1]);  			if (dpb.Length >= 28) {  				byte reserved = dpb [0];  				var flags = new byte[3];  				Array.Copy (dpb' 1' flags' 0' 3);  				var keyNoNulls = new byte[4];  				_protection.PasswordKey = new byte[4];  				Array.Copy (dpb' 4' keyNoNulls' 0' 4);  				var hashNoNulls = new byte[20];  				_protection.PasswordHash = new byte[20];  				Array.Copy (dpb' 8' hashNoNulls' 0' 20);  				//Handle 0x00 bitwise 2.4.4.3   				for (int i = 0; i < 24; i++) {  					int bit = 128 >> (int)((i % 8));  					if (i < 4) {  						if ((int)(flags [0] & bit) == 0) {  							_protection.PasswordKey [i] = 0;  						}  						else {  							_protection.PasswordKey [i] = keyNoNulls [i];  						}  					}  					else {  						int flagIndex = (i - i % 8) / 8;  						if ((int)(flags [flagIndex] & bit) == 0) {  							_protection.PasswordHash [i - 4] = 0;  						}  						else {  							_protection.PasswordHash [i - 4] = hashNoNulls [i - 4];  						}  					}  				}  			}  			break;  		case "GC":  			_protection.VisibilityState = Decrypt (split [1]) [0] == 0xFF;  			break;  		}  	}  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadProjectProperties,The following statement contains a magic number: foreach (string line in lines) {  	if (line.StartsWith ("[")) {  	}  	else {  		var split = line.Split ('=');  		if (split.Length > 1 && split [1].Length > 1 && split [1].StartsWith ("\""))//Remove any double qouates  		 {  			split [1] = split [1].Substring (1' split [1].Length - 2);  		}  		switch (split [0]) {  		case "ID":  			ProjectID = split [1];  			break;  		case "Document":  			string mn = split [1].Substring (0' split [1].IndexOf ("/&H"));  			Modules [mn].Type = eModuleType.Document;  			break;  		case "Package":  			prevPackage = split [1];  			break;  		case "BaseClass":  			Modules [split [1]].Type = eModuleType.Designer;  			Modules [split [1]].ClassID = prevPackage;  			break;  		case "Module":  			Modules [split [1]].Type = eModuleType.Module;  			break;  		case "Class":  			Modules [split [1]].Type = eModuleType.Class;  			break;  		case "HelpFile":  		case "Name":  		case "HelpContextID":  		case "Description":  		case "VersionCompatible32":  			break;  		//393222000"  		case "CMG":  			byte[] cmg = Decrypt (split [1]);  			_protection.UserProtected = (cmg [0] & 1) != 0;  			_protection.HostProtected = (cmg [0] & 2) != 0;  			_protection.VbeProtected = (cmg [0] & 4) != 0;  			break;  		case "DPB":  			byte[] dpb = Decrypt (split [1]);  			if (dpb.Length >= 28) {  				byte reserved = dpb [0];  				var flags = new byte[3];  				Array.Copy (dpb' 1' flags' 0' 3);  				var keyNoNulls = new byte[4];  				_protection.PasswordKey = new byte[4];  				Array.Copy (dpb' 4' keyNoNulls' 0' 4);  				var hashNoNulls = new byte[20];  				_protection.PasswordHash = new byte[20];  				Array.Copy (dpb' 8' hashNoNulls' 0' 20);  				//Handle 0x00 bitwise 2.4.4.3   				for (int i = 0; i < 24; i++) {  					int bit = 128 >> (int)((i % 8));  					if (i < 4) {  						if ((int)(flags [0] & bit) == 0) {  							_protection.PasswordKey [i] = 0;  						}  						else {  							_protection.PasswordKey [i] = keyNoNulls [i];  						}  					}  					else {  						int flagIndex = (i - i % 8) / 8;  						if ((int)(flags [flagIndex] & bit) == 0) {  							_protection.PasswordHash [i - 4] = 0;  						}  						else {  							_protection.PasswordHash [i - 4] = hashNoNulls [i - 4];  						}  					}  				}  			}  			break;  		case "GC":  			_protection.VisibilityState = Decrypt (split [1]) [0] == 0xFF;  			break;  		}  	}  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadProjectProperties,The following statement contains a magic number: foreach (string line in lines) {  	if (line.StartsWith ("[")) {  	}  	else {  		var split = line.Split ('=');  		if (split.Length > 1 && split [1].Length > 1 && split [1].StartsWith ("\""))//Remove any double qouates  		 {  			split [1] = split [1].Substring (1' split [1].Length - 2);  		}  		switch (split [0]) {  		case "ID":  			ProjectID = split [1];  			break;  		case "Document":  			string mn = split [1].Substring (0' split [1].IndexOf ("/&H"));  			Modules [mn].Type = eModuleType.Document;  			break;  		case "Package":  			prevPackage = split [1];  			break;  		case "BaseClass":  			Modules [split [1]].Type = eModuleType.Designer;  			Modules [split [1]].ClassID = prevPackage;  			break;  		case "Module":  			Modules [split [1]].Type = eModuleType.Module;  			break;  		case "Class":  			Modules [split [1]].Type = eModuleType.Class;  			break;  		case "HelpFile":  		case "Name":  		case "HelpContextID":  		case "Description":  		case "VersionCompatible32":  			break;  		//393222000"  		case "CMG":  			byte[] cmg = Decrypt (split [1]);  			_protection.UserProtected = (cmg [0] & 1) != 0;  			_protection.HostProtected = (cmg [0] & 2) != 0;  			_protection.VbeProtected = (cmg [0] & 4) != 0;  			break;  		case "DPB":  			byte[] dpb = Decrypt (split [1]);  			if (dpb.Length >= 28) {  				byte reserved = dpb [0];  				var flags = new byte[3];  				Array.Copy (dpb' 1' flags' 0' 3);  				var keyNoNulls = new byte[4];  				_protection.PasswordKey = new byte[4];  				Array.Copy (dpb' 4' keyNoNulls' 0' 4);  				var hashNoNulls = new byte[20];  				_protection.PasswordHash = new byte[20];  				Array.Copy (dpb' 8' hashNoNulls' 0' 20);  				//Handle 0x00 bitwise 2.4.4.3   				for (int i = 0; i < 24; i++) {  					int bit = 128 >> (int)((i % 8));  					if (i < 4) {  						if ((int)(flags [0] & bit) == 0) {  							_protection.PasswordKey [i] = 0;  						}  						else {  							_protection.PasswordKey [i] = keyNoNulls [i];  						}  					}  					else {  						int flagIndex = (i - i % 8) / 8;  						if ((int)(flags [flagIndex] & bit) == 0) {  							_protection.PasswordHash [i - 4] = 0;  						}  						else {  							_protection.PasswordHash [i - 4] = hashNoNulls [i - 4];  						}  					}  				}  			}  			break;  		case "GC":  			_protection.VisibilityState = Decrypt (split [1]) [0] == 0xFF;  			break;  		}  	}  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadProjectProperties,The following statement contains a magic number: foreach (string line in lines) {  	if (line.StartsWith ("[")) {  	}  	else {  		var split = line.Split ('=');  		if (split.Length > 1 && split [1].Length > 1 && split [1].StartsWith ("\""))//Remove any double qouates  		 {  			split [1] = split [1].Substring (1' split [1].Length - 2);  		}  		switch (split [0]) {  		case "ID":  			ProjectID = split [1];  			break;  		case "Document":  			string mn = split [1].Substring (0' split [1].IndexOf ("/&H"));  			Modules [mn].Type = eModuleType.Document;  			break;  		case "Package":  			prevPackage = split [1];  			break;  		case "BaseClass":  			Modules [split [1]].Type = eModuleType.Designer;  			Modules [split [1]].ClassID = prevPackage;  			break;  		case "Module":  			Modules [split [1]].Type = eModuleType.Module;  			break;  		case "Class":  			Modules [split [1]].Type = eModuleType.Class;  			break;  		case "HelpFile":  		case "Name":  		case "HelpContextID":  		case "Description":  		case "VersionCompatible32":  			break;  		//393222000"  		case "CMG":  			byte[] cmg = Decrypt (split [1]);  			_protection.UserProtected = (cmg [0] & 1) != 0;  			_protection.HostProtected = (cmg [0] & 2) != 0;  			_protection.VbeProtected = (cmg [0] & 4) != 0;  			break;  		case "DPB":  			byte[] dpb = Decrypt (split [1]);  			if (dpb.Length >= 28) {  				byte reserved = dpb [0];  				var flags = new byte[3];  				Array.Copy (dpb' 1' flags' 0' 3);  				var keyNoNulls = new byte[4];  				_protection.PasswordKey = new byte[4];  				Array.Copy (dpb' 4' keyNoNulls' 0' 4);  				var hashNoNulls = new byte[20];  				_protection.PasswordHash = new byte[20];  				Array.Copy (dpb' 8' hashNoNulls' 0' 20);  				//Handle 0x00 bitwise 2.4.4.3   				for (int i = 0; i < 24; i++) {  					int bit = 128 >> (int)((i % 8));  					if (i < 4) {  						if ((int)(flags [0] & bit) == 0) {  							_protection.PasswordKey [i] = 0;  						}  						else {  							_protection.PasswordKey [i] = keyNoNulls [i];  						}  					}  					else {  						int flagIndex = (i - i % 8) / 8;  						if ((int)(flags [flagIndex] & bit) == 0) {  							_protection.PasswordHash [i - 4] = 0;  						}  						else {  							_protection.PasswordHash [i - 4] = hashNoNulls [i - 4];  						}  					}  				}  			}  			break;  		case "GC":  			_protection.VisibilityState = Decrypt (split [1]) [0] == 0xFF;  			break;  		}  	}  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadProjectProperties,The following statement contains a magic number: if (line.StartsWith ("[")) {  }  else {  	var split = line.Split ('=');  	if (split.Length > 1 && split [1].Length > 1 && split [1].StartsWith ("\""))//Remove any double qouates  	 {  		split [1] = split [1].Substring (1' split [1].Length - 2);  	}  	switch (split [0]) {  	case "ID":  		ProjectID = split [1];  		break;  	case "Document":  		string mn = split [1].Substring (0' split [1].IndexOf ("/&H"));  		Modules [mn].Type = eModuleType.Document;  		break;  	case "Package":  		prevPackage = split [1];  		break;  	case "BaseClass":  		Modules [split [1]].Type = eModuleType.Designer;  		Modules [split [1]].ClassID = prevPackage;  		break;  	case "Module":  		Modules [split [1]].Type = eModuleType.Module;  		break;  	case "Class":  		Modules [split [1]].Type = eModuleType.Class;  		break;  	case "HelpFile":  	case "Name":  	case "HelpContextID":  	case "Description":  	case "VersionCompatible32":  		break;  	//393222000"  	case "CMG":  		byte[] cmg = Decrypt (split [1]);  		_protection.UserProtected = (cmg [0] & 1) != 0;  		_protection.HostProtected = (cmg [0] & 2) != 0;  		_protection.VbeProtected = (cmg [0] & 4) != 0;  		break;  	case "DPB":  		byte[] dpb = Decrypt (split [1]);  		if (dpb.Length >= 28) {  			byte reserved = dpb [0];  			var flags = new byte[3];  			Array.Copy (dpb' 1' flags' 0' 3);  			var keyNoNulls = new byte[4];  			_protection.PasswordKey = new byte[4];  			Array.Copy (dpb' 4' keyNoNulls' 0' 4);  			var hashNoNulls = new byte[20];  			_protection.PasswordHash = new byte[20];  			Array.Copy (dpb' 8' hashNoNulls' 0' 20);  			//Handle 0x00 bitwise 2.4.4.3   			for (int i = 0; i < 24; i++) {  				int bit = 128 >> (int)((i % 8));  				if (i < 4) {  					if ((int)(flags [0] & bit) == 0) {  						_protection.PasswordKey [i] = 0;  					}  					else {  						_protection.PasswordKey [i] = keyNoNulls [i];  					}  				}  				else {  					int flagIndex = (i - i % 8) / 8;  					if ((int)(flags [flagIndex] & bit) == 0) {  						_protection.PasswordHash [i - 4] = 0;  					}  					else {  						_protection.PasswordHash [i - 4] = hashNoNulls [i - 4];  					}  				}  			}  		}  		break;  	case "GC":  		_protection.VisibilityState = Decrypt (split [1]) [0] == 0xFF;  		break;  	}  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadProjectProperties,The following statement contains a magic number: if (line.StartsWith ("[")) {  }  else {  	var split = line.Split ('=');  	if (split.Length > 1 && split [1].Length > 1 && split [1].StartsWith ("\""))//Remove any double qouates  	 {  		split [1] = split [1].Substring (1' split [1].Length - 2);  	}  	switch (split [0]) {  	case "ID":  		ProjectID = split [1];  		break;  	case "Document":  		string mn = split [1].Substring (0' split [1].IndexOf ("/&H"));  		Modules [mn].Type = eModuleType.Document;  		break;  	case "Package":  		prevPackage = split [1];  		break;  	case "BaseClass":  		Modules [split [1]].Type = eModuleType.Designer;  		Modules [split [1]].ClassID = prevPackage;  		break;  	case "Module":  		Modules [split [1]].Type = eModuleType.Module;  		break;  	case "Class":  		Modules [split [1]].Type = eModuleType.Class;  		break;  	case "HelpFile":  	case "Name":  	case "HelpContextID":  	case "Description":  	case "VersionCompatible32":  		break;  	//393222000"  	case "CMG":  		byte[] cmg = Decrypt (split [1]);  		_protection.UserProtected = (cmg [0] & 1) != 0;  		_protection.HostProtected = (cmg [0] & 2) != 0;  		_protection.VbeProtected = (cmg [0] & 4) != 0;  		break;  	case "DPB":  		byte[] dpb = Decrypt (split [1]);  		if (dpb.Length >= 28) {  			byte reserved = dpb [0];  			var flags = new byte[3];  			Array.Copy (dpb' 1' flags' 0' 3);  			var keyNoNulls = new byte[4];  			_protection.PasswordKey = new byte[4];  			Array.Copy (dpb' 4' keyNoNulls' 0' 4);  			var hashNoNulls = new byte[20];  			_protection.PasswordHash = new byte[20];  			Array.Copy (dpb' 8' hashNoNulls' 0' 20);  			//Handle 0x00 bitwise 2.4.4.3   			for (int i = 0; i < 24; i++) {  				int bit = 128 >> (int)((i % 8));  				if (i < 4) {  					if ((int)(flags [0] & bit) == 0) {  						_protection.PasswordKey [i] = 0;  					}  					else {  						_protection.PasswordKey [i] = keyNoNulls [i];  					}  				}  				else {  					int flagIndex = (i - i % 8) / 8;  					if ((int)(flags [flagIndex] & bit) == 0) {  						_protection.PasswordHash [i - 4] = 0;  					}  					else {  						_protection.PasswordHash [i - 4] = hashNoNulls [i - 4];  					}  				}  			}  		}  		break;  	case "GC":  		_protection.VisibilityState = Decrypt (split [1]) [0] == 0xFF;  		break;  	}  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadProjectProperties,The following statement contains a magic number: if (line.StartsWith ("[")) {  }  else {  	var split = line.Split ('=');  	if (split.Length > 1 && split [1].Length > 1 && split [1].StartsWith ("\""))//Remove any double qouates  	 {  		split [1] = split [1].Substring (1' split [1].Length - 2);  	}  	switch (split [0]) {  	case "ID":  		ProjectID = split [1];  		break;  	case "Document":  		string mn = split [1].Substring (0' split [1].IndexOf ("/&H"));  		Modules [mn].Type = eModuleType.Document;  		break;  	case "Package":  		prevPackage = split [1];  		break;  	case "BaseClass":  		Modules [split [1]].Type = eModuleType.Designer;  		Modules [split [1]].ClassID = prevPackage;  		break;  	case "Module":  		Modules [split [1]].Type = eModuleType.Module;  		break;  	case "Class":  		Modules [split [1]].Type = eModuleType.Class;  		break;  	case "HelpFile":  	case "Name":  	case "HelpContextID":  	case "Description":  	case "VersionCompatible32":  		break;  	//393222000"  	case "CMG":  		byte[] cmg = Decrypt (split [1]);  		_protection.UserProtected = (cmg [0] & 1) != 0;  		_protection.HostProtected = (cmg [0] & 2) != 0;  		_protection.VbeProtected = (cmg [0] & 4) != 0;  		break;  	case "DPB":  		byte[] dpb = Decrypt (split [1]);  		if (dpb.Length >= 28) {  			byte reserved = dpb [0];  			var flags = new byte[3];  			Array.Copy (dpb' 1' flags' 0' 3);  			var keyNoNulls = new byte[4];  			_protection.PasswordKey = new byte[4];  			Array.Copy (dpb' 4' keyNoNulls' 0' 4);  			var hashNoNulls = new byte[20];  			_protection.PasswordHash = new byte[20];  			Array.Copy (dpb' 8' hashNoNulls' 0' 20);  			//Handle 0x00 bitwise 2.4.4.3   			for (int i = 0; i < 24; i++) {  				int bit = 128 >> (int)((i % 8));  				if (i < 4) {  					if ((int)(flags [0] & bit) == 0) {  						_protection.PasswordKey [i] = 0;  					}  					else {  						_protection.PasswordKey [i] = keyNoNulls [i];  					}  				}  				else {  					int flagIndex = (i - i % 8) / 8;  					if ((int)(flags [flagIndex] & bit) == 0) {  						_protection.PasswordHash [i - 4] = 0;  					}  					else {  						_protection.PasswordHash [i - 4] = hashNoNulls [i - 4];  					}  				}  			}  		}  		break;  	case "GC":  		_protection.VisibilityState = Decrypt (split [1]) [0] == 0xFF;  		break;  	}  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadProjectProperties,The following statement contains a magic number: if (line.StartsWith ("[")) {  }  else {  	var split = line.Split ('=');  	if (split.Length > 1 && split [1].Length > 1 && split [1].StartsWith ("\""))//Remove any double qouates  	 {  		split [1] = split [1].Substring (1' split [1].Length - 2);  	}  	switch (split [0]) {  	case "ID":  		ProjectID = split [1];  		break;  	case "Document":  		string mn = split [1].Substring (0' split [1].IndexOf ("/&H"));  		Modules [mn].Type = eModuleType.Document;  		break;  	case "Package":  		prevPackage = split [1];  		break;  	case "BaseClass":  		Modules [split [1]].Type = eModuleType.Designer;  		Modules [split [1]].ClassID = prevPackage;  		break;  	case "Module":  		Modules [split [1]].Type = eModuleType.Module;  		break;  	case "Class":  		Modules [split [1]].Type = eModuleType.Class;  		break;  	case "HelpFile":  	case "Name":  	case "HelpContextID":  	case "Description":  	case "VersionCompatible32":  		break;  	//393222000"  	case "CMG":  		byte[] cmg = Decrypt (split [1]);  		_protection.UserProtected = (cmg [0] & 1) != 0;  		_protection.HostProtected = (cmg [0] & 2) != 0;  		_protection.VbeProtected = (cmg [0] & 4) != 0;  		break;  	case "DPB":  		byte[] dpb = Decrypt (split [1]);  		if (dpb.Length >= 28) {  			byte reserved = dpb [0];  			var flags = new byte[3];  			Array.Copy (dpb' 1' flags' 0' 3);  			var keyNoNulls = new byte[4];  			_protection.PasswordKey = new byte[4];  			Array.Copy (dpb' 4' keyNoNulls' 0' 4);  			var hashNoNulls = new byte[20];  			_protection.PasswordHash = new byte[20];  			Array.Copy (dpb' 8' hashNoNulls' 0' 20);  			//Handle 0x00 bitwise 2.4.4.3   			for (int i = 0; i < 24; i++) {  				int bit = 128 >> (int)((i % 8));  				if (i < 4) {  					if ((int)(flags [0] & bit) == 0) {  						_protection.PasswordKey [i] = 0;  					}  					else {  						_protection.PasswordKey [i] = keyNoNulls [i];  					}  				}  				else {  					int flagIndex = (i - i % 8) / 8;  					if ((int)(flags [flagIndex] & bit) == 0) {  						_protection.PasswordHash [i - 4] = 0;  					}  					else {  						_protection.PasswordHash [i - 4] = hashNoNulls [i - 4];  					}  				}  			}  		}  		break;  	case "GC":  		_protection.VisibilityState = Decrypt (split [1]) [0] == 0xFF;  		break;  	}  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadProjectProperties,The following statement contains a magic number: if (line.StartsWith ("[")) {  }  else {  	var split = line.Split ('=');  	if (split.Length > 1 && split [1].Length > 1 && split [1].StartsWith ("\""))//Remove any double qouates  	 {  		split [1] = split [1].Substring (1' split [1].Length - 2);  	}  	switch (split [0]) {  	case "ID":  		ProjectID = split [1];  		break;  	case "Document":  		string mn = split [1].Substring (0' split [1].IndexOf ("/&H"));  		Modules [mn].Type = eModuleType.Document;  		break;  	case "Package":  		prevPackage = split [1];  		break;  	case "BaseClass":  		Modules [split [1]].Type = eModuleType.Designer;  		Modules [split [1]].ClassID = prevPackage;  		break;  	case "Module":  		Modules [split [1]].Type = eModuleType.Module;  		break;  	case "Class":  		Modules [split [1]].Type = eModuleType.Class;  		break;  	case "HelpFile":  	case "Name":  	case "HelpContextID":  	case "Description":  	case "VersionCompatible32":  		break;  	//393222000"  	case "CMG":  		byte[] cmg = Decrypt (split [1]);  		_protection.UserProtected = (cmg [0] & 1) != 0;  		_protection.HostProtected = (cmg [0] & 2) != 0;  		_protection.VbeProtected = (cmg [0] & 4) != 0;  		break;  	case "DPB":  		byte[] dpb = Decrypt (split [1]);  		if (dpb.Length >= 28) {  			byte reserved = dpb [0];  			var flags = new byte[3];  			Array.Copy (dpb' 1' flags' 0' 3);  			var keyNoNulls = new byte[4];  			_protection.PasswordKey = new byte[4];  			Array.Copy (dpb' 4' keyNoNulls' 0' 4);  			var hashNoNulls = new byte[20];  			_protection.PasswordHash = new byte[20];  			Array.Copy (dpb' 8' hashNoNulls' 0' 20);  			//Handle 0x00 bitwise 2.4.4.3   			for (int i = 0; i < 24; i++) {  				int bit = 128 >> (int)((i % 8));  				if (i < 4) {  					if ((int)(flags [0] & bit) == 0) {  						_protection.PasswordKey [i] = 0;  					}  					else {  						_protection.PasswordKey [i] = keyNoNulls [i];  					}  				}  				else {  					int flagIndex = (i - i % 8) / 8;  					if ((int)(flags [flagIndex] & bit) == 0) {  						_protection.PasswordHash [i - 4] = 0;  					}  					else {  						_protection.PasswordHash [i - 4] = hashNoNulls [i - 4];  					}  				}  			}  		}  		break;  	case "GC":  		_protection.VisibilityState = Decrypt (split [1]) [0] == 0xFF;  		break;  	}  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadProjectProperties,The following statement contains a magic number: if (line.StartsWith ("[")) {  }  else {  	var split = line.Split ('=');  	if (split.Length > 1 && split [1].Length > 1 && split [1].StartsWith ("\""))//Remove any double qouates  	 {  		split [1] = split [1].Substring (1' split [1].Length - 2);  	}  	switch (split [0]) {  	case "ID":  		ProjectID = split [1];  		break;  	case "Document":  		string mn = split [1].Substring (0' split [1].IndexOf ("/&H"));  		Modules [mn].Type = eModuleType.Document;  		break;  	case "Package":  		prevPackage = split [1];  		break;  	case "BaseClass":  		Modules [split [1]].Type = eModuleType.Designer;  		Modules [split [1]].ClassID = prevPackage;  		break;  	case "Module":  		Modules [split [1]].Type = eModuleType.Module;  		break;  	case "Class":  		Modules [split [1]].Type = eModuleType.Class;  		break;  	case "HelpFile":  	case "Name":  	case "HelpContextID":  	case "Description":  	case "VersionCompatible32":  		break;  	//393222000"  	case "CMG":  		byte[] cmg = Decrypt (split [1]);  		_protection.UserProtected = (cmg [0] & 1) != 0;  		_protection.HostProtected = (cmg [0] & 2) != 0;  		_protection.VbeProtected = (cmg [0] & 4) != 0;  		break;  	case "DPB":  		byte[] dpb = Decrypt (split [1]);  		if (dpb.Length >= 28) {  			byte reserved = dpb [0];  			var flags = new byte[3];  			Array.Copy (dpb' 1' flags' 0' 3);  			var keyNoNulls = new byte[4];  			_protection.PasswordKey = new byte[4];  			Array.Copy (dpb' 4' keyNoNulls' 0' 4);  			var hashNoNulls = new byte[20];  			_protection.PasswordHash = new byte[20];  			Array.Copy (dpb' 8' hashNoNulls' 0' 20);  			//Handle 0x00 bitwise 2.4.4.3   			for (int i = 0; i < 24; i++) {  				int bit = 128 >> (int)((i % 8));  				if (i < 4) {  					if ((int)(flags [0] & bit) == 0) {  						_protection.PasswordKey [i] = 0;  					}  					else {  						_protection.PasswordKey [i] = keyNoNulls [i];  					}  				}  				else {  					int flagIndex = (i - i % 8) / 8;  					if ((int)(flags [flagIndex] & bit) == 0) {  						_protection.PasswordHash [i - 4] = 0;  					}  					else {  						_protection.PasswordHash [i - 4] = hashNoNulls [i - 4];  					}  				}  			}  		}  		break;  	case "GC":  		_protection.VisibilityState = Decrypt (split [1]) [0] == 0xFF;  		break;  	}  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadProjectProperties,The following statement contains a magic number: if (line.StartsWith ("[")) {  }  else {  	var split = line.Split ('=');  	if (split.Length > 1 && split [1].Length > 1 && split [1].StartsWith ("\""))//Remove any double qouates  	 {  		split [1] = split [1].Substring (1' split [1].Length - 2);  	}  	switch (split [0]) {  	case "ID":  		ProjectID = split [1];  		break;  	case "Document":  		string mn = split [1].Substring (0' split [1].IndexOf ("/&H"));  		Modules [mn].Type = eModuleType.Document;  		break;  	case "Package":  		prevPackage = split [1];  		break;  	case "BaseClass":  		Modules [split [1]].Type = eModuleType.Designer;  		Modules [split [1]].ClassID = prevPackage;  		break;  	case "Module":  		Modules [split [1]].Type = eModuleType.Module;  		break;  	case "Class":  		Modules [split [1]].Type = eModuleType.Class;  		break;  	case "HelpFile":  	case "Name":  	case "HelpContextID":  	case "Description":  	case "VersionCompatible32":  		break;  	//393222000"  	case "CMG":  		byte[] cmg = Decrypt (split [1]);  		_protection.UserProtected = (cmg [0] & 1) != 0;  		_protection.HostProtected = (cmg [0] & 2) != 0;  		_protection.VbeProtected = (cmg [0] & 4) != 0;  		break;  	case "DPB":  		byte[] dpb = Decrypt (split [1]);  		if (dpb.Length >= 28) {  			byte reserved = dpb [0];  			var flags = new byte[3];  			Array.Copy (dpb' 1' flags' 0' 3);  			var keyNoNulls = new byte[4];  			_protection.PasswordKey = new byte[4];  			Array.Copy (dpb' 4' keyNoNulls' 0' 4);  			var hashNoNulls = new byte[20];  			_protection.PasswordHash = new byte[20];  			Array.Copy (dpb' 8' hashNoNulls' 0' 20);  			//Handle 0x00 bitwise 2.4.4.3   			for (int i = 0; i < 24; i++) {  				int bit = 128 >> (int)((i % 8));  				if (i < 4) {  					if ((int)(flags [0] & bit) == 0) {  						_protection.PasswordKey [i] = 0;  					}  					else {  						_protection.PasswordKey [i] = keyNoNulls [i];  					}  				}  				else {  					int flagIndex = (i - i % 8) / 8;  					if ((int)(flags [flagIndex] & bit) == 0) {  						_protection.PasswordHash [i - 4] = 0;  					}  					else {  						_protection.PasswordHash [i - 4] = hashNoNulls [i - 4];  					}  				}  			}  		}  		break;  	case "GC":  		_protection.VisibilityState = Decrypt (split [1]) [0] == 0xFF;  		break;  	}  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadProjectProperties,The following statement contains a magic number: if (line.StartsWith ("[")) {  }  else {  	var split = line.Split ('=');  	if (split.Length > 1 && split [1].Length > 1 && split [1].StartsWith ("\""))//Remove any double qouates  	 {  		split [1] = split [1].Substring (1' split [1].Length - 2);  	}  	switch (split [0]) {  	case "ID":  		ProjectID = split [1];  		break;  	case "Document":  		string mn = split [1].Substring (0' split [1].IndexOf ("/&H"));  		Modules [mn].Type = eModuleType.Document;  		break;  	case "Package":  		prevPackage = split [1];  		break;  	case "BaseClass":  		Modules [split [1]].Type = eModuleType.Designer;  		Modules [split [1]].ClassID = prevPackage;  		break;  	case "Module":  		Modules [split [1]].Type = eModuleType.Module;  		break;  	case "Class":  		Modules [split [1]].Type = eModuleType.Class;  		break;  	case "HelpFile":  	case "Name":  	case "HelpContextID":  	case "Description":  	case "VersionCompatible32":  		break;  	//393222000"  	case "CMG":  		byte[] cmg = Decrypt (split [1]);  		_protection.UserProtected = (cmg [0] & 1) != 0;  		_protection.HostProtected = (cmg [0] & 2) != 0;  		_protection.VbeProtected = (cmg [0] & 4) != 0;  		break;  	case "DPB":  		byte[] dpb = Decrypt (split [1]);  		if (dpb.Length >= 28) {  			byte reserved = dpb [0];  			var flags = new byte[3];  			Array.Copy (dpb' 1' flags' 0' 3);  			var keyNoNulls = new byte[4];  			_protection.PasswordKey = new byte[4];  			Array.Copy (dpb' 4' keyNoNulls' 0' 4);  			var hashNoNulls = new byte[20];  			_protection.PasswordHash = new byte[20];  			Array.Copy (dpb' 8' hashNoNulls' 0' 20);  			//Handle 0x00 bitwise 2.4.4.3   			for (int i = 0; i < 24; i++) {  				int bit = 128 >> (int)((i % 8));  				if (i < 4) {  					if ((int)(flags [0] & bit) == 0) {  						_protection.PasswordKey [i] = 0;  					}  					else {  						_protection.PasswordKey [i] = keyNoNulls [i];  					}  				}  				else {  					int flagIndex = (i - i % 8) / 8;  					if ((int)(flags [flagIndex] & bit) == 0) {  						_protection.PasswordHash [i - 4] = 0;  					}  					else {  						_protection.PasswordHash [i - 4] = hashNoNulls [i - 4];  					}  				}  			}  		}  		break;  	case "GC":  		_protection.VisibilityState = Decrypt (split [1]) [0] == 0xFF;  		break;  	}  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadProjectProperties,The following statement contains a magic number: if (line.StartsWith ("[")) {  }  else {  	var split = line.Split ('=');  	if (split.Length > 1 && split [1].Length > 1 && split [1].StartsWith ("\""))//Remove any double qouates  	 {  		split [1] = split [1].Substring (1' split [1].Length - 2);  	}  	switch (split [0]) {  	case "ID":  		ProjectID = split [1];  		break;  	case "Document":  		string mn = split [1].Substring (0' split [1].IndexOf ("/&H"));  		Modules [mn].Type = eModuleType.Document;  		break;  	case "Package":  		prevPackage = split [1];  		break;  	case "BaseClass":  		Modules [split [1]].Type = eModuleType.Designer;  		Modules [split [1]].ClassID = prevPackage;  		break;  	case "Module":  		Modules [split [1]].Type = eModuleType.Module;  		break;  	case "Class":  		Modules [split [1]].Type = eModuleType.Class;  		break;  	case "HelpFile":  	case "Name":  	case "HelpContextID":  	case "Description":  	case "VersionCompatible32":  		break;  	//393222000"  	case "CMG":  		byte[] cmg = Decrypt (split [1]);  		_protection.UserProtected = (cmg [0] & 1) != 0;  		_protection.HostProtected = (cmg [0] & 2) != 0;  		_protection.VbeProtected = (cmg [0] & 4) != 0;  		break;  	case "DPB":  		byte[] dpb = Decrypt (split [1]);  		if (dpb.Length >= 28) {  			byte reserved = dpb [0];  			var flags = new byte[3];  			Array.Copy (dpb' 1' flags' 0' 3);  			var keyNoNulls = new byte[4];  			_protection.PasswordKey = new byte[4];  			Array.Copy (dpb' 4' keyNoNulls' 0' 4);  			var hashNoNulls = new byte[20];  			_protection.PasswordHash = new byte[20];  			Array.Copy (dpb' 8' hashNoNulls' 0' 20);  			//Handle 0x00 bitwise 2.4.4.3   			for (int i = 0; i < 24; i++) {  				int bit = 128 >> (int)((i % 8));  				if (i < 4) {  					if ((int)(flags [0] & bit) == 0) {  						_protection.PasswordKey [i] = 0;  					}  					else {  						_protection.PasswordKey [i] = keyNoNulls [i];  					}  				}  				else {  					int flagIndex = (i - i % 8) / 8;  					if ((int)(flags [flagIndex] & bit) == 0) {  						_protection.PasswordHash [i - 4] = 0;  					}  					else {  						_protection.PasswordHash [i - 4] = hashNoNulls [i - 4];  					}  				}  			}  		}  		break;  	case "GC":  		_protection.VisibilityState = Decrypt (split [1]) [0] == 0xFF;  		break;  	}  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadProjectProperties,The following statement contains a magic number: if (line.StartsWith ("[")) {  }  else {  	var split = line.Split ('=');  	if (split.Length > 1 && split [1].Length > 1 && split [1].StartsWith ("\""))//Remove any double qouates  	 {  		split [1] = split [1].Substring (1' split [1].Length - 2);  	}  	switch (split [0]) {  	case "ID":  		ProjectID = split [1];  		break;  	case "Document":  		string mn = split [1].Substring (0' split [1].IndexOf ("/&H"));  		Modules [mn].Type = eModuleType.Document;  		break;  	case "Package":  		prevPackage = split [1];  		break;  	case "BaseClass":  		Modules [split [1]].Type = eModuleType.Designer;  		Modules [split [1]].ClassID = prevPackage;  		break;  	case "Module":  		Modules [split [1]].Type = eModuleType.Module;  		break;  	case "Class":  		Modules [split [1]].Type = eModuleType.Class;  		break;  	case "HelpFile":  	case "Name":  	case "HelpContextID":  	case "Description":  	case "VersionCompatible32":  		break;  	//393222000"  	case "CMG":  		byte[] cmg = Decrypt (split [1]);  		_protection.UserProtected = (cmg [0] & 1) != 0;  		_protection.HostProtected = (cmg [0] & 2) != 0;  		_protection.VbeProtected = (cmg [0] & 4) != 0;  		break;  	case "DPB":  		byte[] dpb = Decrypt (split [1]);  		if (dpb.Length >= 28) {  			byte reserved = dpb [0];  			var flags = new byte[3];  			Array.Copy (dpb' 1' flags' 0' 3);  			var keyNoNulls = new byte[4];  			_protection.PasswordKey = new byte[4];  			Array.Copy (dpb' 4' keyNoNulls' 0' 4);  			var hashNoNulls = new byte[20];  			_protection.PasswordHash = new byte[20];  			Array.Copy (dpb' 8' hashNoNulls' 0' 20);  			//Handle 0x00 bitwise 2.4.4.3   			for (int i = 0; i < 24; i++) {  				int bit = 128 >> (int)((i % 8));  				if (i < 4) {  					if ((int)(flags [0] & bit) == 0) {  						_protection.PasswordKey [i] = 0;  					}  					else {  						_protection.PasswordKey [i] = keyNoNulls [i];  					}  				}  				else {  					int flagIndex = (i - i % 8) / 8;  					if ((int)(flags [flagIndex] & bit) == 0) {  						_protection.PasswordHash [i - 4] = 0;  					}  					else {  						_protection.PasswordHash [i - 4] = hashNoNulls [i - 4];  					}  				}  			}  		}  		break;  	case "GC":  		_protection.VisibilityState = Decrypt (split [1]) [0] == 0xFF;  		break;  	}  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadProjectProperties,The following statement contains a magic number: if (line.StartsWith ("[")) {  }  else {  	var split = line.Split ('=');  	if (split.Length > 1 && split [1].Length > 1 && split [1].StartsWith ("\""))//Remove any double qouates  	 {  		split [1] = split [1].Substring (1' split [1].Length - 2);  	}  	switch (split [0]) {  	case "ID":  		ProjectID = split [1];  		break;  	case "Document":  		string mn = split [1].Substring (0' split [1].IndexOf ("/&H"));  		Modules [mn].Type = eModuleType.Document;  		break;  	case "Package":  		prevPackage = split [1];  		break;  	case "BaseClass":  		Modules [split [1]].Type = eModuleType.Designer;  		Modules [split [1]].ClassID = prevPackage;  		break;  	case "Module":  		Modules [split [1]].Type = eModuleType.Module;  		break;  	case "Class":  		Modules [split [1]].Type = eModuleType.Class;  		break;  	case "HelpFile":  	case "Name":  	case "HelpContextID":  	case "Description":  	case "VersionCompatible32":  		break;  	//393222000"  	case "CMG":  		byte[] cmg = Decrypt (split [1]);  		_protection.UserProtected = (cmg [0] & 1) != 0;  		_protection.HostProtected = (cmg [0] & 2) != 0;  		_protection.VbeProtected = (cmg [0] & 4) != 0;  		break;  	case "DPB":  		byte[] dpb = Decrypt (split [1]);  		if (dpb.Length >= 28) {  			byte reserved = dpb [0];  			var flags = new byte[3];  			Array.Copy (dpb' 1' flags' 0' 3);  			var keyNoNulls = new byte[4];  			_protection.PasswordKey = new byte[4];  			Array.Copy (dpb' 4' keyNoNulls' 0' 4);  			var hashNoNulls = new byte[20];  			_protection.PasswordHash = new byte[20];  			Array.Copy (dpb' 8' hashNoNulls' 0' 20);  			//Handle 0x00 bitwise 2.4.4.3   			for (int i = 0; i < 24; i++) {  				int bit = 128 >> (int)((i % 8));  				if (i < 4) {  					if ((int)(flags [0] & bit) == 0) {  						_protection.PasswordKey [i] = 0;  					}  					else {  						_protection.PasswordKey [i] = keyNoNulls [i];  					}  				}  				else {  					int flagIndex = (i - i % 8) / 8;  					if ((int)(flags [flagIndex] & bit) == 0) {  						_protection.PasswordHash [i - 4] = 0;  					}  					else {  						_protection.PasswordHash [i - 4] = hashNoNulls [i - 4];  					}  				}  			}  		}  		break;  	case "GC":  		_protection.VisibilityState = Decrypt (split [1]) [0] == 0xFF;  		break;  	}  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadProjectProperties,The following statement contains a magic number: if (line.StartsWith ("[")) {  }  else {  	var split = line.Split ('=');  	if (split.Length > 1 && split [1].Length > 1 && split [1].StartsWith ("\""))//Remove any double qouates  	 {  		split [1] = split [1].Substring (1' split [1].Length - 2);  	}  	switch (split [0]) {  	case "ID":  		ProjectID = split [1];  		break;  	case "Document":  		string mn = split [1].Substring (0' split [1].IndexOf ("/&H"));  		Modules [mn].Type = eModuleType.Document;  		break;  	case "Package":  		prevPackage = split [1];  		break;  	case "BaseClass":  		Modules [split [1]].Type = eModuleType.Designer;  		Modules [split [1]].ClassID = prevPackage;  		break;  	case "Module":  		Modules [split [1]].Type = eModuleType.Module;  		break;  	case "Class":  		Modules [split [1]].Type = eModuleType.Class;  		break;  	case "HelpFile":  	case "Name":  	case "HelpContextID":  	case "Description":  	case "VersionCompatible32":  		break;  	//393222000"  	case "CMG":  		byte[] cmg = Decrypt (split [1]);  		_protection.UserProtected = (cmg [0] & 1) != 0;  		_protection.HostProtected = (cmg [0] & 2) != 0;  		_protection.VbeProtected = (cmg [0] & 4) != 0;  		break;  	case "DPB":  		byte[] dpb = Decrypt (split [1]);  		if (dpb.Length >= 28) {  			byte reserved = dpb [0];  			var flags = new byte[3];  			Array.Copy (dpb' 1' flags' 0' 3);  			var keyNoNulls = new byte[4];  			_protection.PasswordKey = new byte[4];  			Array.Copy (dpb' 4' keyNoNulls' 0' 4);  			var hashNoNulls = new byte[20];  			_protection.PasswordHash = new byte[20];  			Array.Copy (dpb' 8' hashNoNulls' 0' 20);  			//Handle 0x00 bitwise 2.4.4.3   			for (int i = 0; i < 24; i++) {  				int bit = 128 >> (int)((i % 8));  				if (i < 4) {  					if ((int)(flags [0] & bit) == 0) {  						_protection.PasswordKey [i] = 0;  					}  					else {  						_protection.PasswordKey [i] = keyNoNulls [i];  					}  				}  				else {  					int flagIndex = (i - i % 8) / 8;  					if ((int)(flags [flagIndex] & bit) == 0) {  						_protection.PasswordHash [i - 4] = 0;  					}  					else {  						_protection.PasswordHash [i - 4] = hashNoNulls [i - 4];  					}  				}  			}  		}  		break;  	case "GC":  		_protection.VisibilityState = Decrypt (split [1]) [0] == 0xFF;  		break;  	}  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadProjectProperties,The following statement contains a magic number: if (line.StartsWith ("[")) {  }  else {  	var split = line.Split ('=');  	if (split.Length > 1 && split [1].Length > 1 && split [1].StartsWith ("\""))//Remove any double qouates  	 {  		split [1] = split [1].Substring (1' split [1].Length - 2);  	}  	switch (split [0]) {  	case "ID":  		ProjectID = split [1];  		break;  	case "Document":  		string mn = split [1].Substring (0' split [1].IndexOf ("/&H"));  		Modules [mn].Type = eModuleType.Document;  		break;  	case "Package":  		prevPackage = split [1];  		break;  	case "BaseClass":  		Modules [split [1]].Type = eModuleType.Designer;  		Modules [split [1]].ClassID = prevPackage;  		break;  	case "Module":  		Modules [split [1]].Type = eModuleType.Module;  		break;  	case "Class":  		Modules [split [1]].Type = eModuleType.Class;  		break;  	case "HelpFile":  	case "Name":  	case "HelpContextID":  	case "Description":  	case "VersionCompatible32":  		break;  	//393222000"  	case "CMG":  		byte[] cmg = Decrypt (split [1]);  		_protection.UserProtected = (cmg [0] & 1) != 0;  		_protection.HostProtected = (cmg [0] & 2) != 0;  		_protection.VbeProtected = (cmg [0] & 4) != 0;  		break;  	case "DPB":  		byte[] dpb = Decrypt (split [1]);  		if (dpb.Length >= 28) {  			byte reserved = dpb [0];  			var flags = new byte[3];  			Array.Copy (dpb' 1' flags' 0' 3);  			var keyNoNulls = new byte[4];  			_protection.PasswordKey = new byte[4];  			Array.Copy (dpb' 4' keyNoNulls' 0' 4);  			var hashNoNulls = new byte[20];  			_protection.PasswordHash = new byte[20];  			Array.Copy (dpb' 8' hashNoNulls' 0' 20);  			//Handle 0x00 bitwise 2.4.4.3   			for (int i = 0; i < 24; i++) {  				int bit = 128 >> (int)((i % 8));  				if (i < 4) {  					if ((int)(flags [0] & bit) == 0) {  						_protection.PasswordKey [i] = 0;  					}  					else {  						_protection.PasswordKey [i] = keyNoNulls [i];  					}  				}  				else {  					int flagIndex = (i - i % 8) / 8;  					if ((int)(flags [flagIndex] & bit) == 0) {  						_protection.PasswordHash [i - 4] = 0;  					}  					else {  						_protection.PasswordHash [i - 4] = hashNoNulls [i - 4];  					}  				}  			}  		}  		break;  	case "GC":  		_protection.VisibilityState = Decrypt (split [1]) [0] == 0xFF;  		break;  	}  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadProjectProperties,The following statement contains a magic number: if (line.StartsWith ("[")) {  }  else {  	var split = line.Split ('=');  	if (split.Length > 1 && split [1].Length > 1 && split [1].StartsWith ("\""))//Remove any double qouates  	 {  		split [1] = split [1].Substring (1' split [1].Length - 2);  	}  	switch (split [0]) {  	case "ID":  		ProjectID = split [1];  		break;  	case "Document":  		string mn = split [1].Substring (0' split [1].IndexOf ("/&H"));  		Modules [mn].Type = eModuleType.Document;  		break;  	case "Package":  		prevPackage = split [1];  		break;  	case "BaseClass":  		Modules [split [1]].Type = eModuleType.Designer;  		Modules [split [1]].ClassID = prevPackage;  		break;  	case "Module":  		Modules [split [1]].Type = eModuleType.Module;  		break;  	case "Class":  		Modules [split [1]].Type = eModuleType.Class;  		break;  	case "HelpFile":  	case "Name":  	case "HelpContextID":  	case "Description":  	case "VersionCompatible32":  		break;  	//393222000"  	case "CMG":  		byte[] cmg = Decrypt (split [1]);  		_protection.UserProtected = (cmg [0] & 1) != 0;  		_protection.HostProtected = (cmg [0] & 2) != 0;  		_protection.VbeProtected = (cmg [0] & 4) != 0;  		break;  	case "DPB":  		byte[] dpb = Decrypt (split [1]);  		if (dpb.Length >= 28) {  			byte reserved = dpb [0];  			var flags = new byte[3];  			Array.Copy (dpb' 1' flags' 0' 3);  			var keyNoNulls = new byte[4];  			_protection.PasswordKey = new byte[4];  			Array.Copy (dpb' 4' keyNoNulls' 0' 4);  			var hashNoNulls = new byte[20];  			_protection.PasswordHash = new byte[20];  			Array.Copy (dpb' 8' hashNoNulls' 0' 20);  			//Handle 0x00 bitwise 2.4.4.3   			for (int i = 0; i < 24; i++) {  				int bit = 128 >> (int)((i % 8));  				if (i < 4) {  					if ((int)(flags [0] & bit) == 0) {  						_protection.PasswordKey [i] = 0;  					}  					else {  						_protection.PasswordKey [i] = keyNoNulls [i];  					}  				}  				else {  					int flagIndex = (i - i % 8) / 8;  					if ((int)(flags [flagIndex] & bit) == 0) {  						_protection.PasswordHash [i - 4] = 0;  					}  					else {  						_protection.PasswordHash [i - 4] = hashNoNulls [i - 4];  					}  				}  			}  		}  		break;  	case "GC":  		_protection.VisibilityState = Decrypt (split [1]) [0] == 0xFF;  		break;  	}  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadProjectProperties,The following statement contains a magic number: if (line.StartsWith ("[")) {  }  else {  	var split = line.Split ('=');  	if (split.Length > 1 && split [1].Length > 1 && split [1].StartsWith ("\""))//Remove any double qouates  	 {  		split [1] = split [1].Substring (1' split [1].Length - 2);  	}  	switch (split [0]) {  	case "ID":  		ProjectID = split [1];  		break;  	case "Document":  		string mn = split [1].Substring (0' split [1].IndexOf ("/&H"));  		Modules [mn].Type = eModuleType.Document;  		break;  	case "Package":  		prevPackage = split [1];  		break;  	case "BaseClass":  		Modules [split [1]].Type = eModuleType.Designer;  		Modules [split [1]].ClassID = prevPackage;  		break;  	case "Module":  		Modules [split [1]].Type = eModuleType.Module;  		break;  	case "Class":  		Modules [split [1]].Type = eModuleType.Class;  		break;  	case "HelpFile":  	case "Name":  	case "HelpContextID":  	case "Description":  	case "VersionCompatible32":  		break;  	//393222000"  	case "CMG":  		byte[] cmg = Decrypt (split [1]);  		_protection.UserProtected = (cmg [0] & 1) != 0;  		_protection.HostProtected = (cmg [0] & 2) != 0;  		_protection.VbeProtected = (cmg [0] & 4) != 0;  		break;  	case "DPB":  		byte[] dpb = Decrypt (split [1]);  		if (dpb.Length >= 28) {  			byte reserved = dpb [0];  			var flags = new byte[3];  			Array.Copy (dpb' 1' flags' 0' 3);  			var keyNoNulls = new byte[4];  			_protection.PasswordKey = new byte[4];  			Array.Copy (dpb' 4' keyNoNulls' 0' 4);  			var hashNoNulls = new byte[20];  			_protection.PasswordHash = new byte[20];  			Array.Copy (dpb' 8' hashNoNulls' 0' 20);  			//Handle 0x00 bitwise 2.4.4.3   			for (int i = 0; i < 24; i++) {  				int bit = 128 >> (int)((i % 8));  				if (i < 4) {  					if ((int)(flags [0] & bit) == 0) {  						_protection.PasswordKey [i] = 0;  					}  					else {  						_protection.PasswordKey [i] = keyNoNulls [i];  					}  				}  				else {  					int flagIndex = (i - i % 8) / 8;  					if ((int)(flags [flagIndex] & bit) == 0) {  						_protection.PasswordHash [i - 4] = 0;  					}  					else {  						_protection.PasswordHash [i - 4] = hashNoNulls [i - 4];  					}  				}  			}  		}  		break;  	case "GC":  		_protection.VisibilityState = Decrypt (split [1]) [0] == 0xFF;  		break;  	}  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadProjectProperties,The following statement contains a magic number: if (line.StartsWith ("[")) {  }  else {  	var split = line.Split ('=');  	if (split.Length > 1 && split [1].Length > 1 && split [1].StartsWith ("\""))//Remove any double qouates  	 {  		split [1] = split [1].Substring (1' split [1].Length - 2);  	}  	switch (split [0]) {  	case "ID":  		ProjectID = split [1];  		break;  	case "Document":  		string mn = split [1].Substring (0' split [1].IndexOf ("/&H"));  		Modules [mn].Type = eModuleType.Document;  		break;  	case "Package":  		prevPackage = split [1];  		break;  	case "BaseClass":  		Modules [split [1]].Type = eModuleType.Designer;  		Modules [split [1]].ClassID = prevPackage;  		break;  	case "Module":  		Modules [split [1]].Type = eModuleType.Module;  		break;  	case "Class":  		Modules [split [1]].Type = eModuleType.Class;  		break;  	case "HelpFile":  	case "Name":  	case "HelpContextID":  	case "Description":  	case "VersionCompatible32":  		break;  	//393222000"  	case "CMG":  		byte[] cmg = Decrypt (split [1]);  		_protection.UserProtected = (cmg [0] & 1) != 0;  		_protection.HostProtected = (cmg [0] & 2) != 0;  		_protection.VbeProtected = (cmg [0] & 4) != 0;  		break;  	case "DPB":  		byte[] dpb = Decrypt (split [1]);  		if (dpb.Length >= 28) {  			byte reserved = dpb [0];  			var flags = new byte[3];  			Array.Copy (dpb' 1' flags' 0' 3);  			var keyNoNulls = new byte[4];  			_protection.PasswordKey = new byte[4];  			Array.Copy (dpb' 4' keyNoNulls' 0' 4);  			var hashNoNulls = new byte[20];  			_protection.PasswordHash = new byte[20];  			Array.Copy (dpb' 8' hashNoNulls' 0' 20);  			//Handle 0x00 bitwise 2.4.4.3   			for (int i = 0; i < 24; i++) {  				int bit = 128 >> (int)((i % 8));  				if (i < 4) {  					if ((int)(flags [0] & bit) == 0) {  						_protection.PasswordKey [i] = 0;  					}  					else {  						_protection.PasswordKey [i] = keyNoNulls [i];  					}  				}  				else {  					int flagIndex = (i - i % 8) / 8;  					if ((int)(flags [flagIndex] & bit) == 0) {  						_protection.PasswordHash [i - 4] = 0;  					}  					else {  						_protection.PasswordHash [i - 4] = hashNoNulls [i - 4];  					}  				}  			}  		}  		break;  	case "GC":  		_protection.VisibilityState = Decrypt (split [1]) [0] == 0xFF;  		break;  	}  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadProjectProperties,The following statement contains a magic number: if (line.StartsWith ("[")) {  }  else {  	var split = line.Split ('=');  	if (split.Length > 1 && split [1].Length > 1 && split [1].StartsWith ("\""))//Remove any double qouates  	 {  		split [1] = split [1].Substring (1' split [1].Length - 2);  	}  	switch (split [0]) {  	case "ID":  		ProjectID = split [1];  		break;  	case "Document":  		string mn = split [1].Substring (0' split [1].IndexOf ("/&H"));  		Modules [mn].Type = eModuleType.Document;  		break;  	case "Package":  		prevPackage = split [1];  		break;  	case "BaseClass":  		Modules [split [1]].Type = eModuleType.Designer;  		Modules [split [1]].ClassID = prevPackage;  		break;  	case "Module":  		Modules [split [1]].Type = eModuleType.Module;  		break;  	case "Class":  		Modules [split [1]].Type = eModuleType.Class;  		break;  	case "HelpFile":  	case "Name":  	case "HelpContextID":  	case "Description":  	case "VersionCompatible32":  		break;  	//393222000"  	case "CMG":  		byte[] cmg = Decrypt (split [1]);  		_protection.UserProtected = (cmg [0] & 1) != 0;  		_protection.HostProtected = (cmg [0] & 2) != 0;  		_protection.VbeProtected = (cmg [0] & 4) != 0;  		break;  	case "DPB":  		byte[] dpb = Decrypt (split [1]);  		if (dpb.Length >= 28) {  			byte reserved = dpb [0];  			var flags = new byte[3];  			Array.Copy (dpb' 1' flags' 0' 3);  			var keyNoNulls = new byte[4];  			_protection.PasswordKey = new byte[4];  			Array.Copy (dpb' 4' keyNoNulls' 0' 4);  			var hashNoNulls = new byte[20];  			_protection.PasswordHash = new byte[20];  			Array.Copy (dpb' 8' hashNoNulls' 0' 20);  			//Handle 0x00 bitwise 2.4.4.3   			for (int i = 0; i < 24; i++) {  				int bit = 128 >> (int)((i % 8));  				if (i < 4) {  					if ((int)(flags [0] & bit) == 0) {  						_protection.PasswordKey [i] = 0;  					}  					else {  						_protection.PasswordKey [i] = keyNoNulls [i];  					}  				}  				else {  					int flagIndex = (i - i % 8) / 8;  					if ((int)(flags [flagIndex] & bit) == 0) {  						_protection.PasswordHash [i - 4] = 0;  					}  					else {  						_protection.PasswordHash [i - 4] = hashNoNulls [i - 4];  					}  				}  			}  		}  		break;  	case "GC":  		_protection.VisibilityState = Decrypt (split [1]) [0] == 0xFF;  		break;  	}  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadProjectProperties,The following statement contains a magic number: if (line.StartsWith ("[")) {  }  else {  	var split = line.Split ('=');  	if (split.Length > 1 && split [1].Length > 1 && split [1].StartsWith ("\""))//Remove any double qouates  	 {  		split [1] = split [1].Substring (1' split [1].Length - 2);  	}  	switch (split [0]) {  	case "ID":  		ProjectID = split [1];  		break;  	case "Document":  		string mn = split [1].Substring (0' split [1].IndexOf ("/&H"));  		Modules [mn].Type = eModuleType.Document;  		break;  	case "Package":  		prevPackage = split [1];  		break;  	case "BaseClass":  		Modules [split [1]].Type = eModuleType.Designer;  		Modules [split [1]].ClassID = prevPackage;  		break;  	case "Module":  		Modules [split [1]].Type = eModuleType.Module;  		break;  	case "Class":  		Modules [split [1]].Type = eModuleType.Class;  		break;  	case "HelpFile":  	case "Name":  	case "HelpContextID":  	case "Description":  	case "VersionCompatible32":  		break;  	//393222000"  	case "CMG":  		byte[] cmg = Decrypt (split [1]);  		_protection.UserProtected = (cmg [0] & 1) != 0;  		_protection.HostProtected = (cmg [0] & 2) != 0;  		_protection.VbeProtected = (cmg [0] & 4) != 0;  		break;  	case "DPB":  		byte[] dpb = Decrypt (split [1]);  		if (dpb.Length >= 28) {  			byte reserved = dpb [0];  			var flags = new byte[3];  			Array.Copy (dpb' 1' flags' 0' 3);  			var keyNoNulls = new byte[4];  			_protection.PasswordKey = new byte[4];  			Array.Copy (dpb' 4' keyNoNulls' 0' 4);  			var hashNoNulls = new byte[20];  			_protection.PasswordHash = new byte[20];  			Array.Copy (dpb' 8' hashNoNulls' 0' 20);  			//Handle 0x00 bitwise 2.4.4.3   			for (int i = 0; i < 24; i++) {  				int bit = 128 >> (int)((i % 8));  				if (i < 4) {  					if ((int)(flags [0] & bit) == 0) {  						_protection.PasswordKey [i] = 0;  					}  					else {  						_protection.PasswordKey [i] = keyNoNulls [i];  					}  				}  				else {  					int flagIndex = (i - i % 8) / 8;  					if ((int)(flags [flagIndex] & bit) == 0) {  						_protection.PasswordHash [i - 4] = 0;  					}  					else {  						_protection.PasswordHash [i - 4] = hashNoNulls [i - 4];  					}  				}  			}  		}  		break;  	case "GC":  		_protection.VisibilityState = Decrypt (split [1]) [0] == 0xFF;  		break;  	}  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadProjectProperties,The following statement contains a magic number: if (line.StartsWith ("[")) {  }  else {  	var split = line.Split ('=');  	if (split.Length > 1 && split [1].Length > 1 && split [1].StartsWith ("\""))//Remove any double qouates  	 {  		split [1] = split [1].Substring (1' split [1].Length - 2);  	}  	switch (split [0]) {  	case "ID":  		ProjectID = split [1];  		break;  	case "Document":  		string mn = split [1].Substring (0' split [1].IndexOf ("/&H"));  		Modules [mn].Type = eModuleType.Document;  		break;  	case "Package":  		prevPackage = split [1];  		break;  	case "BaseClass":  		Modules [split [1]].Type = eModuleType.Designer;  		Modules [split [1]].ClassID = prevPackage;  		break;  	case "Module":  		Modules [split [1]].Type = eModuleType.Module;  		break;  	case "Class":  		Modules [split [1]].Type = eModuleType.Class;  		break;  	case "HelpFile":  	case "Name":  	case "HelpContextID":  	case "Description":  	case "VersionCompatible32":  		break;  	//393222000"  	case "CMG":  		byte[] cmg = Decrypt (split [1]);  		_protection.UserProtected = (cmg [0] & 1) != 0;  		_protection.HostProtected = (cmg [0] & 2) != 0;  		_protection.VbeProtected = (cmg [0] & 4) != 0;  		break;  	case "DPB":  		byte[] dpb = Decrypt (split [1]);  		if (dpb.Length >= 28) {  			byte reserved = dpb [0];  			var flags = new byte[3];  			Array.Copy (dpb' 1' flags' 0' 3);  			var keyNoNulls = new byte[4];  			_protection.PasswordKey = new byte[4];  			Array.Copy (dpb' 4' keyNoNulls' 0' 4);  			var hashNoNulls = new byte[20];  			_protection.PasswordHash = new byte[20];  			Array.Copy (dpb' 8' hashNoNulls' 0' 20);  			//Handle 0x00 bitwise 2.4.4.3   			for (int i = 0; i < 24; i++) {  				int bit = 128 >> (int)((i % 8));  				if (i < 4) {  					if ((int)(flags [0] & bit) == 0) {  						_protection.PasswordKey [i] = 0;  					}  					else {  						_protection.PasswordKey [i] = keyNoNulls [i];  					}  				}  				else {  					int flagIndex = (i - i % 8) / 8;  					if ((int)(flags [flagIndex] & bit) == 0) {  						_protection.PasswordHash [i - 4] = 0;  					}  					else {  						_protection.PasswordHash [i - 4] = hashNoNulls [i - 4];  					}  				}  			}  		}  		break;  	case "GC":  		_protection.VisibilityState = Decrypt (split [1]) [0] == 0xFF;  		break;  	}  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadProjectProperties,The following statement contains a magic number: if (line.StartsWith ("[")) {  }  else {  	var split = line.Split ('=');  	if (split.Length > 1 && split [1].Length > 1 && split [1].StartsWith ("\""))//Remove any double qouates  	 {  		split [1] = split [1].Substring (1' split [1].Length - 2);  	}  	switch (split [0]) {  	case "ID":  		ProjectID = split [1];  		break;  	case "Document":  		string mn = split [1].Substring (0' split [1].IndexOf ("/&H"));  		Modules [mn].Type = eModuleType.Document;  		break;  	case "Package":  		prevPackage = split [1];  		break;  	case "BaseClass":  		Modules [split [1]].Type = eModuleType.Designer;  		Modules [split [1]].ClassID = prevPackage;  		break;  	case "Module":  		Modules [split [1]].Type = eModuleType.Module;  		break;  	case "Class":  		Modules [split [1]].Type = eModuleType.Class;  		break;  	case "HelpFile":  	case "Name":  	case "HelpContextID":  	case "Description":  	case "VersionCompatible32":  		break;  	//393222000"  	case "CMG":  		byte[] cmg = Decrypt (split [1]);  		_protection.UserProtected = (cmg [0] & 1) != 0;  		_protection.HostProtected = (cmg [0] & 2) != 0;  		_protection.VbeProtected = (cmg [0] & 4) != 0;  		break;  	case "DPB":  		byte[] dpb = Decrypt (split [1]);  		if (dpb.Length >= 28) {  			byte reserved = dpb [0];  			var flags = new byte[3];  			Array.Copy (dpb' 1' flags' 0' 3);  			var keyNoNulls = new byte[4];  			_protection.PasswordKey = new byte[4];  			Array.Copy (dpb' 4' keyNoNulls' 0' 4);  			var hashNoNulls = new byte[20];  			_protection.PasswordHash = new byte[20];  			Array.Copy (dpb' 8' hashNoNulls' 0' 20);  			//Handle 0x00 bitwise 2.4.4.3   			for (int i = 0; i < 24; i++) {  				int bit = 128 >> (int)((i % 8));  				if (i < 4) {  					if ((int)(flags [0] & bit) == 0) {  						_protection.PasswordKey [i] = 0;  					}  					else {  						_protection.PasswordKey [i] = keyNoNulls [i];  					}  				}  				else {  					int flagIndex = (i - i % 8) / 8;  					if ((int)(flags [flagIndex] & bit) == 0) {  						_protection.PasswordHash [i - 4] = 0;  					}  					else {  						_protection.PasswordHash [i - 4] = hashNoNulls [i - 4];  					}  				}  			}  		}  		break;  	case "GC":  		_protection.VisibilityState = Decrypt (split [1]) [0] == 0xFF;  		break;  	}  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadProjectProperties,The following statement contains a magic number: if (line.StartsWith ("[")) {  }  else {  	var split = line.Split ('=');  	if (split.Length > 1 && split [1].Length > 1 && split [1].StartsWith ("\""))//Remove any double qouates  	 {  		split [1] = split [1].Substring (1' split [1].Length - 2);  	}  	switch (split [0]) {  	case "ID":  		ProjectID = split [1];  		break;  	case "Document":  		string mn = split [1].Substring (0' split [1].IndexOf ("/&H"));  		Modules [mn].Type = eModuleType.Document;  		break;  	case "Package":  		prevPackage = split [1];  		break;  	case "BaseClass":  		Modules [split [1]].Type = eModuleType.Designer;  		Modules [split [1]].ClassID = prevPackage;  		break;  	case "Module":  		Modules [split [1]].Type = eModuleType.Module;  		break;  	case "Class":  		Modules [split [1]].Type = eModuleType.Class;  		break;  	case "HelpFile":  	case "Name":  	case "HelpContextID":  	case "Description":  	case "VersionCompatible32":  		break;  	//393222000"  	case "CMG":  		byte[] cmg = Decrypt (split [1]);  		_protection.UserProtected = (cmg [0] & 1) != 0;  		_protection.HostProtected = (cmg [0] & 2) != 0;  		_protection.VbeProtected = (cmg [0] & 4) != 0;  		break;  	case "DPB":  		byte[] dpb = Decrypt (split [1]);  		if (dpb.Length >= 28) {  			byte reserved = dpb [0];  			var flags = new byte[3];  			Array.Copy (dpb' 1' flags' 0' 3);  			var keyNoNulls = new byte[4];  			_protection.PasswordKey = new byte[4];  			Array.Copy (dpb' 4' keyNoNulls' 0' 4);  			var hashNoNulls = new byte[20];  			_protection.PasswordHash = new byte[20];  			Array.Copy (dpb' 8' hashNoNulls' 0' 20);  			//Handle 0x00 bitwise 2.4.4.3   			for (int i = 0; i < 24; i++) {  				int bit = 128 >> (int)((i % 8));  				if (i < 4) {  					if ((int)(flags [0] & bit) == 0) {  						_protection.PasswordKey [i] = 0;  					}  					else {  						_protection.PasswordKey [i] = keyNoNulls [i];  					}  				}  				else {  					int flagIndex = (i - i % 8) / 8;  					if ((int)(flags [flagIndex] & bit) == 0) {  						_protection.PasswordHash [i - 4] = 0;  					}  					else {  						_protection.PasswordHash [i - 4] = hashNoNulls [i - 4];  					}  				}  			}  		}  		break;  	case "GC":  		_protection.VisibilityState = Decrypt (split [1]) [0] == 0xFF;  		break;  	}  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadProjectProperties,The following statement contains a magic number: if (line.StartsWith ("[")) {  }  else {  	var split = line.Split ('=');  	if (split.Length > 1 && split [1].Length > 1 && split [1].StartsWith ("\""))//Remove any double qouates  	 {  		split [1] = split [1].Substring (1' split [1].Length - 2);  	}  	switch (split [0]) {  	case "ID":  		ProjectID = split [1];  		break;  	case "Document":  		string mn = split [1].Substring (0' split [1].IndexOf ("/&H"));  		Modules [mn].Type = eModuleType.Document;  		break;  	case "Package":  		prevPackage = split [1];  		break;  	case "BaseClass":  		Modules [split [1]].Type = eModuleType.Designer;  		Modules [split [1]].ClassID = prevPackage;  		break;  	case "Module":  		Modules [split [1]].Type = eModuleType.Module;  		break;  	case "Class":  		Modules [split [1]].Type = eModuleType.Class;  		break;  	case "HelpFile":  	case "Name":  	case "HelpContextID":  	case "Description":  	case "VersionCompatible32":  		break;  	//393222000"  	case "CMG":  		byte[] cmg = Decrypt (split [1]);  		_protection.UserProtected = (cmg [0] & 1) != 0;  		_protection.HostProtected = (cmg [0] & 2) != 0;  		_protection.VbeProtected = (cmg [0] & 4) != 0;  		break;  	case "DPB":  		byte[] dpb = Decrypt (split [1]);  		if (dpb.Length >= 28) {  			byte reserved = dpb [0];  			var flags = new byte[3];  			Array.Copy (dpb' 1' flags' 0' 3);  			var keyNoNulls = new byte[4];  			_protection.PasswordKey = new byte[4];  			Array.Copy (dpb' 4' keyNoNulls' 0' 4);  			var hashNoNulls = new byte[20];  			_protection.PasswordHash = new byte[20];  			Array.Copy (dpb' 8' hashNoNulls' 0' 20);  			//Handle 0x00 bitwise 2.4.4.3   			for (int i = 0; i < 24; i++) {  				int bit = 128 >> (int)((i % 8));  				if (i < 4) {  					if ((int)(flags [0] & bit) == 0) {  						_protection.PasswordKey [i] = 0;  					}  					else {  						_protection.PasswordKey [i] = keyNoNulls [i];  					}  				}  				else {  					int flagIndex = (i - i % 8) / 8;  					if ((int)(flags [flagIndex] & bit) == 0) {  						_protection.PasswordHash [i - 4] = 0;  					}  					else {  						_protection.PasswordHash [i - 4] = hashNoNulls [i - 4];  					}  				}  			}  		}  		break;  	case "GC":  		_protection.VisibilityState = Decrypt (split [1]) [0] == 0xFF;  		break;  	}  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadProjectProperties,The following statement contains a magic number: if (line.StartsWith ("[")) {  }  else {  	var split = line.Split ('=');  	if (split.Length > 1 && split [1].Length > 1 && split [1].StartsWith ("\""))//Remove any double qouates  	 {  		split [1] = split [1].Substring (1' split [1].Length - 2);  	}  	switch (split [0]) {  	case "ID":  		ProjectID = split [1];  		break;  	case "Document":  		string mn = split [1].Substring (0' split [1].IndexOf ("/&H"));  		Modules [mn].Type = eModuleType.Document;  		break;  	case "Package":  		prevPackage = split [1];  		break;  	case "BaseClass":  		Modules [split [1]].Type = eModuleType.Designer;  		Modules [split [1]].ClassID = prevPackage;  		break;  	case "Module":  		Modules [split [1]].Type = eModuleType.Module;  		break;  	case "Class":  		Modules [split [1]].Type = eModuleType.Class;  		break;  	case "HelpFile":  	case "Name":  	case "HelpContextID":  	case "Description":  	case "VersionCompatible32":  		break;  	//393222000"  	case "CMG":  		byte[] cmg = Decrypt (split [1]);  		_protection.UserProtected = (cmg [0] & 1) != 0;  		_protection.HostProtected = (cmg [0] & 2) != 0;  		_protection.VbeProtected = (cmg [0] & 4) != 0;  		break;  	case "DPB":  		byte[] dpb = Decrypt (split [1]);  		if (dpb.Length >= 28) {  			byte reserved = dpb [0];  			var flags = new byte[3];  			Array.Copy (dpb' 1' flags' 0' 3);  			var keyNoNulls = new byte[4];  			_protection.PasswordKey = new byte[4];  			Array.Copy (dpb' 4' keyNoNulls' 0' 4);  			var hashNoNulls = new byte[20];  			_protection.PasswordHash = new byte[20];  			Array.Copy (dpb' 8' hashNoNulls' 0' 20);  			//Handle 0x00 bitwise 2.4.4.3   			for (int i = 0; i < 24; i++) {  				int bit = 128 >> (int)((i % 8));  				if (i < 4) {  					if ((int)(flags [0] & bit) == 0) {  						_protection.PasswordKey [i] = 0;  					}  					else {  						_protection.PasswordKey [i] = keyNoNulls [i];  					}  				}  				else {  					int flagIndex = (i - i % 8) / 8;  					if ((int)(flags [flagIndex] & bit) == 0) {  						_protection.PasswordHash [i - 4] = 0;  					}  					else {  						_protection.PasswordHash [i - 4] = hashNoNulls [i - 4];  					}  				}  			}  		}  		break;  	case "GC":  		_protection.VisibilityState = Decrypt (split [1]) [0] == 0xFF;  		break;  	}  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadProjectProperties,The following statement contains a magic number: if (split.Length > 1 && split [1].Length > 1 && split [1].StartsWith ("\""))//Remove any double qouates   {  	split [1] = split [1].Substring (1' split [1].Length - 2);  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadProjectProperties,The following statement contains a magic number: split [1] = split [1].Substring (1' split [1].Length - 2);  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadProjectProperties,The following statement contains a magic number: switch (split [0]) {  case "ID":  	ProjectID = split [1];  	break;  case "Document":  	string mn = split [1].Substring (0' split [1].IndexOf ("/&H"));  	Modules [mn].Type = eModuleType.Document;  	break;  case "Package":  	prevPackage = split [1];  	break;  case "BaseClass":  	Modules [split [1]].Type = eModuleType.Designer;  	Modules [split [1]].ClassID = prevPackage;  	break;  case "Module":  	Modules [split [1]].Type = eModuleType.Module;  	break;  case "Class":  	Modules [split [1]].Type = eModuleType.Class;  	break;  case "HelpFile":  case "Name":  case "HelpContextID":  case "Description":  case "VersionCompatible32":  	break;  //393222000"  case "CMG":  	byte[] cmg = Decrypt (split [1]);  	_protection.UserProtected = (cmg [0] & 1) != 0;  	_protection.HostProtected = (cmg [0] & 2) != 0;  	_protection.VbeProtected = (cmg [0] & 4) != 0;  	break;  case "DPB":  	byte[] dpb = Decrypt (split [1]);  	if (dpb.Length >= 28) {  		byte reserved = dpb [0];  		var flags = new byte[3];  		Array.Copy (dpb' 1' flags' 0' 3);  		var keyNoNulls = new byte[4];  		_protection.PasswordKey = new byte[4];  		Array.Copy (dpb' 4' keyNoNulls' 0' 4);  		var hashNoNulls = new byte[20];  		_protection.PasswordHash = new byte[20];  		Array.Copy (dpb' 8' hashNoNulls' 0' 20);  		//Handle 0x00 bitwise 2.4.4.3   		for (int i = 0; i < 24; i++) {  			int bit = 128 >> (int)((i % 8));  			if (i < 4) {  				if ((int)(flags [0] & bit) == 0) {  					_protection.PasswordKey [i] = 0;  				}  				else {  					_protection.PasswordKey [i] = keyNoNulls [i];  				}  			}  			else {  				int flagIndex = (i - i % 8) / 8;  				if ((int)(flags [flagIndex] & bit) == 0) {  					_protection.PasswordHash [i - 4] = 0;  				}  				else {  					_protection.PasswordHash [i - 4] = hashNoNulls [i - 4];  				}  			}  		}  	}  	break;  case "GC":  	_protection.VisibilityState = Decrypt (split [1]) [0] == 0xFF;  	break;  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadProjectProperties,The following statement contains a magic number: switch (split [0]) {  case "ID":  	ProjectID = split [1];  	break;  case "Document":  	string mn = split [1].Substring (0' split [1].IndexOf ("/&H"));  	Modules [mn].Type = eModuleType.Document;  	break;  case "Package":  	prevPackage = split [1];  	break;  case "BaseClass":  	Modules [split [1]].Type = eModuleType.Designer;  	Modules [split [1]].ClassID = prevPackage;  	break;  case "Module":  	Modules [split [1]].Type = eModuleType.Module;  	break;  case "Class":  	Modules [split [1]].Type = eModuleType.Class;  	break;  case "HelpFile":  case "Name":  case "HelpContextID":  case "Description":  case "VersionCompatible32":  	break;  //393222000"  case "CMG":  	byte[] cmg = Decrypt (split [1]);  	_protection.UserProtected = (cmg [0] & 1) != 0;  	_protection.HostProtected = (cmg [0] & 2) != 0;  	_protection.VbeProtected = (cmg [0] & 4) != 0;  	break;  case "DPB":  	byte[] dpb = Decrypt (split [1]);  	if (dpb.Length >= 28) {  		byte reserved = dpb [0];  		var flags = new byte[3];  		Array.Copy (dpb' 1' flags' 0' 3);  		var keyNoNulls = new byte[4];  		_protection.PasswordKey = new byte[4];  		Array.Copy (dpb' 4' keyNoNulls' 0' 4);  		var hashNoNulls = new byte[20];  		_protection.PasswordHash = new byte[20];  		Array.Copy (dpb' 8' hashNoNulls' 0' 20);  		//Handle 0x00 bitwise 2.4.4.3   		for (int i = 0; i < 24; i++) {  			int bit = 128 >> (int)((i % 8));  			if (i < 4) {  				if ((int)(flags [0] & bit) == 0) {  					_protection.PasswordKey [i] = 0;  				}  				else {  					_protection.PasswordKey [i] = keyNoNulls [i];  				}  			}  			else {  				int flagIndex = (i - i % 8) / 8;  				if ((int)(flags [flagIndex] & bit) == 0) {  					_protection.PasswordHash [i - 4] = 0;  				}  				else {  					_protection.PasswordHash [i - 4] = hashNoNulls [i - 4];  				}  			}  		}  	}  	break;  case "GC":  	_protection.VisibilityState = Decrypt (split [1]) [0] == 0xFF;  	break;  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadProjectProperties,The following statement contains a magic number: switch (split [0]) {  case "ID":  	ProjectID = split [1];  	break;  case "Document":  	string mn = split [1].Substring (0' split [1].IndexOf ("/&H"));  	Modules [mn].Type = eModuleType.Document;  	break;  case "Package":  	prevPackage = split [1];  	break;  case "BaseClass":  	Modules [split [1]].Type = eModuleType.Designer;  	Modules [split [1]].ClassID = prevPackage;  	break;  case "Module":  	Modules [split [1]].Type = eModuleType.Module;  	break;  case "Class":  	Modules [split [1]].Type = eModuleType.Class;  	break;  case "HelpFile":  case "Name":  case "HelpContextID":  case "Description":  case "VersionCompatible32":  	break;  //393222000"  case "CMG":  	byte[] cmg = Decrypt (split [1]);  	_protection.UserProtected = (cmg [0] & 1) != 0;  	_protection.HostProtected = (cmg [0] & 2) != 0;  	_protection.VbeProtected = (cmg [0] & 4) != 0;  	break;  case "DPB":  	byte[] dpb = Decrypt (split [1]);  	if (dpb.Length >= 28) {  		byte reserved = dpb [0];  		var flags = new byte[3];  		Array.Copy (dpb' 1' flags' 0' 3);  		var keyNoNulls = new byte[4];  		_protection.PasswordKey = new byte[4];  		Array.Copy (dpb' 4' keyNoNulls' 0' 4);  		var hashNoNulls = new byte[20];  		_protection.PasswordHash = new byte[20];  		Array.Copy (dpb' 8' hashNoNulls' 0' 20);  		//Handle 0x00 bitwise 2.4.4.3   		for (int i = 0; i < 24; i++) {  			int bit = 128 >> (int)((i % 8));  			if (i < 4) {  				if ((int)(flags [0] & bit) == 0) {  					_protection.PasswordKey [i] = 0;  				}  				else {  					_protection.PasswordKey [i] = keyNoNulls [i];  				}  			}  			else {  				int flagIndex = (i - i % 8) / 8;  				if ((int)(flags [flagIndex] & bit) == 0) {  					_protection.PasswordHash [i - 4] = 0;  				}  				else {  					_protection.PasswordHash [i - 4] = hashNoNulls [i - 4];  				}  			}  		}  	}  	break;  case "GC":  	_protection.VisibilityState = Decrypt (split [1]) [0] == 0xFF;  	break;  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadProjectProperties,The following statement contains a magic number: switch (split [0]) {  case "ID":  	ProjectID = split [1];  	break;  case "Document":  	string mn = split [1].Substring (0' split [1].IndexOf ("/&H"));  	Modules [mn].Type = eModuleType.Document;  	break;  case "Package":  	prevPackage = split [1];  	break;  case "BaseClass":  	Modules [split [1]].Type = eModuleType.Designer;  	Modules [split [1]].ClassID = prevPackage;  	break;  case "Module":  	Modules [split [1]].Type = eModuleType.Module;  	break;  case "Class":  	Modules [split [1]].Type = eModuleType.Class;  	break;  case "HelpFile":  case "Name":  case "HelpContextID":  case "Description":  case "VersionCompatible32":  	break;  //393222000"  case "CMG":  	byte[] cmg = Decrypt (split [1]);  	_protection.UserProtected = (cmg [0] & 1) != 0;  	_protection.HostProtected = (cmg [0] & 2) != 0;  	_protection.VbeProtected = (cmg [0] & 4) != 0;  	break;  case "DPB":  	byte[] dpb = Decrypt (split [1]);  	if (dpb.Length >= 28) {  		byte reserved = dpb [0];  		var flags = new byte[3];  		Array.Copy (dpb' 1' flags' 0' 3);  		var keyNoNulls = new byte[4];  		_protection.PasswordKey = new byte[4];  		Array.Copy (dpb' 4' keyNoNulls' 0' 4);  		var hashNoNulls = new byte[20];  		_protection.PasswordHash = new byte[20];  		Array.Copy (dpb' 8' hashNoNulls' 0' 20);  		//Handle 0x00 bitwise 2.4.4.3   		for (int i = 0; i < 24; i++) {  			int bit = 128 >> (int)((i % 8));  			if (i < 4) {  				if ((int)(flags [0] & bit) == 0) {  					_protection.PasswordKey [i] = 0;  				}  				else {  					_protection.PasswordKey [i] = keyNoNulls [i];  				}  			}  			else {  				int flagIndex = (i - i % 8) / 8;  				if ((int)(flags [flagIndex] & bit) == 0) {  					_protection.PasswordHash [i - 4] = 0;  				}  				else {  					_protection.PasswordHash [i - 4] = hashNoNulls [i - 4];  				}  			}  		}  	}  	break;  case "GC":  	_protection.VisibilityState = Decrypt (split [1]) [0] == 0xFF;  	break;  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadProjectProperties,The following statement contains a magic number: switch (split [0]) {  case "ID":  	ProjectID = split [1];  	break;  case "Document":  	string mn = split [1].Substring (0' split [1].IndexOf ("/&H"));  	Modules [mn].Type = eModuleType.Document;  	break;  case "Package":  	prevPackage = split [1];  	break;  case "BaseClass":  	Modules [split [1]].Type = eModuleType.Designer;  	Modules [split [1]].ClassID = prevPackage;  	break;  case "Module":  	Modules [split [1]].Type = eModuleType.Module;  	break;  case "Class":  	Modules [split [1]].Type = eModuleType.Class;  	break;  case "HelpFile":  case "Name":  case "HelpContextID":  case "Description":  case "VersionCompatible32":  	break;  //393222000"  case "CMG":  	byte[] cmg = Decrypt (split [1]);  	_protection.UserProtected = (cmg [0] & 1) != 0;  	_protection.HostProtected = (cmg [0] & 2) != 0;  	_protection.VbeProtected = (cmg [0] & 4) != 0;  	break;  case "DPB":  	byte[] dpb = Decrypt (split [1]);  	if (dpb.Length >= 28) {  		byte reserved = dpb [0];  		var flags = new byte[3];  		Array.Copy (dpb' 1' flags' 0' 3);  		var keyNoNulls = new byte[4];  		_protection.PasswordKey = new byte[4];  		Array.Copy (dpb' 4' keyNoNulls' 0' 4);  		var hashNoNulls = new byte[20];  		_protection.PasswordHash = new byte[20];  		Array.Copy (dpb' 8' hashNoNulls' 0' 20);  		//Handle 0x00 bitwise 2.4.4.3   		for (int i = 0; i < 24; i++) {  			int bit = 128 >> (int)((i % 8));  			if (i < 4) {  				if ((int)(flags [0] & bit) == 0) {  					_protection.PasswordKey [i] = 0;  				}  				else {  					_protection.PasswordKey [i] = keyNoNulls [i];  				}  			}  			else {  				int flagIndex = (i - i % 8) / 8;  				if ((int)(flags [flagIndex] & bit) == 0) {  					_protection.PasswordHash [i - 4] = 0;  				}  				else {  					_protection.PasswordHash [i - 4] = hashNoNulls [i - 4];  				}  			}  		}  	}  	break;  case "GC":  	_protection.VisibilityState = Decrypt (split [1]) [0] == 0xFF;  	break;  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadProjectProperties,The following statement contains a magic number: switch (split [0]) {  case "ID":  	ProjectID = split [1];  	break;  case "Document":  	string mn = split [1].Substring (0' split [1].IndexOf ("/&H"));  	Modules [mn].Type = eModuleType.Document;  	break;  case "Package":  	prevPackage = split [1];  	break;  case "BaseClass":  	Modules [split [1]].Type = eModuleType.Designer;  	Modules [split [1]].ClassID = prevPackage;  	break;  case "Module":  	Modules [split [1]].Type = eModuleType.Module;  	break;  case "Class":  	Modules [split [1]].Type = eModuleType.Class;  	break;  case "HelpFile":  case "Name":  case "HelpContextID":  case "Description":  case "VersionCompatible32":  	break;  //393222000"  case "CMG":  	byte[] cmg = Decrypt (split [1]);  	_protection.UserProtected = (cmg [0] & 1) != 0;  	_protection.HostProtected = (cmg [0] & 2) != 0;  	_protection.VbeProtected = (cmg [0] & 4) != 0;  	break;  case "DPB":  	byte[] dpb = Decrypt (split [1]);  	if (dpb.Length >= 28) {  		byte reserved = dpb [0];  		var flags = new byte[3];  		Array.Copy (dpb' 1' flags' 0' 3);  		var keyNoNulls = new byte[4];  		_protection.PasswordKey = new byte[4];  		Array.Copy (dpb' 4' keyNoNulls' 0' 4);  		var hashNoNulls = new byte[20];  		_protection.PasswordHash = new byte[20];  		Array.Copy (dpb' 8' hashNoNulls' 0' 20);  		//Handle 0x00 bitwise 2.4.4.3   		for (int i = 0; i < 24; i++) {  			int bit = 128 >> (int)((i % 8));  			if (i < 4) {  				if ((int)(flags [0] & bit) == 0) {  					_protection.PasswordKey [i] = 0;  				}  				else {  					_protection.PasswordKey [i] = keyNoNulls [i];  				}  			}  			else {  				int flagIndex = (i - i % 8) / 8;  				if ((int)(flags [flagIndex] & bit) == 0) {  					_protection.PasswordHash [i - 4] = 0;  				}  				else {  					_protection.PasswordHash [i - 4] = hashNoNulls [i - 4];  				}  			}  		}  	}  	break;  case "GC":  	_protection.VisibilityState = Decrypt (split [1]) [0] == 0xFF;  	break;  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadProjectProperties,The following statement contains a magic number: switch (split [0]) {  case "ID":  	ProjectID = split [1];  	break;  case "Document":  	string mn = split [1].Substring (0' split [1].IndexOf ("/&H"));  	Modules [mn].Type = eModuleType.Document;  	break;  case "Package":  	prevPackage = split [1];  	break;  case "BaseClass":  	Modules [split [1]].Type = eModuleType.Designer;  	Modules [split [1]].ClassID = prevPackage;  	break;  case "Module":  	Modules [split [1]].Type = eModuleType.Module;  	break;  case "Class":  	Modules [split [1]].Type = eModuleType.Class;  	break;  case "HelpFile":  case "Name":  case "HelpContextID":  case "Description":  case "VersionCompatible32":  	break;  //393222000"  case "CMG":  	byte[] cmg = Decrypt (split [1]);  	_protection.UserProtected = (cmg [0] & 1) != 0;  	_protection.HostProtected = (cmg [0] & 2) != 0;  	_protection.VbeProtected = (cmg [0] & 4) != 0;  	break;  case "DPB":  	byte[] dpb = Decrypt (split [1]);  	if (dpb.Length >= 28) {  		byte reserved = dpb [0];  		var flags = new byte[3];  		Array.Copy (dpb' 1' flags' 0' 3);  		var keyNoNulls = new byte[4];  		_protection.PasswordKey = new byte[4];  		Array.Copy (dpb' 4' keyNoNulls' 0' 4);  		var hashNoNulls = new byte[20];  		_protection.PasswordHash = new byte[20];  		Array.Copy (dpb' 8' hashNoNulls' 0' 20);  		//Handle 0x00 bitwise 2.4.4.3   		for (int i = 0; i < 24; i++) {  			int bit = 128 >> (int)((i % 8));  			if (i < 4) {  				if ((int)(flags [0] & bit) == 0) {  					_protection.PasswordKey [i] = 0;  				}  				else {  					_protection.PasswordKey [i] = keyNoNulls [i];  				}  			}  			else {  				int flagIndex = (i - i % 8) / 8;  				if ((int)(flags [flagIndex] & bit) == 0) {  					_protection.PasswordHash [i - 4] = 0;  				}  				else {  					_protection.PasswordHash [i - 4] = hashNoNulls [i - 4];  				}  			}  		}  	}  	break;  case "GC":  	_protection.VisibilityState = Decrypt (split [1]) [0] == 0xFF;  	break;  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadProjectProperties,The following statement contains a magic number: switch (split [0]) {  case "ID":  	ProjectID = split [1];  	break;  case "Document":  	string mn = split [1].Substring (0' split [1].IndexOf ("/&H"));  	Modules [mn].Type = eModuleType.Document;  	break;  case "Package":  	prevPackage = split [1];  	break;  case "BaseClass":  	Modules [split [1]].Type = eModuleType.Designer;  	Modules [split [1]].ClassID = prevPackage;  	break;  case "Module":  	Modules [split [1]].Type = eModuleType.Module;  	break;  case "Class":  	Modules [split [1]].Type = eModuleType.Class;  	break;  case "HelpFile":  case "Name":  case "HelpContextID":  case "Description":  case "VersionCompatible32":  	break;  //393222000"  case "CMG":  	byte[] cmg = Decrypt (split [1]);  	_protection.UserProtected = (cmg [0] & 1) != 0;  	_protection.HostProtected = (cmg [0] & 2) != 0;  	_protection.VbeProtected = (cmg [0] & 4) != 0;  	break;  case "DPB":  	byte[] dpb = Decrypt (split [1]);  	if (dpb.Length >= 28) {  		byte reserved = dpb [0];  		var flags = new byte[3];  		Array.Copy (dpb' 1' flags' 0' 3);  		var keyNoNulls = new byte[4];  		_protection.PasswordKey = new byte[4];  		Array.Copy (dpb' 4' keyNoNulls' 0' 4);  		var hashNoNulls = new byte[20];  		_protection.PasswordHash = new byte[20];  		Array.Copy (dpb' 8' hashNoNulls' 0' 20);  		//Handle 0x00 bitwise 2.4.4.3   		for (int i = 0; i < 24; i++) {  			int bit = 128 >> (int)((i % 8));  			if (i < 4) {  				if ((int)(flags [0] & bit) == 0) {  					_protection.PasswordKey [i] = 0;  				}  				else {  					_protection.PasswordKey [i] = keyNoNulls [i];  				}  			}  			else {  				int flagIndex = (i - i % 8) / 8;  				if ((int)(flags [flagIndex] & bit) == 0) {  					_protection.PasswordHash [i - 4] = 0;  				}  				else {  					_protection.PasswordHash [i - 4] = hashNoNulls [i - 4];  				}  			}  		}  	}  	break;  case "GC":  	_protection.VisibilityState = Decrypt (split [1]) [0] == 0xFF;  	break;  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadProjectProperties,The following statement contains a magic number: switch (split [0]) {  case "ID":  	ProjectID = split [1];  	break;  case "Document":  	string mn = split [1].Substring (0' split [1].IndexOf ("/&H"));  	Modules [mn].Type = eModuleType.Document;  	break;  case "Package":  	prevPackage = split [1];  	break;  case "BaseClass":  	Modules [split [1]].Type = eModuleType.Designer;  	Modules [split [1]].ClassID = prevPackage;  	break;  case "Module":  	Modules [split [1]].Type = eModuleType.Module;  	break;  case "Class":  	Modules [split [1]].Type = eModuleType.Class;  	break;  case "HelpFile":  case "Name":  case "HelpContextID":  case "Description":  case "VersionCompatible32":  	break;  //393222000"  case "CMG":  	byte[] cmg = Decrypt (split [1]);  	_protection.UserProtected = (cmg [0] & 1) != 0;  	_protection.HostProtected = (cmg [0] & 2) != 0;  	_protection.VbeProtected = (cmg [0] & 4) != 0;  	break;  case "DPB":  	byte[] dpb = Decrypt (split [1]);  	if (dpb.Length >= 28) {  		byte reserved = dpb [0];  		var flags = new byte[3];  		Array.Copy (dpb' 1' flags' 0' 3);  		var keyNoNulls = new byte[4];  		_protection.PasswordKey = new byte[4];  		Array.Copy (dpb' 4' keyNoNulls' 0' 4);  		var hashNoNulls = new byte[20];  		_protection.PasswordHash = new byte[20];  		Array.Copy (dpb' 8' hashNoNulls' 0' 20);  		//Handle 0x00 bitwise 2.4.4.3   		for (int i = 0; i < 24; i++) {  			int bit = 128 >> (int)((i % 8));  			if (i < 4) {  				if ((int)(flags [0] & bit) == 0) {  					_protection.PasswordKey [i] = 0;  				}  				else {  					_protection.PasswordKey [i] = keyNoNulls [i];  				}  			}  			else {  				int flagIndex = (i - i % 8) / 8;  				if ((int)(flags [flagIndex] & bit) == 0) {  					_protection.PasswordHash [i - 4] = 0;  				}  				else {  					_protection.PasswordHash [i - 4] = hashNoNulls [i - 4];  				}  			}  		}  	}  	break;  case "GC":  	_protection.VisibilityState = Decrypt (split [1]) [0] == 0xFF;  	break;  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadProjectProperties,The following statement contains a magic number: switch (split [0]) {  case "ID":  	ProjectID = split [1];  	break;  case "Document":  	string mn = split [1].Substring (0' split [1].IndexOf ("/&H"));  	Modules [mn].Type = eModuleType.Document;  	break;  case "Package":  	prevPackage = split [1];  	break;  case "BaseClass":  	Modules [split [1]].Type = eModuleType.Designer;  	Modules [split [1]].ClassID = prevPackage;  	break;  case "Module":  	Modules [split [1]].Type = eModuleType.Module;  	break;  case "Class":  	Modules [split [1]].Type = eModuleType.Class;  	break;  case "HelpFile":  case "Name":  case "HelpContextID":  case "Description":  case "VersionCompatible32":  	break;  //393222000"  case "CMG":  	byte[] cmg = Decrypt (split [1]);  	_protection.UserProtected = (cmg [0] & 1) != 0;  	_protection.HostProtected = (cmg [0] & 2) != 0;  	_protection.VbeProtected = (cmg [0] & 4) != 0;  	break;  case "DPB":  	byte[] dpb = Decrypt (split [1]);  	if (dpb.Length >= 28) {  		byte reserved = dpb [0];  		var flags = new byte[3];  		Array.Copy (dpb' 1' flags' 0' 3);  		var keyNoNulls = new byte[4];  		_protection.PasswordKey = new byte[4];  		Array.Copy (dpb' 4' keyNoNulls' 0' 4);  		var hashNoNulls = new byte[20];  		_protection.PasswordHash = new byte[20];  		Array.Copy (dpb' 8' hashNoNulls' 0' 20);  		//Handle 0x00 bitwise 2.4.4.3   		for (int i = 0; i < 24; i++) {  			int bit = 128 >> (int)((i % 8));  			if (i < 4) {  				if ((int)(flags [0] & bit) == 0) {  					_protection.PasswordKey [i] = 0;  				}  				else {  					_protection.PasswordKey [i] = keyNoNulls [i];  				}  			}  			else {  				int flagIndex = (i - i % 8) / 8;  				if ((int)(flags [flagIndex] & bit) == 0) {  					_protection.PasswordHash [i - 4] = 0;  				}  				else {  					_protection.PasswordHash [i - 4] = hashNoNulls [i - 4];  				}  			}  		}  	}  	break;  case "GC":  	_protection.VisibilityState = Decrypt (split [1]) [0] == 0xFF;  	break;  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadProjectProperties,The following statement contains a magic number: switch (split [0]) {  case "ID":  	ProjectID = split [1];  	break;  case "Document":  	string mn = split [1].Substring (0' split [1].IndexOf ("/&H"));  	Modules [mn].Type = eModuleType.Document;  	break;  case "Package":  	prevPackage = split [1];  	break;  case "BaseClass":  	Modules [split [1]].Type = eModuleType.Designer;  	Modules [split [1]].ClassID = prevPackage;  	break;  case "Module":  	Modules [split [1]].Type = eModuleType.Module;  	break;  case "Class":  	Modules [split [1]].Type = eModuleType.Class;  	break;  case "HelpFile":  case "Name":  case "HelpContextID":  case "Description":  case "VersionCompatible32":  	break;  //393222000"  case "CMG":  	byte[] cmg = Decrypt (split [1]);  	_protection.UserProtected = (cmg [0] & 1) != 0;  	_protection.HostProtected = (cmg [0] & 2) != 0;  	_protection.VbeProtected = (cmg [0] & 4) != 0;  	break;  case "DPB":  	byte[] dpb = Decrypt (split [1]);  	if (dpb.Length >= 28) {  		byte reserved = dpb [0];  		var flags = new byte[3];  		Array.Copy (dpb' 1' flags' 0' 3);  		var keyNoNulls = new byte[4];  		_protection.PasswordKey = new byte[4];  		Array.Copy (dpb' 4' keyNoNulls' 0' 4);  		var hashNoNulls = new byte[20];  		_protection.PasswordHash = new byte[20];  		Array.Copy (dpb' 8' hashNoNulls' 0' 20);  		//Handle 0x00 bitwise 2.4.4.3   		for (int i = 0; i < 24; i++) {  			int bit = 128 >> (int)((i % 8));  			if (i < 4) {  				if ((int)(flags [0] & bit) == 0) {  					_protection.PasswordKey [i] = 0;  				}  				else {  					_protection.PasswordKey [i] = keyNoNulls [i];  				}  			}  			else {  				int flagIndex = (i - i % 8) / 8;  				if ((int)(flags [flagIndex] & bit) == 0) {  					_protection.PasswordHash [i - 4] = 0;  				}  				else {  					_protection.PasswordHash [i - 4] = hashNoNulls [i - 4];  				}  			}  		}  	}  	break;  case "GC":  	_protection.VisibilityState = Decrypt (split [1]) [0] == 0xFF;  	break;  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadProjectProperties,The following statement contains a magic number: switch (split [0]) {  case "ID":  	ProjectID = split [1];  	break;  case "Document":  	string mn = split [1].Substring (0' split [1].IndexOf ("/&H"));  	Modules [mn].Type = eModuleType.Document;  	break;  case "Package":  	prevPackage = split [1];  	break;  case "BaseClass":  	Modules [split [1]].Type = eModuleType.Designer;  	Modules [split [1]].ClassID = prevPackage;  	break;  case "Module":  	Modules [split [1]].Type = eModuleType.Module;  	break;  case "Class":  	Modules [split [1]].Type = eModuleType.Class;  	break;  case "HelpFile":  case "Name":  case "HelpContextID":  case "Description":  case "VersionCompatible32":  	break;  //393222000"  case "CMG":  	byte[] cmg = Decrypt (split [1]);  	_protection.UserProtected = (cmg [0] & 1) != 0;  	_protection.HostProtected = (cmg [0] & 2) != 0;  	_protection.VbeProtected = (cmg [0] & 4) != 0;  	break;  case "DPB":  	byte[] dpb = Decrypt (split [1]);  	if (dpb.Length >= 28) {  		byte reserved = dpb [0];  		var flags = new byte[3];  		Array.Copy (dpb' 1' flags' 0' 3);  		var keyNoNulls = new byte[4];  		_protection.PasswordKey = new byte[4];  		Array.Copy (dpb' 4' keyNoNulls' 0' 4);  		var hashNoNulls = new byte[20];  		_protection.PasswordHash = new byte[20];  		Array.Copy (dpb' 8' hashNoNulls' 0' 20);  		//Handle 0x00 bitwise 2.4.4.3   		for (int i = 0; i < 24; i++) {  			int bit = 128 >> (int)((i % 8));  			if (i < 4) {  				if ((int)(flags [0] & bit) == 0) {  					_protection.PasswordKey [i] = 0;  				}  				else {  					_protection.PasswordKey [i] = keyNoNulls [i];  				}  			}  			else {  				int flagIndex = (i - i % 8) / 8;  				if ((int)(flags [flagIndex] & bit) == 0) {  					_protection.PasswordHash [i - 4] = 0;  				}  				else {  					_protection.PasswordHash [i - 4] = hashNoNulls [i - 4];  				}  			}  		}  	}  	break;  case "GC":  	_protection.VisibilityState = Decrypt (split [1]) [0] == 0xFF;  	break;  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadProjectProperties,The following statement contains a magic number: switch (split [0]) {  case "ID":  	ProjectID = split [1];  	break;  case "Document":  	string mn = split [1].Substring (0' split [1].IndexOf ("/&H"));  	Modules [mn].Type = eModuleType.Document;  	break;  case "Package":  	prevPackage = split [1];  	break;  case "BaseClass":  	Modules [split [1]].Type = eModuleType.Designer;  	Modules [split [1]].ClassID = prevPackage;  	break;  case "Module":  	Modules [split [1]].Type = eModuleType.Module;  	break;  case "Class":  	Modules [split [1]].Type = eModuleType.Class;  	break;  case "HelpFile":  case "Name":  case "HelpContextID":  case "Description":  case "VersionCompatible32":  	break;  //393222000"  case "CMG":  	byte[] cmg = Decrypt (split [1]);  	_protection.UserProtected = (cmg [0] & 1) != 0;  	_protection.HostProtected = (cmg [0] & 2) != 0;  	_protection.VbeProtected = (cmg [0] & 4) != 0;  	break;  case "DPB":  	byte[] dpb = Decrypt (split [1]);  	if (dpb.Length >= 28) {  		byte reserved = dpb [0];  		var flags = new byte[3];  		Array.Copy (dpb' 1' flags' 0' 3);  		var keyNoNulls = new byte[4];  		_protection.PasswordKey = new byte[4];  		Array.Copy (dpb' 4' keyNoNulls' 0' 4);  		var hashNoNulls = new byte[20];  		_protection.PasswordHash = new byte[20];  		Array.Copy (dpb' 8' hashNoNulls' 0' 20);  		//Handle 0x00 bitwise 2.4.4.3   		for (int i = 0; i < 24; i++) {  			int bit = 128 >> (int)((i % 8));  			if (i < 4) {  				if ((int)(flags [0] & bit) == 0) {  					_protection.PasswordKey [i] = 0;  				}  				else {  					_protection.PasswordKey [i] = keyNoNulls [i];  				}  			}  			else {  				int flagIndex = (i - i % 8) / 8;  				if ((int)(flags [flagIndex] & bit) == 0) {  					_protection.PasswordHash [i - 4] = 0;  				}  				else {  					_protection.PasswordHash [i - 4] = hashNoNulls [i - 4];  				}  			}  		}  	}  	break;  case "GC":  	_protection.VisibilityState = Decrypt (split [1]) [0] == 0xFF;  	break;  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadProjectProperties,The following statement contains a magic number: switch (split [0]) {  case "ID":  	ProjectID = split [1];  	break;  case "Document":  	string mn = split [1].Substring (0' split [1].IndexOf ("/&H"));  	Modules [mn].Type = eModuleType.Document;  	break;  case "Package":  	prevPackage = split [1];  	break;  case "BaseClass":  	Modules [split [1]].Type = eModuleType.Designer;  	Modules [split [1]].ClassID = prevPackage;  	break;  case "Module":  	Modules [split [1]].Type = eModuleType.Module;  	break;  case "Class":  	Modules [split [1]].Type = eModuleType.Class;  	break;  case "HelpFile":  case "Name":  case "HelpContextID":  case "Description":  case "VersionCompatible32":  	break;  //393222000"  case "CMG":  	byte[] cmg = Decrypt (split [1]);  	_protection.UserProtected = (cmg [0] & 1) != 0;  	_protection.HostProtected = (cmg [0] & 2) != 0;  	_protection.VbeProtected = (cmg [0] & 4) != 0;  	break;  case "DPB":  	byte[] dpb = Decrypt (split [1]);  	if (dpb.Length >= 28) {  		byte reserved = dpb [0];  		var flags = new byte[3];  		Array.Copy (dpb' 1' flags' 0' 3);  		var keyNoNulls = new byte[4];  		_protection.PasswordKey = new byte[4];  		Array.Copy (dpb' 4' keyNoNulls' 0' 4);  		var hashNoNulls = new byte[20];  		_protection.PasswordHash = new byte[20];  		Array.Copy (dpb' 8' hashNoNulls' 0' 20);  		//Handle 0x00 bitwise 2.4.4.3   		for (int i = 0; i < 24; i++) {  			int bit = 128 >> (int)((i % 8));  			if (i < 4) {  				if ((int)(flags [0] & bit) == 0) {  					_protection.PasswordKey [i] = 0;  				}  				else {  					_protection.PasswordKey [i] = keyNoNulls [i];  				}  			}  			else {  				int flagIndex = (i - i % 8) / 8;  				if ((int)(flags [flagIndex] & bit) == 0) {  					_protection.PasswordHash [i - 4] = 0;  				}  				else {  					_protection.PasswordHash [i - 4] = hashNoNulls [i - 4];  				}  			}  		}  	}  	break;  case "GC":  	_protection.VisibilityState = Decrypt (split [1]) [0] == 0xFF;  	break;  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadProjectProperties,The following statement contains a magic number: switch (split [0]) {  case "ID":  	ProjectID = split [1];  	break;  case "Document":  	string mn = split [1].Substring (0' split [1].IndexOf ("/&H"));  	Modules [mn].Type = eModuleType.Document;  	break;  case "Package":  	prevPackage = split [1];  	break;  case "BaseClass":  	Modules [split [1]].Type = eModuleType.Designer;  	Modules [split [1]].ClassID = prevPackage;  	break;  case "Module":  	Modules [split [1]].Type = eModuleType.Module;  	break;  case "Class":  	Modules [split [1]].Type = eModuleType.Class;  	break;  case "HelpFile":  case "Name":  case "HelpContextID":  case "Description":  case "VersionCompatible32":  	break;  //393222000"  case "CMG":  	byte[] cmg = Decrypt (split [1]);  	_protection.UserProtected = (cmg [0] & 1) != 0;  	_protection.HostProtected = (cmg [0] & 2) != 0;  	_protection.VbeProtected = (cmg [0] & 4) != 0;  	break;  case "DPB":  	byte[] dpb = Decrypt (split [1]);  	if (dpb.Length >= 28) {  		byte reserved = dpb [0];  		var flags = new byte[3];  		Array.Copy (dpb' 1' flags' 0' 3);  		var keyNoNulls = new byte[4];  		_protection.PasswordKey = new byte[4];  		Array.Copy (dpb' 4' keyNoNulls' 0' 4);  		var hashNoNulls = new byte[20];  		_protection.PasswordHash = new byte[20];  		Array.Copy (dpb' 8' hashNoNulls' 0' 20);  		//Handle 0x00 bitwise 2.4.4.3   		for (int i = 0; i < 24; i++) {  			int bit = 128 >> (int)((i % 8));  			if (i < 4) {  				if ((int)(flags [0] & bit) == 0) {  					_protection.PasswordKey [i] = 0;  				}  				else {  					_protection.PasswordKey [i] = keyNoNulls [i];  				}  			}  			else {  				int flagIndex = (i - i % 8) / 8;  				if ((int)(flags [flagIndex] & bit) == 0) {  					_protection.PasswordHash [i - 4] = 0;  				}  				else {  					_protection.PasswordHash [i - 4] = hashNoNulls [i - 4];  				}  			}  		}  	}  	break;  case "GC":  	_protection.VisibilityState = Decrypt (split [1]) [0] == 0xFF;  	break;  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadProjectProperties,The following statement contains a magic number: switch (split [0]) {  case "ID":  	ProjectID = split [1];  	break;  case "Document":  	string mn = split [1].Substring (0' split [1].IndexOf ("/&H"));  	Modules [mn].Type = eModuleType.Document;  	break;  case "Package":  	prevPackage = split [1];  	break;  case "BaseClass":  	Modules [split [1]].Type = eModuleType.Designer;  	Modules [split [1]].ClassID = prevPackage;  	break;  case "Module":  	Modules [split [1]].Type = eModuleType.Module;  	break;  case "Class":  	Modules [split [1]].Type = eModuleType.Class;  	break;  case "HelpFile":  case "Name":  case "HelpContextID":  case "Description":  case "VersionCompatible32":  	break;  //393222000"  case "CMG":  	byte[] cmg = Decrypt (split [1]);  	_protection.UserProtected = (cmg [0] & 1) != 0;  	_protection.HostProtected = (cmg [0] & 2) != 0;  	_protection.VbeProtected = (cmg [0] & 4) != 0;  	break;  case "DPB":  	byte[] dpb = Decrypt (split [1]);  	if (dpb.Length >= 28) {  		byte reserved = dpb [0];  		var flags = new byte[3];  		Array.Copy (dpb' 1' flags' 0' 3);  		var keyNoNulls = new byte[4];  		_protection.PasswordKey = new byte[4];  		Array.Copy (dpb' 4' keyNoNulls' 0' 4);  		var hashNoNulls = new byte[20];  		_protection.PasswordHash = new byte[20];  		Array.Copy (dpb' 8' hashNoNulls' 0' 20);  		//Handle 0x00 bitwise 2.4.4.3   		for (int i = 0; i < 24; i++) {  			int bit = 128 >> (int)((i % 8));  			if (i < 4) {  				if ((int)(flags [0] & bit) == 0) {  					_protection.PasswordKey [i] = 0;  				}  				else {  					_protection.PasswordKey [i] = keyNoNulls [i];  				}  			}  			else {  				int flagIndex = (i - i % 8) / 8;  				if ((int)(flags [flagIndex] & bit) == 0) {  					_protection.PasswordHash [i - 4] = 0;  				}  				else {  					_protection.PasswordHash [i - 4] = hashNoNulls [i - 4];  				}  			}  		}  	}  	break;  case "GC":  	_protection.VisibilityState = Decrypt (split [1]) [0] == 0xFF;  	break;  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadProjectProperties,The following statement contains a magic number: switch (split [0]) {  case "ID":  	ProjectID = split [1];  	break;  case "Document":  	string mn = split [1].Substring (0' split [1].IndexOf ("/&H"));  	Modules [mn].Type = eModuleType.Document;  	break;  case "Package":  	prevPackage = split [1];  	break;  case "BaseClass":  	Modules [split [1]].Type = eModuleType.Designer;  	Modules [split [1]].ClassID = prevPackage;  	break;  case "Module":  	Modules [split [1]].Type = eModuleType.Module;  	break;  case "Class":  	Modules [split [1]].Type = eModuleType.Class;  	break;  case "HelpFile":  case "Name":  case "HelpContextID":  case "Description":  case "VersionCompatible32":  	break;  //393222000"  case "CMG":  	byte[] cmg = Decrypt (split [1]);  	_protection.UserProtected = (cmg [0] & 1) != 0;  	_protection.HostProtected = (cmg [0] & 2) != 0;  	_protection.VbeProtected = (cmg [0] & 4) != 0;  	break;  case "DPB":  	byte[] dpb = Decrypt (split [1]);  	if (dpb.Length >= 28) {  		byte reserved = dpb [0];  		var flags = new byte[3];  		Array.Copy (dpb' 1' flags' 0' 3);  		var keyNoNulls = new byte[4];  		_protection.PasswordKey = new byte[4];  		Array.Copy (dpb' 4' keyNoNulls' 0' 4);  		var hashNoNulls = new byte[20];  		_protection.PasswordHash = new byte[20];  		Array.Copy (dpb' 8' hashNoNulls' 0' 20);  		//Handle 0x00 bitwise 2.4.4.3   		for (int i = 0; i < 24; i++) {  			int bit = 128 >> (int)((i % 8));  			if (i < 4) {  				if ((int)(flags [0] & bit) == 0) {  					_protection.PasswordKey [i] = 0;  				}  				else {  					_protection.PasswordKey [i] = keyNoNulls [i];  				}  			}  			else {  				int flagIndex = (i - i % 8) / 8;  				if ((int)(flags [flagIndex] & bit) == 0) {  					_protection.PasswordHash [i - 4] = 0;  				}  				else {  					_protection.PasswordHash [i - 4] = hashNoNulls [i - 4];  				}  			}  		}  	}  	break;  case "GC":  	_protection.VisibilityState = Decrypt (split [1]) [0] == 0xFF;  	break;  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadProjectProperties,The following statement contains a magic number: switch (split [0]) {  case "ID":  	ProjectID = split [1];  	break;  case "Document":  	string mn = split [1].Substring (0' split [1].IndexOf ("/&H"));  	Modules [mn].Type = eModuleType.Document;  	break;  case "Package":  	prevPackage = split [1];  	break;  case "BaseClass":  	Modules [split [1]].Type = eModuleType.Designer;  	Modules [split [1]].ClassID = prevPackage;  	break;  case "Module":  	Modules [split [1]].Type = eModuleType.Module;  	break;  case "Class":  	Modules [split [1]].Type = eModuleType.Class;  	break;  case "HelpFile":  case "Name":  case "HelpContextID":  case "Description":  case "VersionCompatible32":  	break;  //393222000"  case "CMG":  	byte[] cmg = Decrypt (split [1]);  	_protection.UserProtected = (cmg [0] & 1) != 0;  	_protection.HostProtected = (cmg [0] & 2) != 0;  	_protection.VbeProtected = (cmg [0] & 4) != 0;  	break;  case "DPB":  	byte[] dpb = Decrypt (split [1]);  	if (dpb.Length >= 28) {  		byte reserved = dpb [0];  		var flags = new byte[3];  		Array.Copy (dpb' 1' flags' 0' 3);  		var keyNoNulls = new byte[4];  		_protection.PasswordKey = new byte[4];  		Array.Copy (dpb' 4' keyNoNulls' 0' 4);  		var hashNoNulls = new byte[20];  		_protection.PasswordHash = new byte[20];  		Array.Copy (dpb' 8' hashNoNulls' 0' 20);  		//Handle 0x00 bitwise 2.4.4.3   		for (int i = 0; i < 24; i++) {  			int bit = 128 >> (int)((i % 8));  			if (i < 4) {  				if ((int)(flags [0] & bit) == 0) {  					_protection.PasswordKey [i] = 0;  				}  				else {  					_protection.PasswordKey [i] = keyNoNulls [i];  				}  			}  			else {  				int flagIndex = (i - i % 8) / 8;  				if ((int)(flags [flagIndex] & bit) == 0) {  					_protection.PasswordHash [i - 4] = 0;  				}  				else {  					_protection.PasswordHash [i - 4] = hashNoNulls [i - 4];  				}  			}  		}  	}  	break;  case "GC":  	_protection.VisibilityState = Decrypt (split [1]) [0] == 0xFF;  	break;  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadProjectProperties,The following statement contains a magic number: switch (split [0]) {  case "ID":  	ProjectID = split [1];  	break;  case "Document":  	string mn = split [1].Substring (0' split [1].IndexOf ("/&H"));  	Modules [mn].Type = eModuleType.Document;  	break;  case "Package":  	prevPackage = split [1];  	break;  case "BaseClass":  	Modules [split [1]].Type = eModuleType.Designer;  	Modules [split [1]].ClassID = prevPackage;  	break;  case "Module":  	Modules [split [1]].Type = eModuleType.Module;  	break;  case "Class":  	Modules [split [1]].Type = eModuleType.Class;  	break;  case "HelpFile":  case "Name":  case "HelpContextID":  case "Description":  case "VersionCompatible32":  	break;  //393222000"  case "CMG":  	byte[] cmg = Decrypt (split [1]);  	_protection.UserProtected = (cmg [0] & 1) != 0;  	_protection.HostProtected = (cmg [0] & 2) != 0;  	_protection.VbeProtected = (cmg [0] & 4) != 0;  	break;  case "DPB":  	byte[] dpb = Decrypt (split [1]);  	if (dpb.Length >= 28) {  		byte reserved = dpb [0];  		var flags = new byte[3];  		Array.Copy (dpb' 1' flags' 0' 3);  		var keyNoNulls = new byte[4];  		_protection.PasswordKey = new byte[4];  		Array.Copy (dpb' 4' keyNoNulls' 0' 4);  		var hashNoNulls = new byte[20];  		_protection.PasswordHash = new byte[20];  		Array.Copy (dpb' 8' hashNoNulls' 0' 20);  		//Handle 0x00 bitwise 2.4.4.3   		for (int i = 0; i < 24; i++) {  			int bit = 128 >> (int)((i % 8));  			if (i < 4) {  				if ((int)(flags [0] & bit) == 0) {  					_protection.PasswordKey [i] = 0;  				}  				else {  					_protection.PasswordKey [i] = keyNoNulls [i];  				}  			}  			else {  				int flagIndex = (i - i % 8) / 8;  				if ((int)(flags [flagIndex] & bit) == 0) {  					_protection.PasswordHash [i - 4] = 0;  				}  				else {  					_protection.PasswordHash [i - 4] = hashNoNulls [i - 4];  				}  			}  		}  	}  	break;  case "GC":  	_protection.VisibilityState = Decrypt (split [1]) [0] == 0xFF;  	break;  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadProjectProperties,The following statement contains a magic number: switch (split [0]) {  case "ID":  	ProjectID = split [1];  	break;  case "Document":  	string mn = split [1].Substring (0' split [1].IndexOf ("/&H"));  	Modules [mn].Type = eModuleType.Document;  	break;  case "Package":  	prevPackage = split [1];  	break;  case "BaseClass":  	Modules [split [1]].Type = eModuleType.Designer;  	Modules [split [1]].ClassID = prevPackage;  	break;  case "Module":  	Modules [split [1]].Type = eModuleType.Module;  	break;  case "Class":  	Modules [split [1]].Type = eModuleType.Class;  	break;  case "HelpFile":  case "Name":  case "HelpContextID":  case "Description":  case "VersionCompatible32":  	break;  //393222000"  case "CMG":  	byte[] cmg = Decrypt (split [1]);  	_protection.UserProtected = (cmg [0] & 1) != 0;  	_protection.HostProtected = (cmg [0] & 2) != 0;  	_protection.VbeProtected = (cmg [0] & 4) != 0;  	break;  case "DPB":  	byte[] dpb = Decrypt (split [1]);  	if (dpb.Length >= 28) {  		byte reserved = dpb [0];  		var flags = new byte[3];  		Array.Copy (dpb' 1' flags' 0' 3);  		var keyNoNulls = new byte[4];  		_protection.PasswordKey = new byte[4];  		Array.Copy (dpb' 4' keyNoNulls' 0' 4);  		var hashNoNulls = new byte[20];  		_protection.PasswordHash = new byte[20];  		Array.Copy (dpb' 8' hashNoNulls' 0' 20);  		//Handle 0x00 bitwise 2.4.4.3   		for (int i = 0; i < 24; i++) {  			int bit = 128 >> (int)((i % 8));  			if (i < 4) {  				if ((int)(flags [0] & bit) == 0) {  					_protection.PasswordKey [i] = 0;  				}  				else {  					_protection.PasswordKey [i] = keyNoNulls [i];  				}  			}  			else {  				int flagIndex = (i - i % 8) / 8;  				if ((int)(flags [flagIndex] & bit) == 0) {  					_protection.PasswordHash [i - 4] = 0;  				}  				else {  					_protection.PasswordHash [i - 4] = hashNoNulls [i - 4];  				}  			}  		}  	}  	break;  case "GC":  	_protection.VisibilityState = Decrypt (split [1]) [0] == 0xFF;  	break;  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadProjectProperties,The following statement contains a magic number: switch (split [0]) {  case "ID":  	ProjectID = split [1];  	break;  case "Document":  	string mn = split [1].Substring (0' split [1].IndexOf ("/&H"));  	Modules [mn].Type = eModuleType.Document;  	break;  case "Package":  	prevPackage = split [1];  	break;  case "BaseClass":  	Modules [split [1]].Type = eModuleType.Designer;  	Modules [split [1]].ClassID = prevPackage;  	break;  case "Module":  	Modules [split [1]].Type = eModuleType.Module;  	break;  case "Class":  	Modules [split [1]].Type = eModuleType.Class;  	break;  case "HelpFile":  case "Name":  case "HelpContextID":  case "Description":  case "VersionCompatible32":  	break;  //393222000"  case "CMG":  	byte[] cmg = Decrypt (split [1]);  	_protection.UserProtected = (cmg [0] & 1) != 0;  	_protection.HostProtected = (cmg [0] & 2) != 0;  	_protection.VbeProtected = (cmg [0] & 4) != 0;  	break;  case "DPB":  	byte[] dpb = Decrypt (split [1]);  	if (dpb.Length >= 28) {  		byte reserved = dpb [0];  		var flags = new byte[3];  		Array.Copy (dpb' 1' flags' 0' 3);  		var keyNoNulls = new byte[4];  		_protection.PasswordKey = new byte[4];  		Array.Copy (dpb' 4' keyNoNulls' 0' 4);  		var hashNoNulls = new byte[20];  		_protection.PasswordHash = new byte[20];  		Array.Copy (dpb' 8' hashNoNulls' 0' 20);  		//Handle 0x00 bitwise 2.4.4.3   		for (int i = 0; i < 24; i++) {  			int bit = 128 >> (int)((i % 8));  			if (i < 4) {  				if ((int)(flags [0] & bit) == 0) {  					_protection.PasswordKey [i] = 0;  				}  				else {  					_protection.PasswordKey [i] = keyNoNulls [i];  				}  			}  			else {  				int flagIndex = (i - i % 8) / 8;  				if ((int)(flags [flagIndex] & bit) == 0) {  					_protection.PasswordHash [i - 4] = 0;  				}  				else {  					_protection.PasswordHash [i - 4] = hashNoNulls [i - 4];  				}  			}  		}  	}  	break;  case "GC":  	_protection.VisibilityState = Decrypt (split [1]) [0] == 0xFF;  	break;  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadProjectProperties,The following statement contains a magic number: switch (split [0]) {  case "ID":  	ProjectID = split [1];  	break;  case "Document":  	string mn = split [1].Substring (0' split [1].IndexOf ("/&H"));  	Modules [mn].Type = eModuleType.Document;  	break;  case "Package":  	prevPackage = split [1];  	break;  case "BaseClass":  	Modules [split [1]].Type = eModuleType.Designer;  	Modules [split [1]].ClassID = prevPackage;  	break;  case "Module":  	Modules [split [1]].Type = eModuleType.Module;  	break;  case "Class":  	Modules [split [1]].Type = eModuleType.Class;  	break;  case "HelpFile":  case "Name":  case "HelpContextID":  case "Description":  case "VersionCompatible32":  	break;  //393222000"  case "CMG":  	byte[] cmg = Decrypt (split [1]);  	_protection.UserProtected = (cmg [0] & 1) != 0;  	_protection.HostProtected = (cmg [0] & 2) != 0;  	_protection.VbeProtected = (cmg [0] & 4) != 0;  	break;  case "DPB":  	byte[] dpb = Decrypt (split [1]);  	if (dpb.Length >= 28) {  		byte reserved = dpb [0];  		var flags = new byte[3];  		Array.Copy (dpb' 1' flags' 0' 3);  		var keyNoNulls = new byte[4];  		_protection.PasswordKey = new byte[4];  		Array.Copy (dpb' 4' keyNoNulls' 0' 4);  		var hashNoNulls = new byte[20];  		_protection.PasswordHash = new byte[20];  		Array.Copy (dpb' 8' hashNoNulls' 0' 20);  		//Handle 0x00 bitwise 2.4.4.3   		for (int i = 0; i < 24; i++) {  			int bit = 128 >> (int)((i % 8));  			if (i < 4) {  				if ((int)(flags [0] & bit) == 0) {  					_protection.PasswordKey [i] = 0;  				}  				else {  					_protection.PasswordKey [i] = keyNoNulls [i];  				}  			}  			else {  				int flagIndex = (i - i % 8) / 8;  				if ((int)(flags [flagIndex] & bit) == 0) {  					_protection.PasswordHash [i - 4] = 0;  				}  				else {  					_protection.PasswordHash [i - 4] = hashNoNulls [i - 4];  				}  			}  		}  	}  	break;  case "GC":  	_protection.VisibilityState = Decrypt (split [1]) [0] == 0xFF;  	break;  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadProjectProperties,The following statement contains a magic number: _protection.HostProtected = (cmg [0] & 2) != 0;  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadProjectProperties,The following statement contains a magic number: _protection.VbeProtected = (cmg [0] & 4) != 0;  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadProjectProperties,The following statement contains a magic number: if (dpb.Length >= 28) {  	byte reserved = dpb [0];  	var flags = new byte[3];  	Array.Copy (dpb' 1' flags' 0' 3);  	var keyNoNulls = new byte[4];  	_protection.PasswordKey = new byte[4];  	Array.Copy (dpb' 4' keyNoNulls' 0' 4);  	var hashNoNulls = new byte[20];  	_protection.PasswordHash = new byte[20];  	Array.Copy (dpb' 8' hashNoNulls' 0' 20);  	//Handle 0x00 bitwise 2.4.4.3   	for (int i = 0; i < 24; i++) {  		int bit = 128 >> (int)((i % 8));  		if (i < 4) {  			if ((int)(flags [0] & bit) == 0) {  				_protection.PasswordKey [i] = 0;  			}  			else {  				_protection.PasswordKey [i] = keyNoNulls [i];  			}  		}  		else {  			int flagIndex = (i - i % 8) / 8;  			if ((int)(flags [flagIndex] & bit) == 0) {  				_protection.PasswordHash [i - 4] = 0;  			}  			else {  				_protection.PasswordHash [i - 4] = hashNoNulls [i - 4];  			}  		}  	}  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadProjectProperties,The following statement contains a magic number: if (dpb.Length >= 28) {  	byte reserved = dpb [0];  	var flags = new byte[3];  	Array.Copy (dpb' 1' flags' 0' 3);  	var keyNoNulls = new byte[4];  	_protection.PasswordKey = new byte[4];  	Array.Copy (dpb' 4' keyNoNulls' 0' 4);  	var hashNoNulls = new byte[20];  	_protection.PasswordHash = new byte[20];  	Array.Copy (dpb' 8' hashNoNulls' 0' 20);  	//Handle 0x00 bitwise 2.4.4.3   	for (int i = 0; i < 24; i++) {  		int bit = 128 >> (int)((i % 8));  		if (i < 4) {  			if ((int)(flags [0] & bit) == 0) {  				_protection.PasswordKey [i] = 0;  			}  			else {  				_protection.PasswordKey [i] = keyNoNulls [i];  			}  		}  		else {  			int flagIndex = (i - i % 8) / 8;  			if ((int)(flags [flagIndex] & bit) == 0) {  				_protection.PasswordHash [i - 4] = 0;  			}  			else {  				_protection.PasswordHash [i - 4] = hashNoNulls [i - 4];  			}  		}  	}  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadProjectProperties,The following statement contains a magic number: if (dpb.Length >= 28) {  	byte reserved = dpb [0];  	var flags = new byte[3];  	Array.Copy (dpb' 1' flags' 0' 3);  	var keyNoNulls = new byte[4];  	_protection.PasswordKey = new byte[4];  	Array.Copy (dpb' 4' keyNoNulls' 0' 4);  	var hashNoNulls = new byte[20];  	_protection.PasswordHash = new byte[20];  	Array.Copy (dpb' 8' hashNoNulls' 0' 20);  	//Handle 0x00 bitwise 2.4.4.3   	for (int i = 0; i < 24; i++) {  		int bit = 128 >> (int)((i % 8));  		if (i < 4) {  			if ((int)(flags [0] & bit) == 0) {  				_protection.PasswordKey [i] = 0;  			}  			else {  				_protection.PasswordKey [i] = keyNoNulls [i];  			}  		}  		else {  			int flagIndex = (i - i % 8) / 8;  			if ((int)(flags [flagIndex] & bit) == 0) {  				_protection.PasswordHash [i - 4] = 0;  			}  			else {  				_protection.PasswordHash [i - 4] = hashNoNulls [i - 4];  			}  		}  	}  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadProjectProperties,The following statement contains a magic number: if (dpb.Length >= 28) {  	byte reserved = dpb [0];  	var flags = new byte[3];  	Array.Copy (dpb' 1' flags' 0' 3);  	var keyNoNulls = new byte[4];  	_protection.PasswordKey = new byte[4];  	Array.Copy (dpb' 4' keyNoNulls' 0' 4);  	var hashNoNulls = new byte[20];  	_protection.PasswordHash = new byte[20];  	Array.Copy (dpb' 8' hashNoNulls' 0' 20);  	//Handle 0x00 bitwise 2.4.4.3   	for (int i = 0; i < 24; i++) {  		int bit = 128 >> (int)((i % 8));  		if (i < 4) {  			if ((int)(flags [0] & bit) == 0) {  				_protection.PasswordKey [i] = 0;  			}  			else {  				_protection.PasswordKey [i] = keyNoNulls [i];  			}  		}  		else {  			int flagIndex = (i - i % 8) / 8;  			if ((int)(flags [flagIndex] & bit) == 0) {  				_protection.PasswordHash [i - 4] = 0;  			}  			else {  				_protection.PasswordHash [i - 4] = hashNoNulls [i - 4];  			}  		}  	}  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadProjectProperties,The following statement contains a magic number: if (dpb.Length >= 28) {  	byte reserved = dpb [0];  	var flags = new byte[3];  	Array.Copy (dpb' 1' flags' 0' 3);  	var keyNoNulls = new byte[4];  	_protection.PasswordKey = new byte[4];  	Array.Copy (dpb' 4' keyNoNulls' 0' 4);  	var hashNoNulls = new byte[20];  	_protection.PasswordHash = new byte[20];  	Array.Copy (dpb' 8' hashNoNulls' 0' 20);  	//Handle 0x00 bitwise 2.4.4.3   	for (int i = 0; i < 24; i++) {  		int bit = 128 >> (int)((i % 8));  		if (i < 4) {  			if ((int)(flags [0] & bit) == 0) {  				_protection.PasswordKey [i] = 0;  			}  			else {  				_protection.PasswordKey [i] = keyNoNulls [i];  			}  		}  		else {  			int flagIndex = (i - i % 8) / 8;  			if ((int)(flags [flagIndex] & bit) == 0) {  				_protection.PasswordHash [i - 4] = 0;  			}  			else {  				_protection.PasswordHash [i - 4] = hashNoNulls [i - 4];  			}  		}  	}  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadProjectProperties,The following statement contains a magic number: if (dpb.Length >= 28) {  	byte reserved = dpb [0];  	var flags = new byte[3];  	Array.Copy (dpb' 1' flags' 0' 3);  	var keyNoNulls = new byte[4];  	_protection.PasswordKey = new byte[4];  	Array.Copy (dpb' 4' keyNoNulls' 0' 4);  	var hashNoNulls = new byte[20];  	_protection.PasswordHash = new byte[20];  	Array.Copy (dpb' 8' hashNoNulls' 0' 20);  	//Handle 0x00 bitwise 2.4.4.3   	for (int i = 0; i < 24; i++) {  		int bit = 128 >> (int)((i % 8));  		if (i < 4) {  			if ((int)(flags [0] & bit) == 0) {  				_protection.PasswordKey [i] = 0;  			}  			else {  				_protection.PasswordKey [i] = keyNoNulls [i];  			}  		}  		else {  			int flagIndex = (i - i % 8) / 8;  			if ((int)(flags [flagIndex] & bit) == 0) {  				_protection.PasswordHash [i - 4] = 0;  			}  			else {  				_protection.PasswordHash [i - 4] = hashNoNulls [i - 4];  			}  		}  	}  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadProjectProperties,The following statement contains a magic number: if (dpb.Length >= 28) {  	byte reserved = dpb [0];  	var flags = new byte[3];  	Array.Copy (dpb' 1' flags' 0' 3);  	var keyNoNulls = new byte[4];  	_protection.PasswordKey = new byte[4];  	Array.Copy (dpb' 4' keyNoNulls' 0' 4);  	var hashNoNulls = new byte[20];  	_protection.PasswordHash = new byte[20];  	Array.Copy (dpb' 8' hashNoNulls' 0' 20);  	//Handle 0x00 bitwise 2.4.4.3   	for (int i = 0; i < 24; i++) {  		int bit = 128 >> (int)((i % 8));  		if (i < 4) {  			if ((int)(flags [0] & bit) == 0) {  				_protection.PasswordKey [i] = 0;  			}  			else {  				_protection.PasswordKey [i] = keyNoNulls [i];  			}  		}  		else {  			int flagIndex = (i - i % 8) / 8;  			if ((int)(flags [flagIndex] & bit) == 0) {  				_protection.PasswordHash [i - 4] = 0;  			}  			else {  				_protection.PasswordHash [i - 4] = hashNoNulls [i - 4];  			}  		}  	}  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadProjectProperties,The following statement contains a magic number: if (dpb.Length >= 28) {  	byte reserved = dpb [0];  	var flags = new byte[3];  	Array.Copy (dpb' 1' flags' 0' 3);  	var keyNoNulls = new byte[4];  	_protection.PasswordKey = new byte[4];  	Array.Copy (dpb' 4' keyNoNulls' 0' 4);  	var hashNoNulls = new byte[20];  	_protection.PasswordHash = new byte[20];  	Array.Copy (dpb' 8' hashNoNulls' 0' 20);  	//Handle 0x00 bitwise 2.4.4.3   	for (int i = 0; i < 24; i++) {  		int bit = 128 >> (int)((i % 8));  		if (i < 4) {  			if ((int)(flags [0] & bit) == 0) {  				_protection.PasswordKey [i] = 0;  			}  			else {  				_protection.PasswordKey [i] = keyNoNulls [i];  			}  		}  		else {  			int flagIndex = (i - i % 8) / 8;  			if ((int)(flags [flagIndex] & bit) == 0) {  				_protection.PasswordHash [i - 4] = 0;  			}  			else {  				_protection.PasswordHash [i - 4] = hashNoNulls [i - 4];  			}  		}  	}  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadProjectProperties,The following statement contains a magic number: if (dpb.Length >= 28) {  	byte reserved = dpb [0];  	var flags = new byte[3];  	Array.Copy (dpb' 1' flags' 0' 3);  	var keyNoNulls = new byte[4];  	_protection.PasswordKey = new byte[4];  	Array.Copy (dpb' 4' keyNoNulls' 0' 4);  	var hashNoNulls = new byte[20];  	_protection.PasswordHash = new byte[20];  	Array.Copy (dpb' 8' hashNoNulls' 0' 20);  	//Handle 0x00 bitwise 2.4.4.3   	for (int i = 0; i < 24; i++) {  		int bit = 128 >> (int)((i % 8));  		if (i < 4) {  			if ((int)(flags [0] & bit) == 0) {  				_protection.PasswordKey [i] = 0;  			}  			else {  				_protection.PasswordKey [i] = keyNoNulls [i];  			}  		}  		else {  			int flagIndex = (i - i % 8) / 8;  			if ((int)(flags [flagIndex] & bit) == 0) {  				_protection.PasswordHash [i - 4] = 0;  			}  			else {  				_protection.PasswordHash [i - 4] = hashNoNulls [i - 4];  			}  		}  	}  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadProjectProperties,The following statement contains a magic number: if (dpb.Length >= 28) {  	byte reserved = dpb [0];  	var flags = new byte[3];  	Array.Copy (dpb' 1' flags' 0' 3);  	var keyNoNulls = new byte[4];  	_protection.PasswordKey = new byte[4];  	Array.Copy (dpb' 4' keyNoNulls' 0' 4);  	var hashNoNulls = new byte[20];  	_protection.PasswordHash = new byte[20];  	Array.Copy (dpb' 8' hashNoNulls' 0' 20);  	//Handle 0x00 bitwise 2.4.4.3   	for (int i = 0; i < 24; i++) {  		int bit = 128 >> (int)((i % 8));  		if (i < 4) {  			if ((int)(flags [0] & bit) == 0) {  				_protection.PasswordKey [i] = 0;  			}  			else {  				_protection.PasswordKey [i] = keyNoNulls [i];  			}  		}  		else {  			int flagIndex = (i - i % 8) / 8;  			if ((int)(flags [flagIndex] & bit) == 0) {  				_protection.PasswordHash [i - 4] = 0;  			}  			else {  				_protection.PasswordHash [i - 4] = hashNoNulls [i - 4];  			}  		}  	}  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadProjectProperties,The following statement contains a magic number: if (dpb.Length >= 28) {  	byte reserved = dpb [0];  	var flags = new byte[3];  	Array.Copy (dpb' 1' flags' 0' 3);  	var keyNoNulls = new byte[4];  	_protection.PasswordKey = new byte[4];  	Array.Copy (dpb' 4' keyNoNulls' 0' 4);  	var hashNoNulls = new byte[20];  	_protection.PasswordHash = new byte[20];  	Array.Copy (dpb' 8' hashNoNulls' 0' 20);  	//Handle 0x00 bitwise 2.4.4.3   	for (int i = 0; i < 24; i++) {  		int bit = 128 >> (int)((i % 8));  		if (i < 4) {  			if ((int)(flags [0] & bit) == 0) {  				_protection.PasswordKey [i] = 0;  			}  			else {  				_protection.PasswordKey [i] = keyNoNulls [i];  			}  		}  		else {  			int flagIndex = (i - i % 8) / 8;  			if ((int)(flags [flagIndex] & bit) == 0) {  				_protection.PasswordHash [i - 4] = 0;  			}  			else {  				_protection.PasswordHash [i - 4] = hashNoNulls [i - 4];  			}  		}  	}  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadProjectProperties,The following statement contains a magic number: if (dpb.Length >= 28) {  	byte reserved = dpb [0];  	var flags = new byte[3];  	Array.Copy (dpb' 1' flags' 0' 3);  	var keyNoNulls = new byte[4];  	_protection.PasswordKey = new byte[4];  	Array.Copy (dpb' 4' keyNoNulls' 0' 4);  	var hashNoNulls = new byte[20];  	_protection.PasswordHash = new byte[20];  	Array.Copy (dpb' 8' hashNoNulls' 0' 20);  	//Handle 0x00 bitwise 2.4.4.3   	for (int i = 0; i < 24; i++) {  		int bit = 128 >> (int)((i % 8));  		if (i < 4) {  			if ((int)(flags [0] & bit) == 0) {  				_protection.PasswordKey [i] = 0;  			}  			else {  				_protection.PasswordKey [i] = keyNoNulls [i];  			}  		}  		else {  			int flagIndex = (i - i % 8) / 8;  			if ((int)(flags [flagIndex] & bit) == 0) {  				_protection.PasswordHash [i - 4] = 0;  			}  			else {  				_protection.PasswordHash [i - 4] = hashNoNulls [i - 4];  			}  		}  	}  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadProjectProperties,The following statement contains a magic number: if (dpb.Length >= 28) {  	byte reserved = dpb [0];  	var flags = new byte[3];  	Array.Copy (dpb' 1' flags' 0' 3);  	var keyNoNulls = new byte[4];  	_protection.PasswordKey = new byte[4];  	Array.Copy (dpb' 4' keyNoNulls' 0' 4);  	var hashNoNulls = new byte[20];  	_protection.PasswordHash = new byte[20];  	Array.Copy (dpb' 8' hashNoNulls' 0' 20);  	//Handle 0x00 bitwise 2.4.4.3   	for (int i = 0; i < 24; i++) {  		int bit = 128 >> (int)((i % 8));  		if (i < 4) {  			if ((int)(flags [0] & bit) == 0) {  				_protection.PasswordKey [i] = 0;  			}  			else {  				_protection.PasswordKey [i] = keyNoNulls [i];  			}  		}  		else {  			int flagIndex = (i - i % 8) / 8;  			if ((int)(flags [flagIndex] & bit) == 0) {  				_protection.PasswordHash [i - 4] = 0;  			}  			else {  				_protection.PasswordHash [i - 4] = hashNoNulls [i - 4];  			}  		}  	}  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadProjectProperties,The following statement contains a magic number: if (dpb.Length >= 28) {  	byte reserved = dpb [0];  	var flags = new byte[3];  	Array.Copy (dpb' 1' flags' 0' 3);  	var keyNoNulls = new byte[4];  	_protection.PasswordKey = new byte[4];  	Array.Copy (dpb' 4' keyNoNulls' 0' 4);  	var hashNoNulls = new byte[20];  	_protection.PasswordHash = new byte[20];  	Array.Copy (dpb' 8' hashNoNulls' 0' 20);  	//Handle 0x00 bitwise 2.4.4.3   	for (int i = 0; i < 24; i++) {  		int bit = 128 >> (int)((i % 8));  		if (i < 4) {  			if ((int)(flags [0] & bit) == 0) {  				_protection.PasswordKey [i] = 0;  			}  			else {  				_protection.PasswordKey [i] = keyNoNulls [i];  			}  		}  		else {  			int flagIndex = (i - i % 8) / 8;  			if ((int)(flags [flagIndex] & bit) == 0) {  				_protection.PasswordHash [i - 4] = 0;  			}  			else {  				_protection.PasswordHash [i - 4] = hashNoNulls [i - 4];  			}  		}  	}  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadProjectProperties,The following statement contains a magic number: if (dpb.Length >= 28) {  	byte reserved = dpb [0];  	var flags = new byte[3];  	Array.Copy (dpb' 1' flags' 0' 3);  	var keyNoNulls = new byte[4];  	_protection.PasswordKey = new byte[4];  	Array.Copy (dpb' 4' keyNoNulls' 0' 4);  	var hashNoNulls = new byte[20];  	_protection.PasswordHash = new byte[20];  	Array.Copy (dpb' 8' hashNoNulls' 0' 20);  	//Handle 0x00 bitwise 2.4.4.3   	for (int i = 0; i < 24; i++) {  		int bit = 128 >> (int)((i % 8));  		if (i < 4) {  			if ((int)(flags [0] & bit) == 0) {  				_protection.PasswordKey [i] = 0;  			}  			else {  				_protection.PasswordKey [i] = keyNoNulls [i];  			}  		}  		else {  			int flagIndex = (i - i % 8) / 8;  			if ((int)(flags [flagIndex] & bit) == 0) {  				_protection.PasswordHash [i - 4] = 0;  			}  			else {  				_protection.PasswordHash [i - 4] = hashNoNulls [i - 4];  			}  		}  	}  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadProjectProperties,The following statement contains a magic number: if (dpb.Length >= 28) {  	byte reserved = dpb [0];  	var flags = new byte[3];  	Array.Copy (dpb' 1' flags' 0' 3);  	var keyNoNulls = new byte[4];  	_protection.PasswordKey = new byte[4];  	Array.Copy (dpb' 4' keyNoNulls' 0' 4);  	var hashNoNulls = new byte[20];  	_protection.PasswordHash = new byte[20];  	Array.Copy (dpb' 8' hashNoNulls' 0' 20);  	//Handle 0x00 bitwise 2.4.4.3   	for (int i = 0; i < 24; i++) {  		int bit = 128 >> (int)((i % 8));  		if (i < 4) {  			if ((int)(flags [0] & bit) == 0) {  				_protection.PasswordKey [i] = 0;  			}  			else {  				_protection.PasswordKey [i] = keyNoNulls [i];  			}  		}  		else {  			int flagIndex = (i - i % 8) / 8;  			if ((int)(flags [flagIndex] & bit) == 0) {  				_protection.PasswordHash [i - 4] = 0;  			}  			else {  				_protection.PasswordHash [i - 4] = hashNoNulls [i - 4];  			}  		}  	}  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadProjectProperties,The following statement contains a magic number: if (dpb.Length >= 28) {  	byte reserved = dpb [0];  	var flags = new byte[3];  	Array.Copy (dpb' 1' flags' 0' 3);  	var keyNoNulls = new byte[4];  	_protection.PasswordKey = new byte[4];  	Array.Copy (dpb' 4' keyNoNulls' 0' 4);  	var hashNoNulls = new byte[20];  	_protection.PasswordHash = new byte[20];  	Array.Copy (dpb' 8' hashNoNulls' 0' 20);  	//Handle 0x00 bitwise 2.4.4.3   	for (int i = 0; i < 24; i++) {  		int bit = 128 >> (int)((i % 8));  		if (i < 4) {  			if ((int)(flags [0] & bit) == 0) {  				_protection.PasswordKey [i] = 0;  			}  			else {  				_protection.PasswordKey [i] = keyNoNulls [i];  			}  		}  		else {  			int flagIndex = (i - i % 8) / 8;  			if ((int)(flags [flagIndex] & bit) == 0) {  				_protection.PasswordHash [i - 4] = 0;  			}  			else {  				_protection.PasswordHash [i - 4] = hashNoNulls [i - 4];  			}  		}  	}  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadProjectProperties,The following statement contains a magic number: if (dpb.Length >= 28) {  	byte reserved = dpb [0];  	var flags = new byte[3];  	Array.Copy (dpb' 1' flags' 0' 3);  	var keyNoNulls = new byte[4];  	_protection.PasswordKey = new byte[4];  	Array.Copy (dpb' 4' keyNoNulls' 0' 4);  	var hashNoNulls = new byte[20];  	_protection.PasswordHash = new byte[20];  	Array.Copy (dpb' 8' hashNoNulls' 0' 20);  	//Handle 0x00 bitwise 2.4.4.3   	for (int i = 0; i < 24; i++) {  		int bit = 128 >> (int)((i % 8));  		if (i < 4) {  			if ((int)(flags [0] & bit) == 0) {  				_protection.PasswordKey [i] = 0;  			}  			else {  				_protection.PasswordKey [i] = keyNoNulls [i];  			}  		}  		else {  			int flagIndex = (i - i % 8) / 8;  			if ((int)(flags [flagIndex] & bit) == 0) {  				_protection.PasswordHash [i - 4] = 0;  			}  			else {  				_protection.PasswordHash [i - 4] = hashNoNulls [i - 4];  			}  		}  	}  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadProjectProperties,The following statement contains a magic number: if (dpb.Length >= 28) {  	byte reserved = dpb [0];  	var flags = new byte[3];  	Array.Copy (dpb' 1' flags' 0' 3);  	var keyNoNulls = new byte[4];  	_protection.PasswordKey = new byte[4];  	Array.Copy (dpb' 4' keyNoNulls' 0' 4);  	var hashNoNulls = new byte[20];  	_protection.PasswordHash = new byte[20];  	Array.Copy (dpb' 8' hashNoNulls' 0' 20);  	//Handle 0x00 bitwise 2.4.4.3   	for (int i = 0; i < 24; i++) {  		int bit = 128 >> (int)((i % 8));  		if (i < 4) {  			if ((int)(flags [0] & bit) == 0) {  				_protection.PasswordKey [i] = 0;  			}  			else {  				_protection.PasswordKey [i] = keyNoNulls [i];  			}  		}  		else {  			int flagIndex = (i - i % 8) / 8;  			if ((int)(flags [flagIndex] & bit) == 0) {  				_protection.PasswordHash [i - 4] = 0;  			}  			else {  				_protection.PasswordHash [i - 4] = hashNoNulls [i - 4];  			}  		}  	}  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadProjectProperties,The following statement contains a magic number: if (dpb.Length >= 28) {  	byte reserved = dpb [0];  	var flags = new byte[3];  	Array.Copy (dpb' 1' flags' 0' 3);  	var keyNoNulls = new byte[4];  	_protection.PasswordKey = new byte[4];  	Array.Copy (dpb' 4' keyNoNulls' 0' 4);  	var hashNoNulls = new byte[20];  	_protection.PasswordHash = new byte[20];  	Array.Copy (dpb' 8' hashNoNulls' 0' 20);  	//Handle 0x00 bitwise 2.4.4.3   	for (int i = 0; i < 24; i++) {  		int bit = 128 >> (int)((i % 8));  		if (i < 4) {  			if ((int)(flags [0] & bit) == 0) {  				_protection.PasswordKey [i] = 0;  			}  			else {  				_protection.PasswordKey [i] = keyNoNulls [i];  			}  		}  		else {  			int flagIndex = (i - i % 8) / 8;  			if ((int)(flags [flagIndex] & bit) == 0) {  				_protection.PasswordHash [i - 4] = 0;  			}  			else {  				_protection.PasswordHash [i - 4] = hashNoNulls [i - 4];  			}  		}  	}  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadProjectProperties,The following statement contains a magic number: Array.Copy (dpb' 1' flags' 0' 3);  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadProjectProperties,The following statement contains a magic number: _protection.PasswordKey = new byte[4];  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadProjectProperties,The following statement contains a magic number: Array.Copy (dpb' 4' keyNoNulls' 0' 4);  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadProjectProperties,The following statement contains a magic number: Array.Copy (dpb' 4' keyNoNulls' 0' 4);  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadProjectProperties,The following statement contains a magic number: _protection.PasswordHash = new byte[20];  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadProjectProperties,The following statement contains a magic number: Array.Copy (dpb' 8' hashNoNulls' 0' 20);  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadProjectProperties,The following statement contains a magic number: Array.Copy (dpb' 8' hashNoNulls' 0' 20);  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadProjectProperties,The following statement contains a magic number: for (int i = 0; i < 24; i++) {  	int bit = 128 >> (int)((i % 8));  	if (i < 4) {  		if ((int)(flags [0] & bit) == 0) {  			_protection.PasswordKey [i] = 0;  		}  		else {  			_protection.PasswordKey [i] = keyNoNulls [i];  		}  	}  	else {  		int flagIndex = (i - i % 8) / 8;  		if ((int)(flags [flagIndex] & bit) == 0) {  			_protection.PasswordHash [i - 4] = 0;  		}  		else {  			_protection.PasswordHash [i - 4] = hashNoNulls [i - 4];  		}  	}  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadProjectProperties,The following statement contains a magic number: for (int i = 0; i < 24; i++) {  	int bit = 128 >> (int)((i % 8));  	if (i < 4) {  		if ((int)(flags [0] & bit) == 0) {  			_protection.PasswordKey [i] = 0;  		}  		else {  			_protection.PasswordKey [i] = keyNoNulls [i];  		}  	}  	else {  		int flagIndex = (i - i % 8) / 8;  		if ((int)(flags [flagIndex] & bit) == 0) {  			_protection.PasswordHash [i - 4] = 0;  		}  		else {  			_protection.PasswordHash [i - 4] = hashNoNulls [i - 4];  		}  	}  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadProjectProperties,The following statement contains a magic number: for (int i = 0; i < 24; i++) {  	int bit = 128 >> (int)((i % 8));  	if (i < 4) {  		if ((int)(flags [0] & bit) == 0) {  			_protection.PasswordKey [i] = 0;  		}  		else {  			_protection.PasswordKey [i] = keyNoNulls [i];  		}  	}  	else {  		int flagIndex = (i - i % 8) / 8;  		if ((int)(flags [flagIndex] & bit) == 0) {  			_protection.PasswordHash [i - 4] = 0;  		}  		else {  			_protection.PasswordHash [i - 4] = hashNoNulls [i - 4];  		}  	}  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadProjectProperties,The following statement contains a magic number: for (int i = 0; i < 24; i++) {  	int bit = 128 >> (int)((i % 8));  	if (i < 4) {  		if ((int)(flags [0] & bit) == 0) {  			_protection.PasswordKey [i] = 0;  		}  		else {  			_protection.PasswordKey [i] = keyNoNulls [i];  		}  	}  	else {  		int flagIndex = (i - i % 8) / 8;  		if ((int)(flags [flagIndex] & bit) == 0) {  			_protection.PasswordHash [i - 4] = 0;  		}  		else {  			_protection.PasswordHash [i - 4] = hashNoNulls [i - 4];  		}  	}  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadProjectProperties,The following statement contains a magic number: for (int i = 0; i < 24; i++) {  	int bit = 128 >> (int)((i % 8));  	if (i < 4) {  		if ((int)(flags [0] & bit) == 0) {  			_protection.PasswordKey [i] = 0;  		}  		else {  			_protection.PasswordKey [i] = keyNoNulls [i];  		}  	}  	else {  		int flagIndex = (i - i % 8) / 8;  		if ((int)(flags [flagIndex] & bit) == 0) {  			_protection.PasswordHash [i - 4] = 0;  		}  		else {  			_protection.PasswordHash [i - 4] = hashNoNulls [i - 4];  		}  	}  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadProjectProperties,The following statement contains a magic number: for (int i = 0; i < 24; i++) {  	int bit = 128 >> (int)((i % 8));  	if (i < 4) {  		if ((int)(flags [0] & bit) == 0) {  			_protection.PasswordKey [i] = 0;  		}  		else {  			_protection.PasswordKey [i] = keyNoNulls [i];  		}  	}  	else {  		int flagIndex = (i - i % 8) / 8;  		if ((int)(flags [flagIndex] & bit) == 0) {  			_protection.PasswordHash [i - 4] = 0;  		}  		else {  			_protection.PasswordHash [i - 4] = hashNoNulls [i - 4];  		}  	}  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadProjectProperties,The following statement contains a magic number: for (int i = 0; i < 24; i++) {  	int bit = 128 >> (int)((i % 8));  	if (i < 4) {  		if ((int)(flags [0] & bit) == 0) {  			_protection.PasswordKey [i] = 0;  		}  		else {  			_protection.PasswordKey [i] = keyNoNulls [i];  		}  	}  	else {  		int flagIndex = (i - i % 8) / 8;  		if ((int)(flags [flagIndex] & bit) == 0) {  			_protection.PasswordHash [i - 4] = 0;  		}  		else {  			_protection.PasswordHash [i - 4] = hashNoNulls [i - 4];  		}  	}  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadProjectProperties,The following statement contains a magic number: for (int i = 0; i < 24; i++) {  	int bit = 128 >> (int)((i % 8));  	if (i < 4) {  		if ((int)(flags [0] & bit) == 0) {  			_protection.PasswordKey [i] = 0;  		}  		else {  			_protection.PasswordKey [i] = keyNoNulls [i];  		}  	}  	else {  		int flagIndex = (i - i % 8) / 8;  		if ((int)(flags [flagIndex] & bit) == 0) {  			_protection.PasswordHash [i - 4] = 0;  		}  		else {  			_protection.PasswordHash [i - 4] = hashNoNulls [i - 4];  		}  	}  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadProjectProperties,The following statement contains a magic number: for (int i = 0; i < 24; i++) {  	int bit = 128 >> (int)((i % 8));  	if (i < 4) {  		if ((int)(flags [0] & bit) == 0) {  			_protection.PasswordKey [i] = 0;  		}  		else {  			_protection.PasswordKey [i] = keyNoNulls [i];  		}  	}  	else {  		int flagIndex = (i - i % 8) / 8;  		if ((int)(flags [flagIndex] & bit) == 0) {  			_protection.PasswordHash [i - 4] = 0;  		}  		else {  			_protection.PasswordHash [i - 4] = hashNoNulls [i - 4];  		}  	}  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadProjectProperties,The following statement contains a magic number: if (i < 4) {  	if ((int)(flags [0] & bit) == 0) {  		_protection.PasswordKey [i] = 0;  	}  	else {  		_protection.PasswordKey [i] = keyNoNulls [i];  	}  }  else {  	int flagIndex = (i - i % 8) / 8;  	if ((int)(flags [flagIndex] & bit) == 0) {  		_protection.PasswordHash [i - 4] = 0;  	}  	else {  		_protection.PasswordHash [i - 4] = hashNoNulls [i - 4];  	}  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadProjectProperties,The following statement contains a magic number: if (i < 4) {  	if ((int)(flags [0] & bit) == 0) {  		_protection.PasswordKey [i] = 0;  	}  	else {  		_protection.PasswordKey [i] = keyNoNulls [i];  	}  }  else {  	int flagIndex = (i - i % 8) / 8;  	if ((int)(flags [flagIndex] & bit) == 0) {  		_protection.PasswordHash [i - 4] = 0;  	}  	else {  		_protection.PasswordHash [i - 4] = hashNoNulls [i - 4];  	}  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadProjectProperties,The following statement contains a magic number: if (i < 4) {  	if ((int)(flags [0] & bit) == 0) {  		_protection.PasswordKey [i] = 0;  	}  	else {  		_protection.PasswordKey [i] = keyNoNulls [i];  	}  }  else {  	int flagIndex = (i - i % 8) / 8;  	if ((int)(flags [flagIndex] & bit) == 0) {  		_protection.PasswordHash [i - 4] = 0;  	}  	else {  		_protection.PasswordHash [i - 4] = hashNoNulls [i - 4];  	}  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadProjectProperties,The following statement contains a magic number: if (i < 4) {  	if ((int)(flags [0] & bit) == 0) {  		_protection.PasswordKey [i] = 0;  	}  	else {  		_protection.PasswordKey [i] = keyNoNulls [i];  	}  }  else {  	int flagIndex = (i - i % 8) / 8;  	if ((int)(flags [flagIndex] & bit) == 0) {  		_protection.PasswordHash [i - 4] = 0;  	}  	else {  		_protection.PasswordHash [i - 4] = hashNoNulls [i - 4];  	}  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadProjectProperties,The following statement contains a magic number: if (i < 4) {  	if ((int)(flags [0] & bit) == 0) {  		_protection.PasswordKey [i] = 0;  	}  	else {  		_protection.PasswordKey [i] = keyNoNulls [i];  	}  }  else {  	int flagIndex = (i - i % 8) / 8;  	if ((int)(flags [flagIndex] & bit) == 0) {  		_protection.PasswordHash [i - 4] = 0;  	}  	else {  		_protection.PasswordHash [i - 4] = hashNoNulls [i - 4];  	}  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadProjectProperties,The following statement contains a magic number: if (i < 4) {  	if ((int)(flags [0] & bit) == 0) {  		_protection.PasswordKey [i] = 0;  	}  	else {  		_protection.PasswordKey [i] = keyNoNulls [i];  	}  }  else {  	int flagIndex = (i - i % 8) / 8;  	if ((int)(flags [flagIndex] & bit) == 0) {  		_protection.PasswordHash [i - 4] = 0;  	}  	else {  		_protection.PasswordHash [i - 4] = hashNoNulls [i - 4];  	}  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadProjectProperties,The following statement contains a magic number: if ((int)(flags [flagIndex] & bit) == 0) {  	_protection.PasswordHash [i - 4] = 0;  }  else {  	_protection.PasswordHash [i - 4] = hashNoNulls [i - 4];  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadProjectProperties,The following statement contains a magic number: if ((int)(flags [flagIndex] & bit) == 0) {  	_protection.PasswordHash [i - 4] = 0;  }  else {  	_protection.PasswordHash [i - 4] = hashNoNulls [i - 4];  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadProjectProperties,The following statement contains a magic number: if ((int)(flags [flagIndex] & bit) == 0) {  	_protection.PasswordHash [i - 4] = 0;  }  else {  	_protection.PasswordHash [i - 4] = hashNoNulls [i - 4];  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadProjectProperties,The following statement contains a magic number: _protection.PasswordHash [i - 4] = 0;  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadProjectProperties,The following statement contains a magic number: _protection.PasswordHash [i - 4] = hashNoNulls [i - 4];  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadProjectProperties,The following statement contains a magic number: _protection.PasswordHash [i - 4] = hashNoNulls [i - 4];  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,Decrypt,The following statement contains a magic number: dec [1] = (byte)(enc [2] ^ seed);  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,Decrypt,The following statement contains a magic number: for (int i = 2; i < enc.Length - 1; i++) {  	dec [i] = (byte)(enc [i + 1] ^ (enc [i - 1] + dec [i - 1]));  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,Decrypt,The following statement contains a magic number: ignoredLength = (byte)((seed & 6) / 2);  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,Decrypt,The following statement contains a magic number: ignoredLength = (byte)((seed & 6) / 2);  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,Decrypt,The following statement contains a magic number: Array.Copy (dec' 6 + ignoredLength' data' 0' datalength);  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,Encrypt,The following statement contains a magic number: enc [1] = (byte)(2 ^ seed [0]);  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,Encrypt,The following statement contains a magic number: enc [2] = (byte)(projKey ^ seed [0]);  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,Encrypt,The following statement contains a magic number: foreach (var b in ((MemoryStream)br.BaseStream).ToArray ()) {  	enc [pos] = (byte)(b ^ (enc [pos - 2] + pb));  	pos++;  	pb = b;  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,Encrypt,The following statement contains a magic number: enc [pos] = (byte)(b ^ (enc [pos - 2] + pb));  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,GetString,The following statement contains a magic number: for (int i = 0; i <= max; i++) {  	if (value [i] < 16) {  		ret += "0" + value [i].ToString ("x");  	}  	else {  		ret += value [i].ToString ("x");  	}  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,GetString,The following statement contains a magic number: if (value [i] < 16) {  	ret += "0" + value [i].ToString ("x");  }  else {  	ret += value [i].ToString ("x");  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,GetByte,The following statement contains a magic number: for (int i = 0; i < ret.Length; i++) {  	ret [i] = byte.Parse (value.Substring (i * 2' 2)' System.Globalization.NumberStyles.AllowHexSpecifier);  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,GetByte,The following statement contains a magic number: for (int i = 0; i < ret.Length; i++) {  	ret [i] = byte.Parse (value.Substring (i * 2' 2)' System.Globalization.NumberStyles.AllowHexSpecifier);  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,GetByte,The following statement contains a magic number: ret [i] = byte.Parse (value.Substring (i * 2' 2)' System.Globalization.NumberStyles.AllowHexSpecifier);  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,GetByte,The following statement contains a magic number: ret [i] = byte.Parse (value.Substring (i * 2' 2)' System.Globalization.NumberStyles.AllowHexSpecifier);  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadDirStream,The following statement contains a magic number: while (br.BaseStream.Position < br.BaseStream.Length && terminate == false) {  	ushort id = br.ReadUInt16 ();  	uint size = br.ReadUInt32 ();  	switch (id) {  	case 0x01:  		SystemKind = (eSyskind)br.ReadUInt32 ();  		break;  	case 0x02:  		Lcid = (int)br.ReadUInt32 ();  		break;  	case 0x03:  		CodePage = (int)br.ReadUInt16 ();  		break;  	case 0x04:  		Name = GetString (br' size);  		break;  	case 0x05:  		Description = GetUnicodeString (br' size);  		break;  	case 0x06:  		HelpFile1 = GetString (br' size);  		break;  	case 0x3D:  		HelpFile2 = GetString (br' size);  		break;  	case 0x07:  		HelpContextID = (int)br.ReadUInt32 ();  		break;  	case 0x08:  		LibFlags = (int)br.ReadUInt32 ();  		break;  	case 0x09:  		MajorVersion = (int)br.ReadUInt32 ();  		MinorVersion = (int)br.ReadUInt16 ();  		break;  	case 0x0C:  		Constants = GetUnicodeString (br' size);  		break;  	case 0x0D:  		uint sizeLibID = br.ReadUInt32 ();  		var regRef = new ExcelVbaReference ();  		regRef.Name = referenceName;  		regRef.ReferenceRecordID = id;  		regRef.Libid = GetString (br' sizeLibID);  		uint reserved1 = br.ReadUInt32 ();  		ushort reserved2 = br.ReadUInt16 ();  		References.Add (regRef);  		break;  	case 0x0E:  		var projRef = new ExcelVbaReferenceProject ();  		projRef.ReferenceRecordID = id;  		projRef.Name = referenceName;  		sizeLibID = br.ReadUInt32 ();  		projRef.Libid = GetString (br' sizeLibID);  		sizeLibID = br.ReadUInt32 ();  		projRef.LibIdRelative = GetString (br' sizeLibID);  		projRef.MajorVersion = br.ReadUInt32 ();  		projRef.MinorVersion = br.ReadUInt16 ();  		References.Add (projRef);  		break;  	case 0x0F:  		ushort modualCount = br.ReadUInt16 ();  		break;  	case 0x13:  		ushort cookie = br.ReadUInt16 ();  		break;  	case 0x14:  		LcidInvoke = (int)br.ReadUInt32 ();  		break;  	case 0x16:  		referenceName = GetUnicodeString (br' size);  		break;  	case 0x19:  		currentModule = new ExcelVBAModule ();  		currentModule.Name = GetUnicodeString (br' size);  		Modules.Add (currentModule);  		break;  	case 0x1A:  		currentModule.streamName = GetUnicodeString (br' size);  		break;  	case 0x1C:  		currentModule.Description = GetUnicodeString (br' size);  		break;  	case 0x1E:  		currentModule.HelpContext = (int)br.ReadUInt32 ();  		break;  	case 0x21:  	case 0x22:  		break;  	case 0x2B:  		//Modul Terminator  		break;  	case 0x2C:  		currentModule.Cookie = br.ReadUInt16 ();  		break;  	case 0x31:  		currentModule.ModuleOffset = br.ReadUInt32 ();  		break;  	case 0x10:  		terminate = true;  		break;  	case 0x30:  		var extRef = (ExcelVbaReferenceControl)currentRef;  		var sizeExt = br.ReadUInt32 ();  		extRef.LibIdExternal = GetString (br' sizeExt);  		uint reserved4 = br.ReadUInt32 ();  		ushort reserved5 = br.ReadUInt16 ();  		extRef.OriginalTypeLib = new Guid (br.ReadBytes (16));  		extRef.Cookie = br.ReadUInt32 ();  		break;  	case 0x33:  		currentRef = new ExcelVbaReferenceControl ();  		currentRef.ReferenceRecordID = id;  		currentRef.Name = referenceName;  		currentRef.Libid = GetString (br' size);  		References.Add (currentRef);  		break;  	case 0x2F:  		var contrRef = (ExcelVbaReferenceControl)currentRef;  		contrRef.ReferenceRecordID = id;  		var sizeTwiddled = br.ReadUInt32 ();  		contrRef.LibIdTwiddled = GetString (br' sizeTwiddled);  		var r1 = br.ReadUInt32 ();  		var r2 = br.ReadUInt16 ();  		break;  	case 0x25:  		currentModule.ReadOnly = true;  		break;  	case 0x28:  		currentModule.Private = true;  		break;  	default:  		break;  	}  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadDirStream,The following statement contains a magic number: switch (id) {  case 0x01:  	SystemKind = (eSyskind)br.ReadUInt32 ();  	break;  case 0x02:  	Lcid = (int)br.ReadUInt32 ();  	break;  case 0x03:  	CodePage = (int)br.ReadUInt16 ();  	break;  case 0x04:  	Name = GetString (br' size);  	break;  case 0x05:  	Description = GetUnicodeString (br' size);  	break;  case 0x06:  	HelpFile1 = GetString (br' size);  	break;  case 0x3D:  	HelpFile2 = GetString (br' size);  	break;  case 0x07:  	HelpContextID = (int)br.ReadUInt32 ();  	break;  case 0x08:  	LibFlags = (int)br.ReadUInt32 ();  	break;  case 0x09:  	MajorVersion = (int)br.ReadUInt32 ();  	MinorVersion = (int)br.ReadUInt16 ();  	break;  case 0x0C:  	Constants = GetUnicodeString (br' size);  	break;  case 0x0D:  	uint sizeLibID = br.ReadUInt32 ();  	var regRef = new ExcelVbaReference ();  	regRef.Name = referenceName;  	regRef.ReferenceRecordID = id;  	regRef.Libid = GetString (br' sizeLibID);  	uint reserved1 = br.ReadUInt32 ();  	ushort reserved2 = br.ReadUInt16 ();  	References.Add (regRef);  	break;  case 0x0E:  	var projRef = new ExcelVbaReferenceProject ();  	projRef.ReferenceRecordID = id;  	projRef.Name = referenceName;  	sizeLibID = br.ReadUInt32 ();  	projRef.Libid = GetString (br' sizeLibID);  	sizeLibID = br.ReadUInt32 ();  	projRef.LibIdRelative = GetString (br' sizeLibID);  	projRef.MajorVersion = br.ReadUInt32 ();  	projRef.MinorVersion = br.ReadUInt16 ();  	References.Add (projRef);  	break;  case 0x0F:  	ushort modualCount = br.ReadUInt16 ();  	break;  case 0x13:  	ushort cookie = br.ReadUInt16 ();  	break;  case 0x14:  	LcidInvoke = (int)br.ReadUInt32 ();  	break;  case 0x16:  	referenceName = GetUnicodeString (br' size);  	break;  case 0x19:  	currentModule = new ExcelVBAModule ();  	currentModule.Name = GetUnicodeString (br' size);  	Modules.Add (currentModule);  	break;  case 0x1A:  	currentModule.streamName = GetUnicodeString (br' size);  	break;  case 0x1C:  	currentModule.Description = GetUnicodeString (br' size);  	break;  case 0x1E:  	currentModule.HelpContext = (int)br.ReadUInt32 ();  	break;  case 0x21:  case 0x22:  	break;  case 0x2B:  	//Modul Terminator  	break;  case 0x2C:  	currentModule.Cookie = br.ReadUInt16 ();  	break;  case 0x31:  	currentModule.ModuleOffset = br.ReadUInt32 ();  	break;  case 0x10:  	terminate = true;  	break;  case 0x30:  	var extRef = (ExcelVbaReferenceControl)currentRef;  	var sizeExt = br.ReadUInt32 ();  	extRef.LibIdExternal = GetString (br' sizeExt);  	uint reserved4 = br.ReadUInt32 ();  	ushort reserved5 = br.ReadUInt16 ();  	extRef.OriginalTypeLib = new Guid (br.ReadBytes (16));  	extRef.Cookie = br.ReadUInt32 ();  	break;  case 0x33:  	currentRef = new ExcelVbaReferenceControl ();  	currentRef.ReferenceRecordID = id;  	currentRef.Name = referenceName;  	currentRef.Libid = GetString (br' size);  	References.Add (currentRef);  	break;  case 0x2F:  	var contrRef = (ExcelVbaReferenceControl)currentRef;  	contrRef.ReferenceRecordID = id;  	var sizeTwiddled = br.ReadUInt32 ();  	contrRef.LibIdTwiddled = GetString (br' sizeTwiddled);  	var r1 = br.ReadUInt32 ();  	var r2 = br.ReadUInt16 ();  	break;  case 0x25:  	currentModule.ReadOnly = true;  	break;  case 0x28:  	currentModule.Private = true;  	break;  default:  	break;  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadDirStream,The following statement contains a magic number: extRef.OriginalTypeLib = new Guid (br.ReadBytes (16));  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,CreateDirStream,The following statement contains a magic number: bw.Write ((uint)4);  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,CreateDirStream,The following statement contains a magic number: bw.Write ((ushort)2);  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,CreateDirStream,The following statement contains a magic number: bw.Write ((uint)4);  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,CreateDirStream,The following statement contains a magic number: bw.Write ((uint)4);  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,CreateDirStream,The following statement contains a magic number: bw.Write ((ushort)3);  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,CreateDirStream,The following statement contains a magic number: bw.Write ((uint)2);  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,CreateDirStream,The following statement contains a magic number: bw.Write ((ushort)4);  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,CreateDirStream,The following statement contains a magic number: bw.Write ((ushort)5);  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,CreateDirStream,The following statement contains a magic number: bw.Write ((uint)Description.Length * 2);  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,CreateDirStream,The following statement contains a magic number: bw.Write ((ushort)6);  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,CreateDirStream,The following statement contains a magic number: bw.Write ((ushort)7);  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,CreateDirStream,The following statement contains a magic number: bw.Write ((uint)4);  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,CreateDirStream,The following statement contains a magic number: bw.Write ((ushort)8);  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,CreateDirStream,The following statement contains a magic number: bw.Write ((uint)4);  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,CreateDirStream,The following statement contains a magic number: bw.Write ((ushort)9);  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,CreateDirStream,The following statement contains a magic number: bw.Write ((uint)4);  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,CreateDirStream,The following statement contains a magic number: bw.Write ((uint)Constants.Length / 2);  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,WriteModuleRecord,The following statement contains a magic number: bw.Write ((uint)module.Name.Length * 2);  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,WriteModuleRecord,The following statement contains a magic number: bw.Write ((uint)module.Name.Length * 2);  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,WriteModuleRecord,The following statement contains a magic number: bw.Write ((uint)module.Description.Length * 2);  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,WriteModuleRecord,The following statement contains a magic number: bw.Write ((uint)4);  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,WriteModuleRecord,The following statement contains a magic number: bw.Write ((uint)4);  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,WriteModuleRecord,The following statement contains a magic number: bw.Write ((uint)2);  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,WriteNameReference,The following statement contains a magic number: bw.Write ((uint)reference.Name.Length * 2);  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,WriteControlReference,The following statement contains a magic number: bw.Write ((uint)(4 + controlRef.LibIdTwiddled.Length + 4 + 2));  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,WriteControlReference,The following statement contains a magic number: bw.Write ((uint)(4 + controlRef.LibIdTwiddled.Length + 4 + 2));  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,WriteControlReference,The following statement contains a magic number: bw.Write ((uint)(4 + controlRef.LibIdTwiddled.Length + 4 + 2));  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,WriteControlReference,The following statement contains a magic number: bw.Write ((uint)(4 + controlRef.LibIdExternal.Length + 4 + 2 + 16 + 4));  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,WriteControlReference,The following statement contains a magic number: bw.Write ((uint)(4 + controlRef.LibIdExternal.Length + 4 + 2 + 16 + 4));  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,WriteControlReference,The following statement contains a magic number: bw.Write ((uint)(4 + controlRef.LibIdExternal.Length + 4 + 2 + 16 + 4));  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,WriteControlReference,The following statement contains a magic number: bw.Write ((uint)(4 + controlRef.LibIdExternal.Length + 4 + 2 + 16 + 4));  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,WriteControlReference,The following statement contains a magic number: bw.Write ((uint)(4 + controlRef.LibIdExternal.Length + 4 + 2 + 16 + 4));  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,WriteProjectReference,The following statement contains a magic number: bw.Write ((uint)(4 + projRef.Libid.Length + 4 + projRef.LibIdRelative.Length + 4 + 2));  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,WriteProjectReference,The following statement contains a magic number: bw.Write ((uint)(4 + projRef.Libid.Length + 4 + projRef.LibIdRelative.Length + 4 + 2));  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,WriteProjectReference,The following statement contains a magic number: bw.Write ((uint)(4 + projRef.Libid.Length + 4 + projRef.LibIdRelative.Length + 4 + 2));  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,WriteProjectReference,The following statement contains a magic number: bw.Write ((uint)(4 + projRef.Libid.Length + 4 + projRef.LibIdRelative.Length + 4 + 2));  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,WriteRegisteredReference,The following statement contains a magic number: bw.Write ((uint)(4 + reference.Libid.Length + 4 + 2));  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,WriteRegisteredReference,The following statement contains a magic number: bw.Write ((uint)(4 + reference.Libid.Length + 4 + 2));  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,WriteRegisteredReference,The following statement contains a magic number: bw.Write ((uint)(4 + reference.Libid.Length + 4 + 2));  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,WritePassword,The following statement contains a magic number: if (Protection.PasswordKey == null) {  	return Encrypt (new byte[] {  		0  	});  }  else {  	Array.Copy (Protection.PasswordKey' nullKey' 4);  	Array.Copy (Protection.PasswordHash' nullHash' 20);  	//Set Null bits  	for (int i = 0; i < 24; i++) {  		byte bit = (byte)(128 >> (int)((i % 8)));  		if (i < 4) {  			if (nullKey [i] == 0) {  				nullKey [i] = 1;  			}  			else {  				nullBits [0] |= bit;  			}  		}  		else {  			if (nullHash [i - 4] == 0) {  				nullHash [i - 4] = 1;  			}  			else {  				int byteIndex = (i - i % 8) / 8;  				nullBits [byteIndex] |= bit;  			}  		}  	}  	//Write the Password Hash Data Structure (2.4.4.1)  	BinaryWriter bw = new BinaryWriter (new MemoryStream ());  	bw.Write ((byte)0xFF);  	bw.Write (nullBits);  	bw.Write (nullKey);  	bw.Write (nullHash);  	bw.Write ((byte)0);  	return Encrypt (((MemoryStream)bw.BaseStream).ToArray ());  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,WritePassword,The following statement contains a magic number: if (Protection.PasswordKey == null) {  	return Encrypt (new byte[] {  		0  	});  }  else {  	Array.Copy (Protection.PasswordKey' nullKey' 4);  	Array.Copy (Protection.PasswordHash' nullHash' 20);  	//Set Null bits  	for (int i = 0; i < 24; i++) {  		byte bit = (byte)(128 >> (int)((i % 8)));  		if (i < 4) {  			if (nullKey [i] == 0) {  				nullKey [i] = 1;  			}  			else {  				nullBits [0] |= bit;  			}  		}  		else {  			if (nullHash [i - 4] == 0) {  				nullHash [i - 4] = 1;  			}  			else {  				int byteIndex = (i - i % 8) / 8;  				nullBits [byteIndex] |= bit;  			}  		}  	}  	//Write the Password Hash Data Structure (2.4.4.1)  	BinaryWriter bw = new BinaryWriter (new MemoryStream ());  	bw.Write ((byte)0xFF);  	bw.Write (nullBits);  	bw.Write (nullKey);  	bw.Write (nullHash);  	bw.Write ((byte)0);  	return Encrypt (((MemoryStream)bw.BaseStream).ToArray ());  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,WritePassword,The following statement contains a magic number: if (Protection.PasswordKey == null) {  	return Encrypt (new byte[] {  		0  	});  }  else {  	Array.Copy (Protection.PasswordKey' nullKey' 4);  	Array.Copy (Protection.PasswordHash' nullHash' 20);  	//Set Null bits  	for (int i = 0; i < 24; i++) {  		byte bit = (byte)(128 >> (int)((i % 8)));  		if (i < 4) {  			if (nullKey [i] == 0) {  				nullKey [i] = 1;  			}  			else {  				nullBits [0] |= bit;  			}  		}  		else {  			if (nullHash [i - 4] == 0) {  				nullHash [i - 4] = 1;  			}  			else {  				int byteIndex = (i - i % 8) / 8;  				nullBits [byteIndex] |= bit;  			}  		}  	}  	//Write the Password Hash Data Structure (2.4.4.1)  	BinaryWriter bw = new BinaryWriter (new MemoryStream ());  	bw.Write ((byte)0xFF);  	bw.Write (nullBits);  	bw.Write (nullKey);  	bw.Write (nullHash);  	bw.Write ((byte)0);  	return Encrypt (((MemoryStream)bw.BaseStream).ToArray ());  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,WritePassword,The following statement contains a magic number: if (Protection.PasswordKey == null) {  	return Encrypt (new byte[] {  		0  	});  }  else {  	Array.Copy (Protection.PasswordKey' nullKey' 4);  	Array.Copy (Protection.PasswordHash' nullHash' 20);  	//Set Null bits  	for (int i = 0; i < 24; i++) {  		byte bit = (byte)(128 >> (int)((i % 8)));  		if (i < 4) {  			if (nullKey [i] == 0) {  				nullKey [i] = 1;  			}  			else {  				nullBits [0] |= bit;  			}  		}  		else {  			if (nullHash [i - 4] == 0) {  				nullHash [i - 4] = 1;  			}  			else {  				int byteIndex = (i - i % 8) / 8;  				nullBits [byteIndex] |= bit;  			}  		}  	}  	//Write the Password Hash Data Structure (2.4.4.1)  	BinaryWriter bw = new BinaryWriter (new MemoryStream ());  	bw.Write ((byte)0xFF);  	bw.Write (nullBits);  	bw.Write (nullKey);  	bw.Write (nullHash);  	bw.Write ((byte)0);  	return Encrypt (((MemoryStream)bw.BaseStream).ToArray ());  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,WritePassword,The following statement contains a magic number: if (Protection.PasswordKey == null) {  	return Encrypt (new byte[] {  		0  	});  }  else {  	Array.Copy (Protection.PasswordKey' nullKey' 4);  	Array.Copy (Protection.PasswordHash' nullHash' 20);  	//Set Null bits  	for (int i = 0; i < 24; i++) {  		byte bit = (byte)(128 >> (int)((i % 8)));  		if (i < 4) {  			if (nullKey [i] == 0) {  				nullKey [i] = 1;  			}  			else {  				nullBits [0] |= bit;  			}  		}  		else {  			if (nullHash [i - 4] == 0) {  				nullHash [i - 4] = 1;  			}  			else {  				int byteIndex = (i - i % 8) / 8;  				nullBits [byteIndex] |= bit;  			}  		}  	}  	//Write the Password Hash Data Structure (2.4.4.1)  	BinaryWriter bw = new BinaryWriter (new MemoryStream ());  	bw.Write ((byte)0xFF);  	bw.Write (nullBits);  	bw.Write (nullKey);  	bw.Write (nullHash);  	bw.Write ((byte)0);  	return Encrypt (((MemoryStream)bw.BaseStream).ToArray ());  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,WritePassword,The following statement contains a magic number: if (Protection.PasswordKey == null) {  	return Encrypt (new byte[] {  		0  	});  }  else {  	Array.Copy (Protection.PasswordKey' nullKey' 4);  	Array.Copy (Protection.PasswordHash' nullHash' 20);  	//Set Null bits  	for (int i = 0; i < 24; i++) {  		byte bit = (byte)(128 >> (int)((i % 8)));  		if (i < 4) {  			if (nullKey [i] == 0) {  				nullKey [i] = 1;  			}  			else {  				nullBits [0] |= bit;  			}  		}  		else {  			if (nullHash [i - 4] == 0) {  				nullHash [i - 4] = 1;  			}  			else {  				int byteIndex = (i - i % 8) / 8;  				nullBits [byteIndex] |= bit;  			}  		}  	}  	//Write the Password Hash Data Structure (2.4.4.1)  	BinaryWriter bw = new BinaryWriter (new MemoryStream ());  	bw.Write ((byte)0xFF);  	bw.Write (nullBits);  	bw.Write (nullKey);  	bw.Write (nullHash);  	bw.Write ((byte)0);  	return Encrypt (((MemoryStream)bw.BaseStream).ToArray ());  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,WritePassword,The following statement contains a magic number: if (Protection.PasswordKey == null) {  	return Encrypt (new byte[] {  		0  	});  }  else {  	Array.Copy (Protection.PasswordKey' nullKey' 4);  	Array.Copy (Protection.PasswordHash' nullHash' 20);  	//Set Null bits  	for (int i = 0; i < 24; i++) {  		byte bit = (byte)(128 >> (int)((i % 8)));  		if (i < 4) {  			if (nullKey [i] == 0) {  				nullKey [i] = 1;  			}  			else {  				nullBits [0] |= bit;  			}  		}  		else {  			if (nullHash [i - 4] == 0) {  				nullHash [i - 4] = 1;  			}  			else {  				int byteIndex = (i - i % 8) / 8;  				nullBits [byteIndex] |= bit;  			}  		}  	}  	//Write the Password Hash Data Structure (2.4.4.1)  	BinaryWriter bw = new BinaryWriter (new MemoryStream ());  	bw.Write ((byte)0xFF);  	bw.Write (nullBits);  	bw.Write (nullKey);  	bw.Write (nullHash);  	bw.Write ((byte)0);  	return Encrypt (((MemoryStream)bw.BaseStream).ToArray ());  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,WritePassword,The following statement contains a magic number: if (Protection.PasswordKey == null) {  	return Encrypt (new byte[] {  		0  	});  }  else {  	Array.Copy (Protection.PasswordKey' nullKey' 4);  	Array.Copy (Protection.PasswordHash' nullHash' 20);  	//Set Null bits  	for (int i = 0; i < 24; i++) {  		byte bit = (byte)(128 >> (int)((i % 8)));  		if (i < 4) {  			if (nullKey [i] == 0) {  				nullKey [i] = 1;  			}  			else {  				nullBits [0] |= bit;  			}  		}  		else {  			if (nullHash [i - 4] == 0) {  				nullHash [i - 4] = 1;  			}  			else {  				int byteIndex = (i - i % 8) / 8;  				nullBits [byteIndex] |= bit;  			}  		}  	}  	//Write the Password Hash Data Structure (2.4.4.1)  	BinaryWriter bw = new BinaryWriter (new MemoryStream ());  	bw.Write ((byte)0xFF);  	bw.Write (nullBits);  	bw.Write (nullKey);  	bw.Write (nullHash);  	bw.Write ((byte)0);  	return Encrypt (((MemoryStream)bw.BaseStream).ToArray ());  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,WritePassword,The following statement contains a magic number: if (Protection.PasswordKey == null) {  	return Encrypt (new byte[] {  		0  	});  }  else {  	Array.Copy (Protection.PasswordKey' nullKey' 4);  	Array.Copy (Protection.PasswordHash' nullHash' 20);  	//Set Null bits  	for (int i = 0; i < 24; i++) {  		byte bit = (byte)(128 >> (int)((i % 8)));  		if (i < 4) {  			if (nullKey [i] == 0) {  				nullKey [i] = 1;  			}  			else {  				nullBits [0] |= bit;  			}  		}  		else {  			if (nullHash [i - 4] == 0) {  				nullHash [i - 4] = 1;  			}  			else {  				int byteIndex = (i - i % 8) / 8;  				nullBits [byteIndex] |= bit;  			}  		}  	}  	//Write the Password Hash Data Structure (2.4.4.1)  	BinaryWriter bw = new BinaryWriter (new MemoryStream ());  	bw.Write ((byte)0xFF);  	bw.Write (nullBits);  	bw.Write (nullKey);  	bw.Write (nullHash);  	bw.Write ((byte)0);  	return Encrypt (((MemoryStream)bw.BaseStream).ToArray ());  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,WritePassword,The following statement contains a magic number: if (Protection.PasswordKey == null) {  	return Encrypt (new byte[] {  		0  	});  }  else {  	Array.Copy (Protection.PasswordKey' nullKey' 4);  	Array.Copy (Protection.PasswordHash' nullHash' 20);  	//Set Null bits  	for (int i = 0; i < 24; i++) {  		byte bit = (byte)(128 >> (int)((i % 8)));  		if (i < 4) {  			if (nullKey [i] == 0) {  				nullKey [i] = 1;  			}  			else {  				nullBits [0] |= bit;  			}  		}  		else {  			if (nullHash [i - 4] == 0) {  				nullHash [i - 4] = 1;  			}  			else {  				int byteIndex = (i - i % 8) / 8;  				nullBits [byteIndex] |= bit;  			}  		}  	}  	//Write the Password Hash Data Structure (2.4.4.1)  	BinaryWriter bw = new BinaryWriter (new MemoryStream ());  	bw.Write ((byte)0xFF);  	bw.Write (nullBits);  	bw.Write (nullKey);  	bw.Write (nullHash);  	bw.Write ((byte)0);  	return Encrypt (((MemoryStream)bw.BaseStream).ToArray ());  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,WritePassword,The following statement contains a magic number: Array.Copy (Protection.PasswordKey' nullKey' 4);  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,WritePassword,The following statement contains a magic number: Array.Copy (Protection.PasswordHash' nullHash' 20);  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,WritePassword,The following statement contains a magic number: for (int i = 0; i < 24; i++) {  	byte bit = (byte)(128 >> (int)((i % 8)));  	if (i < 4) {  		if (nullKey [i] == 0) {  			nullKey [i] = 1;  		}  		else {  			nullBits [0] |= bit;  		}  	}  	else {  		if (nullHash [i - 4] == 0) {  			nullHash [i - 4] = 1;  		}  		else {  			int byteIndex = (i - i % 8) / 8;  			nullBits [byteIndex] |= bit;  		}  	}  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,WritePassword,The following statement contains a magic number: for (int i = 0; i < 24; i++) {  	byte bit = (byte)(128 >> (int)((i % 8)));  	if (i < 4) {  		if (nullKey [i] == 0) {  			nullKey [i] = 1;  		}  		else {  			nullBits [0] |= bit;  		}  	}  	else {  		if (nullHash [i - 4] == 0) {  			nullHash [i - 4] = 1;  		}  		else {  			int byteIndex = (i - i % 8) / 8;  			nullBits [byteIndex] |= bit;  		}  	}  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,WritePassword,The following statement contains a magic number: for (int i = 0; i < 24; i++) {  	byte bit = (byte)(128 >> (int)((i % 8)));  	if (i < 4) {  		if (nullKey [i] == 0) {  			nullKey [i] = 1;  		}  		else {  			nullBits [0] |= bit;  		}  	}  	else {  		if (nullHash [i - 4] == 0) {  			nullHash [i - 4] = 1;  		}  		else {  			int byteIndex = (i - i % 8) / 8;  			nullBits [byteIndex] |= bit;  		}  	}  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,WritePassword,The following statement contains a magic number: for (int i = 0; i < 24; i++) {  	byte bit = (byte)(128 >> (int)((i % 8)));  	if (i < 4) {  		if (nullKey [i] == 0) {  			nullKey [i] = 1;  		}  		else {  			nullBits [0] |= bit;  		}  	}  	else {  		if (nullHash [i - 4] == 0) {  			nullHash [i - 4] = 1;  		}  		else {  			int byteIndex = (i - i % 8) / 8;  			nullBits [byteIndex] |= bit;  		}  	}  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,WritePassword,The following statement contains a magic number: for (int i = 0; i < 24; i++) {  	byte bit = (byte)(128 >> (int)((i % 8)));  	if (i < 4) {  		if (nullKey [i] == 0) {  			nullKey [i] = 1;  		}  		else {  			nullBits [0] |= bit;  		}  	}  	else {  		if (nullHash [i - 4] == 0) {  			nullHash [i - 4] = 1;  		}  		else {  			int byteIndex = (i - i % 8) / 8;  			nullBits [byteIndex] |= bit;  		}  	}  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,WritePassword,The following statement contains a magic number: for (int i = 0; i < 24; i++) {  	byte bit = (byte)(128 >> (int)((i % 8)));  	if (i < 4) {  		if (nullKey [i] == 0) {  			nullKey [i] = 1;  		}  		else {  			nullBits [0] |= bit;  		}  	}  	else {  		if (nullHash [i - 4] == 0) {  			nullHash [i - 4] = 1;  		}  		else {  			int byteIndex = (i - i % 8) / 8;  			nullBits [byteIndex] |= bit;  		}  	}  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,WritePassword,The following statement contains a magic number: for (int i = 0; i < 24; i++) {  	byte bit = (byte)(128 >> (int)((i % 8)));  	if (i < 4) {  		if (nullKey [i] == 0) {  			nullKey [i] = 1;  		}  		else {  			nullBits [0] |= bit;  		}  	}  	else {  		if (nullHash [i - 4] == 0) {  			nullHash [i - 4] = 1;  		}  		else {  			int byteIndex = (i - i % 8) / 8;  			nullBits [byteIndex] |= bit;  		}  	}  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,WritePassword,The following statement contains a magic number: for (int i = 0; i < 24; i++) {  	byte bit = (byte)(128 >> (int)((i % 8)));  	if (i < 4) {  		if (nullKey [i] == 0) {  			nullKey [i] = 1;  		}  		else {  			nullBits [0] |= bit;  		}  	}  	else {  		if (nullHash [i - 4] == 0) {  			nullHash [i - 4] = 1;  		}  		else {  			int byteIndex = (i - i % 8) / 8;  			nullBits [byteIndex] |= bit;  		}  	}  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,WritePassword,The following statement contains a magic number: if (i < 4) {  	if (nullKey [i] == 0) {  		nullKey [i] = 1;  	}  	else {  		nullBits [0] |= bit;  	}  }  else {  	if (nullHash [i - 4] == 0) {  		nullHash [i - 4] = 1;  	}  	else {  		int byteIndex = (i - i % 8) / 8;  		nullBits [byteIndex] |= bit;  	}  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,WritePassword,The following statement contains a magic number: if (i < 4) {  	if (nullKey [i] == 0) {  		nullKey [i] = 1;  	}  	else {  		nullBits [0] |= bit;  	}  }  else {  	if (nullHash [i - 4] == 0) {  		nullHash [i - 4] = 1;  	}  	else {  		int byteIndex = (i - i % 8) / 8;  		nullBits [byteIndex] |= bit;  	}  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,WritePassword,The following statement contains a magic number: if (i < 4) {  	if (nullKey [i] == 0) {  		nullKey [i] = 1;  	}  	else {  		nullBits [0] |= bit;  	}  }  else {  	if (nullHash [i - 4] == 0) {  		nullHash [i - 4] = 1;  	}  	else {  		int byteIndex = (i - i % 8) / 8;  		nullBits [byteIndex] |= bit;  	}  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,WritePassword,The following statement contains a magic number: if (i < 4) {  	if (nullKey [i] == 0) {  		nullKey [i] = 1;  	}  	else {  		nullBits [0] |= bit;  	}  }  else {  	if (nullHash [i - 4] == 0) {  		nullHash [i - 4] = 1;  	}  	else {  		int byteIndex = (i - i % 8) / 8;  		nullBits [byteIndex] |= bit;  	}  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,WritePassword,The following statement contains a magic number: if (i < 4) {  	if (nullKey [i] == 0) {  		nullKey [i] = 1;  	}  	else {  		nullBits [0] |= bit;  	}  }  else {  	if (nullHash [i - 4] == 0) {  		nullHash [i - 4] = 1;  	}  	else {  		int byteIndex = (i - i % 8) / 8;  		nullBits [byteIndex] |= bit;  	}  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,WritePassword,The following statement contains a magic number: if (nullHash [i - 4] == 0) {  	nullHash [i - 4] = 1;  }  else {  	int byteIndex = (i - i % 8) / 8;  	nullBits [byteIndex] |= bit;  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,WritePassword,The following statement contains a magic number: if (nullHash [i - 4] == 0) {  	nullHash [i - 4] = 1;  }  else {  	int byteIndex = (i - i % 8) / 8;  	nullBits [byteIndex] |= bit;  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,WritePassword,The following statement contains a magic number: if (nullHash [i - 4] == 0) {  	nullHash [i - 4] = 1;  }  else {  	int byteIndex = (i - i % 8) / 8;  	nullBits [byteIndex] |= bit;  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,WritePassword,The following statement contains a magic number: if (nullHash [i - 4] == 0) {  	nullHash [i - 4] = 1;  }  else {  	int byteIndex = (i - i % 8) / 8;  	nullBits [byteIndex] |= bit;  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,WritePassword,The following statement contains a magic number: nullHash [i - 4] = 1;  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,Create,The following statement contains a magic number: Lcid = 1033;  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,Create,The following statement contains a magic number: LcidInvoke = 1033;  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,Create,The following statement contains a magic number: MajorVersion = 1361024421;  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,Create,The following statement contains a magic number: MinorVersion = 6;  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProtection,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProtection.cs,SetPassword,The following statement contains a magic number: if (string.IsNullOrEmpty (Password)) {  	PasswordHash = null;  	PasswordKey = null;  	VbeProtected = false;  	HostProtected = false;  	UserProtected = false;  	VisibilityState = true;  	_project.ProjectID = "{5DD90D76-4904-47A2-AF0D-D69B4673604E}";  }  else {  	//Join Password and Key  	byte[] data;  	//Set the key  	PasswordKey = new byte[4];  	RandomNumberGenerator r = RandomNumberGenerator.Create ();  	r.GetBytes (PasswordKey);  	data = new byte[Password.Length + 4];  	Array.Copy (Encoding.GetEncoding (_project.CodePage).GetBytes (Password)' data' Password.Length);  	VbeProtected = true;  	VisibilityState = false;  	Array.Copy (PasswordKey' 0' data' data.Length - 4' 4);  	//Calculate Hash  	var provider = SHA1.Create ();  	PasswordHash = provider.ComputeHash (data);  	_project.ProjectID = "{00000000-0000-0000-0000-000000000000}";  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProtection,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProtection.cs,SetPassword,The following statement contains a magic number: if (string.IsNullOrEmpty (Password)) {  	PasswordHash = null;  	PasswordKey = null;  	VbeProtected = false;  	HostProtected = false;  	UserProtected = false;  	VisibilityState = true;  	_project.ProjectID = "{5DD90D76-4904-47A2-AF0D-D69B4673604E}";  }  else {  	//Join Password and Key  	byte[] data;  	//Set the key  	PasswordKey = new byte[4];  	RandomNumberGenerator r = RandomNumberGenerator.Create ();  	r.GetBytes (PasswordKey);  	data = new byte[Password.Length + 4];  	Array.Copy (Encoding.GetEncoding (_project.CodePage).GetBytes (Password)' data' Password.Length);  	VbeProtected = true;  	VisibilityState = false;  	Array.Copy (PasswordKey' 0' data' data.Length - 4' 4);  	//Calculate Hash  	var provider = SHA1.Create ();  	PasswordHash = provider.ComputeHash (data);  	_project.ProjectID = "{00000000-0000-0000-0000-000000000000}";  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProtection,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProtection.cs,SetPassword,The following statement contains a magic number: if (string.IsNullOrEmpty (Password)) {  	PasswordHash = null;  	PasswordKey = null;  	VbeProtected = false;  	HostProtected = false;  	UserProtected = false;  	VisibilityState = true;  	_project.ProjectID = "{5DD90D76-4904-47A2-AF0D-D69B4673604E}";  }  else {  	//Join Password and Key  	byte[] data;  	//Set the key  	PasswordKey = new byte[4];  	RandomNumberGenerator r = RandomNumberGenerator.Create ();  	r.GetBytes (PasswordKey);  	data = new byte[Password.Length + 4];  	Array.Copy (Encoding.GetEncoding (_project.CodePage).GetBytes (Password)' data' Password.Length);  	VbeProtected = true;  	VisibilityState = false;  	Array.Copy (PasswordKey' 0' data' data.Length - 4' 4);  	//Calculate Hash  	var provider = SHA1.Create ();  	PasswordHash = provider.ComputeHash (data);  	_project.ProjectID = "{00000000-0000-0000-0000-000000000000}";  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProtection,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProtection.cs,SetPassword,The following statement contains a magic number: if (string.IsNullOrEmpty (Password)) {  	PasswordHash = null;  	PasswordKey = null;  	VbeProtected = false;  	HostProtected = false;  	UserProtected = false;  	VisibilityState = true;  	_project.ProjectID = "{5DD90D76-4904-47A2-AF0D-D69B4673604E}";  }  else {  	//Join Password and Key  	byte[] data;  	//Set the key  	PasswordKey = new byte[4];  	RandomNumberGenerator r = RandomNumberGenerator.Create ();  	r.GetBytes (PasswordKey);  	data = new byte[Password.Length + 4];  	Array.Copy (Encoding.GetEncoding (_project.CodePage).GetBytes (Password)' data' Password.Length);  	VbeProtected = true;  	VisibilityState = false;  	Array.Copy (PasswordKey' 0' data' data.Length - 4' 4);  	//Calculate Hash  	var provider = SHA1.Create ();  	PasswordHash = provider.ComputeHash (data);  	_project.ProjectID = "{00000000-0000-0000-0000-000000000000}";  }  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProtection,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProtection.cs,SetPassword,The following statement contains a magic number: PasswordKey = new byte[4];  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProtection,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProtection.cs,SetPassword,The following statement contains a magic number: data = new byte[Password.Length + 4];  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProtection,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProtection.cs,SetPassword,The following statement contains a magic number: Array.Copy (PasswordKey' 0' data' data.Length - 4' 4);  
Magic Number,OfficeOpenXml.VBA,ExcelVbaProtection,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProtection.cs,SetPassword,The following statement contains a magic number: Array.Copy (PasswordKey' 0' data' data.Length - 4' 4);  
Magic Number,OfficeOpenXml.VBA,ExcelVbaSignature,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaSignature.cs,Save,The following statement contains a magic number: bw.Write ((uint)44);  
Magic Number,OfficeOpenXml.VBA,ExcelVbaSignature,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaSignature.cs,Save,The following statement contains a magic number: bw.Write ((uint)(cert.Length + 44));  
Magic Number,OfficeOpenXml.VBA,ExcelVbaSignature,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaSignature.cs,Save,The following statement contains a magic number: bw.Write ((uint)(cert.Length + certStore.Length + 44));  
Magic Number,OfficeOpenXml.VBA,ExcelVbaSignature,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaSignature.cs,Save,The following statement contains a magic number: bw.Write ((uint)(cert.Length + certStore.Length + 44 + 2));  
Magic Number,OfficeOpenXml.VBA,ExcelVbaSignature,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaSignature.cs,Save,The following statement contains a magic number: bw.Write ((uint)(cert.Length + certStore.Length + 44 + 2));  
Magic Number,OfficeOpenXml.Utils,EncryptionInfo,C:\repos\bambit_EPPlus\EPPlus\Utils\EncryptedPackageHandler.cs,ReadBinary,The following statement contains a magic number: MinorVersion = BitConverter.ToInt16 (data' 2);  
Magic Number,OfficeOpenXml.Utils,EncryptionInfo,C:\repos\bambit_EPPlus\EPPlus\Utils\EncryptedPackageHandler.cs,ReadBinary,The following statement contains a magic number: Flags = (Flags)BitConverter.ToInt32 (data' 4);  
Magic Number,OfficeOpenXml.Utils,EncryptionInfo,C:\repos\bambit_EPPlus\EPPlus\Utils\EncryptedPackageHandler.cs,ReadBinary,The following statement contains a magic number: HeaderSize = (uint)BitConverter.ToInt32 (data' 8);  
Magic Number,OfficeOpenXml.Utils,EncryptionInfo,C:\repos\bambit_EPPlus\EPPlus\Utils\EncryptedPackageHandler.cs,ReadBinary,The following statement contains a magic number: Header.Flags = (Flags)BitConverter.ToInt32 (data' 12);  
Magic Number,OfficeOpenXml.Utils,EncryptionInfo,C:\repos\bambit_EPPlus\EPPlus\Utils\EncryptedPackageHandler.cs,ReadBinary,The following statement contains a magic number: Header.SizeExtra = BitConverter.ToInt32 (data' 16);  
Magic Number,OfficeOpenXml.Utils,EncryptionInfo,C:\repos\bambit_EPPlus\EPPlus\Utils\EncryptedPackageHandler.cs,ReadBinary,The following statement contains a magic number: Header.AlgID = (AlgorithmID)BitConverter.ToInt32 (data' 20);  
Magic Number,OfficeOpenXml.Utils,EncryptionInfo,C:\repos\bambit_EPPlus\EPPlus\Utils\EncryptedPackageHandler.cs,ReadBinary,The following statement contains a magic number: Header.AlgIDHash = (AlgorithmHashID)BitConverter.ToInt32 (data' 24);  
Magic Number,OfficeOpenXml.Utils,EncryptionInfo,C:\repos\bambit_EPPlus\EPPlus\Utils\EncryptedPackageHandler.cs,ReadBinary,The following statement contains a magic number: Header.KeySize = BitConverter.ToInt32 (data' 28);  
Magic Number,OfficeOpenXml.Utils,EncryptionInfo,C:\repos\bambit_EPPlus\EPPlus\Utils\EncryptedPackageHandler.cs,ReadBinary,The following statement contains a magic number: Header.ProviderType = (ProviderType)BitConverter.ToInt32 (data' 32);  
Magic Number,OfficeOpenXml.Utils,EncryptionInfo,C:\repos\bambit_EPPlus\EPPlus\Utils\EncryptedPackageHandler.cs,ReadBinary,The following statement contains a magic number: Header.Reserved1 = BitConverter.ToInt32 (data' 36);  
Magic Number,OfficeOpenXml.Utils,EncryptionInfo,C:\repos\bambit_EPPlus\EPPlus\Utils\EncryptedPackageHandler.cs,ReadBinary,The following statement contains a magic number: Header.Reserved2 = BitConverter.ToInt32 (data' 40);  
Magic Number,OfficeOpenXml.Utils,EncryptionInfo,C:\repos\bambit_EPPlus\EPPlus\Utils\EncryptedPackageHandler.cs,ReadBinary,The following statement contains a magic number: Array.Copy (data' 44' text' 0' (int)HeaderSize - 34);  
Magic Number,OfficeOpenXml.Utils,EncryptionInfo,C:\repos\bambit_EPPlus\EPPlus\Utils\EncryptedPackageHandler.cs,ReadBinary,The following statement contains a magic number: Array.Copy (data' 44' text' 0' (int)HeaderSize - 34);  
Magic Number,OfficeOpenXml.Utils,EncryptionInfo,C:\repos\bambit_EPPlus\EPPlus\Utils\EncryptedPackageHandler.cs,ReadBinary,The following statement contains a magic number: Array.Copy (data' pos + 4' Verifier.Salt' 0' Verifier.SaltSize);  
Magic Number,OfficeOpenXml.Utils,EncryptionInfo,C:\repos\bambit_EPPlus\EPPlus\Utils\EncryptedPackageHandler.cs,ReadBinary,The following statement contains a magic number: Verifier.EncryptedVerifier = new byte[16];  
Magic Number,OfficeOpenXml.Utils,EncryptionInfo,C:\repos\bambit_EPPlus\EPPlus\Utils\EncryptedPackageHandler.cs,ReadBinary,The following statement contains a magic number: Array.Copy (data' pos + 20' Verifier.EncryptedVerifier' 0' 16);  
Magic Number,OfficeOpenXml.Utils,EncryptionInfo,C:\repos\bambit_EPPlus\EPPlus\Utils\EncryptedPackageHandler.cs,ReadBinary,The following statement contains a magic number: Array.Copy (data' pos + 20' Verifier.EncryptedVerifier' 0' 16);  
Magic Number,OfficeOpenXml.Utils,EncryptionInfo,C:\repos\bambit_EPPlus\EPPlus\Utils\EncryptedPackageHandler.cs,ReadBinary,The following statement contains a magic number: Verifier.VerifierHashSize = (uint)BitConverter.ToInt32 (data' pos + 36);  
Magic Number,OfficeOpenXml.Utils,EncryptionInfo,C:\repos\bambit_EPPlus\EPPlus\Utils\EncryptedPackageHandler.cs,ReadBinary,The following statement contains a magic number: Array.Copy (data' pos + 40' Verifier.EncryptedVerifierHash' 0' Verifier.VerifierHashSize);  
Magic Number,OfficeOpenXml.Utils,EncryptedPackageHandler,C:\repos\bambit_EPPlus\EPPlus\Utils\EncryptedPackageHandler.cs,CreateStrongEncryptionDataSpaceStream,The following statement contains a magic number: bw.Write ((int)8);  
Magic Number,OfficeOpenXml.Utils,EncryptedPackageHandler,C:\repos\bambit_EPPlus\EPPlus\Utils\EncryptedPackageHandler.cs,CreateDataSpaceMap,The following statement contains a magic number: bw.Write ((int)8);  
Magic Number,OfficeOpenXml.Utils,EncryptedPackageHandler,C:\repos\bambit_EPPlus\EPPlus\Utils\EncryptedPackageHandler.cs,CreateDataSpaceMap,The following statement contains a magic number: bw.Write ((int)s1.Length * 2);  
Magic Number,OfficeOpenXml.Utils,EncryptedPackageHandler,C:\repos\bambit_EPPlus\EPPlus\Utils\EncryptedPackageHandler.cs,CreateDataSpaceMap,The following statement contains a magic number: bw.Write ((int)(s2.Length - 1) * 2);  
Magic Number,OfficeOpenXml.Utils,EncryptedPackageHandler,C:\repos\bambit_EPPlus\EPPlus\Utils\EncryptedPackageHandler.cs,CreateTransformInfoPrimary,The following statement contains a magic number: bw.Write (TransformID.Length * 2 + 12);  
Magic Number,OfficeOpenXml.Utils,EncryptedPackageHandler,C:\repos\bambit_EPPlus\EPPlus\Utils\EncryptedPackageHandler.cs,CreateTransformInfoPrimary,The following statement contains a magic number: bw.Write (TransformID.Length * 2 + 12);  
Magic Number,OfficeOpenXml.Utils,EncryptedPackageHandler,C:\repos\bambit_EPPlus\EPPlus\Utils\EncryptedPackageHandler.cs,CreateTransformInfoPrimary,The following statement contains a magic number: bw.Write (TransformID.Length * 2);  
Magic Number,OfficeOpenXml.Utils,EncryptedPackageHandler,C:\repos\bambit_EPPlus\EPPlus\Utils\EncryptedPackageHandler.cs,CreateTransformInfoPrimary,The following statement contains a magic number: bw.Write (TransformName.Length * 2);  
Magic Number,OfficeOpenXml.Utils,EncryptedPackageHandler,C:\repos\bambit_EPPlus\EPPlus\Utils\EncryptedPackageHandler.cs,CreateTransformInfoPrimary,The following statement contains a magic number: bw.Write ((int)4);  
Magic Number,OfficeOpenXml.Utils,EncryptedPackageHandler,C:\repos\bambit_EPPlus\EPPlus\Utils\EncryptedPackageHandler.cs,CreateEncryptionInfo,The following statement contains a magic number: encryptionInfo.MajorVersion = 4;  
Magic Number,OfficeOpenXml.Utils,EncryptedPackageHandler,C:\repos\bambit_EPPlus\EPPlus\Utils\EncryptedPackageHandler.cs,CreateEncryptionInfo,The following statement contains a magic number: encryptionInfo.MinorVersion = 2;  
Magic Number,OfficeOpenXml.Utils,EncryptedPackageHandler,C:\repos\bambit_EPPlus\EPPlus\Utils\EncryptedPackageHandler.cs,CreateEncryptionInfo,The following statement contains a magic number: encryptionInfo.Verifier.Salt = new byte[16];  
Magic Number,OfficeOpenXml.Utils,EncryptedPackageHandler,C:\repos\bambit_EPPlus\EPPlus\Utils\EncryptedPackageHandler.cs,EncryptData,The following statement contains a magic number: aes.KeySize = key.Length * 8;  
Magic Number,OfficeOpenXml.Utils,EncryptedPackageHandler,C:\repos\bambit_EPPlus\EPPlus\Utils\EncryptedPackageHandler.cs,DecryptDocument,The following statement contains a magic number: Array.Copy (data' 8' encryptedData' 0' encryptedData.Length);  
Magic Number,OfficeOpenXml.Utils,EncryptedPackageHandler,C:\repos\bambit_EPPlus\EPPlus\Utils\EncryptedPackageHandler.cs,IsPasswordValid,The following statement contains a magic number: cryptoStream.Read (decryptedVerifier' 0' 16);  
Magic Number,OfficeOpenXml.Utils,EncryptedPackageHandler,C:\repos\bambit_EPPlus\EPPlus\Utils\EncryptedPackageHandler.cs,IsPasswordValid,The following statement contains a magic number: cryptoStream.Read (decryptedVerifierHash' 0' (int)16);  
Magic Number,OfficeOpenXml.Utils,EncryptedPackageHandler,C:\repos\bambit_EPPlus\EPPlus\Utils\EncryptedPackageHandler.cs,IsPasswordValid,The following statement contains a magic number: for (int i = 0; i < 16; i++) {  	if (hash [i] != decryptedVerifierHash [i]) {  		return false;  	}  }  
Magic Number,OfficeOpenXml.Utils,EncryptedPackageHandler,C:\repos\bambit_EPPlus\EPPlus\Utils\EncryptedPackageHandler.cs,GetPasswordHash,The following statement contains a magic number: try {  	HashAlgorithm hashProvider;  	if (encryptionInfo.Header.AlgIDHash == AlgorithmHashID.SHA1 || encryptionInfo.Header.AlgIDHash == AlgorithmHashID.App && (encryptionInfo.Flags & Flags.fExternal) == 0) {  		hashProvider = new SHA1CryptoServiceProvider ();  	}  	else if (encryptionInfo.Header.KeySize > 0 && encryptionInfo.Header.KeySize < 80) {  		throw new NotSupportedException ("RC4 Hash provider is not supported. Must be SHA1(AlgIDHash == 0x8004)");  	}  	else {  		throw new NotSupportedException ("Hash provider is invalid. Must be SHA1(AlgIDHash == 0x8004)");  	}  	hash = hashProvider.ComputeHash (CombinePassword (encryptionInfo.Verifier.Salt' password));  	//Iterate 50 000 times' inserting i in first 4 bytes and then the prev. hash in byte 5-24  	for (int i = 0; i < 50000; i++) {  		Array.Copy (BitConverter.GetBytes (i)' tempHash' 4);  		Array.Copy (hash' 0' tempHash' 4' hash.Length);  		hash = hashProvider.ComputeHash (tempHash);  	}  	// Append "block" (0)  	Array.Copy (hash' tempHash' hash.Length);  	Array.Copy (System.BitConverter.GetBytes (0)' 0' tempHash' hash.Length' 4);  	hash = hashProvider.ComputeHash (tempHash);  	/***** Now use the derived key algorithm *****/byte[] derivedKey = new byte[64];  	int keySizeBytes = encryptionInfo.Header.KeySize / 8;  	//First XOR hash bytes with 0x36 and fill the rest with 0x36  	for (int i = 0; i < derivedKey.Length; i++)  		derivedKey [i] = (byte)(i < hash.Length ? 0x36 ^ hash [i] : 0x36);  	byte[] X1 = hashProvider.ComputeHash (derivedKey);  	//if verifier size is bigger than the key size we can return X1  	if (encryptionInfo.Verifier.VerifierHashSize > keySizeBytes)  		return FixHashSize (X1' keySizeBytes);  	//Else XOR hash bytes with 0x5C and fill the rest with 0x5C  	for (int i = 0; i < derivedKey.Length; i++)  		derivedKey [i] = (byte)(i < hash.Length ? 0x5C ^ hash [i] : 0x5C);  	byte[] X2 = hashProvider.ComputeHash (derivedKey);  	//Join the two and return   	byte[] join = new byte[X1.Length + X2.Length];  	Array.Copy (X1' 0' join' 0' X1.Length);  	Array.Copy (X2' 0' join' X1.Length' X2.Length);  	return FixHashSize (join' keySizeBytes);  }  catch (Exception ex) {  	throw (new Exception ("An error occured when the encryptionkey was created"' ex));  }  
Magic Number,OfficeOpenXml.Utils,EncryptedPackageHandler,C:\repos\bambit_EPPlus\EPPlus\Utils\EncryptedPackageHandler.cs,GetPasswordHash,The following statement contains a magic number: try {  	HashAlgorithm hashProvider;  	if (encryptionInfo.Header.AlgIDHash == AlgorithmHashID.SHA1 || encryptionInfo.Header.AlgIDHash == AlgorithmHashID.App && (encryptionInfo.Flags & Flags.fExternal) == 0) {  		hashProvider = new SHA1CryptoServiceProvider ();  	}  	else if (encryptionInfo.Header.KeySize > 0 && encryptionInfo.Header.KeySize < 80) {  		throw new NotSupportedException ("RC4 Hash provider is not supported. Must be SHA1(AlgIDHash == 0x8004)");  	}  	else {  		throw new NotSupportedException ("Hash provider is invalid. Must be SHA1(AlgIDHash == 0x8004)");  	}  	hash = hashProvider.ComputeHash (CombinePassword (encryptionInfo.Verifier.Salt' password));  	//Iterate 50 000 times' inserting i in first 4 bytes and then the prev. hash in byte 5-24  	for (int i = 0; i < 50000; i++) {  		Array.Copy (BitConverter.GetBytes (i)' tempHash' 4);  		Array.Copy (hash' 0' tempHash' 4' hash.Length);  		hash = hashProvider.ComputeHash (tempHash);  	}  	// Append "block" (0)  	Array.Copy (hash' tempHash' hash.Length);  	Array.Copy (System.BitConverter.GetBytes (0)' 0' tempHash' hash.Length' 4);  	hash = hashProvider.ComputeHash (tempHash);  	/***** Now use the derived key algorithm *****/byte[] derivedKey = new byte[64];  	int keySizeBytes = encryptionInfo.Header.KeySize / 8;  	//First XOR hash bytes with 0x36 and fill the rest with 0x36  	for (int i = 0; i < derivedKey.Length; i++)  		derivedKey [i] = (byte)(i < hash.Length ? 0x36 ^ hash [i] : 0x36);  	byte[] X1 = hashProvider.ComputeHash (derivedKey);  	//if verifier size is bigger than the key size we can return X1  	if (encryptionInfo.Verifier.VerifierHashSize > keySizeBytes)  		return FixHashSize (X1' keySizeBytes);  	//Else XOR hash bytes with 0x5C and fill the rest with 0x5C  	for (int i = 0; i < derivedKey.Length; i++)  		derivedKey [i] = (byte)(i < hash.Length ? 0x5C ^ hash [i] : 0x5C);  	byte[] X2 = hashProvider.ComputeHash (derivedKey);  	//Join the two and return   	byte[] join = new byte[X1.Length + X2.Length];  	Array.Copy (X1' 0' join' 0' X1.Length);  	Array.Copy (X2' 0' join' X1.Length' X2.Length);  	return FixHashSize (join' keySizeBytes);  }  catch (Exception ex) {  	throw (new Exception ("An error occured when the encryptionkey was created"' ex));  }  
Magic Number,OfficeOpenXml.Utils,EncryptedPackageHandler,C:\repos\bambit_EPPlus\EPPlus\Utils\EncryptedPackageHandler.cs,GetPasswordHash,The following statement contains a magic number: try {  	HashAlgorithm hashProvider;  	if (encryptionInfo.Header.AlgIDHash == AlgorithmHashID.SHA1 || encryptionInfo.Header.AlgIDHash == AlgorithmHashID.App && (encryptionInfo.Flags & Flags.fExternal) == 0) {  		hashProvider = new SHA1CryptoServiceProvider ();  	}  	else if (encryptionInfo.Header.KeySize > 0 && encryptionInfo.Header.KeySize < 80) {  		throw new NotSupportedException ("RC4 Hash provider is not supported. Must be SHA1(AlgIDHash == 0x8004)");  	}  	else {  		throw new NotSupportedException ("Hash provider is invalid. Must be SHA1(AlgIDHash == 0x8004)");  	}  	hash = hashProvider.ComputeHash (CombinePassword (encryptionInfo.Verifier.Salt' password));  	//Iterate 50 000 times' inserting i in first 4 bytes and then the prev. hash in byte 5-24  	for (int i = 0; i < 50000; i++) {  		Array.Copy (BitConverter.GetBytes (i)' tempHash' 4);  		Array.Copy (hash' 0' tempHash' 4' hash.Length);  		hash = hashProvider.ComputeHash (tempHash);  	}  	// Append "block" (0)  	Array.Copy (hash' tempHash' hash.Length);  	Array.Copy (System.BitConverter.GetBytes (0)' 0' tempHash' hash.Length' 4);  	hash = hashProvider.ComputeHash (tempHash);  	/***** Now use the derived key algorithm *****/byte[] derivedKey = new byte[64];  	int keySizeBytes = encryptionInfo.Header.KeySize / 8;  	//First XOR hash bytes with 0x36 and fill the rest with 0x36  	for (int i = 0; i < derivedKey.Length; i++)  		derivedKey [i] = (byte)(i < hash.Length ? 0x36 ^ hash [i] : 0x36);  	byte[] X1 = hashProvider.ComputeHash (derivedKey);  	//if verifier size is bigger than the key size we can return X1  	if (encryptionInfo.Verifier.VerifierHashSize > keySizeBytes)  		return FixHashSize (X1' keySizeBytes);  	//Else XOR hash bytes with 0x5C and fill the rest with 0x5C  	for (int i = 0; i < derivedKey.Length; i++)  		derivedKey [i] = (byte)(i < hash.Length ? 0x5C ^ hash [i] : 0x5C);  	byte[] X2 = hashProvider.ComputeHash (derivedKey);  	//Join the two and return   	byte[] join = new byte[X1.Length + X2.Length];  	Array.Copy (X1' 0' join' 0' X1.Length);  	Array.Copy (X2' 0' join' X1.Length' X2.Length);  	return FixHashSize (join' keySizeBytes);  }  catch (Exception ex) {  	throw (new Exception ("An error occured when the encryptionkey was created"' ex));  }  
Magic Number,OfficeOpenXml.Utils,EncryptedPackageHandler,C:\repos\bambit_EPPlus\EPPlus\Utils\EncryptedPackageHandler.cs,GetPasswordHash,The following statement contains a magic number: try {  	HashAlgorithm hashProvider;  	if (encryptionInfo.Header.AlgIDHash == AlgorithmHashID.SHA1 || encryptionInfo.Header.AlgIDHash == AlgorithmHashID.App && (encryptionInfo.Flags & Flags.fExternal) == 0) {  		hashProvider = new SHA1CryptoServiceProvider ();  	}  	else if (encryptionInfo.Header.KeySize > 0 && encryptionInfo.Header.KeySize < 80) {  		throw new NotSupportedException ("RC4 Hash provider is not supported. Must be SHA1(AlgIDHash == 0x8004)");  	}  	else {  		throw new NotSupportedException ("Hash provider is invalid. Must be SHA1(AlgIDHash == 0x8004)");  	}  	hash = hashProvider.ComputeHash (CombinePassword (encryptionInfo.Verifier.Salt' password));  	//Iterate 50 000 times' inserting i in first 4 bytes and then the prev. hash in byte 5-24  	for (int i = 0; i < 50000; i++) {  		Array.Copy (BitConverter.GetBytes (i)' tempHash' 4);  		Array.Copy (hash' 0' tempHash' 4' hash.Length);  		hash = hashProvider.ComputeHash (tempHash);  	}  	// Append "block" (0)  	Array.Copy (hash' tempHash' hash.Length);  	Array.Copy (System.BitConverter.GetBytes (0)' 0' tempHash' hash.Length' 4);  	hash = hashProvider.ComputeHash (tempHash);  	/***** Now use the derived key algorithm *****/byte[] derivedKey = new byte[64];  	int keySizeBytes = encryptionInfo.Header.KeySize / 8;  	//First XOR hash bytes with 0x36 and fill the rest with 0x36  	for (int i = 0; i < derivedKey.Length; i++)  		derivedKey [i] = (byte)(i < hash.Length ? 0x36 ^ hash [i] : 0x36);  	byte[] X1 = hashProvider.ComputeHash (derivedKey);  	//if verifier size is bigger than the key size we can return X1  	if (encryptionInfo.Verifier.VerifierHashSize > keySizeBytes)  		return FixHashSize (X1' keySizeBytes);  	//Else XOR hash bytes with 0x5C and fill the rest with 0x5C  	for (int i = 0; i < derivedKey.Length; i++)  		derivedKey [i] = (byte)(i < hash.Length ? 0x5C ^ hash [i] : 0x5C);  	byte[] X2 = hashProvider.ComputeHash (derivedKey);  	//Join the two and return   	byte[] join = new byte[X1.Length + X2.Length];  	Array.Copy (X1' 0' join' 0' X1.Length);  	Array.Copy (X2' 0' join' X1.Length' X2.Length);  	return FixHashSize (join' keySizeBytes);  }  catch (Exception ex) {  	throw (new Exception ("An error occured when the encryptionkey was created"' ex));  }  
Magic Number,OfficeOpenXml.Utils,EncryptedPackageHandler,C:\repos\bambit_EPPlus\EPPlus\Utils\EncryptedPackageHandler.cs,GetPasswordHash,The following statement contains a magic number: try {  	HashAlgorithm hashProvider;  	if (encryptionInfo.Header.AlgIDHash == AlgorithmHashID.SHA1 || encryptionInfo.Header.AlgIDHash == AlgorithmHashID.App && (encryptionInfo.Flags & Flags.fExternal) == 0) {  		hashProvider = new SHA1CryptoServiceProvider ();  	}  	else if (encryptionInfo.Header.KeySize > 0 && encryptionInfo.Header.KeySize < 80) {  		throw new NotSupportedException ("RC4 Hash provider is not supported. Must be SHA1(AlgIDHash == 0x8004)");  	}  	else {  		throw new NotSupportedException ("Hash provider is invalid. Must be SHA1(AlgIDHash == 0x8004)");  	}  	hash = hashProvider.ComputeHash (CombinePassword (encryptionInfo.Verifier.Salt' password));  	//Iterate 50 000 times' inserting i in first 4 bytes and then the prev. hash in byte 5-24  	for (int i = 0; i < 50000; i++) {  		Array.Copy (BitConverter.GetBytes (i)' tempHash' 4);  		Array.Copy (hash' 0' tempHash' 4' hash.Length);  		hash = hashProvider.ComputeHash (tempHash);  	}  	// Append "block" (0)  	Array.Copy (hash' tempHash' hash.Length);  	Array.Copy (System.BitConverter.GetBytes (0)' 0' tempHash' hash.Length' 4);  	hash = hashProvider.ComputeHash (tempHash);  	/***** Now use the derived key algorithm *****/byte[] derivedKey = new byte[64];  	int keySizeBytes = encryptionInfo.Header.KeySize / 8;  	//First XOR hash bytes with 0x36 and fill the rest with 0x36  	for (int i = 0; i < derivedKey.Length; i++)  		derivedKey [i] = (byte)(i < hash.Length ? 0x36 ^ hash [i] : 0x36);  	byte[] X1 = hashProvider.ComputeHash (derivedKey);  	//if verifier size is bigger than the key size we can return X1  	if (encryptionInfo.Verifier.VerifierHashSize > keySizeBytes)  		return FixHashSize (X1' keySizeBytes);  	//Else XOR hash bytes with 0x5C and fill the rest with 0x5C  	for (int i = 0; i < derivedKey.Length; i++)  		derivedKey [i] = (byte)(i < hash.Length ? 0x5C ^ hash [i] : 0x5C);  	byte[] X2 = hashProvider.ComputeHash (derivedKey);  	//Join the two and return   	byte[] join = new byte[X1.Length + X2.Length];  	Array.Copy (X1' 0' join' 0' X1.Length);  	Array.Copy (X2' 0' join' X1.Length' X2.Length);  	return FixHashSize (join' keySizeBytes);  }  catch (Exception ex) {  	throw (new Exception ("An error occured when the encryptionkey was created"' ex));  }  
Magic Number,OfficeOpenXml.Utils,EncryptedPackageHandler,C:\repos\bambit_EPPlus\EPPlus\Utils\EncryptedPackageHandler.cs,GetPasswordHash,The following statement contains a magic number: try {  	HashAlgorithm hashProvider;  	if (encryptionInfo.Header.AlgIDHash == AlgorithmHashID.SHA1 || encryptionInfo.Header.AlgIDHash == AlgorithmHashID.App && (encryptionInfo.Flags & Flags.fExternal) == 0) {  		hashProvider = new SHA1CryptoServiceProvider ();  	}  	else if (encryptionInfo.Header.KeySize > 0 && encryptionInfo.Header.KeySize < 80) {  		throw new NotSupportedException ("RC4 Hash provider is not supported. Must be SHA1(AlgIDHash == 0x8004)");  	}  	else {  		throw new NotSupportedException ("Hash provider is invalid. Must be SHA1(AlgIDHash == 0x8004)");  	}  	hash = hashProvider.ComputeHash (CombinePassword (encryptionInfo.Verifier.Salt' password));  	//Iterate 50 000 times' inserting i in first 4 bytes and then the prev. hash in byte 5-24  	for (int i = 0; i < 50000; i++) {  		Array.Copy (BitConverter.GetBytes (i)' tempHash' 4);  		Array.Copy (hash' 0' tempHash' 4' hash.Length);  		hash = hashProvider.ComputeHash (tempHash);  	}  	// Append "block" (0)  	Array.Copy (hash' tempHash' hash.Length);  	Array.Copy (System.BitConverter.GetBytes (0)' 0' tempHash' hash.Length' 4);  	hash = hashProvider.ComputeHash (tempHash);  	/***** Now use the derived key algorithm *****/byte[] derivedKey = new byte[64];  	int keySizeBytes = encryptionInfo.Header.KeySize / 8;  	//First XOR hash bytes with 0x36 and fill the rest with 0x36  	for (int i = 0; i < derivedKey.Length; i++)  		derivedKey [i] = (byte)(i < hash.Length ? 0x36 ^ hash [i] : 0x36);  	byte[] X1 = hashProvider.ComputeHash (derivedKey);  	//if verifier size is bigger than the key size we can return X1  	if (encryptionInfo.Verifier.VerifierHashSize > keySizeBytes)  		return FixHashSize (X1' keySizeBytes);  	//Else XOR hash bytes with 0x5C and fill the rest with 0x5C  	for (int i = 0; i < derivedKey.Length; i++)  		derivedKey [i] = (byte)(i < hash.Length ? 0x5C ^ hash [i] : 0x5C);  	byte[] X2 = hashProvider.ComputeHash (derivedKey);  	//Join the two and return   	byte[] join = new byte[X1.Length + X2.Length];  	Array.Copy (X1' 0' join' 0' X1.Length);  	Array.Copy (X2' 0' join' X1.Length' X2.Length);  	return FixHashSize (join' keySizeBytes);  }  catch (Exception ex) {  	throw (new Exception ("An error occured when the encryptionkey was created"' ex));  }  
Magic Number,OfficeOpenXml.Utils,EncryptedPackageHandler,C:\repos\bambit_EPPlus\EPPlus\Utils\EncryptedPackageHandler.cs,GetPasswordHash,The following statement contains a magic number: try {  	HashAlgorithm hashProvider;  	if (encryptionInfo.Header.AlgIDHash == AlgorithmHashID.SHA1 || encryptionInfo.Header.AlgIDHash == AlgorithmHashID.App && (encryptionInfo.Flags & Flags.fExternal) == 0) {  		hashProvider = new SHA1CryptoServiceProvider ();  	}  	else if (encryptionInfo.Header.KeySize > 0 && encryptionInfo.Header.KeySize < 80) {  		throw new NotSupportedException ("RC4 Hash provider is not supported. Must be SHA1(AlgIDHash == 0x8004)");  	}  	else {  		throw new NotSupportedException ("Hash provider is invalid. Must be SHA1(AlgIDHash == 0x8004)");  	}  	hash = hashProvider.ComputeHash (CombinePassword (encryptionInfo.Verifier.Salt' password));  	//Iterate 50 000 times' inserting i in first 4 bytes and then the prev. hash in byte 5-24  	for (int i = 0; i < 50000; i++) {  		Array.Copy (BitConverter.GetBytes (i)' tempHash' 4);  		Array.Copy (hash' 0' tempHash' 4' hash.Length);  		hash = hashProvider.ComputeHash (tempHash);  	}  	// Append "block" (0)  	Array.Copy (hash' tempHash' hash.Length);  	Array.Copy (System.BitConverter.GetBytes (0)' 0' tempHash' hash.Length' 4);  	hash = hashProvider.ComputeHash (tempHash);  	/***** Now use the derived key algorithm *****/byte[] derivedKey = new byte[64];  	int keySizeBytes = encryptionInfo.Header.KeySize / 8;  	//First XOR hash bytes with 0x36 and fill the rest with 0x36  	for (int i = 0; i < derivedKey.Length; i++)  		derivedKey [i] = (byte)(i < hash.Length ? 0x36 ^ hash [i] : 0x36);  	byte[] X1 = hashProvider.ComputeHash (derivedKey);  	//if verifier size is bigger than the key size we can return X1  	if (encryptionInfo.Verifier.VerifierHashSize > keySizeBytes)  		return FixHashSize (X1' keySizeBytes);  	//Else XOR hash bytes with 0x5C and fill the rest with 0x5C  	for (int i = 0; i < derivedKey.Length; i++)  		derivedKey [i] = (byte)(i < hash.Length ? 0x5C ^ hash [i] : 0x5C);  	byte[] X2 = hashProvider.ComputeHash (derivedKey);  	//Join the two and return   	byte[] join = new byte[X1.Length + X2.Length];  	Array.Copy (X1' 0' join' 0' X1.Length);  	Array.Copy (X2' 0' join' X1.Length' X2.Length);  	return FixHashSize (join' keySizeBytes);  }  catch (Exception ex) {  	throw (new Exception ("An error occured when the encryptionkey was created"' ex));  }  
Magic Number,OfficeOpenXml.Utils,EncryptedPackageHandler,C:\repos\bambit_EPPlus\EPPlus\Utils\EncryptedPackageHandler.cs,GetPasswordHash,The following statement contains a magic number: if (encryptionInfo.Header.AlgIDHash == AlgorithmHashID.SHA1 || encryptionInfo.Header.AlgIDHash == AlgorithmHashID.App && (encryptionInfo.Flags & Flags.fExternal) == 0) {  	hashProvider = new SHA1CryptoServiceProvider ();  }  else if (encryptionInfo.Header.KeySize > 0 && encryptionInfo.Header.KeySize < 80) {  	throw new NotSupportedException ("RC4 Hash provider is not supported. Must be SHA1(AlgIDHash == 0x8004)");  }  else {  	throw new NotSupportedException ("Hash provider is invalid. Must be SHA1(AlgIDHash == 0x8004)");  }  
Magic Number,OfficeOpenXml.Utils,EncryptedPackageHandler,C:\repos\bambit_EPPlus\EPPlus\Utils\EncryptedPackageHandler.cs,GetPasswordHash,The following statement contains a magic number: if (encryptionInfo.Header.KeySize > 0 && encryptionInfo.Header.KeySize < 80) {  	throw new NotSupportedException ("RC4 Hash provider is not supported. Must be SHA1(AlgIDHash == 0x8004)");  }  else {  	throw new NotSupportedException ("Hash provider is invalid. Must be SHA1(AlgIDHash == 0x8004)");  }  
Magic Number,OfficeOpenXml.Utils,EncryptedPackageHandler,C:\repos\bambit_EPPlus\EPPlus\Utils\EncryptedPackageHandler.cs,GetPasswordHash,The following statement contains a magic number: for (int i = 0; i < 50000; i++) {  	Array.Copy (BitConverter.GetBytes (i)' tempHash' 4);  	Array.Copy (hash' 0' tempHash' 4' hash.Length);  	hash = hashProvider.ComputeHash (tempHash);  }  
Magic Number,OfficeOpenXml.Utils,EncryptedPackageHandler,C:\repos\bambit_EPPlus\EPPlus\Utils\EncryptedPackageHandler.cs,GetPasswordHash,The following statement contains a magic number: for (int i = 0; i < 50000; i++) {  	Array.Copy (BitConverter.GetBytes (i)' tempHash' 4);  	Array.Copy (hash' 0' tempHash' 4' hash.Length);  	hash = hashProvider.ComputeHash (tempHash);  }  
Magic Number,OfficeOpenXml.Utils,EncryptedPackageHandler,C:\repos\bambit_EPPlus\EPPlus\Utils\EncryptedPackageHandler.cs,GetPasswordHash,The following statement contains a magic number: for (int i = 0; i < 50000; i++) {  	Array.Copy (BitConverter.GetBytes (i)' tempHash' 4);  	Array.Copy (hash' 0' tempHash' 4' hash.Length);  	hash = hashProvider.ComputeHash (tempHash);  }  
Magic Number,OfficeOpenXml.Utils,EncryptedPackageHandler,C:\repos\bambit_EPPlus\EPPlus\Utils\EncryptedPackageHandler.cs,GetPasswordHash,The following statement contains a magic number: Array.Copy (BitConverter.GetBytes (i)' tempHash' 4);  
Magic Number,OfficeOpenXml.Utils,EncryptedPackageHandler,C:\repos\bambit_EPPlus\EPPlus\Utils\EncryptedPackageHandler.cs,GetPasswordHash,The following statement contains a magic number: Array.Copy (hash' 0' tempHash' 4' hash.Length);  
Magic Number,OfficeOpenXml.Utils,EncryptedPackageHandler,C:\repos\bambit_EPPlus\EPPlus\Utils\EncryptedPackageHandler.cs,GetPasswordHash,The following statement contains a magic number: Array.Copy (System.BitConverter.GetBytes (0)' 0' tempHash' hash.Length' 4);  
Magic Number,OfficeOpenXml.Utils,EncryptedPackageHandler,C:\repos\bambit_EPPlus\EPPlus\Utils\EncryptedPackageHandler.cs,CalculatePasswordHash,The following statement contains a magic number: for (int i = Password.Length - 1; i >= 0; i--) {  	hash ^= Password [i];  	hash = (ushort)(((ushort)((hash >> 14) & 0x01)) | ((ushort)((hash << 1) & 0x7FFF)));  	//Shift 1 to the left. Overflowing bit 15 goes into bit 0  }  
Magic Number,OfficeOpenXml.Utils,EncryptedPackageHandler,C:\repos\bambit_EPPlus\EPPlus\Utils\EncryptedPackageHandler.cs,CalculatePasswordHash,The following statement contains a magic number: hash = (ushort)(((ushort)((hash >> 14) & 0x01)) | ((ushort)((hash << 1) & 0x7FFF)));  
Magic Number,OfficeOpenXml.Utils,EncryptedPackageHandler,C:\repos\bambit_EPPlus\EPPlus\Utils\EncryptedPackageHandler.cs,CalculatePasswordHash,The following statement contains a magic number: hash ^= (0x8000 | ('N' << 8) | 'K');  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,CompressPart,The following statement contains a magic number: while (decompStart < decompEnd && compStart < compEnd) {  	byte[] chunk = CompressChunk (part' ref decompStart);  	ushort header;  	if (chunk == null || chunk.Length == 0) {  		header = 4096 | 0x600;  		//B=011 A=0  	}  	else {  		header = (ushort)(((chunk.Length - 1) & 0xFFF));  		header |= 0xB000;  		//B=011 A=1  		br.Write (header);  		br.Write (chunk);  	}  	decompEnd = part.Length < decompStart + 4096 ? part.Length : decompStart + 4096;  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,CompressPart,The following statement contains a magic number: while (decompStart < decompEnd && compStart < compEnd) {  	byte[] chunk = CompressChunk (part' ref decompStart);  	ushort header;  	if (chunk == null || chunk.Length == 0) {  		header = 4096 | 0x600;  		//B=011 A=0  	}  	else {  		header = (ushort)(((chunk.Length - 1) & 0xFFF));  		header |= 0xB000;  		//B=011 A=1  		br.Write (header);  		br.Write (chunk);  	}  	decompEnd = part.Length < decompStart + 4096 ? part.Length : decompStart + 4096;  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,CompressPart,The following statement contains a magic number: while (decompStart < decompEnd && compStart < compEnd) {  	byte[] chunk = CompressChunk (part' ref decompStart);  	ushort header;  	if (chunk == null || chunk.Length == 0) {  		header = 4096 | 0x600;  		//B=011 A=0  	}  	else {  		header = (ushort)(((chunk.Length - 1) & 0xFFF));  		header |= 0xB000;  		//B=011 A=1  		br.Write (header);  		br.Write (chunk);  	}  	decompEnd = part.Length < decompStart + 4096 ? part.Length : decompStart + 4096;  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,CompressPart,The following statement contains a magic number: if (chunk == null || chunk.Length == 0) {  	header = 4096 | 0x600;  	//B=011 A=0  }  else {  	header = (ushort)(((chunk.Length - 1) & 0xFFF));  	header |= 0xB000;  	//B=011 A=1  	br.Write (header);  	br.Write (chunk);  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,CompressPart,The following statement contains a magic number: header = 4096 | 0x600;  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,CompressPart,The following statement contains a magic number: decompEnd = part.Length < decompStart + 4096 ? part.Length : decompStart + 4096;  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,CompressPart,The following statement contains a magic number: decompEnd = part.Length < decompStart + 4096 ? part.Length : decompStart + 4096;  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,CompressChunk,The following statement contains a magic number: while (dPos < dEnd) {  	byte tokenFlags = 0;  	for (int i = 0; i < 8; i++) {  		if (dPos - startPos > 0) {  			int bestCandidate = -1;  			int bestLength = 0;  			int candidate = dPos - 1;  			int bitCount = GetLengthBits (dPos - startPos);  			int bits = (16 - bitCount);  			ushort lengthMask = (ushort)((0xFFFF) >> bits);  			while (candidate >= startPos) {  				if (buffer [candidate] == buffer [dPos]) {  					int length = 1;  					while (buffer.Length > dPos + length && buffer [candidate + length] == buffer [dPos + length] && length < lengthMask) {  						length++;  					}  					if (length > bestLength) {  						bestCandidate = candidate;  						bestLength = length;  						if (bestLength == lengthMask) {  							break;  						}  					}  				}  				candidate--;  			}  			if (bestLength >= 3)//Copy token  			 {  				tokenFlags |= (byte)(1 << i);  				UInt16 offsetMask = (ushort)~lengthMask;  				ushort token = (ushort)(((ushort)(dPos - (bestCandidate + 1))) << (bitCount) | (ushort)(bestLength - 3));  				Array.Copy (BitConverter.GetBytes (token)' 0' comprBuffer' cPos' 2);  				dPos = dPos + bestLength;  				cPos += 2;  				//SetCopy Token                          			}  			else {  				comprBuffer [cPos++] = buffer [dPos++];  			}  		}  		else {  			comprBuffer [cPos++] = buffer [dPos++];  		}  		if (dPos >= dEnd)  			break;  	}  	comprBuffer [flagPos] = tokenFlags;  	flagPos = cPos++;  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,CompressChunk,The following statement contains a magic number: while (dPos < dEnd) {  	byte tokenFlags = 0;  	for (int i = 0; i < 8; i++) {  		if (dPos - startPos > 0) {  			int bestCandidate = -1;  			int bestLength = 0;  			int candidate = dPos - 1;  			int bitCount = GetLengthBits (dPos - startPos);  			int bits = (16 - bitCount);  			ushort lengthMask = (ushort)((0xFFFF) >> bits);  			while (candidate >= startPos) {  				if (buffer [candidate] == buffer [dPos]) {  					int length = 1;  					while (buffer.Length > dPos + length && buffer [candidate + length] == buffer [dPos + length] && length < lengthMask) {  						length++;  					}  					if (length > bestLength) {  						bestCandidate = candidate;  						bestLength = length;  						if (bestLength == lengthMask) {  							break;  						}  					}  				}  				candidate--;  			}  			if (bestLength >= 3)//Copy token  			 {  				tokenFlags |= (byte)(1 << i);  				UInt16 offsetMask = (ushort)~lengthMask;  				ushort token = (ushort)(((ushort)(dPos - (bestCandidate + 1))) << (bitCount) | (ushort)(bestLength - 3));  				Array.Copy (BitConverter.GetBytes (token)' 0' comprBuffer' cPos' 2);  				dPos = dPos + bestLength;  				cPos += 2;  				//SetCopy Token                          			}  			else {  				comprBuffer [cPos++] = buffer [dPos++];  			}  		}  		else {  			comprBuffer [cPos++] = buffer [dPos++];  		}  		if (dPos >= dEnd)  			break;  	}  	comprBuffer [flagPos] = tokenFlags;  	flagPos = cPos++;  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,CompressChunk,The following statement contains a magic number: while (dPos < dEnd) {  	byte tokenFlags = 0;  	for (int i = 0; i < 8; i++) {  		if (dPos - startPos > 0) {  			int bestCandidate = -1;  			int bestLength = 0;  			int candidate = dPos - 1;  			int bitCount = GetLengthBits (dPos - startPos);  			int bits = (16 - bitCount);  			ushort lengthMask = (ushort)((0xFFFF) >> bits);  			while (candidate >= startPos) {  				if (buffer [candidate] == buffer [dPos]) {  					int length = 1;  					while (buffer.Length > dPos + length && buffer [candidate + length] == buffer [dPos + length] && length < lengthMask) {  						length++;  					}  					if (length > bestLength) {  						bestCandidate = candidate;  						bestLength = length;  						if (bestLength == lengthMask) {  							break;  						}  					}  				}  				candidate--;  			}  			if (bestLength >= 3)//Copy token  			 {  				tokenFlags |= (byte)(1 << i);  				UInt16 offsetMask = (ushort)~lengthMask;  				ushort token = (ushort)(((ushort)(dPos - (bestCandidate + 1))) << (bitCount) | (ushort)(bestLength - 3));  				Array.Copy (BitConverter.GetBytes (token)' 0' comprBuffer' cPos' 2);  				dPos = dPos + bestLength;  				cPos += 2;  				//SetCopy Token                          			}  			else {  				comprBuffer [cPos++] = buffer [dPos++];  			}  		}  		else {  			comprBuffer [cPos++] = buffer [dPos++];  		}  		if (dPos >= dEnd)  			break;  	}  	comprBuffer [flagPos] = tokenFlags;  	flagPos = cPos++;  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,CompressChunk,The following statement contains a magic number: while (dPos < dEnd) {  	byte tokenFlags = 0;  	for (int i = 0; i < 8; i++) {  		if (dPos - startPos > 0) {  			int bestCandidate = -1;  			int bestLength = 0;  			int candidate = dPos - 1;  			int bitCount = GetLengthBits (dPos - startPos);  			int bits = (16 - bitCount);  			ushort lengthMask = (ushort)((0xFFFF) >> bits);  			while (candidate >= startPos) {  				if (buffer [candidate] == buffer [dPos]) {  					int length = 1;  					while (buffer.Length > dPos + length && buffer [candidate + length] == buffer [dPos + length] && length < lengthMask) {  						length++;  					}  					if (length > bestLength) {  						bestCandidate = candidate;  						bestLength = length;  						if (bestLength == lengthMask) {  							break;  						}  					}  				}  				candidate--;  			}  			if (bestLength >= 3)//Copy token  			 {  				tokenFlags |= (byte)(1 << i);  				UInt16 offsetMask = (ushort)~lengthMask;  				ushort token = (ushort)(((ushort)(dPos - (bestCandidate + 1))) << (bitCount) | (ushort)(bestLength - 3));  				Array.Copy (BitConverter.GetBytes (token)' 0' comprBuffer' cPos' 2);  				dPos = dPos + bestLength;  				cPos += 2;  				//SetCopy Token                          			}  			else {  				comprBuffer [cPos++] = buffer [dPos++];  			}  		}  		else {  			comprBuffer [cPos++] = buffer [dPos++];  		}  		if (dPos >= dEnd)  			break;  	}  	comprBuffer [flagPos] = tokenFlags;  	flagPos = cPos++;  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,CompressChunk,The following statement contains a magic number: while (dPos < dEnd) {  	byte tokenFlags = 0;  	for (int i = 0; i < 8; i++) {  		if (dPos - startPos > 0) {  			int bestCandidate = -1;  			int bestLength = 0;  			int candidate = dPos - 1;  			int bitCount = GetLengthBits (dPos - startPos);  			int bits = (16 - bitCount);  			ushort lengthMask = (ushort)((0xFFFF) >> bits);  			while (candidate >= startPos) {  				if (buffer [candidate] == buffer [dPos]) {  					int length = 1;  					while (buffer.Length > dPos + length && buffer [candidate + length] == buffer [dPos + length] && length < lengthMask) {  						length++;  					}  					if (length > bestLength) {  						bestCandidate = candidate;  						bestLength = length;  						if (bestLength == lengthMask) {  							break;  						}  					}  				}  				candidate--;  			}  			if (bestLength >= 3)//Copy token  			 {  				tokenFlags |= (byte)(1 << i);  				UInt16 offsetMask = (ushort)~lengthMask;  				ushort token = (ushort)(((ushort)(dPos - (bestCandidate + 1))) << (bitCount) | (ushort)(bestLength - 3));  				Array.Copy (BitConverter.GetBytes (token)' 0' comprBuffer' cPos' 2);  				dPos = dPos + bestLength;  				cPos += 2;  				//SetCopy Token                          			}  			else {  				comprBuffer [cPos++] = buffer [dPos++];  			}  		}  		else {  			comprBuffer [cPos++] = buffer [dPos++];  		}  		if (dPos >= dEnd)  			break;  	}  	comprBuffer [flagPos] = tokenFlags;  	flagPos = cPos++;  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,CompressChunk,The following statement contains a magic number: while (dPos < dEnd) {  	byte tokenFlags = 0;  	for (int i = 0; i < 8; i++) {  		if (dPos - startPos > 0) {  			int bestCandidate = -1;  			int bestLength = 0;  			int candidate = dPos - 1;  			int bitCount = GetLengthBits (dPos - startPos);  			int bits = (16 - bitCount);  			ushort lengthMask = (ushort)((0xFFFF) >> bits);  			while (candidate >= startPos) {  				if (buffer [candidate] == buffer [dPos]) {  					int length = 1;  					while (buffer.Length > dPos + length && buffer [candidate + length] == buffer [dPos + length] && length < lengthMask) {  						length++;  					}  					if (length > bestLength) {  						bestCandidate = candidate;  						bestLength = length;  						if (bestLength == lengthMask) {  							break;  						}  					}  				}  				candidate--;  			}  			if (bestLength >= 3)//Copy token  			 {  				tokenFlags |= (byte)(1 << i);  				UInt16 offsetMask = (ushort)~lengthMask;  				ushort token = (ushort)(((ushort)(dPos - (bestCandidate + 1))) << (bitCount) | (ushort)(bestLength - 3));  				Array.Copy (BitConverter.GetBytes (token)' 0' comprBuffer' cPos' 2);  				dPos = dPos + bestLength;  				cPos += 2;  				//SetCopy Token                          			}  			else {  				comprBuffer [cPos++] = buffer [dPos++];  			}  		}  		else {  			comprBuffer [cPos++] = buffer [dPos++];  		}  		if (dPos >= dEnd)  			break;  	}  	comprBuffer [flagPos] = tokenFlags;  	flagPos = cPos++;  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,CompressChunk,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  	if (dPos - startPos > 0) {  		int bestCandidate = -1;  		int bestLength = 0;  		int candidate = dPos - 1;  		int bitCount = GetLengthBits (dPos - startPos);  		int bits = (16 - bitCount);  		ushort lengthMask = (ushort)((0xFFFF) >> bits);  		while (candidate >= startPos) {  			if (buffer [candidate] == buffer [dPos]) {  				int length = 1;  				while (buffer.Length > dPos + length && buffer [candidate + length] == buffer [dPos + length] && length < lengthMask) {  					length++;  				}  				if (length > bestLength) {  					bestCandidate = candidate;  					bestLength = length;  					if (bestLength == lengthMask) {  						break;  					}  				}  			}  			candidate--;  		}  		if (bestLength >= 3)//Copy token  		 {  			tokenFlags |= (byte)(1 << i);  			UInt16 offsetMask = (ushort)~lengthMask;  			ushort token = (ushort)(((ushort)(dPos - (bestCandidate + 1))) << (bitCount) | (ushort)(bestLength - 3));  			Array.Copy (BitConverter.GetBytes (token)' 0' comprBuffer' cPos' 2);  			dPos = dPos + bestLength;  			cPos += 2;  			//SetCopy Token                          		}  		else {  			comprBuffer [cPos++] = buffer [dPos++];  		}  	}  	else {  		comprBuffer [cPos++] = buffer [dPos++];  	}  	if (dPos >= dEnd)  		break;  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,CompressChunk,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  	if (dPos - startPos > 0) {  		int bestCandidate = -1;  		int bestLength = 0;  		int candidate = dPos - 1;  		int bitCount = GetLengthBits (dPos - startPos);  		int bits = (16 - bitCount);  		ushort lengthMask = (ushort)((0xFFFF) >> bits);  		while (candidate >= startPos) {  			if (buffer [candidate] == buffer [dPos]) {  				int length = 1;  				while (buffer.Length > dPos + length && buffer [candidate + length] == buffer [dPos + length] && length < lengthMask) {  					length++;  				}  				if (length > bestLength) {  					bestCandidate = candidate;  					bestLength = length;  					if (bestLength == lengthMask) {  						break;  					}  				}  			}  			candidate--;  		}  		if (bestLength >= 3)//Copy token  		 {  			tokenFlags |= (byte)(1 << i);  			UInt16 offsetMask = (ushort)~lengthMask;  			ushort token = (ushort)(((ushort)(dPos - (bestCandidate + 1))) << (bitCount) | (ushort)(bestLength - 3));  			Array.Copy (BitConverter.GetBytes (token)' 0' comprBuffer' cPos' 2);  			dPos = dPos + bestLength;  			cPos += 2;  			//SetCopy Token                          		}  		else {  			comprBuffer [cPos++] = buffer [dPos++];  		}  	}  	else {  		comprBuffer [cPos++] = buffer [dPos++];  	}  	if (dPos >= dEnd)  		break;  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,CompressChunk,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  	if (dPos - startPos > 0) {  		int bestCandidate = -1;  		int bestLength = 0;  		int candidate = dPos - 1;  		int bitCount = GetLengthBits (dPos - startPos);  		int bits = (16 - bitCount);  		ushort lengthMask = (ushort)((0xFFFF) >> bits);  		while (candidate >= startPos) {  			if (buffer [candidate] == buffer [dPos]) {  				int length = 1;  				while (buffer.Length > dPos + length && buffer [candidate + length] == buffer [dPos + length] && length < lengthMask) {  					length++;  				}  				if (length > bestLength) {  					bestCandidate = candidate;  					bestLength = length;  					if (bestLength == lengthMask) {  						break;  					}  				}  			}  			candidate--;  		}  		if (bestLength >= 3)//Copy token  		 {  			tokenFlags |= (byte)(1 << i);  			UInt16 offsetMask = (ushort)~lengthMask;  			ushort token = (ushort)(((ushort)(dPos - (bestCandidate + 1))) << (bitCount) | (ushort)(bestLength - 3));  			Array.Copy (BitConverter.GetBytes (token)' 0' comprBuffer' cPos' 2);  			dPos = dPos + bestLength;  			cPos += 2;  			//SetCopy Token                          		}  		else {  			comprBuffer [cPos++] = buffer [dPos++];  		}  	}  	else {  		comprBuffer [cPos++] = buffer [dPos++];  	}  	if (dPos >= dEnd)  		break;  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,CompressChunk,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  	if (dPos - startPos > 0) {  		int bestCandidate = -1;  		int bestLength = 0;  		int candidate = dPos - 1;  		int bitCount = GetLengthBits (dPos - startPos);  		int bits = (16 - bitCount);  		ushort lengthMask = (ushort)((0xFFFF) >> bits);  		while (candidate >= startPos) {  			if (buffer [candidate] == buffer [dPos]) {  				int length = 1;  				while (buffer.Length > dPos + length && buffer [candidate + length] == buffer [dPos + length] && length < lengthMask) {  					length++;  				}  				if (length > bestLength) {  					bestCandidate = candidate;  					bestLength = length;  					if (bestLength == lengthMask) {  						break;  					}  				}  			}  			candidate--;  		}  		if (bestLength >= 3)//Copy token  		 {  			tokenFlags |= (byte)(1 << i);  			UInt16 offsetMask = (ushort)~lengthMask;  			ushort token = (ushort)(((ushort)(dPos - (bestCandidate + 1))) << (bitCount) | (ushort)(bestLength - 3));  			Array.Copy (BitConverter.GetBytes (token)' 0' comprBuffer' cPos' 2);  			dPos = dPos + bestLength;  			cPos += 2;  			//SetCopy Token                          		}  		else {  			comprBuffer [cPos++] = buffer [dPos++];  		}  	}  	else {  		comprBuffer [cPos++] = buffer [dPos++];  	}  	if (dPos >= dEnd)  		break;  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,CompressChunk,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  	if (dPos - startPos > 0) {  		int bestCandidate = -1;  		int bestLength = 0;  		int candidate = dPos - 1;  		int bitCount = GetLengthBits (dPos - startPos);  		int bits = (16 - bitCount);  		ushort lengthMask = (ushort)((0xFFFF) >> bits);  		while (candidate >= startPos) {  			if (buffer [candidate] == buffer [dPos]) {  				int length = 1;  				while (buffer.Length > dPos + length && buffer [candidate + length] == buffer [dPos + length] && length < lengthMask) {  					length++;  				}  				if (length > bestLength) {  					bestCandidate = candidate;  					bestLength = length;  					if (bestLength == lengthMask) {  						break;  					}  				}  			}  			candidate--;  		}  		if (bestLength >= 3)//Copy token  		 {  			tokenFlags |= (byte)(1 << i);  			UInt16 offsetMask = (ushort)~lengthMask;  			ushort token = (ushort)(((ushort)(dPos - (bestCandidate + 1))) << (bitCount) | (ushort)(bestLength - 3));  			Array.Copy (BitConverter.GetBytes (token)' 0' comprBuffer' cPos' 2);  			dPos = dPos + bestLength;  			cPos += 2;  			//SetCopy Token                          		}  		else {  			comprBuffer [cPos++] = buffer [dPos++];  		}  	}  	else {  		comprBuffer [cPos++] = buffer [dPos++];  	}  	if (dPos >= dEnd)  		break;  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,CompressChunk,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  	if (dPos - startPos > 0) {  		int bestCandidate = -1;  		int bestLength = 0;  		int candidate = dPos - 1;  		int bitCount = GetLengthBits (dPos - startPos);  		int bits = (16 - bitCount);  		ushort lengthMask = (ushort)((0xFFFF) >> bits);  		while (candidate >= startPos) {  			if (buffer [candidate] == buffer [dPos]) {  				int length = 1;  				while (buffer.Length > dPos + length && buffer [candidate + length] == buffer [dPos + length] && length < lengthMask) {  					length++;  				}  				if (length > bestLength) {  					bestCandidate = candidate;  					bestLength = length;  					if (bestLength == lengthMask) {  						break;  					}  				}  			}  			candidate--;  		}  		if (bestLength >= 3)//Copy token  		 {  			tokenFlags |= (byte)(1 << i);  			UInt16 offsetMask = (ushort)~lengthMask;  			ushort token = (ushort)(((ushort)(dPos - (bestCandidate + 1))) << (bitCount) | (ushort)(bestLength - 3));  			Array.Copy (BitConverter.GetBytes (token)' 0' comprBuffer' cPos' 2);  			dPos = dPos + bestLength;  			cPos += 2;  			//SetCopy Token                          		}  		else {  			comprBuffer [cPos++] = buffer [dPos++];  		}  	}  	else {  		comprBuffer [cPos++] = buffer [dPos++];  	}  	if (dPos >= dEnd)  		break;  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,CompressChunk,The following statement contains a magic number: if (dPos - startPos > 0) {  	int bestCandidate = -1;  	int bestLength = 0;  	int candidate = dPos - 1;  	int bitCount = GetLengthBits (dPos - startPos);  	int bits = (16 - bitCount);  	ushort lengthMask = (ushort)((0xFFFF) >> bits);  	while (candidate >= startPos) {  		if (buffer [candidate] == buffer [dPos]) {  			int length = 1;  			while (buffer.Length > dPos + length && buffer [candidate + length] == buffer [dPos + length] && length < lengthMask) {  				length++;  			}  			if (length > bestLength) {  				bestCandidate = candidate;  				bestLength = length;  				if (bestLength == lengthMask) {  					break;  				}  			}  		}  		candidate--;  	}  	if (bestLength >= 3)//Copy token  	 {  		tokenFlags |= (byte)(1 << i);  		UInt16 offsetMask = (ushort)~lengthMask;  		ushort token = (ushort)(((ushort)(dPos - (bestCandidate + 1))) << (bitCount) | (ushort)(bestLength - 3));  		Array.Copy (BitConverter.GetBytes (token)' 0' comprBuffer' cPos' 2);  		dPos = dPos + bestLength;  		cPos += 2;  		//SetCopy Token                          	}  	else {  		comprBuffer [cPos++] = buffer [dPos++];  	}  }  else {  	comprBuffer [cPos++] = buffer [dPos++];  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,CompressChunk,The following statement contains a magic number: if (dPos - startPos > 0) {  	int bestCandidate = -1;  	int bestLength = 0;  	int candidate = dPos - 1;  	int bitCount = GetLengthBits (dPos - startPos);  	int bits = (16 - bitCount);  	ushort lengthMask = (ushort)((0xFFFF) >> bits);  	while (candidate >= startPos) {  		if (buffer [candidate] == buffer [dPos]) {  			int length = 1;  			while (buffer.Length > dPos + length && buffer [candidate + length] == buffer [dPos + length] && length < lengthMask) {  				length++;  			}  			if (length > bestLength) {  				bestCandidate = candidate;  				bestLength = length;  				if (bestLength == lengthMask) {  					break;  				}  			}  		}  		candidate--;  	}  	if (bestLength >= 3)//Copy token  	 {  		tokenFlags |= (byte)(1 << i);  		UInt16 offsetMask = (ushort)~lengthMask;  		ushort token = (ushort)(((ushort)(dPos - (bestCandidate + 1))) << (bitCount) | (ushort)(bestLength - 3));  		Array.Copy (BitConverter.GetBytes (token)' 0' comprBuffer' cPos' 2);  		dPos = dPos + bestLength;  		cPos += 2;  		//SetCopy Token                          	}  	else {  		comprBuffer [cPos++] = buffer [dPos++];  	}  }  else {  	comprBuffer [cPos++] = buffer [dPos++];  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,CompressChunk,The following statement contains a magic number: if (dPos - startPos > 0) {  	int bestCandidate = -1;  	int bestLength = 0;  	int candidate = dPos - 1;  	int bitCount = GetLengthBits (dPos - startPos);  	int bits = (16 - bitCount);  	ushort lengthMask = (ushort)((0xFFFF) >> bits);  	while (candidate >= startPos) {  		if (buffer [candidate] == buffer [dPos]) {  			int length = 1;  			while (buffer.Length > dPos + length && buffer [candidate + length] == buffer [dPos + length] && length < lengthMask) {  				length++;  			}  			if (length > bestLength) {  				bestCandidate = candidate;  				bestLength = length;  				if (bestLength == lengthMask) {  					break;  				}  			}  		}  		candidate--;  	}  	if (bestLength >= 3)//Copy token  	 {  		tokenFlags |= (byte)(1 << i);  		UInt16 offsetMask = (ushort)~lengthMask;  		ushort token = (ushort)(((ushort)(dPos - (bestCandidate + 1))) << (bitCount) | (ushort)(bestLength - 3));  		Array.Copy (BitConverter.GetBytes (token)' 0' comprBuffer' cPos' 2);  		dPos = dPos + bestLength;  		cPos += 2;  		//SetCopy Token                          	}  	else {  		comprBuffer [cPos++] = buffer [dPos++];  	}  }  else {  	comprBuffer [cPos++] = buffer [dPos++];  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,CompressChunk,The following statement contains a magic number: if (dPos - startPos > 0) {  	int bestCandidate = -1;  	int bestLength = 0;  	int candidate = dPos - 1;  	int bitCount = GetLengthBits (dPos - startPos);  	int bits = (16 - bitCount);  	ushort lengthMask = (ushort)((0xFFFF) >> bits);  	while (candidate >= startPos) {  		if (buffer [candidate] == buffer [dPos]) {  			int length = 1;  			while (buffer.Length > dPos + length && buffer [candidate + length] == buffer [dPos + length] && length < lengthMask) {  				length++;  			}  			if (length > bestLength) {  				bestCandidate = candidate;  				bestLength = length;  				if (bestLength == lengthMask) {  					break;  				}  			}  		}  		candidate--;  	}  	if (bestLength >= 3)//Copy token  	 {  		tokenFlags |= (byte)(1 << i);  		UInt16 offsetMask = (ushort)~lengthMask;  		ushort token = (ushort)(((ushort)(dPos - (bestCandidate + 1))) << (bitCount) | (ushort)(bestLength - 3));  		Array.Copy (BitConverter.GetBytes (token)' 0' comprBuffer' cPos' 2);  		dPos = dPos + bestLength;  		cPos += 2;  		//SetCopy Token                          	}  	else {  		comprBuffer [cPos++] = buffer [dPos++];  	}  }  else {  	comprBuffer [cPos++] = buffer [dPos++];  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,CompressChunk,The following statement contains a magic number: if (dPos - startPos > 0) {  	int bestCandidate = -1;  	int bestLength = 0;  	int candidate = dPos - 1;  	int bitCount = GetLengthBits (dPos - startPos);  	int bits = (16 - bitCount);  	ushort lengthMask = (ushort)((0xFFFF) >> bits);  	while (candidate >= startPos) {  		if (buffer [candidate] == buffer [dPos]) {  			int length = 1;  			while (buffer.Length > dPos + length && buffer [candidate + length] == buffer [dPos + length] && length < lengthMask) {  				length++;  			}  			if (length > bestLength) {  				bestCandidate = candidate;  				bestLength = length;  				if (bestLength == lengthMask) {  					break;  				}  			}  		}  		candidate--;  	}  	if (bestLength >= 3)//Copy token  	 {  		tokenFlags |= (byte)(1 << i);  		UInt16 offsetMask = (ushort)~lengthMask;  		ushort token = (ushort)(((ushort)(dPos - (bestCandidate + 1))) << (bitCount) | (ushort)(bestLength - 3));  		Array.Copy (BitConverter.GetBytes (token)' 0' comprBuffer' cPos' 2);  		dPos = dPos + bestLength;  		cPos += 2;  		//SetCopy Token                          	}  	else {  		comprBuffer [cPos++] = buffer [dPos++];  	}  }  else {  	comprBuffer [cPos++] = buffer [dPos++];  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,CompressChunk,The following statement contains a magic number: if (bestLength >= 3)//Copy token   {  	tokenFlags |= (byte)(1 << i);  	UInt16 offsetMask = (ushort)~lengthMask;  	ushort token = (ushort)(((ushort)(dPos - (bestCandidate + 1))) << (bitCount) | (ushort)(bestLength - 3));  	Array.Copy (BitConverter.GetBytes (token)' 0' comprBuffer' cPos' 2);  	dPos = dPos + bestLength;  	cPos += 2;  	//SetCopy Token                          }  else {  	comprBuffer [cPos++] = buffer [dPos++];  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,CompressChunk,The following statement contains a magic number: if (bestLength >= 3)//Copy token   {  	tokenFlags |= (byte)(1 << i);  	UInt16 offsetMask = (ushort)~lengthMask;  	ushort token = (ushort)(((ushort)(dPos - (bestCandidate + 1))) << (bitCount) | (ushort)(bestLength - 3));  	Array.Copy (BitConverter.GetBytes (token)' 0' comprBuffer' cPos' 2);  	dPos = dPos + bestLength;  	cPos += 2;  	//SetCopy Token                          }  else {  	comprBuffer [cPos++] = buffer [dPos++];  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,CompressChunk,The following statement contains a magic number: if (bestLength >= 3)//Copy token   {  	tokenFlags |= (byte)(1 << i);  	UInt16 offsetMask = (ushort)~lengthMask;  	ushort token = (ushort)(((ushort)(dPos - (bestCandidate + 1))) << (bitCount) | (ushort)(bestLength - 3));  	Array.Copy (BitConverter.GetBytes (token)' 0' comprBuffer' cPos' 2);  	dPos = dPos + bestLength;  	cPos += 2;  	//SetCopy Token                          }  else {  	comprBuffer [cPos++] = buffer [dPos++];  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,CompressChunk,The following statement contains a magic number: if (bestLength >= 3)//Copy token   {  	tokenFlags |= (byte)(1 << i);  	UInt16 offsetMask = (ushort)~lengthMask;  	ushort token = (ushort)(((ushort)(dPos - (bestCandidate + 1))) << (bitCount) | (ushort)(bestLength - 3));  	Array.Copy (BitConverter.GetBytes (token)' 0' comprBuffer' cPos' 2);  	dPos = dPos + bestLength;  	cPos += 2;  	//SetCopy Token                          }  else {  	comprBuffer [cPos++] = buffer [dPos++];  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,CompressChunk,The following statement contains a magic number: Array.Copy (BitConverter.GetBytes (token)' 0' comprBuffer' cPos' 2);  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,CompressChunk,The following statement contains a magic number: cPos += 2;  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetChunk,The following statement contains a magic number: pos += 2;  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetChunk,The following statement contains a magic number: if (b == 1)//Compressed chunk   {  	while (pos < compBuffer.Length && pos < endPos) {  		//Decompress token  		byte token = compBuffer [pos++];  		if (pos >= endPos)  			break;  		for (int i = 0; i < 8; i++) {  			//Literal token  			if ((token & (1 << i)) == 0) {  				buffer [decomprPos++] = compBuffer [pos++];  			}  			else//copy token  			 {  				var t = BitConverter.ToUInt16 (compBuffer' pos);  				int bitCount = GetLengthBits (decomprPos);  				int bits = (16 - bitCount);  				ushort lengthMask = (ushort)((0xFFFF) >> bits);  				UInt16 offsetMask = (ushort)~lengthMask;  				var length = (lengthMask & t) + 3;  				var offset = (offsetMask & t) >> (bitCount);  				int source = decomprPos - offset - 1;  				for (int c = 0; c < length; c++) {  					buffer [decomprPos++] = buffer [source++];  				}  				pos += 2;  			}  			if (pos >= endPos)  				break;  		}  	}  	if (decomprPos > 0) {  		byte[] ret = new byte[decomprPos];  		Array.Copy (buffer' ret' decomprPos);  		return ret;  	}  	else {  		return null;  	}  }  else//Raw chunk   {  	byte[] ret = new byte[size];  	Array.Copy (compBuffer' pos' ret' 0' size);  	pos += size;  	return ret;  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetChunk,The following statement contains a magic number: if (b == 1)//Compressed chunk   {  	while (pos < compBuffer.Length && pos < endPos) {  		//Decompress token  		byte token = compBuffer [pos++];  		if (pos >= endPos)  			break;  		for (int i = 0; i < 8; i++) {  			//Literal token  			if ((token & (1 << i)) == 0) {  				buffer [decomprPos++] = compBuffer [pos++];  			}  			else//copy token  			 {  				var t = BitConverter.ToUInt16 (compBuffer' pos);  				int bitCount = GetLengthBits (decomprPos);  				int bits = (16 - bitCount);  				ushort lengthMask = (ushort)((0xFFFF) >> bits);  				UInt16 offsetMask = (ushort)~lengthMask;  				var length = (lengthMask & t) + 3;  				var offset = (offsetMask & t) >> (bitCount);  				int source = decomprPos - offset - 1;  				for (int c = 0; c < length; c++) {  					buffer [decomprPos++] = buffer [source++];  				}  				pos += 2;  			}  			if (pos >= endPos)  				break;  		}  	}  	if (decomprPos > 0) {  		byte[] ret = new byte[decomprPos];  		Array.Copy (buffer' ret' decomprPos);  		return ret;  	}  	else {  		return null;  	}  }  else//Raw chunk   {  	byte[] ret = new byte[size];  	Array.Copy (compBuffer' pos' ret' 0' size);  	pos += size;  	return ret;  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetChunk,The following statement contains a magic number: if (b == 1)//Compressed chunk   {  	while (pos < compBuffer.Length && pos < endPos) {  		//Decompress token  		byte token = compBuffer [pos++];  		if (pos >= endPos)  			break;  		for (int i = 0; i < 8; i++) {  			//Literal token  			if ((token & (1 << i)) == 0) {  				buffer [decomprPos++] = compBuffer [pos++];  			}  			else//copy token  			 {  				var t = BitConverter.ToUInt16 (compBuffer' pos);  				int bitCount = GetLengthBits (decomprPos);  				int bits = (16 - bitCount);  				ushort lengthMask = (ushort)((0xFFFF) >> bits);  				UInt16 offsetMask = (ushort)~lengthMask;  				var length = (lengthMask & t) + 3;  				var offset = (offsetMask & t) >> (bitCount);  				int source = decomprPos - offset - 1;  				for (int c = 0; c < length; c++) {  					buffer [decomprPos++] = buffer [source++];  				}  				pos += 2;  			}  			if (pos >= endPos)  				break;  		}  	}  	if (decomprPos > 0) {  		byte[] ret = new byte[decomprPos];  		Array.Copy (buffer' ret' decomprPos);  		return ret;  	}  	else {  		return null;  	}  }  else//Raw chunk   {  	byte[] ret = new byte[size];  	Array.Copy (compBuffer' pos' ret' 0' size);  	pos += size;  	return ret;  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetChunk,The following statement contains a magic number: if (b == 1)//Compressed chunk   {  	while (pos < compBuffer.Length && pos < endPos) {  		//Decompress token  		byte token = compBuffer [pos++];  		if (pos >= endPos)  			break;  		for (int i = 0; i < 8; i++) {  			//Literal token  			if ((token & (1 << i)) == 0) {  				buffer [decomprPos++] = compBuffer [pos++];  			}  			else//copy token  			 {  				var t = BitConverter.ToUInt16 (compBuffer' pos);  				int bitCount = GetLengthBits (decomprPos);  				int bits = (16 - bitCount);  				ushort lengthMask = (ushort)((0xFFFF) >> bits);  				UInt16 offsetMask = (ushort)~lengthMask;  				var length = (lengthMask & t) + 3;  				var offset = (offsetMask & t) >> (bitCount);  				int source = decomprPos - offset - 1;  				for (int c = 0; c < length; c++) {  					buffer [decomprPos++] = buffer [source++];  				}  				pos += 2;  			}  			if (pos >= endPos)  				break;  		}  	}  	if (decomprPos > 0) {  		byte[] ret = new byte[decomprPos];  		Array.Copy (buffer' ret' decomprPos);  		return ret;  	}  	else {  		return null;  	}  }  else//Raw chunk   {  	byte[] ret = new byte[size];  	Array.Copy (compBuffer' pos' ret' 0' size);  	pos += size;  	return ret;  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetChunk,The following statement contains a magic number: while (pos < compBuffer.Length && pos < endPos) {  	//Decompress token  	byte token = compBuffer [pos++];  	if (pos >= endPos)  		break;  	for (int i = 0; i < 8; i++) {  		//Literal token  		if ((token & (1 << i)) == 0) {  			buffer [decomprPos++] = compBuffer [pos++];  		}  		else//copy token  		 {  			var t = BitConverter.ToUInt16 (compBuffer' pos);  			int bitCount = GetLengthBits (decomprPos);  			int bits = (16 - bitCount);  			ushort lengthMask = (ushort)((0xFFFF) >> bits);  			UInt16 offsetMask = (ushort)~lengthMask;  			var length = (lengthMask & t) + 3;  			var offset = (offsetMask & t) >> (bitCount);  			int source = decomprPos - offset - 1;  			for (int c = 0; c < length; c++) {  				buffer [decomprPos++] = buffer [source++];  			}  			pos += 2;  		}  		if (pos >= endPos)  			break;  	}  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetChunk,The following statement contains a magic number: while (pos < compBuffer.Length && pos < endPos) {  	//Decompress token  	byte token = compBuffer [pos++];  	if (pos >= endPos)  		break;  	for (int i = 0; i < 8; i++) {  		//Literal token  		if ((token & (1 << i)) == 0) {  			buffer [decomprPos++] = compBuffer [pos++];  		}  		else//copy token  		 {  			var t = BitConverter.ToUInt16 (compBuffer' pos);  			int bitCount = GetLengthBits (decomprPos);  			int bits = (16 - bitCount);  			ushort lengthMask = (ushort)((0xFFFF) >> bits);  			UInt16 offsetMask = (ushort)~lengthMask;  			var length = (lengthMask & t) + 3;  			var offset = (offsetMask & t) >> (bitCount);  			int source = decomprPos - offset - 1;  			for (int c = 0; c < length; c++) {  				buffer [decomprPos++] = buffer [source++];  			}  			pos += 2;  		}  		if (pos >= endPos)  			break;  	}  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetChunk,The following statement contains a magic number: while (pos < compBuffer.Length && pos < endPos) {  	//Decompress token  	byte token = compBuffer [pos++];  	if (pos >= endPos)  		break;  	for (int i = 0; i < 8; i++) {  		//Literal token  		if ((token & (1 << i)) == 0) {  			buffer [decomprPos++] = compBuffer [pos++];  		}  		else//copy token  		 {  			var t = BitConverter.ToUInt16 (compBuffer' pos);  			int bitCount = GetLengthBits (decomprPos);  			int bits = (16 - bitCount);  			ushort lengthMask = (ushort)((0xFFFF) >> bits);  			UInt16 offsetMask = (ushort)~lengthMask;  			var length = (lengthMask & t) + 3;  			var offset = (offsetMask & t) >> (bitCount);  			int source = decomprPos - offset - 1;  			for (int c = 0; c < length; c++) {  				buffer [decomprPos++] = buffer [source++];  			}  			pos += 2;  		}  		if (pos >= endPos)  			break;  	}  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetChunk,The following statement contains a magic number: while (pos < compBuffer.Length && pos < endPos) {  	//Decompress token  	byte token = compBuffer [pos++];  	if (pos >= endPos)  		break;  	for (int i = 0; i < 8; i++) {  		//Literal token  		if ((token & (1 << i)) == 0) {  			buffer [decomprPos++] = compBuffer [pos++];  		}  		else//copy token  		 {  			var t = BitConverter.ToUInt16 (compBuffer' pos);  			int bitCount = GetLengthBits (decomprPos);  			int bits = (16 - bitCount);  			ushort lengthMask = (ushort)((0xFFFF) >> bits);  			UInt16 offsetMask = (ushort)~lengthMask;  			var length = (lengthMask & t) + 3;  			var offset = (offsetMask & t) >> (bitCount);  			int source = decomprPos - offset - 1;  			for (int c = 0; c < length; c++) {  				buffer [decomprPos++] = buffer [source++];  			}  			pos += 2;  		}  		if (pos >= endPos)  			break;  	}  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetChunk,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  	//Literal token  	if ((token & (1 << i)) == 0) {  		buffer [decomprPos++] = compBuffer [pos++];  	}  	else//copy token  	 {  		var t = BitConverter.ToUInt16 (compBuffer' pos);  		int bitCount = GetLengthBits (decomprPos);  		int bits = (16 - bitCount);  		ushort lengthMask = (ushort)((0xFFFF) >> bits);  		UInt16 offsetMask = (ushort)~lengthMask;  		var length = (lengthMask & t) + 3;  		var offset = (offsetMask & t) >> (bitCount);  		int source = decomprPos - offset - 1;  		for (int c = 0; c < length; c++) {  			buffer [decomprPos++] = buffer [source++];  		}  		pos += 2;  	}  	if (pos >= endPos)  		break;  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetChunk,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  	//Literal token  	if ((token & (1 << i)) == 0) {  		buffer [decomprPos++] = compBuffer [pos++];  	}  	else//copy token  	 {  		var t = BitConverter.ToUInt16 (compBuffer' pos);  		int bitCount = GetLengthBits (decomprPos);  		int bits = (16 - bitCount);  		ushort lengthMask = (ushort)((0xFFFF) >> bits);  		UInt16 offsetMask = (ushort)~lengthMask;  		var length = (lengthMask & t) + 3;  		var offset = (offsetMask & t) >> (bitCount);  		int source = decomprPos - offset - 1;  		for (int c = 0; c < length; c++) {  			buffer [decomprPos++] = buffer [source++];  		}  		pos += 2;  	}  	if (pos >= endPos)  		break;  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetChunk,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  	//Literal token  	if ((token & (1 << i)) == 0) {  		buffer [decomprPos++] = compBuffer [pos++];  	}  	else//copy token  	 {  		var t = BitConverter.ToUInt16 (compBuffer' pos);  		int bitCount = GetLengthBits (decomprPos);  		int bits = (16 - bitCount);  		ushort lengthMask = (ushort)((0xFFFF) >> bits);  		UInt16 offsetMask = (ushort)~lengthMask;  		var length = (lengthMask & t) + 3;  		var offset = (offsetMask & t) >> (bitCount);  		int source = decomprPos - offset - 1;  		for (int c = 0; c < length; c++) {  			buffer [decomprPos++] = buffer [source++];  		}  		pos += 2;  	}  	if (pos >= endPos)  		break;  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetChunk,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  	//Literal token  	if ((token & (1 << i)) == 0) {  		buffer [decomprPos++] = compBuffer [pos++];  	}  	else//copy token  	 {  		var t = BitConverter.ToUInt16 (compBuffer' pos);  		int bitCount = GetLengthBits (decomprPos);  		int bits = (16 - bitCount);  		ushort lengthMask = (ushort)((0xFFFF) >> bits);  		UInt16 offsetMask = (ushort)~lengthMask;  		var length = (lengthMask & t) + 3;  		var offset = (offsetMask & t) >> (bitCount);  		int source = decomprPos - offset - 1;  		for (int c = 0; c < length; c++) {  			buffer [decomprPos++] = buffer [source++];  		}  		pos += 2;  	}  	if (pos >= endPos)  		break;  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetChunk,The following statement contains a magic number: if ((token & (1 << i)) == 0) {  	buffer [decomprPos++] = compBuffer [pos++];  }  else//copy token   {  	var t = BitConverter.ToUInt16 (compBuffer' pos);  	int bitCount = GetLengthBits (decomprPos);  	int bits = (16 - bitCount);  	ushort lengthMask = (ushort)((0xFFFF) >> bits);  	UInt16 offsetMask = (ushort)~lengthMask;  	var length = (lengthMask & t) + 3;  	var offset = (offsetMask & t) >> (bitCount);  	int source = decomprPos - offset - 1;  	for (int c = 0; c < length; c++) {  		buffer [decomprPos++] = buffer [source++];  	}  	pos += 2;  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetChunk,The following statement contains a magic number: if ((token & (1 << i)) == 0) {  	buffer [decomprPos++] = compBuffer [pos++];  }  else//copy token   {  	var t = BitConverter.ToUInt16 (compBuffer' pos);  	int bitCount = GetLengthBits (decomprPos);  	int bits = (16 - bitCount);  	ushort lengthMask = (ushort)((0xFFFF) >> bits);  	UInt16 offsetMask = (ushort)~lengthMask;  	var length = (lengthMask & t) + 3;  	var offset = (offsetMask & t) >> (bitCount);  	int source = decomprPos - offset - 1;  	for (int c = 0; c < length; c++) {  		buffer [decomprPos++] = buffer [source++];  	}  	pos += 2;  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetChunk,The following statement contains a magic number: if ((token & (1 << i)) == 0) {  	buffer [decomprPos++] = compBuffer [pos++];  }  else//copy token   {  	var t = BitConverter.ToUInt16 (compBuffer' pos);  	int bitCount = GetLengthBits (decomprPos);  	int bits = (16 - bitCount);  	ushort lengthMask = (ushort)((0xFFFF) >> bits);  	UInt16 offsetMask = (ushort)~lengthMask;  	var length = (lengthMask & t) + 3;  	var offset = (offsetMask & t) >> (bitCount);  	int source = decomprPos - offset - 1;  	for (int c = 0; c < length; c++) {  		buffer [decomprPos++] = buffer [source++];  	}  	pos += 2;  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetChunk,The following statement contains a magic number: pos += 2;  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetLengthBits,The following statement contains a magic number: if (decompPos <= 16) {  	return 12;  }  else if (decompPos <= 32) {  	return 11;  }  else if (decompPos <= 64) {  	return 10;  }  else if (decompPos <= 128) {  	return 9;  }  else if (decompPos <= 256) {  	return 8;  }  else if (decompPos <= 512) {  	return 7;  }  else if (decompPos <= 1024) {  	return 6;  }  else if (decompPos <= 2048) {  	return 5;  }  else if (decompPos <= 4096) {  	return 4;  }  else {  	//We should never end up here' but if so this is the formula to calculate the bits...  	return 12 - (int)Math.Truncate (Math.Log (decompPos - 1 >> 4' 2) + 1);  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetLengthBits,The following statement contains a magic number: if (decompPos <= 16) {  	return 12;  }  else if (decompPos <= 32) {  	return 11;  }  else if (decompPos <= 64) {  	return 10;  }  else if (decompPos <= 128) {  	return 9;  }  else if (decompPos <= 256) {  	return 8;  }  else if (decompPos <= 512) {  	return 7;  }  else if (decompPos <= 1024) {  	return 6;  }  else if (decompPos <= 2048) {  	return 5;  }  else if (decompPos <= 4096) {  	return 4;  }  else {  	//We should never end up here' but if so this is the formula to calculate the bits...  	return 12 - (int)Math.Truncate (Math.Log (decompPos - 1 >> 4' 2) + 1);  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetLengthBits,The following statement contains a magic number: if (decompPos <= 16) {  	return 12;  }  else if (decompPos <= 32) {  	return 11;  }  else if (decompPos <= 64) {  	return 10;  }  else if (decompPos <= 128) {  	return 9;  }  else if (decompPos <= 256) {  	return 8;  }  else if (decompPos <= 512) {  	return 7;  }  else if (decompPos <= 1024) {  	return 6;  }  else if (decompPos <= 2048) {  	return 5;  }  else if (decompPos <= 4096) {  	return 4;  }  else {  	//We should never end up here' but if so this is the formula to calculate the bits...  	return 12 - (int)Math.Truncate (Math.Log (decompPos - 1 >> 4' 2) + 1);  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetLengthBits,The following statement contains a magic number: if (decompPos <= 16) {  	return 12;  }  else if (decompPos <= 32) {  	return 11;  }  else if (decompPos <= 64) {  	return 10;  }  else if (decompPos <= 128) {  	return 9;  }  else if (decompPos <= 256) {  	return 8;  }  else if (decompPos <= 512) {  	return 7;  }  else if (decompPos <= 1024) {  	return 6;  }  else if (decompPos <= 2048) {  	return 5;  }  else if (decompPos <= 4096) {  	return 4;  }  else {  	//We should never end up here' but if so this is the formula to calculate the bits...  	return 12 - (int)Math.Truncate (Math.Log (decompPos - 1 >> 4' 2) + 1);  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetLengthBits,The following statement contains a magic number: if (decompPos <= 16) {  	return 12;  }  else if (decompPos <= 32) {  	return 11;  }  else if (decompPos <= 64) {  	return 10;  }  else if (decompPos <= 128) {  	return 9;  }  else if (decompPos <= 256) {  	return 8;  }  else if (decompPos <= 512) {  	return 7;  }  else if (decompPos <= 1024) {  	return 6;  }  else if (decompPos <= 2048) {  	return 5;  }  else if (decompPos <= 4096) {  	return 4;  }  else {  	//We should never end up here' but if so this is the formula to calculate the bits...  	return 12 - (int)Math.Truncate (Math.Log (decompPos - 1 >> 4' 2) + 1);  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetLengthBits,The following statement contains a magic number: if (decompPos <= 16) {  	return 12;  }  else if (decompPos <= 32) {  	return 11;  }  else if (decompPos <= 64) {  	return 10;  }  else if (decompPos <= 128) {  	return 9;  }  else if (decompPos <= 256) {  	return 8;  }  else if (decompPos <= 512) {  	return 7;  }  else if (decompPos <= 1024) {  	return 6;  }  else if (decompPos <= 2048) {  	return 5;  }  else if (decompPos <= 4096) {  	return 4;  }  else {  	//We should never end up here' but if so this is the formula to calculate the bits...  	return 12 - (int)Math.Truncate (Math.Log (decompPos - 1 >> 4' 2) + 1);  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetLengthBits,The following statement contains a magic number: if (decompPos <= 16) {  	return 12;  }  else if (decompPos <= 32) {  	return 11;  }  else if (decompPos <= 64) {  	return 10;  }  else if (decompPos <= 128) {  	return 9;  }  else if (decompPos <= 256) {  	return 8;  }  else if (decompPos <= 512) {  	return 7;  }  else if (decompPos <= 1024) {  	return 6;  }  else if (decompPos <= 2048) {  	return 5;  }  else if (decompPos <= 4096) {  	return 4;  }  else {  	//We should never end up here' but if so this is the formula to calculate the bits...  	return 12 - (int)Math.Truncate (Math.Log (decompPos - 1 >> 4' 2) + 1);  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetLengthBits,The following statement contains a magic number: if (decompPos <= 16) {  	return 12;  }  else if (decompPos <= 32) {  	return 11;  }  else if (decompPos <= 64) {  	return 10;  }  else if (decompPos <= 128) {  	return 9;  }  else if (decompPos <= 256) {  	return 8;  }  else if (decompPos <= 512) {  	return 7;  }  else if (decompPos <= 1024) {  	return 6;  }  else if (decompPos <= 2048) {  	return 5;  }  else if (decompPos <= 4096) {  	return 4;  }  else {  	//We should never end up here' but if so this is the formula to calculate the bits...  	return 12 - (int)Math.Truncate (Math.Log (decompPos - 1 >> 4' 2) + 1);  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetLengthBits,The following statement contains a magic number: if (decompPos <= 16) {  	return 12;  }  else if (decompPos <= 32) {  	return 11;  }  else if (decompPos <= 64) {  	return 10;  }  else if (decompPos <= 128) {  	return 9;  }  else if (decompPos <= 256) {  	return 8;  }  else if (decompPos <= 512) {  	return 7;  }  else if (decompPos <= 1024) {  	return 6;  }  else if (decompPos <= 2048) {  	return 5;  }  else if (decompPos <= 4096) {  	return 4;  }  else {  	//We should never end up here' but if so this is the formula to calculate the bits...  	return 12 - (int)Math.Truncate (Math.Log (decompPos - 1 >> 4' 2) + 1);  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetLengthBits,The following statement contains a magic number: if (decompPos <= 16) {  	return 12;  }  else if (decompPos <= 32) {  	return 11;  }  else if (decompPos <= 64) {  	return 10;  }  else if (decompPos <= 128) {  	return 9;  }  else if (decompPos <= 256) {  	return 8;  }  else if (decompPos <= 512) {  	return 7;  }  else if (decompPos <= 1024) {  	return 6;  }  else if (decompPos <= 2048) {  	return 5;  }  else if (decompPos <= 4096) {  	return 4;  }  else {  	//We should never end up here' but if so this is the formula to calculate the bits...  	return 12 - (int)Math.Truncate (Math.Log (decompPos - 1 >> 4' 2) + 1);  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetLengthBits,The following statement contains a magic number: if (decompPos <= 16) {  	return 12;  }  else if (decompPos <= 32) {  	return 11;  }  else if (decompPos <= 64) {  	return 10;  }  else if (decompPos <= 128) {  	return 9;  }  else if (decompPos <= 256) {  	return 8;  }  else if (decompPos <= 512) {  	return 7;  }  else if (decompPos <= 1024) {  	return 6;  }  else if (decompPos <= 2048) {  	return 5;  }  else if (decompPos <= 4096) {  	return 4;  }  else {  	//We should never end up here' but if so this is the formula to calculate the bits...  	return 12 - (int)Math.Truncate (Math.Log (decompPos - 1 >> 4' 2) + 1);  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetLengthBits,The following statement contains a magic number: if (decompPos <= 16) {  	return 12;  }  else if (decompPos <= 32) {  	return 11;  }  else if (decompPos <= 64) {  	return 10;  }  else if (decompPos <= 128) {  	return 9;  }  else if (decompPos <= 256) {  	return 8;  }  else if (decompPos <= 512) {  	return 7;  }  else if (decompPos <= 1024) {  	return 6;  }  else if (decompPos <= 2048) {  	return 5;  }  else if (decompPos <= 4096) {  	return 4;  }  else {  	//We should never end up here' but if so this is the formula to calculate the bits...  	return 12 - (int)Math.Truncate (Math.Log (decompPos - 1 >> 4' 2) + 1);  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetLengthBits,The following statement contains a magic number: if (decompPos <= 16) {  	return 12;  }  else if (decompPos <= 32) {  	return 11;  }  else if (decompPos <= 64) {  	return 10;  }  else if (decompPos <= 128) {  	return 9;  }  else if (decompPos <= 256) {  	return 8;  }  else if (decompPos <= 512) {  	return 7;  }  else if (decompPos <= 1024) {  	return 6;  }  else if (decompPos <= 2048) {  	return 5;  }  else if (decompPos <= 4096) {  	return 4;  }  else {  	//We should never end up here' but if so this is the formula to calculate the bits...  	return 12 - (int)Math.Truncate (Math.Log (decompPos - 1 >> 4' 2) + 1);  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetLengthBits,The following statement contains a magic number: if (decompPos <= 16) {  	return 12;  }  else if (decompPos <= 32) {  	return 11;  }  else if (decompPos <= 64) {  	return 10;  }  else if (decompPos <= 128) {  	return 9;  }  else if (decompPos <= 256) {  	return 8;  }  else if (decompPos <= 512) {  	return 7;  }  else if (decompPos <= 1024) {  	return 6;  }  else if (decompPos <= 2048) {  	return 5;  }  else if (decompPos <= 4096) {  	return 4;  }  else {  	//We should never end up here' but if so this is the formula to calculate the bits...  	return 12 - (int)Math.Truncate (Math.Log (decompPos - 1 >> 4' 2) + 1);  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetLengthBits,The following statement contains a magic number: if (decompPos <= 16) {  	return 12;  }  else if (decompPos <= 32) {  	return 11;  }  else if (decompPos <= 64) {  	return 10;  }  else if (decompPos <= 128) {  	return 9;  }  else if (decompPos <= 256) {  	return 8;  }  else if (decompPos <= 512) {  	return 7;  }  else if (decompPos <= 1024) {  	return 6;  }  else if (decompPos <= 2048) {  	return 5;  }  else if (decompPos <= 4096) {  	return 4;  }  else {  	//We should never end up here' but if so this is the formula to calculate the bits...  	return 12 - (int)Math.Truncate (Math.Log (decompPos - 1 >> 4' 2) + 1);  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetLengthBits,The following statement contains a magic number: if (decompPos <= 16) {  	return 12;  }  else if (decompPos <= 32) {  	return 11;  }  else if (decompPos <= 64) {  	return 10;  }  else if (decompPos <= 128) {  	return 9;  }  else if (decompPos <= 256) {  	return 8;  }  else if (decompPos <= 512) {  	return 7;  }  else if (decompPos <= 1024) {  	return 6;  }  else if (decompPos <= 2048) {  	return 5;  }  else if (decompPos <= 4096) {  	return 4;  }  else {  	//We should never end up here' but if so this is the formula to calculate the bits...  	return 12 - (int)Math.Truncate (Math.Log (decompPos - 1 >> 4' 2) + 1);  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetLengthBits,The following statement contains a magic number: if (decompPos <= 16) {  	return 12;  }  else if (decompPos <= 32) {  	return 11;  }  else if (decompPos <= 64) {  	return 10;  }  else if (decompPos <= 128) {  	return 9;  }  else if (decompPos <= 256) {  	return 8;  }  else if (decompPos <= 512) {  	return 7;  }  else if (decompPos <= 1024) {  	return 6;  }  else if (decompPos <= 2048) {  	return 5;  }  else if (decompPos <= 4096) {  	return 4;  }  else {  	//We should never end up here' but if so this is the formula to calculate the bits...  	return 12 - (int)Math.Truncate (Math.Log (decompPos - 1 >> 4' 2) + 1);  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetLengthBits,The following statement contains a magic number: if (decompPos <= 16) {  	return 12;  }  else if (decompPos <= 32) {  	return 11;  }  else if (decompPos <= 64) {  	return 10;  }  else if (decompPos <= 128) {  	return 9;  }  else if (decompPos <= 256) {  	return 8;  }  else if (decompPos <= 512) {  	return 7;  }  else if (decompPos <= 1024) {  	return 6;  }  else if (decompPos <= 2048) {  	return 5;  }  else if (decompPos <= 4096) {  	return 4;  }  else {  	//We should never end up here' but if so this is the formula to calculate the bits...  	return 12 - (int)Math.Truncate (Math.Log (decompPos - 1 >> 4' 2) + 1);  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetLengthBits,The following statement contains a magic number: if (decompPos <= 16) {  	return 12;  }  else if (decompPos <= 32) {  	return 11;  }  else if (decompPos <= 64) {  	return 10;  }  else if (decompPos <= 128) {  	return 9;  }  else if (decompPos <= 256) {  	return 8;  }  else if (decompPos <= 512) {  	return 7;  }  else if (decompPos <= 1024) {  	return 6;  }  else if (decompPos <= 2048) {  	return 5;  }  else if (decompPos <= 4096) {  	return 4;  }  else {  	//We should never end up here' but if so this is the formula to calculate the bits...  	return 12 - (int)Math.Truncate (Math.Log (decompPos - 1 >> 4' 2) + 1);  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetLengthBits,The following statement contains a magic number: if (decompPos <= 16) {  	return 12;  }  else if (decompPos <= 32) {  	return 11;  }  else if (decompPos <= 64) {  	return 10;  }  else if (decompPos <= 128) {  	return 9;  }  else if (decompPos <= 256) {  	return 8;  }  else if (decompPos <= 512) {  	return 7;  }  else if (decompPos <= 1024) {  	return 6;  }  else if (decompPos <= 2048) {  	return 5;  }  else if (decompPos <= 4096) {  	return 4;  }  else {  	//We should never end up here' but if so this is the formula to calculate the bits...  	return 12 - (int)Math.Truncate (Math.Log (decompPos - 1 >> 4' 2) + 1);  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetLengthBits,The following statement contains a magic number: if (decompPos <= 16) {  	return 12;  }  else if (decompPos <= 32) {  	return 11;  }  else if (decompPos <= 64) {  	return 10;  }  else if (decompPos <= 128) {  	return 9;  }  else if (decompPos <= 256) {  	return 8;  }  else if (decompPos <= 512) {  	return 7;  }  else if (decompPos <= 1024) {  	return 6;  }  else if (decompPos <= 2048) {  	return 5;  }  else if (decompPos <= 4096) {  	return 4;  }  else {  	//We should never end up here' but if so this is the formula to calculate the bits...  	return 12 - (int)Math.Truncate (Math.Log (decompPos - 1 >> 4' 2) + 1);  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetLengthBits,The following statement contains a magic number: return 12;  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetLengthBits,The following statement contains a magic number: if (decompPos <= 32) {  	return 11;  }  else if (decompPos <= 64) {  	return 10;  }  else if (decompPos <= 128) {  	return 9;  }  else if (decompPos <= 256) {  	return 8;  }  else if (decompPos <= 512) {  	return 7;  }  else if (decompPos <= 1024) {  	return 6;  }  else if (decompPos <= 2048) {  	return 5;  }  else if (decompPos <= 4096) {  	return 4;  }  else {  	//We should never end up here' but if so this is the formula to calculate the bits...  	return 12 - (int)Math.Truncate (Math.Log (decompPos - 1 >> 4' 2) + 1);  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetLengthBits,The following statement contains a magic number: if (decompPos <= 32) {  	return 11;  }  else if (decompPos <= 64) {  	return 10;  }  else if (decompPos <= 128) {  	return 9;  }  else if (decompPos <= 256) {  	return 8;  }  else if (decompPos <= 512) {  	return 7;  }  else if (decompPos <= 1024) {  	return 6;  }  else if (decompPos <= 2048) {  	return 5;  }  else if (decompPos <= 4096) {  	return 4;  }  else {  	//We should never end up here' but if so this is the formula to calculate the bits...  	return 12 - (int)Math.Truncate (Math.Log (decompPos - 1 >> 4' 2) + 1);  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetLengthBits,The following statement contains a magic number: if (decompPos <= 32) {  	return 11;  }  else if (decompPos <= 64) {  	return 10;  }  else if (decompPos <= 128) {  	return 9;  }  else if (decompPos <= 256) {  	return 8;  }  else if (decompPos <= 512) {  	return 7;  }  else if (decompPos <= 1024) {  	return 6;  }  else if (decompPos <= 2048) {  	return 5;  }  else if (decompPos <= 4096) {  	return 4;  }  else {  	//We should never end up here' but if so this is the formula to calculate the bits...  	return 12 - (int)Math.Truncate (Math.Log (decompPos - 1 >> 4' 2) + 1);  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetLengthBits,The following statement contains a magic number: if (decompPos <= 32) {  	return 11;  }  else if (decompPos <= 64) {  	return 10;  }  else if (decompPos <= 128) {  	return 9;  }  else if (decompPos <= 256) {  	return 8;  }  else if (decompPos <= 512) {  	return 7;  }  else if (decompPos <= 1024) {  	return 6;  }  else if (decompPos <= 2048) {  	return 5;  }  else if (decompPos <= 4096) {  	return 4;  }  else {  	//We should never end up here' but if so this is the formula to calculate the bits...  	return 12 - (int)Math.Truncate (Math.Log (decompPos - 1 >> 4' 2) + 1);  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetLengthBits,The following statement contains a magic number: if (decompPos <= 32) {  	return 11;  }  else if (decompPos <= 64) {  	return 10;  }  else if (decompPos <= 128) {  	return 9;  }  else if (decompPos <= 256) {  	return 8;  }  else if (decompPos <= 512) {  	return 7;  }  else if (decompPos <= 1024) {  	return 6;  }  else if (decompPos <= 2048) {  	return 5;  }  else if (decompPos <= 4096) {  	return 4;  }  else {  	//We should never end up here' but if so this is the formula to calculate the bits...  	return 12 - (int)Math.Truncate (Math.Log (decompPos - 1 >> 4' 2) + 1);  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetLengthBits,The following statement contains a magic number: if (decompPos <= 32) {  	return 11;  }  else if (decompPos <= 64) {  	return 10;  }  else if (decompPos <= 128) {  	return 9;  }  else if (decompPos <= 256) {  	return 8;  }  else if (decompPos <= 512) {  	return 7;  }  else if (decompPos <= 1024) {  	return 6;  }  else if (decompPos <= 2048) {  	return 5;  }  else if (decompPos <= 4096) {  	return 4;  }  else {  	//We should never end up here' but if so this is the formula to calculate the bits...  	return 12 - (int)Math.Truncate (Math.Log (decompPos - 1 >> 4' 2) + 1);  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetLengthBits,The following statement contains a magic number: if (decompPos <= 32) {  	return 11;  }  else if (decompPos <= 64) {  	return 10;  }  else if (decompPos <= 128) {  	return 9;  }  else if (decompPos <= 256) {  	return 8;  }  else if (decompPos <= 512) {  	return 7;  }  else if (decompPos <= 1024) {  	return 6;  }  else if (decompPos <= 2048) {  	return 5;  }  else if (decompPos <= 4096) {  	return 4;  }  else {  	//We should never end up here' but if so this is the formula to calculate the bits...  	return 12 - (int)Math.Truncate (Math.Log (decompPos - 1 >> 4' 2) + 1);  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetLengthBits,The following statement contains a magic number: if (decompPos <= 32) {  	return 11;  }  else if (decompPos <= 64) {  	return 10;  }  else if (decompPos <= 128) {  	return 9;  }  else if (decompPos <= 256) {  	return 8;  }  else if (decompPos <= 512) {  	return 7;  }  else if (decompPos <= 1024) {  	return 6;  }  else if (decompPos <= 2048) {  	return 5;  }  else if (decompPos <= 4096) {  	return 4;  }  else {  	//We should never end up here' but if so this is the formula to calculate the bits...  	return 12 - (int)Math.Truncate (Math.Log (decompPos - 1 >> 4' 2) + 1);  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetLengthBits,The following statement contains a magic number: if (decompPos <= 32) {  	return 11;  }  else if (decompPos <= 64) {  	return 10;  }  else if (decompPos <= 128) {  	return 9;  }  else if (decompPos <= 256) {  	return 8;  }  else if (decompPos <= 512) {  	return 7;  }  else if (decompPos <= 1024) {  	return 6;  }  else if (decompPos <= 2048) {  	return 5;  }  else if (decompPos <= 4096) {  	return 4;  }  else {  	//We should never end up here' but if so this is the formula to calculate the bits...  	return 12 - (int)Math.Truncate (Math.Log (decompPos - 1 >> 4' 2) + 1);  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetLengthBits,The following statement contains a magic number: if (decompPos <= 32) {  	return 11;  }  else if (decompPos <= 64) {  	return 10;  }  else if (decompPos <= 128) {  	return 9;  }  else if (decompPos <= 256) {  	return 8;  }  else if (decompPos <= 512) {  	return 7;  }  else if (decompPos <= 1024) {  	return 6;  }  else if (decompPos <= 2048) {  	return 5;  }  else if (decompPos <= 4096) {  	return 4;  }  else {  	//We should never end up here' but if so this is the formula to calculate the bits...  	return 12 - (int)Math.Truncate (Math.Log (decompPos - 1 >> 4' 2) + 1);  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetLengthBits,The following statement contains a magic number: if (decompPos <= 32) {  	return 11;  }  else if (decompPos <= 64) {  	return 10;  }  else if (decompPos <= 128) {  	return 9;  }  else if (decompPos <= 256) {  	return 8;  }  else if (decompPos <= 512) {  	return 7;  }  else if (decompPos <= 1024) {  	return 6;  }  else if (decompPos <= 2048) {  	return 5;  }  else if (decompPos <= 4096) {  	return 4;  }  else {  	//We should never end up here' but if so this is the formula to calculate the bits...  	return 12 - (int)Math.Truncate (Math.Log (decompPos - 1 >> 4' 2) + 1);  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetLengthBits,The following statement contains a magic number: if (decompPos <= 32) {  	return 11;  }  else if (decompPos <= 64) {  	return 10;  }  else if (decompPos <= 128) {  	return 9;  }  else if (decompPos <= 256) {  	return 8;  }  else if (decompPos <= 512) {  	return 7;  }  else if (decompPos <= 1024) {  	return 6;  }  else if (decompPos <= 2048) {  	return 5;  }  else if (decompPos <= 4096) {  	return 4;  }  else {  	//We should never end up here' but if so this is the formula to calculate the bits...  	return 12 - (int)Math.Truncate (Math.Log (decompPos - 1 >> 4' 2) + 1);  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetLengthBits,The following statement contains a magic number: if (decompPos <= 32) {  	return 11;  }  else if (decompPos <= 64) {  	return 10;  }  else if (decompPos <= 128) {  	return 9;  }  else if (decompPos <= 256) {  	return 8;  }  else if (decompPos <= 512) {  	return 7;  }  else if (decompPos <= 1024) {  	return 6;  }  else if (decompPos <= 2048) {  	return 5;  }  else if (decompPos <= 4096) {  	return 4;  }  else {  	//We should never end up here' but if so this is the formula to calculate the bits...  	return 12 - (int)Math.Truncate (Math.Log (decompPos - 1 >> 4' 2) + 1);  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetLengthBits,The following statement contains a magic number: if (decompPos <= 32) {  	return 11;  }  else if (decompPos <= 64) {  	return 10;  }  else if (decompPos <= 128) {  	return 9;  }  else if (decompPos <= 256) {  	return 8;  }  else if (decompPos <= 512) {  	return 7;  }  else if (decompPos <= 1024) {  	return 6;  }  else if (decompPos <= 2048) {  	return 5;  }  else if (decompPos <= 4096) {  	return 4;  }  else {  	//We should never end up here' but if so this is the formula to calculate the bits...  	return 12 - (int)Math.Truncate (Math.Log (decompPos - 1 >> 4' 2) + 1);  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetLengthBits,The following statement contains a magic number: if (decompPos <= 32) {  	return 11;  }  else if (decompPos <= 64) {  	return 10;  }  else if (decompPos <= 128) {  	return 9;  }  else if (decompPos <= 256) {  	return 8;  }  else if (decompPos <= 512) {  	return 7;  }  else if (decompPos <= 1024) {  	return 6;  }  else if (decompPos <= 2048) {  	return 5;  }  else if (decompPos <= 4096) {  	return 4;  }  else {  	//We should never end up here' but if so this is the formula to calculate the bits...  	return 12 - (int)Math.Truncate (Math.Log (decompPos - 1 >> 4' 2) + 1);  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetLengthBits,The following statement contains a magic number: if (decompPos <= 32) {  	return 11;  }  else if (decompPos <= 64) {  	return 10;  }  else if (decompPos <= 128) {  	return 9;  }  else if (decompPos <= 256) {  	return 8;  }  else if (decompPos <= 512) {  	return 7;  }  else if (decompPos <= 1024) {  	return 6;  }  else if (decompPos <= 2048) {  	return 5;  }  else if (decompPos <= 4096) {  	return 4;  }  else {  	//We should never end up here' but if so this is the formula to calculate the bits...  	return 12 - (int)Math.Truncate (Math.Log (decompPos - 1 >> 4' 2) + 1);  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetLengthBits,The following statement contains a magic number: if (decompPos <= 32) {  	return 11;  }  else if (decompPos <= 64) {  	return 10;  }  else if (decompPos <= 128) {  	return 9;  }  else if (decompPos <= 256) {  	return 8;  }  else if (decompPos <= 512) {  	return 7;  }  else if (decompPos <= 1024) {  	return 6;  }  else if (decompPos <= 2048) {  	return 5;  }  else if (decompPos <= 4096) {  	return 4;  }  else {  	//We should never end up here' but if so this is the formula to calculate the bits...  	return 12 - (int)Math.Truncate (Math.Log (decompPos - 1 >> 4' 2) + 1);  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetLengthBits,The following statement contains a magic number: if (decompPos <= 32) {  	return 11;  }  else if (decompPos <= 64) {  	return 10;  }  else if (decompPos <= 128) {  	return 9;  }  else if (decompPos <= 256) {  	return 8;  }  else if (decompPos <= 512) {  	return 7;  }  else if (decompPos <= 1024) {  	return 6;  }  else if (decompPos <= 2048) {  	return 5;  }  else if (decompPos <= 4096) {  	return 4;  }  else {  	//We should never end up here' but if so this is the formula to calculate the bits...  	return 12 - (int)Math.Truncate (Math.Log (decompPos - 1 >> 4' 2) + 1);  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetLengthBits,The following statement contains a magic number: if (decompPos <= 32) {  	return 11;  }  else if (decompPos <= 64) {  	return 10;  }  else if (decompPos <= 128) {  	return 9;  }  else if (decompPos <= 256) {  	return 8;  }  else if (decompPos <= 512) {  	return 7;  }  else if (decompPos <= 1024) {  	return 6;  }  else if (decompPos <= 2048) {  	return 5;  }  else if (decompPos <= 4096) {  	return 4;  }  else {  	//We should never end up here' but if so this is the formula to calculate the bits...  	return 12 - (int)Math.Truncate (Math.Log (decompPos - 1 >> 4' 2) + 1);  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetLengthBits,The following statement contains a magic number: return 11;  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetLengthBits,The following statement contains a magic number: if (decompPos <= 64) {  	return 10;  }  else if (decompPos <= 128) {  	return 9;  }  else if (decompPos <= 256) {  	return 8;  }  else if (decompPos <= 512) {  	return 7;  }  else if (decompPos <= 1024) {  	return 6;  }  else if (decompPos <= 2048) {  	return 5;  }  else if (decompPos <= 4096) {  	return 4;  }  else {  	//We should never end up here' but if so this is the formula to calculate the bits...  	return 12 - (int)Math.Truncate (Math.Log (decompPos - 1 >> 4' 2) + 1);  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetLengthBits,The following statement contains a magic number: if (decompPos <= 64) {  	return 10;  }  else if (decompPos <= 128) {  	return 9;  }  else if (decompPos <= 256) {  	return 8;  }  else if (decompPos <= 512) {  	return 7;  }  else if (decompPos <= 1024) {  	return 6;  }  else if (decompPos <= 2048) {  	return 5;  }  else if (decompPos <= 4096) {  	return 4;  }  else {  	//We should never end up here' but if so this is the formula to calculate the bits...  	return 12 - (int)Math.Truncate (Math.Log (decompPos - 1 >> 4' 2) + 1);  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetLengthBits,The following statement contains a magic number: if (decompPos <= 64) {  	return 10;  }  else if (decompPos <= 128) {  	return 9;  }  else if (decompPos <= 256) {  	return 8;  }  else if (decompPos <= 512) {  	return 7;  }  else if (decompPos <= 1024) {  	return 6;  }  else if (decompPos <= 2048) {  	return 5;  }  else if (decompPos <= 4096) {  	return 4;  }  else {  	//We should never end up here' but if so this is the formula to calculate the bits...  	return 12 - (int)Math.Truncate (Math.Log (decompPos - 1 >> 4' 2) + 1);  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetLengthBits,The following statement contains a magic number: if (decompPos <= 64) {  	return 10;  }  else if (decompPos <= 128) {  	return 9;  }  else if (decompPos <= 256) {  	return 8;  }  else if (decompPos <= 512) {  	return 7;  }  else if (decompPos <= 1024) {  	return 6;  }  else if (decompPos <= 2048) {  	return 5;  }  else if (decompPos <= 4096) {  	return 4;  }  else {  	//We should never end up here' but if so this is the formula to calculate the bits...  	return 12 - (int)Math.Truncate (Math.Log (decompPos - 1 >> 4' 2) + 1);  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetLengthBits,The following statement contains a magic number: if (decompPos <= 64) {  	return 10;  }  else if (decompPos <= 128) {  	return 9;  }  else if (decompPos <= 256) {  	return 8;  }  else if (decompPos <= 512) {  	return 7;  }  else if (decompPos <= 1024) {  	return 6;  }  else if (decompPos <= 2048) {  	return 5;  }  else if (decompPos <= 4096) {  	return 4;  }  else {  	//We should never end up here' but if so this is the formula to calculate the bits...  	return 12 - (int)Math.Truncate (Math.Log (decompPos - 1 >> 4' 2) + 1);  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetLengthBits,The following statement contains a magic number: if (decompPos <= 64) {  	return 10;  }  else if (decompPos <= 128) {  	return 9;  }  else if (decompPos <= 256) {  	return 8;  }  else if (decompPos <= 512) {  	return 7;  }  else if (decompPos <= 1024) {  	return 6;  }  else if (decompPos <= 2048) {  	return 5;  }  else if (decompPos <= 4096) {  	return 4;  }  else {  	//We should never end up here' but if so this is the formula to calculate the bits...  	return 12 - (int)Math.Truncate (Math.Log (decompPos - 1 >> 4' 2) + 1);  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetLengthBits,The following statement contains a magic number: if (decompPos <= 64) {  	return 10;  }  else if (decompPos <= 128) {  	return 9;  }  else if (decompPos <= 256) {  	return 8;  }  else if (decompPos <= 512) {  	return 7;  }  else if (decompPos <= 1024) {  	return 6;  }  else if (decompPos <= 2048) {  	return 5;  }  else if (decompPos <= 4096) {  	return 4;  }  else {  	//We should never end up here' but if so this is the formula to calculate the bits...  	return 12 - (int)Math.Truncate (Math.Log (decompPos - 1 >> 4' 2) + 1);  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetLengthBits,The following statement contains a magic number: if (decompPos <= 64) {  	return 10;  }  else if (decompPos <= 128) {  	return 9;  }  else if (decompPos <= 256) {  	return 8;  }  else if (decompPos <= 512) {  	return 7;  }  else if (decompPos <= 1024) {  	return 6;  }  else if (decompPos <= 2048) {  	return 5;  }  else if (decompPos <= 4096) {  	return 4;  }  else {  	//We should never end up here' but if so this is the formula to calculate the bits...  	return 12 - (int)Math.Truncate (Math.Log (decompPos - 1 >> 4' 2) + 1);  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetLengthBits,The following statement contains a magic number: if (decompPos <= 64) {  	return 10;  }  else if (decompPos <= 128) {  	return 9;  }  else if (decompPos <= 256) {  	return 8;  }  else if (decompPos <= 512) {  	return 7;  }  else if (decompPos <= 1024) {  	return 6;  }  else if (decompPos <= 2048) {  	return 5;  }  else if (decompPos <= 4096) {  	return 4;  }  else {  	//We should never end up here' but if so this is the formula to calculate the bits...  	return 12 - (int)Math.Truncate (Math.Log (decompPos - 1 >> 4' 2) + 1);  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetLengthBits,The following statement contains a magic number: if (decompPos <= 64) {  	return 10;  }  else if (decompPos <= 128) {  	return 9;  }  else if (decompPos <= 256) {  	return 8;  }  else if (decompPos <= 512) {  	return 7;  }  else if (decompPos <= 1024) {  	return 6;  }  else if (decompPos <= 2048) {  	return 5;  }  else if (decompPos <= 4096) {  	return 4;  }  else {  	//We should never end up here' but if so this is the formula to calculate the bits...  	return 12 - (int)Math.Truncate (Math.Log (decompPos - 1 >> 4' 2) + 1);  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetLengthBits,The following statement contains a magic number: if (decompPos <= 64) {  	return 10;  }  else if (decompPos <= 128) {  	return 9;  }  else if (decompPos <= 256) {  	return 8;  }  else if (decompPos <= 512) {  	return 7;  }  else if (decompPos <= 1024) {  	return 6;  }  else if (decompPos <= 2048) {  	return 5;  }  else if (decompPos <= 4096) {  	return 4;  }  else {  	//We should never end up here' but if so this is the formula to calculate the bits...  	return 12 - (int)Math.Truncate (Math.Log (decompPos - 1 >> 4' 2) + 1);  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetLengthBits,The following statement contains a magic number: if (decompPos <= 64) {  	return 10;  }  else if (decompPos <= 128) {  	return 9;  }  else if (decompPos <= 256) {  	return 8;  }  else if (decompPos <= 512) {  	return 7;  }  else if (decompPos <= 1024) {  	return 6;  }  else if (decompPos <= 2048) {  	return 5;  }  else if (decompPos <= 4096) {  	return 4;  }  else {  	//We should never end up here' but if so this is the formula to calculate the bits...  	return 12 - (int)Math.Truncate (Math.Log (decompPos - 1 >> 4' 2) + 1);  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetLengthBits,The following statement contains a magic number: if (decompPos <= 64) {  	return 10;  }  else if (decompPos <= 128) {  	return 9;  }  else if (decompPos <= 256) {  	return 8;  }  else if (decompPos <= 512) {  	return 7;  }  else if (decompPos <= 1024) {  	return 6;  }  else if (decompPos <= 2048) {  	return 5;  }  else if (decompPos <= 4096) {  	return 4;  }  else {  	//We should never end up here' but if so this is the formula to calculate the bits...  	return 12 - (int)Math.Truncate (Math.Log (decompPos - 1 >> 4' 2) + 1);  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetLengthBits,The following statement contains a magic number: if (decompPos <= 64) {  	return 10;  }  else if (decompPos <= 128) {  	return 9;  }  else if (decompPos <= 256) {  	return 8;  }  else if (decompPos <= 512) {  	return 7;  }  else if (decompPos <= 1024) {  	return 6;  }  else if (decompPos <= 2048) {  	return 5;  }  else if (decompPos <= 4096) {  	return 4;  }  else {  	//We should never end up here' but if so this is the formula to calculate the bits...  	return 12 - (int)Math.Truncate (Math.Log (decompPos - 1 >> 4' 2) + 1);  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetLengthBits,The following statement contains a magic number: if (decompPos <= 64) {  	return 10;  }  else if (decompPos <= 128) {  	return 9;  }  else if (decompPos <= 256) {  	return 8;  }  else if (decompPos <= 512) {  	return 7;  }  else if (decompPos <= 1024) {  	return 6;  }  else if (decompPos <= 2048) {  	return 5;  }  else if (decompPos <= 4096) {  	return 4;  }  else {  	//We should never end up here' but if so this is the formula to calculate the bits...  	return 12 - (int)Math.Truncate (Math.Log (decompPos - 1 >> 4' 2) + 1);  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetLengthBits,The following statement contains a magic number: if (decompPos <= 64) {  	return 10;  }  else if (decompPos <= 128) {  	return 9;  }  else if (decompPos <= 256) {  	return 8;  }  else if (decompPos <= 512) {  	return 7;  }  else if (decompPos <= 1024) {  	return 6;  }  else if (decompPos <= 2048) {  	return 5;  }  else if (decompPos <= 4096) {  	return 4;  }  else {  	//We should never end up here' but if so this is the formula to calculate the bits...  	return 12 - (int)Math.Truncate (Math.Log (decompPos - 1 >> 4' 2) + 1);  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetLengthBits,The following statement contains a magic number: if (decompPos <= 64) {  	return 10;  }  else if (decompPos <= 128) {  	return 9;  }  else if (decompPos <= 256) {  	return 8;  }  else if (decompPos <= 512) {  	return 7;  }  else if (decompPos <= 1024) {  	return 6;  }  else if (decompPos <= 2048) {  	return 5;  }  else if (decompPos <= 4096) {  	return 4;  }  else {  	//We should never end up here' but if so this is the formula to calculate the bits...  	return 12 - (int)Math.Truncate (Math.Log (decompPos - 1 >> 4' 2) + 1);  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetLengthBits,The following statement contains a magic number: return 10;  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetLengthBits,The following statement contains a magic number: if (decompPos <= 128) {  	return 9;  }  else if (decompPos <= 256) {  	return 8;  }  else if (decompPos <= 512) {  	return 7;  }  else if (decompPos <= 1024) {  	return 6;  }  else if (decompPos <= 2048) {  	return 5;  }  else if (decompPos <= 4096) {  	return 4;  }  else {  	//We should never end up here' but if so this is the formula to calculate the bits...  	return 12 - (int)Math.Truncate (Math.Log (decompPos - 1 >> 4' 2) + 1);  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetLengthBits,The following statement contains a magic number: if (decompPos <= 128) {  	return 9;  }  else if (decompPos <= 256) {  	return 8;  }  else if (decompPos <= 512) {  	return 7;  }  else if (decompPos <= 1024) {  	return 6;  }  else if (decompPos <= 2048) {  	return 5;  }  else if (decompPos <= 4096) {  	return 4;  }  else {  	//We should never end up here' but if so this is the formula to calculate the bits...  	return 12 - (int)Math.Truncate (Math.Log (decompPos - 1 >> 4' 2) + 1);  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetLengthBits,The following statement contains a magic number: if (decompPos <= 128) {  	return 9;  }  else if (decompPos <= 256) {  	return 8;  }  else if (decompPos <= 512) {  	return 7;  }  else if (decompPos <= 1024) {  	return 6;  }  else if (decompPos <= 2048) {  	return 5;  }  else if (decompPos <= 4096) {  	return 4;  }  else {  	//We should never end up here' but if so this is the formula to calculate the bits...  	return 12 - (int)Math.Truncate (Math.Log (decompPos - 1 >> 4' 2) + 1);  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetLengthBits,The following statement contains a magic number: if (decompPos <= 128) {  	return 9;  }  else if (decompPos <= 256) {  	return 8;  }  else if (decompPos <= 512) {  	return 7;  }  else if (decompPos <= 1024) {  	return 6;  }  else if (decompPos <= 2048) {  	return 5;  }  else if (decompPos <= 4096) {  	return 4;  }  else {  	//We should never end up here' but if so this is the formula to calculate the bits...  	return 12 - (int)Math.Truncate (Math.Log (decompPos - 1 >> 4' 2) + 1);  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetLengthBits,The following statement contains a magic number: if (decompPos <= 128) {  	return 9;  }  else if (decompPos <= 256) {  	return 8;  }  else if (decompPos <= 512) {  	return 7;  }  else if (decompPos <= 1024) {  	return 6;  }  else if (decompPos <= 2048) {  	return 5;  }  else if (decompPos <= 4096) {  	return 4;  }  else {  	//We should never end up here' but if so this is the formula to calculate the bits...  	return 12 - (int)Math.Truncate (Math.Log (decompPos - 1 >> 4' 2) + 1);  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetLengthBits,The following statement contains a magic number: if (decompPos <= 128) {  	return 9;  }  else if (decompPos <= 256) {  	return 8;  }  else if (decompPos <= 512) {  	return 7;  }  else if (decompPos <= 1024) {  	return 6;  }  else if (decompPos <= 2048) {  	return 5;  }  else if (decompPos <= 4096) {  	return 4;  }  else {  	//We should never end up here' but if so this is the formula to calculate the bits...  	return 12 - (int)Math.Truncate (Math.Log (decompPos - 1 >> 4' 2) + 1);  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetLengthBits,The following statement contains a magic number: if (decompPos <= 128) {  	return 9;  }  else if (decompPos <= 256) {  	return 8;  }  else if (decompPos <= 512) {  	return 7;  }  else if (decompPos <= 1024) {  	return 6;  }  else if (decompPos <= 2048) {  	return 5;  }  else if (decompPos <= 4096) {  	return 4;  }  else {  	//We should never end up here' but if so this is the formula to calculate the bits...  	return 12 - (int)Math.Truncate (Math.Log (decompPos - 1 >> 4' 2) + 1);  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetLengthBits,The following statement contains a magic number: if (decompPos <= 128) {  	return 9;  }  else if (decompPos <= 256) {  	return 8;  }  else if (decompPos <= 512) {  	return 7;  }  else if (decompPos <= 1024) {  	return 6;  }  else if (decompPos <= 2048) {  	return 5;  }  else if (decompPos <= 4096) {  	return 4;  }  else {  	//We should never end up here' but if so this is the formula to calculate the bits...  	return 12 - (int)Math.Truncate (Math.Log (decompPos - 1 >> 4' 2) + 1);  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetLengthBits,The following statement contains a magic number: if (decompPos <= 128) {  	return 9;  }  else if (decompPos <= 256) {  	return 8;  }  else if (decompPos <= 512) {  	return 7;  }  else if (decompPos <= 1024) {  	return 6;  }  else if (decompPos <= 2048) {  	return 5;  }  else if (decompPos <= 4096) {  	return 4;  }  else {  	//We should never end up here' but if so this is the formula to calculate the bits...  	return 12 - (int)Math.Truncate (Math.Log (decompPos - 1 >> 4' 2) + 1);  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetLengthBits,The following statement contains a magic number: if (decompPos <= 128) {  	return 9;  }  else if (decompPos <= 256) {  	return 8;  }  else if (decompPos <= 512) {  	return 7;  }  else if (decompPos <= 1024) {  	return 6;  }  else if (decompPos <= 2048) {  	return 5;  }  else if (decompPos <= 4096) {  	return 4;  }  else {  	//We should never end up here' but if so this is the formula to calculate the bits...  	return 12 - (int)Math.Truncate (Math.Log (decompPos - 1 >> 4' 2) + 1);  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetLengthBits,The following statement contains a magic number: if (decompPos <= 128) {  	return 9;  }  else if (decompPos <= 256) {  	return 8;  }  else if (decompPos <= 512) {  	return 7;  }  else if (decompPos <= 1024) {  	return 6;  }  else if (decompPos <= 2048) {  	return 5;  }  else if (decompPos <= 4096) {  	return 4;  }  else {  	//We should never end up here' but if so this is the formula to calculate the bits...  	return 12 - (int)Math.Truncate (Math.Log (decompPos - 1 >> 4' 2) + 1);  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetLengthBits,The following statement contains a magic number: if (decompPos <= 128) {  	return 9;  }  else if (decompPos <= 256) {  	return 8;  }  else if (decompPos <= 512) {  	return 7;  }  else if (decompPos <= 1024) {  	return 6;  }  else if (decompPos <= 2048) {  	return 5;  }  else if (decompPos <= 4096) {  	return 4;  }  else {  	//We should never end up here' but if so this is the formula to calculate the bits...  	return 12 - (int)Math.Truncate (Math.Log (decompPos - 1 >> 4' 2) + 1);  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetLengthBits,The following statement contains a magic number: if (decompPos <= 128) {  	return 9;  }  else if (decompPos <= 256) {  	return 8;  }  else if (decompPos <= 512) {  	return 7;  }  else if (decompPos <= 1024) {  	return 6;  }  else if (decompPos <= 2048) {  	return 5;  }  else if (decompPos <= 4096) {  	return 4;  }  else {  	//We should never end up here' but if so this is the formula to calculate the bits...  	return 12 - (int)Math.Truncate (Math.Log (decompPos - 1 >> 4' 2) + 1);  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetLengthBits,The following statement contains a magic number: if (decompPos <= 128) {  	return 9;  }  else if (decompPos <= 256) {  	return 8;  }  else if (decompPos <= 512) {  	return 7;  }  else if (decompPos <= 1024) {  	return 6;  }  else if (decompPos <= 2048) {  	return 5;  }  else if (decompPos <= 4096) {  	return 4;  }  else {  	//We should never end up here' but if so this is the formula to calculate the bits...  	return 12 - (int)Math.Truncate (Math.Log (decompPos - 1 >> 4' 2) + 1);  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetLengthBits,The following statement contains a magic number: if (decompPos <= 128) {  	return 9;  }  else if (decompPos <= 256) {  	return 8;  }  else if (decompPos <= 512) {  	return 7;  }  else if (decompPos <= 1024) {  	return 6;  }  else if (decompPos <= 2048) {  	return 5;  }  else if (decompPos <= 4096) {  	return 4;  }  else {  	//We should never end up here' but if so this is the formula to calculate the bits...  	return 12 - (int)Math.Truncate (Math.Log (decompPos - 1 >> 4' 2) + 1);  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetLengthBits,The following statement contains a magic number: return 9;  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetLengthBits,The following statement contains a magic number: if (decompPos <= 256) {  	return 8;  }  else if (decompPos <= 512) {  	return 7;  }  else if (decompPos <= 1024) {  	return 6;  }  else if (decompPos <= 2048) {  	return 5;  }  else if (decompPos <= 4096) {  	return 4;  }  else {  	//We should never end up here' but if so this is the formula to calculate the bits...  	return 12 - (int)Math.Truncate (Math.Log (decompPos - 1 >> 4' 2) + 1);  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetLengthBits,The following statement contains a magic number: if (decompPos <= 256) {  	return 8;  }  else if (decompPos <= 512) {  	return 7;  }  else if (decompPos <= 1024) {  	return 6;  }  else if (decompPos <= 2048) {  	return 5;  }  else if (decompPos <= 4096) {  	return 4;  }  else {  	//We should never end up here' but if so this is the formula to calculate the bits...  	return 12 - (int)Math.Truncate (Math.Log (decompPos - 1 >> 4' 2) + 1);  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetLengthBits,The following statement contains a magic number: if (decompPos <= 256) {  	return 8;  }  else if (decompPos <= 512) {  	return 7;  }  else if (decompPos <= 1024) {  	return 6;  }  else if (decompPos <= 2048) {  	return 5;  }  else if (decompPos <= 4096) {  	return 4;  }  else {  	//We should never end up here' but if so this is the formula to calculate the bits...  	return 12 - (int)Math.Truncate (Math.Log (decompPos - 1 >> 4' 2) + 1);  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetLengthBits,The following statement contains a magic number: if (decompPos <= 256) {  	return 8;  }  else if (decompPos <= 512) {  	return 7;  }  else if (decompPos <= 1024) {  	return 6;  }  else if (decompPos <= 2048) {  	return 5;  }  else if (decompPos <= 4096) {  	return 4;  }  else {  	//We should never end up here' but if so this is the formula to calculate the bits...  	return 12 - (int)Math.Truncate (Math.Log (decompPos - 1 >> 4' 2) + 1);  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetLengthBits,The following statement contains a magic number: if (decompPos <= 256) {  	return 8;  }  else if (decompPos <= 512) {  	return 7;  }  else if (decompPos <= 1024) {  	return 6;  }  else if (decompPos <= 2048) {  	return 5;  }  else if (decompPos <= 4096) {  	return 4;  }  else {  	//We should never end up here' but if so this is the formula to calculate the bits...  	return 12 - (int)Math.Truncate (Math.Log (decompPos - 1 >> 4' 2) + 1);  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetLengthBits,The following statement contains a magic number: if (decompPos <= 256) {  	return 8;  }  else if (decompPos <= 512) {  	return 7;  }  else if (decompPos <= 1024) {  	return 6;  }  else if (decompPos <= 2048) {  	return 5;  }  else if (decompPos <= 4096) {  	return 4;  }  else {  	//We should never end up here' but if so this is the formula to calculate the bits...  	return 12 - (int)Math.Truncate (Math.Log (decompPos - 1 >> 4' 2) + 1);  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetLengthBits,The following statement contains a magic number: if (decompPos <= 256) {  	return 8;  }  else if (decompPos <= 512) {  	return 7;  }  else if (decompPos <= 1024) {  	return 6;  }  else if (decompPos <= 2048) {  	return 5;  }  else if (decompPos <= 4096) {  	return 4;  }  else {  	//We should never end up here' but if so this is the formula to calculate the bits...  	return 12 - (int)Math.Truncate (Math.Log (decompPos - 1 >> 4' 2) + 1);  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetLengthBits,The following statement contains a magic number: if (decompPos <= 256) {  	return 8;  }  else if (decompPos <= 512) {  	return 7;  }  else if (decompPos <= 1024) {  	return 6;  }  else if (decompPos <= 2048) {  	return 5;  }  else if (decompPos <= 4096) {  	return 4;  }  else {  	//We should never end up here' but if so this is the formula to calculate the bits...  	return 12 - (int)Math.Truncate (Math.Log (decompPos - 1 >> 4' 2) + 1);  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetLengthBits,The following statement contains a magic number: if (decompPos <= 256) {  	return 8;  }  else if (decompPos <= 512) {  	return 7;  }  else if (decompPos <= 1024) {  	return 6;  }  else if (decompPos <= 2048) {  	return 5;  }  else if (decompPos <= 4096) {  	return 4;  }  else {  	//We should never end up here' but if so this is the formula to calculate the bits...  	return 12 - (int)Math.Truncate (Math.Log (decompPos - 1 >> 4' 2) + 1);  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetLengthBits,The following statement contains a magic number: if (decompPos <= 256) {  	return 8;  }  else if (decompPos <= 512) {  	return 7;  }  else if (decompPos <= 1024) {  	return 6;  }  else if (decompPos <= 2048) {  	return 5;  }  else if (decompPos <= 4096) {  	return 4;  }  else {  	//We should never end up here' but if so this is the formula to calculate the bits...  	return 12 - (int)Math.Truncate (Math.Log (decompPos - 1 >> 4' 2) + 1);  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetLengthBits,The following statement contains a magic number: if (decompPos <= 256) {  	return 8;  }  else if (decompPos <= 512) {  	return 7;  }  else if (decompPos <= 1024) {  	return 6;  }  else if (decompPos <= 2048) {  	return 5;  }  else if (decompPos <= 4096) {  	return 4;  }  else {  	//We should never end up here' but if so this is the formula to calculate the bits...  	return 12 - (int)Math.Truncate (Math.Log (decompPos - 1 >> 4' 2) + 1);  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetLengthBits,The following statement contains a magic number: if (decompPos <= 256) {  	return 8;  }  else if (decompPos <= 512) {  	return 7;  }  else if (decompPos <= 1024) {  	return 6;  }  else if (decompPos <= 2048) {  	return 5;  }  else if (decompPos <= 4096) {  	return 4;  }  else {  	//We should never end up here' but if so this is the formula to calculate the bits...  	return 12 - (int)Math.Truncate (Math.Log (decompPos - 1 >> 4' 2) + 1);  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetLengthBits,The following statement contains a magic number: if (decompPos <= 256) {  	return 8;  }  else if (decompPos <= 512) {  	return 7;  }  else if (decompPos <= 1024) {  	return 6;  }  else if (decompPos <= 2048) {  	return 5;  }  else if (decompPos <= 4096) {  	return 4;  }  else {  	//We should never end up here' but if so this is the formula to calculate the bits...  	return 12 - (int)Math.Truncate (Math.Log (decompPos - 1 >> 4' 2) + 1);  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetLengthBits,The following statement contains a magic number: return 8;  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetLengthBits,The following statement contains a magic number: if (decompPos <= 512) {  	return 7;  }  else if (decompPos <= 1024) {  	return 6;  }  else if (decompPos <= 2048) {  	return 5;  }  else if (decompPos <= 4096) {  	return 4;  }  else {  	//We should never end up here' but if so this is the formula to calculate the bits...  	return 12 - (int)Math.Truncate (Math.Log (decompPos - 1 >> 4' 2) + 1);  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetLengthBits,The following statement contains a magic number: if (decompPos <= 512) {  	return 7;  }  else if (decompPos <= 1024) {  	return 6;  }  else if (decompPos <= 2048) {  	return 5;  }  else if (decompPos <= 4096) {  	return 4;  }  else {  	//We should never end up here' but if so this is the formula to calculate the bits...  	return 12 - (int)Math.Truncate (Math.Log (decompPos - 1 >> 4' 2) + 1);  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetLengthBits,The following statement contains a magic number: if (decompPos <= 512) {  	return 7;  }  else if (decompPos <= 1024) {  	return 6;  }  else if (decompPos <= 2048) {  	return 5;  }  else if (decompPos <= 4096) {  	return 4;  }  else {  	//We should never end up here' but if so this is the formula to calculate the bits...  	return 12 - (int)Math.Truncate (Math.Log (decompPos - 1 >> 4' 2) + 1);  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetLengthBits,The following statement contains a magic number: if (decompPos <= 512) {  	return 7;  }  else if (decompPos <= 1024) {  	return 6;  }  else if (decompPos <= 2048) {  	return 5;  }  else if (decompPos <= 4096) {  	return 4;  }  else {  	//We should never end up here' but if so this is the formula to calculate the bits...  	return 12 - (int)Math.Truncate (Math.Log (decompPos - 1 >> 4' 2) + 1);  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetLengthBits,The following statement contains a magic number: if (decompPos <= 512) {  	return 7;  }  else if (decompPos <= 1024) {  	return 6;  }  else if (decompPos <= 2048) {  	return 5;  }  else if (decompPos <= 4096) {  	return 4;  }  else {  	//We should never end up here' but if so this is the formula to calculate the bits...  	return 12 - (int)Math.Truncate (Math.Log (decompPos - 1 >> 4' 2) + 1);  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetLengthBits,The following statement contains a magic number: if (decompPos <= 512) {  	return 7;  }  else if (decompPos <= 1024) {  	return 6;  }  else if (decompPos <= 2048) {  	return 5;  }  else if (decompPos <= 4096) {  	return 4;  }  else {  	//We should never end up here' but if so this is the formula to calculate the bits...  	return 12 - (int)Math.Truncate (Math.Log (decompPos - 1 >> 4' 2) + 1);  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetLengthBits,The following statement contains a magic number: if (decompPos <= 512) {  	return 7;  }  else if (decompPos <= 1024) {  	return 6;  }  else if (decompPos <= 2048) {  	return 5;  }  else if (decompPos <= 4096) {  	return 4;  }  else {  	//We should never end up here' but if so this is the formula to calculate the bits...  	return 12 - (int)Math.Truncate (Math.Log (decompPos - 1 >> 4' 2) + 1);  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetLengthBits,The following statement contains a magic number: if (decompPos <= 512) {  	return 7;  }  else if (decompPos <= 1024) {  	return 6;  }  else if (decompPos <= 2048) {  	return 5;  }  else if (decompPos <= 4096) {  	return 4;  }  else {  	//We should never end up here' but if so this is the formula to calculate the bits...  	return 12 - (int)Math.Truncate (Math.Log (decompPos - 1 >> 4' 2) + 1);  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetLengthBits,The following statement contains a magic number: if (decompPos <= 512) {  	return 7;  }  else if (decompPos <= 1024) {  	return 6;  }  else if (decompPos <= 2048) {  	return 5;  }  else if (decompPos <= 4096) {  	return 4;  }  else {  	//We should never end up here' but if so this is the formula to calculate the bits...  	return 12 - (int)Math.Truncate (Math.Log (decompPos - 1 >> 4' 2) + 1);  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetLengthBits,The following statement contains a magic number: if (decompPos <= 512) {  	return 7;  }  else if (decompPos <= 1024) {  	return 6;  }  else if (decompPos <= 2048) {  	return 5;  }  else if (decompPos <= 4096) {  	return 4;  }  else {  	//We should never end up here' but if so this is the formula to calculate the bits...  	return 12 - (int)Math.Truncate (Math.Log (decompPos - 1 >> 4' 2) + 1);  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetLengthBits,The following statement contains a magic number: if (decompPos <= 512) {  	return 7;  }  else if (decompPos <= 1024) {  	return 6;  }  else if (decompPos <= 2048) {  	return 5;  }  else if (decompPos <= 4096) {  	return 4;  }  else {  	//We should never end up here' but if so this is the formula to calculate the bits...  	return 12 - (int)Math.Truncate (Math.Log (decompPos - 1 >> 4' 2) + 1);  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetLengthBits,The following statement contains a magic number: return 7;  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetLengthBits,The following statement contains a magic number: if (decompPos <= 1024) {  	return 6;  }  else if (decompPos <= 2048) {  	return 5;  }  else if (decompPos <= 4096) {  	return 4;  }  else {  	//We should never end up here' but if so this is the formula to calculate the bits...  	return 12 - (int)Math.Truncate (Math.Log (decompPos - 1 >> 4' 2) + 1);  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetLengthBits,The following statement contains a magic number: if (decompPos <= 1024) {  	return 6;  }  else if (decompPos <= 2048) {  	return 5;  }  else if (decompPos <= 4096) {  	return 4;  }  else {  	//We should never end up here' but if so this is the formula to calculate the bits...  	return 12 - (int)Math.Truncate (Math.Log (decompPos - 1 >> 4' 2) + 1);  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetLengthBits,The following statement contains a magic number: if (decompPos <= 1024) {  	return 6;  }  else if (decompPos <= 2048) {  	return 5;  }  else if (decompPos <= 4096) {  	return 4;  }  else {  	//We should never end up here' but if so this is the formula to calculate the bits...  	return 12 - (int)Math.Truncate (Math.Log (decompPos - 1 >> 4' 2) + 1);  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetLengthBits,The following statement contains a magic number: if (decompPos <= 1024) {  	return 6;  }  else if (decompPos <= 2048) {  	return 5;  }  else if (decompPos <= 4096) {  	return 4;  }  else {  	//We should never end up here' but if so this is the formula to calculate the bits...  	return 12 - (int)Math.Truncate (Math.Log (decompPos - 1 >> 4' 2) + 1);  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetLengthBits,The following statement contains a magic number: if (decompPos <= 1024) {  	return 6;  }  else if (decompPos <= 2048) {  	return 5;  }  else if (decompPos <= 4096) {  	return 4;  }  else {  	//We should never end up here' but if so this is the formula to calculate the bits...  	return 12 - (int)Math.Truncate (Math.Log (decompPos - 1 >> 4' 2) + 1);  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetLengthBits,The following statement contains a magic number: if (decompPos <= 1024) {  	return 6;  }  else if (decompPos <= 2048) {  	return 5;  }  else if (decompPos <= 4096) {  	return 4;  }  else {  	//We should never end up here' but if so this is the formula to calculate the bits...  	return 12 - (int)Math.Truncate (Math.Log (decompPos - 1 >> 4' 2) + 1);  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetLengthBits,The following statement contains a magic number: if (decompPos <= 1024) {  	return 6;  }  else if (decompPos <= 2048) {  	return 5;  }  else if (decompPos <= 4096) {  	return 4;  }  else {  	//We should never end up here' but if so this is the formula to calculate the bits...  	return 12 - (int)Math.Truncate (Math.Log (decompPos - 1 >> 4' 2) + 1);  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetLengthBits,The following statement contains a magic number: if (decompPos <= 1024) {  	return 6;  }  else if (decompPos <= 2048) {  	return 5;  }  else if (decompPos <= 4096) {  	return 4;  }  else {  	//We should never end up here' but if so this is the formula to calculate the bits...  	return 12 - (int)Math.Truncate (Math.Log (decompPos - 1 >> 4' 2) + 1);  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetLengthBits,The following statement contains a magic number: if (decompPos <= 1024) {  	return 6;  }  else if (decompPos <= 2048) {  	return 5;  }  else if (decompPos <= 4096) {  	return 4;  }  else {  	//We should never end up here' but if so this is the formula to calculate the bits...  	return 12 - (int)Math.Truncate (Math.Log (decompPos - 1 >> 4' 2) + 1);  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetLengthBits,The following statement contains a magic number: return 6;  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetLengthBits,The following statement contains a magic number: if (decompPos <= 2048) {  	return 5;  }  else if (decompPos <= 4096) {  	return 4;  }  else {  	//We should never end up here' but if so this is the formula to calculate the bits...  	return 12 - (int)Math.Truncate (Math.Log (decompPos - 1 >> 4' 2) + 1);  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetLengthBits,The following statement contains a magic number: if (decompPos <= 2048) {  	return 5;  }  else if (decompPos <= 4096) {  	return 4;  }  else {  	//We should never end up here' but if so this is the formula to calculate the bits...  	return 12 - (int)Math.Truncate (Math.Log (decompPos - 1 >> 4' 2) + 1);  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetLengthBits,The following statement contains a magic number: if (decompPos <= 2048) {  	return 5;  }  else if (decompPos <= 4096) {  	return 4;  }  else {  	//We should never end up here' but if so this is the formula to calculate the bits...  	return 12 - (int)Math.Truncate (Math.Log (decompPos - 1 >> 4' 2) + 1);  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetLengthBits,The following statement contains a magic number: if (decompPos <= 2048) {  	return 5;  }  else if (decompPos <= 4096) {  	return 4;  }  else {  	//We should never end up here' but if so this is the formula to calculate the bits...  	return 12 - (int)Math.Truncate (Math.Log (decompPos - 1 >> 4' 2) + 1);  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetLengthBits,The following statement contains a magic number: if (decompPos <= 2048) {  	return 5;  }  else if (decompPos <= 4096) {  	return 4;  }  else {  	//We should never end up here' but if so this is the formula to calculate the bits...  	return 12 - (int)Math.Truncate (Math.Log (decompPos - 1 >> 4' 2) + 1);  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetLengthBits,The following statement contains a magic number: if (decompPos <= 2048) {  	return 5;  }  else if (decompPos <= 4096) {  	return 4;  }  else {  	//We should never end up here' but if so this is the formula to calculate the bits...  	return 12 - (int)Math.Truncate (Math.Log (decompPos - 1 >> 4' 2) + 1);  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetLengthBits,The following statement contains a magic number: if (decompPos <= 2048) {  	return 5;  }  else if (decompPos <= 4096) {  	return 4;  }  else {  	//We should never end up here' but if so this is the formula to calculate the bits...  	return 12 - (int)Math.Truncate (Math.Log (decompPos - 1 >> 4' 2) + 1);  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetLengthBits,The following statement contains a magic number: return 5;  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetLengthBits,The following statement contains a magic number: if (decompPos <= 4096) {  	return 4;  }  else {  	//We should never end up here' but if so this is the formula to calculate the bits...  	return 12 - (int)Math.Truncate (Math.Log (decompPos - 1 >> 4' 2) + 1);  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetLengthBits,The following statement contains a magic number: if (decompPos <= 4096) {  	return 4;  }  else {  	//We should never end up here' but if so this is the formula to calculate the bits...  	return 12 - (int)Math.Truncate (Math.Log (decompPos - 1 >> 4' 2) + 1);  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetLengthBits,The following statement contains a magic number: if (decompPos <= 4096) {  	return 4;  }  else {  	//We should never end up here' but if so this is the formula to calculate the bits...  	return 12 - (int)Math.Truncate (Math.Log (decompPos - 1 >> 4' 2) + 1);  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetLengthBits,The following statement contains a magic number: if (decompPos <= 4096) {  	return 4;  }  else {  	//We should never end up here' but if so this is the formula to calculate the bits...  	return 12 - (int)Math.Truncate (Math.Log (decompPos - 1 >> 4' 2) + 1);  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetLengthBits,The following statement contains a magic number: if (decompPos <= 4096) {  	return 4;  }  else {  	//We should never end up here' but if so this is the formula to calculate the bits...  	return 12 - (int)Math.Truncate (Math.Log (decompPos - 1 >> 4' 2) + 1);  }  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetLengthBits,The following statement contains a magic number: return 4;  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetLengthBits,The following statement contains a magic number: return 12 - (int)Math.Truncate (Math.Log (decompPos - 1 >> 4' 2) + 1);  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetLengthBits,The following statement contains a magic number: return 12 - (int)Math.Truncate (Math.Log (decompPos - 1 >> 4' 2) + 1);  
Magic Number,OfficeOpenXml.Utils,CompoundDocument,C:\repos\bambit_EPPlus\EPPlus\Utils\CompoundDocument.cs,GetLengthBits,The following statement contains a magic number: return 12 - (int)Math.Truncate (Math.Log (decompPos - 1 >> 4' 2) + 1);  
Magic Number,OfficeOpenXml.Style.Dxf,ExcelDxfStyleConditionalFormatting,C:\repos\bambit_EPPlus\EPPlus\Style\Dxf\ExcelDxfStyle.cs,ExcelDxfStyleConditionalFormatting,The following statement contains a magic number: if (topNode != null) {  	_helper = new XmlHelperInstance (nameSpaceManager' topNode);  	NumberFormat.NumFmtID = _helper.GetXmlNodeInt ("d:numFmt/@numFmtId");  	NumberFormat.Format = _helper.GetXmlNodeString ("d:numFmt/@formatCode");  	if (NumberFormat.NumFmtID < 164 && string.IsNullOrEmpty (NumberFormat.Format)) {  		NumberFormat.Format = ExcelNumberFormat.GetFromBuildInFromID (NumberFormat.NumFmtID);  	}  	Font.Bold = _helper.GetXmlNodeBoolNullable ("d:font/d:b/@val");  	Font.Italic = _helper.GetXmlNodeBoolNullable ("d:font/d:i/@val");  	Font.Strike = _helper.GetXmlNodeBoolNullable ("d:font/d:strike");  	Font.Underline = GetUnderLineEnum (_helper.GetXmlNodeString ("d:font/d:u/@val"));  	Font.Color = GetColor (_helper' "d:font/d:color");  	Border.Left = GetBorderItem (_helper' "d:border/d:left");  	Border.Right = GetBorderItem (_helper' "d:border/d:right");  	Border.Bottom = GetBorderItem (_helper' "d:border/d:bottom");  	Border.Top = GetBorderItem (_helper' "d:border/d:top");  	Fill.PatternType = GetPatternTypeEnum (_helper.GetXmlNodeString ("d:fill/d:patternFill/@patternType"));  	Fill.BackgroundColor = GetColor (_helper' "d:fill/d:patternFill/d:bgColor/");  	Fill.PatternColor = GetColor (_helper' "d:fill/d:patternFill/d:fgColor/");  }  else {  	_helper = new XmlHelperInstance (nameSpaceManager);  }  
Magic Number,OfficeOpenXml.Style.Dxf,ExcelDxfStyleConditionalFormatting,C:\repos\bambit_EPPlus\EPPlus\Style\Dxf\ExcelDxfStyle.cs,ExcelDxfStyleConditionalFormatting,The following statement contains a magic number: if (NumberFormat.NumFmtID < 164 && string.IsNullOrEmpty (NumberFormat.Format)) {  	NumberFormat.Format = ExcelNumberFormat.GetFromBuildInFromID (NumberFormat.NumFmtID);  }  
Magic Number,OfficeOpenXml.Style.Dxf,ExcelDxfStyleConditionalFormatting,C:\repos\bambit_EPPlus\EPPlus\Style\Dxf\ExcelDxfStyle.cs,GetColor,The following statement contains a magic number: if (rgb != "") {  	ret.Color = Color.FromArgb (int.Parse (rgb.Substring (0' 2)' System.Globalization.NumberStyles.AllowHexSpecifier)' int.Parse (rgb.Substring (2' 2)' System.Globalization.NumberStyles.AllowHexSpecifier)' int.Parse (rgb.Substring (4' 2)' System.Globalization.NumberStyles.AllowHexSpecifier)' int.Parse (rgb.Substring (6' 2)' System.Globalization.NumberStyles.AllowHexSpecifier));  }  
Magic Number,OfficeOpenXml.Style.Dxf,ExcelDxfStyleConditionalFormatting,C:\repos\bambit_EPPlus\EPPlus\Style\Dxf\ExcelDxfStyle.cs,GetColor,The following statement contains a magic number: if (rgb != "") {  	ret.Color = Color.FromArgb (int.Parse (rgb.Substring (0' 2)' System.Globalization.NumberStyles.AllowHexSpecifier)' int.Parse (rgb.Substring (2' 2)' System.Globalization.NumberStyles.AllowHexSpecifier)' int.Parse (rgb.Substring (4' 2)' System.Globalization.NumberStyles.AllowHexSpecifier)' int.Parse (rgb.Substring (6' 2)' System.Globalization.NumberStyles.AllowHexSpecifier));  }  
Magic Number,OfficeOpenXml.Style.Dxf,ExcelDxfStyleConditionalFormatting,C:\repos\bambit_EPPlus\EPPlus\Style\Dxf\ExcelDxfStyle.cs,GetColor,The following statement contains a magic number: if (rgb != "") {  	ret.Color = Color.FromArgb (int.Parse (rgb.Substring (0' 2)' System.Globalization.NumberStyles.AllowHexSpecifier)' int.Parse (rgb.Substring (2' 2)' System.Globalization.NumberStyles.AllowHexSpecifier)' int.Parse (rgb.Substring (4' 2)' System.Globalization.NumberStyles.AllowHexSpecifier)' int.Parse (rgb.Substring (6' 2)' System.Globalization.NumberStyles.AllowHexSpecifier));  }  
Magic Number,OfficeOpenXml.Style.Dxf,ExcelDxfStyleConditionalFormatting,C:\repos\bambit_EPPlus\EPPlus\Style\Dxf\ExcelDxfStyle.cs,GetColor,The following statement contains a magic number: if (rgb != "") {  	ret.Color = Color.FromArgb (int.Parse (rgb.Substring (0' 2)' System.Globalization.NumberStyles.AllowHexSpecifier)' int.Parse (rgb.Substring (2' 2)' System.Globalization.NumberStyles.AllowHexSpecifier)' int.Parse (rgb.Substring (4' 2)' System.Globalization.NumberStyles.AllowHexSpecifier)' int.Parse (rgb.Substring (6' 2)' System.Globalization.NumberStyles.AllowHexSpecifier));  }  
Magic Number,OfficeOpenXml.Style.Dxf,ExcelDxfStyleConditionalFormatting,C:\repos\bambit_EPPlus\EPPlus\Style\Dxf\ExcelDxfStyle.cs,GetColor,The following statement contains a magic number: if (rgb != "") {  	ret.Color = Color.FromArgb (int.Parse (rgb.Substring (0' 2)' System.Globalization.NumberStyles.AllowHexSpecifier)' int.Parse (rgb.Substring (2' 2)' System.Globalization.NumberStyles.AllowHexSpecifier)' int.Parse (rgb.Substring (4' 2)' System.Globalization.NumberStyles.AllowHexSpecifier)' int.Parse (rgb.Substring (6' 2)' System.Globalization.NumberStyles.AllowHexSpecifier));  }  
Magic Number,OfficeOpenXml.Style.Dxf,ExcelDxfStyleConditionalFormatting,C:\repos\bambit_EPPlus\EPPlus\Style\Dxf\ExcelDxfStyle.cs,GetColor,The following statement contains a magic number: if (rgb != "") {  	ret.Color = Color.FromArgb (int.Parse (rgb.Substring (0' 2)' System.Globalization.NumberStyles.AllowHexSpecifier)' int.Parse (rgb.Substring (2' 2)' System.Globalization.NumberStyles.AllowHexSpecifier)' int.Parse (rgb.Substring (4' 2)' System.Globalization.NumberStyles.AllowHexSpecifier)' int.Parse (rgb.Substring (6' 2)' System.Globalization.NumberStyles.AllowHexSpecifier));  }  
Magic Number,OfficeOpenXml.Style.Dxf,ExcelDxfStyleConditionalFormatting,C:\repos\bambit_EPPlus\EPPlus\Style\Dxf\ExcelDxfStyle.cs,GetColor,The following statement contains a magic number: if (rgb != "") {  	ret.Color = Color.FromArgb (int.Parse (rgb.Substring (0' 2)' System.Globalization.NumberStyles.AllowHexSpecifier)' int.Parse (rgb.Substring (2' 2)' System.Globalization.NumberStyles.AllowHexSpecifier)' int.Parse (rgb.Substring (4' 2)' System.Globalization.NumberStyles.AllowHexSpecifier)' int.Parse (rgb.Substring (6' 2)' System.Globalization.NumberStyles.AllowHexSpecifier));  }  
Magic Number,OfficeOpenXml.Style.Dxf,ExcelDxfStyleConditionalFormatting,C:\repos\bambit_EPPlus\EPPlus\Style\Dxf\ExcelDxfStyle.cs,GetColor,The following statement contains a magic number: ret.Color = Color.FromArgb (int.Parse (rgb.Substring (0' 2)' System.Globalization.NumberStyles.AllowHexSpecifier)' int.Parse (rgb.Substring (2' 2)' System.Globalization.NumberStyles.AllowHexSpecifier)' int.Parse (rgb.Substring (4' 2)' System.Globalization.NumberStyles.AllowHexSpecifier)' int.Parse (rgb.Substring (6' 2)' System.Globalization.NumberStyles.AllowHexSpecifier));  
Magic Number,OfficeOpenXml.Style.Dxf,ExcelDxfStyleConditionalFormatting,C:\repos\bambit_EPPlus\EPPlus\Style\Dxf\ExcelDxfStyle.cs,GetColor,The following statement contains a magic number: ret.Color = Color.FromArgb (int.Parse (rgb.Substring (0' 2)' System.Globalization.NumberStyles.AllowHexSpecifier)' int.Parse (rgb.Substring (2' 2)' System.Globalization.NumberStyles.AllowHexSpecifier)' int.Parse (rgb.Substring (4' 2)' System.Globalization.NumberStyles.AllowHexSpecifier)' int.Parse (rgb.Substring (6' 2)' System.Globalization.NumberStyles.AllowHexSpecifier));  
Magic Number,OfficeOpenXml.Style.Dxf,ExcelDxfStyleConditionalFormatting,C:\repos\bambit_EPPlus\EPPlus\Style\Dxf\ExcelDxfStyle.cs,GetColor,The following statement contains a magic number: ret.Color = Color.FromArgb (int.Parse (rgb.Substring (0' 2)' System.Globalization.NumberStyles.AllowHexSpecifier)' int.Parse (rgb.Substring (2' 2)' System.Globalization.NumberStyles.AllowHexSpecifier)' int.Parse (rgb.Substring (4' 2)' System.Globalization.NumberStyles.AllowHexSpecifier)' int.Parse (rgb.Substring (6' 2)' System.Globalization.NumberStyles.AllowHexSpecifier));  
Magic Number,OfficeOpenXml.Style.Dxf,ExcelDxfStyleConditionalFormatting,C:\repos\bambit_EPPlus\EPPlus\Style\Dxf\ExcelDxfStyle.cs,GetColor,The following statement contains a magic number: ret.Color = Color.FromArgb (int.Parse (rgb.Substring (0' 2)' System.Globalization.NumberStyles.AllowHexSpecifier)' int.Parse (rgb.Substring (2' 2)' System.Globalization.NumberStyles.AllowHexSpecifier)' int.Parse (rgb.Substring (4' 2)' System.Globalization.NumberStyles.AllowHexSpecifier)' int.Parse (rgb.Substring (6' 2)' System.Globalization.NumberStyles.AllowHexSpecifier));  
Magic Number,OfficeOpenXml.Style.Dxf,ExcelDxfStyleConditionalFormatting,C:\repos\bambit_EPPlus\EPPlus\Style\Dxf\ExcelDxfStyle.cs,GetColor,The following statement contains a magic number: ret.Color = Color.FromArgb (int.Parse (rgb.Substring (0' 2)' System.Globalization.NumberStyles.AllowHexSpecifier)' int.Parse (rgb.Substring (2' 2)' System.Globalization.NumberStyles.AllowHexSpecifier)' int.Parse (rgb.Substring (4' 2)' System.Globalization.NumberStyles.AllowHexSpecifier)' int.Parse (rgb.Substring (6' 2)' System.Globalization.NumberStyles.AllowHexSpecifier));  
Magic Number,OfficeOpenXml.Style.Dxf,ExcelDxfStyleConditionalFormatting,C:\repos\bambit_EPPlus\EPPlus\Style\Dxf\ExcelDxfStyle.cs,GetColor,The following statement contains a magic number: ret.Color = Color.FromArgb (int.Parse (rgb.Substring (0' 2)' System.Globalization.NumberStyles.AllowHexSpecifier)' int.Parse (rgb.Substring (2' 2)' System.Globalization.NumberStyles.AllowHexSpecifier)' int.Parse (rgb.Substring (4' 2)' System.Globalization.NumberStyles.AllowHexSpecifier)' int.Parse (rgb.Substring (6' 2)' System.Globalization.NumberStyles.AllowHexSpecifier));  
Magic Number,OfficeOpenXml.Style.Dxf,ExcelDxfStyleConditionalFormatting,C:\repos\bambit_EPPlus\EPPlus\Style\Dxf\ExcelDxfStyle.cs,GetColor,The following statement contains a magic number: ret.Color = Color.FromArgb (int.Parse (rgb.Substring (0' 2)' System.Globalization.NumberStyles.AllowHexSpecifier)' int.Parse (rgb.Substring (2' 2)' System.Globalization.NumberStyles.AllowHexSpecifier)' int.Parse (rgb.Substring (4' 2)' System.Globalization.NumberStyles.AllowHexSpecifier)' int.Parse (rgb.Substring (6' 2)' System.Globalization.NumberStyles.AllowHexSpecifier));  
Magic Number,OfficeOpenXml.Style,ExcelParagraphCollection,C:\repos\bambit_EPPlus\EPPlus\Style\ExcelParagraphCollection.cs,Add,The following statement contains a magic number: rt.Size = 11;  
Magic Number,OfficeOpenXml.Style,ExcelRichTextCollection,C:\repos\bambit_EPPlus\EPPlus\Style\ExcelRichTextCollection.cs,Add,The following statement contains a magic number: if (_list.Count > 0) {  	ExcelRichText prevItem = _list [_list.Count - 1];  	rt.FontName = prevItem.FontName;  	rt.Size = prevItem.Size;  	if (prevItem.Color.IsEmpty) {  		rt.Color = Color.Black;  	}  	else {  		rt.Color = prevItem.Color;  	}  	rt.PreserveSpace = rt.PreserveSpace;  	rt.Bold = prevItem.Bold;  	rt.Italic = prevItem.Italic;  	rt.UnderLine = prevItem.UnderLine;  }  else if (_cells == null) {  	rt.FontName = "Calibri";  	rt.Size = 11;  }  else {  	var style = _cells.Offset (0' 0).Style;  	rt.FontName = style.Font.Name;  	rt.Size = style.Font.Size;  	rt.Bold = style.Font.Bold;  	rt.Italic = style.Font.Italic;  	_cells.IsRichText = true;  }  
Magic Number,OfficeOpenXml.Style,ExcelRichTextCollection,C:\repos\bambit_EPPlus\EPPlus\Style\ExcelRichTextCollection.cs,Add,The following statement contains a magic number: if (_cells == null) {  	rt.FontName = "Calibri";  	rt.Size = 11;  }  else {  	var style = _cells.Offset (0' 0).Style;  	rt.FontName = style.Font.Name;  	rt.Size = style.Font.Size;  	rt.Bold = style.Font.Bold;  	rt.Italic = style.Font.Italic;  	_cells.IsRichText = true;  }  
Magic Number,OfficeOpenXml.Style,ExcelRichTextCollection,C:\repos\bambit_EPPlus\EPPlus\Style\ExcelRichTextCollection.cs,Add,The following statement contains a magic number: rt.Size = 11;  
Magic Number,OfficeOpenXml.Style,ExcelNumberFormat,C:\repos\bambit_EPPlus\EPPlus\Style\ExcelNumberFormat.cs,GetFromBuildInFromID,The following statement contains a magic number: switch (_numFmtId) {  case 0:  	return "General";  case 1:  	return "0";  case 2:  	return "0.00";  case 3:  	return "#'##0";  case 4:  	return "#'##0.00";  case 9:  	return "0%";  case 10:  	return "0.00%";  case 11:  	return "0.00E+00";  case 12:  	return "# ?/?";  case 13:  	return "# ??/??";  case 14:  	return "mm-dd-yy";  case 15:  	return "d-mmm-yy";  case 16:  	return "d-mmm";  case 17:  	return "mmm-yy";  case 18:  	return "h:mm AM/PM";  case 19:  	return "h:mm:ss AM/PM";  case 20:  	return "h:mm";  case 21:  	return "h:mm:ss";  case 22:  	return "m/d/yy h:mm";  case 37:  	return "#'##0 ;(#'##0)";  case 38:  	return "#'##0 ;[Red](#'##0)";  case 39:  	return "#'##0.00;(#'##0.00)";  case 40:  	return "#'##0.00;[Red](#'#)";  case 45:  	return "mm:ss";  case 46:  	return "[h]:mm:ss";  case 47:  	return "mmss.0";  case 48:  	return "##0.0";  case 49:  	return "@";  default:  	return string.Empty;  }  
Magic Number,OfficeOpenXml.Style,ExcelNumberFormat,C:\repos\bambit_EPPlus\EPPlus\Style\ExcelNumberFormat.cs,GetFromBuildInFromID,The following statement contains a magic number: switch (_numFmtId) {  case 0:  	return "General";  case 1:  	return "0";  case 2:  	return "0.00";  case 3:  	return "#'##0";  case 4:  	return "#'##0.00";  case 9:  	return "0%";  case 10:  	return "0.00%";  case 11:  	return "0.00E+00";  case 12:  	return "# ?/?";  case 13:  	return "# ??/??";  case 14:  	return "mm-dd-yy";  case 15:  	return "d-mmm-yy";  case 16:  	return "d-mmm";  case 17:  	return "mmm-yy";  case 18:  	return "h:mm AM/PM";  case 19:  	return "h:mm:ss AM/PM";  case 20:  	return "h:mm";  case 21:  	return "h:mm:ss";  case 22:  	return "m/d/yy h:mm";  case 37:  	return "#'##0 ;(#'##0)";  case 38:  	return "#'##0 ;[Red](#'##0)";  case 39:  	return "#'##0.00;(#'##0.00)";  case 40:  	return "#'##0.00;[Red](#'#)";  case 45:  	return "mm:ss";  case 46:  	return "[h]:mm:ss";  case 47:  	return "mmss.0";  case 48:  	return "##0.0";  case 49:  	return "@";  default:  	return string.Empty;  }  
Magic Number,OfficeOpenXml.Style,ExcelNumberFormat,C:\repos\bambit_EPPlus\EPPlus\Style\ExcelNumberFormat.cs,GetFromBuildInFromID,The following statement contains a magic number: switch (_numFmtId) {  case 0:  	return "General";  case 1:  	return "0";  case 2:  	return "0.00";  case 3:  	return "#'##0";  case 4:  	return "#'##0.00";  case 9:  	return "0%";  case 10:  	return "0.00%";  case 11:  	return "0.00E+00";  case 12:  	return "# ?/?";  case 13:  	return "# ??/??";  case 14:  	return "mm-dd-yy";  case 15:  	return "d-mmm-yy";  case 16:  	return "d-mmm";  case 17:  	return "mmm-yy";  case 18:  	return "h:mm AM/PM";  case 19:  	return "h:mm:ss AM/PM";  case 20:  	return "h:mm";  case 21:  	return "h:mm:ss";  case 22:  	return "m/d/yy h:mm";  case 37:  	return "#'##0 ;(#'##0)";  case 38:  	return "#'##0 ;[Red](#'##0)";  case 39:  	return "#'##0.00;(#'##0.00)";  case 40:  	return "#'##0.00;[Red](#'#)";  case 45:  	return "mm:ss";  case 46:  	return "[h]:mm:ss";  case 47:  	return "mmss.0";  case 48:  	return "##0.0";  case 49:  	return "@";  default:  	return string.Empty;  }  
Magic Number,OfficeOpenXml.Style,ExcelNumberFormat,C:\repos\bambit_EPPlus\EPPlus\Style\ExcelNumberFormat.cs,GetFromBuildInFromID,The following statement contains a magic number: switch (_numFmtId) {  case 0:  	return "General";  case 1:  	return "0";  case 2:  	return "0.00";  case 3:  	return "#'##0";  case 4:  	return "#'##0.00";  case 9:  	return "0%";  case 10:  	return "0.00%";  case 11:  	return "0.00E+00";  case 12:  	return "# ?/?";  case 13:  	return "# ??/??";  case 14:  	return "mm-dd-yy";  case 15:  	return "d-mmm-yy";  case 16:  	return "d-mmm";  case 17:  	return "mmm-yy";  case 18:  	return "h:mm AM/PM";  case 19:  	return "h:mm:ss AM/PM";  case 20:  	return "h:mm";  case 21:  	return "h:mm:ss";  case 22:  	return "m/d/yy h:mm";  case 37:  	return "#'##0 ;(#'##0)";  case 38:  	return "#'##0 ;[Red](#'##0)";  case 39:  	return "#'##0.00;(#'##0.00)";  case 40:  	return "#'##0.00;[Red](#'#)";  case 45:  	return "mm:ss";  case 46:  	return "[h]:mm:ss";  case 47:  	return "mmss.0";  case 48:  	return "##0.0";  case 49:  	return "@";  default:  	return string.Empty;  }  
Magic Number,OfficeOpenXml.Style,ExcelNumberFormat,C:\repos\bambit_EPPlus\EPPlus\Style\ExcelNumberFormat.cs,GetFromBuildInFromID,The following statement contains a magic number: switch (_numFmtId) {  case 0:  	return "General";  case 1:  	return "0";  case 2:  	return "0.00";  case 3:  	return "#'##0";  case 4:  	return "#'##0.00";  case 9:  	return "0%";  case 10:  	return "0.00%";  case 11:  	return "0.00E+00";  case 12:  	return "# ?/?";  case 13:  	return "# ??/??";  case 14:  	return "mm-dd-yy";  case 15:  	return "d-mmm-yy";  case 16:  	return "d-mmm";  case 17:  	return "mmm-yy";  case 18:  	return "h:mm AM/PM";  case 19:  	return "h:mm:ss AM/PM";  case 20:  	return "h:mm";  case 21:  	return "h:mm:ss";  case 22:  	return "m/d/yy h:mm";  case 37:  	return "#'##0 ;(#'##0)";  case 38:  	return "#'##0 ;[Red](#'##0)";  case 39:  	return "#'##0.00;(#'##0.00)";  case 40:  	return "#'##0.00;[Red](#'#)";  case 45:  	return "mm:ss";  case 46:  	return "[h]:mm:ss";  case 47:  	return "mmss.0";  case 48:  	return "##0.0";  case 49:  	return "@";  default:  	return string.Empty;  }  
Magic Number,OfficeOpenXml.Style,ExcelNumberFormat,C:\repos\bambit_EPPlus\EPPlus\Style\ExcelNumberFormat.cs,GetFromBuildInFromID,The following statement contains a magic number: switch (_numFmtId) {  case 0:  	return "General";  case 1:  	return "0";  case 2:  	return "0.00";  case 3:  	return "#'##0";  case 4:  	return "#'##0.00";  case 9:  	return "0%";  case 10:  	return "0.00%";  case 11:  	return "0.00E+00";  case 12:  	return "# ?/?";  case 13:  	return "# ??/??";  case 14:  	return "mm-dd-yy";  case 15:  	return "d-mmm-yy";  case 16:  	return "d-mmm";  case 17:  	return "mmm-yy";  case 18:  	return "h:mm AM/PM";  case 19:  	return "h:mm:ss AM/PM";  case 20:  	return "h:mm";  case 21:  	return "h:mm:ss";  case 22:  	return "m/d/yy h:mm";  case 37:  	return "#'##0 ;(#'##0)";  case 38:  	return "#'##0 ;[Red](#'##0)";  case 39:  	return "#'##0.00;(#'##0.00)";  case 40:  	return "#'##0.00;[Red](#'#)";  case 45:  	return "mm:ss";  case 46:  	return "[h]:mm:ss";  case 47:  	return "mmss.0";  case 48:  	return "##0.0";  case 49:  	return "@";  default:  	return string.Empty;  }  
Magic Number,OfficeOpenXml.Style,ExcelNumberFormat,C:\repos\bambit_EPPlus\EPPlus\Style\ExcelNumberFormat.cs,GetFromBuildInFromID,The following statement contains a magic number: switch (_numFmtId) {  case 0:  	return "General";  case 1:  	return "0";  case 2:  	return "0.00";  case 3:  	return "#'##0";  case 4:  	return "#'##0.00";  case 9:  	return "0%";  case 10:  	return "0.00%";  case 11:  	return "0.00E+00";  case 12:  	return "# ?/?";  case 13:  	return "# ??/??";  case 14:  	return "mm-dd-yy";  case 15:  	return "d-mmm-yy";  case 16:  	return "d-mmm";  case 17:  	return "mmm-yy";  case 18:  	return "h:mm AM/PM";  case 19:  	return "h:mm:ss AM/PM";  case 20:  	return "h:mm";  case 21:  	return "h:mm:ss";  case 22:  	return "m/d/yy h:mm";  case 37:  	return "#'##0 ;(#'##0)";  case 38:  	return "#'##0 ;[Red](#'##0)";  case 39:  	return "#'##0.00;(#'##0.00)";  case 40:  	return "#'##0.00;[Red](#'#)";  case 45:  	return "mm:ss";  case 46:  	return "[h]:mm:ss";  case 47:  	return "mmss.0";  case 48:  	return "##0.0";  case 49:  	return "@";  default:  	return string.Empty;  }  
Magic Number,OfficeOpenXml.Style,ExcelNumberFormat,C:\repos\bambit_EPPlus\EPPlus\Style\ExcelNumberFormat.cs,GetFromBuildInFromID,The following statement contains a magic number: switch (_numFmtId) {  case 0:  	return "General";  case 1:  	return "0";  case 2:  	return "0.00";  case 3:  	return "#'##0";  case 4:  	return "#'##0.00";  case 9:  	return "0%";  case 10:  	return "0.00%";  case 11:  	return "0.00E+00";  case 12:  	return "# ?/?";  case 13:  	return "# ??/??";  case 14:  	return "mm-dd-yy";  case 15:  	return "d-mmm-yy";  case 16:  	return "d-mmm";  case 17:  	return "mmm-yy";  case 18:  	return "h:mm AM/PM";  case 19:  	return "h:mm:ss AM/PM";  case 20:  	return "h:mm";  case 21:  	return "h:mm:ss";  case 22:  	return "m/d/yy h:mm";  case 37:  	return "#'##0 ;(#'##0)";  case 38:  	return "#'##0 ;[Red](#'##0)";  case 39:  	return "#'##0.00;(#'##0.00)";  case 40:  	return "#'##0.00;[Red](#'#)";  case 45:  	return "mm:ss";  case 46:  	return "[h]:mm:ss";  case 47:  	return "mmss.0";  case 48:  	return "##0.0";  case 49:  	return "@";  default:  	return string.Empty;  }  
Magic Number,OfficeOpenXml.Style,ExcelNumberFormat,C:\repos\bambit_EPPlus\EPPlus\Style\ExcelNumberFormat.cs,GetFromBuildInFromID,The following statement contains a magic number: switch (_numFmtId) {  case 0:  	return "General";  case 1:  	return "0";  case 2:  	return "0.00";  case 3:  	return "#'##0";  case 4:  	return "#'##0.00";  case 9:  	return "0%";  case 10:  	return "0.00%";  case 11:  	return "0.00E+00";  case 12:  	return "# ?/?";  case 13:  	return "# ??/??";  case 14:  	return "mm-dd-yy";  case 15:  	return "d-mmm-yy";  case 16:  	return "d-mmm";  case 17:  	return "mmm-yy";  case 18:  	return "h:mm AM/PM";  case 19:  	return "h:mm:ss AM/PM";  case 20:  	return "h:mm";  case 21:  	return "h:mm:ss";  case 22:  	return "m/d/yy h:mm";  case 37:  	return "#'##0 ;(#'##0)";  case 38:  	return "#'##0 ;[Red](#'##0)";  case 39:  	return "#'##0.00;(#'##0.00)";  case 40:  	return "#'##0.00;[Red](#'#)";  case 45:  	return "mm:ss";  case 46:  	return "[h]:mm:ss";  case 47:  	return "mmss.0";  case 48:  	return "##0.0";  case 49:  	return "@";  default:  	return string.Empty;  }  
Magic Number,OfficeOpenXml.Style,ExcelNumberFormat,C:\repos\bambit_EPPlus\EPPlus\Style\ExcelNumberFormat.cs,GetFromBuildInFromID,The following statement contains a magic number: switch (_numFmtId) {  case 0:  	return "General";  case 1:  	return "0";  case 2:  	return "0.00";  case 3:  	return "#'##0";  case 4:  	return "#'##0.00";  case 9:  	return "0%";  case 10:  	return "0.00%";  case 11:  	return "0.00E+00";  case 12:  	return "# ?/?";  case 13:  	return "# ??/??";  case 14:  	return "mm-dd-yy";  case 15:  	return "d-mmm-yy";  case 16:  	return "d-mmm";  case 17:  	return "mmm-yy";  case 18:  	return "h:mm AM/PM";  case 19:  	return "h:mm:ss AM/PM";  case 20:  	return "h:mm";  case 21:  	return "h:mm:ss";  case 22:  	return "m/d/yy h:mm";  case 37:  	return "#'##0 ;(#'##0)";  case 38:  	return "#'##0 ;[Red](#'##0)";  case 39:  	return "#'##0.00;(#'##0.00)";  case 40:  	return "#'##0.00;[Red](#'#)";  case 45:  	return "mm:ss";  case 46:  	return "[h]:mm:ss";  case 47:  	return "mmss.0";  case 48:  	return "##0.0";  case 49:  	return "@";  default:  	return string.Empty;  }  
Magic Number,OfficeOpenXml.Style,ExcelNumberFormat,C:\repos\bambit_EPPlus\EPPlus\Style\ExcelNumberFormat.cs,GetFromBuildInFromID,The following statement contains a magic number: switch (_numFmtId) {  case 0:  	return "General";  case 1:  	return "0";  case 2:  	return "0.00";  case 3:  	return "#'##0";  case 4:  	return "#'##0.00";  case 9:  	return "0%";  case 10:  	return "0.00%";  case 11:  	return "0.00E+00";  case 12:  	return "# ?/?";  case 13:  	return "# ??/??";  case 14:  	return "mm-dd-yy";  case 15:  	return "d-mmm-yy";  case 16:  	return "d-mmm";  case 17:  	return "mmm-yy";  case 18:  	return "h:mm AM/PM";  case 19:  	return "h:mm:ss AM/PM";  case 20:  	return "h:mm";  case 21:  	return "h:mm:ss";  case 22:  	return "m/d/yy h:mm";  case 37:  	return "#'##0 ;(#'##0)";  case 38:  	return "#'##0 ;[Red](#'##0)";  case 39:  	return "#'##0.00;(#'##0.00)";  case 40:  	return "#'##0.00;[Red](#'#)";  case 45:  	return "mm:ss";  case 46:  	return "[h]:mm:ss";  case 47:  	return "mmss.0";  case 48:  	return "##0.0";  case 49:  	return "@";  default:  	return string.Empty;  }  
Magic Number,OfficeOpenXml.Style,ExcelNumberFormat,C:\repos\bambit_EPPlus\EPPlus\Style\ExcelNumberFormat.cs,GetFromBuildInFromID,The following statement contains a magic number: switch (_numFmtId) {  case 0:  	return "General";  case 1:  	return "0";  case 2:  	return "0.00";  case 3:  	return "#'##0";  case 4:  	return "#'##0.00";  case 9:  	return "0%";  case 10:  	return "0.00%";  case 11:  	return "0.00E+00";  case 12:  	return "# ?/?";  case 13:  	return "# ??/??";  case 14:  	return "mm-dd-yy";  case 15:  	return "d-mmm-yy";  case 16:  	return "d-mmm";  case 17:  	return "mmm-yy";  case 18:  	return "h:mm AM/PM";  case 19:  	return "h:mm:ss AM/PM";  case 20:  	return "h:mm";  case 21:  	return "h:mm:ss";  case 22:  	return "m/d/yy h:mm";  case 37:  	return "#'##0 ;(#'##0)";  case 38:  	return "#'##0 ;[Red](#'##0)";  case 39:  	return "#'##0.00;(#'##0.00)";  case 40:  	return "#'##0.00;[Red](#'#)";  case 45:  	return "mm:ss";  case 46:  	return "[h]:mm:ss";  case 47:  	return "mmss.0";  case 48:  	return "##0.0";  case 49:  	return "@";  default:  	return string.Empty;  }  
Magic Number,OfficeOpenXml.Style,ExcelNumberFormat,C:\repos\bambit_EPPlus\EPPlus\Style\ExcelNumberFormat.cs,GetFromBuildInFromID,The following statement contains a magic number: switch (_numFmtId) {  case 0:  	return "General";  case 1:  	return "0";  case 2:  	return "0.00";  case 3:  	return "#'##0";  case 4:  	return "#'##0.00";  case 9:  	return "0%";  case 10:  	return "0.00%";  case 11:  	return "0.00E+00";  case 12:  	return "# ?/?";  case 13:  	return "# ??/??";  case 14:  	return "mm-dd-yy";  case 15:  	return "d-mmm-yy";  case 16:  	return "d-mmm";  case 17:  	return "mmm-yy";  case 18:  	return "h:mm AM/PM";  case 19:  	return "h:mm:ss AM/PM";  case 20:  	return "h:mm";  case 21:  	return "h:mm:ss";  case 22:  	return "m/d/yy h:mm";  case 37:  	return "#'##0 ;(#'##0)";  case 38:  	return "#'##0 ;[Red](#'##0)";  case 39:  	return "#'##0.00;(#'##0.00)";  case 40:  	return "#'##0.00;[Red](#'#)";  case 45:  	return "mm:ss";  case 46:  	return "[h]:mm:ss";  case 47:  	return "mmss.0";  case 48:  	return "##0.0";  case 49:  	return "@";  default:  	return string.Empty;  }  
Magic Number,OfficeOpenXml.Style,ExcelNumberFormat,C:\repos\bambit_EPPlus\EPPlus\Style\ExcelNumberFormat.cs,GetFromBuildInFromID,The following statement contains a magic number: switch (_numFmtId) {  case 0:  	return "General";  case 1:  	return "0";  case 2:  	return "0.00";  case 3:  	return "#'##0";  case 4:  	return "#'##0.00";  case 9:  	return "0%";  case 10:  	return "0.00%";  case 11:  	return "0.00E+00";  case 12:  	return "# ?/?";  case 13:  	return "# ??/??";  case 14:  	return "mm-dd-yy";  case 15:  	return "d-mmm-yy";  case 16:  	return "d-mmm";  case 17:  	return "mmm-yy";  case 18:  	return "h:mm AM/PM";  case 19:  	return "h:mm:ss AM/PM";  case 20:  	return "h:mm";  case 21:  	return "h:mm:ss";  case 22:  	return "m/d/yy h:mm";  case 37:  	return "#'##0 ;(#'##0)";  case 38:  	return "#'##0 ;[Red](#'##0)";  case 39:  	return "#'##0.00;(#'##0.00)";  case 40:  	return "#'##0.00;[Red](#'#)";  case 45:  	return "mm:ss";  case 46:  	return "[h]:mm:ss";  case 47:  	return "mmss.0";  case 48:  	return "##0.0";  case 49:  	return "@";  default:  	return string.Empty;  }  
Magic Number,OfficeOpenXml.Style,ExcelNumberFormat,C:\repos\bambit_EPPlus\EPPlus\Style\ExcelNumberFormat.cs,GetFromBuildInFromID,The following statement contains a magic number: switch (_numFmtId) {  case 0:  	return "General";  case 1:  	return "0";  case 2:  	return "0.00";  case 3:  	return "#'##0";  case 4:  	return "#'##0.00";  case 9:  	return "0%";  case 10:  	return "0.00%";  case 11:  	return "0.00E+00";  case 12:  	return "# ?/?";  case 13:  	return "# ??/??";  case 14:  	return "mm-dd-yy";  case 15:  	return "d-mmm-yy";  case 16:  	return "d-mmm";  case 17:  	return "mmm-yy";  case 18:  	return "h:mm AM/PM";  case 19:  	return "h:mm:ss AM/PM";  case 20:  	return "h:mm";  case 21:  	return "h:mm:ss";  case 22:  	return "m/d/yy h:mm";  case 37:  	return "#'##0 ;(#'##0)";  case 38:  	return "#'##0 ;[Red](#'##0)";  case 39:  	return "#'##0.00;(#'##0.00)";  case 40:  	return "#'##0.00;[Red](#'#)";  case 45:  	return "mm:ss";  case 46:  	return "[h]:mm:ss";  case 47:  	return "mmss.0";  case 48:  	return "##0.0";  case 49:  	return "@";  default:  	return string.Empty;  }  
Magic Number,OfficeOpenXml.Style,ExcelNumberFormat,C:\repos\bambit_EPPlus\EPPlus\Style\ExcelNumberFormat.cs,GetFromBuildInFromID,The following statement contains a magic number: switch (_numFmtId) {  case 0:  	return "General";  case 1:  	return "0";  case 2:  	return "0.00";  case 3:  	return "#'##0";  case 4:  	return "#'##0.00";  case 9:  	return "0%";  case 10:  	return "0.00%";  case 11:  	return "0.00E+00";  case 12:  	return "# ?/?";  case 13:  	return "# ??/??";  case 14:  	return "mm-dd-yy";  case 15:  	return "d-mmm-yy";  case 16:  	return "d-mmm";  case 17:  	return "mmm-yy";  case 18:  	return "h:mm AM/PM";  case 19:  	return "h:mm:ss AM/PM";  case 20:  	return "h:mm";  case 21:  	return "h:mm:ss";  case 22:  	return "m/d/yy h:mm";  case 37:  	return "#'##0 ;(#'##0)";  case 38:  	return "#'##0 ;[Red](#'##0)";  case 39:  	return "#'##0.00;(#'##0.00)";  case 40:  	return "#'##0.00;[Red](#'#)";  case 45:  	return "mm:ss";  case 46:  	return "[h]:mm:ss";  case 47:  	return "mmss.0";  case 48:  	return "##0.0";  case 49:  	return "@";  default:  	return string.Empty;  }  
Magic Number,OfficeOpenXml.Style,ExcelNumberFormat,C:\repos\bambit_EPPlus\EPPlus\Style\ExcelNumberFormat.cs,GetFromBuildInFromID,The following statement contains a magic number: switch (_numFmtId) {  case 0:  	return "General";  case 1:  	return "0";  case 2:  	return "0.00";  case 3:  	return "#'##0";  case 4:  	return "#'##0.00";  case 9:  	return "0%";  case 10:  	return "0.00%";  case 11:  	return "0.00E+00";  case 12:  	return "# ?/?";  case 13:  	return "# ??/??";  case 14:  	return "mm-dd-yy";  case 15:  	return "d-mmm-yy";  case 16:  	return "d-mmm";  case 17:  	return "mmm-yy";  case 18:  	return "h:mm AM/PM";  case 19:  	return "h:mm:ss AM/PM";  case 20:  	return "h:mm";  case 21:  	return "h:mm:ss";  case 22:  	return "m/d/yy h:mm";  case 37:  	return "#'##0 ;(#'##0)";  case 38:  	return "#'##0 ;[Red](#'##0)";  case 39:  	return "#'##0.00;(#'##0.00)";  case 40:  	return "#'##0.00;[Red](#'#)";  case 45:  	return "mm:ss";  case 46:  	return "[h]:mm:ss";  case 47:  	return "mmss.0";  case 48:  	return "##0.0";  case 49:  	return "@";  default:  	return string.Empty;  }  
Magic Number,OfficeOpenXml.Style,ExcelNumberFormat,C:\repos\bambit_EPPlus\EPPlus\Style\ExcelNumberFormat.cs,GetFromBuildInFromID,The following statement contains a magic number: switch (_numFmtId) {  case 0:  	return "General";  case 1:  	return "0";  case 2:  	return "0.00";  case 3:  	return "#'##0";  case 4:  	return "#'##0.00";  case 9:  	return "0%";  case 10:  	return "0.00%";  case 11:  	return "0.00E+00";  case 12:  	return "# ?/?";  case 13:  	return "# ??/??";  case 14:  	return "mm-dd-yy";  case 15:  	return "d-mmm-yy";  case 16:  	return "d-mmm";  case 17:  	return "mmm-yy";  case 18:  	return "h:mm AM/PM";  case 19:  	return "h:mm:ss AM/PM";  case 20:  	return "h:mm";  case 21:  	return "h:mm:ss";  case 22:  	return "m/d/yy h:mm";  case 37:  	return "#'##0 ;(#'##0)";  case 38:  	return "#'##0 ;[Red](#'##0)";  case 39:  	return "#'##0.00;(#'##0.00)";  case 40:  	return "#'##0.00;[Red](#'#)";  case 45:  	return "mm:ss";  case 46:  	return "[h]:mm:ss";  case 47:  	return "mmss.0";  case 48:  	return "##0.0";  case 49:  	return "@";  default:  	return string.Empty;  }  
Magic Number,OfficeOpenXml.Style,ExcelNumberFormat,C:\repos\bambit_EPPlus\EPPlus\Style\ExcelNumberFormat.cs,GetFromBuildInFromID,The following statement contains a magic number: switch (_numFmtId) {  case 0:  	return "General";  case 1:  	return "0";  case 2:  	return "0.00";  case 3:  	return "#'##0";  case 4:  	return "#'##0.00";  case 9:  	return "0%";  case 10:  	return "0.00%";  case 11:  	return "0.00E+00";  case 12:  	return "# ?/?";  case 13:  	return "# ??/??";  case 14:  	return "mm-dd-yy";  case 15:  	return "d-mmm-yy";  case 16:  	return "d-mmm";  case 17:  	return "mmm-yy";  case 18:  	return "h:mm AM/PM";  case 19:  	return "h:mm:ss AM/PM";  case 20:  	return "h:mm";  case 21:  	return "h:mm:ss";  case 22:  	return "m/d/yy h:mm";  case 37:  	return "#'##0 ;(#'##0)";  case 38:  	return "#'##0 ;[Red](#'##0)";  case 39:  	return "#'##0.00;(#'##0.00)";  case 40:  	return "#'##0.00;[Red](#'#)";  case 45:  	return "mm:ss";  case 46:  	return "[h]:mm:ss";  case 47:  	return "mmss.0";  case 48:  	return "##0.0";  case 49:  	return "@";  default:  	return string.Empty;  }  
Magic Number,OfficeOpenXml.Style,ExcelNumberFormat,C:\repos\bambit_EPPlus\EPPlus\Style\ExcelNumberFormat.cs,GetFromBuildInFromID,The following statement contains a magic number: switch (_numFmtId) {  case 0:  	return "General";  case 1:  	return "0";  case 2:  	return "0.00";  case 3:  	return "#'##0";  case 4:  	return "#'##0.00";  case 9:  	return "0%";  case 10:  	return "0.00%";  case 11:  	return "0.00E+00";  case 12:  	return "# ?/?";  case 13:  	return "# ??/??";  case 14:  	return "mm-dd-yy";  case 15:  	return "d-mmm-yy";  case 16:  	return "d-mmm";  case 17:  	return "mmm-yy";  case 18:  	return "h:mm AM/PM";  case 19:  	return "h:mm:ss AM/PM";  case 20:  	return "h:mm";  case 21:  	return "h:mm:ss";  case 22:  	return "m/d/yy h:mm";  case 37:  	return "#'##0 ;(#'##0)";  case 38:  	return "#'##0 ;[Red](#'##0)";  case 39:  	return "#'##0.00;(#'##0.00)";  case 40:  	return "#'##0.00;[Red](#'#)";  case 45:  	return "mm:ss";  case 46:  	return "[h]:mm:ss";  case 47:  	return "mmss.0";  case 48:  	return "##0.0";  case 49:  	return "@";  default:  	return string.Empty;  }  
Magic Number,OfficeOpenXml.Style,ExcelNumberFormat,C:\repos\bambit_EPPlus\EPPlus\Style\ExcelNumberFormat.cs,GetFromBuildInFromID,The following statement contains a magic number: switch (_numFmtId) {  case 0:  	return "General";  case 1:  	return "0";  case 2:  	return "0.00";  case 3:  	return "#'##0";  case 4:  	return "#'##0.00";  case 9:  	return "0%";  case 10:  	return "0.00%";  case 11:  	return "0.00E+00";  case 12:  	return "# ?/?";  case 13:  	return "# ??/??";  case 14:  	return "mm-dd-yy";  case 15:  	return "d-mmm-yy";  case 16:  	return "d-mmm";  case 17:  	return "mmm-yy";  case 18:  	return "h:mm AM/PM";  case 19:  	return "h:mm:ss AM/PM";  case 20:  	return "h:mm";  case 21:  	return "h:mm:ss";  case 22:  	return "m/d/yy h:mm";  case 37:  	return "#'##0 ;(#'##0)";  case 38:  	return "#'##0 ;[Red](#'##0)";  case 39:  	return "#'##0.00;(#'##0.00)";  case 40:  	return "#'##0.00;[Red](#'#)";  case 45:  	return "mm:ss";  case 46:  	return "[h]:mm:ss";  case 47:  	return "mmss.0";  case 48:  	return "##0.0";  case 49:  	return "@";  default:  	return string.Empty;  }  
Magic Number,OfficeOpenXml.Style,ExcelNumberFormat,C:\repos\bambit_EPPlus\EPPlus\Style\ExcelNumberFormat.cs,GetFromBuildInFromID,The following statement contains a magic number: switch (_numFmtId) {  case 0:  	return "General";  case 1:  	return "0";  case 2:  	return "0.00";  case 3:  	return "#'##0";  case 4:  	return "#'##0.00";  case 9:  	return "0%";  case 10:  	return "0.00%";  case 11:  	return "0.00E+00";  case 12:  	return "# ?/?";  case 13:  	return "# ??/??";  case 14:  	return "mm-dd-yy";  case 15:  	return "d-mmm-yy";  case 16:  	return "d-mmm";  case 17:  	return "mmm-yy";  case 18:  	return "h:mm AM/PM";  case 19:  	return "h:mm:ss AM/PM";  case 20:  	return "h:mm";  case 21:  	return "h:mm:ss";  case 22:  	return "m/d/yy h:mm";  case 37:  	return "#'##0 ;(#'##0)";  case 38:  	return "#'##0 ;[Red](#'##0)";  case 39:  	return "#'##0.00;(#'##0.00)";  case 40:  	return "#'##0.00;[Red](#'#)";  case 45:  	return "mm:ss";  case 46:  	return "[h]:mm:ss";  case 47:  	return "mmss.0";  case 48:  	return "##0.0";  case 49:  	return "@";  default:  	return string.Empty;  }  
Magic Number,OfficeOpenXml.Style,ExcelNumberFormat,C:\repos\bambit_EPPlus\EPPlus\Style\ExcelNumberFormat.cs,GetFromBuildInFromID,The following statement contains a magic number: switch (_numFmtId) {  case 0:  	return "General";  case 1:  	return "0";  case 2:  	return "0.00";  case 3:  	return "#'##0";  case 4:  	return "#'##0.00";  case 9:  	return "0%";  case 10:  	return "0.00%";  case 11:  	return "0.00E+00";  case 12:  	return "# ?/?";  case 13:  	return "# ??/??";  case 14:  	return "mm-dd-yy";  case 15:  	return "d-mmm-yy";  case 16:  	return "d-mmm";  case 17:  	return "mmm-yy";  case 18:  	return "h:mm AM/PM";  case 19:  	return "h:mm:ss AM/PM";  case 20:  	return "h:mm";  case 21:  	return "h:mm:ss";  case 22:  	return "m/d/yy h:mm";  case 37:  	return "#'##0 ;(#'##0)";  case 38:  	return "#'##0 ;[Red](#'##0)";  case 39:  	return "#'##0.00;(#'##0.00)";  case 40:  	return "#'##0.00;[Red](#'#)";  case 45:  	return "mm:ss";  case 46:  	return "[h]:mm:ss";  case 47:  	return "mmss.0";  case 48:  	return "##0.0";  case 49:  	return "@";  default:  	return string.Empty;  }  
Magic Number,OfficeOpenXml.Style,ExcelNumberFormat,C:\repos\bambit_EPPlus\EPPlus\Style\ExcelNumberFormat.cs,GetFromBuildInFromID,The following statement contains a magic number: switch (_numFmtId) {  case 0:  	return "General";  case 1:  	return "0";  case 2:  	return "0.00";  case 3:  	return "#'##0";  case 4:  	return "#'##0.00";  case 9:  	return "0%";  case 10:  	return "0.00%";  case 11:  	return "0.00E+00";  case 12:  	return "# ?/?";  case 13:  	return "# ??/??";  case 14:  	return "mm-dd-yy";  case 15:  	return "d-mmm-yy";  case 16:  	return "d-mmm";  case 17:  	return "mmm-yy";  case 18:  	return "h:mm AM/PM";  case 19:  	return "h:mm:ss AM/PM";  case 20:  	return "h:mm";  case 21:  	return "h:mm:ss";  case 22:  	return "m/d/yy h:mm";  case 37:  	return "#'##0 ;(#'##0)";  case 38:  	return "#'##0 ;[Red](#'##0)";  case 39:  	return "#'##0.00;(#'##0.00)";  case 40:  	return "#'##0.00;[Red](#'#)";  case 45:  	return "mm:ss";  case 46:  	return "[h]:mm:ss";  case 47:  	return "mmss.0";  case 48:  	return "##0.0";  case 49:  	return "@";  default:  	return string.Empty;  }  
Magic Number,OfficeOpenXml.Style,ExcelNumberFormat,C:\repos\bambit_EPPlus\EPPlus\Style\ExcelNumberFormat.cs,GetFromBuildInFromID,The following statement contains a magic number: switch (_numFmtId) {  case 0:  	return "General";  case 1:  	return "0";  case 2:  	return "0.00";  case 3:  	return "#'##0";  case 4:  	return "#'##0.00";  case 9:  	return "0%";  case 10:  	return "0.00%";  case 11:  	return "0.00E+00";  case 12:  	return "# ?/?";  case 13:  	return "# ??/??";  case 14:  	return "mm-dd-yy";  case 15:  	return "d-mmm-yy";  case 16:  	return "d-mmm";  case 17:  	return "mmm-yy";  case 18:  	return "h:mm AM/PM";  case 19:  	return "h:mm:ss AM/PM";  case 20:  	return "h:mm";  case 21:  	return "h:mm:ss";  case 22:  	return "m/d/yy h:mm";  case 37:  	return "#'##0 ;(#'##0)";  case 38:  	return "#'##0 ;[Red](#'##0)";  case 39:  	return "#'##0.00;(#'##0.00)";  case 40:  	return "#'##0.00;[Red](#'#)";  case 45:  	return "mm:ss";  case 46:  	return "[h]:mm:ss";  case 47:  	return "mmss.0";  case 48:  	return "##0.0";  case 49:  	return "@";  default:  	return string.Empty;  }  
Magic Number,OfficeOpenXml.Style,ExcelNumberFormat,C:\repos\bambit_EPPlus\EPPlus\Style\ExcelNumberFormat.cs,GetFromBuildInFromID,The following statement contains a magic number: switch (_numFmtId) {  case 0:  	return "General";  case 1:  	return "0";  case 2:  	return "0.00";  case 3:  	return "#'##0";  case 4:  	return "#'##0.00";  case 9:  	return "0%";  case 10:  	return "0.00%";  case 11:  	return "0.00E+00";  case 12:  	return "# ?/?";  case 13:  	return "# ??/??";  case 14:  	return "mm-dd-yy";  case 15:  	return "d-mmm-yy";  case 16:  	return "d-mmm";  case 17:  	return "mmm-yy";  case 18:  	return "h:mm AM/PM";  case 19:  	return "h:mm:ss AM/PM";  case 20:  	return "h:mm";  case 21:  	return "h:mm:ss";  case 22:  	return "m/d/yy h:mm";  case 37:  	return "#'##0 ;(#'##0)";  case 38:  	return "#'##0 ;[Red](#'##0)";  case 39:  	return "#'##0.00;(#'##0.00)";  case 40:  	return "#'##0.00;[Red](#'#)";  case 45:  	return "mm:ss";  case 46:  	return "[h]:mm:ss";  case 47:  	return "mmss.0";  case 48:  	return "##0.0";  case 49:  	return "@";  default:  	return string.Empty;  }  
Magic Number,OfficeOpenXml.Style,ExcelNumberFormat,C:\repos\bambit_EPPlus\EPPlus\Style\ExcelNumberFormat.cs,GetFromBuildIdFromFormat,The following statement contains a magic number: switch (format) {  case "General":  	return 0;  case "0":  	return 1;  case "0.00":  	return 2;  case "#'##0":  	return 3;  case "#'##0.00":  	return 4;  case "0%":  	return 9;  case "0.00%":  	return 10;  case "0.00E+00":  	return 11;  case "# ?/?":  	return 12;  case "# ??/??":  	return 13;  case "mm-dd-yy":  	return 14;  case "d-mmm-yy":  	return 15;  case "d-mmm":  	return 16;  case "mmm-yy":  	return 17;  case "h:mm AM/PM":  	return 18;  case "h:mm:ss AM/PM":  	return 19;  case "h:mm":  	return 20;  case "h:mm:ss":  	return 21;  case "m/d/yy h:mm":  	return 22;  case "#'##0 ;(#'##0)":  	return 37;  case "#'##0 ;[Red](#'##0)":  	return 38;  case "#'##0.00;(#'##0.00)":  	return 39;  case "#'##0.00;[Red](#'#)":  	return 40;  case "mm:ss":  	return 45;  case "[h]:mm:ss":  	return 46;  case "mmss.0":  	return 47;  case "##0.0":  	return 48;  case "@":  	return 49;  default:  	return int.MinValue;  }  
Magic Number,OfficeOpenXml.Style,ExcelNumberFormat,C:\repos\bambit_EPPlus\EPPlus\Style\ExcelNumberFormat.cs,GetFromBuildIdFromFormat,The following statement contains a magic number: switch (format) {  case "General":  	return 0;  case "0":  	return 1;  case "0.00":  	return 2;  case "#'##0":  	return 3;  case "#'##0.00":  	return 4;  case "0%":  	return 9;  case "0.00%":  	return 10;  case "0.00E+00":  	return 11;  case "# ?/?":  	return 12;  case "# ??/??":  	return 13;  case "mm-dd-yy":  	return 14;  case "d-mmm-yy":  	return 15;  case "d-mmm":  	return 16;  case "mmm-yy":  	return 17;  case "h:mm AM/PM":  	return 18;  case "h:mm:ss AM/PM":  	return 19;  case "h:mm":  	return 20;  case "h:mm:ss":  	return 21;  case "m/d/yy h:mm":  	return 22;  case "#'##0 ;(#'##0)":  	return 37;  case "#'##0 ;[Red](#'##0)":  	return 38;  case "#'##0.00;(#'##0.00)":  	return 39;  case "#'##0.00;[Red](#'#)":  	return 40;  case "mm:ss":  	return 45;  case "[h]:mm:ss":  	return 46;  case "mmss.0":  	return 47;  case "##0.0":  	return 48;  case "@":  	return 49;  default:  	return int.MinValue;  }  
Magic Number,OfficeOpenXml.Style,ExcelNumberFormat,C:\repos\bambit_EPPlus\EPPlus\Style\ExcelNumberFormat.cs,GetFromBuildIdFromFormat,The following statement contains a magic number: switch (format) {  case "General":  	return 0;  case "0":  	return 1;  case "0.00":  	return 2;  case "#'##0":  	return 3;  case "#'##0.00":  	return 4;  case "0%":  	return 9;  case "0.00%":  	return 10;  case "0.00E+00":  	return 11;  case "# ?/?":  	return 12;  case "# ??/??":  	return 13;  case "mm-dd-yy":  	return 14;  case "d-mmm-yy":  	return 15;  case "d-mmm":  	return 16;  case "mmm-yy":  	return 17;  case "h:mm AM/PM":  	return 18;  case "h:mm:ss AM/PM":  	return 19;  case "h:mm":  	return 20;  case "h:mm:ss":  	return 21;  case "m/d/yy h:mm":  	return 22;  case "#'##0 ;(#'##0)":  	return 37;  case "#'##0 ;[Red](#'##0)":  	return 38;  case "#'##0.00;(#'##0.00)":  	return 39;  case "#'##0.00;[Red](#'#)":  	return 40;  case "mm:ss":  	return 45;  case "[h]:mm:ss":  	return 46;  case "mmss.0":  	return 47;  case "##0.0":  	return 48;  case "@":  	return 49;  default:  	return int.MinValue;  }  
Magic Number,OfficeOpenXml.Style,ExcelNumberFormat,C:\repos\bambit_EPPlus\EPPlus\Style\ExcelNumberFormat.cs,GetFromBuildIdFromFormat,The following statement contains a magic number: switch (format) {  case "General":  	return 0;  case "0":  	return 1;  case "0.00":  	return 2;  case "#'##0":  	return 3;  case "#'##0.00":  	return 4;  case "0%":  	return 9;  case "0.00%":  	return 10;  case "0.00E+00":  	return 11;  case "# ?/?":  	return 12;  case "# ??/??":  	return 13;  case "mm-dd-yy":  	return 14;  case "d-mmm-yy":  	return 15;  case "d-mmm":  	return 16;  case "mmm-yy":  	return 17;  case "h:mm AM/PM":  	return 18;  case "h:mm:ss AM/PM":  	return 19;  case "h:mm":  	return 20;  case "h:mm:ss":  	return 21;  case "m/d/yy h:mm":  	return 22;  case "#'##0 ;(#'##0)":  	return 37;  case "#'##0 ;[Red](#'##0)":  	return 38;  case "#'##0.00;(#'##0.00)":  	return 39;  case "#'##0.00;[Red](#'#)":  	return 40;  case "mm:ss":  	return 45;  case "[h]:mm:ss":  	return 46;  case "mmss.0":  	return 47;  case "##0.0":  	return 48;  case "@":  	return 49;  default:  	return int.MinValue;  }  
Magic Number,OfficeOpenXml.Style,ExcelNumberFormat,C:\repos\bambit_EPPlus\EPPlus\Style\ExcelNumberFormat.cs,GetFromBuildIdFromFormat,The following statement contains a magic number: switch (format) {  case "General":  	return 0;  case "0":  	return 1;  case "0.00":  	return 2;  case "#'##0":  	return 3;  case "#'##0.00":  	return 4;  case "0%":  	return 9;  case "0.00%":  	return 10;  case "0.00E+00":  	return 11;  case "# ?/?":  	return 12;  case "# ??/??":  	return 13;  case "mm-dd-yy":  	return 14;  case "d-mmm-yy":  	return 15;  case "d-mmm":  	return 16;  case "mmm-yy":  	return 17;  case "h:mm AM/PM":  	return 18;  case "h:mm:ss AM/PM":  	return 19;  case "h:mm":  	return 20;  case "h:mm:ss":  	return 21;  case "m/d/yy h:mm":  	return 22;  case "#'##0 ;(#'##0)":  	return 37;  case "#'##0 ;[Red](#'##0)":  	return 38;  case "#'##0.00;(#'##0.00)":  	return 39;  case "#'##0.00;[Red](#'#)":  	return 40;  case "mm:ss":  	return 45;  case "[h]:mm:ss":  	return 46;  case "mmss.0":  	return 47;  case "##0.0":  	return 48;  case "@":  	return 49;  default:  	return int.MinValue;  }  
Magic Number,OfficeOpenXml.Style,ExcelNumberFormat,C:\repos\bambit_EPPlus\EPPlus\Style\ExcelNumberFormat.cs,GetFromBuildIdFromFormat,The following statement contains a magic number: switch (format) {  case "General":  	return 0;  case "0":  	return 1;  case "0.00":  	return 2;  case "#'##0":  	return 3;  case "#'##0.00":  	return 4;  case "0%":  	return 9;  case "0.00%":  	return 10;  case "0.00E+00":  	return 11;  case "# ?/?":  	return 12;  case "# ??/??":  	return 13;  case "mm-dd-yy":  	return 14;  case "d-mmm-yy":  	return 15;  case "d-mmm":  	return 16;  case "mmm-yy":  	return 17;  case "h:mm AM/PM":  	return 18;  case "h:mm:ss AM/PM":  	return 19;  case "h:mm":  	return 20;  case "h:mm:ss":  	return 21;  case "m/d/yy h:mm":  	return 22;  case "#'##0 ;(#'##0)":  	return 37;  case "#'##0 ;[Red](#'##0)":  	return 38;  case "#'##0.00;(#'##0.00)":  	return 39;  case "#'##0.00;[Red](#'#)":  	return 40;  case "mm:ss":  	return 45;  case "[h]:mm:ss":  	return 46;  case "mmss.0":  	return 47;  case "##0.0":  	return 48;  case "@":  	return 49;  default:  	return int.MinValue;  }  
Magic Number,OfficeOpenXml.Style,ExcelNumberFormat,C:\repos\bambit_EPPlus\EPPlus\Style\ExcelNumberFormat.cs,GetFromBuildIdFromFormat,The following statement contains a magic number: switch (format) {  case "General":  	return 0;  case "0":  	return 1;  case "0.00":  	return 2;  case "#'##0":  	return 3;  case "#'##0.00":  	return 4;  case "0%":  	return 9;  case "0.00%":  	return 10;  case "0.00E+00":  	return 11;  case "# ?/?":  	return 12;  case "# ??/??":  	return 13;  case "mm-dd-yy":  	return 14;  case "d-mmm-yy":  	return 15;  case "d-mmm":  	return 16;  case "mmm-yy":  	return 17;  case "h:mm AM/PM":  	return 18;  case "h:mm:ss AM/PM":  	return 19;  case "h:mm":  	return 20;  case "h:mm:ss":  	return 21;  case "m/d/yy h:mm":  	return 22;  case "#'##0 ;(#'##0)":  	return 37;  case "#'##0 ;[Red](#'##0)":  	return 38;  case "#'##0.00;(#'##0.00)":  	return 39;  case "#'##0.00;[Red](#'#)":  	return 40;  case "mm:ss":  	return 45;  case "[h]:mm:ss":  	return 46;  case "mmss.0":  	return 47;  case "##0.0":  	return 48;  case "@":  	return 49;  default:  	return int.MinValue;  }  
Magic Number,OfficeOpenXml.Style,ExcelNumberFormat,C:\repos\bambit_EPPlus\EPPlus\Style\ExcelNumberFormat.cs,GetFromBuildIdFromFormat,The following statement contains a magic number: switch (format) {  case "General":  	return 0;  case "0":  	return 1;  case "0.00":  	return 2;  case "#'##0":  	return 3;  case "#'##0.00":  	return 4;  case "0%":  	return 9;  case "0.00%":  	return 10;  case "0.00E+00":  	return 11;  case "# ?/?":  	return 12;  case "# ??/??":  	return 13;  case "mm-dd-yy":  	return 14;  case "d-mmm-yy":  	return 15;  case "d-mmm":  	return 16;  case "mmm-yy":  	return 17;  case "h:mm AM/PM":  	return 18;  case "h:mm:ss AM/PM":  	return 19;  case "h:mm":  	return 20;  case "h:mm:ss":  	return 21;  case "m/d/yy h:mm":  	return 22;  case "#'##0 ;(#'##0)":  	return 37;  case "#'##0 ;[Red](#'##0)":  	return 38;  case "#'##0.00;(#'##0.00)":  	return 39;  case "#'##0.00;[Red](#'#)":  	return 40;  case "mm:ss":  	return 45;  case "[h]:mm:ss":  	return 46;  case "mmss.0":  	return 47;  case "##0.0":  	return 48;  case "@":  	return 49;  default:  	return int.MinValue;  }  
Magic Number,OfficeOpenXml.Style,ExcelNumberFormat,C:\repos\bambit_EPPlus\EPPlus\Style\ExcelNumberFormat.cs,GetFromBuildIdFromFormat,The following statement contains a magic number: switch (format) {  case "General":  	return 0;  case "0":  	return 1;  case "0.00":  	return 2;  case "#'##0":  	return 3;  case "#'##0.00":  	return 4;  case "0%":  	return 9;  case "0.00%":  	return 10;  case "0.00E+00":  	return 11;  case "# ?/?":  	return 12;  case "# ??/??":  	return 13;  case "mm-dd-yy":  	return 14;  case "d-mmm-yy":  	return 15;  case "d-mmm":  	return 16;  case "mmm-yy":  	return 17;  case "h:mm AM/PM":  	return 18;  case "h:mm:ss AM/PM":  	return 19;  case "h:mm":  	return 20;  case "h:mm:ss":  	return 21;  case "m/d/yy h:mm":  	return 22;  case "#'##0 ;(#'##0)":  	return 37;  case "#'##0 ;[Red](#'##0)":  	return 38;  case "#'##0.00;(#'##0.00)":  	return 39;  case "#'##0.00;[Red](#'#)":  	return 40;  case "mm:ss":  	return 45;  case "[h]:mm:ss":  	return 46;  case "mmss.0":  	return 47;  case "##0.0":  	return 48;  case "@":  	return 49;  default:  	return int.MinValue;  }  
Magic Number,OfficeOpenXml.Style,ExcelNumberFormat,C:\repos\bambit_EPPlus\EPPlus\Style\ExcelNumberFormat.cs,GetFromBuildIdFromFormat,The following statement contains a magic number: switch (format) {  case "General":  	return 0;  case "0":  	return 1;  case "0.00":  	return 2;  case "#'##0":  	return 3;  case "#'##0.00":  	return 4;  case "0%":  	return 9;  case "0.00%":  	return 10;  case "0.00E+00":  	return 11;  case "# ?/?":  	return 12;  case "# ??/??":  	return 13;  case "mm-dd-yy":  	return 14;  case "d-mmm-yy":  	return 15;  case "d-mmm":  	return 16;  case "mmm-yy":  	return 17;  case "h:mm AM/PM":  	return 18;  case "h:mm:ss AM/PM":  	return 19;  case "h:mm":  	return 20;  case "h:mm:ss":  	return 21;  case "m/d/yy h:mm":  	return 22;  case "#'##0 ;(#'##0)":  	return 37;  case "#'##0 ;[Red](#'##0)":  	return 38;  case "#'##0.00;(#'##0.00)":  	return 39;  case "#'##0.00;[Red](#'#)":  	return 40;  case "mm:ss":  	return 45;  case "[h]:mm:ss":  	return 46;  case "mmss.0":  	return 47;  case "##0.0":  	return 48;  case "@":  	return 49;  default:  	return int.MinValue;  }  
Magic Number,OfficeOpenXml.Style,ExcelNumberFormat,C:\repos\bambit_EPPlus\EPPlus\Style\ExcelNumberFormat.cs,GetFromBuildIdFromFormat,The following statement contains a magic number: switch (format) {  case "General":  	return 0;  case "0":  	return 1;  case "0.00":  	return 2;  case "#'##0":  	return 3;  case "#'##0.00":  	return 4;  case "0%":  	return 9;  case "0.00%":  	return 10;  case "0.00E+00":  	return 11;  case "# ?/?":  	return 12;  case "# ??/??":  	return 13;  case "mm-dd-yy":  	return 14;  case "d-mmm-yy":  	return 15;  case "d-mmm":  	return 16;  case "mmm-yy":  	return 17;  case "h:mm AM/PM":  	return 18;  case "h:mm:ss AM/PM":  	return 19;  case "h:mm":  	return 20;  case "h:mm:ss":  	return 21;  case "m/d/yy h:mm":  	return 22;  case "#'##0 ;(#'##0)":  	return 37;  case "#'##0 ;[Red](#'##0)":  	return 38;  case "#'##0.00;(#'##0.00)":  	return 39;  case "#'##0.00;[Red](#'#)":  	return 40;  case "mm:ss":  	return 45;  case "[h]:mm:ss":  	return 46;  case "mmss.0":  	return 47;  case "##0.0":  	return 48;  case "@":  	return 49;  default:  	return int.MinValue;  }  
Magic Number,OfficeOpenXml.Style,ExcelNumberFormat,C:\repos\bambit_EPPlus\EPPlus\Style\ExcelNumberFormat.cs,GetFromBuildIdFromFormat,The following statement contains a magic number: switch (format) {  case "General":  	return 0;  case "0":  	return 1;  case "0.00":  	return 2;  case "#'##0":  	return 3;  case "#'##0.00":  	return 4;  case "0%":  	return 9;  case "0.00%":  	return 10;  case "0.00E+00":  	return 11;  case "# ?/?":  	return 12;  case "# ??/??":  	return 13;  case "mm-dd-yy":  	return 14;  case "d-mmm-yy":  	return 15;  case "d-mmm":  	return 16;  case "mmm-yy":  	return 17;  case "h:mm AM/PM":  	return 18;  case "h:mm:ss AM/PM":  	return 19;  case "h:mm":  	return 20;  case "h:mm:ss":  	return 21;  case "m/d/yy h:mm":  	return 22;  case "#'##0 ;(#'##0)":  	return 37;  case "#'##0 ;[Red](#'##0)":  	return 38;  case "#'##0.00;(#'##0.00)":  	return 39;  case "#'##0.00;[Red](#'#)":  	return 40;  case "mm:ss":  	return 45;  case "[h]:mm:ss":  	return 46;  case "mmss.0":  	return 47;  case "##0.0":  	return 48;  case "@":  	return 49;  default:  	return int.MinValue;  }  
Magic Number,OfficeOpenXml.Style,ExcelNumberFormat,C:\repos\bambit_EPPlus\EPPlus\Style\ExcelNumberFormat.cs,GetFromBuildIdFromFormat,The following statement contains a magic number: switch (format) {  case "General":  	return 0;  case "0":  	return 1;  case "0.00":  	return 2;  case "#'##0":  	return 3;  case "#'##0.00":  	return 4;  case "0%":  	return 9;  case "0.00%":  	return 10;  case "0.00E+00":  	return 11;  case "# ?/?":  	return 12;  case "# ??/??":  	return 13;  case "mm-dd-yy":  	return 14;  case "d-mmm-yy":  	return 15;  case "d-mmm":  	return 16;  case "mmm-yy":  	return 17;  case "h:mm AM/PM":  	return 18;  case "h:mm:ss AM/PM":  	return 19;  case "h:mm":  	return 20;  case "h:mm:ss":  	return 21;  case "m/d/yy h:mm":  	return 22;  case "#'##0 ;(#'##0)":  	return 37;  case "#'##0 ;[Red](#'##0)":  	return 38;  case "#'##0.00;(#'##0.00)":  	return 39;  case "#'##0.00;[Red](#'#)":  	return 40;  case "mm:ss":  	return 45;  case "[h]:mm:ss":  	return 46;  case "mmss.0":  	return 47;  case "##0.0":  	return 48;  case "@":  	return 49;  default:  	return int.MinValue;  }  
Magic Number,OfficeOpenXml.Style,ExcelNumberFormat,C:\repos\bambit_EPPlus\EPPlus\Style\ExcelNumberFormat.cs,GetFromBuildIdFromFormat,The following statement contains a magic number: switch (format) {  case "General":  	return 0;  case "0":  	return 1;  case "0.00":  	return 2;  case "#'##0":  	return 3;  case "#'##0.00":  	return 4;  case "0%":  	return 9;  case "0.00%":  	return 10;  case "0.00E+00":  	return 11;  case "# ?/?":  	return 12;  case "# ??/??":  	return 13;  case "mm-dd-yy":  	return 14;  case "d-mmm-yy":  	return 15;  case "d-mmm":  	return 16;  case "mmm-yy":  	return 17;  case "h:mm AM/PM":  	return 18;  case "h:mm:ss AM/PM":  	return 19;  case "h:mm":  	return 20;  case "h:mm:ss":  	return 21;  case "m/d/yy h:mm":  	return 22;  case "#'##0 ;(#'##0)":  	return 37;  case "#'##0 ;[Red](#'##0)":  	return 38;  case "#'##0.00;(#'##0.00)":  	return 39;  case "#'##0.00;[Red](#'#)":  	return 40;  case "mm:ss":  	return 45;  case "[h]:mm:ss":  	return 46;  case "mmss.0":  	return 47;  case "##0.0":  	return 48;  case "@":  	return 49;  default:  	return int.MinValue;  }  
Magic Number,OfficeOpenXml.Style,ExcelNumberFormat,C:\repos\bambit_EPPlus\EPPlus\Style\ExcelNumberFormat.cs,GetFromBuildIdFromFormat,The following statement contains a magic number: switch (format) {  case "General":  	return 0;  case "0":  	return 1;  case "0.00":  	return 2;  case "#'##0":  	return 3;  case "#'##0.00":  	return 4;  case "0%":  	return 9;  case "0.00%":  	return 10;  case "0.00E+00":  	return 11;  case "# ?/?":  	return 12;  case "# ??/??":  	return 13;  case "mm-dd-yy":  	return 14;  case "d-mmm-yy":  	return 15;  case "d-mmm":  	return 16;  case "mmm-yy":  	return 17;  case "h:mm AM/PM":  	return 18;  case "h:mm:ss AM/PM":  	return 19;  case "h:mm":  	return 20;  case "h:mm:ss":  	return 21;  case "m/d/yy h:mm":  	return 22;  case "#'##0 ;(#'##0)":  	return 37;  case "#'##0 ;[Red](#'##0)":  	return 38;  case "#'##0.00;(#'##0.00)":  	return 39;  case "#'##0.00;[Red](#'#)":  	return 40;  case "mm:ss":  	return 45;  case "[h]:mm:ss":  	return 46;  case "mmss.0":  	return 47;  case "##0.0":  	return 48;  case "@":  	return 49;  default:  	return int.MinValue;  }  
Magic Number,OfficeOpenXml.Style,ExcelNumberFormat,C:\repos\bambit_EPPlus\EPPlus\Style\ExcelNumberFormat.cs,GetFromBuildIdFromFormat,The following statement contains a magic number: switch (format) {  case "General":  	return 0;  case "0":  	return 1;  case "0.00":  	return 2;  case "#'##0":  	return 3;  case "#'##0.00":  	return 4;  case "0%":  	return 9;  case "0.00%":  	return 10;  case "0.00E+00":  	return 11;  case "# ?/?":  	return 12;  case "# ??/??":  	return 13;  case "mm-dd-yy":  	return 14;  case "d-mmm-yy":  	return 15;  case "d-mmm":  	return 16;  case "mmm-yy":  	return 17;  case "h:mm AM/PM":  	return 18;  case "h:mm:ss AM/PM":  	return 19;  case "h:mm":  	return 20;  case "h:mm:ss":  	return 21;  case "m/d/yy h:mm":  	return 22;  case "#'##0 ;(#'##0)":  	return 37;  case "#'##0 ;[Red](#'##0)":  	return 38;  case "#'##0.00;(#'##0.00)":  	return 39;  case "#'##0.00;[Red](#'#)":  	return 40;  case "mm:ss":  	return 45;  case "[h]:mm:ss":  	return 46;  case "mmss.0":  	return 47;  case "##0.0":  	return 48;  case "@":  	return 49;  default:  	return int.MinValue;  }  
Magic Number,OfficeOpenXml.Style,ExcelNumberFormat,C:\repos\bambit_EPPlus\EPPlus\Style\ExcelNumberFormat.cs,GetFromBuildIdFromFormat,The following statement contains a magic number: switch (format) {  case "General":  	return 0;  case "0":  	return 1;  case "0.00":  	return 2;  case "#'##0":  	return 3;  case "#'##0.00":  	return 4;  case "0%":  	return 9;  case "0.00%":  	return 10;  case "0.00E+00":  	return 11;  case "# ?/?":  	return 12;  case "# ??/??":  	return 13;  case "mm-dd-yy":  	return 14;  case "d-mmm-yy":  	return 15;  case "d-mmm":  	return 16;  case "mmm-yy":  	return 17;  case "h:mm AM/PM":  	return 18;  case "h:mm:ss AM/PM":  	return 19;  case "h:mm":  	return 20;  case "h:mm:ss":  	return 21;  case "m/d/yy h:mm":  	return 22;  case "#'##0 ;(#'##0)":  	return 37;  case "#'##0 ;[Red](#'##0)":  	return 38;  case "#'##0.00;(#'##0.00)":  	return 39;  case "#'##0.00;[Red](#'#)":  	return 40;  case "mm:ss":  	return 45;  case "[h]:mm:ss":  	return 46;  case "mmss.0":  	return 47;  case "##0.0":  	return 48;  case "@":  	return 49;  default:  	return int.MinValue;  }  
Magic Number,OfficeOpenXml.Style,ExcelNumberFormat,C:\repos\bambit_EPPlus\EPPlus\Style\ExcelNumberFormat.cs,GetFromBuildIdFromFormat,The following statement contains a magic number: switch (format) {  case "General":  	return 0;  case "0":  	return 1;  case "0.00":  	return 2;  case "#'##0":  	return 3;  case "#'##0.00":  	return 4;  case "0%":  	return 9;  case "0.00%":  	return 10;  case "0.00E+00":  	return 11;  case "# ?/?":  	return 12;  case "# ??/??":  	return 13;  case "mm-dd-yy":  	return 14;  case "d-mmm-yy":  	return 15;  case "d-mmm":  	return 16;  case "mmm-yy":  	return 17;  case "h:mm AM/PM":  	return 18;  case "h:mm:ss AM/PM":  	return 19;  case "h:mm":  	return 20;  case "h:mm:ss":  	return 21;  case "m/d/yy h:mm":  	return 22;  case "#'##0 ;(#'##0)":  	return 37;  case "#'##0 ;[Red](#'##0)":  	return 38;  case "#'##0.00;(#'##0.00)":  	return 39;  case "#'##0.00;[Red](#'#)":  	return 40;  case "mm:ss":  	return 45;  case "[h]:mm:ss":  	return 46;  case "mmss.0":  	return 47;  case "##0.0":  	return 48;  case "@":  	return 49;  default:  	return int.MinValue;  }  
Magic Number,OfficeOpenXml.Style,ExcelNumberFormat,C:\repos\bambit_EPPlus\EPPlus\Style\ExcelNumberFormat.cs,GetFromBuildIdFromFormat,The following statement contains a magic number: switch (format) {  case "General":  	return 0;  case "0":  	return 1;  case "0.00":  	return 2;  case "#'##0":  	return 3;  case "#'##0.00":  	return 4;  case "0%":  	return 9;  case "0.00%":  	return 10;  case "0.00E+00":  	return 11;  case "# ?/?":  	return 12;  case "# ??/??":  	return 13;  case "mm-dd-yy":  	return 14;  case "d-mmm-yy":  	return 15;  case "d-mmm":  	return 16;  case "mmm-yy":  	return 17;  case "h:mm AM/PM":  	return 18;  case "h:mm:ss AM/PM":  	return 19;  case "h:mm":  	return 20;  case "h:mm:ss":  	return 21;  case "m/d/yy h:mm":  	return 22;  case "#'##0 ;(#'##0)":  	return 37;  case "#'##0 ;[Red](#'##0)":  	return 38;  case "#'##0.00;(#'##0.00)":  	return 39;  case "#'##0.00;[Red](#'#)":  	return 40;  case "mm:ss":  	return 45;  case "[h]:mm:ss":  	return 46;  case "mmss.0":  	return 47;  case "##0.0":  	return 48;  case "@":  	return 49;  default:  	return int.MinValue;  }  
Magic Number,OfficeOpenXml.Style,ExcelNumberFormat,C:\repos\bambit_EPPlus\EPPlus\Style\ExcelNumberFormat.cs,GetFromBuildIdFromFormat,The following statement contains a magic number: switch (format) {  case "General":  	return 0;  case "0":  	return 1;  case "0.00":  	return 2;  case "#'##0":  	return 3;  case "#'##0.00":  	return 4;  case "0%":  	return 9;  case "0.00%":  	return 10;  case "0.00E+00":  	return 11;  case "# ?/?":  	return 12;  case "# ??/??":  	return 13;  case "mm-dd-yy":  	return 14;  case "d-mmm-yy":  	return 15;  case "d-mmm":  	return 16;  case "mmm-yy":  	return 17;  case "h:mm AM/PM":  	return 18;  case "h:mm:ss AM/PM":  	return 19;  case "h:mm":  	return 20;  case "h:mm:ss":  	return 21;  case "m/d/yy h:mm":  	return 22;  case "#'##0 ;(#'##0)":  	return 37;  case "#'##0 ;[Red](#'##0)":  	return 38;  case "#'##0.00;(#'##0.00)":  	return 39;  case "#'##0.00;[Red](#'#)":  	return 40;  case "mm:ss":  	return 45;  case "[h]:mm:ss":  	return 46;  case "mmss.0":  	return 47;  case "##0.0":  	return 48;  case "@":  	return 49;  default:  	return int.MinValue;  }  
Magic Number,OfficeOpenXml.Style,ExcelNumberFormat,C:\repos\bambit_EPPlus\EPPlus\Style\ExcelNumberFormat.cs,GetFromBuildIdFromFormat,The following statement contains a magic number: switch (format) {  case "General":  	return 0;  case "0":  	return 1;  case "0.00":  	return 2;  case "#'##0":  	return 3;  case "#'##0.00":  	return 4;  case "0%":  	return 9;  case "0.00%":  	return 10;  case "0.00E+00":  	return 11;  case "# ?/?":  	return 12;  case "# ??/??":  	return 13;  case "mm-dd-yy":  	return 14;  case "d-mmm-yy":  	return 15;  case "d-mmm":  	return 16;  case "mmm-yy":  	return 17;  case "h:mm AM/PM":  	return 18;  case "h:mm:ss AM/PM":  	return 19;  case "h:mm":  	return 20;  case "h:mm:ss":  	return 21;  case "m/d/yy h:mm":  	return 22;  case "#'##0 ;(#'##0)":  	return 37;  case "#'##0 ;[Red](#'##0)":  	return 38;  case "#'##0.00;(#'##0.00)":  	return 39;  case "#'##0.00;[Red](#'#)":  	return 40;  case "mm:ss":  	return 45;  case "[h]:mm:ss":  	return 46;  case "mmss.0":  	return 47;  case "##0.0":  	return 48;  case "@":  	return 49;  default:  	return int.MinValue;  }  
Magic Number,OfficeOpenXml.Style,ExcelNumberFormat,C:\repos\bambit_EPPlus\EPPlus\Style\ExcelNumberFormat.cs,GetFromBuildIdFromFormat,The following statement contains a magic number: switch (format) {  case "General":  	return 0;  case "0":  	return 1;  case "0.00":  	return 2;  case "#'##0":  	return 3;  case "#'##0.00":  	return 4;  case "0%":  	return 9;  case "0.00%":  	return 10;  case "0.00E+00":  	return 11;  case "# ?/?":  	return 12;  case "# ??/??":  	return 13;  case "mm-dd-yy":  	return 14;  case "d-mmm-yy":  	return 15;  case "d-mmm":  	return 16;  case "mmm-yy":  	return 17;  case "h:mm AM/PM":  	return 18;  case "h:mm:ss AM/PM":  	return 19;  case "h:mm":  	return 20;  case "h:mm:ss":  	return 21;  case "m/d/yy h:mm":  	return 22;  case "#'##0 ;(#'##0)":  	return 37;  case "#'##0 ;[Red](#'##0)":  	return 38;  case "#'##0.00;(#'##0.00)":  	return 39;  case "#'##0.00;[Red](#'#)":  	return 40;  case "mm:ss":  	return 45;  case "[h]:mm:ss":  	return 46;  case "mmss.0":  	return 47;  case "##0.0":  	return 48;  case "@":  	return 49;  default:  	return int.MinValue;  }  
Magic Number,OfficeOpenXml.Style,ExcelNumberFormat,C:\repos\bambit_EPPlus\EPPlus\Style\ExcelNumberFormat.cs,GetFromBuildIdFromFormat,The following statement contains a magic number: switch (format) {  case "General":  	return 0;  case "0":  	return 1;  case "0.00":  	return 2;  case "#'##0":  	return 3;  case "#'##0.00":  	return 4;  case "0%":  	return 9;  case "0.00%":  	return 10;  case "0.00E+00":  	return 11;  case "# ?/?":  	return 12;  case "# ??/??":  	return 13;  case "mm-dd-yy":  	return 14;  case "d-mmm-yy":  	return 15;  case "d-mmm":  	return 16;  case "mmm-yy":  	return 17;  case "h:mm AM/PM":  	return 18;  case "h:mm:ss AM/PM":  	return 19;  case "h:mm":  	return 20;  case "h:mm:ss":  	return 21;  case "m/d/yy h:mm":  	return 22;  case "#'##0 ;(#'##0)":  	return 37;  case "#'##0 ;[Red](#'##0)":  	return 38;  case "#'##0.00;(#'##0.00)":  	return 39;  case "#'##0.00;[Red](#'#)":  	return 40;  case "mm:ss":  	return 45;  case "[h]:mm:ss":  	return 46;  case "mmss.0":  	return 47;  case "##0.0":  	return 48;  case "@":  	return 49;  default:  	return int.MinValue;  }  
Magic Number,OfficeOpenXml.Style,ExcelNumberFormat,C:\repos\bambit_EPPlus\EPPlus\Style\ExcelNumberFormat.cs,GetFromBuildIdFromFormat,The following statement contains a magic number: switch (format) {  case "General":  	return 0;  case "0":  	return 1;  case "0.00":  	return 2;  case "#'##0":  	return 3;  case "#'##0.00":  	return 4;  case "0%":  	return 9;  case "0.00%":  	return 10;  case "0.00E+00":  	return 11;  case "# ?/?":  	return 12;  case "# ??/??":  	return 13;  case "mm-dd-yy":  	return 14;  case "d-mmm-yy":  	return 15;  case "d-mmm":  	return 16;  case "mmm-yy":  	return 17;  case "h:mm AM/PM":  	return 18;  case "h:mm:ss AM/PM":  	return 19;  case "h:mm":  	return 20;  case "h:mm:ss":  	return 21;  case "m/d/yy h:mm":  	return 22;  case "#'##0 ;(#'##0)":  	return 37;  case "#'##0 ;[Red](#'##0)":  	return 38;  case "#'##0.00;(#'##0.00)":  	return 39;  case "#'##0.00;[Red](#'#)":  	return 40;  case "mm:ss":  	return 45;  case "[h]:mm:ss":  	return 46;  case "mmss.0":  	return 47;  case "##0.0":  	return 48;  case "@":  	return 49;  default:  	return int.MinValue;  }  
Magic Number,OfficeOpenXml.Style,ExcelNumberFormat,C:\repos\bambit_EPPlus\EPPlus\Style\ExcelNumberFormat.cs,GetFromBuildIdFromFormat,The following statement contains a magic number: switch (format) {  case "General":  	return 0;  case "0":  	return 1;  case "0.00":  	return 2;  case "#'##0":  	return 3;  case "#'##0.00":  	return 4;  case "0%":  	return 9;  case "0.00%":  	return 10;  case "0.00E+00":  	return 11;  case "# ?/?":  	return 12;  case "# ??/??":  	return 13;  case "mm-dd-yy":  	return 14;  case "d-mmm-yy":  	return 15;  case "d-mmm":  	return 16;  case "mmm-yy":  	return 17;  case "h:mm AM/PM":  	return 18;  case "h:mm:ss AM/PM":  	return 19;  case "h:mm":  	return 20;  case "h:mm:ss":  	return 21;  case "m/d/yy h:mm":  	return 22;  case "#'##0 ;(#'##0)":  	return 37;  case "#'##0 ;[Red](#'##0)":  	return 38;  case "#'##0.00;(#'##0.00)":  	return 39;  case "#'##0.00;[Red](#'#)":  	return 40;  case "mm:ss":  	return 45;  case "[h]:mm:ss":  	return 46;  case "mmss.0":  	return 47;  case "##0.0":  	return 48;  case "@":  	return 49;  default:  	return int.MinValue;  }  
Magic Number,OfficeOpenXml.Style,ExcelNumberFormat,C:\repos\bambit_EPPlus\EPPlus\Style\ExcelNumberFormat.cs,GetFromBuildIdFromFormat,The following statement contains a magic number: switch (format) {  case "General":  	return 0;  case "0":  	return 1;  case "0.00":  	return 2;  case "#'##0":  	return 3;  case "#'##0.00":  	return 4;  case "0%":  	return 9;  case "0.00%":  	return 10;  case "0.00E+00":  	return 11;  case "# ?/?":  	return 12;  case "# ??/??":  	return 13;  case "mm-dd-yy":  	return 14;  case "d-mmm-yy":  	return 15;  case "d-mmm":  	return 16;  case "mmm-yy":  	return 17;  case "h:mm AM/PM":  	return 18;  case "h:mm:ss AM/PM":  	return 19;  case "h:mm":  	return 20;  case "h:mm:ss":  	return 21;  case "m/d/yy h:mm":  	return 22;  case "#'##0 ;(#'##0)":  	return 37;  case "#'##0 ;[Red](#'##0)":  	return 38;  case "#'##0.00;(#'##0.00)":  	return 39;  case "#'##0.00;[Red](#'#)":  	return 40;  case "mm:ss":  	return 45;  case "[h]:mm:ss":  	return 46;  case "mmss.0":  	return 47;  case "##0.0":  	return 48;  case "@":  	return 49;  default:  	return int.MinValue;  }  
Magic Number,OfficeOpenXml.Style,ExcelNumberFormat,C:\repos\bambit_EPPlus\EPPlus\Style\ExcelNumberFormat.cs,GetFromBuildIdFromFormat,The following statement contains a magic number: return 2;  
Magic Number,OfficeOpenXml.Style,ExcelNumberFormat,C:\repos\bambit_EPPlus\EPPlus\Style\ExcelNumberFormat.cs,GetFromBuildIdFromFormat,The following statement contains a magic number: return 3;  
Magic Number,OfficeOpenXml.Style,ExcelNumberFormat,C:\repos\bambit_EPPlus\EPPlus\Style\ExcelNumberFormat.cs,GetFromBuildIdFromFormat,The following statement contains a magic number: return 4;  
Magic Number,OfficeOpenXml.Style,ExcelNumberFormat,C:\repos\bambit_EPPlus\EPPlus\Style\ExcelNumberFormat.cs,GetFromBuildIdFromFormat,The following statement contains a magic number: return 9;  
Magic Number,OfficeOpenXml.Style,ExcelNumberFormat,C:\repos\bambit_EPPlus\EPPlus\Style\ExcelNumberFormat.cs,GetFromBuildIdFromFormat,The following statement contains a magic number: return 10;  
Magic Number,OfficeOpenXml.Style,ExcelNumberFormat,C:\repos\bambit_EPPlus\EPPlus\Style\ExcelNumberFormat.cs,GetFromBuildIdFromFormat,The following statement contains a magic number: return 11;  
Magic Number,OfficeOpenXml.Style,ExcelNumberFormat,C:\repos\bambit_EPPlus\EPPlus\Style\ExcelNumberFormat.cs,GetFromBuildIdFromFormat,The following statement contains a magic number: return 12;  
Magic Number,OfficeOpenXml.Style,ExcelNumberFormat,C:\repos\bambit_EPPlus\EPPlus\Style\ExcelNumberFormat.cs,GetFromBuildIdFromFormat,The following statement contains a magic number: return 13;  
Magic Number,OfficeOpenXml.Style,ExcelNumberFormat,C:\repos\bambit_EPPlus\EPPlus\Style\ExcelNumberFormat.cs,GetFromBuildIdFromFormat,The following statement contains a magic number: return 14;  
Magic Number,OfficeOpenXml.Style,ExcelNumberFormat,C:\repos\bambit_EPPlus\EPPlus\Style\ExcelNumberFormat.cs,GetFromBuildIdFromFormat,The following statement contains a magic number: return 15;  
Magic Number,OfficeOpenXml.Style,ExcelNumberFormat,C:\repos\bambit_EPPlus\EPPlus\Style\ExcelNumberFormat.cs,GetFromBuildIdFromFormat,The following statement contains a magic number: return 16;  
Magic Number,OfficeOpenXml.Style,ExcelNumberFormat,C:\repos\bambit_EPPlus\EPPlus\Style\ExcelNumberFormat.cs,GetFromBuildIdFromFormat,The following statement contains a magic number: return 17;  
Magic Number,OfficeOpenXml.Style,ExcelNumberFormat,C:\repos\bambit_EPPlus\EPPlus\Style\ExcelNumberFormat.cs,GetFromBuildIdFromFormat,The following statement contains a magic number: return 18;  
Magic Number,OfficeOpenXml.Style,ExcelNumberFormat,C:\repos\bambit_EPPlus\EPPlus\Style\ExcelNumberFormat.cs,GetFromBuildIdFromFormat,The following statement contains a magic number: return 19;  
Magic Number,OfficeOpenXml.Style,ExcelNumberFormat,C:\repos\bambit_EPPlus\EPPlus\Style\ExcelNumberFormat.cs,GetFromBuildIdFromFormat,The following statement contains a magic number: return 20;  
Magic Number,OfficeOpenXml.Style,ExcelNumberFormat,C:\repos\bambit_EPPlus\EPPlus\Style\ExcelNumberFormat.cs,GetFromBuildIdFromFormat,The following statement contains a magic number: return 21;  
Magic Number,OfficeOpenXml.Style,ExcelNumberFormat,C:\repos\bambit_EPPlus\EPPlus\Style\ExcelNumberFormat.cs,GetFromBuildIdFromFormat,The following statement contains a magic number: return 22;  
Magic Number,OfficeOpenXml.Style,ExcelNumberFormat,C:\repos\bambit_EPPlus\EPPlus\Style\ExcelNumberFormat.cs,GetFromBuildIdFromFormat,The following statement contains a magic number: return 37;  
Magic Number,OfficeOpenXml.Style,ExcelNumberFormat,C:\repos\bambit_EPPlus\EPPlus\Style\ExcelNumberFormat.cs,GetFromBuildIdFromFormat,The following statement contains a magic number: return 38;  
Magic Number,OfficeOpenXml.Style,ExcelNumberFormat,C:\repos\bambit_EPPlus\EPPlus\Style\ExcelNumberFormat.cs,GetFromBuildIdFromFormat,The following statement contains a magic number: return 39;  
Magic Number,OfficeOpenXml.Style,ExcelNumberFormat,C:\repos\bambit_EPPlus\EPPlus\Style\ExcelNumberFormat.cs,GetFromBuildIdFromFormat,The following statement contains a magic number: return 40;  
Magic Number,OfficeOpenXml.Style,ExcelNumberFormat,C:\repos\bambit_EPPlus\EPPlus\Style\ExcelNumberFormat.cs,GetFromBuildIdFromFormat,The following statement contains a magic number: return 45;  
Magic Number,OfficeOpenXml.Style,ExcelNumberFormat,C:\repos\bambit_EPPlus\EPPlus\Style\ExcelNumberFormat.cs,GetFromBuildIdFromFormat,The following statement contains a magic number: return 46;  
Magic Number,OfficeOpenXml.Style,ExcelNumberFormat,C:\repos\bambit_EPPlus\EPPlus\Style\ExcelNumberFormat.cs,GetFromBuildIdFromFormat,The following statement contains a magic number: return 47;  
Magic Number,OfficeOpenXml.Style,ExcelNumberFormat,C:\repos\bambit_EPPlus\EPPlus\Style\ExcelNumberFormat.cs,GetFromBuildIdFromFormat,The following statement contains a magic number: return 48;  
Magic Number,OfficeOpenXml.Style,ExcelNumberFormat,C:\repos\bambit_EPPlus\EPPlus\Style\ExcelNumberFormat.cs,GetFromBuildIdFromFormat,The following statement contains a magic number: return 49;  
Magic Number,OfficeOpenXml.Style.XmlAccess,ExcelXfs,C:\repos\bambit_EPPlus\EPPlus\Style\XmlAccess\ExcelXfsXml.cs,GetIdGradientFill,The following statement contains a magic number: if (Fill is ExcelGradientFillXml) {  	fill = (ExcelGradientFillXml)Fill.Copy ();  }  else {  	fill = new ExcelGradientFillXml (Fill.NameSpaceManager);  	fill.GradientColor1.SetColor (Color.White);  	fill.GradientColor2.SetColor (Color.FromArgb (79' 129' 189));  	fill.Type = ExcelFillGradientType.Linear;  	fill.Degree = 90;  	fill.Top = double.NaN;  	fill.Bottom = double.NaN;  	fill.Left = double.NaN;  	fill.Right = double.NaN;  }  
Magic Number,OfficeOpenXml.Style.XmlAccess,ExcelXfs,C:\repos\bambit_EPPlus\EPPlus\Style\XmlAccess\ExcelXfsXml.cs,GetIdGradientFill,The following statement contains a magic number: if (Fill is ExcelGradientFillXml) {  	fill = (ExcelGradientFillXml)Fill.Copy ();  }  else {  	fill = new ExcelGradientFillXml (Fill.NameSpaceManager);  	fill.GradientColor1.SetColor (Color.White);  	fill.GradientColor2.SetColor (Color.FromArgb (79' 129' 189));  	fill.Type = ExcelFillGradientType.Linear;  	fill.Degree = 90;  	fill.Top = double.NaN;  	fill.Bottom = double.NaN;  	fill.Left = double.NaN;  	fill.Right = double.NaN;  }  
Magic Number,OfficeOpenXml.Style.XmlAccess,ExcelXfs,C:\repos\bambit_EPPlus\EPPlus\Style\XmlAccess\ExcelXfsXml.cs,GetIdGradientFill,The following statement contains a magic number: if (Fill is ExcelGradientFillXml) {  	fill = (ExcelGradientFillXml)Fill.Copy ();  }  else {  	fill = new ExcelGradientFillXml (Fill.NameSpaceManager);  	fill.GradientColor1.SetColor (Color.White);  	fill.GradientColor2.SetColor (Color.FromArgb (79' 129' 189));  	fill.Type = ExcelFillGradientType.Linear;  	fill.Degree = 90;  	fill.Top = double.NaN;  	fill.Bottom = double.NaN;  	fill.Left = double.NaN;  	fill.Right = double.NaN;  }  
Magic Number,OfficeOpenXml.Style.XmlAccess,ExcelXfs,C:\repos\bambit_EPPlus\EPPlus\Style\XmlAccess\ExcelXfsXml.cs,GetIdGradientFill,The following statement contains a magic number: if (Fill is ExcelGradientFillXml) {  	fill = (ExcelGradientFillXml)Fill.Copy ();  }  else {  	fill = new ExcelGradientFillXml (Fill.NameSpaceManager);  	fill.GradientColor1.SetColor (Color.White);  	fill.GradientColor2.SetColor (Color.FromArgb (79' 129' 189));  	fill.Type = ExcelFillGradientType.Linear;  	fill.Degree = 90;  	fill.Top = double.NaN;  	fill.Bottom = double.NaN;  	fill.Left = double.NaN;  	fill.Right = double.NaN;  }  
Magic Number,OfficeOpenXml.Style.XmlAccess,ExcelXfs,C:\repos\bambit_EPPlus\EPPlus\Style\XmlAccess\ExcelXfsXml.cs,GetIdGradientFill,The following statement contains a magic number: fill.GradientColor2.SetColor (Color.FromArgb (79' 129' 189));  
Magic Number,OfficeOpenXml.Style.XmlAccess,ExcelXfs,C:\repos\bambit_EPPlus\EPPlus\Style\XmlAccess\ExcelXfsXml.cs,GetIdGradientFill,The following statement contains a magic number: fill.GradientColor2.SetColor (Color.FromArgb (79' 129' 189));  
Magic Number,OfficeOpenXml.Style.XmlAccess,ExcelXfs,C:\repos\bambit_EPPlus\EPPlus\Style\XmlAccess\ExcelXfsXml.cs,GetIdGradientFill,The following statement contains a magic number: fill.GradientColor2.SetColor (Color.FromArgb (79' 129' 189));  
Magic Number,OfficeOpenXml.Style.XmlAccess,ExcelXfs,C:\repos\bambit_EPPlus\EPPlus\Style\XmlAccess\ExcelXfsXml.cs,GetIdGradientFill,The following statement contains a magic number: fill.Degree = 90;  
Magic Number,OfficeOpenXml.Style.XmlAccess,ExcelNumberFormatXml,C:\repos\bambit_EPPlus\EPPlus\Style\XmlAccess\ExcelNumberFormatXml.cs,AddBuildIn,The following statement contains a magic number: NumberFormats.Add ("0.00"' new ExcelNumberFormatXml (NameSpaceManager' true) {  	NumFmtId = 2'  	Format = "0.00"  });  
Magic Number,OfficeOpenXml.Style.XmlAccess,ExcelNumberFormatXml,C:\repos\bambit_EPPlus\EPPlus\Style\XmlAccess\ExcelNumberFormatXml.cs,AddBuildIn,The following statement contains a magic number: NumberFormats.Add ("#'##0"' new ExcelNumberFormatXml (NameSpaceManager' true) {  	NumFmtId = 3'  	Format = "#'##0"  });  
Magic Number,OfficeOpenXml.Style.XmlAccess,ExcelNumberFormatXml,C:\repos\bambit_EPPlus\EPPlus\Style\XmlAccess\ExcelNumberFormatXml.cs,AddBuildIn,The following statement contains a magic number: NumberFormats.Add ("#'##0.00"' new ExcelNumberFormatXml (NameSpaceManager' true) {  	NumFmtId = 4'  	Format = "#'##0.00"  });  
Magic Number,OfficeOpenXml.Style.XmlAccess,ExcelNumberFormatXml,C:\repos\bambit_EPPlus\EPPlus\Style\XmlAccess\ExcelNumberFormatXml.cs,AddBuildIn,The following statement contains a magic number: NumberFormats.Add ("0%"' new ExcelNumberFormatXml (NameSpaceManager' true) {  	NumFmtId = 9'  	Format = "0%"  });  
Magic Number,OfficeOpenXml.Style.XmlAccess,ExcelNumberFormatXml,C:\repos\bambit_EPPlus\EPPlus\Style\XmlAccess\ExcelNumberFormatXml.cs,AddBuildIn,The following statement contains a magic number: NumberFormats.Add ("0.00%"' new ExcelNumberFormatXml (NameSpaceManager' true) {  	NumFmtId = 10'  	Format = "0.00%"  });  
Magic Number,OfficeOpenXml.Style.XmlAccess,ExcelNumberFormatXml,C:\repos\bambit_EPPlus\EPPlus\Style\XmlAccess\ExcelNumberFormatXml.cs,AddBuildIn,The following statement contains a magic number: NumberFormats.Add ("0.00E+00"' new ExcelNumberFormatXml (NameSpaceManager' true) {  	NumFmtId = 11'  	Format = "0.00E+00"  });  
Magic Number,OfficeOpenXml.Style.XmlAccess,ExcelNumberFormatXml,C:\repos\bambit_EPPlus\EPPlus\Style\XmlAccess\ExcelNumberFormatXml.cs,AddBuildIn,The following statement contains a magic number: NumberFormats.Add ("# ?/?"' new ExcelNumberFormatXml (NameSpaceManager' true) {  	NumFmtId = 12'  	Format = "# ?/?"  });  
Magic Number,OfficeOpenXml.Style.XmlAccess,ExcelNumberFormatXml,C:\repos\bambit_EPPlus\EPPlus\Style\XmlAccess\ExcelNumberFormatXml.cs,AddBuildIn,The following statement contains a magic number: NumberFormats.Add ("# ??/??"' new ExcelNumberFormatXml (NameSpaceManager' true) {  	NumFmtId = 13'  	Format = "# ??/??"  });  
Magic Number,OfficeOpenXml.Style.XmlAccess,ExcelNumberFormatXml,C:\repos\bambit_EPPlus\EPPlus\Style\XmlAccess\ExcelNumberFormatXml.cs,AddBuildIn,The following statement contains a magic number: NumberFormats.Add ("mm-dd-yy"' new ExcelNumberFormatXml (NameSpaceManager' true) {  	NumFmtId = 14'  	Format = "mm-dd-yy"  });  
Magic Number,OfficeOpenXml.Style.XmlAccess,ExcelNumberFormatXml,C:\repos\bambit_EPPlus\EPPlus\Style\XmlAccess\ExcelNumberFormatXml.cs,AddBuildIn,The following statement contains a magic number: NumberFormats.Add ("d-mmm-yy"' new ExcelNumberFormatXml (NameSpaceManager' true) {  	NumFmtId = 15'  	Format = "d-mmm-yy"  });  
Magic Number,OfficeOpenXml.Style.XmlAccess,ExcelNumberFormatXml,C:\repos\bambit_EPPlus\EPPlus\Style\XmlAccess\ExcelNumberFormatXml.cs,AddBuildIn,The following statement contains a magic number: NumberFormats.Add ("d-mmm"' new ExcelNumberFormatXml (NameSpaceManager' true) {  	NumFmtId = 16'  	Format = "d-mmm"  });  
Magic Number,OfficeOpenXml.Style.XmlAccess,ExcelNumberFormatXml,C:\repos\bambit_EPPlus\EPPlus\Style\XmlAccess\ExcelNumberFormatXml.cs,AddBuildIn,The following statement contains a magic number: NumberFormats.Add ("mmm-yy"' new ExcelNumberFormatXml (NameSpaceManager' true) {  	NumFmtId = 17'  	Format = "mmm-yy"  });  
Magic Number,OfficeOpenXml.Style.XmlAccess,ExcelNumberFormatXml,C:\repos\bambit_EPPlus\EPPlus\Style\XmlAccess\ExcelNumberFormatXml.cs,AddBuildIn,The following statement contains a magic number: NumberFormats.Add ("h:mm AM/PM"' new ExcelNumberFormatXml (NameSpaceManager' true) {  	NumFmtId = 18'  	Format = "h:mm AM/PM"  });  
Magic Number,OfficeOpenXml.Style.XmlAccess,ExcelNumberFormatXml,C:\repos\bambit_EPPlus\EPPlus\Style\XmlAccess\ExcelNumberFormatXml.cs,AddBuildIn,The following statement contains a magic number: NumberFormats.Add ("h:mm:ss AM/PM"' new ExcelNumberFormatXml (NameSpaceManager' true) {  	NumFmtId = 19'  	Format = "h:mm:ss AM/PM"  });  
Magic Number,OfficeOpenXml.Style.XmlAccess,ExcelNumberFormatXml,C:\repos\bambit_EPPlus\EPPlus\Style\XmlAccess\ExcelNumberFormatXml.cs,AddBuildIn,The following statement contains a magic number: NumberFormats.Add ("h:mm"' new ExcelNumberFormatXml (NameSpaceManager' true) {  	NumFmtId = 20'  	Format = "h:mm"  });  
Magic Number,OfficeOpenXml.Style.XmlAccess,ExcelNumberFormatXml,C:\repos\bambit_EPPlus\EPPlus\Style\XmlAccess\ExcelNumberFormatXml.cs,AddBuildIn,The following statement contains a magic number: NumberFormats.Add ("h:mm:dd"' new ExcelNumberFormatXml (NameSpaceManager' true) {  	NumFmtId = 21'  	Format = "h:mm:dd"  });  
Magic Number,OfficeOpenXml.Style.XmlAccess,ExcelNumberFormatXml,C:\repos\bambit_EPPlus\EPPlus\Style\XmlAccess\ExcelNumberFormatXml.cs,AddBuildIn,The following statement contains a magic number: NumberFormats.Add ("m/d/yy h:mm"' new ExcelNumberFormatXml (NameSpaceManager' true) {  	NumFmtId = 22'  	Format = "m/d/yy h:mm"  });  
Magic Number,OfficeOpenXml.Style.XmlAccess,ExcelNumberFormatXml,C:\repos\bambit_EPPlus\EPPlus\Style\XmlAccess\ExcelNumberFormatXml.cs,AddBuildIn,The following statement contains a magic number: NumberFormats.Add ("#'##0 ;(#'##0)"' new ExcelNumberFormatXml (NameSpaceManager' true) {  	NumFmtId = 37'  	Format = "#'##0 ;(#'##0)"  });  
Magic Number,OfficeOpenXml.Style.XmlAccess,ExcelNumberFormatXml,C:\repos\bambit_EPPlus\EPPlus\Style\XmlAccess\ExcelNumberFormatXml.cs,AddBuildIn,The following statement contains a magic number: NumberFormats.Add ("#'##0 ;[Red](#'##0)"' new ExcelNumberFormatXml (NameSpaceManager' true) {  	NumFmtId = 38'  	Format = "#'##0 ;[Red](#'##0)"  });  
Magic Number,OfficeOpenXml.Style.XmlAccess,ExcelNumberFormatXml,C:\repos\bambit_EPPlus\EPPlus\Style\XmlAccess\ExcelNumberFormatXml.cs,AddBuildIn,The following statement contains a magic number: NumberFormats.Add ("#'##0.00;(#'##0.00)"' new ExcelNumberFormatXml (NameSpaceManager' true) {  	NumFmtId = 39'  	Format = "#'##0.00;(#'##0.00)"  });  
Magic Number,OfficeOpenXml.Style.XmlAccess,ExcelNumberFormatXml,C:\repos\bambit_EPPlus\EPPlus\Style\XmlAccess\ExcelNumberFormatXml.cs,AddBuildIn,The following statement contains a magic number: NumberFormats.Add ("#'##0.00;[Red](#'#)"' new ExcelNumberFormatXml (NameSpaceManager' true) {  	NumFmtId = 40'  	Format = "#'##0.00;[Red](#'#)"  });  
Magic Number,OfficeOpenXml.Style.XmlAccess,ExcelNumberFormatXml,C:\repos\bambit_EPPlus\EPPlus\Style\XmlAccess\ExcelNumberFormatXml.cs,AddBuildIn,The following statement contains a magic number: NumberFormats.Add ("mm:ss"' new ExcelNumberFormatXml (NameSpaceManager' true) {  	NumFmtId = 45'  	Format = "mm:ss"  });  
Magic Number,OfficeOpenXml.Style.XmlAccess,ExcelNumberFormatXml,C:\repos\bambit_EPPlus\EPPlus\Style\XmlAccess\ExcelNumberFormatXml.cs,AddBuildIn,The following statement contains a magic number: NumberFormats.Add ("[h]:mm:ss"' new ExcelNumberFormatXml (NameSpaceManager' true) {  	NumFmtId = 46'  	Format = "[h]:mm:ss"  });  
Magic Number,OfficeOpenXml.Style.XmlAccess,ExcelNumberFormatXml,C:\repos\bambit_EPPlus\EPPlus\Style\XmlAccess\ExcelNumberFormatXml.cs,AddBuildIn,The following statement contains a magic number: NumberFormats.Add ("mmss.0"' new ExcelNumberFormatXml (NameSpaceManager' true) {  	NumFmtId = 47'  	Format = "mmss.0"  });  
Magic Number,OfficeOpenXml.Style.XmlAccess,ExcelNumberFormatXml,C:\repos\bambit_EPPlus\EPPlus\Style\XmlAccess\ExcelNumberFormatXml.cs,AddBuildIn,The following statement contains a magic number: NumberFormats.Add ("##0.0"' new ExcelNumberFormatXml (NameSpaceManager' true) {  	NumFmtId = 48'  	Format = "##0.0"  });  
Magic Number,OfficeOpenXml.Style.XmlAccess,ExcelNumberFormatXml,C:\repos\bambit_EPPlus\EPPlus\Style\XmlAccess\ExcelNumberFormatXml.cs,AddBuildIn,The following statement contains a magic number: NumberFormats.Add ("@"' new ExcelNumberFormatXml (NameSpaceManager' true) {  	NumFmtId = 49'  	Format = "@"  });  
Magic Number,OfficeOpenXml.Style.XmlAccess,ExcelNumberFormatXml,C:\repos\bambit_EPPlus\EPPlus\Style\XmlAccess\ExcelNumberFormatXml.cs,AddBuildIn,The following statement contains a magic number: NumberFormats.NextId = 164;  
Magic Number,OfficeOpenXml.Table.PivotTable,ExcelPivotTableRowColumnFieldCollection,C:\repos\bambit_EPPlus\EPPlus\Table\PivotTable\ExcelPivotTableFieldCollection.cs,SetFlag,The following statement contains a magic number: switch (_topNode) {  case "rowFields":  	if (field.IsColumnField || field.IsPageField) {  		throw (new Exception ("This field is a column or page field. Can't add it to the RowFields collection"));  	}  	field.IsRowField = value;  	field.Axis = ePivotFieldAxis.Row;  	break;  case "colFields":  	if (field.IsRowField || field.IsPageField) {  		throw (new Exception ("This field is a row or page field. Can't add it to the ColumnFields collection"));  	}  	field.IsColumnField = value;  	field.Axis = ePivotFieldAxis.Column;  	break;  case "pageFields":  	if (field.IsColumnField || field.IsRowField) {  		throw (new Exception ("Field is a column or row field. Can't add it to the PageFields collection"));  	}  	if (_table.Address._fromRow < 3) {  		throw (new Exception (string.Format ("A pivot table with page fields must be located above row 3. Currenct location is {0}"' _table.Address.Address)));  	}  	field.IsPageField = value;  	field.Axis = ePivotFieldAxis.Page;  	break;  case "dataFields":  	break;  }  
Magic Number,OfficeOpenXml.Table.PivotTable,ExcelPivotTableRowColumnFieldCollection,C:\repos\bambit_EPPlus\EPPlus\Table\PivotTable\ExcelPivotTableFieldCollection.cs,SetFlag,The following statement contains a magic number: if (_table.Address._fromRow < 3) {  	throw (new Exception (string.Format ("A pivot table with page fields must be located above row 3. Currenct location is {0}"' _table.Address.Address)));  }  
Magic Number,OfficeOpenXml.Table.PivotTable,ExcelPivotTableDataFieldCollection,C:\repos\bambit_EPPlus\EPPlus\Table\PivotTable\ExcelPivotTableFieldCollection.cs,ValidateDupName,The following statement contains a magic number: if (ExistsDfName (dataField.Field.Name' null)) {  	var index = 2;  	string name;  	do {  		name = dataField.Field.Name + "_" + index++.ToString ();  	}  	while (ExistsDfName (name' null));  	dataField.Name = name;  }  
Magic Number,OfficeOpenXml.Table.PivotTable,ExcelPivotTableField,C:\repos\bambit_EPPlus\EPPlus\Table\PivotTable\ExcelPivotTableField.cs,SetDateGroup,The following statement contains a magic number: if (StartDate.Year < 1900) {  	_cacheFieldHelper.SetXmlNodeString ("d:fieldGroup/d:rangePr/@startDate"' "1900-01-01T00:00:00");  }  else {  	_cacheFieldHelper.SetXmlNodeString ("d:fieldGroup/d:rangePr/@startDate"' StartDate.ToString ("s"' CultureInfo.InvariantCulture));  	_cacheFieldHelper.SetXmlNodeString ("d:fieldGroup/d:rangePr/@autoStart"' "0");  }  
Magic Number,OfficeOpenXml.Table.PivotTable,ExcelPivotTableField,C:\repos\bambit_EPPlus\EPPlus\Table\PivotTable\ExcelPivotTableField.cs,AddDateGroupItems,The following statement contains a magic number: AddGroupItem (groupItems' "<" + StartDate.ToString ("s"' CultureInfo.InvariantCulture).Substring (0' 10));  
Magic Number,OfficeOpenXml.Table.PivotTable,ExcelPivotTableField,C:\repos\bambit_EPPlus\EPPlus\Table\PivotTable\ExcelPivotTableField.cs,AddDateGroupItems,The following statement contains a magic number: switch (GroupBy) {  case eDateGroupBy.Seconds:  case eDateGroupBy.Minutes:  	AddTimeSerie (60' groupItems);  	items += 60;  	break;  case eDateGroupBy.Hours:  	AddTimeSerie (24' groupItems);  	items += 24;  	break;  case eDateGroupBy.Days:  	if (interval == 1) {  		DateTime dt = new DateTime (2008' 1' 1);  		//pick a year with 366 days  		while (dt.Year == 2008) {  			AddGroupItem (groupItems' dt.ToString ("dd-MMM"));  			dt = dt.AddDays (1);  		}  		items += 366;  	}  	else {  		DateTime dt = StartDate;  		items = 0;  		while (dt < EndDate) {  			AddGroupItem (groupItems' dt.ToString ("dd-MMM"));  			dt = dt.AddDays (interval);  			items++;  		}  	}  	break;  case eDateGroupBy.Months:  	AddGroupItem (groupItems' "jan");  	AddGroupItem (groupItems' "feb");  	AddGroupItem (groupItems' "mar");  	AddGroupItem (groupItems' "apr");  	AddGroupItem (groupItems' "may");  	AddGroupItem (groupItems' "jun");  	AddGroupItem (groupItems' "jul");  	AddGroupItem (groupItems' "aug");  	AddGroupItem (groupItems' "sep");  	AddGroupItem (groupItems' "oct");  	AddGroupItem (groupItems' "nov");  	AddGroupItem (groupItems' "dec");  	items += 12;  	break;  case eDateGroupBy.Quarters:  	AddGroupItem (groupItems' "Qtr1");  	AddGroupItem (groupItems' "Qtr2");  	AddGroupItem (groupItems' "Qtr3");  	AddGroupItem (groupItems' "Qtr4");  	items += 4;  	break;  case eDateGroupBy.Years:  	if (StartDate.Year >= 1900 && EndDate != DateTime.MaxValue) {  		for (int year = StartDate.Year; year <= EndDate.Year; year++) {  			AddGroupItem (groupItems' year.ToString ());  		}  		items += EndDate.Year - StartDate.Year + 1;  	}  	break;  default:  	throw (new Exception ("unsupported grouping"));  }  
Magic Number,OfficeOpenXml.Table.PivotTable,ExcelPivotTableField,C:\repos\bambit_EPPlus\EPPlus\Table\PivotTable\ExcelPivotTableField.cs,AddDateGroupItems,The following statement contains a magic number: switch (GroupBy) {  case eDateGroupBy.Seconds:  case eDateGroupBy.Minutes:  	AddTimeSerie (60' groupItems);  	items += 60;  	break;  case eDateGroupBy.Hours:  	AddTimeSerie (24' groupItems);  	items += 24;  	break;  case eDateGroupBy.Days:  	if (interval == 1) {  		DateTime dt = new DateTime (2008' 1' 1);  		//pick a year with 366 days  		while (dt.Year == 2008) {  			AddGroupItem (groupItems' dt.ToString ("dd-MMM"));  			dt = dt.AddDays (1);  		}  		items += 366;  	}  	else {  		DateTime dt = StartDate;  		items = 0;  		while (dt < EndDate) {  			AddGroupItem (groupItems' dt.ToString ("dd-MMM"));  			dt = dt.AddDays (interval);  			items++;  		}  	}  	break;  case eDateGroupBy.Months:  	AddGroupItem (groupItems' "jan");  	AddGroupItem (groupItems' "feb");  	AddGroupItem (groupItems' "mar");  	AddGroupItem (groupItems' "apr");  	AddGroupItem (groupItems' "may");  	AddGroupItem (groupItems' "jun");  	AddGroupItem (groupItems' "jul");  	AddGroupItem (groupItems' "aug");  	AddGroupItem (groupItems' "sep");  	AddGroupItem (groupItems' "oct");  	AddGroupItem (groupItems' "nov");  	AddGroupItem (groupItems' "dec");  	items += 12;  	break;  case eDateGroupBy.Quarters:  	AddGroupItem (groupItems' "Qtr1");  	AddGroupItem (groupItems' "Qtr2");  	AddGroupItem (groupItems' "Qtr3");  	AddGroupItem (groupItems' "Qtr4");  	items += 4;  	break;  case eDateGroupBy.Years:  	if (StartDate.Year >= 1900 && EndDate != DateTime.MaxValue) {  		for (int year = StartDate.Year; year <= EndDate.Year; year++) {  			AddGroupItem (groupItems' year.ToString ());  		}  		items += EndDate.Year - StartDate.Year + 1;  	}  	break;  default:  	throw (new Exception ("unsupported grouping"));  }  
Magic Number,OfficeOpenXml.Table.PivotTable,ExcelPivotTableField,C:\repos\bambit_EPPlus\EPPlus\Table\PivotTable\ExcelPivotTableField.cs,AddDateGroupItems,The following statement contains a magic number: switch (GroupBy) {  case eDateGroupBy.Seconds:  case eDateGroupBy.Minutes:  	AddTimeSerie (60' groupItems);  	items += 60;  	break;  case eDateGroupBy.Hours:  	AddTimeSerie (24' groupItems);  	items += 24;  	break;  case eDateGroupBy.Days:  	if (interval == 1) {  		DateTime dt = new DateTime (2008' 1' 1);  		//pick a year with 366 days  		while (dt.Year == 2008) {  			AddGroupItem (groupItems' dt.ToString ("dd-MMM"));  			dt = dt.AddDays (1);  		}  		items += 366;  	}  	else {  		DateTime dt = StartDate;  		items = 0;  		while (dt < EndDate) {  			AddGroupItem (groupItems' dt.ToString ("dd-MMM"));  			dt = dt.AddDays (interval);  			items++;  		}  	}  	break;  case eDateGroupBy.Months:  	AddGroupItem (groupItems' "jan");  	AddGroupItem (groupItems' "feb");  	AddGroupItem (groupItems' "mar");  	AddGroupItem (groupItems' "apr");  	AddGroupItem (groupItems' "may");  	AddGroupItem (groupItems' "jun");  	AddGroupItem (groupItems' "jul");  	AddGroupItem (groupItems' "aug");  	AddGroupItem (groupItems' "sep");  	AddGroupItem (groupItems' "oct");  	AddGroupItem (groupItems' "nov");  	AddGroupItem (groupItems' "dec");  	items += 12;  	break;  case eDateGroupBy.Quarters:  	AddGroupItem (groupItems' "Qtr1");  	AddGroupItem (groupItems' "Qtr2");  	AddGroupItem (groupItems' "Qtr3");  	AddGroupItem (groupItems' "Qtr4");  	items += 4;  	break;  case eDateGroupBy.Years:  	if (StartDate.Year >= 1900 && EndDate != DateTime.MaxValue) {  		for (int year = StartDate.Year; year <= EndDate.Year; year++) {  			AddGroupItem (groupItems' year.ToString ());  		}  		items += EndDate.Year - StartDate.Year + 1;  	}  	break;  default:  	throw (new Exception ("unsupported grouping"));  }  
Magic Number,OfficeOpenXml.Table.PivotTable,ExcelPivotTableField,C:\repos\bambit_EPPlus\EPPlus\Table\PivotTable\ExcelPivotTableField.cs,AddDateGroupItems,The following statement contains a magic number: switch (GroupBy) {  case eDateGroupBy.Seconds:  case eDateGroupBy.Minutes:  	AddTimeSerie (60' groupItems);  	items += 60;  	break;  case eDateGroupBy.Hours:  	AddTimeSerie (24' groupItems);  	items += 24;  	break;  case eDateGroupBy.Days:  	if (interval == 1) {  		DateTime dt = new DateTime (2008' 1' 1);  		//pick a year with 366 days  		while (dt.Year == 2008) {  			AddGroupItem (groupItems' dt.ToString ("dd-MMM"));  			dt = dt.AddDays (1);  		}  		items += 366;  	}  	else {  		DateTime dt = StartDate;  		items = 0;  		while (dt < EndDate) {  			AddGroupItem (groupItems' dt.ToString ("dd-MMM"));  			dt = dt.AddDays (interval);  			items++;  		}  	}  	break;  case eDateGroupBy.Months:  	AddGroupItem (groupItems' "jan");  	AddGroupItem (groupItems' "feb");  	AddGroupItem (groupItems' "mar");  	AddGroupItem (groupItems' "apr");  	AddGroupItem (groupItems' "may");  	AddGroupItem (groupItems' "jun");  	AddGroupItem (groupItems' "jul");  	AddGroupItem (groupItems' "aug");  	AddGroupItem (groupItems' "sep");  	AddGroupItem (groupItems' "oct");  	AddGroupItem (groupItems' "nov");  	AddGroupItem (groupItems' "dec");  	items += 12;  	break;  case eDateGroupBy.Quarters:  	AddGroupItem (groupItems' "Qtr1");  	AddGroupItem (groupItems' "Qtr2");  	AddGroupItem (groupItems' "Qtr3");  	AddGroupItem (groupItems' "Qtr4");  	items += 4;  	break;  case eDateGroupBy.Years:  	if (StartDate.Year >= 1900 && EndDate != DateTime.MaxValue) {  		for (int year = StartDate.Year; year <= EndDate.Year; year++) {  			AddGroupItem (groupItems' year.ToString ());  		}  		items += EndDate.Year - StartDate.Year + 1;  	}  	break;  default:  	throw (new Exception ("unsupported grouping"));  }  
Magic Number,OfficeOpenXml.Table.PivotTable,ExcelPivotTableField,C:\repos\bambit_EPPlus\EPPlus\Table\PivotTable\ExcelPivotTableField.cs,AddDateGroupItems,The following statement contains a magic number: switch (GroupBy) {  case eDateGroupBy.Seconds:  case eDateGroupBy.Minutes:  	AddTimeSerie (60' groupItems);  	items += 60;  	break;  case eDateGroupBy.Hours:  	AddTimeSerie (24' groupItems);  	items += 24;  	break;  case eDateGroupBy.Days:  	if (interval == 1) {  		DateTime dt = new DateTime (2008' 1' 1);  		//pick a year with 366 days  		while (dt.Year == 2008) {  			AddGroupItem (groupItems' dt.ToString ("dd-MMM"));  			dt = dt.AddDays (1);  		}  		items += 366;  	}  	else {  		DateTime dt = StartDate;  		items = 0;  		while (dt < EndDate) {  			AddGroupItem (groupItems' dt.ToString ("dd-MMM"));  			dt = dt.AddDays (interval);  			items++;  		}  	}  	break;  case eDateGroupBy.Months:  	AddGroupItem (groupItems' "jan");  	AddGroupItem (groupItems' "feb");  	AddGroupItem (groupItems' "mar");  	AddGroupItem (groupItems' "apr");  	AddGroupItem (groupItems' "may");  	AddGroupItem (groupItems' "jun");  	AddGroupItem (groupItems' "jul");  	AddGroupItem (groupItems' "aug");  	AddGroupItem (groupItems' "sep");  	AddGroupItem (groupItems' "oct");  	AddGroupItem (groupItems' "nov");  	AddGroupItem (groupItems' "dec");  	items += 12;  	break;  case eDateGroupBy.Quarters:  	AddGroupItem (groupItems' "Qtr1");  	AddGroupItem (groupItems' "Qtr2");  	AddGroupItem (groupItems' "Qtr3");  	AddGroupItem (groupItems' "Qtr4");  	items += 4;  	break;  case eDateGroupBy.Years:  	if (StartDate.Year >= 1900 && EndDate != DateTime.MaxValue) {  		for (int year = StartDate.Year; year <= EndDate.Year; year++) {  			AddGroupItem (groupItems' year.ToString ());  		}  		items += EndDate.Year - StartDate.Year + 1;  	}  	break;  default:  	throw (new Exception ("unsupported grouping"));  }  
Magic Number,OfficeOpenXml.Table.PivotTable,ExcelPivotTableField,C:\repos\bambit_EPPlus\EPPlus\Table\PivotTable\ExcelPivotTableField.cs,AddDateGroupItems,The following statement contains a magic number: switch (GroupBy) {  case eDateGroupBy.Seconds:  case eDateGroupBy.Minutes:  	AddTimeSerie (60' groupItems);  	items += 60;  	break;  case eDateGroupBy.Hours:  	AddTimeSerie (24' groupItems);  	items += 24;  	break;  case eDateGroupBy.Days:  	if (interval == 1) {  		DateTime dt = new DateTime (2008' 1' 1);  		//pick a year with 366 days  		while (dt.Year == 2008) {  			AddGroupItem (groupItems' dt.ToString ("dd-MMM"));  			dt = dt.AddDays (1);  		}  		items += 366;  	}  	else {  		DateTime dt = StartDate;  		items = 0;  		while (dt < EndDate) {  			AddGroupItem (groupItems' dt.ToString ("dd-MMM"));  			dt = dt.AddDays (interval);  			items++;  		}  	}  	break;  case eDateGroupBy.Months:  	AddGroupItem (groupItems' "jan");  	AddGroupItem (groupItems' "feb");  	AddGroupItem (groupItems' "mar");  	AddGroupItem (groupItems' "apr");  	AddGroupItem (groupItems' "may");  	AddGroupItem (groupItems' "jun");  	AddGroupItem (groupItems' "jul");  	AddGroupItem (groupItems' "aug");  	AddGroupItem (groupItems' "sep");  	AddGroupItem (groupItems' "oct");  	AddGroupItem (groupItems' "nov");  	AddGroupItem (groupItems' "dec");  	items += 12;  	break;  case eDateGroupBy.Quarters:  	AddGroupItem (groupItems' "Qtr1");  	AddGroupItem (groupItems' "Qtr2");  	AddGroupItem (groupItems' "Qtr3");  	AddGroupItem (groupItems' "Qtr4");  	items += 4;  	break;  case eDateGroupBy.Years:  	if (StartDate.Year >= 1900 && EndDate != DateTime.MaxValue) {  		for (int year = StartDate.Year; year <= EndDate.Year; year++) {  			AddGroupItem (groupItems' year.ToString ());  		}  		items += EndDate.Year - StartDate.Year + 1;  	}  	break;  default:  	throw (new Exception ("unsupported grouping"));  }  
Magic Number,OfficeOpenXml.Table.PivotTable,ExcelPivotTableField,C:\repos\bambit_EPPlus\EPPlus\Table\PivotTable\ExcelPivotTableField.cs,AddDateGroupItems,The following statement contains a magic number: switch (GroupBy) {  case eDateGroupBy.Seconds:  case eDateGroupBy.Minutes:  	AddTimeSerie (60' groupItems);  	items += 60;  	break;  case eDateGroupBy.Hours:  	AddTimeSerie (24' groupItems);  	items += 24;  	break;  case eDateGroupBy.Days:  	if (interval == 1) {  		DateTime dt = new DateTime (2008' 1' 1);  		//pick a year with 366 days  		while (dt.Year == 2008) {  			AddGroupItem (groupItems' dt.ToString ("dd-MMM"));  			dt = dt.AddDays (1);  		}  		items += 366;  	}  	else {  		DateTime dt = StartDate;  		items = 0;  		while (dt < EndDate) {  			AddGroupItem (groupItems' dt.ToString ("dd-MMM"));  			dt = dt.AddDays (interval);  			items++;  		}  	}  	break;  case eDateGroupBy.Months:  	AddGroupItem (groupItems' "jan");  	AddGroupItem (groupItems' "feb");  	AddGroupItem (groupItems' "mar");  	AddGroupItem (groupItems' "apr");  	AddGroupItem (groupItems' "may");  	AddGroupItem (groupItems' "jun");  	AddGroupItem (groupItems' "jul");  	AddGroupItem (groupItems' "aug");  	AddGroupItem (groupItems' "sep");  	AddGroupItem (groupItems' "oct");  	AddGroupItem (groupItems' "nov");  	AddGroupItem (groupItems' "dec");  	items += 12;  	break;  case eDateGroupBy.Quarters:  	AddGroupItem (groupItems' "Qtr1");  	AddGroupItem (groupItems' "Qtr2");  	AddGroupItem (groupItems' "Qtr3");  	AddGroupItem (groupItems' "Qtr4");  	items += 4;  	break;  case eDateGroupBy.Years:  	if (StartDate.Year >= 1900 && EndDate != DateTime.MaxValue) {  		for (int year = StartDate.Year; year <= EndDate.Year; year++) {  			AddGroupItem (groupItems' year.ToString ());  		}  		items += EndDate.Year - StartDate.Year + 1;  	}  	break;  default:  	throw (new Exception ("unsupported grouping"));  }  
Magic Number,OfficeOpenXml.Table.PivotTable,ExcelPivotTableField,C:\repos\bambit_EPPlus\EPPlus\Table\PivotTable\ExcelPivotTableField.cs,AddDateGroupItems,The following statement contains a magic number: switch (GroupBy) {  case eDateGroupBy.Seconds:  case eDateGroupBy.Minutes:  	AddTimeSerie (60' groupItems);  	items += 60;  	break;  case eDateGroupBy.Hours:  	AddTimeSerie (24' groupItems);  	items += 24;  	break;  case eDateGroupBy.Days:  	if (interval == 1) {  		DateTime dt = new DateTime (2008' 1' 1);  		//pick a year with 366 days  		while (dt.Year == 2008) {  			AddGroupItem (groupItems' dt.ToString ("dd-MMM"));  			dt = dt.AddDays (1);  		}  		items += 366;  	}  	else {  		DateTime dt = StartDate;  		items = 0;  		while (dt < EndDate) {  			AddGroupItem (groupItems' dt.ToString ("dd-MMM"));  			dt = dt.AddDays (interval);  			items++;  		}  	}  	break;  case eDateGroupBy.Months:  	AddGroupItem (groupItems' "jan");  	AddGroupItem (groupItems' "feb");  	AddGroupItem (groupItems' "mar");  	AddGroupItem (groupItems' "apr");  	AddGroupItem (groupItems' "may");  	AddGroupItem (groupItems' "jun");  	AddGroupItem (groupItems' "jul");  	AddGroupItem (groupItems' "aug");  	AddGroupItem (groupItems' "sep");  	AddGroupItem (groupItems' "oct");  	AddGroupItem (groupItems' "nov");  	AddGroupItem (groupItems' "dec");  	items += 12;  	break;  case eDateGroupBy.Quarters:  	AddGroupItem (groupItems' "Qtr1");  	AddGroupItem (groupItems' "Qtr2");  	AddGroupItem (groupItems' "Qtr3");  	AddGroupItem (groupItems' "Qtr4");  	items += 4;  	break;  case eDateGroupBy.Years:  	if (StartDate.Year >= 1900 && EndDate != DateTime.MaxValue) {  		for (int year = StartDate.Year; year <= EndDate.Year; year++) {  			AddGroupItem (groupItems' year.ToString ());  		}  		items += EndDate.Year - StartDate.Year + 1;  	}  	break;  default:  	throw (new Exception ("unsupported grouping"));  }  
Magic Number,OfficeOpenXml.Table.PivotTable,ExcelPivotTableField,C:\repos\bambit_EPPlus\EPPlus\Table\PivotTable\ExcelPivotTableField.cs,AddDateGroupItems,The following statement contains a magic number: switch (GroupBy) {  case eDateGroupBy.Seconds:  case eDateGroupBy.Minutes:  	AddTimeSerie (60' groupItems);  	items += 60;  	break;  case eDateGroupBy.Hours:  	AddTimeSerie (24' groupItems);  	items += 24;  	break;  case eDateGroupBy.Days:  	if (interval == 1) {  		DateTime dt = new DateTime (2008' 1' 1);  		//pick a year with 366 days  		while (dt.Year == 2008) {  			AddGroupItem (groupItems' dt.ToString ("dd-MMM"));  			dt = dt.AddDays (1);  		}  		items += 366;  	}  	else {  		DateTime dt = StartDate;  		items = 0;  		while (dt < EndDate) {  			AddGroupItem (groupItems' dt.ToString ("dd-MMM"));  			dt = dt.AddDays (interval);  			items++;  		}  	}  	break;  case eDateGroupBy.Months:  	AddGroupItem (groupItems' "jan");  	AddGroupItem (groupItems' "feb");  	AddGroupItem (groupItems' "mar");  	AddGroupItem (groupItems' "apr");  	AddGroupItem (groupItems' "may");  	AddGroupItem (groupItems' "jun");  	AddGroupItem (groupItems' "jul");  	AddGroupItem (groupItems' "aug");  	AddGroupItem (groupItems' "sep");  	AddGroupItem (groupItems' "oct");  	AddGroupItem (groupItems' "nov");  	AddGroupItem (groupItems' "dec");  	items += 12;  	break;  case eDateGroupBy.Quarters:  	AddGroupItem (groupItems' "Qtr1");  	AddGroupItem (groupItems' "Qtr2");  	AddGroupItem (groupItems' "Qtr3");  	AddGroupItem (groupItems' "Qtr4");  	items += 4;  	break;  case eDateGroupBy.Years:  	if (StartDate.Year >= 1900 && EndDate != DateTime.MaxValue) {  		for (int year = StartDate.Year; year <= EndDate.Year; year++) {  			AddGroupItem (groupItems' year.ToString ());  		}  		items += EndDate.Year - StartDate.Year + 1;  	}  	break;  default:  	throw (new Exception ("unsupported grouping"));  }  
Magic Number,OfficeOpenXml.Table.PivotTable,ExcelPivotTableField,C:\repos\bambit_EPPlus\EPPlus\Table\PivotTable\ExcelPivotTableField.cs,AddDateGroupItems,The following statement contains a magic number: switch (GroupBy) {  case eDateGroupBy.Seconds:  case eDateGroupBy.Minutes:  	AddTimeSerie (60' groupItems);  	items += 60;  	break;  case eDateGroupBy.Hours:  	AddTimeSerie (24' groupItems);  	items += 24;  	break;  case eDateGroupBy.Days:  	if (interval == 1) {  		DateTime dt = new DateTime (2008' 1' 1);  		//pick a year with 366 days  		while (dt.Year == 2008) {  			AddGroupItem (groupItems' dt.ToString ("dd-MMM"));  			dt = dt.AddDays (1);  		}  		items += 366;  	}  	else {  		DateTime dt = StartDate;  		items = 0;  		while (dt < EndDate) {  			AddGroupItem (groupItems' dt.ToString ("dd-MMM"));  			dt = dt.AddDays (interval);  			items++;  		}  	}  	break;  case eDateGroupBy.Months:  	AddGroupItem (groupItems' "jan");  	AddGroupItem (groupItems' "feb");  	AddGroupItem (groupItems' "mar");  	AddGroupItem (groupItems' "apr");  	AddGroupItem (groupItems' "may");  	AddGroupItem (groupItems' "jun");  	AddGroupItem (groupItems' "jul");  	AddGroupItem (groupItems' "aug");  	AddGroupItem (groupItems' "sep");  	AddGroupItem (groupItems' "oct");  	AddGroupItem (groupItems' "nov");  	AddGroupItem (groupItems' "dec");  	items += 12;  	break;  case eDateGroupBy.Quarters:  	AddGroupItem (groupItems' "Qtr1");  	AddGroupItem (groupItems' "Qtr2");  	AddGroupItem (groupItems' "Qtr3");  	AddGroupItem (groupItems' "Qtr4");  	items += 4;  	break;  case eDateGroupBy.Years:  	if (StartDate.Year >= 1900 && EndDate != DateTime.MaxValue) {  		for (int year = StartDate.Year; year <= EndDate.Year; year++) {  			AddGroupItem (groupItems' year.ToString ());  		}  		items += EndDate.Year - StartDate.Year + 1;  	}  	break;  default:  	throw (new Exception ("unsupported grouping"));  }  
Magic Number,OfficeOpenXml.Table.PivotTable,ExcelPivotTableField,C:\repos\bambit_EPPlus\EPPlus\Table\PivotTable\ExcelPivotTableField.cs,AddDateGroupItems,The following statement contains a magic number: AddTimeSerie (60' groupItems);  
Magic Number,OfficeOpenXml.Table.PivotTable,ExcelPivotTableField,C:\repos\bambit_EPPlus\EPPlus\Table\PivotTable\ExcelPivotTableField.cs,AddDateGroupItems,The following statement contains a magic number: items += 60;  
Magic Number,OfficeOpenXml.Table.PivotTable,ExcelPivotTableField,C:\repos\bambit_EPPlus\EPPlus\Table\PivotTable\ExcelPivotTableField.cs,AddDateGroupItems,The following statement contains a magic number: AddTimeSerie (24' groupItems);  
Magic Number,OfficeOpenXml.Table.PivotTable,ExcelPivotTableField,C:\repos\bambit_EPPlus\EPPlus\Table\PivotTable\ExcelPivotTableField.cs,AddDateGroupItems,The following statement contains a magic number: items += 24;  
Magic Number,OfficeOpenXml.Table.PivotTable,ExcelPivotTableField,C:\repos\bambit_EPPlus\EPPlus\Table\PivotTable\ExcelPivotTableField.cs,AddDateGroupItems,The following statement contains a magic number: if (interval == 1) {  	DateTime dt = new DateTime (2008' 1' 1);  	//pick a year with 366 days  	while (dt.Year == 2008) {  		AddGroupItem (groupItems' dt.ToString ("dd-MMM"));  		dt = dt.AddDays (1);  	}  	items += 366;  }  else {  	DateTime dt = StartDate;  	items = 0;  	while (dt < EndDate) {  		AddGroupItem (groupItems' dt.ToString ("dd-MMM"));  		dt = dt.AddDays (interval);  		items++;  	}  }  
Magic Number,OfficeOpenXml.Table.PivotTable,ExcelPivotTableField,C:\repos\bambit_EPPlus\EPPlus\Table\PivotTable\ExcelPivotTableField.cs,AddDateGroupItems,The following statement contains a magic number: if (interval == 1) {  	DateTime dt = new DateTime (2008' 1' 1);  	//pick a year with 366 days  	while (dt.Year == 2008) {  		AddGroupItem (groupItems' dt.ToString ("dd-MMM"));  		dt = dt.AddDays (1);  	}  	items += 366;  }  else {  	DateTime dt = StartDate;  	items = 0;  	while (dt < EndDate) {  		AddGroupItem (groupItems' dt.ToString ("dd-MMM"));  		dt = dt.AddDays (interval);  		items++;  	}  }  
Magic Number,OfficeOpenXml.Table.PivotTable,ExcelPivotTableField,C:\repos\bambit_EPPlus\EPPlus\Table\PivotTable\ExcelPivotTableField.cs,AddDateGroupItems,The following statement contains a magic number: if (interval == 1) {  	DateTime dt = new DateTime (2008' 1' 1);  	//pick a year with 366 days  	while (dt.Year == 2008) {  		AddGroupItem (groupItems' dt.ToString ("dd-MMM"));  		dt = dt.AddDays (1);  	}  	items += 366;  }  else {  	DateTime dt = StartDate;  	items = 0;  	while (dt < EndDate) {  		AddGroupItem (groupItems' dt.ToString ("dd-MMM"));  		dt = dt.AddDays (interval);  		items++;  	}  }  
Magic Number,OfficeOpenXml.Table.PivotTable,ExcelPivotTableField,C:\repos\bambit_EPPlus\EPPlus\Table\PivotTable\ExcelPivotTableField.cs,AddDateGroupItems,The following statement contains a magic number: while (dt.Year == 2008) {  	AddGroupItem (groupItems' dt.ToString ("dd-MMM"));  	dt = dt.AddDays (1);  }  
Magic Number,OfficeOpenXml.Table.PivotTable,ExcelPivotTableField,C:\repos\bambit_EPPlus\EPPlus\Table\PivotTable\ExcelPivotTableField.cs,AddDateGroupItems,The following statement contains a magic number: items += 366;  
Magic Number,OfficeOpenXml.Table.PivotTable,ExcelPivotTableField,C:\repos\bambit_EPPlus\EPPlus\Table\PivotTable\ExcelPivotTableField.cs,AddDateGroupItems,The following statement contains a magic number: items += 12;  
Magic Number,OfficeOpenXml.Table.PivotTable,ExcelPivotTableField,C:\repos\bambit_EPPlus\EPPlus\Table\PivotTable\ExcelPivotTableField.cs,AddDateGroupItems,The following statement contains a magic number: items += 4;  
Magic Number,OfficeOpenXml.Table.PivotTable,ExcelPivotTableField,C:\repos\bambit_EPPlus\EPPlus\Table\PivotTable\ExcelPivotTableField.cs,AddDateGroupItems,The following statement contains a magic number: if (StartDate.Year >= 1900 && EndDate != DateTime.MaxValue) {  	for (int year = StartDate.Year; year <= EndDate.Year; year++) {  		AddGroupItem (groupItems' year.ToString ());  	}  	items += EndDate.Year - StartDate.Year + 1;  }  
Magic Number,OfficeOpenXml.Table.PivotTable,ExcelPivotTableField,C:\repos\bambit_EPPlus\EPPlus\Table\PivotTable\ExcelPivotTableField.cs,AddDateGroupItems,The following statement contains a magic number: AddGroupItem (groupItems' ">" + EndDate.ToString ("s"' CultureInfo.InvariantCulture).Substring (0' 10));  
Missing Default,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingOperatorType,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\ExcelConditionalFormattingOperatorType.cs,GetAttributeByType,The following switch statement is missing a default case: switch (type) {  case eExcelConditionalFormattingOperatorType.BeginsWith:  	return ExcelConditionalFormattingConstants.Operators.BeginsWith;  case eExcelConditionalFormattingOperatorType.Between:  	return ExcelConditionalFormattingConstants.Operators.Between;  case eExcelConditionalFormattingOperatorType.ContainsText:  	return ExcelConditionalFormattingConstants.Operators.ContainsText;  case eExcelConditionalFormattingOperatorType.EndsWith:  	return ExcelConditionalFormattingConstants.Operators.EndsWith;  case eExcelConditionalFormattingOperatorType.Equal:  	return ExcelConditionalFormattingConstants.Operators.Equal;  case eExcelConditionalFormattingOperatorType.GreaterThan:  	return ExcelConditionalFormattingConstants.Operators.GreaterThan;  case eExcelConditionalFormattingOperatorType.GreaterThanOrEqual:  	return ExcelConditionalFormattingConstants.Operators.GreaterThanOrEqual;  case eExcelConditionalFormattingOperatorType.LessThan:  	return ExcelConditionalFormattingConstants.Operators.LessThan;  case eExcelConditionalFormattingOperatorType.LessThanOrEqual:  	return ExcelConditionalFormattingConstants.Operators.LessThanOrEqual;  case eExcelConditionalFormattingOperatorType.NotBetween:  	return ExcelConditionalFormattingConstants.Operators.NotBetween;  case eExcelConditionalFormattingOperatorType.NotContains:  	return ExcelConditionalFormattingConstants.Operators.NotContains;  case eExcelConditionalFormattingOperatorType.NotEqual:  	return ExcelConditionalFormattingConstants.Operators.NotEqual;  }  
Missing Default,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingOperatorType,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\ExcelConditionalFormattingOperatorType.cs,GetTypeByAttribute,The following switch statement is missing a default case: switch (attribute) {  case ExcelConditionalFormattingConstants.Operators.BeginsWith:  	return eExcelConditionalFormattingOperatorType.BeginsWith;  case ExcelConditionalFormattingConstants.Operators.Between:  	return eExcelConditionalFormattingOperatorType.Between;  case ExcelConditionalFormattingConstants.Operators.ContainsText:  	return eExcelConditionalFormattingOperatorType.ContainsText;  case ExcelConditionalFormattingConstants.Operators.EndsWith:  	return eExcelConditionalFormattingOperatorType.EndsWith;  case ExcelConditionalFormattingConstants.Operators.Equal:  	return eExcelConditionalFormattingOperatorType.Equal;  case ExcelConditionalFormattingConstants.Operators.GreaterThan:  	return eExcelConditionalFormattingOperatorType.GreaterThan;  case ExcelConditionalFormattingConstants.Operators.GreaterThanOrEqual:  	return eExcelConditionalFormattingOperatorType.GreaterThanOrEqual;  case ExcelConditionalFormattingConstants.Operators.LessThan:  	return eExcelConditionalFormattingOperatorType.LessThan;  case ExcelConditionalFormattingConstants.Operators.LessThanOrEqual:  	return eExcelConditionalFormattingOperatorType.LessThanOrEqual;  case ExcelConditionalFormattingConstants.Operators.NotBetween:  	return eExcelConditionalFormattingOperatorType.NotBetween;  case ExcelConditionalFormattingConstants.Operators.NotContains:  	return eExcelConditionalFormattingOperatorType.NotContains;  case ExcelConditionalFormattingConstants.Operators.NotEqual:  	return eExcelConditionalFormattingOperatorType.NotEqual;  }  
Missing Default,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingRuleFactory,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\ExcelConditionalFormattingRuleFactory.cs,Create,The following switch statement is missing a default case: switch (type) {  case eExcelConditionalFormattingRuleType.AboveAverage:  	return new ExcelConditionalFormattingAboveAverage (address' priority' worksheet' itemElementNode);  case eExcelConditionalFormattingRuleType.AboveOrEqualAverage:  	return new ExcelConditionalFormattingAboveOrEqualAverage (address' priority' worksheet' itemElementNode);  case eExcelConditionalFormattingRuleType.BelowAverage:  	return new ExcelConditionalFormattingBelowAverage (address' priority' worksheet' itemElementNode);  case eExcelConditionalFormattingRuleType.BelowOrEqualAverage:  	return new ExcelConditionalFormattingBelowOrEqualAverage (address' priority' worksheet' itemElementNode);  case eExcelConditionalFormattingRuleType.AboveStdDev:  	return new ExcelConditionalFormattingAboveStdDev (address' priority' worksheet' itemElementNode);  case eExcelConditionalFormattingRuleType.BelowStdDev:  	return new ExcelConditionalFormattingBelowStdDev (address' priority' worksheet' itemElementNode);  case eExcelConditionalFormattingRuleType.Bottom:  	return new ExcelConditionalFormattingBottom (address' priority' worksheet' itemElementNode);  case eExcelConditionalFormattingRuleType.BottomPercent:  	return new ExcelConditionalFormattingBottomPercent (address' priority' worksheet' itemElementNode);  case eExcelConditionalFormattingRuleType.Top:  	return new ExcelConditionalFormattingTop (address' priority' worksheet' itemElementNode);  case eExcelConditionalFormattingRuleType.TopPercent:  	return new ExcelConditionalFormattingTopPercent (address' priority' worksheet' itemElementNode);  case eExcelConditionalFormattingRuleType.Last7Days:  	return new ExcelConditionalFormattingLast7Days (address' priority' worksheet' itemElementNode);  case eExcelConditionalFormattingRuleType.LastMonth:  	return new ExcelConditionalFormattingLastMonth (address' priority' worksheet' itemElementNode);  case eExcelConditionalFormattingRuleType.LastWeek:  	return new ExcelConditionalFormattingLastWeek (address' priority' worksheet' itemElementNode);  case eExcelConditionalFormattingRuleType.NextMonth:  	return new ExcelConditionalFormattingNextMonth (address' priority' worksheet' itemElementNode);  case eExcelConditionalFormattingRuleType.NextWeek:  	return new ExcelConditionalFormattingNextWeek (address' priority' worksheet' itemElementNode);  case eExcelConditionalFormattingRuleType.ThisMonth:  	return new ExcelConditionalFormattingThisMonth (address' priority' worksheet' itemElementNode);  case eExcelConditionalFormattingRuleType.ThisWeek:  	return new ExcelConditionalFormattingThisWeek (address' priority' worksheet' itemElementNode);  case eExcelConditionalFormattingRuleType.Today:  	return new ExcelConditionalFormattingToday (address' priority' worksheet' itemElementNode);  case eExcelConditionalFormattingRuleType.Tomorrow:  	return new ExcelConditionalFormattingTomorrow (address' priority' worksheet' itemElementNode);  case eExcelConditionalFormattingRuleType.Yesterday:  	return new ExcelConditionalFormattingYesterday (address' priority' worksheet' itemElementNode);  case eExcelConditionalFormattingRuleType.BeginsWith:  	return new ExcelConditionalFormattingBeginsWith (address' priority' worksheet' itemElementNode);  case eExcelConditionalFormattingRuleType.Between:  	return new ExcelConditionalFormattingBetween (address' priority' worksheet' itemElementNode);  case eExcelConditionalFormattingRuleType.ContainsBlanks:  	return new ExcelConditionalFormattingContainsBlanks (address' priority' worksheet' itemElementNode);  case eExcelConditionalFormattingRuleType.ContainsErrors:  	return new ExcelConditionalFormattingContainsErrors (address' priority' worksheet' itemElementNode);  case eExcelConditionalFormattingRuleType.ContainsText:  	return new ExcelConditionalFormattingContainsText (address' priority' worksheet' itemElementNode);  case eExcelConditionalFormattingRuleType.DuplicateValues:  	return new ExcelConditionalFormattingDuplicateValues (address' priority' worksheet' itemElementNode);  case eExcelConditionalFormattingRuleType.EndsWith:  	return new ExcelConditionalFormattingEndsWith (address' priority' worksheet' itemElementNode);  case eExcelConditionalFormattingRuleType.Equal:  	return new ExcelConditionalFormattingEqual (address' priority' worksheet' itemElementNode);  case eExcelConditionalFormattingRuleType.Expression:  	return new ExcelConditionalFormattingExpression (address' priority' worksheet' itemElementNode);  case eExcelConditionalFormattingRuleType.GreaterThan:  	return new ExcelConditionalFormattingGreaterThan (address' priority' worksheet' itemElementNode);  case eExcelConditionalFormattingRuleType.GreaterThanOrEqual:  	return new ExcelConditionalFormattingGreaterThanOrEqual (address' priority' worksheet' itemElementNode);  case eExcelConditionalFormattingRuleType.LessThan:  	return new ExcelConditionalFormattingLessThan (address' priority' worksheet' itemElementNode);  case eExcelConditionalFormattingRuleType.LessThanOrEqual:  	return new ExcelConditionalFormattingLessThanOrEqual (address' priority' worksheet' itemElementNode);  case eExcelConditionalFormattingRuleType.NotBetween:  	return new ExcelConditionalFormattingNotBetween (address' priority' worksheet' itemElementNode);  case eExcelConditionalFormattingRuleType.NotContainsBlanks:  	return new ExcelConditionalFormattingNotContainsBlanks (address' priority' worksheet' itemElementNode);  case eExcelConditionalFormattingRuleType.NotContainsErrors:  	return new ExcelConditionalFormattingNotContainsErrors (address' priority' worksheet' itemElementNode);  case eExcelConditionalFormattingRuleType.NotContainsText:  	return new ExcelConditionalFormattingNotContainsText (address' priority' worksheet' itemElementNode);  case eExcelConditionalFormattingRuleType.NotEqual:  	return new ExcelConditionalFormattingNotEqual (address' priority' worksheet' itemElementNode);  case eExcelConditionalFormattingRuleType.UniqueValues:  	return new ExcelConditionalFormattingUniqueValues (address' priority' worksheet' itemElementNode);  case eExcelConditionalFormattingRuleType.ThreeColorScale:  	return new ExcelConditionalFormattingThreeColorScale (address' priority' worksheet' itemElementNode);  case eExcelConditionalFormattingRuleType.TwoColorScale:  	return new ExcelConditionalFormattingTwoColorScale (address' priority' worksheet' itemElementNode);  case eExcelConditionalFormattingRuleType.ThreeIconSet:  	return new ExcelConditionalFormattingThreeIconSet (address' priority' worksheet' itemElementNode' null);  case eExcelConditionalFormattingRuleType.FourIconSet:  	return new ExcelConditionalFormattingFourIconSet (address' priority' worksheet' itemElementNode' null);  case eExcelConditionalFormattingRuleType.FiveIconSet:  	return new ExcelConditionalFormattingFiveIconSet (address' priority' worksheet' itemElementNode' null);  case eExcelConditionalFormattingRuleType.DataBar:  	return new ExcelConditionalFormattingDataBar (eExcelConditionalFormattingRuleType.DataBar' address' priority' worksheet' itemElementNode' null);  //TODO: Add DataBar  }  
Missing Default,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingTimePeriodType,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\ExcelConditionalFormattingTimePeriodType.cs,GetAttributeByType,The following switch statement is missing a default case: switch (type) {  case eExcelConditionalFormattingTimePeriodType.Last7Days:  	return ExcelConditionalFormattingConstants.TimePeriods.Last7Days;  case eExcelConditionalFormattingTimePeriodType.LastMonth:  	return ExcelConditionalFormattingConstants.TimePeriods.LastMonth;  case eExcelConditionalFormattingTimePeriodType.LastWeek:  	return ExcelConditionalFormattingConstants.TimePeriods.LastWeek;  case eExcelConditionalFormattingTimePeriodType.NextMonth:  	return ExcelConditionalFormattingConstants.TimePeriods.NextMonth;  case eExcelConditionalFormattingTimePeriodType.NextWeek:  	return ExcelConditionalFormattingConstants.TimePeriods.NextWeek;  case eExcelConditionalFormattingTimePeriodType.ThisMonth:  	return ExcelConditionalFormattingConstants.TimePeriods.ThisMonth;  case eExcelConditionalFormattingTimePeriodType.ThisWeek:  	return ExcelConditionalFormattingConstants.TimePeriods.ThisWeek;  case eExcelConditionalFormattingTimePeriodType.Today:  	return ExcelConditionalFormattingConstants.TimePeriods.Today;  case eExcelConditionalFormattingTimePeriodType.Tomorrow:  	return ExcelConditionalFormattingConstants.TimePeriods.Tomorrow;  case eExcelConditionalFormattingTimePeriodType.Yesterday:  	return ExcelConditionalFormattingConstants.TimePeriods.Yesterday;  }  
Missing Default,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingTimePeriodType,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\ExcelConditionalFormattingTimePeriodType.cs,GetTypeByAttribute,The following switch statement is missing a default case: switch (attribute) {  case ExcelConditionalFormattingConstants.TimePeriods.Last7Days:  	return eExcelConditionalFormattingTimePeriodType.Last7Days;  case ExcelConditionalFormattingConstants.TimePeriods.LastMonth:  	return eExcelConditionalFormattingTimePeriodType.LastMonth;  case ExcelConditionalFormattingConstants.TimePeriods.LastWeek:  	return eExcelConditionalFormattingTimePeriodType.LastWeek;  case ExcelConditionalFormattingConstants.TimePeriods.NextMonth:  	return eExcelConditionalFormattingTimePeriodType.NextMonth;  case ExcelConditionalFormattingConstants.TimePeriods.NextWeek:  	return eExcelConditionalFormattingTimePeriodType.NextWeek;  case ExcelConditionalFormattingConstants.TimePeriods.ThisMonth:  	return eExcelConditionalFormattingTimePeriodType.ThisMonth;  case ExcelConditionalFormattingConstants.TimePeriods.ThisWeek:  	return eExcelConditionalFormattingTimePeriodType.ThisWeek;  case ExcelConditionalFormattingConstants.TimePeriods.Today:  	return eExcelConditionalFormattingTimePeriodType.Today;  case ExcelConditionalFormattingConstants.TimePeriods.Tomorrow:  	return eExcelConditionalFormattingTimePeriodType.Tomorrow;  case ExcelConditionalFormattingConstants.TimePeriods.Yesterday:  	return eExcelConditionalFormattingTimePeriodType.Yesterday;  }  
Missing Default,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingValueObjectType,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\ExcelConditionalFormattingValueObjectType.cs,GetOrderByPosition,The following switch statement is missing a default case: switch (position) {  case eExcelConditionalFormattingValueObjectPosition.Low:  	return 1;  case eExcelConditionalFormattingValueObjectPosition.Middle:  	return 2;  case eExcelConditionalFormattingValueObjectPosition.High:  	// Check if the rule type is TwoColorScale.  	if (ruleType == eExcelConditionalFormattingRuleType.TwoColorScale) {  		// There are only "Low" and "High". So "High" is the second  		return 2;  	}  	// There are "Low"' "Middle" and "High". So "High" is the third  	return 3;  }  
Missing Default,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingValueObjectType,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\ExcelConditionalFormattingValueObjectType.cs,GetTypeByAttrbiute,The following switch statement is missing a default case: switch (attribute) {  case ExcelConditionalFormattingConstants.CfvoType.Min:  	return eExcelConditionalFormattingValueObjectType.Min;  case ExcelConditionalFormattingConstants.CfvoType.Max:  	return eExcelConditionalFormattingValueObjectType.Max;  case ExcelConditionalFormattingConstants.CfvoType.Num:  	return eExcelConditionalFormattingValueObjectType.Num;  case ExcelConditionalFormattingConstants.CfvoType.Formula:  	return eExcelConditionalFormattingValueObjectType.Formula;  case ExcelConditionalFormattingConstants.CfvoType.Percent:  	return eExcelConditionalFormattingValueObjectType.Percent;  case ExcelConditionalFormattingConstants.CfvoType.Percentile:  	return eExcelConditionalFormattingValueObjectType.Percentile;  }  
Missing Default,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingValueObjectType,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\ExcelConditionalFormattingValueObjectType.cs,GetAttributeByType,The following switch statement is missing a default case: switch (type) {  case eExcelConditionalFormattingValueObjectType.Min:  	return ExcelConditionalFormattingConstants.CfvoType.Min;  case eExcelConditionalFormattingValueObjectType.Max:  	return ExcelConditionalFormattingConstants.CfvoType.Max;  case eExcelConditionalFormattingValueObjectType.Num:  	return ExcelConditionalFormattingConstants.CfvoType.Num;  case eExcelConditionalFormattingValueObjectType.Formula:  	return ExcelConditionalFormattingConstants.CfvoType.Formula;  case eExcelConditionalFormattingValueObjectType.Percent:  	return ExcelConditionalFormattingConstants.CfvoType.Percent;  case eExcelConditionalFormattingValueObjectType.Percentile:  	return ExcelConditionalFormattingConstants.CfvoType.Percentile;  }  
Missing Default,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingValueObjectType,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\ExcelConditionalFormattingValueObjectType.cs,GetParentPathByRuleType,The following switch statement is missing a default case: switch (ruleType) {  case eExcelConditionalFormattingRuleType.TwoColorScale:  case eExcelConditionalFormattingRuleType.ThreeColorScale:  	return ExcelConditionalFormattingConstants.Paths.ColorScale;  case eExcelConditionalFormattingRuleType.ThreeIconSet:  case eExcelConditionalFormattingRuleType.FourIconSet:  case eExcelConditionalFormattingRuleType.FiveIconSet:  	return ExcelConditionalFormattingConstants.Paths.IconSet;  case eExcelConditionalFormattingRuleType.DataBar:  	return ExcelConditionalFormattingConstants.Paths.DataBar;  }  
Missing Default,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingValueObjectType,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\ExcelConditionalFormattingValueObjectType.cs,GetNodePathByNodeType,The following switch statement is missing a default case: switch (nodeType) {  case eExcelConditionalFormattingValueObjectNodeType.Cfvo:  	return ExcelConditionalFormattingConstants.Paths.Cfvo;  case eExcelConditionalFormattingValueObjectNodeType.Color:  	return ExcelConditionalFormattingConstants.Paths.Color;  }  
Missing Default,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingRuleType,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\ExcelConditionalFormattingRuleType.cs,GetTypeByAttrbiute,The following switch statement is missing a default case: switch (attribute) {  case ExcelConditionalFormattingConstants.RuleType.AboveAverage:  	return GetAboveAverageType (topNode' nameSpaceManager);  case ExcelConditionalFormattingConstants.RuleType.Top10:  	return GetTop10Type (topNode' nameSpaceManager);  case ExcelConditionalFormattingConstants.RuleType.TimePeriod:  	return GetTimePeriodType (topNode' nameSpaceManager);  case ExcelConditionalFormattingConstants.RuleType.CellIs:  	return GetCellIs ((XmlElement)topNode);  case ExcelConditionalFormattingConstants.RuleType.BeginsWith:  	return eExcelConditionalFormattingRuleType.BeginsWith;  //case ExcelConditionalFormattingConstants.RuleType.Between:  //  return eExcelConditionalFormattingRuleType.Between;  case ExcelConditionalFormattingConstants.RuleType.ContainsBlanks:  	return eExcelConditionalFormattingRuleType.ContainsBlanks;  case ExcelConditionalFormattingConstants.RuleType.ContainsErrors:  	return eExcelConditionalFormattingRuleType.ContainsErrors;  case ExcelConditionalFormattingConstants.RuleType.ContainsText:  	return eExcelConditionalFormattingRuleType.ContainsText;  case ExcelConditionalFormattingConstants.RuleType.DuplicateValues:  	return eExcelConditionalFormattingRuleType.DuplicateValues;  case ExcelConditionalFormattingConstants.RuleType.EndsWith:  	return eExcelConditionalFormattingRuleType.EndsWith;  //case ExcelConditionalFormattingConstants.RuleType.Equal:  //  return eExcelConditionalFormattingRuleType.Equal;  case ExcelConditionalFormattingConstants.RuleType.Expression:  	return eExcelConditionalFormattingRuleType.Expression;  //case ExcelConditionalFormattingConstants.RuleType.GreaterThan:  //  return eExcelConditionalFormattingRuleType.GreaterThan;  //case ExcelConditionalFormattingConstants.RuleType.GreaterThanOrEqual:  //  return eExcelConditionalFormattingRuleType.GreaterThanOrEqual;  //case ExcelConditionalFormattingConstants.RuleType.LessThan:  //  return eExcelConditionalFormattingRuleType.LessThan;  //case ExcelConditionalFormattingConstants.RuleType.LessThanOrEqual:  //  return eExcelConditionalFormattingRuleType.LessThanOrEqual;  //case ExcelConditionalFormattingConstants.RuleType.NotBetween:  //  return eExcelConditionalFormattingRuleType.NotBetween;  case ExcelConditionalFormattingConstants.RuleType.NotContainsBlanks:  	return eExcelConditionalFormattingRuleType.NotContainsBlanks;  case ExcelConditionalFormattingConstants.RuleType.NotContainsErrors:  	return eExcelConditionalFormattingRuleType.NotContainsErrors;  case ExcelConditionalFormattingConstants.RuleType.NotContainsText:  	return eExcelConditionalFormattingRuleType.NotContainsText;  //case ExcelConditionalFormattingConstants.RuleType.NotEqual:  //  return eExcelConditionalFormattingRuleType.NotEqual;  case ExcelConditionalFormattingConstants.RuleType.UniqueValues:  	return eExcelConditionalFormattingRuleType.UniqueValues;  case ExcelConditionalFormattingConstants.RuleType.ColorScale:  	return GetColorScaleType (topNode' nameSpaceManager);  case ExcelConditionalFormattingConstants.RuleType.IconSet:  	return GetIconSetType (topNode' nameSpaceManager);  case ExcelConditionalFormattingConstants.RuleType.DataBar:  	return eExcelConditionalFormattingRuleType.DataBar;  }  
Missing Default,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingRuleType,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\ExcelConditionalFormattingRuleType.cs,GetTimePeriodType,The following switch statement is missing a default case: switch (timePeriod) {  case eExcelConditionalFormattingTimePeriodType.Last7Days:  	return eExcelConditionalFormattingRuleType.Last7Days;  case eExcelConditionalFormattingTimePeriodType.LastMonth:  	return eExcelConditionalFormattingRuleType.LastMonth;  case eExcelConditionalFormattingTimePeriodType.LastWeek:  	return eExcelConditionalFormattingRuleType.LastWeek;  case eExcelConditionalFormattingTimePeriodType.NextMonth:  	return eExcelConditionalFormattingRuleType.NextMonth;  case eExcelConditionalFormattingTimePeriodType.NextWeek:  	return eExcelConditionalFormattingRuleType.NextWeek;  case eExcelConditionalFormattingTimePeriodType.ThisMonth:  	return eExcelConditionalFormattingRuleType.ThisMonth;  case eExcelConditionalFormattingTimePeriodType.ThisWeek:  	return eExcelConditionalFormattingRuleType.ThisWeek;  case eExcelConditionalFormattingTimePeriodType.Today:  	return eExcelConditionalFormattingRuleType.Today;  case eExcelConditionalFormattingTimePeriodType.Tomorrow:  	return eExcelConditionalFormattingRuleType.Tomorrow;  case eExcelConditionalFormattingTimePeriodType.Yesterday:  	return eExcelConditionalFormattingRuleType.Yesterday;  }  
Missing Default,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingRuleType,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\ExcelConditionalFormattingRuleType.cs,GetAttributeByType,The following switch statement is missing a default case: switch (type) {  case eExcelConditionalFormattingRuleType.AboveAverage:  case eExcelConditionalFormattingRuleType.AboveOrEqualAverage:  case eExcelConditionalFormattingRuleType.BelowAverage:  case eExcelConditionalFormattingRuleType.BelowOrEqualAverage:  case eExcelConditionalFormattingRuleType.AboveStdDev:  case eExcelConditionalFormattingRuleType.BelowStdDev:  	return ExcelConditionalFormattingConstants.RuleType.AboveAverage;  case eExcelConditionalFormattingRuleType.Bottom:  case eExcelConditionalFormattingRuleType.BottomPercent:  case eExcelConditionalFormattingRuleType.Top:  case eExcelConditionalFormattingRuleType.TopPercent:  	return ExcelConditionalFormattingConstants.RuleType.Top10;  case eExcelConditionalFormattingRuleType.Last7Days:  case eExcelConditionalFormattingRuleType.LastMonth:  case eExcelConditionalFormattingRuleType.LastWeek:  case eExcelConditionalFormattingRuleType.NextMonth:  case eExcelConditionalFormattingRuleType.NextWeek:  case eExcelConditionalFormattingRuleType.ThisMonth:  case eExcelConditionalFormattingRuleType.ThisWeek:  case eExcelConditionalFormattingRuleType.Today:  case eExcelConditionalFormattingRuleType.Tomorrow:  case eExcelConditionalFormattingRuleType.Yesterday:  	return ExcelConditionalFormattingConstants.RuleType.TimePeriod;  case eExcelConditionalFormattingRuleType.Between:  case eExcelConditionalFormattingRuleType.Equal:  case eExcelConditionalFormattingRuleType.GreaterThan:  case eExcelConditionalFormattingRuleType.GreaterThanOrEqual:  case eExcelConditionalFormattingRuleType.LessThan:  case eExcelConditionalFormattingRuleType.LessThanOrEqual:  case eExcelConditionalFormattingRuleType.NotBetween:  case eExcelConditionalFormattingRuleType.NotEqual:  	return ExcelConditionalFormattingConstants.RuleType.CellIs;  case eExcelConditionalFormattingRuleType.ThreeIconSet:  case eExcelConditionalFormattingRuleType.FourIconSet:  case eExcelConditionalFormattingRuleType.FiveIconSet:  	return ExcelConditionalFormattingConstants.RuleType.IconSet;  case eExcelConditionalFormattingRuleType.ThreeColorScale:  case eExcelConditionalFormattingRuleType.TwoColorScale:  	return ExcelConditionalFormattingConstants.RuleType.ColorScale;  case eExcelConditionalFormattingRuleType.BeginsWith:  	return ExcelConditionalFormattingConstants.RuleType.BeginsWith;  case eExcelConditionalFormattingRuleType.ContainsBlanks:  	return ExcelConditionalFormattingConstants.RuleType.ContainsBlanks;  case eExcelConditionalFormattingRuleType.ContainsErrors:  	return ExcelConditionalFormattingConstants.RuleType.ContainsErrors;  case eExcelConditionalFormattingRuleType.ContainsText:  	return ExcelConditionalFormattingConstants.RuleType.ContainsText;  case eExcelConditionalFormattingRuleType.DuplicateValues:  	return ExcelConditionalFormattingConstants.RuleType.DuplicateValues;  case eExcelConditionalFormattingRuleType.EndsWith:  	return ExcelConditionalFormattingConstants.RuleType.EndsWith;  case eExcelConditionalFormattingRuleType.Expression:  	return ExcelConditionalFormattingConstants.RuleType.Expression;  case eExcelConditionalFormattingRuleType.NotContainsBlanks:  	return ExcelConditionalFormattingConstants.RuleType.NotContainsBlanks;  case eExcelConditionalFormattingRuleType.NotContainsErrors:  	return ExcelConditionalFormattingConstants.RuleType.NotContainsErrors;  case eExcelConditionalFormattingRuleType.NotContainsText:  	return ExcelConditionalFormattingConstants.RuleType.NotContainsText;  case eExcelConditionalFormattingRuleType.UniqueValues:  	return ExcelConditionalFormattingConstants.RuleType.UniqueValues;  case eExcelConditionalFormattingRuleType.DataBar:  	return ExcelConditionalFormattingConstants.RuleType.DataBar;  }  
Missing Default,OfficeOpenXml.ConditionalFormatting,ExcelConditionalFormattingRuleType,C:\repos\bambit_EPPlus\EPPlus\ConditionalFormatting\ExcelConditionalFormattingRuleType.cs,GetCfvoParentPathByType,The following switch statement is missing a default case: switch (type) {  case eExcelConditionalFormattingRuleType.TwoColorScale:  case eExcelConditionalFormattingRuleType.ThreeColorScale:  	return ExcelConditionalFormattingConstants.Paths.ColorScale;  case eExcelConditionalFormattingRuleType.ThreeIconSet:  case eExcelConditionalFormattingRuleType.FourIconSet:  case eExcelConditionalFormattingRuleType.FiveIconSet:  	return ExcelConditionalFormattingConstants.RuleType.IconSet;  case eExcelConditionalFormattingRuleType.DataBar:  	return ExcelConditionalFormattingConstants.RuleType.DataBar;  }  
Missing Default,OfficeOpenXml,XmlHelper,C:\repos\bambit_EPPlus\EPPlus\XmlHelper.cs,CreateComplexNode,The following switch statement is missing a default case: switch (nodeInsertOrder) {  case eNodeInsertOrder.After:  	node.InsertAfter (subNode' referenceNode);  	referenceNode = null;  	break;  case eNodeInsertOrder.Before:  	node.InsertBefore (subNode' referenceNode);  	referenceNode = null;  	break;  case eNodeInsertOrder.First:  	node.PrependChild (subNode);  	break;  case eNodeInsertOrder.Last:  	node.AppendChild (subNode);  	break;  }  
Missing Default,OfficeOpenXml.VBA,ExcelVbaProject,C:\repos\bambit_EPPlus\EPPlus\VBA\ExcelVbaProject.cs,ReadProjectProperties,The following switch statement is missing a default case: switch (split [0]) {  case "ID":  	ProjectID = split [1];  	break;  case "Document":  	string mn = split [1].Substring (0' split [1].IndexOf ("/&H"));  	Modules [mn].Type = eModuleType.Document;  	break;  case "Package":  	prevPackage = split [1];  	break;  case "BaseClass":  	Modules [split [1]].Type = eModuleType.Designer;  	Modules [split [1]].ClassID = prevPackage;  	break;  case "Module":  	Modules [split [1]].Type = eModuleType.Module;  	break;  case "Class":  	Modules [split [1]].Type = eModuleType.Class;  	break;  case "HelpFile":  case "Name":  case "HelpContextID":  case "Description":  case "VersionCompatible32":  	break;  //393222000"  case "CMG":  	byte[] cmg = Decrypt (split [1]);  	_protection.UserProtected = (cmg [0] & 1) != 0;  	_protection.HostProtected = (cmg [0] & 2) != 0;  	_protection.VbeProtected = (cmg [0] & 4) != 0;  	break;  case "DPB":  	byte[] dpb = Decrypt (split [1]);  	if (dpb.Length >= 28) {  		byte reserved = dpb [0];  		var flags = new byte[3];  		Array.Copy (dpb' 1' flags' 0' 3);  		var keyNoNulls = new byte[4];  		_protection.PasswordKey = new byte[4];  		Array.Copy (dpb' 4' keyNoNulls' 0' 4);  		var hashNoNulls = new byte[20];  		_protection.PasswordHash = new byte[20];  		Array.Copy (dpb' 8' hashNoNulls' 0' 20);  		//Handle 0x00 bitwise 2.4.4.3   		for (int i = 0; i < 24; i++) {  			int bit = 128 >> (int)((i % 8));  			if (i < 4) {  				if ((int)(flags [0] & bit) == 0) {  					_protection.PasswordKey [i] = 0;  				}  				else {  					_protection.PasswordKey [i] = keyNoNulls [i];  				}  			}  			else {  				int flagIndex = (i - i % 8) / 8;  				if ((int)(flags [flagIndex] & bit) == 0) {  					_protection.PasswordHash [i - 4] = 0;  				}  				else {  					_protection.PasswordHash [i - 4] = hashNoNulls [i - 4];  				}  			}  		}  	}  	break;  case "GC":  	_protection.VisibilityState = Decrypt (split [1]) [0] == 0xFF;  	break;  }  
Missing Default,OfficeOpenXml.Utils,EncryptedPackageHandler,C:\repos\bambit_EPPlus\EPPlus\Utils\EncryptedPackageHandler.cs,GetStreamFromPackage,The following switch statement is missing a default case: switch (statstg.pwcsName) {  case "EncryptionInfo":  	data = GetOleStream (storage' statstg);  	//File.WriteAllBytes(@"c:\temp\EncInfo1.bin"' data);  	encryptionInfo = new EncryptionInfo ();  	encryptionInfo.ReadBinary (data);  	encryption.Algorithm = encryptionInfo.Header.AlgID == AlgorithmID.AES128 ? EncryptionAlgorithm.AES128 : encryptionInfo.Header.AlgID == AlgorithmID.AES192 ? EncryptionAlgorithm.AES192 : EncryptionAlgorithm.AES256;  	break;  case "EncryptedPackage":  	data = GetOleStream (storage' statstg);  	ret = DecryptDocument (data' encryptionInfo' encryption.Password);  	break;  }  
Missing Default,OfficeOpenXml.Table.PivotTable,ExcelPivotTableRowColumnFieldCollection,C:\repos\bambit_EPPlus\EPPlus\Table\PivotTable\ExcelPivotTableFieldCollection.cs,SetFlag,The following switch statement is missing a default case: switch (_topNode) {  case "rowFields":  	if (field.IsColumnField || field.IsPageField) {  		throw (new Exception ("This field is a column or page field. Can't add it to the RowFields collection"));  	}  	field.IsRowField = value;  	field.Axis = ePivotFieldAxis.Row;  	break;  case "colFields":  	if (field.IsRowField || field.IsPageField) {  		throw (new Exception ("This field is a row or page field. Can't add it to the ColumnFields collection"));  	}  	field.IsColumnField = value;  	field.Axis = ePivotFieldAxis.Column;  	break;  case "pageFields":  	if (field.IsColumnField || field.IsRowField) {  		throw (new Exception ("Field is a column or row field. Can't add it to the PageFields collection"));  	}  	if (_table.Address._fromRow < 3) {  		throw (new Exception (string.Format ("A pivot table with page fields must be located above row 3. Currenct location is {0}"' _table.Address.Address)));  	}  	field.IsPageField = value;  	field.Axis = ePivotFieldAxis.Page;  	break;  case "dataFields":  	break;  }  
