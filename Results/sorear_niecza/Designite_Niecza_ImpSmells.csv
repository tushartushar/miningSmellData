Implementation smell,Namespace,Class,File,Method,Description
Long Method,Niecza,SubInfo,C:\repos\sorear_niecza\lib\Kernel.cs,Thaw,The method has 106 lines of code.
Long Method,Niecza,Frame,C:\repos\sorear_niecza\lib\Kernel.cs,BindSignature,The method has 248 lines of code.
Long Method,Niecza,StashCursor,C:\repos\sorear_niecza\lib\Kernel.cs,Core,The method has 160 lines of code.
Long Method,Niecza,Kernel,C:\repos\sorear_niecza\lib\Kernel.cs,CreateBasicTypes,The method has 181 lines of code.
Long Method,Niecza,CLRWrapperProvider,C:\repos\sorear_niecza\lib\NieczaCLR.cs,NewWrapper,The method has 101 lines of code.
Long Method,Niecza,CLRWrapperProvider,C:\repos\sorear_niecza\lib\NieczaCLR.cs,CoerceArgument,The method has 164 lines of code.
Complex Method,Niecza,BigInteger,C:\repos\sorear_niecza\lib\BigInteger.cs,BigInteger,Cyclomatic complexity of the method is 10
Complex Method,Niecza,BigInteger,C:\repos\sorear_niecza\lib\BigInteger.cs,ToString,Cyclomatic complexity of the method is 12
Complex Method,Niecza,BigInteger,C:\repos\sorear_niecza\lib\BigInteger.cs,Parse,Cyclomatic complexity of the method is 14
Complex Method,Niecza,BigInteger,C:\repos\sorear_niecza\lib\BigInteger.cs,DivRem,Cyclomatic complexity of the method is 8
Complex Method,Niecza,BigInteger,C:\repos\sorear_niecza\lib\BigInteger.cs,GreatestCommonDivisor,Cyclomatic complexity of the method is 12
Complex Method,Niecza,BigInteger,C:\repos\sorear_niecza\lib\BigInteger.cs,Log,Cyclomatic complexity of the method is 9
Complex Method,Niecza,Builtins,C:\repos\sorear_niecza\lib\Builtins.cs,minus,Cyclomatic complexity of the method is 8
Complex Method,Niecza,Builtins,C:\repos\sorear_niecza\lib\Builtins.cs,pow,Cyclomatic complexity of the method is 9
Complex Method,Niecza,Builtins,C:\repos\sorear_niecza\lib\Builtins.cs,floor,Cyclomatic complexity of the method is 11
Complex Method,Niecza,Builtins,C:\repos\sorear_niecza\lib\Builtins.cs,mod,Cyclomatic complexity of the method is 15
Complex Method,Niecza,EmitUnit,C:\repos\sorear_niecza\lib\Kernel.cs,ExactNum,Cyclomatic complexity of the method is 15
Complex Method,Niecza,EmitUnit,C:\repos\sorear_niecza\lib\Kernel.cs,NewField,Cyclomatic complexity of the method is 9
Complex Method,Niecza,RuntimeUnit,C:\repos\sorear_niecza\lib\Kernel.cs,Freeze,Cyclomatic complexity of the method is 8
Complex Method,Niecza,RuntimeUnit,C:\repos\sorear_niecza\lib\Kernel.cs,Thaw,Cyclomatic complexity of the method is 13
Complex Method,Niecza,SubInfo,C:\repos\sorear_niecza\lib\Kernel.cs,IsInlinable,Cyclomatic complexity of the method is 10
Complex Method,Niecza,SubInfo,C:\repos\sorear_niecza\lib\Kernel.cs,Thaw,Cyclomatic complexity of the method is 10
Complex Method,Niecza,SubInfo,C:\repos\sorear_niecza\lib\Kernel.cs,Fixup,Cyclomatic complexity of the method is 12
Complex Method,Niecza,Frame,C:\repos\sorear_niecza\lib\Kernel.cs,BindSignature,Cyclomatic complexity of the method is 37
Complex Method,Niecza,CtxStrSuccish,C:\repos\sorear_niecza\lib\Kernel.cs,Get,Cyclomatic complexity of the method is 10
Complex Method,Niecza,IxListAtPos,C:\repos\sorear_niecza\lib\Kernel.cs,Get,Cyclomatic complexity of the method is 8
Complex Method,Niecza,StashCursor,C:\repos\sorear_niecza\lib\Kernel.cs,Indirect,Cyclomatic complexity of the method is 9
Complex Method,Niecza,Kernel,C:\repos\sorear_niecza\lib\Kernel.cs,ApplyRoleToClass,Cyclomatic complexity of the method is 17
Complex Method,Niecza,Kernel,C:\repos\sorear_niecza\lib\Kernel.cs,SearchForHandler,Cyclomatic complexity of the method is 15
Complex Method,Niecza,Kernel,C:\repos\sorear_niecza\lib\Kernel.cs,Unwind,Cyclomatic complexity of the method is 14
Complex Method,Niecza,Kernel,C:\repos\sorear_niecza\lib\Kernel.cs,Main,Cyclomatic complexity of the method is 10
Complex Method,Niecza,MMDParameter,C:\repos\sorear_niecza\lib\Kernel.cs,IsNarrowerThan,Cyclomatic complexity of the method is 9
Complex Method,Niecza,MMDCandidate,C:\repos\sorear_niecza\lib\Kernel.cs,IsNarrowerThan,Cyclomatic complexity of the method is 10
Complex Method,Niecza,MMDCandidate,C:\repos\sorear_niecza\lib\Kernel.cs,ToString,Cyclomatic complexity of the method is 10
Complex Method,Niecza,CandidateSet,C:\repos\sorear_niecza\lib\NieczaCLR.cs,DoDispatch,Cyclomatic complexity of the method is 10
Complex Method,Niecza,CandidateSet,C:\repos\sorear_niecza\lib\NieczaCLR.cs,SortCandidates,Cyclomatic complexity of the method is 17
Complex Method,Niecza,OverloadCandidate,C:\repos\sorear_niecza\lib\NieczaCLR.cs,Compare,Cyclomatic complexity of the method is 10
Complex Method,Niecza,CLRWrapperProvider,C:\repos\sorear_niecza\lib\NieczaCLR.cs,NewWrapper,Cyclomatic complexity of the method is 23
Complex Method,Niecza,CLRWrapperProvider,C:\repos\sorear_niecza\lib\NieczaCLR.cs,BoxResult,Cyclomatic complexity of the method is 17
Complex Method,Niecza,P6how,C:\repos\sorear_niecza\lib\ObjModel.cs,CollectMMDs,Cyclomatic complexity of the method is 13
Complex Method,Niecza,P6how,C:\repos\sorear_niecza\lib\ObjModel.cs,Revalidate,Cyclomatic complexity of the method is 11
Complex Method,Niecza,P6how,C:\repos\sorear_niecza\lib\ObjModel.cs,AcceptsType,Cyclomatic complexity of the method is 12
Complex Method,Niecza,P6how,C:\repos\sorear_niecza\lib\ObjModel.cs,C3Merge,Cyclomatic complexity of the method is 11
Complex Method,Niecza,P6how,C:\repos\sorear_niecza\lib\ObjModel.cs,Compose,Cyclomatic complexity of the method is 15
Complex Method,Niecza,VarHash,C:\repos\sorear_niecza\lib\Utils.cs,Remove,Cyclomatic complexity of the method is 10
Long Parameter List,Niecza,Builtins,C:\repos\sorear_niecza\lib\Builtins.cs,CheckSpecialArg,The method has 5 parameters. Parameters: s' ix' pivot' rank' val
Long Parameter List,Niecza,Builtins,C:\repos\sorear_niecza\lib\Builtins.cs,HandleSpecial2,The method has 6 parameters. Parameters: c' av0' av1' ao0' ao1' dgt
Long Parameter List,Niecza,Builtins,C:\repos\sorear_niecza\lib\Builtins.cs,HandleSpecial3,The method has 8 parameters. Parameters: c' av0' av1' av2' ao0' ao1' ao2' dgt
Long Parameter List,Niecza,Builtins,C:\repos\sorear_niecza\lib\Builtins.cs,strcompare,The method has 5 parameters. Parameters: c' v1' v2' mask' d
Long Parameter List,Niecza,Builtins,C:\repos\sorear_niecza\lib\Builtins.cs,numcompare,The method has 5 parameters. Parameters: c' a1' a2' mask' dl
Long Parameter List,Niecza,Builtins,C:\repos\sorear_niecza\lib\Builtins.cs,numcompare_core,The method has 6 parameters. Parameters: s' a1' o1' a2' o2' complex_ok
Long Parameter List,Niecza,Builtins,C:\repos\sorear_niecza\lib\Builtins.cs,mixin,The method has 5 parameters. Parameters: c' obj' role_list' init' newtype
Long Parameter List,Niecza,EmitUnit,C:\repos\sorear_niecza\lib\Kernel.cs,EmitUnit,The method has 5 parameters. Parameters: s' uname' asm_name' dll_name' is_mainish
Long Parameter List,Niecza,RuntimeUnit,C:\repos\sorear_niecza\lib\Kernel.cs,RuntimeUnit,The method has 6 parameters. Parameters: setting' name' filename' source' main' runnow
Long Parameter List,Niecza,RuntimeUnit,C:\repos\sorear_niecza\lib\Kernel.cs,NsBind,The method has 5 parameters. Parameters: who' name' var' file' line
Long Parameter List,Niecza,Parameter,C:\repos\sorear_niecza\lib\Kernel.cs,Parameter,The method has 9 parameters. Parameters: c' flags' slot' name' names' def' type' attr' atype
Long Parameter List,Niecza,SubInfo,C:\repos\sorear_niecza\lib\Kernel.cs,SetupCall,The method has 7 parameters. Parameters: caller' outer' sub' pos' named' quiet' de
Long Parameter List,Niecza,SubInfo,C:\repos\sorear_niecza\lib\Kernel.cs,SubInfo,The method has 9 parameters. Parameters: setting' name' lines' code' outer' ltm' edata' label_names' nspill
Long Parameter List,Niecza,SubInfo,C:\repos\sorear_niecza\lib\Kernel.cs,SubInfo,The method has 7 parameters. Parameters: unit' name' outer' cls' pkg' once' ofr
Long Parameter List,Niecza,Frame,C:\repos\sorear_niecza\lib\Kernel.cs,RunConstraint,The method has 6 parameters. Parameters: th' signame' param' quiet' arg' c
Long Parameter List,Niecza,Frame,C:\repos\sorear_niecza\lib\Kernel.cs,BindSignature,The method has 9 parameters. Parameters: th' sig' mode' signame' pos' named' jun_pivot' jun_pivot_n' jun_rank
Long Parameter List,Niecza,ResumeUnwindException,C:\repos\sorear_niecza\lib\Kernel.cs,ResumeUnwindException,The method has 5 parameters. Parameters: type' tf' tip' td' bt
Long Parameter List,Niecza,StashCursor,C:\repos\sorear_niecza\lib\Kernel.cs,Core,The method has 5 parameters. Parameters: key' final' sc' v' bind_to
Long Parameter List,Niecza,Kernel,C:\repos\sorear_niecza\lib\Kernel.cs,WrapIndexy,The method has 6 parameters. Parameters: kl' name' at' exist' del' bind
Long Parameter List,Niecza,Kernel,C:\repos\sorear_niecza\lib\Kernel.cs,SearchForHandler,The method has 6 parameters. Parameters: th' type' tgt' unused' name' payload
Long Parameter List,Niecza,Kernel,C:\repos\sorear_niecza\lib\Kernel.cs,Unwind,The method has 8 parameters. Parameters: th' type' tf' tip' td' tgt' name' bt
Long Parameter List,Niecza,CandidateSet,C:\repos\sorear_niecza\lib\NieczaCLR.cs,CheckJunctionArg,The method has 6 parameters. Parameters: v' jun_pivot' jun_pivot_n' jun_rank' num' nam
Long Parameter List,Niecza,OverloadCandidate,C:\repos\sorear_niecza\lib\NieczaCLR.cs,OverloadCandidate,The method has 5 parameters. Parameters: s' what_call' args' refs' param_array
Long Parameter List,Niecza,CLRWrapperProvider,C:\repos\sorear_niecza\lib\NieczaCLR.cs,MultiAdd,The method has 5 parameters. Parameters: s' d' n' mi' pi
Long Parameter List,Niecza,CLRWrapperProvider,C:\repos\sorear_niecza\lib\NieczaCLR.cs,dnv4,The method has 5 parameters. Parameters: f' a0' a1' a2' a3
Long Parameter List,Niecza,CLRWrapperProvider,C:\repos\sorear_niecza\lib\NieczaCLR.cs,dv4,The method has 5 parameters. Parameters: f' a0' a1' a2' a3
Long Parameter List,Niecza,CLRWrapperProvider,C:\repos\sorear_niecza\lib\NieczaCLR.cs,dnv5,The method has 6 parameters. Parameters: f' a0' a1' a2' a3' a4
Long Parameter List,Niecza,CLRWrapperProvider,C:\repos\sorear_niecza\lib\NieczaCLR.cs,dv5,The method has 6 parameters. Parameters: f' a0' a1' a2' a3' a4
Long Parameter List,Niecza,CLRWrapperProvider,C:\repos\sorear_niecza\lib\NieczaCLR.cs,dnv6,The method has 7 parameters. Parameters: f' a0' a1' a2' a3' a4' a5
Long Parameter List,Niecza,CLRWrapperProvider,C:\repos\sorear_niecza\lib\NieczaCLR.cs,dv6,The method has 7 parameters. Parameters: f' a0' a1' a2' a3' a4' a5
Long Parameter List,Niecza,CLRWrapperProvider,C:\repos\sorear_niecza\lib\NieczaCLR.cs,dnv7,The method has 8 parameters. Parameters: f' a0' a1' a2' a3' a4' a5' a6
Long Parameter List,Niecza,CLRWrapperProvider,C:\repos\sorear_niecza\lib\NieczaCLR.cs,dv7,The method has 8 parameters. Parameters: f' a0' a1' a2' a3' a4' a5' a6
Long Parameter List,Niecza,CLRWrapperProvider,C:\repos\sorear_niecza\lib\NieczaCLR.cs,dnv8,The method has 9 parameters. Parameters: f' a0' a1' a2' a3' a4' a5' a6' a7
Long Parameter List,Niecza,CLRWrapperProvider,C:\repos\sorear_niecza\lib\NieczaCLR.cs,dv8,The method has 9 parameters. Parameters: f' a0' a1' a2' a3' a4' a5' a6' a7
Long Parameter List,Niecza,CLRWrapperProvider,C:\repos\sorear_niecza\lib\NieczaCLR.cs,dnv9,The method has 10 parameters. Parameters: f' a0' a1' a2' a3' a4' a5' a6' a7' a8
Long Parameter List,Niecza,CLRWrapperProvider,C:\repos\sorear_niecza\lib\NieczaCLR.cs,dv9,The method has 10 parameters. Parameters: f' a0' a1' a2' a3' a4' a5' a6' a7' a8
Long Parameter List,Niecza,P6how,C:\repos\sorear_niecza\lib\ObjModel.cs,AddMethodPos,The method has 5 parameters. Parameters: flags' name' code' file' line
Long Parameter List,Niecza,P6how,C:\repos\sorear_niecza\lib\ObjModel.cs,AddAttributePos,The method has 6 parameters. Parameters: name' flags' init' type' file' line
Long Parameter List,Niecza,RatApproxer,C:\repos\sorear_niecza\lib\Utils.cs,CandidateSimplest,The method has 8 parameters. Parameters: numl' denl' xl' numh' denh' xh' snum' sden
Long Parameter List,Niecza,RatApproxer,C:\repos\sorear_niecza\lib\Utils.cs,Simplest,The method has 6 parameters. Parameters: numl' denl' numh' denh' numo' deno
Long Statement,Niecza,Builtins,C:\repos\sorear_niecza\lib\Builtins.cs,command_run,The length of the statement  "        Type Process = Type.GetType("GLib.Process'glib-sharp' Version=2.12.0.0' Culture=neutral' PublicKeyToken=35e10195dab3c99f"); " is 123.
Long Statement,Niecza,Builtins,C:\repos\sorear_niecza\lib\Builtins.cs,command_run,The length of the statement  "        Type SpawnFlags = Type.GetType("GLib.SpawnFlags'glib-sharp' Version=2.12.0.0' Culture=neutral' PublicKeyToken=35e10195dab3c99f"); " is 129.
Long Statement,Niecza,Builtins,C:\repos\sorear_niecza\lib\Builtins.cs,is_role,The length of the statement  "        return (rty == P6how.ROLE || rty == P6how.CURRIED_ROLE || rty == P6how.PARAMETRIZED_ROLE) ? c.setting.TrueV : c.setting.FalseV; " is 127.
Long Statement,Niecza,RWVariable,C:\repos\sorear_niecza\lib\Kernel.cs,Store,The length of the statement  "                throw new NieczaException("Nominal type check failed for scalar store; got " + v.mo.name + "' needed " + type.name + " or subtype"); " is 132.
Long Statement,Niecza,LIAttrAlias,C:\repos\sorear_niecza\lib\Kernel.cs,GetSelfCode,The length of the statement  "                return DieCode(Tokens.P6any' string.Format("No 'self' available in this scope to resolve reference to attribute '{0}'"' name)); " is 127.
Long Statement,Niecza,Frame,C:\repos\sorear_niecza\lib\Kernel.cs,BindSignature,The length of the statement  "                        throw new NieczaException("Nominal type check failed in binding '" + param.name + "' in '" + signame + "'; got " + srco.mo.name + "' needed " + type.name); " is 155.
Long Statement,Niecza,Frame,C:\repos\sorear_niecza\lib\Kernel.cs,BindSignature,The length of the statement  "                            throw new NieczaException("Binding '" + param.name + "' in '" + signame + "'' cannot bind read-only value to is rw parameter"); " is 127.
Long Statement,Niecza,Kernel,C:\repos\sorear_niecza\lib\Kernel.cs,NewBoundVar,The length of the statement  "                throw new NieczaException("Nominal type check failed in nonparameter binding; got " + rhso.mo.name + "' needed " + type.name); " is 126.
Long Statement,Niecza,Kernel,C:\repos\sorear_niecza\lib\Kernel.cs,ApplyRoleToClass,The length of the statement  "                            throw new NieczaException("Attribute '" + ai.name + "' already exists in the class '" + cls.name + "'' but a role also wishes to compose it"); " is 142.
Long Statement,Niecza,Kernel,C:\repos\sorear_niecza\lib\Kernel.cs,ApplyRoleToClass,The length of the statement  "                            throw new NieczaException("Attribute '" + ai.name + "' is provided by both '" + attrs[ai.name] + "' and '" + r.name + "'"); " is 123.
Long Statement,Niecza,Kernel,C:\repos\sorear_niecza\lib\Kernel.cs,ApplyRoleToClass,The length of the statement  "                            throw new NieczaException(MethodSlot(name) + " must be resolved by class '" + cls.name + "' because it exists in roles '" + role_methods[name].v1 + "' and '" + r.name + "'"); " is 174.
Long Statement,Niecza,Kernel,C:\repos\sorear_niecza\lib\Kernel.cs,ApplyRoleToClass,The length of the statement  "                if (role_methods.ContainsKey(name.Key) || class_methods.Contains(name.Key) || (name.Key.v1 == 0 && cls.FindMethod(name.Key.v2) != null)) continue; " is 146.
Long Statement,Niecza,Kernel,C:\repos\sorear_niecza\lib\Kernel.cs,ApplyRoleToClass,The length of the statement  "                throw new NieczaException(MethodSlot(name.Key) + " must be implemented by '" + cls.name + "' because it is required by role '" + name.Value + "'"); " is 147.
Long Statement,Niecza,Kernel,C:\repos\sorear_niecza\lib\Kernel.cs,SearchForHandler,The length of the statement  "            //Console.WriteLine("Entering SearchForHandler(th={0:X}' type={1}' tgt={2:X}' name={3}"' th.GetHashCode()' type' tgt == null ? 0 : tgt.GetHashCode()' name); " is 156.
Long Statement,Niecza,Kernel,C:\repos\sorear_niecza\lib\Kernel.cs,SearchForHandler,The length of the statement  "                //Console.WriteLine("looking at {0:X} (caller: {1:X}) ..."' csr == null ? 0 : csr.GetHashCode()' (csr == null || csr.caller == null) ? 0 : csr.caller.GetHashCode()); " is 165.
Long Statement,Niecza,PropertyProxy,C:\repos\sorear_niecza\lib\NieczaCLR.cs,Store,The length of the statement  "                throw new NieczaException("Unable to coerce value of type " + v.mo.name + " for " + prop.Name); // could also be a range problem " is 128.
Long Statement,Niecza,FieldProxy,C:\repos\sorear_niecza\lib\NieczaCLR.cs,Store,The length of the statement  "                throw new NieczaException("Unable to coerce value of type " + v.mo.name + " for " + field.Name); // could also be a range problem " is 129.
Long Statement,Niecza,CLRWrapperProvider,C:\repos\sorear_niecza\lib\NieczaCLR.cs,dnv4,The length of the statement  "{ return (TR)Callback(f' typeof(TR)' new object[] { a0'a1'a2'a3' }' new Type[] { typeof(T0)'typeof(T1)'typeof(T2)'typeof(T3)' }); }" is 131.
Long Statement,Niecza,CLRWrapperProvider,C:\repos\sorear_niecza\lib\NieczaCLR.cs,dv4,The length of the statement  "{ Callback(f' typeof(void)' new object[] { a0'a1'a2'a3' }' new Type[] { typeof(T0)'typeof(T1)'typeof(T2)'typeof(T3)' }); }" is 122.
Long Statement,Niecza,CLRWrapperProvider,C:\repos\sorear_niecza\lib\NieczaCLR.cs,dnv5,The length of the statement  "{ return (TR)Callback(f' typeof(TR)' new object[] { a0'a1'a2'a3'a4' }' new Type[] { typeof(T0)'typeof(T1)'typeof(T2)'typeof(T3)'typeof(T4)' }); }" is 145.
Long Statement,Niecza,CLRWrapperProvider,C:\repos\sorear_niecza\lib\NieczaCLR.cs,dv5,The length of the statement  "{ Callback(f' typeof(void)' new object[] { a0'a1'a2'a3'a4' }' new Type[] { typeof(T0)'typeof(T1)'typeof(T2)'typeof(T3)'typeof(T4)' }); }" is 136.
Long Statement,Niecza,CLRWrapperProvider,C:\repos\sorear_niecza\lib\NieczaCLR.cs,dnv6,The length of the statement  "{ return (TR)Callback(f' typeof(TR)' new object[] { a0'a1'a2'a3'a4'a5' }' new Type[] { typeof(T0)'typeof(T1)'typeof(T2)'typeof(T3)'typeof(T4)'typeof(T5)' }); }" is 159.
Long Statement,Niecza,CLRWrapperProvider,C:\repos\sorear_niecza\lib\NieczaCLR.cs,dv6,The length of the statement  "{ Callback(f' typeof(void)' new object[] { a0'a1'a2'a3'a4'a5' }' new Type[] { typeof(T0)'typeof(T1)'typeof(T2)'typeof(T3)'typeof(T4)'typeof(T5)' }); }" is 150.
Long Statement,Niecza,CLRWrapperProvider,C:\repos\sorear_niecza\lib\NieczaCLR.cs,dnv7,The length of the statement  "{ return (TR)Callback(f' typeof(TR)' new object[] { a0'a1'a2'a3'a4'a5'a6' }' new Type[] { typeof(T0)'typeof(T1)'typeof(T2)'typeof(T3)'typeof(T4)'typeof(T5)'typeof(T6)' }); }" is 173.
Long Statement,Niecza,CLRWrapperProvider,C:\repos\sorear_niecza\lib\NieczaCLR.cs,dv7,The length of the statement  "{ Callback(f' typeof(void)' new object[] { a0'a1'a2'a3'a4'a5'a6' }' new Type[] { typeof(T0)'typeof(T1)'typeof(T2)'typeof(T3)'typeof(T4)'typeof(T5)'typeof(T6)' }); }" is 164.
Long Statement,Niecza,CLRWrapperProvider,C:\repos\sorear_niecza\lib\NieczaCLR.cs,dnv8,The length of the statement  "{ return (TR)Callback(f' typeof(TR)' new object[] { a0'a1'a2'a3'a4'a5'a6'a7' }' new Type[] { typeof(T0)'typeof(T1)'typeof(T2)'typeof(T3)'typeof(T4)'typeof(T5)'typeof(T6)'typeof(T7)' }); }" is 187.
Long Statement,Niecza,CLRWrapperProvider,C:\repos\sorear_niecza\lib\NieczaCLR.cs,dv8,The length of the statement  "{ Callback(f' typeof(void)' new object[] { a0'a1'a2'a3'a4'a5'a6'a7' }' new Type[] { typeof(T0)'typeof(T1)'typeof(T2)'typeof(T3)'typeof(T4)'typeof(T5)'typeof(T6)'typeof(T7)' }); }" is 178.
Long Statement,Niecza,CLRWrapperProvider,C:\repos\sorear_niecza\lib\NieczaCLR.cs,dnv9,The length of the statement  "{ return (TR)Callback(f' typeof(TR)' new object[] { a0'a1'a2'a3'a4'a5'a6'a7'a8' }' new Type[] { typeof(T0)'typeof(T1)'typeof(T2)'typeof(T3)'typeof(T4)'typeof(T5)'typeof(T6)'typeof(T7)'typeof(T8)' }); }" is 201.
Long Statement,Niecza,CLRWrapperProvider,C:\repos\sorear_niecza\lib\NieczaCLR.cs,dv9,The length of the statement  "{ Callback(f' typeof(void)' new object[] { a0'a1'a2'a3'a4'a5'a6'a7'a8' }' new Type[] { typeof(T0)'typeof(T1)'typeof(T2)'typeof(T3)'typeof(T4)'typeof(T5)'typeof(T6)'typeof(T7)'typeof(T8)' }); }" is 192.
Long Statement,Niecza,CLRWrapperProvider,C:\repos\sorear_niecza\lib\NieczaCLR.cs,marshal_handler,The length of the statement  "                return Kernel.Die(th' "Cannot coerce value of type " + ((Variable)th.lex1).Fetch().mo.name + " to " + mo.box_type.FullName); " is 124.
Long Statement,Niecza,STable,C:\repos\sorear_niecza\lib\ObjModel.cs,FindSlot,The length of the statement  "            throw new NieczaException("Attribute {0} in {1} is defined in {2} but not {3}"' name' this.name' type_slot[slotMap[name]].name' type.name); " is 139.
Complex Conditional,Niecza,BigInteger,C:\repos\sorear_niecza\lib\BigInteger.cs,ToString,The conditional expression  "sign == 1 && radix > 10 && (last < '0' || last > '9')"  is complex.
Complex Conditional,Niecza,BigInteger,C:\repos\sorear_niecza\lib\BigInteger.cs,Log,The conditional expression  "value.sign == -1 || baseValue == 1.0d || baseValue == -1.0d ||  					baseValue == Double.NegativeInfinity || double.IsNaN (baseValue)"  is complex.
Complex Conditional,Niecza,Builtins,C:\repos\sorear_niecza\lib\Builtins.cs,numcompare_core,The conditional expression  "double.IsNaN(v1.re) || double.IsNaN(v1.im) ||                      double.IsNaN(v2.re) || double.IsNaN(v2.im)"  is complex.
Complex Conditional,Niecza,Builtins,C:\repos\sorear_niecza\lib\Builtins.cs,divop,The conditional expression  "b1 || b2 || small1 == int.MinValue || small2 == int.MinValue"  is complex.
Complex Conditional,Niecza,Builtins,C:\repos\sorear_niecza\lib\Builtins.cs,numand,The conditional expression  "b1 || b2 || small1 == int.MinValue || small2 == int.MinValue"  is complex.
Complex Conditional,Niecza,Builtins,C:\repos\sorear_niecza\lib\Builtins.cs,numor,The conditional expression  "b1 || b2 || small1 == int.MinValue || small2 == int.MinValue"  is complex.
Complex Conditional,Niecza,Builtins,C:\repos\sorear_niecza\lib\Builtins.cs,numxor,The conditional expression  "b1 || b2 || small1 == int.MinValue || small2 == int.MinValue"  is complex.
Complex Conditional,Niecza,Builtins,C:\repos\sorear_niecza\lib\Builtins.cs,ord,The conditional expression  "r.Length >= 2 &&                  r[0] >= (char)0xD800 && r[0] <= (char)0xDBFF &&                  r[1] >= (char)0xDC00 && r[1] <= (char)0xDFFF"  is complex.
Complex Conditional,Niecza,RuntimeUnit,C:\repos\sorear_niecza\lib\Kernel.cs,NsMerge,The conditional expression  "nmode == Variable.RW && !nseod || !nse.constant && IsEmptyAggr(nse.v)"  is complex.
Complex Conditional,Niecza,RuntimeUnit,C:\repos\sorear_niecza\lib\Kernel.cs,NsMerge,The conditional expression  "omode == Variable.RW && !oseod || !ose.constant && IsEmptyAggr(ose.v)"  is complex.
Complex Conditional,Niecza,RuntimeUnit,C:\repos\sorear_niecza\lib\Kernel.cs,NsMerge,The conditional expression  "ose.v == nse.v || omode != Variable.RW &&                      omode == nmode && oseo == nseo"  is complex.
Complex Conditional,Niecza,RuntimeUnit,C:\repos\sorear_niecza\lib\Kernel.cs,NsMerge,The conditional expression  "ose.constant && !oseod && nse.constant && !nseod &&                      (oseo.mo.mo.type == P6how.PACKAGE || nseo.mo.mo.type == P6how.PACKAGE) &&                      oseo.mo.who.Isa(setting.StashMO) &&                      nseo.mo.who.Isa(setting.StashMO) &&                      Kernel.UnboxAny<string>(oseo.mo.who) ==                          Kernel.UnboxAny<string>(nseo.mo.who)"  is complex.
Complex Conditional,Niecza,SubInfo,C:\repos\sorear_niecza\lib\Kernel.cs,GetInlineSlot,The conditional expression  "edata[end+2] == ON_VARLOOKUP && edata[end+4] < 0 &&                          edata[end+3] == depth && ip >= edata[end] &&                          ip < edata[end+1]"  is complex.
Complex Conditional,Niecza,SubInfo,C:\repos\sorear_niecza\lib\Kernel.cs,IsInlinable,The conditional expression  "(kv.Key.Length > 0 &&                              (kv.Key[0] == '?' || kv.Key[0] == '*')) ||                          (kv.Key.Length > 1 &&                            (kv.Key[1] == '?' || kv.Key[1] == '*'))"  is complex.
Complex Conditional,Niecza,StashCursor,C:\repos\sorear_niecza\lib\Kernel.cs,Core,The conditional expression  "key == "UNIT" || key == "OUTER" ||                          key == "SETTING" || key == "CALLER""  is complex.
Complex Conditional,Niecza,Kernel,C:\repos\sorear_niecza\lib\Kernel.cs,ApplyRoleToClass,The conditional expression  "role_methods.ContainsKey(name.Key) || class_methods.Contains(name.Key) || (name.Key.v1 == 0 && cls.FindMethod(name.Key.v2) != null)"  is complex.
Complex Conditional,Niecza,Kernel,C:\repos\sorear_niecza\lib\Kernel.cs,Main,The conditional expression  "fi.IsInitOnly && (ft.IsPrimitive ||                                  ft == typeof(BigInteger) ||                                  ft == typeof(Type) ||                                  ft == typeof(Assembly) ||                                  ft == typeof(FieldInfo) ||                                  ft == typeof(ConstructorInfo) ||                                  ft == typeof(MethodInfo) ||                                  typeof(Delegate).IsAssignableFrom(ft) ||                                  //ft.IsSealed && ft.GetFields(                                  //    BindingFlags.Instance |                                  //    BindingFlags.Public |                                  //    BindingFlags.NonPublic).Length == 0 ||                                  ft == typeof(string))"  is complex.
Virtual Method Call from Constructor,Niecza,TiedVariable,C:\repos\sorear_niecza\lib\Kernel.cs,TiedVariable,The constructor "TiedVariable" calls a virtual method "IsDefined".
Virtual Method Call from Constructor,Niecza,MMDCandidate,C:\repos\sorear_niecza\lib\Kernel.cs,MMDCandidate,The constructor "MMDCandidate" calls a virtual method "GetSlot".
Virtual Method Call from Constructor,Niecza,CandidateSet,C:\repos\sorear_niecza\lib\NieczaCLR.cs,CandidateSet,The constructor "CandidateSet" calls a virtual method "MinDispatchArity".
Magic Number,Niecza,BigInteger,C:\repos\sorear_niecza\lib\BigInteger.cs,BigInteger,The following statement contains a magic number: if (value == 0) {  				sign = 0;  				data = ZERO;  			} else if (value > 0) {  				sign = 1;  				uint low = (uint)value;  				uint high = (uint)(value >> 32);    				data = new uint [high != 0 ? 2 : 1];  				data [0] = low;  				if (high != 0)  					data [1] = high;  			} else {  				sign = -1;  				value = -value;  				uint low = (uint)value;  				uint high = (uint)((ulong)value >> 32);    				data = new uint [high != 0 ? 2 : 1];  				data [0] = low;  				if (high != 0)  					data [1] = high;  			}
Magic Number,Niecza,BigInteger,C:\repos\sorear_niecza\lib\BigInteger.cs,BigInteger,The following statement contains a magic number: if (value == 0) {  				sign = 0;  				data = ZERO;  			} else if (value > 0) {  				sign = 1;  				uint low = (uint)value;  				uint high = (uint)(value >> 32);    				data = new uint [high != 0 ? 2 : 1];  				data [0] = low;  				if (high != 0)  					data [1] = high;  			} else {  				sign = -1;  				value = -value;  				uint low = (uint)value;  				uint high = (uint)((ulong)value >> 32);    				data = new uint [high != 0 ? 2 : 1];  				data [0] = low;  				if (high != 0)  					data [1] = high;  			}
Magic Number,Niecza,BigInteger,C:\repos\sorear_niecza\lib\BigInteger.cs,BigInteger,The following statement contains a magic number: if (value == 0) {  				sign = 0;  				data = ZERO;  			} else if (value > 0) {  				sign = 1;  				uint low = (uint)value;  				uint high = (uint)(value >> 32);    				data = new uint [high != 0 ? 2 : 1];  				data [0] = low;  				if (high != 0)  					data [1] = high;  			} else {  				sign = -1;  				value = -value;  				uint low = (uint)value;  				uint high = (uint)((ulong)value >> 32);    				data = new uint [high != 0 ? 2 : 1];  				data [0] = low;  				if (high != 0)  					data [1] = high;  			}
Magic Number,Niecza,BigInteger,C:\repos\sorear_niecza\lib\BigInteger.cs,BigInteger,The following statement contains a magic number: if (value == 0) {  				sign = 0;  				data = ZERO;  			} else if (value > 0) {  				sign = 1;  				uint low = (uint)value;  				uint high = (uint)(value >> 32);    				data = new uint [high != 0 ? 2 : 1];  				data [0] = low;  				if (high != 0)  					data [1] = high;  			} else {  				sign = -1;  				value = -value;  				uint low = (uint)value;  				uint high = (uint)((ulong)value >> 32);    				data = new uint [high != 0 ? 2 : 1];  				data [0] = low;  				if (high != 0)  					data [1] = high;  			}
Magic Number,Niecza,BigInteger,C:\repos\sorear_niecza\lib\BigInteger.cs,BigInteger,The following statement contains a magic number: if (value == 0) {  				sign = 0;  				data = ZERO;  			} else {  				sign = 1;  				uint low = (uint)value;  				uint high = (uint)(value >> 32);    				data = new uint [high != 0 ? 2 : 1];  				data [0] = low;  				if (high != 0)  					data [1] = high;  			}
Magic Number,Niecza,BigInteger,C:\repos\sorear_niecza\lib\BigInteger.cs,BigInteger,The following statement contains a magic number: if (value == 0) {  				sign = 0;  				data = ZERO;  			} else {  				sign = 1;  				uint low = (uint)value;  				uint high = (uint)(value >> 32);    				data = new uint [high != 0 ? 2 : 1];  				data [0] = low;  				if (high != 0)  					data [1] = high;  			}
Magic Number,Niecza,BigInteger,C:\repos\sorear_niecza\lib\BigInteger.cs,Negative,The following statement contains a magic number: return ((v[7] & 0x80) != 0);
Magic Number,Niecza,BigInteger,C:\repos\sorear_niecza\lib\BigInteger.cs,Exponent,The following statement contains a magic number: return (ushort)((((ushort)(v[7] & 0x7F)) << (ushort)4) | (((ushort)(v[6] & 0xF0)) >> 4));
Magic Number,Niecza,BigInteger,C:\repos\sorear_niecza\lib\BigInteger.cs,Exponent,The following statement contains a magic number: return (ushort)((((ushort)(v[7] & 0x7F)) << (ushort)4) | (((ushort)(v[6] & 0xF0)) >> 4));
Magic Number,Niecza,BigInteger,C:\repos\sorear_niecza\lib\BigInteger.cs,Exponent,The following statement contains a magic number: return (ushort)((((ushort)(v[7] & 0x7F)) << (ushort)4) | (((ushort)(v[6] & 0xF0)) >> 4));
Magic Number,Niecza,BigInteger,C:\repos\sorear_niecza\lib\BigInteger.cs,Exponent,The following statement contains a magic number: return (ushort)((((ushort)(v[7] & 0x7F)) << (ushort)4) | (((ushort)(v[6] & 0xF0)) >> 4));
Magic Number,Niecza,BigInteger,C:\repos\sorear_niecza\lib\BigInteger.cs,Mantissa,The following statement contains a magic number: uint i1 = ((uint)v[0] | ((uint)v[1] << 8) | ((uint)v[2] << 16) | ((uint)v[3] << 24));
Magic Number,Niecza,BigInteger,C:\repos\sorear_niecza\lib\BigInteger.cs,Mantissa,The following statement contains a magic number: uint i1 = ((uint)v[0] | ((uint)v[1] << 8) | ((uint)v[2] << 16) | ((uint)v[3] << 24));
Magic Number,Niecza,BigInteger,C:\repos\sorear_niecza\lib\BigInteger.cs,Mantissa,The following statement contains a magic number: uint i1 = ((uint)v[0] | ((uint)v[1] << 8) | ((uint)v[2] << 16) | ((uint)v[3] << 24));
Magic Number,Niecza,BigInteger,C:\repos\sorear_niecza\lib\BigInteger.cs,Mantissa,The following statement contains a magic number: uint i1 = ((uint)v[0] | ((uint)v[1] << 8) | ((uint)v[2] << 16) | ((uint)v[3] << 24));
Magic Number,Niecza,BigInteger,C:\repos\sorear_niecza\lib\BigInteger.cs,Mantissa,The following statement contains a magic number: uint i1 = ((uint)v[0] | ((uint)v[1] << 8) | ((uint)v[2] << 16) | ((uint)v[3] << 24));
Magic Number,Niecza,BigInteger,C:\repos\sorear_niecza\lib\BigInteger.cs,Mantissa,The following statement contains a magic number: uint i2 = ((uint)v[4] | ((uint)v[5] << 8) | ((uint)(v[6] & 0xF) << 16));
Magic Number,Niecza,BigInteger,C:\repos\sorear_niecza\lib\BigInteger.cs,Mantissa,The following statement contains a magic number: uint i2 = ((uint)v[4] | ((uint)v[5] << 8) | ((uint)(v[6] & 0xF) << 16));
Magic Number,Niecza,BigInteger,C:\repos\sorear_niecza\lib\BigInteger.cs,Mantissa,The following statement contains a magic number: uint i2 = ((uint)v[4] | ((uint)v[5] << 8) | ((uint)(v[6] & 0xF) << 16));
Magic Number,Niecza,BigInteger,C:\repos\sorear_niecza\lib\BigInteger.cs,Mantissa,The following statement contains a magic number: uint i2 = ((uint)v[4] | ((uint)v[5] << 8) | ((uint)(v[6] & 0xF) << 16));
Magic Number,Niecza,BigInteger,C:\repos\sorear_niecza\lib\BigInteger.cs,Mantissa,The following statement contains a magic number: uint i2 = ((uint)v[4] | ((uint)v[5] << 8) | ((uint)(v[6] & 0xF) << 16));
Magic Number,Niecza,BigInteger,C:\repos\sorear_niecza\lib\BigInteger.cs,Mantissa,The following statement contains a magic number: return (ulong)((ulong)i1 | ((ulong)i2 << 32));
Magic Number,Niecza,BigInteger,C:\repos\sorear_niecza\lib\BigInteger.cs,BigInteger,The following statement contains a magic number: int size = 3;
Magic Number,Niecza,BigInteger,C:\repos\sorear_niecza\lib\BigInteger.cs,BigInteger,The following statement contains a magic number: sign = (short) ((bits [3] & DecimalSignMask) != 0 ? -1 : 1);
Magic Number,Niecza,BigInteger,C:\repos\sorear_niecza\lib\BigInteger.cs,BigInteger,The following statement contains a magic number: if (size > 2)  				data [2] = (uint)bits [2];
Magic Number,Niecza,BigInteger,C:\repos\sorear_niecza\lib\BigInteger.cs,BigInteger,The following statement contains a magic number: if (size > 2)  				data [2] = (uint)bits [2];
Magic Number,Niecza,BigInteger,C:\repos\sorear_niecza\lib\BigInteger.cs,BigInteger,The following statement contains a magic number: if (size > 2)  				data [2] = (uint)bits [2];
Magic Number,Niecza,BigInteger,C:\repos\sorear_niecza\lib\BigInteger.cs,BigInteger,The following statement contains a magic number: if (sign == 1) {  				while (len > 1 && value [len - 1] == 0)  					--len;    				int full_words' size;  				full_words = size = len / 4;  				if ((len & 0x3) != 0)  					++size;    				data = new uint [size];  				int j = 0;  				for (int i = 0; i < full_words; ++i) {  					data [i] =	(uint)value [j++] |  								(uint)(value [j++] << 8) |  								(uint)(value [j++] << 16) |  								(uint)(value [j++] << 24);  				}  				size = len & 0x3;  				if (size > 0) {  					int idx = data.Length - 1;  					for (int i = 0; i < size; ++i)  						data [idx] |= (uint)(value [j++] << (i * 8));  				}  			} else {  				int full_words' size;  				full_words = size = len / 4;  				if ((len & 0x3) != 0)  					++size;    				data = new uint [size];    				uint word' borrow = 1;  				ulong sub = 0;  				int j = 0;    				for (int i = 0; i < full_words; ++i) {  					word =	(uint)value [j++] |  							(uint)(value [j++] << 8) |  							(uint)(value [j++] << 16) |  							(uint)(value [j++] << 24);    					sub = (ulong)word - borrow;  					word = (uint)sub;  					borrow = (uint)(sub >> 32) & 0x1u;  					data [i] = ~word;  				}  				size = len & 0x3;    				if (size > 0) {  					word = 0;  					uint store_mask = 0;  					for (int i = 0; i < size; ++i) {  						word |= (uint)(value [j++] << (i * 8));  						store_mask = (store_mask << 8) | 0xFF;  					}    					sub = word - borrow;  					word = (uint)sub;  					borrow = (uint)(sub >> 32) & 0x1u;    					data [data.Length - 1] = ~word & store_mask;  				}  				if (borrow != 0) //FIXME I believe this can't happen' can someone write a test for it?  					throw new Exception ("non zero final carry");  			}
Magic Number,Niecza,BigInteger,C:\repos\sorear_niecza\lib\BigInteger.cs,BigInteger,The following statement contains a magic number: if (sign == 1) {  				while (len > 1 && value [len - 1] == 0)  					--len;    				int full_words' size;  				full_words = size = len / 4;  				if ((len & 0x3) != 0)  					++size;    				data = new uint [size];  				int j = 0;  				for (int i = 0; i < full_words; ++i) {  					data [i] =	(uint)value [j++] |  								(uint)(value [j++] << 8) |  								(uint)(value [j++] << 16) |  								(uint)(value [j++] << 24);  				}  				size = len & 0x3;  				if (size > 0) {  					int idx = data.Length - 1;  					for (int i = 0; i < size; ++i)  						data [idx] |= (uint)(value [j++] << (i * 8));  				}  			} else {  				int full_words' size;  				full_words = size = len / 4;  				if ((len & 0x3) != 0)  					++size;    				data = new uint [size];    				uint word' borrow = 1;  				ulong sub = 0;  				int j = 0;    				for (int i = 0; i < full_words; ++i) {  					word =	(uint)value [j++] |  							(uint)(value [j++] << 8) |  							(uint)(value [j++] << 16) |  							(uint)(value [j++] << 24);    					sub = (ulong)word - borrow;  					word = (uint)sub;  					borrow = (uint)(sub >> 32) & 0x1u;  					data [i] = ~word;  				}  				size = len & 0x3;    				if (size > 0) {  					word = 0;  					uint store_mask = 0;  					for (int i = 0; i < size; ++i) {  						word |= (uint)(value [j++] << (i * 8));  						store_mask = (store_mask << 8) | 0xFF;  					}    					sub = word - borrow;  					word = (uint)sub;  					borrow = (uint)(sub >> 32) & 0x1u;    					data [data.Length - 1] = ~word & store_mask;  				}  				if (borrow != 0) //FIXME I believe this can't happen' can someone write a test for it?  					throw new Exception ("non zero final carry");  			}
Magic Number,Niecza,BigInteger,C:\repos\sorear_niecza\lib\BigInteger.cs,BigInteger,The following statement contains a magic number: if (sign == 1) {  				while (len > 1 && value [len - 1] == 0)  					--len;    				int full_words' size;  				full_words = size = len / 4;  				if ((len & 0x3) != 0)  					++size;    				data = new uint [size];  				int j = 0;  				for (int i = 0; i < full_words; ++i) {  					data [i] =	(uint)value [j++] |  								(uint)(value [j++] << 8) |  								(uint)(value [j++] << 16) |  								(uint)(value [j++] << 24);  				}  				size = len & 0x3;  				if (size > 0) {  					int idx = data.Length - 1;  					for (int i = 0; i < size; ++i)  						data [idx] |= (uint)(value [j++] << (i * 8));  				}  			} else {  				int full_words' size;  				full_words = size = len / 4;  				if ((len & 0x3) != 0)  					++size;    				data = new uint [size];    				uint word' borrow = 1;  				ulong sub = 0;  				int j = 0;    				for (int i = 0; i < full_words; ++i) {  					word =	(uint)value [j++] |  							(uint)(value [j++] << 8) |  							(uint)(value [j++] << 16) |  							(uint)(value [j++] << 24);    					sub = (ulong)word - borrow;  					word = (uint)sub;  					borrow = (uint)(sub >> 32) & 0x1u;  					data [i] = ~word;  				}  				size = len & 0x3;    				if (size > 0) {  					word = 0;  					uint store_mask = 0;  					for (int i = 0; i < size; ++i) {  						word |= (uint)(value [j++] << (i * 8));  						store_mask = (store_mask << 8) | 0xFF;  					}    					sub = word - borrow;  					word = (uint)sub;  					borrow = (uint)(sub >> 32) & 0x1u;    					data [data.Length - 1] = ~word & store_mask;  				}  				if (borrow != 0) //FIXME I believe this can't happen' can someone write a test for it?  					throw new Exception ("non zero final carry");  			}
Magic Number,Niecza,BigInteger,C:\repos\sorear_niecza\lib\BigInteger.cs,BigInteger,The following statement contains a magic number: if (sign == 1) {  				while (len > 1 && value [len - 1] == 0)  					--len;    				int full_words' size;  				full_words = size = len / 4;  				if ((len & 0x3) != 0)  					++size;    				data = new uint [size];  				int j = 0;  				for (int i = 0; i < full_words; ++i) {  					data [i] =	(uint)value [j++] |  								(uint)(value [j++] << 8) |  								(uint)(value [j++] << 16) |  								(uint)(value [j++] << 24);  				}  				size = len & 0x3;  				if (size > 0) {  					int idx = data.Length - 1;  					for (int i = 0; i < size; ++i)  						data [idx] |= (uint)(value [j++] << (i * 8));  				}  			} else {  				int full_words' size;  				full_words = size = len / 4;  				if ((len & 0x3) != 0)  					++size;    				data = new uint [size];    				uint word' borrow = 1;  				ulong sub = 0;  				int j = 0;    				for (int i = 0; i < full_words; ++i) {  					word =	(uint)value [j++] |  							(uint)(value [j++] << 8) |  							(uint)(value [j++] << 16) |  							(uint)(value [j++] << 24);    					sub = (ulong)word - borrow;  					word = (uint)sub;  					borrow = (uint)(sub >> 32) & 0x1u;  					data [i] = ~word;  				}  				size = len & 0x3;    				if (size > 0) {  					word = 0;  					uint store_mask = 0;  					for (int i = 0; i < size; ++i) {  						word |= (uint)(value [j++] << (i * 8));  						store_mask = (store_mask << 8) | 0xFF;  					}    					sub = word - borrow;  					word = (uint)sub;  					borrow = (uint)(sub >> 32) & 0x1u;    					data [data.Length - 1] = ~word & store_mask;  				}  				if (borrow != 0) //FIXME I believe this can't happen' can someone write a test for it?  					throw new Exception ("non zero final carry");  			}
Magic Number,Niecza,BigInteger,C:\repos\sorear_niecza\lib\BigInteger.cs,BigInteger,The following statement contains a magic number: if (sign == 1) {  				while (len > 1 && value [len - 1] == 0)  					--len;    				int full_words' size;  				full_words = size = len / 4;  				if ((len & 0x3) != 0)  					++size;    				data = new uint [size];  				int j = 0;  				for (int i = 0; i < full_words; ++i) {  					data [i] =	(uint)value [j++] |  								(uint)(value [j++] << 8) |  								(uint)(value [j++] << 16) |  								(uint)(value [j++] << 24);  				}  				size = len & 0x3;  				if (size > 0) {  					int idx = data.Length - 1;  					for (int i = 0; i < size; ++i)  						data [idx] |= (uint)(value [j++] << (i * 8));  				}  			} else {  				int full_words' size;  				full_words = size = len / 4;  				if ((len & 0x3) != 0)  					++size;    				data = new uint [size];    				uint word' borrow = 1;  				ulong sub = 0;  				int j = 0;    				for (int i = 0; i < full_words; ++i) {  					word =	(uint)value [j++] |  							(uint)(value [j++] << 8) |  							(uint)(value [j++] << 16) |  							(uint)(value [j++] << 24);    					sub = (ulong)word - borrow;  					word = (uint)sub;  					borrow = (uint)(sub >> 32) & 0x1u;  					data [i] = ~word;  				}  				size = len & 0x3;    				if (size > 0) {  					word = 0;  					uint store_mask = 0;  					for (int i = 0; i < size; ++i) {  						word |= (uint)(value [j++] << (i * 8));  						store_mask = (store_mask << 8) | 0xFF;  					}    					sub = word - borrow;  					word = (uint)sub;  					borrow = (uint)(sub >> 32) & 0x1u;    					data [data.Length - 1] = ~word & store_mask;  				}  				if (borrow != 0) //FIXME I believe this can't happen' can someone write a test for it?  					throw new Exception ("non zero final carry");  			}
Magic Number,Niecza,BigInteger,C:\repos\sorear_niecza\lib\BigInteger.cs,BigInteger,The following statement contains a magic number: if (sign == 1) {  				while (len > 1 && value [len - 1] == 0)  					--len;    				int full_words' size;  				full_words = size = len / 4;  				if ((len & 0x3) != 0)  					++size;    				data = new uint [size];  				int j = 0;  				for (int i = 0; i < full_words; ++i) {  					data [i] =	(uint)value [j++] |  								(uint)(value [j++] << 8) |  								(uint)(value [j++] << 16) |  								(uint)(value [j++] << 24);  				}  				size = len & 0x3;  				if (size > 0) {  					int idx = data.Length - 1;  					for (int i = 0; i < size; ++i)  						data [idx] |= (uint)(value [j++] << (i * 8));  				}  			} else {  				int full_words' size;  				full_words = size = len / 4;  				if ((len & 0x3) != 0)  					++size;    				data = new uint [size];    				uint word' borrow = 1;  				ulong sub = 0;  				int j = 0;    				for (int i = 0; i < full_words; ++i) {  					word =	(uint)value [j++] |  							(uint)(value [j++] << 8) |  							(uint)(value [j++] << 16) |  							(uint)(value [j++] << 24);    					sub = (ulong)word - borrow;  					word = (uint)sub;  					borrow = (uint)(sub >> 32) & 0x1u;  					data [i] = ~word;  				}  				size = len & 0x3;    				if (size > 0) {  					word = 0;  					uint store_mask = 0;  					for (int i = 0; i < size; ++i) {  						word |= (uint)(value [j++] << (i * 8));  						store_mask = (store_mask << 8) | 0xFF;  					}    					sub = word - borrow;  					word = (uint)sub;  					borrow = (uint)(sub >> 32) & 0x1u;    					data [data.Length - 1] = ~word & store_mask;  				}  				if (borrow != 0) //FIXME I believe this can't happen' can someone write a test for it?  					throw new Exception ("non zero final carry");  			}
Magic Number,Niecza,BigInteger,C:\repos\sorear_niecza\lib\BigInteger.cs,BigInteger,The following statement contains a magic number: if (sign == 1) {  				while (len > 1 && value [len - 1] == 0)  					--len;    				int full_words' size;  				full_words = size = len / 4;  				if ((len & 0x3) != 0)  					++size;    				data = new uint [size];  				int j = 0;  				for (int i = 0; i < full_words; ++i) {  					data [i] =	(uint)value [j++] |  								(uint)(value [j++] << 8) |  								(uint)(value [j++] << 16) |  								(uint)(value [j++] << 24);  				}  				size = len & 0x3;  				if (size > 0) {  					int idx = data.Length - 1;  					for (int i = 0; i < size; ++i)  						data [idx] |= (uint)(value [j++] << (i * 8));  				}  			} else {  				int full_words' size;  				full_words = size = len / 4;  				if ((len & 0x3) != 0)  					++size;    				data = new uint [size];    				uint word' borrow = 1;  				ulong sub = 0;  				int j = 0;    				for (int i = 0; i < full_words; ++i) {  					word =	(uint)value [j++] |  							(uint)(value [j++] << 8) |  							(uint)(value [j++] << 16) |  							(uint)(value [j++] << 24);    					sub = (ulong)word - borrow;  					word = (uint)sub;  					borrow = (uint)(sub >> 32) & 0x1u;  					data [i] = ~word;  				}  				size = len & 0x3;    				if (size > 0) {  					word = 0;  					uint store_mask = 0;  					for (int i = 0; i < size; ++i) {  						word |= (uint)(value [j++] << (i * 8));  						store_mask = (store_mask << 8) | 0xFF;  					}    					sub = word - borrow;  					word = (uint)sub;  					borrow = (uint)(sub >> 32) & 0x1u;    					data [data.Length - 1] = ~word & store_mask;  				}  				if (borrow != 0) //FIXME I believe this can't happen' can someone write a test for it?  					throw new Exception ("non zero final carry");  			}
Magic Number,Niecza,BigInteger,C:\repos\sorear_niecza\lib\BigInteger.cs,BigInteger,The following statement contains a magic number: if (sign == 1) {  				while (len > 1 && value [len - 1] == 0)  					--len;    				int full_words' size;  				full_words = size = len / 4;  				if ((len & 0x3) != 0)  					++size;    				data = new uint [size];  				int j = 0;  				for (int i = 0; i < full_words; ++i) {  					data [i] =	(uint)value [j++] |  								(uint)(value [j++] << 8) |  								(uint)(value [j++] << 16) |  								(uint)(value [j++] << 24);  				}  				size = len & 0x3;  				if (size > 0) {  					int idx = data.Length - 1;  					for (int i = 0; i < size; ++i)  						data [idx] |= (uint)(value [j++] << (i * 8));  				}  			} else {  				int full_words' size;  				full_words = size = len / 4;  				if ((len & 0x3) != 0)  					++size;    				data = new uint [size];    				uint word' borrow = 1;  				ulong sub = 0;  				int j = 0;    				for (int i = 0; i < full_words; ++i) {  					word =	(uint)value [j++] |  							(uint)(value [j++] << 8) |  							(uint)(value [j++] << 16) |  							(uint)(value [j++] << 24);    					sub = (ulong)word - borrow;  					word = (uint)sub;  					borrow = (uint)(sub >> 32) & 0x1u;  					data [i] = ~word;  				}  				size = len & 0x3;    				if (size > 0) {  					word = 0;  					uint store_mask = 0;  					for (int i = 0; i < size; ++i) {  						word |= (uint)(value [j++] << (i * 8));  						store_mask = (store_mask << 8) | 0xFF;  					}    					sub = word - borrow;  					word = (uint)sub;  					borrow = (uint)(sub >> 32) & 0x1u;    					data [data.Length - 1] = ~word & store_mask;  				}  				if (borrow != 0) //FIXME I believe this can't happen' can someone write a test for it?  					throw new Exception ("non zero final carry");  			}
Magic Number,Niecza,BigInteger,C:\repos\sorear_niecza\lib\BigInteger.cs,BigInteger,The following statement contains a magic number: if (sign == 1) {  				while (len > 1 && value [len - 1] == 0)  					--len;    				int full_words' size;  				full_words = size = len / 4;  				if ((len & 0x3) != 0)  					++size;    				data = new uint [size];  				int j = 0;  				for (int i = 0; i < full_words; ++i) {  					data [i] =	(uint)value [j++] |  								(uint)(value [j++] << 8) |  								(uint)(value [j++] << 16) |  								(uint)(value [j++] << 24);  				}  				size = len & 0x3;  				if (size > 0) {  					int idx = data.Length - 1;  					for (int i = 0; i < size; ++i)  						data [idx] |= (uint)(value [j++] << (i * 8));  				}  			} else {  				int full_words' size;  				full_words = size = len / 4;  				if ((len & 0x3) != 0)  					++size;    				data = new uint [size];    				uint word' borrow = 1;  				ulong sub = 0;  				int j = 0;    				for (int i = 0; i < full_words; ++i) {  					word =	(uint)value [j++] |  							(uint)(value [j++] << 8) |  							(uint)(value [j++] << 16) |  							(uint)(value [j++] << 24);    					sub = (ulong)word - borrow;  					word = (uint)sub;  					borrow = (uint)(sub >> 32) & 0x1u;  					data [i] = ~word;  				}  				size = len & 0x3;    				if (size > 0) {  					word = 0;  					uint store_mask = 0;  					for (int i = 0; i < size; ++i) {  						word |= (uint)(value [j++] << (i * 8));  						store_mask = (store_mask << 8) | 0xFF;  					}    					sub = word - borrow;  					word = (uint)sub;  					borrow = (uint)(sub >> 32) & 0x1u;    					data [data.Length - 1] = ~word & store_mask;  				}  				if (borrow != 0) //FIXME I believe this can't happen' can someone write a test for it?  					throw new Exception ("non zero final carry");  			}
Magic Number,Niecza,BigInteger,C:\repos\sorear_niecza\lib\BigInteger.cs,BigInteger,The following statement contains a magic number: if (sign == 1) {  				while (len > 1 && value [len - 1] == 0)  					--len;    				int full_words' size;  				full_words = size = len / 4;  				if ((len & 0x3) != 0)  					++size;    				data = new uint [size];  				int j = 0;  				for (int i = 0; i < full_words; ++i) {  					data [i] =	(uint)value [j++] |  								(uint)(value [j++] << 8) |  								(uint)(value [j++] << 16) |  								(uint)(value [j++] << 24);  				}  				size = len & 0x3;  				if (size > 0) {  					int idx = data.Length - 1;  					for (int i = 0; i < size; ++i)  						data [idx] |= (uint)(value [j++] << (i * 8));  				}  			} else {  				int full_words' size;  				full_words = size = len / 4;  				if ((len & 0x3) != 0)  					++size;    				data = new uint [size];    				uint word' borrow = 1;  				ulong sub = 0;  				int j = 0;    				for (int i = 0; i < full_words; ++i) {  					word =	(uint)value [j++] |  							(uint)(value [j++] << 8) |  							(uint)(value [j++] << 16) |  							(uint)(value [j++] << 24);    					sub = (ulong)word - borrow;  					word = (uint)sub;  					borrow = (uint)(sub >> 32) & 0x1u;  					data [i] = ~word;  				}  				size = len & 0x3;    				if (size > 0) {  					word = 0;  					uint store_mask = 0;  					for (int i = 0; i < size; ++i) {  						word |= (uint)(value [j++] << (i * 8));  						store_mask = (store_mask << 8) | 0xFF;  					}    					sub = word - borrow;  					word = (uint)sub;  					borrow = (uint)(sub >> 32) & 0x1u;    					data [data.Length - 1] = ~word & store_mask;  				}  				if (borrow != 0) //FIXME I believe this can't happen' can someone write a test for it?  					throw new Exception ("non zero final carry");  			}
Magic Number,Niecza,BigInteger,C:\repos\sorear_niecza\lib\BigInteger.cs,BigInteger,The following statement contains a magic number: if (sign == 1) {  				while (len > 1 && value [len - 1] == 0)  					--len;    				int full_words' size;  				full_words = size = len / 4;  				if ((len & 0x3) != 0)  					++size;    				data = new uint [size];  				int j = 0;  				for (int i = 0; i < full_words; ++i) {  					data [i] =	(uint)value [j++] |  								(uint)(value [j++] << 8) |  								(uint)(value [j++] << 16) |  								(uint)(value [j++] << 24);  				}  				size = len & 0x3;  				if (size > 0) {  					int idx = data.Length - 1;  					for (int i = 0; i < size; ++i)  						data [idx] |= (uint)(value [j++] << (i * 8));  				}  			} else {  				int full_words' size;  				full_words = size = len / 4;  				if ((len & 0x3) != 0)  					++size;    				data = new uint [size];    				uint word' borrow = 1;  				ulong sub = 0;  				int j = 0;    				for (int i = 0; i < full_words; ++i) {  					word =	(uint)value [j++] |  							(uint)(value [j++] << 8) |  							(uint)(value [j++] << 16) |  							(uint)(value [j++] << 24);    					sub = (ulong)word - borrow;  					word = (uint)sub;  					borrow = (uint)(sub >> 32) & 0x1u;  					data [i] = ~word;  				}  				size = len & 0x3;    				if (size > 0) {  					word = 0;  					uint store_mask = 0;  					for (int i = 0; i < size; ++i) {  						word |= (uint)(value [j++] << (i * 8));  						store_mask = (store_mask << 8) | 0xFF;  					}    					sub = word - borrow;  					word = (uint)sub;  					borrow = (uint)(sub >> 32) & 0x1u;    					data [data.Length - 1] = ~word & store_mask;  				}  				if (borrow != 0) //FIXME I believe this can't happen' can someone write a test for it?  					throw new Exception ("non zero final carry");  			}
Magic Number,Niecza,BigInteger,C:\repos\sorear_niecza\lib\BigInteger.cs,BigInteger,The following statement contains a magic number: if (sign == 1) {  				while (len > 1 && value [len - 1] == 0)  					--len;    				int full_words' size;  				full_words = size = len / 4;  				if ((len & 0x3) != 0)  					++size;    				data = new uint [size];  				int j = 0;  				for (int i = 0; i < full_words; ++i) {  					data [i] =	(uint)value [j++] |  								(uint)(value [j++] << 8) |  								(uint)(value [j++] << 16) |  								(uint)(value [j++] << 24);  				}  				size = len & 0x3;  				if (size > 0) {  					int idx = data.Length - 1;  					for (int i = 0; i < size; ++i)  						data [idx] |= (uint)(value [j++] << (i * 8));  				}  			} else {  				int full_words' size;  				full_words = size = len / 4;  				if ((len & 0x3) != 0)  					++size;    				data = new uint [size];    				uint word' borrow = 1;  				ulong sub = 0;  				int j = 0;    				for (int i = 0; i < full_words; ++i) {  					word =	(uint)value [j++] |  							(uint)(value [j++] << 8) |  							(uint)(value [j++] << 16) |  							(uint)(value [j++] << 24);    					sub = (ulong)word - borrow;  					word = (uint)sub;  					borrow = (uint)(sub >> 32) & 0x1u;  					data [i] = ~word;  				}  				size = len & 0x3;    				if (size > 0) {  					word = 0;  					uint store_mask = 0;  					for (int i = 0; i < size; ++i) {  						word |= (uint)(value [j++] << (i * 8));  						store_mask = (store_mask << 8) | 0xFF;  					}    					sub = word - borrow;  					word = (uint)sub;  					borrow = (uint)(sub >> 32) & 0x1u;    					data [data.Length - 1] = ~word & store_mask;  				}  				if (borrow != 0) //FIXME I believe this can't happen' can someone write a test for it?  					throw new Exception ("non zero final carry");  			}
Magic Number,Niecza,BigInteger,C:\repos\sorear_niecza\lib\BigInteger.cs,BigInteger,The following statement contains a magic number: if (sign == 1) {  				while (len > 1 && value [len - 1] == 0)  					--len;    				int full_words' size;  				full_words = size = len / 4;  				if ((len & 0x3) != 0)  					++size;    				data = new uint [size];  				int j = 0;  				for (int i = 0; i < full_words; ++i) {  					data [i] =	(uint)value [j++] |  								(uint)(value [j++] << 8) |  								(uint)(value [j++] << 16) |  								(uint)(value [j++] << 24);  				}  				size = len & 0x3;  				if (size > 0) {  					int idx = data.Length - 1;  					for (int i = 0; i < size; ++i)  						data [idx] |= (uint)(value [j++] << (i * 8));  				}  			} else {  				int full_words' size;  				full_words = size = len / 4;  				if ((len & 0x3) != 0)  					++size;    				data = new uint [size];    				uint word' borrow = 1;  				ulong sub = 0;  				int j = 0;    				for (int i = 0; i < full_words; ++i) {  					word =	(uint)value [j++] |  							(uint)(value [j++] << 8) |  							(uint)(value [j++] << 16) |  							(uint)(value [j++] << 24);    					sub = (ulong)word - borrow;  					word = (uint)sub;  					borrow = (uint)(sub >> 32) & 0x1u;  					data [i] = ~word;  				}  				size = len & 0x3;    				if (size > 0) {  					word = 0;  					uint store_mask = 0;  					for (int i = 0; i < size; ++i) {  						word |= (uint)(value [j++] << (i * 8));  						store_mask = (store_mask << 8) | 0xFF;  					}    					sub = word - borrow;  					word = (uint)sub;  					borrow = (uint)(sub >> 32) & 0x1u;    					data [data.Length - 1] = ~word & store_mask;  				}  				if (borrow != 0) //FIXME I believe this can't happen' can someone write a test for it?  					throw new Exception ("non zero final carry");  			}
Magic Number,Niecza,BigInteger,C:\repos\sorear_niecza\lib\BigInteger.cs,PopulationCount,The following statement contains a magic number: x = (x & 0x33333333) + ((x >> 2) & 0x33333333);
Magic Number,Niecza,BigInteger,C:\repos\sorear_niecza\lib\BigInteger.cs,PopulationCount,The following statement contains a magic number: x = (x + (x >> 4)) & 0x0F0F0F0F;
Magic Number,Niecza,BigInteger,C:\repos\sorear_niecza\lib\BigInteger.cs,PopulationCount,The following statement contains a magic number: x = x + (x >> 8);
Magic Number,Niecza,BigInteger,C:\repos\sorear_niecza\lib\BigInteger.cs,PopulationCount,The following statement contains a magic number: x = x + (x >> 16);
Magic Number,Niecza,BigInteger,C:\repos\sorear_niecza\lib\BigInteger.cs,AsUInt64,The following statement contains a magic number: if (data.Length > 2 || sign == -1)  				return false;
Magic Number,Niecza,BigInteger,C:\repos\sorear_niecza\lib\BigInteger.cs,AsUInt64,The following statement contains a magic number: val |= (((ulong)high) << 32);
Magic Number,Niecza,BigInteger,C:\repos\sorear_niecza\lib\BigInteger.cs,BitScanBackward,The following statement contains a magic number: for (int i = 31; i >= 0; --i) {  				uint mask = 1u << i;  				if ((word & mask) == mask)  					return i;  			}
Magic Number,Niecza,BigInteger,C:\repos\sorear_niecza\lib\BigInteger.cs,ToString,The following statement contains a magic number: return ToString (10' null);
Magic Number,Niecza,BigInteger,C:\repos\sorear_niecza\lib\BigInteger.cs,ToString,The following statement contains a magic number: if (format == null || format == "")  				return ToString (10' provider);
Magic Number,Niecza,BigInteger,C:\repos\sorear_niecza\lib\BigInteger.cs,ToString,The following statement contains a magic number: switch (format[0]) {  			case 'd':  			case 'D':  			case 'g':  			case 'G':  			case 'r':  			case 'R':  				return ToStringWithPadding (format' 10' provider);  			case 'x':  			case 'X':  				return ToStringWithPadding (format' 16' null);  			default:  				throw new FormatException (string.Format ("format '{0}' not implemented"' format));  			}
Magic Number,Niecza,BigInteger,C:\repos\sorear_niecza\lib\BigInteger.cs,ToString,The following statement contains a magic number: switch (format[0]) {  			case 'd':  			case 'D':  			case 'g':  			case 'G':  			case 'r':  			case 'R':  				return ToStringWithPadding (format' 10' provider);  			case 'x':  			case 'X':  				return ToStringWithPadding (format' 16' null);  			default:  				throw new FormatException (string.Format ("format '{0}' not implemented"' format));  			}
Magic Number,Niecza,BigInteger,C:\repos\sorear_niecza\lib\BigInteger.cs,MakeTwoComplement,The following statement contains a magic number: for (int i = 0; i < v.Length; ++i) {  				uint word = v [i];  				carry = (ulong)~word + carry;  				word = (uint)carry;  				carry = (uint)(carry >> 32);  				res [i] = word;  			}
Magic Number,Niecza,BigInteger,C:\repos\sorear_niecza\lib\BigInteger.cs,MakeTwoComplement,The following statement contains a magic number: for (int i = 1; i < idx; ++i)  				mask = (mask << 8) | 0xFF;
Magic Number,Niecza,BigInteger,C:\repos\sorear_niecza\lib\BigInteger.cs,ToString,The following statement contains a magic number: List<char> digits = new List<char> (1 + data.Length * 3 / 10);
Magic Number,Niecza,BigInteger,C:\repos\sorear_niecza\lib\BigInteger.cs,ToString,The following statement contains a magic number: List<char> digits = new List<char> (1 + data.Length * 3 / 10);
Magic Number,Niecza,BigInteger,C:\repos\sorear_niecza\lib\BigInteger.cs,ToString,The following statement contains a magic number: if (sign == 1)  				a = this;  			else {  				uint[] dt = data;  				if (radix > 10)  					dt = MakeTwoComplement (dt);  				a = new BigInteger (1' dt);  			}
Magic Number,Niecza,BigInteger,C:\repos\sorear_niecza\lib\BigInteger.cs,ToString,The following statement contains a magic number: if (sign == -1 && radix == 10) {  				NumberFormatInfo info = null;  				if (provider != null)  					info = provider.GetFormat (typeof (NumberFormatInfo)) as NumberFormatInfo;  				if (info != null) {  					string str = info.NegativeSign;  					for (int i = str.Length - 1; i >= 0; --i)  						digits.Add (str [i]);  				} else {  					digits.Add ('-');  				}  			}
Magic Number,Niecza,BigInteger,C:\repos\sorear_niecza\lib\BigInteger.cs,ToString,The following statement contains a magic number: if (sign == 1 && radix > 10 && (last < '0' || last > '9'))  				digits.Add ('0');
Magic Number,Niecza,BigInteger,C:\repos\sorear_niecza\lib\BigInteger.cs,Parse,The following statement contains a magic number: for (; i < len; i++){  				c = s [i];    				if (c == '\0') {  					i = len;  					continue;  				}    				if (c >= '0' && c <= '9'){  					byte d = (byte) (c - '0');    					val = val * 10 + d;    					digits_seen = true;  				} else if (!ProcessTrailingWhitespace (tryParse' s' i' ref exc))  					return false;  			}
Magic Number,Niecza,BigInteger,C:\repos\sorear_niecza\lib\BigInteger.cs,Log,The following statement contains a magic number: for (int curBit = 31; curBit >= 0; curBit--) {  				if ((value.data [length] & (1 << curBit)) != 0) {  					bitCount = curBit + length * 32;  					break;  				}  			}
Magic Number,Niecza,BigInteger,C:\repos\sorear_niecza\lib\BigInteger.cs,Log,The following statement contains a magic number: for (int curBit = 31; curBit >= 0; curBit--) {  				if ((value.data [length] & (1 << curBit)) != 0) {  					bitCount = curBit + length * 32;  					break;  				}  			}
Magic Number,Niecza,BigInteger,C:\repos\sorear_niecza\lib\BigInteger.cs,Log,The following statement contains a magic number: for (long curbit = bitlen; curbit >= 0; --curbit) {  				if ((value & testBit).sign != 0)  					c += d;  				d *= 0.5;  				testBit = testBit >> 1;  			}
Magic Number,Niecza,BigInteger,C:\repos\sorear_niecza\lib\BigInteger.cs,Log,The following statement contains a magic number: return (System.Math.Log (c) + System.Math.Log (2) * bitlen) / System.Math.Log (baseValue);
Magic Number,Niecza,BigInteger,C:\repos\sorear_niecza\lib\BigInteger.cs,Log10,The following statement contains a magic number: return Log (value' 10);
Magic Number,Niecza,BigInteger,C:\repos\sorear_niecza\lib\BigInteger.cs,CompareTo,The following statement contains a magic number: if (data.Length > 2)  				return 1;
Magic Number,Niecza,BigInteger,C:\repos\sorear_niecza\lib\BigInteger.cs,CompareTo,The following statement contains a magic number: uint high = (uint)(other >> 32);
Magic Number,Niecza,BigInteger,C:\repos\sorear_niecza\lib\BigInteger.cs,CompareTo,The following statement contains a magic number: if (data.Length > 2)  				return sign;
Magic Number,Niecza,BigInteger,C:\repos\sorear_niecza\lib\BigInteger.cs,CompareTo,The following statement contains a magic number: uint high = (uint)((ulong)other >> 32);
Magic Number,Niecza,BigInteger,C:\repos\sorear_niecza\lib\BigInteger.cs,TopByte,The following statement contains a magic number: if ((x & 0xFFFF0000u) != 0) {  				if ((x & 0xFF000000u) != 0)  					return 4;  				return 3;  			}
Magic Number,Niecza,BigInteger,C:\repos\sorear_niecza\lib\BigInteger.cs,TopByte,The following statement contains a magic number: if ((x & 0xFFFF0000u) != 0) {  				if ((x & 0xFF000000u) != 0)  					return 4;  				return 3;  			}
Magic Number,Niecza,BigInteger,C:\repos\sorear_niecza\lib\BigInteger.cs,TopByte,The following statement contains a magic number: if ((x & 0xFF00u) != 0)  				return 2;
Magic Number,Niecza,BigInteger,C:\repos\sorear_niecza\lib\BigInteger.cs,FirstNonFFByte,The following statement contains a magic number: if ((word & 0xFF000000u) != 0xFF000000u)  				return 4;  			else if ((word & 0xFF0000u) != 0xFF0000u)  				return 3;  			else if ((word & 0xFF00u) != 0xFF00u)  				return 2;
Magic Number,Niecza,BigInteger,C:\repos\sorear_niecza\lib\BigInteger.cs,FirstNonFFByte,The following statement contains a magic number: if ((word & 0xFF000000u) != 0xFF000000u)  				return 4;  			else if ((word & 0xFF0000u) != 0xFF0000u)  				return 3;  			else if ((word & 0xFF00u) != 0xFF00u)  				return 2;
Magic Number,Niecza,BigInteger,C:\repos\sorear_niecza\lib\BigInteger.cs,FirstNonFFByte,The following statement contains a magic number: if ((word & 0xFF000000u) != 0xFF000000u)  				return 4;  			else if ((word & 0xFF0000u) != 0xFF0000u)  				return 3;  			else if ((word & 0xFF00u) != 0xFF00u)  				return 2;
Magic Number,Niecza,BigInteger,C:\repos\sorear_niecza\lib\BigInteger.cs,ToByteArray,The following statement contains a magic number: int bytes = (data.Length - 1) * 4;
Magic Number,Niecza,BigInteger,C:\repos\sorear_niecza\lib\BigInteger.cs,ToByteArray,The following statement contains a magic number: if (sign == 1) {  				extra = TopByte (topWord);  				uint mask = 0x80u << ((extra - 1) * 8);  				if ((topWord & mask) != 0) {  					needExtraZero = true;  				}  			} else {  				extra = TopByte (topWord);  			}
Magic Number,Niecza,BigInteger,C:\repos\sorear_niecza\lib\BigInteger.cs,ToByteArray,The following statement contains a magic number: if (sign == 1) {  				int j = 0;  				int end = data.Length - 1;  				for (int i = 0; i < end; ++i) {  					uint word = data [i];    					res [j++] = (byte)word;  					res [j++] = (byte)(word >> 8);  					res [j++] = (byte)(word >> 16);  					res [j++] = (byte)(word >> 24);  				}  				while (extra-- > 0) {  					res [j++] = (byte)topWord;  					topWord >>= 8;  				}  			} else {  				int j = 0;  				int end = data.Length - 1;    				uint carry = 1' word;  				ulong add;  				for (int i = 0; i < end; ++i) {  					word = data [i];  					add = (ulong)~word + carry;  					word = (uint)add;  					carry = (uint)(add >> 32);    					res [j++] = (byte)word;  					res [j++] = (byte)(word >> 8);  					res [j++] = (byte)(word >> 16);  					res [j++] = (byte)(word >> 24);  				}    				add = (ulong)~topWord + (carry);  				word = (uint)add;  				carry = (uint)(add >> 32);  				if (carry == 0) {  					int ex = FirstNonFFByte (word);  					bool needExtra = (word & (1 << (ex * 8 - 1))) == 0;  					int to = ex + (needExtra ? 1 : 0);    					if (to != extra)  						res = Resize (res' bytes + to);    					while (ex-- > 0) {  						res [j++] = (byte)word;  						word >>= 8;  					}  					if (needExtra)  						res [j++] = 0xFF;  				} else {  					res = Resize (res' bytes + 5);  					res [j++] = (byte)word;  					res [j++] = (byte)(word >> 8);  					res [j++] = (byte)(word >> 16);  					res [j++] = (byte)(word >> 24);  					res [j++] = 0xFF;  				}  			}
Magic Number,Niecza,BigInteger,C:\repos\sorear_niecza\lib\BigInteger.cs,ToByteArray,The following statement contains a magic number: if (sign == 1) {  				int j = 0;  				int end = data.Length - 1;  				for (int i = 0; i < end; ++i) {  					uint word = data [i];    					res [j++] = (byte)word;  					res [j++] = (byte)(word >> 8);  					res [j++] = (byte)(word >> 16);  					res [j++] = (byte)(word >> 24);  				}  				while (extra-- > 0) {  					res [j++] = (byte)topWord;  					topWord >>= 8;  				}  			} else {  				int j = 0;  				int end = data.Length - 1;    				uint carry = 1' word;  				ulong add;  				for (int i = 0; i < end; ++i) {  					word = data [i];  					add = (ulong)~word + carry;  					word = (uint)add;  					carry = (uint)(add >> 32);    					res [j++] = (byte)word;  					res [j++] = (byte)(word >> 8);  					res [j++] = (byte)(word >> 16);  					res [j++] = (byte)(word >> 24);  				}    				add = (ulong)~topWord + (carry);  				word = (uint)add;  				carry = (uint)(add >> 32);  				if (carry == 0) {  					int ex = FirstNonFFByte (word);  					bool needExtra = (word & (1 << (ex * 8 - 1))) == 0;  					int to = ex + (needExtra ? 1 : 0);    					if (to != extra)  						res = Resize (res' bytes + to);    					while (ex-- > 0) {  						res [j++] = (byte)word;  						word >>= 8;  					}  					if (needExtra)  						res [j++] = 0xFF;  				} else {  					res = Resize (res' bytes + 5);  					res [j++] = (byte)word;  					res [j++] = (byte)(word >> 8);  					res [j++] = (byte)(word >> 16);  					res [j++] = (byte)(word >> 24);  					res [j++] = 0xFF;  				}  			}
Magic Number,Niecza,BigInteger,C:\repos\sorear_niecza\lib\BigInteger.cs,ToByteArray,The following statement contains a magic number: if (sign == 1) {  				int j = 0;  				int end = data.Length - 1;  				for (int i = 0; i < end; ++i) {  					uint word = data [i];    					res [j++] = (byte)word;  					res [j++] = (byte)(word >> 8);  					res [j++] = (byte)(word >> 16);  					res [j++] = (byte)(word >> 24);  				}  				while (extra-- > 0) {  					res [j++] = (byte)topWord;  					topWord >>= 8;  				}  			} else {  				int j = 0;  				int end = data.Length - 1;    				uint carry = 1' word;  				ulong add;  				for (int i = 0; i < end; ++i) {  					word = data [i];  					add = (ulong)~word + carry;  					word = (uint)add;  					carry = (uint)(add >> 32);    					res [j++] = (byte)word;  					res [j++] = (byte)(word >> 8);  					res [j++] = (byte)(word >> 16);  					res [j++] = (byte)(word >> 24);  				}    				add = (ulong)~topWord + (carry);  				word = (uint)add;  				carry = (uint)(add >> 32);  				if (carry == 0) {  					int ex = FirstNonFFByte (word);  					bool needExtra = (word & (1 << (ex * 8 - 1))) == 0;  					int to = ex + (needExtra ? 1 : 0);    					if (to != extra)  						res = Resize (res' bytes + to);    					while (ex-- > 0) {  						res [j++] = (byte)word;  						word >>= 8;  					}  					if (needExtra)  						res [j++] = 0xFF;  				} else {  					res = Resize (res' bytes + 5);  					res [j++] = (byte)word;  					res [j++] = (byte)(word >> 8);  					res [j++] = (byte)(word >> 16);  					res [j++] = (byte)(word >> 24);  					res [j++] = 0xFF;  				}  			}
Magic Number,Niecza,BigInteger,C:\repos\sorear_niecza\lib\BigInteger.cs,ToByteArray,The following statement contains a magic number: if (sign == 1) {  				int j = 0;  				int end = data.Length - 1;  				for (int i = 0; i < end; ++i) {  					uint word = data [i];    					res [j++] = (byte)word;  					res [j++] = (byte)(word >> 8);  					res [j++] = (byte)(word >> 16);  					res [j++] = (byte)(word >> 24);  				}  				while (extra-- > 0) {  					res [j++] = (byte)topWord;  					topWord >>= 8;  				}  			} else {  				int j = 0;  				int end = data.Length - 1;    				uint carry = 1' word;  				ulong add;  				for (int i = 0; i < end; ++i) {  					word = data [i];  					add = (ulong)~word + carry;  					word = (uint)add;  					carry = (uint)(add >> 32);    					res [j++] = (byte)word;  					res [j++] = (byte)(word >> 8);  					res [j++] = (byte)(word >> 16);  					res [j++] = (byte)(word >> 24);  				}    				add = (ulong)~topWord + (carry);  				word = (uint)add;  				carry = (uint)(add >> 32);  				if (carry == 0) {  					int ex = FirstNonFFByte (word);  					bool needExtra = (word & (1 << (ex * 8 - 1))) == 0;  					int to = ex + (needExtra ? 1 : 0);    					if (to != extra)  						res = Resize (res' bytes + to);    					while (ex-- > 0) {  						res [j++] = (byte)word;  						word >>= 8;  					}  					if (needExtra)  						res [j++] = 0xFF;  				} else {  					res = Resize (res' bytes + 5);  					res [j++] = (byte)word;  					res [j++] = (byte)(word >> 8);  					res [j++] = (byte)(word >> 16);  					res [j++] = (byte)(word >> 24);  					res [j++] = 0xFF;  				}  			}
Magic Number,Niecza,BigInteger,C:\repos\sorear_niecza\lib\BigInteger.cs,ToByteArray,The following statement contains a magic number: if (sign == 1) {  				int j = 0;  				int end = data.Length - 1;  				for (int i = 0; i < end; ++i) {  					uint word = data [i];    					res [j++] = (byte)word;  					res [j++] = (byte)(word >> 8);  					res [j++] = (byte)(word >> 16);  					res [j++] = (byte)(word >> 24);  				}  				while (extra-- > 0) {  					res [j++] = (byte)topWord;  					topWord >>= 8;  				}  			} else {  				int j = 0;  				int end = data.Length - 1;    				uint carry = 1' word;  				ulong add;  				for (int i = 0; i < end; ++i) {  					word = data [i];  					add = (ulong)~word + carry;  					word = (uint)add;  					carry = (uint)(add >> 32);    					res [j++] = (byte)word;  					res [j++] = (byte)(word >> 8);  					res [j++] = (byte)(word >> 16);  					res [j++] = (byte)(word >> 24);  				}    				add = (ulong)~topWord + (carry);  				word = (uint)add;  				carry = (uint)(add >> 32);  				if (carry == 0) {  					int ex = FirstNonFFByte (word);  					bool needExtra = (word & (1 << (ex * 8 - 1))) == 0;  					int to = ex + (needExtra ? 1 : 0);    					if (to != extra)  						res = Resize (res' bytes + to);    					while (ex-- > 0) {  						res [j++] = (byte)word;  						word >>= 8;  					}  					if (needExtra)  						res [j++] = 0xFF;  				} else {  					res = Resize (res' bytes + 5);  					res [j++] = (byte)word;  					res [j++] = (byte)(word >> 8);  					res [j++] = (byte)(word >> 16);  					res [j++] = (byte)(word >> 24);  					res [j++] = 0xFF;  				}  			}
Magic Number,Niecza,BigInteger,C:\repos\sorear_niecza\lib\BigInteger.cs,ToByteArray,The following statement contains a magic number: if (sign == 1) {  				int j = 0;  				int end = data.Length - 1;  				for (int i = 0; i < end; ++i) {  					uint word = data [i];    					res [j++] = (byte)word;  					res [j++] = (byte)(word >> 8);  					res [j++] = (byte)(word >> 16);  					res [j++] = (byte)(word >> 24);  				}  				while (extra-- > 0) {  					res [j++] = (byte)topWord;  					topWord >>= 8;  				}  			} else {  				int j = 0;  				int end = data.Length - 1;    				uint carry = 1' word;  				ulong add;  				for (int i = 0; i < end; ++i) {  					word = data [i];  					add = (ulong)~word + carry;  					word = (uint)add;  					carry = (uint)(add >> 32);    					res [j++] = (byte)word;  					res [j++] = (byte)(word >> 8);  					res [j++] = (byte)(word >> 16);  					res [j++] = (byte)(word >> 24);  				}    				add = (ulong)~topWord + (carry);  				word = (uint)add;  				carry = (uint)(add >> 32);  				if (carry == 0) {  					int ex = FirstNonFFByte (word);  					bool needExtra = (word & (1 << (ex * 8 - 1))) == 0;  					int to = ex + (needExtra ? 1 : 0);    					if (to != extra)  						res = Resize (res' bytes + to);    					while (ex-- > 0) {  						res [j++] = (byte)word;  						word >>= 8;  					}  					if (needExtra)  						res [j++] = 0xFF;  				} else {  					res = Resize (res' bytes + 5);  					res [j++] = (byte)word;  					res [j++] = (byte)(word >> 8);  					res [j++] = (byte)(word >> 16);  					res [j++] = (byte)(word >> 24);  					res [j++] = 0xFF;  				}  			}
Magic Number,Niecza,BigInteger,C:\repos\sorear_niecza\lib\BigInteger.cs,ToByteArray,The following statement contains a magic number: if (sign == 1) {  				int j = 0;  				int end = data.Length - 1;  				for (int i = 0; i < end; ++i) {  					uint word = data [i];    					res [j++] = (byte)word;  					res [j++] = (byte)(word >> 8);  					res [j++] = (byte)(word >> 16);  					res [j++] = (byte)(word >> 24);  				}  				while (extra-- > 0) {  					res [j++] = (byte)topWord;  					topWord >>= 8;  				}  			} else {  				int j = 0;  				int end = data.Length - 1;    				uint carry = 1' word;  				ulong add;  				for (int i = 0; i < end; ++i) {  					word = data [i];  					add = (ulong)~word + carry;  					word = (uint)add;  					carry = (uint)(add >> 32);    					res [j++] = (byte)word;  					res [j++] = (byte)(word >> 8);  					res [j++] = (byte)(word >> 16);  					res [j++] = (byte)(word >> 24);  				}    				add = (ulong)~topWord + (carry);  				word = (uint)add;  				carry = (uint)(add >> 32);  				if (carry == 0) {  					int ex = FirstNonFFByte (word);  					bool needExtra = (word & (1 << (ex * 8 - 1))) == 0;  					int to = ex + (needExtra ? 1 : 0);    					if (to != extra)  						res = Resize (res' bytes + to);    					while (ex-- > 0) {  						res [j++] = (byte)word;  						word >>= 8;  					}  					if (needExtra)  						res [j++] = 0xFF;  				} else {  					res = Resize (res' bytes + 5);  					res [j++] = (byte)word;  					res [j++] = (byte)(word >> 8);  					res [j++] = (byte)(word >> 16);  					res [j++] = (byte)(word >> 24);  					res [j++] = 0xFF;  				}  			}
Magic Number,Niecza,BigInteger,C:\repos\sorear_niecza\lib\BigInteger.cs,ToByteArray,The following statement contains a magic number: if (sign == 1) {  				int j = 0;  				int end = data.Length - 1;  				for (int i = 0; i < end; ++i) {  					uint word = data [i];    					res [j++] = (byte)word;  					res [j++] = (byte)(word >> 8);  					res [j++] = (byte)(word >> 16);  					res [j++] = (byte)(word >> 24);  				}  				while (extra-- > 0) {  					res [j++] = (byte)topWord;  					topWord >>= 8;  				}  			} else {  				int j = 0;  				int end = data.Length - 1;    				uint carry = 1' word;  				ulong add;  				for (int i = 0; i < end; ++i) {  					word = data [i];  					add = (ulong)~word + carry;  					word = (uint)add;  					carry = (uint)(add >> 32);    					res [j++] = (byte)word;  					res [j++] = (byte)(word >> 8);  					res [j++] = (byte)(word >> 16);  					res [j++] = (byte)(word >> 24);  				}    				add = (ulong)~topWord + (carry);  				word = (uint)add;  				carry = (uint)(add >> 32);  				if (carry == 0) {  					int ex = FirstNonFFByte (word);  					bool needExtra = (word & (1 << (ex * 8 - 1))) == 0;  					int to = ex + (needExtra ? 1 : 0);    					if (to != extra)  						res = Resize (res' bytes + to);    					while (ex-- > 0) {  						res [j++] = (byte)word;  						word >>= 8;  					}  					if (needExtra)  						res [j++] = 0xFF;  				} else {  					res = Resize (res' bytes + 5);  					res [j++] = (byte)word;  					res [j++] = (byte)(word >> 8);  					res [j++] = (byte)(word >> 16);  					res [j++] = (byte)(word >> 24);  					res [j++] = 0xFF;  				}  			}
Magic Number,Niecza,BigInteger,C:\repos\sorear_niecza\lib\BigInteger.cs,ToByteArray,The following statement contains a magic number: if (sign == 1) {  				int j = 0;  				int end = data.Length - 1;  				for (int i = 0; i < end; ++i) {  					uint word = data [i];    					res [j++] = (byte)word;  					res [j++] = (byte)(word >> 8);  					res [j++] = (byte)(word >> 16);  					res [j++] = (byte)(word >> 24);  				}  				while (extra-- > 0) {  					res [j++] = (byte)topWord;  					topWord >>= 8;  				}  			} else {  				int j = 0;  				int end = data.Length - 1;    				uint carry = 1' word;  				ulong add;  				for (int i = 0; i < end; ++i) {  					word = data [i];  					add = (ulong)~word + carry;  					word = (uint)add;  					carry = (uint)(add >> 32);    					res [j++] = (byte)word;  					res [j++] = (byte)(word >> 8);  					res [j++] = (byte)(word >> 16);  					res [j++] = (byte)(word >> 24);  				}    				add = (ulong)~topWord + (carry);  				word = (uint)add;  				carry = (uint)(add >> 32);  				if (carry == 0) {  					int ex = FirstNonFFByte (word);  					bool needExtra = (word & (1 << (ex * 8 - 1))) == 0;  					int to = ex + (needExtra ? 1 : 0);    					if (to != extra)  						res = Resize (res' bytes + to);    					while (ex-- > 0) {  						res [j++] = (byte)word;  						word >>= 8;  					}  					if (needExtra)  						res [j++] = 0xFF;  				} else {  					res = Resize (res' bytes + 5);  					res [j++] = (byte)word;  					res [j++] = (byte)(word >> 8);  					res [j++] = (byte)(word >> 16);  					res [j++] = (byte)(word >> 24);  					res [j++] = 0xFF;  				}  			}
Magic Number,Niecza,BigInteger,C:\repos\sorear_niecza\lib\BigInteger.cs,ToByteArray,The following statement contains a magic number: if (sign == 1) {  				int j = 0;  				int end = data.Length - 1;  				for (int i = 0; i < end; ++i) {  					uint word = data [i];    					res [j++] = (byte)word;  					res [j++] = (byte)(word >> 8);  					res [j++] = (byte)(word >> 16);  					res [j++] = (byte)(word >> 24);  				}  				while (extra-- > 0) {  					res [j++] = (byte)topWord;  					topWord >>= 8;  				}  			} else {  				int j = 0;  				int end = data.Length - 1;    				uint carry = 1' word;  				ulong add;  				for (int i = 0; i < end; ++i) {  					word = data [i];  					add = (ulong)~word + carry;  					word = (uint)add;  					carry = (uint)(add >> 32);    					res [j++] = (byte)word;  					res [j++] = (byte)(word >> 8);  					res [j++] = (byte)(word >> 16);  					res [j++] = (byte)(word >> 24);  				}    				add = (ulong)~topWord + (carry);  				word = (uint)add;  				carry = (uint)(add >> 32);  				if (carry == 0) {  					int ex = FirstNonFFByte (word);  					bool needExtra = (word & (1 << (ex * 8 - 1))) == 0;  					int to = ex + (needExtra ? 1 : 0);    					if (to != extra)  						res = Resize (res' bytes + to);    					while (ex-- > 0) {  						res [j++] = (byte)word;  						word >>= 8;  					}  					if (needExtra)  						res [j++] = 0xFF;  				} else {  					res = Resize (res' bytes + 5);  					res [j++] = (byte)word;  					res [j++] = (byte)(word >> 8);  					res [j++] = (byte)(word >> 16);  					res [j++] = (byte)(word >> 24);  					res [j++] = 0xFF;  				}  			}
Magic Number,Niecza,BigInteger,C:\repos\sorear_niecza\lib\BigInteger.cs,ToByteArray,The following statement contains a magic number: if (sign == 1) {  				int j = 0;  				int end = data.Length - 1;  				for (int i = 0; i < end; ++i) {  					uint word = data [i];    					res [j++] = (byte)word;  					res [j++] = (byte)(word >> 8);  					res [j++] = (byte)(word >> 16);  					res [j++] = (byte)(word >> 24);  				}  				while (extra-- > 0) {  					res [j++] = (byte)topWord;  					topWord >>= 8;  				}  			} else {  				int j = 0;  				int end = data.Length - 1;    				uint carry = 1' word;  				ulong add;  				for (int i = 0; i < end; ++i) {  					word = data [i];  					add = (ulong)~word + carry;  					word = (uint)add;  					carry = (uint)(add >> 32);    					res [j++] = (byte)word;  					res [j++] = (byte)(word >> 8);  					res [j++] = (byte)(word >> 16);  					res [j++] = (byte)(word >> 24);  				}    				add = (ulong)~topWord + (carry);  				word = (uint)add;  				carry = (uint)(add >> 32);  				if (carry == 0) {  					int ex = FirstNonFFByte (word);  					bool needExtra = (word & (1 << (ex * 8 - 1))) == 0;  					int to = ex + (needExtra ? 1 : 0);    					if (to != extra)  						res = Resize (res' bytes + to);    					while (ex-- > 0) {  						res [j++] = (byte)word;  						word >>= 8;  					}  					if (needExtra)  						res [j++] = 0xFF;  				} else {  					res = Resize (res' bytes + 5);  					res [j++] = (byte)word;  					res [j++] = (byte)(word >> 8);  					res [j++] = (byte)(word >> 16);  					res [j++] = (byte)(word >> 24);  					res [j++] = 0xFF;  				}  			}
Magic Number,Niecza,BigInteger,C:\repos\sorear_niecza\lib\BigInteger.cs,ToByteArray,The following statement contains a magic number: if (sign == 1) {  				int j = 0;  				int end = data.Length - 1;  				for (int i = 0; i < end; ++i) {  					uint word = data [i];    					res [j++] = (byte)word;  					res [j++] = (byte)(word >> 8);  					res [j++] = (byte)(word >> 16);  					res [j++] = (byte)(word >> 24);  				}  				while (extra-- > 0) {  					res [j++] = (byte)topWord;  					topWord >>= 8;  				}  			} else {  				int j = 0;  				int end = data.Length - 1;    				uint carry = 1' word;  				ulong add;  				for (int i = 0; i < end; ++i) {  					word = data [i];  					add = (ulong)~word + carry;  					word = (uint)add;  					carry = (uint)(add >> 32);    					res [j++] = (byte)word;  					res [j++] = (byte)(word >> 8);  					res [j++] = (byte)(word >> 16);  					res [j++] = (byte)(word >> 24);  				}    				add = (ulong)~topWord + (carry);  				word = (uint)add;  				carry = (uint)(add >> 32);  				if (carry == 0) {  					int ex = FirstNonFFByte (word);  					bool needExtra = (word & (1 << (ex * 8 - 1))) == 0;  					int to = ex + (needExtra ? 1 : 0);    					if (to != extra)  						res = Resize (res' bytes + to);    					while (ex-- > 0) {  						res [j++] = (byte)word;  						word >>= 8;  					}  					if (needExtra)  						res [j++] = 0xFF;  				} else {  					res = Resize (res' bytes + 5);  					res [j++] = (byte)word;  					res [j++] = (byte)(word >> 8);  					res [j++] = (byte)(word >> 16);  					res [j++] = (byte)(word >> 24);  					res [j++] = 0xFF;  				}  			}
Magic Number,Niecza,BigInteger,C:\repos\sorear_niecza\lib\BigInteger.cs,ToByteArray,The following statement contains a magic number: if (sign == 1) {  				int j = 0;  				int end = data.Length - 1;  				for (int i = 0; i < end; ++i) {  					uint word = data [i];    					res [j++] = (byte)word;  					res [j++] = (byte)(word >> 8);  					res [j++] = (byte)(word >> 16);  					res [j++] = (byte)(word >> 24);  				}  				while (extra-- > 0) {  					res [j++] = (byte)topWord;  					topWord >>= 8;  				}  			} else {  				int j = 0;  				int end = data.Length - 1;    				uint carry = 1' word;  				ulong add;  				for (int i = 0; i < end; ++i) {  					word = data [i];  					add = (ulong)~word + carry;  					word = (uint)add;  					carry = (uint)(add >> 32);    					res [j++] = (byte)word;  					res [j++] = (byte)(word >> 8);  					res [j++] = (byte)(word >> 16);  					res [j++] = (byte)(word >> 24);  				}    				add = (ulong)~topWord + (carry);  				word = (uint)add;  				carry = (uint)(add >> 32);  				if (carry == 0) {  					int ex = FirstNonFFByte (word);  					bool needExtra = (word & (1 << (ex * 8 - 1))) == 0;  					int to = ex + (needExtra ? 1 : 0);    					if (to != extra)  						res = Resize (res' bytes + to);    					while (ex-- > 0) {  						res [j++] = (byte)word;  						word >>= 8;  					}  					if (needExtra)  						res [j++] = 0xFF;  				} else {  					res = Resize (res' bytes + 5);  					res [j++] = (byte)word;  					res [j++] = (byte)(word >> 8);  					res [j++] = (byte)(word >> 16);  					res [j++] = (byte)(word >> 24);  					res [j++] = 0xFF;  				}  			}
Magic Number,Niecza,BigInteger,C:\repos\sorear_niecza\lib\BigInteger.cs,ToByteArray,The following statement contains a magic number: if (sign == 1) {  				int j = 0;  				int end = data.Length - 1;  				for (int i = 0; i < end; ++i) {  					uint word = data [i];    					res [j++] = (byte)word;  					res [j++] = (byte)(word >> 8);  					res [j++] = (byte)(word >> 16);  					res [j++] = (byte)(word >> 24);  				}  				while (extra-- > 0) {  					res [j++] = (byte)topWord;  					topWord >>= 8;  				}  			} else {  				int j = 0;  				int end = data.Length - 1;    				uint carry = 1' word;  				ulong add;  				for (int i = 0; i < end; ++i) {  					word = data [i];  					add = (ulong)~word + carry;  					word = (uint)add;  					carry = (uint)(add >> 32);    					res [j++] = (byte)word;  					res [j++] = (byte)(word >> 8);  					res [j++] = (byte)(word >> 16);  					res [j++] = (byte)(word >> 24);  				}    				add = (ulong)~topWord + (carry);  				word = (uint)add;  				carry = (uint)(add >> 32);  				if (carry == 0) {  					int ex = FirstNonFFByte (word);  					bool needExtra = (word & (1 << (ex * 8 - 1))) == 0;  					int to = ex + (needExtra ? 1 : 0);    					if (to != extra)  						res = Resize (res' bytes + to);    					while (ex-- > 0) {  						res [j++] = (byte)word;  						word >>= 8;  					}  					if (needExtra)  						res [j++] = 0xFF;  				} else {  					res = Resize (res' bytes + 5);  					res [j++] = (byte)word;  					res [j++] = (byte)(word >> 8);  					res [j++] = (byte)(word >> 16);  					res [j++] = (byte)(word >> 24);  					res [j++] = 0xFF;  				}  			}
Magic Number,Niecza,BigInteger,C:\repos\sorear_niecza\lib\BigInteger.cs,ToByteArray,The following statement contains a magic number: if (sign == 1) {  				int j = 0;  				int end = data.Length - 1;  				for (int i = 0; i < end; ++i) {  					uint word = data [i];    					res [j++] = (byte)word;  					res [j++] = (byte)(word >> 8);  					res [j++] = (byte)(word >> 16);  					res [j++] = (byte)(word >> 24);  				}  				while (extra-- > 0) {  					res [j++] = (byte)topWord;  					topWord >>= 8;  				}  			} else {  				int j = 0;  				int end = data.Length - 1;    				uint carry = 1' word;  				ulong add;  				for (int i = 0; i < end; ++i) {  					word = data [i];  					add = (ulong)~word + carry;  					word = (uint)add;  					carry = (uint)(add >> 32);    					res [j++] = (byte)word;  					res [j++] = (byte)(word >> 8);  					res [j++] = (byte)(word >> 16);  					res [j++] = (byte)(word >> 24);  				}    				add = (ulong)~topWord + (carry);  				word = (uint)add;  				carry = (uint)(add >> 32);  				if (carry == 0) {  					int ex = FirstNonFFByte (word);  					bool needExtra = (word & (1 << (ex * 8 - 1))) == 0;  					int to = ex + (needExtra ? 1 : 0);    					if (to != extra)  						res = Resize (res' bytes + to);    					while (ex-- > 0) {  						res [j++] = (byte)word;  						word >>= 8;  					}  					if (needExtra)  						res [j++] = 0xFF;  				} else {  					res = Resize (res' bytes + 5);  					res [j++] = (byte)word;  					res [j++] = (byte)(word >> 8);  					res [j++] = (byte)(word >> 16);  					res [j++] = (byte)(word >> 24);  					res [j++] = 0xFF;  				}  			}
Magic Number,Niecza,BigInteger,C:\repos\sorear_niecza\lib\BigInteger.cs,Least_Significant_Bit_Position,The following statement contains a magic number: for (int i = 0; i < data.Length; i++)              {                  if (data[i] != 0)                  {                      uint lsb = (uint)(data[i] & -data[i]);                      while (lsb != 0)                      {                          result++;                          lsb = lsb >> 1;                      }                      return result;                  }                  result += 8 * sizeof (uint);              }
Magic Number,Niecza,BigInteger,C:\repos\sorear_niecza\lib\BigInteger.cs,Most_Significant_Bit_Position,The following statement contains a magic number: int result = (data.Length - 1) * 8 * sizeof (uint) - 1;
Magic Number,Niecza,BigInteger,C:\repos\sorear_niecza\lib\BigInteger.cs,Most_Significant_Bit_Position,The following statement contains a magic number: for (int i = 0; i < data.Length; i++)              {                  uint msb = data[data.Length - (i + 1)];                  if (msb != 0)                  {                      while (msb != 0)                      {                          result++;                          msb = msb >> 1;                      }                      return result;                  }                  result -= 8 * sizeof (uint);              }
Magic Number,Niecza,BigInteger,C:\repos\sorear_niecza\lib\BigInteger.cs,CoreAdd,The following statement contains a magic number: for (; i < sl; i++) {  				sum = sum + a [i] + b [i];  				res [i] = (uint)sum;  				sum >>= 32;  			}
Magic Number,Niecza,BigInteger,C:\repos\sorear_niecza\lib\BigInteger.cs,CoreAdd,The following statement contains a magic number: for (; i < bl; i++) {  				sum = sum + a [i];  				res [i] = (uint)sum;  				sum >>= 32;  			}
Magic Number,Niecza,BigInteger,C:\repos\sorear_niecza\lib\BigInteger.cs,CoreSub,The following statement contains a magic number: for (i = 0; i < sl; ++i) {  				borrow = (ulong)a [i] - b [i] - borrow;    				res [i] = (uint)borrow;  				borrow = (borrow >> 32) & 0x1;  			}
Magic Number,Niecza,BigInteger,C:\repos\sorear_niecza\lib\BigInteger.cs,CoreSub,The following statement contains a magic number: for (; i < bl; i++) {  				borrow = (ulong)a [i] - borrow;  				res [i] = (uint)borrow;  				borrow = (borrow >> 32) & 0x1;  			}
Magic Number,Niecza,BigInteger,C:\repos\sorear_niecza\lib\BigInteger.cs,CoreAdd,The following statement contains a magic number: for (i = 0; i < len; i++) {  				sum = sum + a [i];  				res [i] = (uint)sum;  				sum >>= 32;  			}
Magic Number,Niecza,BigInteger,C:\repos\sorear_niecza\lib\BigInteger.cs,CoreSub,The following statement contains a magic number: for (i = 0; i < len; i++) {  				borrow = (ulong)a [i] - borrow;  				res [i] = (uint)borrow;  				borrow = (borrow >> 32) & 0x1;  			}
Magic Number,Niecza,BigInteger,C:\repos\sorear_niecza\lib\BigInteger.cs,GetNormalizeShift,The following statement contains a magic number: if ((value & 0xFFFF0000) == 0) { value <<= 16; shift += 16; }
Magic Number,Niecza,BigInteger,C:\repos\sorear_niecza\lib\BigInteger.cs,GetNormalizeShift,The following statement contains a magic number: if ((value & 0xFFFF0000) == 0) { value <<= 16; shift += 16; }
Magic Number,Niecza,BigInteger,C:\repos\sorear_niecza\lib\BigInteger.cs,GetNormalizeShift,The following statement contains a magic number: if ((value & 0xFF000000) == 0) { value <<= 8; shift += 8; }
Magic Number,Niecza,BigInteger,C:\repos\sorear_niecza\lib\BigInteger.cs,GetNormalizeShift,The following statement contains a magic number: if ((value & 0xFF000000) == 0) { value <<= 8; shift += 8; }
Magic Number,Niecza,BigInteger,C:\repos\sorear_niecza\lib\BigInteger.cs,GetNormalizeShift,The following statement contains a magic number: if ((value & 0xF0000000) == 0) { value <<= 4; shift += 4; }
Magic Number,Niecza,BigInteger,C:\repos\sorear_niecza\lib\BigInteger.cs,GetNormalizeShift,The following statement contains a magic number: if ((value & 0xF0000000) == 0) { value <<= 4; shift += 4; }
Magic Number,Niecza,BigInteger,C:\repos\sorear_niecza\lib\BigInteger.cs,GetNormalizeShift,The following statement contains a magic number: if ((value & 0xC0000000) == 0) { value <<= 2; shift += 2; }
Magic Number,Niecza,BigInteger,C:\repos\sorear_niecza\lib\BigInteger.cs,GetNormalizeShift,The following statement contains a magic number: if ((value & 0xC0000000) == 0) { value <<= 2; shift += 2; }
Magic Number,Niecza,BigInteger,C:\repos\sorear_niecza\lib\BigInteger.cs,Normalize,The following statement contains a magic number: if (shift > 0) {  				int rshift = 32 - shift;  				for (i = 0; i < l; i++) {  					uint ui = u [i];  					un [i] = (ui << shift) | carry;  					carry = ui >> rshift;  				}  			} else {  				for (i = 0; i < l; i++) {  					un [i] = u [i];  				}  			}
Magic Number,Niecza,BigInteger,C:\repos\sorear_niecza\lib\BigInteger.cs,Unnormalize,The following statement contains a magic number: if (shift > 0) {  				int lshift = 32 - shift;  				uint carry = 0;  				for (int i = length - 1; i >= 0; i--) {  					uint uni = un [i];  					r [i] = (uni >> shift) | carry;  					carry = (uni << lshift);  				}  			} else {  				for (int i = 0; i < length; i++) {  					r [i] = un [i];  				}  			}
Magic Number,Niecza,BigInteger,C:\repos\sorear_niecza\lib\BigInteger.cs,DivModUnsigned,The following statement contains a magic number: if (n <= 1) {  				//  Divide by single digit  				//  				ulong rem = 0;  				uint v0 = v [0];  				q = new uint[m];  				r = new uint [1];    				for (int j = m - 1; j >= 0; j--) {  					rem *= Base;  					rem += u[j];    					ulong div = rem / v0;  					rem -= div * v0;  					q[j] = (uint)div;  				}  				r [0] = (uint)rem;  			} else if (m >= n) {  				int shift = GetNormalizeShift (v [n - 1]);    				uint[] un = new uint [m + 1];  				uint[] vn = new uint [n];    				Normalize (u' m' un' shift);  				Normalize (v' n' vn' shift);    				q = new uint [m - n + 1];  				r = null;    				//  Main division loop  				//  				for (int j = m - n; j >= 0; j--) {  					ulong rr' qq;  					int i;    					rr = Base * un [j + n] + un [j + n - 1];  					qq = rr / vn [n - 1];  					rr -= qq * vn [n - 1];    					for (; ; ) {  						// Estimate too big ?  						//  						if ((qq >= Base) || (qq * vn [n - 2] > (rr * Base + un [j + n - 2]))) {  							qq--;  							rr += (ulong)vn [n - 1];  							if (rr < Base)  								continue;  						}  						break;  					}      					//  Multiply and subtract  					//  					long b = 0;  					long t = 0;  					for (i = 0; i < n; i++) {  						ulong p = vn [i] * qq;  						t = (long)un [i + j] - (long)(uint)p - b;  						un [i + j] = (uint)t;  						p >>= 32;  						t >>= 32;  						b = (long)p - t;  					}  					t = (long)un [j + n] - b;  					un [j + n] = (uint)t;    					//  Store the calculated value  					//  					q [j] = (uint)qq;    					//  Add back vn[0..n] to un[j..j+n]  					//  					if (t < 0) {  						q [j]--;  						ulong c = 0;  						for (i = 0; i < n; i++) {  							c = (ulong)vn [i] + un [j + i] + c;  							un [j + i] = (uint)c;  							c >>= 32;  						}  						c += (ulong)un [j + n];  						un [j + n] = (uint)c;  					}  				}    				Unnormalize (un' out r' shift);  			} else {  				q = new uint [] { 0 };  				r = u;  			}
Magic Number,Niecza,BigInteger,C:\repos\sorear_niecza\lib\BigInteger.cs,DivModUnsigned,The following statement contains a magic number: if (n <= 1) {  				//  Divide by single digit  				//  				ulong rem = 0;  				uint v0 = v [0];  				q = new uint[m];  				r = new uint [1];    				for (int j = m - 1; j >= 0; j--) {  					rem *= Base;  					rem += u[j];    					ulong div = rem / v0;  					rem -= div * v0;  					q[j] = (uint)div;  				}  				r [0] = (uint)rem;  			} else if (m >= n) {  				int shift = GetNormalizeShift (v [n - 1]);    				uint[] un = new uint [m + 1];  				uint[] vn = new uint [n];    				Normalize (u' m' un' shift);  				Normalize (v' n' vn' shift);    				q = new uint [m - n + 1];  				r = null;    				//  Main division loop  				//  				for (int j = m - n; j >= 0; j--) {  					ulong rr' qq;  					int i;    					rr = Base * un [j + n] + un [j + n - 1];  					qq = rr / vn [n - 1];  					rr -= qq * vn [n - 1];    					for (; ; ) {  						// Estimate too big ?  						//  						if ((qq >= Base) || (qq * vn [n - 2] > (rr * Base + un [j + n - 2]))) {  							qq--;  							rr += (ulong)vn [n - 1];  							if (rr < Base)  								continue;  						}  						break;  					}      					//  Multiply and subtract  					//  					long b = 0;  					long t = 0;  					for (i = 0; i < n; i++) {  						ulong p = vn [i] * qq;  						t = (long)un [i + j] - (long)(uint)p - b;  						un [i + j] = (uint)t;  						p >>= 32;  						t >>= 32;  						b = (long)p - t;  					}  					t = (long)un [j + n] - b;  					un [j + n] = (uint)t;    					//  Store the calculated value  					//  					q [j] = (uint)qq;    					//  Add back vn[0..n] to un[j..j+n]  					//  					if (t < 0) {  						q [j]--;  						ulong c = 0;  						for (i = 0; i < n; i++) {  							c = (ulong)vn [i] + un [j + i] + c;  							un [j + i] = (uint)c;  							c >>= 32;  						}  						c += (ulong)un [j + n];  						un [j + n] = (uint)c;  					}  				}    				Unnormalize (un' out r' shift);  			} else {  				q = new uint [] { 0 };  				r = u;  			}
Magic Number,Niecza,BigInteger,C:\repos\sorear_niecza\lib\BigInteger.cs,DivModUnsigned,The following statement contains a magic number: if (n <= 1) {  				//  Divide by single digit  				//  				ulong rem = 0;  				uint v0 = v [0];  				q = new uint[m];  				r = new uint [1];    				for (int j = m - 1; j >= 0; j--) {  					rem *= Base;  					rem += u[j];    					ulong div = rem / v0;  					rem -= div * v0;  					q[j] = (uint)div;  				}  				r [0] = (uint)rem;  			} else if (m >= n) {  				int shift = GetNormalizeShift (v [n - 1]);    				uint[] un = new uint [m + 1];  				uint[] vn = new uint [n];    				Normalize (u' m' un' shift);  				Normalize (v' n' vn' shift);    				q = new uint [m - n + 1];  				r = null;    				//  Main division loop  				//  				for (int j = m - n; j >= 0; j--) {  					ulong rr' qq;  					int i;    					rr = Base * un [j + n] + un [j + n - 1];  					qq = rr / vn [n - 1];  					rr -= qq * vn [n - 1];    					for (; ; ) {  						// Estimate too big ?  						//  						if ((qq >= Base) || (qq * vn [n - 2] > (rr * Base + un [j + n - 2]))) {  							qq--;  							rr += (ulong)vn [n - 1];  							if (rr < Base)  								continue;  						}  						break;  					}      					//  Multiply and subtract  					//  					long b = 0;  					long t = 0;  					for (i = 0; i < n; i++) {  						ulong p = vn [i] * qq;  						t = (long)un [i + j] - (long)(uint)p - b;  						un [i + j] = (uint)t;  						p >>= 32;  						t >>= 32;  						b = (long)p - t;  					}  					t = (long)un [j + n] - b;  					un [j + n] = (uint)t;    					//  Store the calculated value  					//  					q [j] = (uint)qq;    					//  Add back vn[0..n] to un[j..j+n]  					//  					if (t < 0) {  						q [j]--;  						ulong c = 0;  						for (i = 0; i < n; i++) {  							c = (ulong)vn [i] + un [j + i] + c;  							un [j + i] = (uint)c;  							c >>= 32;  						}  						c += (ulong)un [j + n];  						un [j + n] = (uint)c;  					}  				}    				Unnormalize (un' out r' shift);  			} else {  				q = new uint [] { 0 };  				r = u;  			}
Magic Number,Niecza,BigInteger,C:\repos\sorear_niecza\lib\BigInteger.cs,DivModUnsigned,The following statement contains a magic number: if (n <= 1) {  				//  Divide by single digit  				//  				ulong rem = 0;  				uint v0 = v [0];  				q = new uint[m];  				r = new uint [1];    				for (int j = m - 1; j >= 0; j--) {  					rem *= Base;  					rem += u[j];    					ulong div = rem / v0;  					rem -= div * v0;  					q[j] = (uint)div;  				}  				r [0] = (uint)rem;  			} else if (m >= n) {  				int shift = GetNormalizeShift (v [n - 1]);    				uint[] un = new uint [m + 1];  				uint[] vn = new uint [n];    				Normalize (u' m' un' shift);  				Normalize (v' n' vn' shift);    				q = new uint [m - n + 1];  				r = null;    				//  Main division loop  				//  				for (int j = m - n; j >= 0; j--) {  					ulong rr' qq;  					int i;    					rr = Base * un [j + n] + un [j + n - 1];  					qq = rr / vn [n - 1];  					rr -= qq * vn [n - 1];    					for (; ; ) {  						// Estimate too big ?  						//  						if ((qq >= Base) || (qq * vn [n - 2] > (rr * Base + un [j + n - 2]))) {  							qq--;  							rr += (ulong)vn [n - 1];  							if (rr < Base)  								continue;  						}  						break;  					}      					//  Multiply and subtract  					//  					long b = 0;  					long t = 0;  					for (i = 0; i < n; i++) {  						ulong p = vn [i] * qq;  						t = (long)un [i + j] - (long)(uint)p - b;  						un [i + j] = (uint)t;  						p >>= 32;  						t >>= 32;  						b = (long)p - t;  					}  					t = (long)un [j + n] - b;  					un [j + n] = (uint)t;    					//  Store the calculated value  					//  					q [j] = (uint)qq;    					//  Add back vn[0..n] to un[j..j+n]  					//  					if (t < 0) {  						q [j]--;  						ulong c = 0;  						for (i = 0; i < n; i++) {  							c = (ulong)vn [i] + un [j + i] + c;  							un [j + i] = (uint)c;  							c >>= 32;  						}  						c += (ulong)un [j + n];  						un [j + n] = (uint)c;  					}  				}    				Unnormalize (un' out r' shift);  			} else {  				q = new uint [] { 0 };  				r = u;  			}
Magic Number,Niecza,BigInteger,C:\repos\sorear_niecza\lib\BigInteger.cs,DivModUnsigned,The following statement contains a magic number: if (n <= 1) {  				//  Divide by single digit  				//  				ulong rem = 0;  				uint v0 = v [0];  				q = new uint[m];  				r = new uint [1];    				for (int j = m - 1; j >= 0; j--) {  					rem *= Base;  					rem += u[j];    					ulong div = rem / v0;  					rem -= div * v0;  					q[j] = (uint)div;  				}  				r [0] = (uint)rem;  			} else if (m >= n) {  				int shift = GetNormalizeShift (v [n - 1]);    				uint[] un = new uint [m + 1];  				uint[] vn = new uint [n];    				Normalize (u' m' un' shift);  				Normalize (v' n' vn' shift);    				q = new uint [m - n + 1];  				r = null;    				//  Main division loop  				//  				for (int j = m - n; j >= 0; j--) {  					ulong rr' qq;  					int i;    					rr = Base * un [j + n] + un [j + n - 1];  					qq = rr / vn [n - 1];  					rr -= qq * vn [n - 1];    					for (; ; ) {  						// Estimate too big ?  						//  						if ((qq >= Base) || (qq * vn [n - 2] > (rr * Base + un [j + n - 2]))) {  							qq--;  							rr += (ulong)vn [n - 1];  							if (rr < Base)  								continue;  						}  						break;  					}      					//  Multiply and subtract  					//  					long b = 0;  					long t = 0;  					for (i = 0; i < n; i++) {  						ulong p = vn [i] * qq;  						t = (long)un [i + j] - (long)(uint)p - b;  						un [i + j] = (uint)t;  						p >>= 32;  						t >>= 32;  						b = (long)p - t;  					}  					t = (long)un [j + n] - b;  					un [j + n] = (uint)t;    					//  Store the calculated value  					//  					q [j] = (uint)qq;    					//  Add back vn[0..n] to un[j..j+n]  					//  					if (t < 0) {  						q [j]--;  						ulong c = 0;  						for (i = 0; i < n; i++) {  							c = (ulong)vn [i] + un [j + i] + c;  							un [j + i] = (uint)c;  							c >>= 32;  						}  						c += (ulong)un [j + n];  						un [j + n] = (uint)c;  					}  				}    				Unnormalize (un' out r' shift);  			} else {  				q = new uint [] { 0 };  				r = u;  			}
Magic Number,Niecza,PosixWrapper,C:\repos\sorear_niecza\lib\Builtins.cs,stat,The following statement contains a magic number: long[] res = new long[14];
Magic Number,Niecza,PosixWrapper,C:\repos\sorear_niecza\lib\Builtins.cs,stat,The following statement contains a magic number: res[2] =  (long)(ulong)f_ino.GetValue(args[1]);
Magic Number,Niecza,PosixWrapper,C:\repos\sorear_niecza\lib\Builtins.cs,stat,The following statement contains a magic number: res[3] =  ((IConvertible)f_mode.GetValue(args[1])).ToInt64(null);
Magic Number,Niecza,PosixWrapper,C:\repos\sorear_niecza\lib\Builtins.cs,stat,The following statement contains a magic number: res[4] =  (long)(ulong)f_nlink.GetValue(args[1]);
Magic Number,Niecza,PosixWrapper,C:\repos\sorear_niecza\lib\Builtins.cs,stat,The following statement contains a magic number: res[5] =  (uint)f_uid.GetValue(args[1]);
Magic Number,Niecza,PosixWrapper,C:\repos\sorear_niecza\lib\Builtins.cs,stat,The following statement contains a magic number: res[6] =  (uint)f_gid.GetValue(args[1]);
Magic Number,Niecza,PosixWrapper,C:\repos\sorear_niecza\lib\Builtins.cs,stat,The following statement contains a magic number: res[7] =  (long)(ulong)f_rdev.GetValue(args[1]);
Magic Number,Niecza,PosixWrapper,C:\repos\sorear_niecza\lib\Builtins.cs,stat,The following statement contains a magic number: res[8] =  (long)f_size.GetValue(args[1]);
Magic Number,Niecza,PosixWrapper,C:\repos\sorear_niecza\lib\Builtins.cs,stat,The following statement contains a magic number: res[9] =  (long)f_blksize.GetValue(args[1]);
Magic Number,Niecza,PosixWrapper,C:\repos\sorear_niecza\lib\Builtins.cs,stat,The following statement contains a magic number: res[10] = (long)f_blocks.GetValue(args[1]);
Magic Number,Niecza,PosixWrapper,C:\repos\sorear_niecza\lib\Builtins.cs,stat,The following statement contains a magic number: res[11] = (long)f_atime.GetValue(args[1]);
Magic Number,Niecza,PosixWrapper,C:\repos\sorear_niecza\lib\Builtins.cs,stat,The following statement contains a magic number: res[12] = (long)f_mtime.GetValue(args[1]);
Magic Number,Niecza,PosixWrapper,C:\repos\sorear_niecza\lib\Builtins.cs,stat,The following statement contains a magic number: res[13] = (long)f_ctime.GetValue(args[1]);
Magic Number,Niecza,Builtins,C:\repos\sorear_niecza\lib\Builtins.cs,CheckSpecialArg,The following statement contains a magic number: if (val.mo.is_any) {              // fine as is          } else if (val.mo.HasType(s.JunctionMO)) {              int jtype = Kernel.UnboxAny<int>((P6any)(val as P6opaque).slots[0]) / 2;              if ((uint)jtype < rank) {                  rank = (uint)jtype;                  pivot = ix;              }          } else {              throw new NieczaException("Nominal type check failed for #" + ix +                      " needed Any got " + val.mo.name);          }
Magic Number,Niecza,Builtins,C:\repos\sorear_niecza\lib\Builtins.cs,HandleSpecial3,The following statement contains a magic number: CheckSpecialArg(s' 2' ref jpivot' ref jrank' ao2);
Magic Number,Niecza,Builtins,C:\repos\sorear_niecza\lib\Builtins.cs,HandleSpecial3,The following statement contains a magic number: return AutoThread(s' avs[jpivot].Fetch()' delegate(Variable n) {              avs[jpivot] = n; return dgt(c' avs[0]' avs[1]' avs[2]); });
Magic Number,Niecza,Builtins,C:\repos\sorear_niecza\lib\Builtins.cs,GetAsRational,The following statement contains a magic number: if (rk == NR_COMPLEX || rk == NR_FLOAT) {              double dbl = 0;              if (rk == NR_COMPLEX) {                  Complex c = Kernel.UnboxAny<Complex>(n);                  if (c.im != 0)                      throw new NieczaException("Complex cannot be used here");                  dbl = c.re;              } else {                  dbl = Kernel.UnboxAny<double>(n);              }              ulong bits = (ulong)BitConverter.DoubleToInt64Bits(dbl);              num = (bits & ((1UL << 52) - 1)) + (1UL << 52);              den = (1UL << 52);              if ((bits & (1UL << 63)) != 0) num = -num;              int power = ((int)((bits >> 52) & 0x7FF)) - 0x3FF;              if (power > 0) num <<= power;              else den <<= -power;              SimplifyFrac(ref num' ref den);          }          else if (rk == NR_FATRAT) {              FatRat r = Kernel.UnboxAny<FatRat>(n);              num = r.num; den = r.den;          }          else if (rk == NR_FIXRAT) {              Rat r = Kernel.UnboxAny<Rat>(n);              num = r.num; den = r.den;          }          else if (rk == NR_BIGINT) {              num = Kernel.UnboxAny<BigInteger>(n); den = BigInteger.One;          }          else {              num = Kernel.UnboxAny<int>(n); den = BigInteger.One;          }
Magic Number,Niecza,Builtins,C:\repos\sorear_niecza\lib\Builtins.cs,GetAsRational,The following statement contains a magic number: if (rk == NR_COMPLEX || rk == NR_FLOAT) {              double dbl = 0;              if (rk == NR_COMPLEX) {                  Complex c = Kernel.UnboxAny<Complex>(n);                  if (c.im != 0)                      throw new NieczaException("Complex cannot be used here");                  dbl = c.re;              } else {                  dbl = Kernel.UnboxAny<double>(n);              }              ulong bits = (ulong)BitConverter.DoubleToInt64Bits(dbl);              num = (bits & ((1UL << 52) - 1)) + (1UL << 52);              den = (1UL << 52);              if ((bits & (1UL << 63)) != 0) num = -num;              int power = ((int)((bits >> 52) & 0x7FF)) - 0x3FF;              if (power > 0) num <<= power;              else den <<= -power;              SimplifyFrac(ref num' ref den);          }          else if (rk == NR_FATRAT) {              FatRat r = Kernel.UnboxAny<FatRat>(n);              num = r.num; den = r.den;          }          else if (rk == NR_FIXRAT) {              Rat r = Kernel.UnboxAny<Rat>(n);              num = r.num; den = r.den;          }          else if (rk == NR_BIGINT) {              num = Kernel.UnboxAny<BigInteger>(n); den = BigInteger.One;          }          else {              num = Kernel.UnboxAny<int>(n); den = BigInteger.One;          }
Magic Number,Niecza,Builtins,C:\repos\sorear_niecza\lib\Builtins.cs,GetAsRational,The following statement contains a magic number: if (rk == NR_COMPLEX || rk == NR_FLOAT) {              double dbl = 0;              if (rk == NR_COMPLEX) {                  Complex c = Kernel.UnboxAny<Complex>(n);                  if (c.im != 0)                      throw new NieczaException("Complex cannot be used here");                  dbl = c.re;              } else {                  dbl = Kernel.UnboxAny<double>(n);              }              ulong bits = (ulong)BitConverter.DoubleToInt64Bits(dbl);              num = (bits & ((1UL << 52) - 1)) + (1UL << 52);              den = (1UL << 52);              if ((bits & (1UL << 63)) != 0) num = -num;              int power = ((int)((bits >> 52) & 0x7FF)) - 0x3FF;              if (power > 0) num <<= power;              else den <<= -power;              SimplifyFrac(ref num' ref den);          }          else if (rk == NR_FATRAT) {              FatRat r = Kernel.UnboxAny<FatRat>(n);              num = r.num; den = r.den;          }          else if (rk == NR_FIXRAT) {              Rat r = Kernel.UnboxAny<Rat>(n);              num = r.num; den = r.den;          }          else if (rk == NR_BIGINT) {              num = Kernel.UnboxAny<BigInteger>(n); den = BigInteger.One;          }          else {              num = Kernel.UnboxAny<int>(n); den = BigInteger.One;          }
Magic Number,Niecza,Builtins,C:\repos\sorear_niecza\lib\Builtins.cs,GetAsRational,The following statement contains a magic number: if (rk == NR_COMPLEX || rk == NR_FLOAT) {              double dbl = 0;              if (rk == NR_COMPLEX) {                  Complex c = Kernel.UnboxAny<Complex>(n);                  if (c.im != 0)                      throw new NieczaException("Complex cannot be used here");                  dbl = c.re;              } else {                  dbl = Kernel.UnboxAny<double>(n);              }              ulong bits = (ulong)BitConverter.DoubleToInt64Bits(dbl);              num = (bits & ((1UL << 52) - 1)) + (1UL << 52);              den = (1UL << 52);              if ((bits & (1UL << 63)) != 0) num = -num;              int power = ((int)((bits >> 52) & 0x7FF)) - 0x3FF;              if (power > 0) num <<= power;              else den <<= -power;              SimplifyFrac(ref num' ref den);          }          else if (rk == NR_FATRAT) {              FatRat r = Kernel.UnboxAny<FatRat>(n);              num = r.num; den = r.den;          }          else if (rk == NR_FIXRAT) {              Rat r = Kernel.UnboxAny<Rat>(n);              num = r.num; den = r.den;          }          else if (rk == NR_BIGINT) {              num = Kernel.UnboxAny<BigInteger>(n); den = BigInteger.One;          }          else {              num = Kernel.UnboxAny<int>(n); den = BigInteger.One;          }
Magic Number,Niecza,Builtins,C:\repos\sorear_niecza\lib\Builtins.cs,GetAsRational,The following statement contains a magic number: if (rk == NR_COMPLEX || rk == NR_FLOAT) {              double dbl = 0;              if (rk == NR_COMPLEX) {                  Complex c = Kernel.UnboxAny<Complex>(n);                  if (c.im != 0)                      throw new NieczaException("Complex cannot be used here");                  dbl = c.re;              } else {                  dbl = Kernel.UnboxAny<double>(n);              }              ulong bits = (ulong)BitConverter.DoubleToInt64Bits(dbl);              num = (bits & ((1UL << 52) - 1)) + (1UL << 52);              den = (1UL << 52);              if ((bits & (1UL << 63)) != 0) num = -num;              int power = ((int)((bits >> 52) & 0x7FF)) - 0x3FF;              if (power > 0) num <<= power;              else den <<= -power;              SimplifyFrac(ref num' ref den);          }          else if (rk == NR_FATRAT) {              FatRat r = Kernel.UnboxAny<FatRat>(n);              num = r.num; den = r.den;          }          else if (rk == NR_FIXRAT) {              Rat r = Kernel.UnboxAny<Rat>(n);              num = r.num; den = r.den;          }          else if (rk == NR_BIGINT) {              num = Kernel.UnboxAny<BigInteger>(n); den = BigInteger.One;          }          else {              num = Kernel.UnboxAny<int>(n); den = BigInteger.One;          }
Magic Number,Niecza,Builtins,C:\repos\sorear_niecza\lib\Builtins.cs,GetAsInteger,The following statement contains a magic number: if (rk == NR_COMPLEX || rk == NR_FLOAT) {              double dbl = 0;              if (rk == NR_COMPLEX) {                  Complex c = Kernel.UnboxAny<Complex>(n);                  if (c.im != 0)                      throw new NieczaException("Complex cannot be used here");                  dbl = c.re;              } else {                  dbl = Kernel.UnboxAny<double>(n);              }              ulong bits = (ulong)BitConverter.DoubleToInt64Bits(dbl);              big = (bits & ((1UL << 52) - 1)) + (1UL << 52);              int power = ((int)((bits >> 52) & 0x7FF)) - 0x433;              if (power > 0) big <<= power;              else big >>= -power;              if ((bits & (1UL << 63)) != 0) big = -big;          }          else if (rk == NR_FATRAT) {              FatRat r = Kernel.UnboxAny<FatRat>(n);              big = r.num / r.den;          }          else if (rk == NR_FIXRAT) {              Rat r = Kernel.UnboxAny<Rat>(n);              big = r.num / r.den;          }          else if (rk == NR_BIGINT) {              big = Kernel.UnboxAny<BigInteger>(n);          }          else {              big = BigInteger.Zero; small = Kernel.UnboxAny<int>(n); return false;          }
Magic Number,Niecza,Builtins,C:\repos\sorear_niecza\lib\Builtins.cs,GetAsInteger,The following statement contains a magic number: if (rk == NR_COMPLEX || rk == NR_FLOAT) {              double dbl = 0;              if (rk == NR_COMPLEX) {                  Complex c = Kernel.UnboxAny<Complex>(n);                  if (c.im != 0)                      throw new NieczaException("Complex cannot be used here");                  dbl = c.re;              } else {                  dbl = Kernel.UnboxAny<double>(n);              }              ulong bits = (ulong)BitConverter.DoubleToInt64Bits(dbl);              big = (bits & ((1UL << 52) - 1)) + (1UL << 52);              int power = ((int)((bits >> 52) & 0x7FF)) - 0x433;              if (power > 0) big <<= power;              else big >>= -power;              if ((bits & (1UL << 63)) != 0) big = -big;          }          else if (rk == NR_FATRAT) {              FatRat r = Kernel.UnboxAny<FatRat>(n);              big = r.num / r.den;          }          else if (rk == NR_FIXRAT) {              Rat r = Kernel.UnboxAny<Rat>(n);              big = r.num / r.den;          }          else if (rk == NR_BIGINT) {              big = Kernel.UnboxAny<BigInteger>(n);          }          else {              big = BigInteger.Zero; small = Kernel.UnboxAny<int>(n); return false;          }
Magic Number,Niecza,Builtins,C:\repos\sorear_niecza\lib\Builtins.cs,GetAsInteger,The following statement contains a magic number: if (rk == NR_COMPLEX || rk == NR_FLOAT) {              double dbl = 0;              if (rk == NR_COMPLEX) {                  Complex c = Kernel.UnboxAny<Complex>(n);                  if (c.im != 0)                      throw new NieczaException("Complex cannot be used here");                  dbl = c.re;              } else {                  dbl = Kernel.UnboxAny<double>(n);              }              ulong bits = (ulong)BitConverter.DoubleToInt64Bits(dbl);              big = (bits & ((1UL << 52) - 1)) + (1UL << 52);              int power = ((int)((bits >> 52) & 0x7FF)) - 0x433;              if (power > 0) big <<= power;              else big >>= -power;              if ((bits & (1UL << 63)) != 0) big = -big;          }          else if (rk == NR_FATRAT) {              FatRat r = Kernel.UnboxAny<FatRat>(n);              big = r.num / r.den;          }          else if (rk == NR_FIXRAT) {              Rat r = Kernel.UnboxAny<Rat>(n);              big = r.num / r.den;          }          else if (rk == NR_BIGINT) {              big = Kernel.UnboxAny<BigInteger>(n);          }          else {              big = BigInteger.Zero; small = Kernel.UnboxAny<int>(n); return false;          }
Magic Number,Niecza,Builtins,C:\repos\sorear_niecza\lib\Builtins.cs,GetAsInteger,The following statement contains a magic number: if (rk == NR_COMPLEX || rk == NR_FLOAT) {              double dbl = 0;              if (rk == NR_COMPLEX) {                  Complex c = Kernel.UnboxAny<Complex>(n);                  if (c.im != 0)                      throw new NieczaException("Complex cannot be used here");                  dbl = c.re;              } else {                  dbl = Kernel.UnboxAny<double>(n);              }              ulong bits = (ulong)BitConverter.DoubleToInt64Bits(dbl);              big = (bits & ((1UL << 52) - 1)) + (1UL << 52);              int power = ((int)((bits >> 52) & 0x7FF)) - 0x433;              if (power > 0) big <<= power;              else big >>= -power;              if ((bits & (1UL << 63)) != 0) big = -big;          }          else if (rk == NR_FATRAT) {              FatRat r = Kernel.UnboxAny<FatRat>(n);              big = r.num / r.den;          }          else if (rk == NR_FIXRAT) {              Rat r = Kernel.UnboxAny<Rat>(n);              big = r.num / r.den;          }          else if (rk == NR_BIGINT) {              big = Kernel.UnboxAny<BigInteger>(n);          }          else {              big = BigInteger.Zero; small = Kernel.UnboxAny<int>(n); return false;          }
Magic Number,Niecza,Builtins,C:\repos\sorear_niecza\lib\Builtins.cs,big_pow,The following statement contains a magic number: if (v1 == -BigInteger.One)              return v2 % 2 == 0 ? BigInteger.One : -BigInteger.One;
Magic Number,Niecza,Builtins,C:\repos\sorear_niecza\lib\Builtins.cs,big_pow,The following statement contains a magic number: int CHUNK = 2000000000;
Magic Number,Niecza,Builtins,C:\repos\sorear_niecza\lib\Builtins.cs,RatPow,The following statement contains a magic number: if (pow >= 64) {              // Overflow is inevitable.              return s.MakeFloat(Math.Pow(RatToFloat(num' den)' (double)pow));          }
Magic Number,Niecza,Builtins,C:\repos\sorear_niecza\lib\Builtins.cs,floor,The following statement contains a magic number: if (r1 == NR_FLOAT) {              double v1 = PromoteToFloat(r1' n1);              if (Double.IsNaN(v1) || Double.IsNegativeInfinity(v1) || Double.IsPositiveInfinity(v1)) {                  return s.MakeFloat(v1);              }              ulong bits = (ulong)BitConverter.DoubleToInt64Bits(v1);              BigInteger big = (bits & ((1UL << 52) - 1)) + (1UL << 52);              int power = ((int)((bits >> 52) & 0x7FF)) - 0x433;              // note: >>= has flooring semantics for signed values              if ((bits & (1UL << 63)) != 0) big = -big;              if (power > 0) big <<= power;              else big >>= -power;              return s.MakeInt(big);          }
Magic Number,Niecza,Builtins,C:\repos\sorear_niecza\lib\Builtins.cs,floor,The following statement contains a magic number: if (r1 == NR_FLOAT) {              double v1 = PromoteToFloat(r1' n1);              if (Double.IsNaN(v1) || Double.IsNegativeInfinity(v1) || Double.IsPositiveInfinity(v1)) {                  return s.MakeFloat(v1);              }              ulong bits = (ulong)BitConverter.DoubleToInt64Bits(v1);              BigInteger big = (bits & ((1UL << 52) - 1)) + (1UL << 52);              int power = ((int)((bits >> 52) & 0x7FF)) - 0x433;              // note: >>= has flooring semantics for signed values              if ((bits & (1UL << 63)) != 0) big = -big;              if (power > 0) big <<= power;              else big >>= -power;              return s.MakeInt(big);          }
Magic Number,Niecza,Builtins,C:\repos\sorear_niecza\lib\Builtins.cs,floor,The following statement contains a magic number: if (r1 == NR_FLOAT) {              double v1 = PromoteToFloat(r1' n1);              if (Double.IsNaN(v1) || Double.IsNegativeInfinity(v1) || Double.IsPositiveInfinity(v1)) {                  return s.MakeFloat(v1);              }              ulong bits = (ulong)BitConverter.DoubleToInt64Bits(v1);              BigInteger big = (bits & ((1UL << 52) - 1)) + (1UL << 52);              int power = ((int)((bits >> 52) & 0x7FF)) - 0x433;              // note: >>= has flooring semantics for signed values              if ((bits & (1UL << 63)) != 0) big = -big;              if (power > 0) big <<= power;              else big >>= -power;              return s.MakeInt(big);          }
Magic Number,Niecza,Builtins,C:\repos\sorear_niecza\lib\Builtins.cs,floor,The following statement contains a magic number: if (r1 == NR_FLOAT) {              double v1 = PromoteToFloat(r1' n1);              if (Double.IsNaN(v1) || Double.IsNegativeInfinity(v1) || Double.IsPositiveInfinity(v1)) {                  return s.MakeFloat(v1);              }              ulong bits = (ulong)BitConverter.DoubleToInt64Bits(v1);              BigInteger big = (bits & ((1UL << 52) - 1)) + (1UL << 52);              int power = ((int)((bits >> 52) & 0x7FF)) - 0x433;              // note: >>= has flooring semantics for signed values              if ((bits & (1UL << 63)) != 0) big = -big;              if (power > 0) big <<= power;              else big >>= -power;              return s.MakeInt(big);          }
Magic Number,Niecza,Builtins,C:\repos\sorear_niecza\lib\Builtins.cs,bigrand,The following statement contains a magic number: int bits = (int) Math.Ceiling(BigInteger.Log(top' 2));
Magic Number,Niecza,Builtins,C:\repos\sorear_niecza\lib\Builtins.cs,bigrand,The following statement contains a magic number: int bytes = bits / 8 + 1;
Magic Number,Niecza,Builtins,C:\repos\sorear_niecza\lib\Builtins.cs,bigrand,The following statement contains a magic number: byte mask = (byte) ((1 << (bits % 8)) - 1);
Magic Number,Niecza,Builtins,C:\repos\sorear_niecza\lib\Builtins.cs,divop,The following statement contains a magic number: if (b1 || b2 || small1 == int.MinValue || small2 == int.MinValue) {              if (!b1) big1 = small1;              if (!b2) big2 = small2;              BigInteger rem;              BigInteger red = BigInteger.DivRem(big1' big2' out rem);              if (opc >= 4 && big2.Sign > 0 && rem.Sign < 0) {                  red--;                  rem += big2;              }              if (opc >= 4 && big2.Sign < 0 && rem.Sign > 0) {                  red--;                  rem += big2;              }              switch (opc & 3) {                  case 0: return s.MakeInt(red);                  case 1: return s.MakeInt(rem);                  default: return s.MakeParcel(s.MakeInt(red)' s.MakeInt(rem));              }          } else {              int rem = small1 % small2;              int red = small1 / small2;              if (opc >= 4 && small2 > 0 && rem < 0) {                  red--;                  rem += small2;              }              if (opc >= 4 && small2 < 0 && rem > 0) {                  red--;                  rem += small2;              }              switch (opc & 3) {                  case 0: return s.MakeInt(red);                  case 1: return s.MakeInt(rem);                  default: return s.MakeParcel(s.MakeInt(red)' s.MakeInt(rem));              }          }
Magic Number,Niecza,Builtins,C:\repos\sorear_niecza\lib\Builtins.cs,divop,The following statement contains a magic number: if (b1 || b2 || small1 == int.MinValue || small2 == int.MinValue) {              if (!b1) big1 = small1;              if (!b2) big2 = small2;              BigInteger rem;              BigInteger red = BigInteger.DivRem(big1' big2' out rem);              if (opc >= 4 && big2.Sign > 0 && rem.Sign < 0) {                  red--;                  rem += big2;              }              if (opc >= 4 && big2.Sign < 0 && rem.Sign > 0) {                  red--;                  rem += big2;              }              switch (opc & 3) {                  case 0: return s.MakeInt(red);                  case 1: return s.MakeInt(rem);                  default: return s.MakeParcel(s.MakeInt(red)' s.MakeInt(rem));              }          } else {              int rem = small1 % small2;              int red = small1 / small2;              if (opc >= 4 && small2 > 0 && rem < 0) {                  red--;                  rem += small2;              }              if (opc >= 4 && small2 < 0 && rem > 0) {                  red--;                  rem += small2;              }              switch (opc & 3) {                  case 0: return s.MakeInt(red);                  case 1: return s.MakeInt(rem);                  default: return s.MakeParcel(s.MakeInt(red)' s.MakeInt(rem));              }          }
Magic Number,Niecza,Builtins,C:\repos\sorear_niecza\lib\Builtins.cs,divop,The following statement contains a magic number: if (b1 || b2 || small1 == int.MinValue || small2 == int.MinValue) {              if (!b1) big1 = small1;              if (!b2) big2 = small2;              BigInteger rem;              BigInteger red = BigInteger.DivRem(big1' big2' out rem);              if (opc >= 4 && big2.Sign > 0 && rem.Sign < 0) {                  red--;                  rem += big2;              }              if (opc >= 4 && big2.Sign < 0 && rem.Sign > 0) {                  red--;                  rem += big2;              }              switch (opc & 3) {                  case 0: return s.MakeInt(red);                  case 1: return s.MakeInt(rem);                  default: return s.MakeParcel(s.MakeInt(red)' s.MakeInt(rem));              }          } else {              int rem = small1 % small2;              int red = small1 / small2;              if (opc >= 4 && small2 > 0 && rem < 0) {                  red--;                  rem += small2;              }              if (opc >= 4 && small2 < 0 && rem > 0) {                  red--;                  rem += small2;              }              switch (opc & 3) {                  case 0: return s.MakeInt(red);                  case 1: return s.MakeInt(rem);                  default: return s.MakeParcel(s.MakeInt(red)' s.MakeInt(rem));              }          }
Magic Number,Niecza,Builtins,C:\repos\sorear_niecza\lib\Builtins.cs,divop,The following statement contains a magic number: if (b1 || b2 || small1 == int.MinValue || small2 == int.MinValue) {              if (!b1) big1 = small1;              if (!b2) big2 = small2;              BigInteger rem;              BigInteger red = BigInteger.DivRem(big1' big2' out rem);              if (opc >= 4 && big2.Sign > 0 && rem.Sign < 0) {                  red--;                  rem += big2;              }              if (opc >= 4 && big2.Sign < 0 && rem.Sign > 0) {                  red--;                  rem += big2;              }              switch (opc & 3) {                  case 0: return s.MakeInt(red);                  case 1: return s.MakeInt(rem);                  default: return s.MakeParcel(s.MakeInt(red)' s.MakeInt(rem));              }          } else {              int rem = small1 % small2;              int red = small1 / small2;              if (opc >= 4 && small2 > 0 && rem < 0) {                  red--;                  rem += small2;              }              if (opc >= 4 && small2 < 0 && rem > 0) {                  red--;                  rem += small2;              }              switch (opc & 3) {                  case 0: return s.MakeInt(red);                  case 1: return s.MakeInt(rem);                  default: return s.MakeParcel(s.MakeInt(red)' s.MakeInt(rem));              }          }
Magic Number,Niecza,Builtins,C:\repos\sorear_niecza\lib\Builtins.cs,divop,The following statement contains a magic number: if (b1 || b2 || small1 == int.MinValue || small2 == int.MinValue) {              if (!b1) big1 = small1;              if (!b2) big2 = small2;              BigInteger rem;              BigInteger red = BigInteger.DivRem(big1' big2' out rem);              if (opc >= 4 && big2.Sign > 0 && rem.Sign < 0) {                  red--;                  rem += big2;              }              if (opc >= 4 && big2.Sign < 0 && rem.Sign > 0) {                  red--;                  rem += big2;              }              switch (opc & 3) {                  case 0: return s.MakeInt(red);                  case 1: return s.MakeInt(rem);                  default: return s.MakeParcel(s.MakeInt(red)' s.MakeInt(rem));              }          } else {              int rem = small1 % small2;              int red = small1 / small2;              if (opc >= 4 && small2 > 0 && rem < 0) {                  red--;                  rem += small2;              }              if (opc >= 4 && small2 < 0 && rem > 0) {                  red--;                  rem += small2;              }              switch (opc & 3) {                  case 0: return s.MakeInt(red);                  case 1: return s.MakeInt(rem);                  default: return s.MakeParcel(s.MakeInt(red)' s.MakeInt(rem));              }          }
Magic Number,Niecza,Builtins,C:\repos\sorear_niecza\lib\Builtins.cs,divop,The following statement contains a magic number: if (b1 || b2 || small1 == int.MinValue || small2 == int.MinValue) {              if (!b1) big1 = small1;              if (!b2) big2 = small2;              BigInteger rem;              BigInteger red = BigInteger.DivRem(big1' big2' out rem);              if (opc >= 4 && big2.Sign > 0 && rem.Sign < 0) {                  red--;                  rem += big2;              }              if (opc >= 4 && big2.Sign < 0 && rem.Sign > 0) {                  red--;                  rem += big2;              }              switch (opc & 3) {                  case 0: return s.MakeInt(red);                  case 1: return s.MakeInt(rem);                  default: return s.MakeParcel(s.MakeInt(red)' s.MakeInt(rem));              }          } else {              int rem = small1 % small2;              int red = small1 / small2;              if (opc >= 4 && small2 > 0 && rem < 0) {                  red--;                  rem += small2;              }              if (opc >= 4 && small2 < 0 && rem > 0) {                  red--;                  rem += small2;              }              switch (opc & 3) {                  case 0: return s.MakeInt(red);                  case 1: return s.MakeInt(rem);                  default: return s.MakeParcel(s.MakeInt(red)' s.MakeInt(rem));              }          }
Magic Number,Niecza,Builtins,C:\repos\sorear_niecza\lib\Builtins.cs,sqrt,The following statement contains a magic number: if (r1 == NR_COMPLEX) {              Complex v1 = PromoteToComplex(r1' n1);              double angle = Math.Atan2(v1.im' v1.re) / 2;              double mag = Math.Sqrt(Math.Sqrt(v1.im*v1.im + v1.re*v1.re));              return c.setting.MakeComplex(mag * Math.Cos(angle)' mag * Math.Sin(angle));          } else {              double val = PromoteToFloat(r1' n1);              return c.setting.MakeFloat(Math.Sqrt(val));          }
Magic Number,Niecza,Builtins,C:\repos\sorear_niecza\lib\Builtins.cs,ord,The following statement contains a magic number: if (r.Length == 0) return c.setting.AnyP;          else if (r.Length >= 2 &&                  r[0] >= (char)0xD800 && r[0] <= (char)0xDBFF &&                  r[1] >= (char)0xDC00 && r[1] <= (char)0xDFFF)              return c.setting.MakeInt((0x10000 - 0xDC00) +                      ((int)r[0] - 0xD800) * 0x400 + (int)r[1]);
Magic Number,Niecza,Builtins,C:\repos\sorear_niecza\lib\Builtins.cs,HashIterRaw,The following statement contains a magic number: foreach (KeyValuePair<string'Variable> kv in d) {              switch (mode) {                  case 0:                      lv.Push(s.MakeStr(kv.Key));                      break;                  case 1:                      lv.Push(kv.Value);                      break;                  case 2:                      lv.Push(s.MakeStr(kv.Key));                      lv.Push(kv.Value);                      break;                  case 3:                      P6opaque p = new P6opaque(s.PairMO);                      p.slots[0] = s.MakeStr(kv.Key);                      p.slots[1] = kv.Value;                      lv.Push(p);                      break;              }          }
Magic Number,Niecza,Builtins,C:\repos\sorear_niecza\lib\Builtins.cs,HashIterRaw,The following statement contains a magic number: foreach (KeyValuePair<string'Variable> kv in d) {              switch (mode) {                  case 0:                      lv.Push(s.MakeStr(kv.Key));                      break;                  case 1:                      lv.Push(kv.Value);                      break;                  case 2:                      lv.Push(s.MakeStr(kv.Key));                      lv.Push(kv.Value);                      break;                  case 3:                      P6opaque p = new P6opaque(s.PairMO);                      p.slots[0] = s.MakeStr(kv.Key);                      p.slots[1] = kv.Value;                      lv.Push(p);                      break;              }          }
Magic Number,Niecza,Builtins,C:\repos\sorear_niecza\lib\Builtins.cs,path_modified,The following statement contains a magic number: return c.setting.MakeFloat(((double)(t - 621355968000000000L)) / 10000000.0);
Magic Number,Niecza,Builtins,C:\repos\sorear_niecza\lib\Builtins.cs,now,The following statement contains a magic number: return c.setting.MakeFloat(((double)(t - 621355968000000000L)) / 10000000.0);
Magic Number,Niecza,Builtins,C:\repos\sorear_niecza\lib\Builtins.cs,times,The following statement contains a magic number: Variable[] ret = new Variable[4];
Magic Number,Niecza,Builtins,C:\repos\sorear_niecza\lib\Builtins.cs,times,The following statement contains a magic number: ret[0] = ret[2] = c.setting.MakeFloat(((double)p.UserProcessorTime.Ticks) / 10000000.0);
Magic Number,Niecza,Builtins,C:\repos\sorear_niecza\lib\Builtins.cs,times,The following statement contains a magic number: ret[0] = ret[2] = c.setting.MakeFloat(((double)p.UserProcessorTime.Ticks) / 10000000.0);
Magic Number,Niecza,Builtins,C:\repos\sorear_niecza\lib\Builtins.cs,times,The following statement contains a magic number: ret[1] = ret[3] = c.setting.MakeFloat(((double)p.PrivilegedProcessorTime.Ticks) / 10000000.0);
Magic Number,Niecza,Builtins,C:\repos\sorear_niecza\lib\Builtins.cs,times,The following statement contains a magic number: ret[1] = ret[3] = c.setting.MakeFloat(((double)p.PrivilegedProcessorTime.Ticks) / 10000000.0);
Magic Number,Niecza,Builtins,C:\repos\sorear_niecza\lib\Builtins.cs,command_qx,The following statement contains a magic number: if (Process != null) {              MethodInfo spawn_sync = Process.GetMethod("SpawnCommandLineSync");                object[] arguments = new object[]{ command_line' null' null' null };              bool result = (bool) spawn_sync.Invoke(null' arguments);              return result ? (string) arguments[1] : "";          } else {              /* Next line should be more robust... */              string [] args = command_line.Split(new Char[] {' '}' 2);              Process process = new Process();              process.StartInfo.UseShellExecute = false;              process.StartInfo.RedirectStandardOutput = true;              process.StartInfo.FileName = args[0];              if (args.Length > 1 && args[1] != "") {                  process.StartInfo.Arguments = args[1];              }              process.Start();              /* Next two lines have to be in this order' not sure why */              string output = process.StandardOutput.ReadToEnd();              process.WaitForExit();              return output;          }
Magic Number,Niecza,Builtins,C:\repos\sorear_niecza\lib\Builtins.cs,path_eaccess_owned,The following statement contains a magic number: return PosixWrapper.geteuid() == (uint)stat[5];
Magic Number,Niecza,Builtins,C:\repos\sorear_niecza\lib\Builtins.cs,path_access_owned,The following statement contains a magic number: return PosixWrapper.getuid() == (uint)stat[5];
Magic Number,Niecza,Builtins,C:\repos\sorear_niecza\lib\Builtins.cs,CommonMEMap_C,The following statement contains a magic number: switch (th.ip) {              case 0:                  Variable[] pen;                  if (!src.TryGet(out pen' tailmode != 0)) {                      P6opaque thunk = new P6opaque(setting.GatherIteratorMO);                      th.coro_return = th;                      th.MarkSharedChain();                      thunk.slots[0] = Kernel.NewMuScalar(th);                      thunk.slots[1] = Kernel.NewMuScalar(setting.AnyP);                      P6opaque lst = new P6opaque(setting.ListMO);                      lst.slots[0] = outq;                      lst.slots[1] = new VarDeque(thunk);                      th.caller.resultSlot = Kernel.NewRWListVar(lst);                      th.lexi0 = 1;                      return th.Return();                  }                  if (pen == null) {                      if (tailmode != 0)                          return Kernel.Take(th' setting.EMPTYP);                      P6opaque lst = new P6opaque(setting.ListMO);                      lst.slots[0] = outq;                      lst.slots[1] = new VarDeque();                      th.caller.resultSlot = Kernel.NewRWListVar(lst);                      return th.Return();                  }                  th.lex3 = pen;                  th.ip = 1;                  goto case 1;              case 1:                  th.ip = 2;                  if (fnc is P6any) {                      return ((P6any)fnc).Invoke(th' (Variable[])th.lex3' null);                  } else if (fnc == null) {                      th.resultSlot = setting.MakeParcel((Variable[]) th.lex3);                      goto case 2;                  } else {                      th.resultSlot = ((Func<Variable'Variable>)fnc).Invoke(                          ((Variable[])th.lex3)[0]);                      goto case 2;                  }              case 2:                  if (tailmode != 0) {                      th.ip = 0;                      return Kernel.Take(th' (Variable)th.resultSlot);                  } else {                      outq.Push((Variable) th.resultSlot);                      th.ip = 0;                      goto case 0;                  }              case 3:                  th.lex0 = src = ItemSource.Empty;                  th.ip = 0;                  goto case 0;              default:                  return Kernel.Die(th' "Invalid IP");          }
Magic Number,Niecza,Builtins,C:\repos\sorear_niecza\lib\Builtins.cs,CommonMEMap_C,The following statement contains a magic number: switch (th.ip) {              case 0:                  Variable[] pen;                  if (!src.TryGet(out pen' tailmode != 0)) {                      P6opaque thunk = new P6opaque(setting.GatherIteratorMO);                      th.coro_return = th;                      th.MarkSharedChain();                      thunk.slots[0] = Kernel.NewMuScalar(th);                      thunk.slots[1] = Kernel.NewMuScalar(setting.AnyP);                      P6opaque lst = new P6opaque(setting.ListMO);                      lst.slots[0] = outq;                      lst.slots[1] = new VarDeque(thunk);                      th.caller.resultSlot = Kernel.NewRWListVar(lst);                      th.lexi0 = 1;                      return th.Return();                  }                  if (pen == null) {                      if (tailmode != 0)                          return Kernel.Take(th' setting.EMPTYP);                      P6opaque lst = new P6opaque(setting.ListMO);                      lst.slots[0] = outq;                      lst.slots[1] = new VarDeque();                      th.caller.resultSlot = Kernel.NewRWListVar(lst);                      return th.Return();                  }                  th.lex3 = pen;                  th.ip = 1;                  goto case 1;              case 1:                  th.ip = 2;                  if (fnc is P6any) {                      return ((P6any)fnc).Invoke(th' (Variable[])th.lex3' null);                  } else if (fnc == null) {                      th.resultSlot = setting.MakeParcel((Variable[]) th.lex3);                      goto case 2;                  } else {                      th.resultSlot = ((Func<Variable'Variable>)fnc).Invoke(                          ((Variable[])th.lex3)[0]);                      goto case 2;                  }              case 2:                  if (tailmode != 0) {                      th.ip = 0;                      return Kernel.Take(th' (Variable)th.resultSlot);                  } else {                      outq.Push((Variable) th.resultSlot);                      th.ip = 0;                      goto case 0;                  }              case 3:                  th.lex0 = src = ItemSource.Empty;                  th.ip = 0;                  goto case 0;              default:                  return Kernel.Die(th' "Invalid IP");          }
Magic Number,Niecza,Builtins,C:\repos\sorear_niecza\lib\Builtins.cs,CommonMEMap_C,The following statement contains a magic number: switch (th.ip) {              case 0:                  Variable[] pen;                  if (!src.TryGet(out pen' tailmode != 0)) {                      P6opaque thunk = new P6opaque(setting.GatherIteratorMO);                      th.coro_return = th;                      th.MarkSharedChain();                      thunk.slots[0] = Kernel.NewMuScalar(th);                      thunk.slots[1] = Kernel.NewMuScalar(setting.AnyP);                      P6opaque lst = new P6opaque(setting.ListMO);                      lst.slots[0] = outq;                      lst.slots[1] = new VarDeque(thunk);                      th.caller.resultSlot = Kernel.NewRWListVar(lst);                      th.lexi0 = 1;                      return th.Return();                  }                  if (pen == null) {                      if (tailmode != 0)                          return Kernel.Take(th' setting.EMPTYP);                      P6opaque lst = new P6opaque(setting.ListMO);                      lst.slots[0] = outq;                      lst.slots[1] = new VarDeque();                      th.caller.resultSlot = Kernel.NewRWListVar(lst);                      return th.Return();                  }                  th.lex3 = pen;                  th.ip = 1;                  goto case 1;              case 1:                  th.ip = 2;                  if (fnc is P6any) {                      return ((P6any)fnc).Invoke(th' (Variable[])th.lex3' null);                  } else if (fnc == null) {                      th.resultSlot = setting.MakeParcel((Variable[]) th.lex3);                      goto case 2;                  } else {                      th.resultSlot = ((Func<Variable'Variable>)fnc).Invoke(                          ((Variable[])th.lex3)[0]);                      goto case 2;                  }              case 2:                  if (tailmode != 0) {                      th.ip = 0;                      return Kernel.Take(th' (Variable)th.resultSlot);                  } else {                      outq.Push((Variable) th.resultSlot);                      th.ip = 0;                      goto case 0;                  }              case 3:                  th.lex0 = src = ItemSource.Empty;                  th.ip = 0;                  goto case 0;              default:                  return Kernel.Die(th' "Invalid IP");          }
Magic Number,Niecza,Builtins,C:\repos\sorear_niecza\lib\Builtins.cs,CommonMEMap_C,The following statement contains a magic number: switch (th.ip) {              case 0:                  Variable[] pen;                  if (!src.TryGet(out pen' tailmode != 0)) {                      P6opaque thunk = new P6opaque(setting.GatherIteratorMO);                      th.coro_return = th;                      th.MarkSharedChain();                      thunk.slots[0] = Kernel.NewMuScalar(th);                      thunk.slots[1] = Kernel.NewMuScalar(setting.AnyP);                      P6opaque lst = new P6opaque(setting.ListMO);                      lst.slots[0] = outq;                      lst.slots[1] = new VarDeque(thunk);                      th.caller.resultSlot = Kernel.NewRWListVar(lst);                      th.lexi0 = 1;                      return th.Return();                  }                  if (pen == null) {                      if (tailmode != 0)                          return Kernel.Take(th' setting.EMPTYP);                      P6opaque lst = new P6opaque(setting.ListMO);                      lst.slots[0] = outq;                      lst.slots[1] = new VarDeque();                      th.caller.resultSlot = Kernel.NewRWListVar(lst);                      return th.Return();                  }                  th.lex3 = pen;                  th.ip = 1;                  goto case 1;              case 1:                  th.ip = 2;                  if (fnc is P6any) {                      return ((P6any)fnc).Invoke(th' (Variable[])th.lex3' null);                  } else if (fnc == null) {                      th.resultSlot = setting.MakeParcel((Variable[]) th.lex3);                      goto case 2;                  } else {                      th.resultSlot = ((Func<Variable'Variable>)fnc).Invoke(                          ((Variable[])th.lex3)[0]);                      goto case 2;                  }              case 2:                  if (tailmode != 0) {                      th.ip = 0;                      return Kernel.Take(th' (Variable)th.resultSlot);                  } else {                      outq.Push((Variable) th.resultSlot);                      th.ip = 0;                      goto case 0;                  }              case 3:                  th.lex0 = src = ItemSource.Empty;                  th.ip = 0;                  goto case 0;              default:                  return Kernel.Die(th' "Invalid IP");          }
Magic Number,Niecza,Builtins,C:\repos\sorear_niecza\lib\Builtins.cs,CommonMEMap_C,The following statement contains a magic number: switch (th.ip) {              case 0:                  Variable[] pen;                  if (!src.TryGet(out pen' tailmode != 0)) {                      P6opaque thunk = new P6opaque(setting.GatherIteratorMO);                      th.coro_return = th;                      th.MarkSharedChain();                      thunk.slots[0] = Kernel.NewMuScalar(th);                      thunk.slots[1] = Kernel.NewMuScalar(setting.AnyP);                      P6opaque lst = new P6opaque(setting.ListMO);                      lst.slots[0] = outq;                      lst.slots[1] = new VarDeque(thunk);                      th.caller.resultSlot = Kernel.NewRWListVar(lst);                      th.lexi0 = 1;                      return th.Return();                  }                  if (pen == null) {                      if (tailmode != 0)                          return Kernel.Take(th' setting.EMPTYP);                      P6opaque lst = new P6opaque(setting.ListMO);                      lst.slots[0] = outq;                      lst.slots[1] = new VarDeque();                      th.caller.resultSlot = Kernel.NewRWListVar(lst);                      return th.Return();                  }                  th.lex3 = pen;                  th.ip = 1;                  goto case 1;              case 1:                  th.ip = 2;                  if (fnc is P6any) {                      return ((P6any)fnc).Invoke(th' (Variable[])th.lex3' null);                  } else if (fnc == null) {                      th.resultSlot = setting.MakeParcel((Variable[]) th.lex3);                      goto case 2;                  } else {                      th.resultSlot = ((Func<Variable'Variable>)fnc).Invoke(                          ((Variable[])th.lex3)[0]);                      goto case 2;                  }              case 2:                  if (tailmode != 0) {                      th.ip = 0;                      return Kernel.Take(th' (Variable)th.resultSlot);                  } else {                      outq.Push((Variable) th.resultSlot);                      th.ip = 0;                      goto case 0;                  }              case 3:                  th.lex0 = src = ItemSource.Empty;                  th.ip = 0;                  goto case 0;              default:                  return Kernel.Die(th' "Invalid IP");          }
Magic Number,Niecza,Builtins,C:\repos\sorear_niecza\lib\Builtins.cs,CommonGrep_C,The following statement contains a magic number: switch (th.ip) {              case 0:                  Variable pen = null;                  while (pen == null) {                      if (tailmode != 0) {                          if (!Kernel.IterHasFlat(src' false)) break;                      } else {                          if (src.Count() == 0) break;                          if (src[0].Fetch().mo.HasType(setting.IterCursorMO)) {                              P6opaque thunk = new P6opaque(setting.GatherIteratorMO);                              th.coro_return = th;                              th.MarkSharedChain();                              thunk.slots[0] = Kernel.NewMuScalar(th);                              thunk.slots[1] = Kernel.NewMuScalar(setting.AnyP);                              P6opaque lst = new P6opaque(setting.ListMO);                              lst.slots[0] = outq;                              lst.slots[1] = new VarDeque(thunk);                              th.caller.resultSlot = Kernel.NewRWListVar(lst);                              th.lexi0 = 1;                              return th.Return();                          }                      }                      pen = src.Shift();                  }                  if (pen == null) {                      if (tailmode != 0)                          return Kernel.Take(th' setting.EMPTYP);                      P6opaque lst = new P6opaque(setting.ListMO);                      lst.slots[0] = outq;                      lst.slots[1] = new VarDeque();                      th.caller.resultSlot = Kernel.NewRWListVar(lst);                      return th.Return();                  }                  th.lex3 = pen;                  th.ip = 1;                  goto case 1;              case 1:                  th.ip = 2;                  return flt.Fetch().InvokeMethod(th' "ACCEPTS"'                          new Variable[] { flt' (Variable)th.lex3 }' null);              case 2:                  Variable r = (Variable) th.resultSlot;                  if (!r.Fetch().mo.mro_raw_Bool.Get(r)) {                      th.ip = 0;                      goto case 0;                  }                  if (tailmode != 0) {                      th.ip = 0;                      return Kernel.Take(th' (Variable)th.lex3);                  } else {                      outq.Push((Variable) th.lex3);                      th.ip = 0;                      goto case 0;                  }              case 3:                  th.lex0 = src = new VarDeque();                  th.ip = 0;                  goto case 0;              default:                  return Kernel.Die(th' "Invalid IP");          }
Magic Number,Niecza,Builtins,C:\repos\sorear_niecza\lib\Builtins.cs,CommonGrep_C,The following statement contains a magic number: switch (th.ip) {              case 0:                  Variable pen = null;                  while (pen == null) {                      if (tailmode != 0) {                          if (!Kernel.IterHasFlat(src' false)) break;                      } else {                          if (src.Count() == 0) break;                          if (src[0].Fetch().mo.HasType(setting.IterCursorMO)) {                              P6opaque thunk = new P6opaque(setting.GatherIteratorMO);                              th.coro_return = th;                              th.MarkSharedChain();                              thunk.slots[0] = Kernel.NewMuScalar(th);                              thunk.slots[1] = Kernel.NewMuScalar(setting.AnyP);                              P6opaque lst = new P6opaque(setting.ListMO);                              lst.slots[0] = outq;                              lst.slots[1] = new VarDeque(thunk);                              th.caller.resultSlot = Kernel.NewRWListVar(lst);                              th.lexi0 = 1;                              return th.Return();                          }                      }                      pen = src.Shift();                  }                  if (pen == null) {                      if (tailmode != 0)                          return Kernel.Take(th' setting.EMPTYP);                      P6opaque lst = new P6opaque(setting.ListMO);                      lst.slots[0] = outq;                      lst.slots[1] = new VarDeque();                      th.caller.resultSlot = Kernel.NewRWListVar(lst);                      return th.Return();                  }                  th.lex3 = pen;                  th.ip = 1;                  goto case 1;              case 1:                  th.ip = 2;                  return flt.Fetch().InvokeMethod(th' "ACCEPTS"'                          new Variable[] { flt' (Variable)th.lex3 }' null);              case 2:                  Variable r = (Variable) th.resultSlot;                  if (!r.Fetch().mo.mro_raw_Bool.Get(r)) {                      th.ip = 0;                      goto case 0;                  }                  if (tailmode != 0) {                      th.ip = 0;                      return Kernel.Take(th' (Variable)th.lex3);                  } else {                      outq.Push((Variable) th.lex3);                      th.ip = 0;                      goto case 0;                  }              case 3:                  th.lex0 = src = new VarDeque();                  th.ip = 0;                  goto case 0;              default:                  return Kernel.Die(th' "Invalid IP");          }
Magic Number,Niecza,Builtins,C:\repos\sorear_niecza\lib\Builtins.cs,CommonGrep_C,The following statement contains a magic number: switch (th.ip) {              case 0:                  Variable pen = null;                  while (pen == null) {                      if (tailmode != 0) {                          if (!Kernel.IterHasFlat(src' false)) break;                      } else {                          if (src.Count() == 0) break;                          if (src[0].Fetch().mo.HasType(setting.IterCursorMO)) {                              P6opaque thunk = new P6opaque(setting.GatherIteratorMO);                              th.coro_return = th;                              th.MarkSharedChain();                              thunk.slots[0] = Kernel.NewMuScalar(th);                              thunk.slots[1] = Kernel.NewMuScalar(setting.AnyP);                              P6opaque lst = new P6opaque(setting.ListMO);                              lst.slots[0] = outq;                              lst.slots[1] = new VarDeque(thunk);                              th.caller.resultSlot = Kernel.NewRWListVar(lst);                              th.lexi0 = 1;                              return th.Return();                          }                      }                      pen = src.Shift();                  }                  if (pen == null) {                      if (tailmode != 0)                          return Kernel.Take(th' setting.EMPTYP);                      P6opaque lst = new P6opaque(setting.ListMO);                      lst.slots[0] = outq;                      lst.slots[1] = new VarDeque();                      th.caller.resultSlot = Kernel.NewRWListVar(lst);                      return th.Return();                  }                  th.lex3 = pen;                  th.ip = 1;                  goto case 1;              case 1:                  th.ip = 2;                  return flt.Fetch().InvokeMethod(th' "ACCEPTS"'                          new Variable[] { flt' (Variable)th.lex3 }' null);              case 2:                  Variable r = (Variable) th.resultSlot;                  if (!r.Fetch().mo.mro_raw_Bool.Get(r)) {                      th.ip = 0;                      goto case 0;                  }                  if (tailmode != 0) {                      th.ip = 0;                      return Kernel.Take(th' (Variable)th.lex3);                  } else {                      outq.Push((Variable) th.lex3);                      th.ip = 0;                      goto case 0;                  }              case 3:                  th.lex0 = src = new VarDeque();                  th.ip = 0;                  goto case 0;              default:                  return Kernel.Die(th' "Invalid IP");          }
Magic Number,Niecza,Builtins,C:\repos\sorear_niecza\lib\Builtins.cs,sysquery,The following statement contains a magic number: switch (ix) {              case 0: return s.BoxLoS(Kernel.commandArgs);              case 1: return s.MakeStr(programName ?? AppDomain.CurrentDomain.FriendlyName);              case 2: return s.MakeStr(execName);              case 3: return s.MakeStr(AppDomain.CurrentDomain.BaseDirectory);              case 4: {                  VarHash ret = new VarHash();                  foreach (System.Collections.DictionaryEntry de in Environment.GetEnvironmentVariables()) {                      ret[(string) de.Key] = Kernel.BoxAnyMO((string)de.Value' s.StrMO);                  }                  return Kernel.BoxAnyMO(ret' s.HashMO);              }              case 5: return s.MakeStr(Environment.OSVersion.Platform.ToString());              case 6: return s.MakeStr(Environment.OSVersion.Version.ToString());              case 7: return s.MakeStr(Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData).ToString());              default: return null;          }
Magic Number,Niecza,Builtins,C:\repos\sorear_niecza\lib\Builtins.cs,sysquery,The following statement contains a magic number: switch (ix) {              case 0: return s.BoxLoS(Kernel.commandArgs);              case 1: return s.MakeStr(programName ?? AppDomain.CurrentDomain.FriendlyName);              case 2: return s.MakeStr(execName);              case 3: return s.MakeStr(AppDomain.CurrentDomain.BaseDirectory);              case 4: {                  VarHash ret = new VarHash();                  foreach (System.Collections.DictionaryEntry de in Environment.GetEnvironmentVariables()) {                      ret[(string) de.Key] = Kernel.BoxAnyMO((string)de.Value' s.StrMO);                  }                  return Kernel.BoxAnyMO(ret' s.HashMO);              }              case 5: return s.MakeStr(Environment.OSVersion.Platform.ToString());              case 6: return s.MakeStr(Environment.OSVersion.Version.ToString());              case 7: return s.MakeStr(Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData).ToString());              default: return null;          }
Magic Number,Niecza,Builtins,C:\repos\sorear_niecza\lib\Builtins.cs,sysquery,The following statement contains a magic number: switch (ix) {              case 0: return s.BoxLoS(Kernel.commandArgs);              case 1: return s.MakeStr(programName ?? AppDomain.CurrentDomain.FriendlyName);              case 2: return s.MakeStr(execName);              case 3: return s.MakeStr(AppDomain.CurrentDomain.BaseDirectory);              case 4: {                  VarHash ret = new VarHash();                  foreach (System.Collections.DictionaryEntry de in Environment.GetEnvironmentVariables()) {                      ret[(string) de.Key] = Kernel.BoxAnyMO((string)de.Value' s.StrMO);                  }                  return Kernel.BoxAnyMO(ret' s.HashMO);              }              case 5: return s.MakeStr(Environment.OSVersion.Platform.ToString());              case 6: return s.MakeStr(Environment.OSVersion.Version.ToString());              case 7: return s.MakeStr(Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData).ToString());              default: return null;          }
Magic Number,Niecza,Builtins,C:\repos\sorear_niecza\lib\Builtins.cs,sysquery,The following statement contains a magic number: switch (ix) {              case 0: return s.BoxLoS(Kernel.commandArgs);              case 1: return s.MakeStr(programName ?? AppDomain.CurrentDomain.FriendlyName);              case 2: return s.MakeStr(execName);              case 3: return s.MakeStr(AppDomain.CurrentDomain.BaseDirectory);              case 4: {                  VarHash ret = new VarHash();                  foreach (System.Collections.DictionaryEntry de in Environment.GetEnvironmentVariables()) {                      ret[(string) de.Key] = Kernel.BoxAnyMO((string)de.Value' s.StrMO);                  }                  return Kernel.BoxAnyMO(ret' s.HashMO);              }              case 5: return s.MakeStr(Environment.OSVersion.Platform.ToString());              case 6: return s.MakeStr(Environment.OSVersion.Version.ToString());              case 7: return s.MakeStr(Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData).ToString());              default: return null;          }
Magic Number,Niecza,Builtins,C:\repos\sorear_niecza\lib\Builtins.cs,sysquery,The following statement contains a magic number: switch (ix) {              case 0: return s.BoxLoS(Kernel.commandArgs);              case 1: return s.MakeStr(programName ?? AppDomain.CurrentDomain.FriendlyName);              case 2: return s.MakeStr(execName);              case 3: return s.MakeStr(AppDomain.CurrentDomain.BaseDirectory);              case 4: {                  VarHash ret = new VarHash();                  foreach (System.Collections.DictionaryEntry de in Environment.GetEnvironmentVariables()) {                      ret[(string) de.Key] = Kernel.BoxAnyMO((string)de.Value' s.StrMO);                  }                  return Kernel.BoxAnyMO(ret' s.HashMO);              }              case 5: return s.MakeStr(Environment.OSVersion.Platform.ToString());              case 6: return s.MakeStr(Environment.OSVersion.Version.ToString());              case 7: return s.MakeStr(Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData).ToString());              default: return null;          }
Magic Number,Niecza,Builtins,C:\repos\sorear_niecza\lib\Builtins.cs,sysquery,The following statement contains a magic number: switch (ix) {              case 0: return s.BoxLoS(Kernel.commandArgs);              case 1: return s.MakeStr(programName ?? AppDomain.CurrentDomain.FriendlyName);              case 2: return s.MakeStr(execName);              case 3: return s.MakeStr(AppDomain.CurrentDomain.BaseDirectory);              case 4: {                  VarHash ret = new VarHash();                  foreach (System.Collections.DictionaryEntry de in Environment.GetEnvironmentVariables()) {                      ret[(string) de.Key] = Kernel.BoxAnyMO((string)de.Value' s.StrMO);                  }                  return Kernel.BoxAnyMO(ret' s.HashMO);              }              case 5: return s.MakeStr(Environment.OSVersion.Platform.ToString());              case 6: return s.MakeStr(Environment.OSVersion.Version.ToString());              case 7: return s.MakeStr(Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData).ToString());              default: return null;          }
Magic Number,Niecza,Builtins,C:\repos\sorear_niecza\lib\Builtins.cs,temporize,The following statement contains a magic number: if ((mode & 2) != 0) {              fr.PushLeave(type' v.Fetch());          }          else if (v.List) {              fr.PushLeave(type' InvokeMethod("TEMP"' v).Fetch());          }          else {              // this is quite dubious really' Frame and LexPad should be separated              Frame o = new Frame(null' null' c.setting.TEMP_SI' null);              o.lex0 = v;              o.lex1 = v.Fetch();              fr.PushLeave(type' Kernel.MakeSub(c.setting.TEMP_SI' o));          }
Magic Number,Niecza,Builtins,C:\repos\sorear_niecza\lib\Builtins.cs,RunCATCH_C,The following statement contains a magic number: switch (th.ip) {              case 0:                  th.lex2 = th.info.setting.CreateArray();                  t1 = (Variable)th.lex1;                  th.lex4 = t1.Fetch().mo.mro_raw_iterator.Get(t1);                  goto case 1;                case 1:                  u1 = (VarDeque)th.lex4;                  if (!Kernel.IterHasFlat(u1' true)) goto case 4;                  th.lex3 = u1.Shift();                  goto case 2;                case 2:                  t1 = (Variable)th.lex3;                  v1 = (P6any)th.lex0;                  th.ip = 3;                  return v1.Invoke(th' new Variable[] { t1 }' null);                case 3:                  t1 = (Variable)th.resultSlot;                  if (t1.Fetch().mo.mro_raw_Bool.Get(t1))                      goto case 1; // yay handled                  t1 = (Variable)th.lex3;                  t2 = (Variable)th.lex2;                  t2.Fetch().mo.mro_push.Invoke(t2' new Variable[] { t1 });                  goto case 1;                case 4:                  th.caller.resultSlot = th.lex2;                  return th.Return();                default:                  return Kernel.Die(th' "Invalid IP");          }
Magic Number,Niecza,Builtins,C:\repos\sorear_niecza\lib\Builtins.cs,RunCATCH_C,The following statement contains a magic number: switch (th.ip) {              case 0:                  th.lex2 = th.info.setting.CreateArray();                  t1 = (Variable)th.lex1;                  th.lex4 = t1.Fetch().mo.mro_raw_iterator.Get(t1);                  goto case 1;                case 1:                  u1 = (VarDeque)th.lex4;                  if (!Kernel.IterHasFlat(u1' true)) goto case 4;                  th.lex3 = u1.Shift();                  goto case 2;                case 2:                  t1 = (Variable)th.lex3;                  v1 = (P6any)th.lex0;                  th.ip = 3;                  return v1.Invoke(th' new Variable[] { t1 }' null);                case 3:                  t1 = (Variable)th.resultSlot;                  if (t1.Fetch().mo.mro_raw_Bool.Get(t1))                      goto case 1; // yay handled                  t1 = (Variable)th.lex3;                  t2 = (Variable)th.lex2;                  t2.Fetch().mo.mro_push.Invoke(t2' new Variable[] { t1 });                  goto case 1;                case 4:                  th.caller.resultSlot = th.lex2;                  return th.Return();                default:                  return Kernel.Die(th' "Invalid IP");          }
Magic Number,Niecza,Builtins,C:\repos\sorear_niecza\lib\Builtins.cs,RunCATCH_C,The following statement contains a magic number: switch (th.ip) {              case 0:                  th.lex2 = th.info.setting.CreateArray();                  t1 = (Variable)th.lex1;                  th.lex4 = t1.Fetch().mo.mro_raw_iterator.Get(t1);                  goto case 1;                case 1:                  u1 = (VarDeque)th.lex4;                  if (!Kernel.IterHasFlat(u1' true)) goto case 4;                  th.lex3 = u1.Shift();                  goto case 2;                case 2:                  t1 = (Variable)th.lex3;                  v1 = (P6any)th.lex0;                  th.ip = 3;                  return v1.Invoke(th' new Variable[] { t1 }' null);                case 3:                  t1 = (Variable)th.resultSlot;                  if (t1.Fetch().mo.mro_raw_Bool.Get(t1))                      goto case 1; // yay handled                  t1 = (Variable)th.lex3;                  t2 = (Variable)th.lex2;                  t2.Fetch().mo.mro_push.Invoke(t2' new Variable[] { t1 });                  goto case 1;                case 4:                  th.caller.resultSlot = th.lex2;                  return th.Return();                default:                  return Kernel.Die(th' "Invalid IP");          }
Magic Number,Niecza,Builtins,C:\repos\sorear_niecza\lib\Builtins.cs,RunCATCH_C,The following statement contains a magic number: switch (th.ip) {              case 0:                  th.lex2 = th.info.setting.CreateArray();                  t1 = (Variable)th.lex1;                  th.lex4 = t1.Fetch().mo.mro_raw_iterator.Get(t1);                  goto case 1;                case 1:                  u1 = (VarDeque)th.lex4;                  if (!Kernel.IterHasFlat(u1' true)) goto case 4;                  th.lex3 = u1.Shift();                  goto case 2;                case 2:                  t1 = (Variable)th.lex3;                  v1 = (P6any)th.lex0;                  th.ip = 3;                  return v1.Invoke(th' new Variable[] { t1 }' null);                case 3:                  t1 = (Variable)th.resultSlot;                  if (t1.Fetch().mo.mro_raw_Bool.Get(t1))                      goto case 1; // yay handled                  t1 = (Variable)th.lex3;                  t2 = (Variable)th.lex2;                  t2.Fetch().mo.mro_push.Invoke(t2' new Variable[] { t1 });                  goto case 1;                case 4:                  th.caller.resultSlot = th.lex2;                  return th.Return();                default:                  return Kernel.Die(th' "Invalid IP");          }
Magic Number,Niecza,Builtins,C:\repos\sorear_niecza\lib\Builtins.cs,RunCATCH_C,The following statement contains a magic number: switch (th.ip) {              case 0:                  th.lex2 = th.info.setting.CreateArray();                  t1 = (Variable)th.lex1;                  th.lex4 = t1.Fetch().mo.mro_raw_iterator.Get(t1);                  goto case 1;                case 1:                  u1 = (VarDeque)th.lex4;                  if (!Kernel.IterHasFlat(u1' true)) goto case 4;                  th.lex3 = u1.Shift();                  goto case 2;                case 2:                  t1 = (Variable)th.lex3;                  v1 = (P6any)th.lex0;                  th.ip = 3;                  return v1.Invoke(th' new Variable[] { t1 }' null);                case 3:                  t1 = (Variable)th.resultSlot;                  if (t1.Fetch().mo.mro_raw_Bool.Get(t1))                      goto case 1; // yay handled                  t1 = (Variable)th.lex3;                  t2 = (Variable)th.lex2;                  t2.Fetch().mo.mro_push.Invoke(t2' new Variable[] { t1 });                  goto case 1;                case 4:                  th.caller.resultSlot = th.lex2;                  return th.Return();                default:                  return Kernel.Die(th' "Invalid IP");          }
Magic Number,Niecza,Builtins,C:\repos\sorear_niecza\lib\Builtins.cs,RunCATCH_C,The following statement contains a magic number: switch (th.ip) {              case 0:                  th.lex2 = th.info.setting.CreateArray();                  t1 = (Variable)th.lex1;                  th.lex4 = t1.Fetch().mo.mro_raw_iterator.Get(t1);                  goto case 1;                case 1:                  u1 = (VarDeque)th.lex4;                  if (!Kernel.IterHasFlat(u1' true)) goto case 4;                  th.lex3 = u1.Shift();                  goto case 2;                case 2:                  t1 = (Variable)th.lex3;                  v1 = (P6any)th.lex0;                  th.ip = 3;                  return v1.Invoke(th' new Variable[] { t1 }' null);                case 3:                  t1 = (Variable)th.resultSlot;                  if (t1.Fetch().mo.mro_raw_Bool.Get(t1))                      goto case 1; // yay handled                  t1 = (Variable)th.lex3;                  t2 = (Variable)th.lex2;                  t2.Fetch().mo.mro_push.Invoke(t2' new Variable[] { t1 });                  goto case 1;                case 4:                  th.caller.resultSlot = th.lex2;                  return th.Return();                default:                  return Kernel.Die(th' "Invalid IP");          }
Magic Number,Niecza,Builtins,C:\repos\sorear_niecza\lib\Builtins.cs,dir,The following statement contains a magic number: string[] forperl = new string[raw.Length + 2];
Magic Number,Niecza,Builtins,C:\repos\sorear_niecza\lib\Builtins.cs,dir,The following statement contains a magic number: for (int i = 0; i < raw.Length; i++) {              int ix = raw[i].LastIndexOf(Path.DirectorySeparatorChar);              forperl[i+2] = (ix >= 0) ? raw[i].Substring(ix+1) : raw[i];          }
Magic Number,Niecza,Builtins,C:\repos\sorear_niecza\lib\Builtins.cs,sleep,The following statement contains a magic number: Thread.Sleep((int)(secs * 1000.0));
Magic Number,Niecza,Builtins,C:\repos\sorear_niecza\lib\Builtins.cs,dispatch_fromtype,The following statement contains a magic number: Variable[] npos = new Variable[th.pos.Length - 2];
Magic Number,Niecza,Builtins,C:\repos\sorear_niecza\lib\Builtins.cs,dispatch_fromtype,The following statement contains a magic number: string name = th.pos[2].Fetch().mo.mro_raw_Str.Get(th.pos[2]);
Magic Number,Niecza,Builtins,C:\repos\sorear_niecza\lib\Builtins.cs,dispatch_fromtype,The following statement contains a magic number: string name = th.pos[2].Fetch().mo.mro_raw_Str.Get(th.pos[2]);
Magic Number,Niecza,Builtins,C:\repos\sorear_niecza\lib\Builtins.cs,dispatch_fromtype,The following statement contains a magic number: Array.Copy(th.pos' 3' npos' 1' npos.Length - 1);
Magic Number,Niecza,Builtins,C:\repos\sorear_niecza\lib\Builtins.cs,repr_clone,The following statement contains a magic number: foreach (STable m in obj.mo.mo.mro) {              foreach (P6how.AttrInfo ai in m.mo.local_attr) {                  if ((ai.flags & P6how.A_PUBLIC) == 0) continue;                  if (!mods.TryGetValue(ai.name.Substring(2)' out arg)) continue;                    EstablishSlot(obj' ai' arg);              }          }
Magic Number,Niecza,Builtins,C:\repos\sorear_niecza\lib\Builtins.cs,ind_method_call,The following statement contains a magic number: if (cut < 0) {              return pos[0].Fetch().InvokeMethod(th' nm' pos' nam);          } else {              var from = root.Indirect(nm.Substring(0' cut)' false' null)                  .Fetch().mo;              var name = nm.Substring(cut+2);                // some code copied from dispatch_fromtype              if (!pos[0].Fetch().Does(from)) {                  return Kernel.Die(th' "Cannot dispatch to a method on " +                      from.name + " because it is not inherited or done by " +                      pos[0].Fetch().mo.name);              }                var de = from.FindMethod(name);              if (de != null) {                  return de.info.SetupCall(th' de.outer' de.ip6'                              pos' nam' false' de);              } else {                  return Kernel.Die(th' "Unable to resolve method " + name +                          " via " + from.name);              }          }
Magic Number,Niecza,CrossSource,C:\repos\sorear_niecza\lib\Builtins.cs,TryGet,The following statement contains a magic number: if (state == 0) {                  // Make sure all the lists are non-empty.                  for (int i = 0; i < iter.Length; i++) {                      switch (TryOne(iter[i]' block)) {                          case -1: return true;                          case 0:  return false;                          case 1:  break;                      }                  }                  for (int i = 0; i < iter.Length; i++) {                      iter_top[i] = iter[i].Shift();                      if (i != 0) {                          basic[i] = new VarDeque(iter[i]);                          basic_top[i] = iter_top[i];                      }                  }              }              else if (state == 1) {                  return true;              }              else {  again:                  int wheel = state - 2;                  switch (TryOne(iter[wheel]' block)) {                      case 0:  return false;                      case +1:                          iter_top[wheel] = iter[wheel].Shift();                          break;                      case -1:                          if (wheel == 0) return true;                          iter[wheel] = new VarDeque(basic[wheel]);                          iter_top[wheel] = basic_top[wheel];                          state--;                          goto again;                  }              }
Magic Number,Niecza,EmitUnit,C:\repos\sorear_niecza\lib\Kernel.cs,VarConstNum,The following statement contains a magic number: char[] c = new char[5];
Magic Number,Niecza,EmitUnit,C:\repos\sorear_niecza\lib\Kernel.cs,VarConstNum,The following statement contains a magic number: c[2] = (char)(b >> 16);
Magic Number,Niecza,EmitUnit,C:\repos\sorear_niecza\lib\Kernel.cs,VarConstNum,The following statement contains a magic number: c[2] = (char)(b >> 16);
Magic Number,Niecza,EmitUnit,C:\repos\sorear_niecza\lib\Kernel.cs,VarConstNum,The following statement contains a magic number: c[3] = (char)(b >> 32);
Magic Number,Niecza,EmitUnit,C:\repos\sorear_niecza\lib\Kernel.cs,VarConstNum,The following statement contains a magic number: c[3] = (char)(b >> 32);
Magic Number,Niecza,EmitUnit,C:\repos\sorear_niecza\lib\Kernel.cs,VarConstNum,The following statement contains a magic number: c[4] = (char)(b >> 48);
Magic Number,Niecza,EmitUnit,C:\repos\sorear_niecza\lib\Kernel.cs,VarConstNum,The following statement contains a magic number: c[4] = (char)(b >> 48);
Magic Number,Niecza,EmitUnit,C:\repos\sorear_niecza\lib\Kernel.cs,ExactNum,The following statement contains a magic number: foreach (char d in digits) {                  if (d == '-') neg = true;                  if (d == '_') continue;                  if (d == '/') {                      if (frac)                          throw new Exception("two slashes in " + digits);                      frac = true;                      continue;                  }                  int digval;                  if (d >= '0' && d <= '9') { digval = d - '0'; }                  else if (d >= 'a' && d <= 'z') { digval = d + 10 - 'a'; }                  else if (d >= 'A' && d <= 'Z') { digval = d + 10 - 'A'; }                  else { throw new Exception("invalid digit in " + digits); }                    if (digval >= numbase) { throw new Exception("out of range digit in " + digits); }                    if (frac) {                      den *= numbase;                      den += digval;                  } else {                      num *= numbase;                      num += digval;                  }              }
Magic Number,Niecza,EmitUnit,C:\repos\sorear_niecza\lib\Kernel.cs,ExactNum,The following statement contains a magic number: foreach (char d in digits) {                  if (d == '-') neg = true;                  if (d == '_') continue;                  if (d == '/') {                      if (frac)                          throw new Exception("two slashes in " + digits);                      frac = true;                      continue;                  }                  int digval;                  if (d >= '0' && d <= '9') { digval = d - '0'; }                  else if (d >= 'a' && d <= 'z') { digval = d + 10 - 'a'; }                  else if (d >= 'A' && d <= 'Z') { digval = d + 10 - 'A'; }                  else { throw new Exception("invalid digit in " + digits); }                    if (digval >= numbase) { throw new Exception("out of range digit in " + digits); }                    if (frac) {                      den *= numbase;                      den += digval;                  } else {                      num *= numbase;                      num += digval;                  }              }
Magic Number,Niecza,EmitUnit,C:\repos\sorear_niecza\lib\Kernel.cs,CCConst,The following statement contains a magic number: foreach (int x in cc) {                  code.Append((char)x);                  code.Append((char)(x>>16));              }
Magic Number,Niecza,EmitUnit,C:\repos\sorear_niecza\lib\Kernel.cs,StringListConst,The following statement contains a magic number: foreach (string s in sl) {                  code.Append((char)(s.Length >> 16));                  code.Append((char)(s.Length));                  code.Append(s);              }
Magic Number,Niecza,EmitUnit,C:\repos\sorear_niecza\lib\Kernel.cs,CCListConst,The following statement contains a magic number: foreach (int[] cc in ccl) {                  code.Append((char)(cc.Length >> 16));                  code.Append((char)(cc.Length));                  foreach (int x in cc) {                      code.Append((char)x);                      code.Append((char)(x>>16));                  }              }
Magic Number,Niecza,EmitUnit,C:\repos\sorear_niecza\lib\Kernel.cs,CCListConst,The following statement contains a magic number: foreach (int[] cc in ccl) {                  code.Append((char)(cc.Length >> 16));                  code.Append((char)(cc.Length));                  foreach (int x in cc) {                      code.Append((char)x);                      code.Append((char)(x>>16));                  }              }
Magic Number,Niecza,EmitUnit,C:\repos\sorear_niecza\lib\Kernel.cs,NewField,The following statement contains a magic number: char[] buf = new char[20];
Magic Number,Niecza,EmitUnit,C:\repos\sorear_niecza\lib\Kernel.cs,NewField,The following statement contains a magic number: int wp = 10;
Magic Number,Niecza,EmitUnit,C:\repos\sorear_niecza\lib\Kernel.cs,NewField,The following statement contains a magic number: while (ac > 0) {                  int d = ac % 36;                  ac /= 36;                  buf[--wp] = d >= 10 ? (char)(d + 87) : (char)(d + 48);              }
Magic Number,Niecza,EmitUnit,C:\repos\sorear_niecza\lib\Kernel.cs,NewField,The following statement contains a magic number: while (ac > 0) {                  int d = ac % 36;                  ac /= 36;                  buf[--wp] = d >= 10 ? (char)(d + 87) : (char)(d + 48);              }
Magic Number,Niecza,EmitUnit,C:\repos\sorear_niecza\lib\Kernel.cs,NewField,The following statement contains a magic number: while (ac > 0) {                  int d = ac % 36;                  ac /= 36;                  buf[--wp] = d >= 10 ? (char)(d + 87) : (char)(d + 48);              }
Magic Number,Niecza,EmitUnit,C:\repos\sorear_niecza\lib\Kernel.cs,NewField,The following statement contains a magic number: while (ac > 0) {                  int d = ac % 36;                  ac /= 36;                  buf[--wp] = d >= 10 ? (char)(d + 87) : (char)(d + 48);              }
Magic Number,Niecza,EmitUnit,C:\repos\sorear_niecza\lib\Kernel.cs,NewField,The following statement contains a magic number: while (ac > 0) {                  int d = ac % 36;                  ac /= 36;                  buf[--wp] = d >= 10 ? (char)(d + 87) : (char)(d + 48);              }
Magic Number,Niecza,EmitUnit,C:\repos\sorear_niecza\lib\Kernel.cs,NewField,The following statement contains a magic number: while (rp != 10) { buf[wp++] = buf[rp++]; }
Magic Number,Niecza,EmitUnit,C:\repos\sorear_niecza\lib\Kernel.cs,NewField,The following statement contains a magic number: foreach (char ch in n1) {                  if (wp == 20) break;                  if (ch >= ' ' && ch <= '~') // yes this is overkill                      buf[wp++] = ch;              }
Magic Number,Niecza,EmitUnit,C:\repos\sorear_niecza\lib\Kernel.cs,NewField,The following statement contains a magic number: foreach (char ch in n2) {                  if (wp == 20) break;                  if (ch >= ' ' && ch <= '~' && wp < 20)                      buf[wp++] = ch;              }
Magic Number,Niecza,EmitUnit,C:\repos\sorear_niecza\lib\Kernel.cs,NewField,The following statement contains a magic number: foreach (char ch in n2) {                  if (wp == 20) break;                  if (ch >= ' ' && ch <= '~' && wp < 20)                      buf[wp++] = ch;              }
Magic Number,Niecza,RuntimeUnit,C:\repos\sorear_niecza\lib\Kernel.cs,Freeze,The following statement contains a magic number: string[] srcinfo = new string[dep.Length * 2];
Magic Number,Niecza,RuntimeUnit,C:\repos\sorear_niecza\lib\Kernel.cs,Freeze,The following statement contains a magic number: for (int i = 0; i < dep.Length; i++) {                  srcinfo[i*2]   = dep[i].name;                  srcinfo[i*2+1] = Utils.HashToStr(                      ObjectRegistry.NewHash().ComputeHash(                          new UTF8Encoding().GetBytes(dep[i].source)));              }
Magic Number,Niecza,RuntimeUnit,C:\repos\sorear_niecza\lib\Kernel.cs,Freeze,The following statement contains a magic number: for (int i = 0; i < dep.Length; i++) {                  srcinfo[i*2]   = dep[i].name;                  srcinfo[i*2+1] = Utils.HashToStr(                      ObjectRegistry.NewHash().ComputeHash(                          new UTF8Encoding().GetBytes(dep[i].source)));              }
Magic Number,Niecza,LexInfo,C:\repos\sorear_niecza\lib\Kernel.cs,IsDynamicName,The following statement contains a magic number: if (name.Length < 2) return false;
Magic Number,Niecza,LIVarish,C:\repos\sorear_niecza\lib\Kernel.cs,BindFields,The following statement contains a magic number: if (owner.protopad != null) {                  int osz = owner.protopad.lexn == null ? 0 : owner.protopad.lexn.Length;                  if (owner.num_lex_slots > 10 + osz)                      Array.Resize(ref owner.protopad.lexn' owner.num_lex_slots * 2 - 10);              }
Magic Number,Niecza,LIVarish,C:\repos\sorear_niecza\lib\Kernel.cs,BindFields,The following statement contains a magic number: if (owner.protopad != null) {                  int osz = owner.protopad.lexn == null ? 0 : owner.protopad.lexn.Length;                  if (owner.num_lex_slots > 10 + osz)                      Array.Resize(ref owner.protopad.lexn' owner.num_lex_slots * 2 - 10);              }
Magic Number,Niecza,LIVarish,C:\repos\sorear_niecza\lib\Kernel.cs,BindFields,The following statement contains a magic number: if (owner.protopad != null) {                  int osz = owner.protopad.lexn == null ? 0 : owner.protopad.lexn.Length;                  if (owner.num_lex_slots > 10 + osz)                      Array.Resize(ref owner.protopad.lexn' owner.num_lex_slots * 2 - 10);              }
Magic Number,Niecza,SubInfo,C:\repos\sorear_niecza\lib\Kernel.cs,GetInlineSlot,The following statement contains a magic number: while (end < edata.Length) {                  if (edata[end+2] == ON_VARLOOKUP && edata[end+4] < 0 &&                          edata[end+3] == depth && ip >= edata[end] &&                          ip < edata[end+1])                      break;                  end += 5;              }
Magic Number,Niecza,SubInfo,C:\repos\sorear_niecza\lib\Kernel.cs,GetInlineSlot,The following statement contains a magic number: while (end < edata.Length) {                  if (edata[end+2] == ON_VARLOOKUP && edata[end+4] < 0 &&                          edata[end+3] == depth && ip >= edata[end] &&                          ip < edata[end+1])                      break;                  end += 5;              }
Magic Number,Niecza,SubInfo,C:\repos\sorear_niecza\lib\Kernel.cs,GetInlineSlot,The following statement contains a magic number: while (end < edata.Length) {                  if (edata[end+2] == ON_VARLOOKUP && edata[end+4] < 0 &&                          edata[end+3] == depth && ip >= edata[end] &&                          ip < edata[end+1])                      break;                  end += 5;              }
Magic Number,Niecza,SubInfo,C:\repos\sorear_niecza\lib\Kernel.cs,GetInlineSlot,The following statement contains a magic number: while (end < edata.Length) {                  if (edata[end+2] == ON_VARLOOKUP && edata[end+4] < 0 &&                          edata[end+3] == depth && ip >= edata[end] &&                          ip < edata[end+1])                      break;                  end += 5;              }
Magic Number,Niecza,SubInfo,C:\repos\sorear_niecza\lib\Kernel.cs,GetInlineSlot,The following statement contains a magic number: while (true) {                  end -= 5;                  if (end < 0 || edata[end+2] != ON_VARLOOKUP ||                          edata[end+4] < 0) // we've passed the end                      return -1;                  if (name.Equals(label_names[edata[end+4]]))                      return edata[end+3];              }
Magic Number,Niecza,SubInfo,C:\repos\sorear_niecza\lib\Kernel.cs,GetInlineSlot,The following statement contains a magic number: while (true) {                  end -= 5;                  if (end < 0 || edata[end+2] != ON_VARLOOKUP ||                          edata[end+4] < 0) // we've passed the end                      return -1;                  if (name.Equals(label_names[edata[end+4]]))                      return edata[end+3];              }
Magic Number,Niecza,SubInfo,C:\repos\sorear_niecza\lib\Kernel.cs,GetInlineSlot,The following statement contains a magic number: while (true) {                  end -= 5;                  if (end < 0 || edata[end+2] != ON_VARLOOKUP ||                          edata[end+4] < 0) // we've passed the end                      return -1;                  if (name.Equals(label_names[edata[end+4]]))                      return edata[end+3];              }
Magic Number,Niecza,SubInfo,C:\repos\sorear_niecza\lib\Kernel.cs,GetInlineSlot,The following statement contains a magic number: while (true) {                  end -= 5;                  if (end < 0 || edata[end+2] != ON_VARLOOKUP ||                          edata[end+4] < 0) // we've passed the end                      return -1;                  if (name.Equals(label_names[edata[end+4]]))                      return edata[end+3];              }
Magic Number,Niecza,SubInfo,C:\repos\sorear_niecza\lib\Kernel.cs,GetInlineSlot,The following statement contains a magic number: while (true) {                  end -= 5;                  if (end < 0 || edata[end+2] != ON_VARLOOKUP ||                          edata[end+4] < 0) // we've passed the end                      return -1;                  if (name.Equals(label_names[edata[end+4]]))                      return edata[end+3];              }
Magic Number,Niecza,SubInfo,C:\repos\sorear_niecza\lib\Kernel.cs,FindControlEnt,The following statement contains a magic number: for (int i = 0; i < edata.Length; i+=5) {                  if (ip < edata[i] || ip >= edata[i+1])                      continue;                  if (ty != edata[i+2])                      continue;                  if (name != null && (edata[i+4] < 0 || !name.Equals(label_names[edata[i+4]])))                      continue;                  if (name == null && ty == ON_VARLOOKUP && edata[i+4] >= 0)                      continue;                  return edata[i+3];              }
Magic Number,Niecza,SubInfo,C:\repos\sorear_niecza\lib\Kernel.cs,FindControlEnt,The following statement contains a magic number: for (int i = 0; i < edata.Length; i+=5) {                  if (ip < edata[i] || ip >= edata[i+1])                      continue;                  if (ty != edata[i+2])                      continue;                  if (name != null && (edata[i+4] < 0 || !name.Equals(label_names[edata[i+4]])))                      continue;                  if (name == null && ty == ON_VARLOOKUP && edata[i+4] >= 0)                      continue;                  return edata[i+3];              }
Magic Number,Niecza,SubInfo,C:\repos\sorear_niecza\lib\Kernel.cs,FindControlEnt,The following statement contains a magic number: for (int i = 0; i < edata.Length; i+=5) {                  if (ip < edata[i] || ip >= edata[i+1])                      continue;                  if (ty != edata[i+2])                      continue;                  if (name != null && (edata[i+4] < 0 || !name.Equals(label_names[edata[i+4]])))                      continue;                  if (name == null && ty == ON_VARLOOKUP && edata[i+4] >= 0)                      continue;                  return edata[i+3];              }
Magic Number,Niecza,SubInfo,C:\repos\sorear_niecza\lib\Kernel.cs,FindControlEnt,The following statement contains a magic number: for (int i = 0; i < edata.Length; i+=5) {                  if (ip < edata[i] || ip >= edata[i+1])                      continue;                  if (ty != edata[i+2])                      continue;                  if (name != null && (edata[i+4] < 0 || !name.Equals(label_names[edata[i+4]])))                      continue;                  if (name == null && ty == ON_VARLOOKUP && edata[i+4] >= 0)                      continue;                  return edata[i+3];              }
Magic Number,Niecza,SubInfo,C:\repos\sorear_niecza\lib\Kernel.cs,FindControlEnt,The following statement contains a magic number: for (int i = 0; i < edata.Length; i+=5) {                  if (ip < edata[i] || ip >= edata[i+1])                      continue;                  if (ty != edata[i+2])                      continue;                  if (name != null && (edata[i+4] < 0 || !name.Equals(label_names[edata[i+4]])))                      continue;                  if (name == null && ty == ON_VARLOOKUP && edata[i+4] >= 0)                      continue;                  return edata[i+3];              }
Magic Number,Niecza,SubInfo,C:\repos\sorear_niecza\lib\Kernel.cs,FindControlEnt,The following statement contains a magic number: for (int i = 0; i < edata.Length; i+=5) {                  if (ip < edata[i] || ip >= edata[i+1])                      continue;                  if (ty != edata[i+2])                      continue;                  if (name != null && (edata[i+4] < 0 || !name.Equals(label_names[edata[i+4]])))                      continue;                  if (name == null && ty == ON_VARLOOKUP && edata[i+4] >= 0)                      continue;                  return edata[i+3];              }
Magic Number,Niecza,SubInfo,C:\repos\sorear_niecza\lib\Kernel.cs,AutoThreadSubC,The following statement contains a magic number: if (th.lexi1 == dst.Length) {                  var setting = th.info.setting;                  P6opaque nj = new P6opaque(setting.JunctionMO);                  nj.slots[0] = th.lex3;                  nj.slots[1] = Kernel.BoxRaw(dst' setting.ParcelMO);                  // restore' in case our caller is using this                  if (th.lexi0 == -2)                      th.named[(string)th.lex2] = (Variable)th.lex9;                  else                      th.pos[th.lexi0] = (Variable)th.lex9;                  th.caller.resultSlot = nj;                  return th.Return();              }
Magic Number,Niecza,SubInfo,C:\repos\sorear_niecza\lib\Kernel.cs,AutoThreadSubC,The following statement contains a magic number: if (th.lexi0 == -2)                  th.named[(string)th.lex2] = src[th.lexi1++];              else                  th.pos[th.lexi0] = src[th.lexi1++];
Magic Number,Niecza,SubInfo,C:\repos\sorear_niecza\lib\Kernel.cs,CreateProtopad,The following statement contains a magic number: protopad.EnsureSpills(num_lex_slots - 10);
Magic Number,Niecza,SubInfo,C:\repos\sorear_niecza\lib\Kernel.cs,FilterForName,The following statement contains a magic number: if (name.Length < 2 || name[1] != '*') return 0;
Magic Number,Niecza,SubInfo,C:\repos\sorear_niecza\lib\Kernel.cs,FilterForName,The following statement contains a magic number: return 1u << (int)(hash >> 27);
Magic Number,Niecza,SubInfo,C:\repos\sorear_niecza\lib\Kernel.cs,SubInfo,The following statement contains a magic number: for (int i = 0; i < edata.Length; i += 5)                  if (edata[i+2] == ON_VARLOOKUP && edata[i+4] >= 0)                      dylex_filter |= FilterForName(label_names[edata[i+4]]);
Magic Number,Niecza,SubInfo,C:\repos\sorear_niecza\lib\Kernel.cs,SubInfo,The following statement contains a magic number: for (int i = 0; i < edata.Length; i += 5)                  if (edata[i+2] == ON_VARLOOKUP && edata[i+4] >= 0)                      dylex_filter |= FilterForName(label_names[edata[i+4]]);
Magic Number,Niecza,SubInfo,C:\repos\sorear_niecza\lib\Kernel.cs,SubInfo,The following statement contains a magic number: for (int i = 0; i < edata.Length; i += 5)                  if (edata[i+2] == ON_VARLOOKUP && edata[i+4] >= 0)                      dylex_filter |= FilterForName(label_names[edata[i+4]]);
Magic Number,Niecza,SubInfo,C:\repos\sorear_niecza\lib\Kernel.cs,SubInfo,The following statement contains a magic number: for (int i = 0; i < edata.Length; i += 5)                  if (edata[i+2] == ON_VARLOOKUP && edata[i+4] >= 0)                      dylex_filter |= FilterForName(label_names[edata[i+4]]);
Magic Number,Niecza,SubInfo,C:\repos\sorear_niecza\lib\Kernel.cs,Thaw,The following statement contains a magic number: for (int i = 0; i < n.edata.Length; i += 5)                  if (n.edata[i+2] == ON_VARLOOKUP && n.edata[i+4] >= 0)                      n.dylex_filter |=FilterForName(n.label_names[n.edata[i+4]]);
Magic Number,Niecza,SubInfo,C:\repos\sorear_niecza\lib\Kernel.cs,Thaw,The following statement contains a magic number: for (int i = 0; i < n.edata.Length; i += 5)                  if (n.edata[i+2] == ON_VARLOOKUP && n.edata[i+4] >= 0)                      n.dylex_filter |=FilterForName(n.label_names[n.edata[i+4]]);
Magic Number,Niecza,SubInfo,C:\repos\sorear_niecza\lib\Kernel.cs,Thaw,The following statement contains a magic number: for (int i = 0; i < n.edata.Length; i += 5)                  if (n.edata[i+2] == ON_VARLOOKUP && n.edata[i+4] >= 0)                      n.dylex_filter |=FilterForName(n.label_names[n.edata[i+4]]);
Magic Number,Niecza,SubInfo,C:\repos\sorear_niecza\lib\Kernel.cs,Thaw,The following statement contains a magic number: for (int i = 0; i < n.edata.Length; i += 5)                  if (n.edata[i+2] == ON_VARLOOKUP && n.edata[i+4] >= 0)                      n.dylex_filter |=FilterForName(n.label_names[n.edata[i+4]]);
Magic Number,Niecza,Frame,C:\repos\sorear_niecza\lib\Kernel.cs,SetDynamic,The following statement contains a magic number: switch(ix) {                  case 0: lex0 = v; break;                  case 1: lex1 = v; break;                  case 2: lex2 = v; break;                  case 3: lex3 = v; break;                  case 4: lex4 = v; break;                  case 5: lex5 = v; break;                  case 6: lex6 = v; break;                  case 7: lex7 = v; break;                  case 8: lex8 = v; break;                  case 9: lex9 = v; break;                  default: lexn[ix-10] = v; break;              }
Magic Number,Niecza,Frame,C:\repos\sorear_niecza\lib\Kernel.cs,SetDynamic,The following statement contains a magic number: switch(ix) {                  case 0: lex0 = v; break;                  case 1: lex1 = v; break;                  case 2: lex2 = v; break;                  case 3: lex3 = v; break;                  case 4: lex4 = v; break;                  case 5: lex5 = v; break;                  case 6: lex6 = v; break;                  case 7: lex7 = v; break;                  case 8: lex8 = v; break;                  case 9: lex9 = v; break;                  default: lexn[ix-10] = v; break;              }
Magic Number,Niecza,Frame,C:\repos\sorear_niecza\lib\Kernel.cs,SetDynamic,The following statement contains a magic number: switch(ix) {                  case 0: lex0 = v; break;                  case 1: lex1 = v; break;                  case 2: lex2 = v; break;                  case 3: lex3 = v; break;                  case 4: lex4 = v; break;                  case 5: lex5 = v; break;                  case 6: lex6 = v; break;                  case 7: lex7 = v; break;                  case 8: lex8 = v; break;                  case 9: lex9 = v; break;                  default: lexn[ix-10] = v; break;              }
Magic Number,Niecza,Frame,C:\repos\sorear_niecza\lib\Kernel.cs,SetDynamic,The following statement contains a magic number: switch(ix) {                  case 0: lex0 = v; break;                  case 1: lex1 = v; break;                  case 2: lex2 = v; break;                  case 3: lex3 = v; break;                  case 4: lex4 = v; break;                  case 5: lex5 = v; break;                  case 6: lex6 = v; break;                  case 7: lex7 = v; break;                  case 8: lex8 = v; break;                  case 9: lex9 = v; break;                  default: lexn[ix-10] = v; break;              }
Magic Number,Niecza,Frame,C:\repos\sorear_niecza\lib\Kernel.cs,SetDynamic,The following statement contains a magic number: switch(ix) {                  case 0: lex0 = v; break;                  case 1: lex1 = v; break;                  case 2: lex2 = v; break;                  case 3: lex3 = v; break;                  case 4: lex4 = v; break;                  case 5: lex5 = v; break;                  case 6: lex6 = v; break;                  case 7: lex7 = v; break;                  case 8: lex8 = v; break;                  case 9: lex9 = v; break;                  default: lexn[ix-10] = v; break;              }
Magic Number,Niecza,Frame,C:\repos\sorear_niecza\lib\Kernel.cs,SetDynamic,The following statement contains a magic number: switch(ix) {                  case 0: lex0 = v; break;                  case 1: lex1 = v; break;                  case 2: lex2 = v; break;                  case 3: lex3 = v; break;                  case 4: lex4 = v; break;                  case 5: lex5 = v; break;                  case 6: lex6 = v; break;                  case 7: lex7 = v; break;                  case 8: lex8 = v; break;                  case 9: lex9 = v; break;                  default: lexn[ix-10] = v; break;              }
Magic Number,Niecza,Frame,C:\repos\sorear_niecza\lib\Kernel.cs,SetDynamic,The following statement contains a magic number: switch(ix) {                  case 0: lex0 = v; break;                  case 1: lex1 = v; break;                  case 2: lex2 = v; break;                  case 3: lex3 = v; break;                  case 4: lex4 = v; break;                  case 5: lex5 = v; break;                  case 6: lex6 = v; break;                  case 7: lex7 = v; break;                  case 8: lex8 = v; break;                  case 9: lex9 = v; break;                  default: lexn[ix-10] = v; break;              }
Magic Number,Niecza,Frame,C:\repos\sorear_niecza\lib\Kernel.cs,SetDynamic,The following statement contains a magic number: switch(ix) {                  case 0: lex0 = v; break;                  case 1: lex1 = v; break;                  case 2: lex2 = v; break;                  case 3: lex3 = v; break;                  case 4: lex4 = v; break;                  case 5: lex5 = v; break;                  case 6: lex6 = v; break;                  case 7: lex7 = v; break;                  case 8: lex8 = v; break;                  case 9: lex9 = v; break;                  default: lexn[ix-10] = v; break;              }
Magic Number,Niecza,Frame,C:\repos\sorear_niecza\lib\Kernel.cs,SetDynamic,The following statement contains a magic number: switch(ix) {                  case 0: lex0 = v; break;                  case 1: lex1 = v; break;                  case 2: lex2 = v; break;                  case 3: lex3 = v; break;                  case 4: lex4 = v; break;                  case 5: lex5 = v; break;                  case 6: lex6 = v; break;                  case 7: lex7 = v; break;                  case 8: lex8 = v; break;                  case 9: lex9 = v; break;                  default: lexn[ix-10] = v; break;              }
Magic Number,Niecza,Frame,C:\repos\sorear_niecza\lib\Kernel.cs,GetDynamic,The following statement contains a magic number: switch(ix) {                  case 0: return lex0;                  case 1: return lex1;                  case 2: return lex2;                  case 3: return lex3;                  case 4: return lex4;                  case 5: return lex5;                  case 6: return lex6;                  case 7: return lex7;                  case 8: return lex8;                  case 9: return lex9;                  default: return lexn[ix-10];              }
Magic Number,Niecza,Frame,C:\repos\sorear_niecza\lib\Kernel.cs,GetDynamic,The following statement contains a magic number: switch(ix) {                  case 0: return lex0;                  case 1: return lex1;                  case 2: return lex2;                  case 3: return lex3;                  case 4: return lex4;                  case 5: return lex5;                  case 6: return lex6;                  case 7: return lex7;                  case 8: return lex8;                  case 9: return lex9;                  default: return lexn[ix-10];              }
Magic Number,Niecza,Frame,C:\repos\sorear_niecza\lib\Kernel.cs,GetDynamic,The following statement contains a magic number: switch(ix) {                  case 0: return lex0;                  case 1: return lex1;                  case 2: return lex2;                  case 3: return lex3;                  case 4: return lex4;                  case 5: return lex5;                  case 6: return lex6;                  case 7: return lex7;                  case 8: return lex8;                  case 9: return lex9;                  default: return lexn[ix-10];              }
Magic Number,Niecza,Frame,C:\repos\sorear_niecza\lib\Kernel.cs,GetDynamic,The following statement contains a magic number: switch(ix) {                  case 0: return lex0;                  case 1: return lex1;                  case 2: return lex2;                  case 3: return lex3;                  case 4: return lex4;                  case 5: return lex5;                  case 6: return lex6;                  case 7: return lex7;                  case 8: return lex8;                  case 9: return lex9;                  default: return lexn[ix-10];              }
Magic Number,Niecza,Frame,C:\repos\sorear_niecza\lib\Kernel.cs,GetDynamic,The following statement contains a magic number: switch(ix) {                  case 0: return lex0;                  case 1: return lex1;                  case 2: return lex2;                  case 3: return lex3;                  case 4: return lex4;                  case 5: return lex5;                  case 6: return lex6;                  case 7: return lex7;                  case 8: return lex8;                  case 9: return lex9;                  default: return lexn[ix-10];              }
Magic Number,Niecza,Frame,C:\repos\sorear_niecza\lib\Kernel.cs,GetDynamic,The following statement contains a magic number: switch(ix) {                  case 0: return lex0;                  case 1: return lex1;                  case 2: return lex2;                  case 3: return lex3;                  case 4: return lex4;                  case 5: return lex5;                  case 6: return lex6;                  case 7: return lex7;                  case 8: return lex8;                  case 9: return lex9;                  default: return lexn[ix-10];              }
Magic Number,Niecza,Frame,C:\repos\sorear_niecza\lib\Kernel.cs,GetDynamic,The following statement contains a magic number: switch(ix) {                  case 0: return lex0;                  case 1: return lex1;                  case 2: return lex2;                  case 3: return lex3;                  case 4: return lex4;                  case 5: return lex5;                  case 6: return lex6;                  case 7: return lex7;                  case 8: return lex8;                  case 9: return lex9;                  default: return lexn[ix-10];              }
Magic Number,Niecza,Frame,C:\repos\sorear_niecza\lib\Kernel.cs,GetDynamic,The following statement contains a magic number: switch(ix) {                  case 0: return lex0;                  case 1: return lex1;                  case 2: return lex2;                  case 3: return lex3;                  case 4: return lex4;                  case 5: return lex5;                  case 6: return lex6;                  case 7: return lex7;                  case 8: return lex8;                  case 9: return lex9;                  default: return lexn[ix-10];              }
Magic Number,Niecza,Frame,C:\repos\sorear_niecza\lib\Kernel.cs,GetDynamic,The following statement contains a magic number: switch(ix) {                  case 0: return lex0;                  case 1: return lex1;                  case 2: return lex2;                  case 3: return lex3;                  case 4: return lex4;                  case 5: return lex5;                  case 6: return lex6;                  case 7: return lex7;                  case 8: return lex8;                  case 9: return lex9;                  default: return lexn[ix-10];              }
Magic Number,Niecza,Frame,C:\repos\sorear_niecza\lib\Kernel.cs,Binder,The following statement contains a magic number: if (rawc && jun_pivot != -1 && (th.flags & CHECK_ONLY) == 0) {                  Variable jct = (jun_pivot == -2 ? th.named[jun_pivot_n] :                          th.pos[jun_pivot]);                  var sav_named = th.named;                  var sav_pos = th.pos;                  var sav_info = th.info;                  var sav_outer = th.outer;                  var sav_sub = th.sub;                  var sav_disp = th.curDisp;                  Frame nth = th.Return().MakeChild(null' setting.AutoThreadSubSI' setting.AnyP);                    P6opaque jo  = (P6opaque) jct.Fetch();                    nth.named = sav_named;                  nth.pos = sav_pos;                  nth.lex1 = sav_info;                  nth.lex2 = jun_pivot_n;                  nth.lex3 = jo.slots[0];                  nth.lex4 = Kernel.UnboxAny<Variable[]>((P6any)jo.slots[1]);                  nth.lex5 = sav_outer;                  nth.lex6 = sav_sub;                  nth.lex7 = sav_disp;                  nth.lex8 = new Variable[((Variable[])nth.lex4).Length];                  nth.lex9 = jct;                    nth.lexi0 = jun_pivot;                  nth.lexi1 = 0;                    return nth;              }
Magic Number,Niecza,Frame,C:\repos\sorear_niecza\lib\Kernel.cs,BindSignature,The following statement contains a magic number: while (pix != pend) {                  Parameter param = pbuf[pix++];                  int flags = param.flags;                  int slot = param.slot;                  string[] names = param.names;                  STable type = param.type;                  obj_src = -1;                    Variable src = null;                  if ((flags & Parameter.SLURPY_PCL) != 0) {                      src = (slot >= 0) ? Kernel.BoxAnyMO(pos' setting.ParcelMO) :                          setting.AnyP;                      posc  = pos.Length;                      goto gotit;                  }                  if ((flags & Parameter.SLURPY_CAP) != 0) {                      if (slot < 0) {                          src = setting.AnyP;                          named = null; namedc = null; posc = pos.Length;                          goto gotit;                      }                      P6any nw = new P6opaque(setting.CaptureMO);                      Variable[] spos = new Variable[pos.Length - posc];                      Array.Copy(pos' posc' spos' 0' spos.Length);                      VarHash snamed = null;                      if (named != null) {                          snamed = new VarHash();                          foreach (string k in named.Keys) {                              if (namedc.Contains(k))                                  snamed[k] = named[k];                          }                      }                      nw.SetSlot(setting.CaptureMO' "$!positionals"' spos);                      nw.SetSlot(setting.CaptureMO' "$!named"' snamed);                      src = nw;                      named = null; namedc = null; posc = pos.Length;                      goto gotit;                  }                  if ((flags & Parameter.SLURPY_POS) != 0) {                      P6any l = new P6opaque(setting.ListMO);                      Kernel.IterToList(l' Kernel.IterFlatten(                                  Kernel.SlurpyHelper(pos' posc)));                      src = Kernel.NewRWListVar(l);                      posc = pos.Length;                      goto gotit;                  }                  if ((flags & Parameter.SLURPY_NAM) != 0) {                      VarHash nh = new VarHash();                      if (named != null) {                          foreach (KeyValuePair<string'Variable> kv in named)                              if (namedc.Contains(kv.Key))                                  nh[kv.Key] = kv.Value;                          named = null;                          namedc = null;                      }                      src = Kernel.BoxAnyMO(nh' setting.HashMO);                      goto gotit;                  }                  if (names != null && named != null) {                      for (int ni = 0; ni < names.Length; ni++) {                          string n = names[ni];                          if (namedc.Contains(n)) {                              namedc.Remove(n);                              src = named[n];                              obj_src_n = n;                              obj_src = -2;                              goto gotit;                          }                      }                  }                  if ((flags & Parameter.POSITIONAL) != 0 && posc != pos.Length) {                      obj_src = posc;                      src = pos[posc++];                      goto gotit;                  }  get_default:                  if ((flags & Parameter.HASDEFAULT) != 0) {                      if (param.def is Variable) {                          src = (Variable)param.def;                      } else {                          Frame thn = Kernel.GetInferiorRoot(setting)                              .MakeChild(th' (SubInfo)param.def' setting.AnyP);                          src = Kernel.RunInferior(thn);                          if (src == null)                              throw new Exception("Improper null return from sub default for '" + param.name + "' in '" + signame + "'");                      }                      goto gotit;                  }                  if ((flags & Parameter.DEFOUTER) != 0) {                      Frame f = th;                      if (th.info.outer_topic_key < 0) {                          src = setting.AnyP;                          goto gotit;                      }                      for (int i = 0; i < th.info.outer_topic_rank; i++) f = f.outer;                      src = (Variable)f.GetDynamic(th.info.outer_topic_key);                      goto gotit;                  }                  if ((flags & Parameter.OPTIONAL) != 0) {                      // Array is the "default" Positional -masak                      if ((flags & Parameter.IS_LIST) != 0)                          src = setting.CreateArray();                      else if ((flags & Parameter.IS_HASH) != 0)                          src = setting.CreateHash();                      else                          src = type.initObj;                      goto gotit;                  }                  if (quiet) return false;                  throw new NieczaException("No value for parameter '" + param.name + "' in '" + signame + "'");  gotit:                  switch ((flags & Parameter.DEF_MASK) >> Parameter.DEF_SHIFT) {                      // TODO: Failure will make these cases different                      case Parameter.TYPE_ONLY >> Parameter.DEF_SHIFT:                      case Parameter.UNDEF_ONLY >> Parameter.DEF_SHIFT:                          if (!src.Fetch().IsDefined())                              break;                          if (quiet) return false;                          throw new NieczaException("Parameter '" + param.name + "' in '" + signame + "' requires an undefined argument");                      case Parameter.DEF_ONLY >> Parameter.DEF_SHIFT:                          if (src.Fetch().IsDefined())                              break;                          if (quiet) return false;                          throw new NieczaException("Parameter '" + param.name + "' in '" + signame + "' requires a defined argument");                      default:                          break;                  }                  if ((flags & Parameter.RWTRANS) != 0) {                  } else if ((flags & Parameter.IS_COPY) != 0) {                      if ((flags & Parameter.IS_HASH) != 0)                          src = Kernel.Assign(setting.CreateHash()'                              Kernel.NewRWListVar(src.Fetch()));                      else if ((flags & Parameter.IS_LIST) != 0)                          src = Kernel.Assign(setting.CreateArray()'                              Kernel.NewRWListVar(src.Fetch()));                      else                          src = Kernel.Assign(type == null ? setting.NewMuAnyScalar() : Kernel.NewTypedScalar(type)' src);                  } else {                      bool islist = ((flags & (Parameter.IS_HASH | Parameter.IS_LIST)) != 0);                      bool rw     = ((flags & Parameter.READWRITE) != 0) && !islist;                      P6any srco  = src.Fetch();                        // XXX: in order for calling methods on Nil to work'                      // self needs to be ignored here.                      if (srco == setting.NilP && obj_src != -1 &&                              (flags & Parameter.INVOCANT) == 0) {                          obj_src = -1;                          goto get_default;                      }                      if ((flags & Parameter.IS_LIST) != 0)                          type = setting.PositionalMO;                      if ((flags & Parameter.IS_HASH) != 0)                          type = setting.AssociativeMO;                      if ((flags & Parameter.CALLABLE) != 0)                          type = setting.CallableMO;                      if (!srco.Does(type)) {                          if (quiet) return false;                          if (srco.mo.HasType(setting.JunctionMO) && obj_src != -1 && (mode & NO_JUNCTION) == 0) {                              int jrank = Kernel.UnboxAny<int>((P6any) ((P6opaque)srco).slots[0]) / 2;                              if (jrank < jun_rank) {                                  jun_rank = jrank;                                  jun_pivot = obj_src;                                  jun_pivot_n = obj_src_n;                              }                              continue;                          }                          throw new NieczaException("Nominal type check failed in binding '" + param.name + "' in '" + signame + "'; got " + srco.mo.name + "' needed " + type.name);                      }                        if (rw) {                          if (src.Rw) {                              // this will be a functional RW binding                              src.Vivify();                              goto bound;                          } else {                              if (quiet) return false;                              throw new NieczaException("Binding '" + param.name + "' in '" + signame + "'' cannot bind read-only value to is rw parameter");                          }                      }                      else {                          if (src.Mode == (islist ? Variable.LIST : Variable.RO))                              goto bound;                          src = islist ? (Variable)new ListVariable(srco) : srco;                      }  bound: ;                  }                  if (param.attribute != null) {                      object self;                      if (!th.TryGetDynamic("self"' 0' out self))                          throw new NieczaException("No 'self' available for attributive?");                      Variable selfv = (Variable)self;                      if (param.attribute[1] == '!') {                          Kernel.Assign(((Variable)(selfv.Fetch().                              GetSlot(param.attribute_type' param.attribute)))'                                  src);                      } else {                          Variable dest = Builtins.InvokeMethod(                                  param.attribute.Substring(2)' selfv);                          Kernel.Assign(dest' src);                      }                  }                  if ((flags & Parameter.INVOCANT) != 0 && th.info.self_key >= 0)                      th.SetDynamic(th.info.self_key' src);                  switch (slot + 1) {                      case 0: break;                      case 1:  th.lex0 = src; break;                      case 2:  th.lex1 = src; break;                      case 3:  th.lex2 = src; break;                      case 4:  th.lex3 = src; break;                      case 5:  th.lex4 = src; break;                      case 6:  th.lex5 = src; break;                      case 7:  th.lex6 = src; break;                      case 8:  th.lex7 = src; break;                      case 9:  th.lex8 = src; break;                      case 10: th.lex9 = src; break;                      default: th.lexn[slot - 10] = src; break;                  }                  // Really' this should be earlier (next to the :D/:U checks);                  // it's not right to be binding variables before doing                  // constraint checks.  We're compromising a bit of purity here                  // for the sake of making 'Int $odd where { $odd % 2 }' DWIM.                  if (param.post_constraints != null) {                      foreach (object c in param.post_constraints)                          if (!RunConstraint(th' signame' param' quiet' src' c))                              return false;                  }              }
Magic Number,Niecza,Frame,C:\repos\sorear_niecza\lib\Kernel.cs,BindSignature,The following statement contains a magic number: while (pix != pend) {                  Parameter param = pbuf[pix++];                  int flags = param.flags;                  int slot = param.slot;                  string[] names = param.names;                  STable type = param.type;                  obj_src = -1;                    Variable src = null;                  if ((flags & Parameter.SLURPY_PCL) != 0) {                      src = (slot >= 0) ? Kernel.BoxAnyMO(pos' setting.ParcelMO) :                          setting.AnyP;                      posc  = pos.Length;                      goto gotit;                  }                  if ((flags & Parameter.SLURPY_CAP) != 0) {                      if (slot < 0) {                          src = setting.AnyP;                          named = null; namedc = null; posc = pos.Length;                          goto gotit;                      }                      P6any nw = new P6opaque(setting.CaptureMO);                      Variable[] spos = new Variable[pos.Length - posc];                      Array.Copy(pos' posc' spos' 0' spos.Length);                      VarHash snamed = null;                      if (named != null) {                          snamed = new VarHash();                          foreach (string k in named.Keys) {                              if (namedc.Contains(k))                                  snamed[k] = named[k];                          }                      }                      nw.SetSlot(setting.CaptureMO' "$!positionals"' spos);                      nw.SetSlot(setting.CaptureMO' "$!named"' snamed);                      src = nw;                      named = null; namedc = null; posc = pos.Length;                      goto gotit;                  }                  if ((flags & Parameter.SLURPY_POS) != 0) {                      P6any l = new P6opaque(setting.ListMO);                      Kernel.IterToList(l' Kernel.IterFlatten(                                  Kernel.SlurpyHelper(pos' posc)));                      src = Kernel.NewRWListVar(l);                      posc = pos.Length;                      goto gotit;                  }                  if ((flags & Parameter.SLURPY_NAM) != 0) {                      VarHash nh = new VarHash();                      if (named != null) {                          foreach (KeyValuePair<string'Variable> kv in named)                              if (namedc.Contains(kv.Key))                                  nh[kv.Key] = kv.Value;                          named = null;                          namedc = null;                      }                      src = Kernel.BoxAnyMO(nh' setting.HashMO);                      goto gotit;                  }                  if (names != null && named != null) {                      for (int ni = 0; ni < names.Length; ni++) {                          string n = names[ni];                          if (namedc.Contains(n)) {                              namedc.Remove(n);                              src = named[n];                              obj_src_n = n;                              obj_src = -2;                              goto gotit;                          }                      }                  }                  if ((flags & Parameter.POSITIONAL) != 0 && posc != pos.Length) {                      obj_src = posc;                      src = pos[posc++];                      goto gotit;                  }  get_default:                  if ((flags & Parameter.HASDEFAULT) != 0) {                      if (param.def is Variable) {                          src = (Variable)param.def;                      } else {                          Frame thn = Kernel.GetInferiorRoot(setting)                              .MakeChild(th' (SubInfo)param.def' setting.AnyP);                          src = Kernel.RunInferior(thn);                          if (src == null)                              throw new Exception("Improper null return from sub default for '" + param.name + "' in '" + signame + "'");                      }                      goto gotit;                  }                  if ((flags & Parameter.DEFOUTER) != 0) {                      Frame f = th;                      if (th.info.outer_topic_key < 0) {                          src = setting.AnyP;                          goto gotit;                      }                      for (int i = 0; i < th.info.outer_topic_rank; i++) f = f.outer;                      src = (Variable)f.GetDynamic(th.info.outer_topic_key);                      goto gotit;                  }                  if ((flags & Parameter.OPTIONAL) != 0) {                      // Array is the "default" Positional -masak                      if ((flags & Parameter.IS_LIST) != 0)                          src = setting.CreateArray();                      else if ((flags & Parameter.IS_HASH) != 0)                          src = setting.CreateHash();                      else                          src = type.initObj;                      goto gotit;                  }                  if (quiet) return false;                  throw new NieczaException("No value for parameter '" + param.name + "' in '" + signame + "'");  gotit:                  switch ((flags & Parameter.DEF_MASK) >> Parameter.DEF_SHIFT) {                      // TODO: Failure will make these cases different                      case Parameter.TYPE_ONLY >> Parameter.DEF_SHIFT:                      case Parameter.UNDEF_ONLY >> Parameter.DEF_SHIFT:                          if (!src.Fetch().IsDefined())                              break;                          if (quiet) return false;                          throw new NieczaException("Parameter '" + param.name + "' in '" + signame + "' requires an undefined argument");                      case Parameter.DEF_ONLY >> Parameter.DEF_SHIFT:                          if (src.Fetch().IsDefined())                              break;                          if (quiet) return false;                          throw new NieczaException("Parameter '" + param.name + "' in '" + signame + "' requires a defined argument");                      default:                          break;                  }                  if ((flags & Parameter.RWTRANS) != 0) {                  } else if ((flags & Parameter.IS_COPY) != 0) {                      if ((flags & Parameter.IS_HASH) != 0)                          src = Kernel.Assign(setting.CreateHash()'                              Kernel.NewRWListVar(src.Fetch()));                      else if ((flags & Parameter.IS_LIST) != 0)                          src = Kernel.Assign(setting.CreateArray()'                              Kernel.NewRWListVar(src.Fetch()));                      else                          src = Kernel.Assign(type == null ? setting.NewMuAnyScalar() : Kernel.NewTypedScalar(type)' src);                  } else {                      bool islist = ((flags & (Parameter.IS_HASH | Parameter.IS_LIST)) != 0);                      bool rw     = ((flags & Parameter.READWRITE) != 0) && !islist;                      P6any srco  = src.Fetch();                        // XXX: in order for calling methods on Nil to work'                      // self needs to be ignored here.                      if (srco == setting.NilP && obj_src != -1 &&                              (flags & Parameter.INVOCANT) == 0) {                          obj_src = -1;                          goto get_default;                      }                      if ((flags & Parameter.IS_LIST) != 0)                          type = setting.PositionalMO;                      if ((flags & Parameter.IS_HASH) != 0)                          type = setting.AssociativeMO;                      if ((flags & Parameter.CALLABLE) != 0)                          type = setting.CallableMO;                      if (!srco.Does(type)) {                          if (quiet) return false;                          if (srco.mo.HasType(setting.JunctionMO) && obj_src != -1 && (mode & NO_JUNCTION) == 0) {                              int jrank = Kernel.UnboxAny<int>((P6any) ((P6opaque)srco).slots[0]) / 2;                              if (jrank < jun_rank) {                                  jun_rank = jrank;                                  jun_pivot = obj_src;                                  jun_pivot_n = obj_src_n;                              }                              continue;                          }                          throw new NieczaException("Nominal type check failed in binding '" + param.name + "' in '" + signame + "'; got " + srco.mo.name + "' needed " + type.name);                      }                        if (rw) {                          if (src.Rw) {                              // this will be a functional RW binding                              src.Vivify();                              goto bound;                          } else {                              if (quiet) return false;                              throw new NieczaException("Binding '" + param.name + "' in '" + signame + "'' cannot bind read-only value to is rw parameter");                          }                      }                      else {                          if (src.Mode == (islist ? Variable.LIST : Variable.RO))                              goto bound;                          src = islist ? (Variable)new ListVariable(srco) : srco;                      }  bound: ;                  }                  if (param.attribute != null) {                      object self;                      if (!th.TryGetDynamic("self"' 0' out self))                          throw new NieczaException("No 'self' available for attributive?");                      Variable selfv = (Variable)self;                      if (param.attribute[1] == '!') {                          Kernel.Assign(((Variable)(selfv.Fetch().                              GetSlot(param.attribute_type' param.attribute)))'                                  src);                      } else {                          Variable dest = Builtins.InvokeMethod(                                  param.attribute.Substring(2)' selfv);                          Kernel.Assign(dest' src);                      }                  }                  if ((flags & Parameter.INVOCANT) != 0 && th.info.self_key >= 0)                      th.SetDynamic(th.info.self_key' src);                  switch (slot + 1) {                      case 0: break;                      case 1:  th.lex0 = src; break;                      case 2:  th.lex1 = src; break;                      case 3:  th.lex2 = src; break;                      case 4:  th.lex3 = src; break;                      case 5:  th.lex4 = src; break;                      case 6:  th.lex5 = src; break;                      case 7:  th.lex6 = src; break;                      case 8:  th.lex7 = src; break;                      case 9:  th.lex8 = src; break;                      case 10: th.lex9 = src; break;                      default: th.lexn[slot - 10] = src; break;                  }                  // Really' this should be earlier (next to the :D/:U checks);                  // it's not right to be binding variables before doing                  // constraint checks.  We're compromising a bit of purity here                  // for the sake of making 'Int $odd where { $odd % 2 }' DWIM.                  if (param.post_constraints != null) {                      foreach (object c in param.post_constraints)                          if (!RunConstraint(th' signame' param' quiet' src' c))                              return false;                  }              }
Magic Number,Niecza,Frame,C:\repos\sorear_niecza\lib\Kernel.cs,BindSignature,The following statement contains a magic number: while (pix != pend) {                  Parameter param = pbuf[pix++];                  int flags = param.flags;                  int slot = param.slot;                  string[] names = param.names;                  STable type = param.type;                  obj_src = -1;                    Variable src = null;                  if ((flags & Parameter.SLURPY_PCL) != 0) {                      src = (slot >= 0) ? Kernel.BoxAnyMO(pos' setting.ParcelMO) :                          setting.AnyP;                      posc  = pos.Length;                      goto gotit;                  }                  if ((flags & Parameter.SLURPY_CAP) != 0) {                      if (slot < 0) {                          src = setting.AnyP;                          named = null; namedc = null; posc = pos.Length;                          goto gotit;                      }                      P6any nw = new P6opaque(setting.CaptureMO);                      Variable[] spos = new Variable[pos.Length - posc];                      Array.Copy(pos' posc' spos' 0' spos.Length);                      VarHash snamed = null;                      if (named != null) {                          snamed = new VarHash();                          foreach (string k in named.Keys) {                              if (namedc.Contains(k))                                  snamed[k] = named[k];                          }                      }                      nw.SetSlot(setting.CaptureMO' "$!positionals"' spos);                      nw.SetSlot(setting.CaptureMO' "$!named"' snamed);                      src = nw;                      named = null; namedc = null; posc = pos.Length;                      goto gotit;                  }                  if ((flags & Parameter.SLURPY_POS) != 0) {                      P6any l = new P6opaque(setting.ListMO);                      Kernel.IterToList(l' Kernel.IterFlatten(                                  Kernel.SlurpyHelper(pos' posc)));                      src = Kernel.NewRWListVar(l);                      posc = pos.Length;                      goto gotit;                  }                  if ((flags & Parameter.SLURPY_NAM) != 0) {                      VarHash nh = new VarHash();                      if (named != null) {                          foreach (KeyValuePair<string'Variable> kv in named)                              if (namedc.Contains(kv.Key))                                  nh[kv.Key] = kv.Value;                          named = null;                          namedc = null;                      }                      src = Kernel.BoxAnyMO(nh' setting.HashMO);                      goto gotit;                  }                  if (names != null && named != null) {                      for (int ni = 0; ni < names.Length; ni++) {                          string n = names[ni];                          if (namedc.Contains(n)) {                              namedc.Remove(n);                              src = named[n];                              obj_src_n = n;                              obj_src = -2;                              goto gotit;                          }                      }                  }                  if ((flags & Parameter.POSITIONAL) != 0 && posc != pos.Length) {                      obj_src = posc;                      src = pos[posc++];                      goto gotit;                  }  get_default:                  if ((flags & Parameter.HASDEFAULT) != 0) {                      if (param.def is Variable) {                          src = (Variable)param.def;                      } else {                          Frame thn = Kernel.GetInferiorRoot(setting)                              .MakeChild(th' (SubInfo)param.def' setting.AnyP);                          src = Kernel.RunInferior(thn);                          if (src == null)                              throw new Exception("Improper null return from sub default for '" + param.name + "' in '" + signame + "'");                      }                      goto gotit;                  }                  if ((flags & Parameter.DEFOUTER) != 0) {                      Frame f = th;                      if (th.info.outer_topic_key < 0) {                          src = setting.AnyP;                          goto gotit;                      }                      for (int i = 0; i < th.info.outer_topic_rank; i++) f = f.outer;                      src = (Variable)f.GetDynamic(th.info.outer_topic_key);                      goto gotit;                  }                  if ((flags & Parameter.OPTIONAL) != 0) {                      // Array is the "default" Positional -masak                      if ((flags & Parameter.IS_LIST) != 0)                          src = setting.CreateArray();                      else if ((flags & Parameter.IS_HASH) != 0)                          src = setting.CreateHash();                      else                          src = type.initObj;                      goto gotit;                  }                  if (quiet) return false;                  throw new NieczaException("No value for parameter '" + param.name + "' in '" + signame + "'");  gotit:                  switch ((flags & Parameter.DEF_MASK) >> Parameter.DEF_SHIFT) {                      // TODO: Failure will make these cases different                      case Parameter.TYPE_ONLY >> Parameter.DEF_SHIFT:                      case Parameter.UNDEF_ONLY >> Parameter.DEF_SHIFT:                          if (!src.Fetch().IsDefined())                              break;                          if (quiet) return false;                          throw new NieczaException("Parameter '" + param.name + "' in '" + signame + "' requires an undefined argument");                      case Parameter.DEF_ONLY >> Parameter.DEF_SHIFT:                          if (src.Fetch().IsDefined())                              break;                          if (quiet) return false;                          throw new NieczaException("Parameter '" + param.name + "' in '" + signame + "' requires a defined argument");                      default:                          break;                  }                  if ((flags & Parameter.RWTRANS) != 0) {                  } else if ((flags & Parameter.IS_COPY) != 0) {                      if ((flags & Parameter.IS_HASH) != 0)                          src = Kernel.Assign(setting.CreateHash()'                              Kernel.NewRWListVar(src.Fetch()));                      else if ((flags & Parameter.IS_LIST) != 0)                          src = Kernel.Assign(setting.CreateArray()'                              Kernel.NewRWListVar(src.Fetch()));                      else                          src = Kernel.Assign(type == null ? setting.NewMuAnyScalar() : Kernel.NewTypedScalar(type)' src);                  } else {                      bool islist = ((flags & (Parameter.IS_HASH | Parameter.IS_LIST)) != 0);                      bool rw     = ((flags & Parameter.READWRITE) != 0) && !islist;                      P6any srco  = src.Fetch();                        // XXX: in order for calling methods on Nil to work'                      // self needs to be ignored here.                      if (srco == setting.NilP && obj_src != -1 &&                              (flags & Parameter.INVOCANT) == 0) {                          obj_src = -1;                          goto get_default;                      }                      if ((flags & Parameter.IS_LIST) != 0)                          type = setting.PositionalMO;                      if ((flags & Parameter.IS_HASH) != 0)                          type = setting.AssociativeMO;                      if ((flags & Parameter.CALLABLE) != 0)                          type = setting.CallableMO;                      if (!srco.Does(type)) {                          if (quiet) return false;                          if (srco.mo.HasType(setting.JunctionMO) && obj_src != -1 && (mode & NO_JUNCTION) == 0) {                              int jrank = Kernel.UnboxAny<int>((P6any) ((P6opaque)srco).slots[0]) / 2;                              if (jrank < jun_rank) {                                  jun_rank = jrank;                                  jun_pivot = obj_src;                                  jun_pivot_n = obj_src_n;                              }                              continue;                          }                          throw new NieczaException("Nominal type check failed in binding '" + param.name + "' in '" + signame + "'; got " + srco.mo.name + "' needed " + type.name);                      }                        if (rw) {                          if (src.Rw) {                              // this will be a functional RW binding                              src.Vivify();                              goto bound;                          } else {                              if (quiet) return false;                              throw new NieczaException("Binding '" + param.name + "' in '" + signame + "'' cannot bind read-only value to is rw parameter");                          }                      }                      else {                          if (src.Mode == (islist ? Variable.LIST : Variable.RO))                              goto bound;                          src = islist ? (Variable)new ListVariable(srco) : srco;                      }  bound: ;                  }                  if (param.attribute != null) {                      object self;                      if (!th.TryGetDynamic("self"' 0' out self))                          throw new NieczaException("No 'self' available for attributive?");                      Variable selfv = (Variable)self;                      if (param.attribute[1] == '!') {                          Kernel.Assign(((Variable)(selfv.Fetch().                              GetSlot(param.attribute_type' param.attribute)))'                                  src);                      } else {                          Variable dest = Builtins.InvokeMethod(                                  param.attribute.Substring(2)' selfv);                          Kernel.Assign(dest' src);                      }                  }                  if ((flags & Parameter.INVOCANT) != 0 && th.info.self_key >= 0)                      th.SetDynamic(th.info.self_key' src);                  switch (slot + 1) {                      case 0: break;                      case 1:  th.lex0 = src; break;                      case 2:  th.lex1 = src; break;                      case 3:  th.lex2 = src; break;                      case 4:  th.lex3 = src; break;                      case 5:  th.lex4 = src; break;                      case 6:  th.lex5 = src; break;                      case 7:  th.lex6 = src; break;                      case 8:  th.lex7 = src; break;                      case 9:  th.lex8 = src; break;                      case 10: th.lex9 = src; break;                      default: th.lexn[slot - 10] = src; break;                  }                  // Really' this should be earlier (next to the :D/:U checks);                  // it's not right to be binding variables before doing                  // constraint checks.  We're compromising a bit of purity here                  // for the sake of making 'Int $odd where { $odd % 2 }' DWIM.                  if (param.post_constraints != null) {                      foreach (object c in param.post_constraints)                          if (!RunConstraint(th' signame' param' quiet' src' c))                              return false;                  }              }
Magic Number,Niecza,Frame,C:\repos\sorear_niecza\lib\Kernel.cs,BindSignature,The following statement contains a magic number: while (pix != pend) {                  Parameter param = pbuf[pix++];                  int flags = param.flags;                  int slot = param.slot;                  string[] names = param.names;                  STable type = param.type;                  obj_src = -1;                    Variable src = null;                  if ((flags & Parameter.SLURPY_PCL) != 0) {                      src = (slot >= 0) ? Kernel.BoxAnyMO(pos' setting.ParcelMO) :                          setting.AnyP;                      posc  = pos.Length;                      goto gotit;                  }                  if ((flags & Parameter.SLURPY_CAP) != 0) {                      if (slot < 0) {                          src = setting.AnyP;                          named = null; namedc = null; posc = pos.Length;                          goto gotit;                      }                      P6any nw = new P6opaque(setting.CaptureMO);                      Variable[] spos = new Variable[pos.Length - posc];                      Array.Copy(pos' posc' spos' 0' spos.Length);                      VarHash snamed = null;                      if (named != null) {                          snamed = new VarHash();                          foreach (string k in named.Keys) {                              if (namedc.Contains(k))                                  snamed[k] = named[k];                          }                      }                      nw.SetSlot(setting.CaptureMO' "$!positionals"' spos);                      nw.SetSlot(setting.CaptureMO' "$!named"' snamed);                      src = nw;                      named = null; namedc = null; posc = pos.Length;                      goto gotit;                  }                  if ((flags & Parameter.SLURPY_POS) != 0) {                      P6any l = new P6opaque(setting.ListMO);                      Kernel.IterToList(l' Kernel.IterFlatten(                                  Kernel.SlurpyHelper(pos' posc)));                      src = Kernel.NewRWListVar(l);                      posc = pos.Length;                      goto gotit;                  }                  if ((flags & Parameter.SLURPY_NAM) != 0) {                      VarHash nh = new VarHash();                      if (named != null) {                          foreach (KeyValuePair<string'Variable> kv in named)                              if (namedc.Contains(kv.Key))                                  nh[kv.Key] = kv.Value;                          named = null;                          namedc = null;                      }                      src = Kernel.BoxAnyMO(nh' setting.HashMO);                      goto gotit;                  }                  if (names != null && named != null) {                      for (int ni = 0; ni < names.Length; ni++) {                          string n = names[ni];                          if (namedc.Contains(n)) {                              namedc.Remove(n);                              src = named[n];                              obj_src_n = n;                              obj_src = -2;                              goto gotit;                          }                      }                  }                  if ((flags & Parameter.POSITIONAL) != 0 && posc != pos.Length) {                      obj_src = posc;                      src = pos[posc++];                      goto gotit;                  }  get_default:                  if ((flags & Parameter.HASDEFAULT) != 0) {                      if (param.def is Variable) {                          src = (Variable)param.def;                      } else {                          Frame thn = Kernel.GetInferiorRoot(setting)                              .MakeChild(th' (SubInfo)param.def' setting.AnyP);                          src = Kernel.RunInferior(thn);                          if (src == null)                              throw new Exception("Improper null return from sub default for '" + param.name + "' in '" + signame + "'");                      }                      goto gotit;                  }                  if ((flags & Parameter.DEFOUTER) != 0) {                      Frame f = th;                      if (th.info.outer_topic_key < 0) {                          src = setting.AnyP;                          goto gotit;                      }                      for (int i = 0; i < th.info.outer_topic_rank; i++) f = f.outer;                      src = (Variable)f.GetDynamic(th.info.outer_topic_key);                      goto gotit;                  }                  if ((flags & Parameter.OPTIONAL) != 0) {                      // Array is the "default" Positional -masak                      if ((flags & Parameter.IS_LIST) != 0)                          src = setting.CreateArray();                      else if ((flags & Parameter.IS_HASH) != 0)                          src = setting.CreateHash();                      else                          src = type.initObj;                      goto gotit;                  }                  if (quiet) return false;                  throw new NieczaException("No value for parameter '" + param.name + "' in '" + signame + "'");  gotit:                  switch ((flags & Parameter.DEF_MASK) >> Parameter.DEF_SHIFT) {                      // TODO: Failure will make these cases different                      case Parameter.TYPE_ONLY >> Parameter.DEF_SHIFT:                      case Parameter.UNDEF_ONLY >> Parameter.DEF_SHIFT:                          if (!src.Fetch().IsDefined())                              break;                          if (quiet) return false;                          throw new NieczaException("Parameter '" + param.name + "' in '" + signame + "' requires an undefined argument");                      case Parameter.DEF_ONLY >> Parameter.DEF_SHIFT:                          if (src.Fetch().IsDefined())                              break;                          if (quiet) return false;                          throw new NieczaException("Parameter '" + param.name + "' in '" + signame + "' requires a defined argument");                      default:                          break;                  }                  if ((flags & Parameter.RWTRANS) != 0) {                  } else if ((flags & Parameter.IS_COPY) != 0) {                      if ((flags & Parameter.IS_HASH) != 0)                          src = Kernel.Assign(setting.CreateHash()'                              Kernel.NewRWListVar(src.Fetch()));                      else if ((flags & Parameter.IS_LIST) != 0)                          src = Kernel.Assign(setting.CreateArray()'                              Kernel.NewRWListVar(src.Fetch()));                      else                          src = Kernel.Assign(type == null ? setting.NewMuAnyScalar() : Kernel.NewTypedScalar(type)' src);                  } else {                      bool islist = ((flags & (Parameter.IS_HASH | Parameter.IS_LIST)) != 0);                      bool rw     = ((flags & Parameter.READWRITE) != 0) && !islist;                      P6any srco  = src.Fetch();                        // XXX: in order for calling methods on Nil to work'                      // self needs to be ignored here.                      if (srco == setting.NilP && obj_src != -1 &&                              (flags & Parameter.INVOCANT) == 0) {                          obj_src = -1;                          goto get_default;                      }                      if ((flags & Parameter.IS_LIST) != 0)                          type = setting.PositionalMO;                      if ((flags & Parameter.IS_HASH) != 0)                          type = setting.AssociativeMO;                      if ((flags & Parameter.CALLABLE) != 0)                          type = setting.CallableMO;                      if (!srco.Does(type)) {                          if (quiet) return false;                          if (srco.mo.HasType(setting.JunctionMO) && obj_src != -1 && (mode & NO_JUNCTION) == 0) {                              int jrank = Kernel.UnboxAny<int>((P6any) ((P6opaque)srco).slots[0]) / 2;                              if (jrank < jun_rank) {                                  jun_rank = jrank;                                  jun_pivot = obj_src;                                  jun_pivot_n = obj_src_n;                              }                              continue;                          }                          throw new NieczaException("Nominal type check failed in binding '" + param.name + "' in '" + signame + "'; got " + srco.mo.name + "' needed " + type.name);                      }                        if (rw) {                          if (src.Rw) {                              // this will be a functional RW binding                              src.Vivify();                              goto bound;                          } else {                              if (quiet) return false;                              throw new NieczaException("Binding '" + param.name + "' in '" + signame + "'' cannot bind read-only value to is rw parameter");                          }                      }                      else {                          if (src.Mode == (islist ? Variable.LIST : Variable.RO))                              goto bound;                          src = islist ? (Variable)new ListVariable(srco) : srco;                      }  bound: ;                  }                  if (param.attribute != null) {                      object self;                      if (!th.TryGetDynamic("self"' 0' out self))                          throw new NieczaException("No 'self' available for attributive?");                      Variable selfv = (Variable)self;                      if (param.attribute[1] == '!') {                          Kernel.Assign(((Variable)(selfv.Fetch().                              GetSlot(param.attribute_type' param.attribute)))'                                  src);                      } else {                          Variable dest = Builtins.InvokeMethod(                                  param.attribute.Substring(2)' selfv);                          Kernel.Assign(dest' src);                      }                  }                  if ((flags & Parameter.INVOCANT) != 0 && th.info.self_key >= 0)                      th.SetDynamic(th.info.self_key' src);                  switch (slot + 1) {                      case 0: break;                      case 1:  th.lex0 = src; break;                      case 2:  th.lex1 = src; break;                      case 3:  th.lex2 = src; break;                      case 4:  th.lex3 = src; break;                      case 5:  th.lex4 = src; break;                      case 6:  th.lex5 = src; break;                      case 7:  th.lex6 = src; break;                      case 8:  th.lex7 = src; break;                      case 9:  th.lex8 = src; break;                      case 10: th.lex9 = src; break;                      default: th.lexn[slot - 10] = src; break;                  }                  // Really' this should be earlier (next to the :D/:U checks);                  // it's not right to be binding variables before doing                  // constraint checks.  We're compromising a bit of purity here                  // for the sake of making 'Int $odd where { $odd % 2 }' DWIM.                  if (param.post_constraints != null) {                      foreach (object c in param.post_constraints)                          if (!RunConstraint(th' signame' param' quiet' src' c))                              return false;                  }              }
Magic Number,Niecza,Frame,C:\repos\sorear_niecza\lib\Kernel.cs,BindSignature,The following statement contains a magic number: while (pix != pend) {                  Parameter param = pbuf[pix++];                  int flags = param.flags;                  int slot = param.slot;                  string[] names = param.names;                  STable type = param.type;                  obj_src = -1;                    Variable src = null;                  if ((flags & Parameter.SLURPY_PCL) != 0) {                      src = (slot >= 0) ? Kernel.BoxAnyMO(pos' setting.ParcelMO) :                          setting.AnyP;                      posc  = pos.Length;                      goto gotit;                  }                  if ((flags & Parameter.SLURPY_CAP) != 0) {                      if (slot < 0) {                          src = setting.AnyP;                          named = null; namedc = null; posc = pos.Length;                          goto gotit;                      }                      P6any nw = new P6opaque(setting.CaptureMO);                      Variable[] spos = new Variable[pos.Length - posc];                      Array.Copy(pos' posc' spos' 0' spos.Length);                      VarHash snamed = null;                      if (named != null) {                          snamed = new VarHash();                          foreach (string k in named.Keys) {                              if (namedc.Contains(k))                                  snamed[k] = named[k];                          }                      }                      nw.SetSlot(setting.CaptureMO' "$!positionals"' spos);                      nw.SetSlot(setting.CaptureMO' "$!named"' snamed);                      src = nw;                      named = null; namedc = null; posc = pos.Length;                      goto gotit;                  }                  if ((flags & Parameter.SLURPY_POS) != 0) {                      P6any l = new P6opaque(setting.ListMO);                      Kernel.IterToList(l' Kernel.IterFlatten(                                  Kernel.SlurpyHelper(pos' posc)));                      src = Kernel.NewRWListVar(l);                      posc = pos.Length;                      goto gotit;                  }                  if ((flags & Parameter.SLURPY_NAM) != 0) {                      VarHash nh = new VarHash();                      if (named != null) {                          foreach (KeyValuePair<string'Variable> kv in named)                              if (namedc.Contains(kv.Key))                                  nh[kv.Key] = kv.Value;                          named = null;                          namedc = null;                      }                      src = Kernel.BoxAnyMO(nh' setting.HashMO);                      goto gotit;                  }                  if (names != null && named != null) {                      for (int ni = 0; ni < names.Length; ni++) {                          string n = names[ni];                          if (namedc.Contains(n)) {                              namedc.Remove(n);                              src = named[n];                              obj_src_n = n;                              obj_src = -2;                              goto gotit;                          }                      }                  }                  if ((flags & Parameter.POSITIONAL) != 0 && posc != pos.Length) {                      obj_src = posc;                      src = pos[posc++];                      goto gotit;                  }  get_default:                  if ((flags & Parameter.HASDEFAULT) != 0) {                      if (param.def is Variable) {                          src = (Variable)param.def;                      } else {                          Frame thn = Kernel.GetInferiorRoot(setting)                              .MakeChild(th' (SubInfo)param.def' setting.AnyP);                          src = Kernel.RunInferior(thn);                          if (src == null)                              throw new Exception("Improper null return from sub default for '" + param.name + "' in '" + signame + "'");                      }                      goto gotit;                  }                  if ((flags & Parameter.DEFOUTER) != 0) {                      Frame f = th;                      if (th.info.outer_topic_key < 0) {                          src = setting.AnyP;                          goto gotit;                      }                      for (int i = 0; i < th.info.outer_topic_rank; i++) f = f.outer;                      src = (Variable)f.GetDynamic(th.info.outer_topic_key);                      goto gotit;                  }                  if ((flags & Parameter.OPTIONAL) != 0) {                      // Array is the "default" Positional -masak                      if ((flags & Parameter.IS_LIST) != 0)                          src = setting.CreateArray();                      else if ((flags & Parameter.IS_HASH) != 0)                          src = setting.CreateHash();                      else                          src = type.initObj;                      goto gotit;                  }                  if (quiet) return false;                  throw new NieczaException("No value for parameter '" + param.name + "' in '" + signame + "'");  gotit:                  switch ((flags & Parameter.DEF_MASK) >> Parameter.DEF_SHIFT) {                      // TODO: Failure will make these cases different                      case Parameter.TYPE_ONLY >> Parameter.DEF_SHIFT:                      case Parameter.UNDEF_ONLY >> Parameter.DEF_SHIFT:                          if (!src.Fetch().IsDefined())                              break;                          if (quiet) return false;                          throw new NieczaException("Parameter '" + param.name + "' in '" + signame + "' requires an undefined argument");                      case Parameter.DEF_ONLY >> Parameter.DEF_SHIFT:                          if (src.Fetch().IsDefined())                              break;                          if (quiet) return false;                          throw new NieczaException("Parameter '" + param.name + "' in '" + signame + "' requires a defined argument");                      default:                          break;                  }                  if ((flags & Parameter.RWTRANS) != 0) {                  } else if ((flags & Parameter.IS_COPY) != 0) {                      if ((flags & Parameter.IS_HASH) != 0)                          src = Kernel.Assign(setting.CreateHash()'                              Kernel.NewRWListVar(src.Fetch()));                      else if ((flags & Parameter.IS_LIST) != 0)                          src = Kernel.Assign(setting.CreateArray()'                              Kernel.NewRWListVar(src.Fetch()));                      else                          src = Kernel.Assign(type == null ? setting.NewMuAnyScalar() : Kernel.NewTypedScalar(type)' src);                  } else {                      bool islist = ((flags & (Parameter.IS_HASH | Parameter.IS_LIST)) != 0);                      bool rw     = ((flags & Parameter.READWRITE) != 0) && !islist;                      P6any srco  = src.Fetch();                        // XXX: in order for calling methods on Nil to work'                      // self needs to be ignored here.                      if (srco == setting.NilP && obj_src != -1 &&                              (flags & Parameter.INVOCANT) == 0) {                          obj_src = -1;                          goto get_default;                      }                      if ((flags & Parameter.IS_LIST) != 0)                          type = setting.PositionalMO;                      if ((flags & Parameter.IS_HASH) != 0)                          type = setting.AssociativeMO;                      if ((flags & Parameter.CALLABLE) != 0)                          type = setting.CallableMO;                      if (!srco.Does(type)) {                          if (quiet) return false;                          if (srco.mo.HasType(setting.JunctionMO) && obj_src != -1 && (mode & NO_JUNCTION) == 0) {                              int jrank = Kernel.UnboxAny<int>((P6any) ((P6opaque)srco).slots[0]) / 2;                              if (jrank < jun_rank) {                                  jun_rank = jrank;                                  jun_pivot = obj_src;                                  jun_pivot_n = obj_src_n;                              }                              continue;                          }                          throw new NieczaException("Nominal type check failed in binding '" + param.name + "' in '" + signame + "'; got " + srco.mo.name + "' needed " + type.name);                      }                        if (rw) {                          if (src.Rw) {                              // this will be a functional RW binding                              src.Vivify();                              goto bound;                          } else {                              if (quiet) return false;                              throw new NieczaException("Binding '" + param.name + "' in '" + signame + "'' cannot bind read-only value to is rw parameter");                          }                      }                      else {                          if (src.Mode == (islist ? Variable.LIST : Variable.RO))                              goto bound;                          src = islist ? (Variable)new ListVariable(srco) : srco;                      }  bound: ;                  }                  if (param.attribute != null) {                      object self;                      if (!th.TryGetDynamic("self"' 0' out self))                          throw new NieczaException("No 'self' available for attributive?");                      Variable selfv = (Variable)self;                      if (param.attribute[1] == '!') {                          Kernel.Assign(((Variable)(selfv.Fetch().                              GetSlot(param.attribute_type' param.attribute)))'                                  src);                      } else {                          Variable dest = Builtins.InvokeMethod(                                  param.attribute.Substring(2)' selfv);                          Kernel.Assign(dest' src);                      }                  }                  if ((flags & Parameter.INVOCANT) != 0 && th.info.self_key >= 0)                      th.SetDynamic(th.info.self_key' src);                  switch (slot + 1) {                      case 0: break;                      case 1:  th.lex0 = src; break;                      case 2:  th.lex1 = src; break;                      case 3:  th.lex2 = src; break;                      case 4:  th.lex3 = src; break;                      case 5:  th.lex4 = src; break;                      case 6:  th.lex5 = src; break;                      case 7:  th.lex6 = src; break;                      case 8:  th.lex7 = src; break;                      case 9:  th.lex8 = src; break;                      case 10: th.lex9 = src; break;                      default: th.lexn[slot - 10] = src; break;                  }                  // Really' this should be earlier (next to the :D/:U checks);                  // it's not right to be binding variables before doing                  // constraint checks.  We're compromising a bit of purity here                  // for the sake of making 'Int $odd where { $odd % 2 }' DWIM.                  if (param.post_constraints != null) {                      foreach (object c in param.post_constraints)                          if (!RunConstraint(th' signame' param' quiet' src' c))                              return false;                  }              }
Magic Number,Niecza,Frame,C:\repos\sorear_niecza\lib\Kernel.cs,BindSignature,The following statement contains a magic number: while (pix != pend) {                  Parameter param = pbuf[pix++];                  int flags = param.flags;                  int slot = param.slot;                  string[] names = param.names;                  STable type = param.type;                  obj_src = -1;                    Variable src = null;                  if ((flags & Parameter.SLURPY_PCL) != 0) {                      src = (slot >= 0) ? Kernel.BoxAnyMO(pos' setting.ParcelMO) :                          setting.AnyP;                      posc  = pos.Length;                      goto gotit;                  }                  if ((flags & Parameter.SLURPY_CAP) != 0) {                      if (slot < 0) {                          src = setting.AnyP;                          named = null; namedc = null; posc = pos.Length;                          goto gotit;                      }                      P6any nw = new P6opaque(setting.CaptureMO);                      Variable[] spos = new Variable[pos.Length - posc];                      Array.Copy(pos' posc' spos' 0' spos.Length);                      VarHash snamed = null;                      if (named != null) {                          snamed = new VarHash();                          foreach (string k in named.Keys) {                              if (namedc.Contains(k))                                  snamed[k] = named[k];                          }                      }                      nw.SetSlot(setting.CaptureMO' "$!positionals"' spos);                      nw.SetSlot(setting.CaptureMO' "$!named"' snamed);                      src = nw;                      named = null; namedc = null; posc = pos.Length;                      goto gotit;                  }                  if ((flags & Parameter.SLURPY_POS) != 0) {                      P6any l = new P6opaque(setting.ListMO);                      Kernel.IterToList(l' Kernel.IterFlatten(                                  Kernel.SlurpyHelper(pos' posc)));                      src = Kernel.NewRWListVar(l);                      posc = pos.Length;                      goto gotit;                  }                  if ((flags & Parameter.SLURPY_NAM) != 0) {                      VarHash nh = new VarHash();                      if (named != null) {                          foreach (KeyValuePair<string'Variable> kv in named)                              if (namedc.Contains(kv.Key))                                  nh[kv.Key] = kv.Value;                          named = null;                          namedc = null;                      }                      src = Kernel.BoxAnyMO(nh' setting.HashMO);                      goto gotit;                  }                  if (names != null && named != null) {                      for (int ni = 0; ni < names.Length; ni++) {                          string n = names[ni];                          if (namedc.Contains(n)) {                              namedc.Remove(n);                              src = named[n];                              obj_src_n = n;                              obj_src = -2;                              goto gotit;                          }                      }                  }                  if ((flags & Parameter.POSITIONAL) != 0 && posc != pos.Length) {                      obj_src = posc;                      src = pos[posc++];                      goto gotit;                  }  get_default:                  if ((flags & Parameter.HASDEFAULT) != 0) {                      if (param.def is Variable) {                          src = (Variable)param.def;                      } else {                          Frame thn = Kernel.GetInferiorRoot(setting)                              .MakeChild(th' (SubInfo)param.def' setting.AnyP);                          src = Kernel.RunInferior(thn);                          if (src == null)                              throw new Exception("Improper null return from sub default for '" + param.name + "' in '" + signame + "'");                      }                      goto gotit;                  }                  if ((flags & Parameter.DEFOUTER) != 0) {                      Frame f = th;                      if (th.info.outer_topic_key < 0) {                          src = setting.AnyP;                          goto gotit;                      }                      for (int i = 0; i < th.info.outer_topic_rank; i++) f = f.outer;                      src = (Variable)f.GetDynamic(th.info.outer_topic_key);                      goto gotit;                  }                  if ((flags & Parameter.OPTIONAL) != 0) {                      // Array is the "default" Positional -masak                      if ((flags & Parameter.IS_LIST) != 0)                          src = setting.CreateArray();                      else if ((flags & Parameter.IS_HASH) != 0)                          src = setting.CreateHash();                      else                          src = type.initObj;                      goto gotit;                  }                  if (quiet) return false;                  throw new NieczaException("No value for parameter '" + param.name + "' in '" + signame + "'");  gotit:                  switch ((flags & Parameter.DEF_MASK) >> Parameter.DEF_SHIFT) {                      // TODO: Failure will make these cases different                      case Parameter.TYPE_ONLY >> Parameter.DEF_SHIFT:                      case Parameter.UNDEF_ONLY >> Parameter.DEF_SHIFT:                          if (!src.Fetch().IsDefined())                              break;                          if (quiet) return false;                          throw new NieczaException("Parameter '" + param.name + "' in '" + signame + "' requires an undefined argument");                      case Parameter.DEF_ONLY >> Parameter.DEF_SHIFT:                          if (src.Fetch().IsDefined())                              break;                          if (quiet) return false;                          throw new NieczaException("Parameter '" + param.name + "' in '" + signame + "' requires a defined argument");                      default:                          break;                  }                  if ((flags & Parameter.RWTRANS) != 0) {                  } else if ((flags & Parameter.IS_COPY) != 0) {                      if ((flags & Parameter.IS_HASH) != 0)                          src = Kernel.Assign(setting.CreateHash()'                              Kernel.NewRWListVar(src.Fetch()));                      else if ((flags & Parameter.IS_LIST) != 0)                          src = Kernel.Assign(setting.CreateArray()'                              Kernel.NewRWListVar(src.Fetch()));                      else                          src = Kernel.Assign(type == null ? setting.NewMuAnyScalar() : Kernel.NewTypedScalar(type)' src);                  } else {                      bool islist = ((flags & (Parameter.IS_HASH | Parameter.IS_LIST)) != 0);                      bool rw     = ((flags & Parameter.READWRITE) != 0) && !islist;                      P6any srco  = src.Fetch();                        // XXX: in order for calling methods on Nil to work'                      // self needs to be ignored here.                      if (srco == setting.NilP && obj_src != -1 &&                              (flags & Parameter.INVOCANT) == 0) {                          obj_src = -1;                          goto get_default;                      }                      if ((flags & Parameter.IS_LIST) != 0)                          type = setting.PositionalMO;                      if ((flags & Parameter.IS_HASH) != 0)                          type = setting.AssociativeMO;                      if ((flags & Parameter.CALLABLE) != 0)                          type = setting.CallableMO;                      if (!srco.Does(type)) {                          if (quiet) return false;                          if (srco.mo.HasType(setting.JunctionMO) && obj_src != -1 && (mode & NO_JUNCTION) == 0) {                              int jrank = Kernel.UnboxAny<int>((P6any) ((P6opaque)srco).slots[0]) / 2;                              if (jrank < jun_rank) {                                  jun_rank = jrank;                                  jun_pivot = obj_src;                                  jun_pivot_n = obj_src_n;                              }                              continue;                          }                          throw new NieczaException("Nominal type check failed in binding '" + param.name + "' in '" + signame + "'; got " + srco.mo.name + "' needed " + type.name);                      }                        if (rw) {                          if (src.Rw) {                              // this will be a functional RW binding                              src.Vivify();                              goto bound;                          } else {                              if (quiet) return false;                              throw new NieczaException("Binding '" + param.name + "' in '" + signame + "'' cannot bind read-only value to is rw parameter");                          }                      }                      else {                          if (src.Mode == (islist ? Variable.LIST : Variable.RO))                              goto bound;                          src = islist ? (Variable)new ListVariable(srco) : srco;                      }  bound: ;                  }                  if (param.attribute != null) {                      object self;                      if (!th.TryGetDynamic("self"' 0' out self))                          throw new NieczaException("No 'self' available for attributive?");                      Variable selfv = (Variable)self;                      if (param.attribute[1] == '!') {                          Kernel.Assign(((Variable)(selfv.Fetch().                              GetSlot(param.attribute_type' param.attribute)))'                                  src);                      } else {                          Variable dest = Builtins.InvokeMethod(                                  param.attribute.Substring(2)' selfv);                          Kernel.Assign(dest' src);                      }                  }                  if ((flags & Parameter.INVOCANT) != 0 && th.info.self_key >= 0)                      th.SetDynamic(th.info.self_key' src);                  switch (slot + 1) {                      case 0: break;                      case 1:  th.lex0 = src; break;                      case 2:  th.lex1 = src; break;                      case 3:  th.lex2 = src; break;                      case 4:  th.lex3 = src; break;                      case 5:  th.lex4 = src; break;                      case 6:  th.lex5 = src; break;                      case 7:  th.lex6 = src; break;                      case 8:  th.lex7 = src; break;                      case 9:  th.lex8 = src; break;                      case 10: th.lex9 = src; break;                      default: th.lexn[slot - 10] = src; break;                  }                  // Really' this should be earlier (next to the :D/:U checks);                  // it's not right to be binding variables before doing                  // constraint checks.  We're compromising a bit of purity here                  // for the sake of making 'Int $odd where { $odd % 2 }' DWIM.                  if (param.post_constraints != null) {                      foreach (object c in param.post_constraints)                          if (!RunConstraint(th' signame' param' quiet' src' c))                              return false;                  }              }
Magic Number,Niecza,Frame,C:\repos\sorear_niecza\lib\Kernel.cs,BindSignature,The following statement contains a magic number: while (pix != pend) {                  Parameter param = pbuf[pix++];                  int flags = param.flags;                  int slot = param.slot;                  string[] names = param.names;                  STable type = param.type;                  obj_src = -1;                    Variable src = null;                  if ((flags & Parameter.SLURPY_PCL) != 0) {                      src = (slot >= 0) ? Kernel.BoxAnyMO(pos' setting.ParcelMO) :                          setting.AnyP;                      posc  = pos.Length;                      goto gotit;                  }                  if ((flags & Parameter.SLURPY_CAP) != 0) {                      if (slot < 0) {                          src = setting.AnyP;                          named = null; namedc = null; posc = pos.Length;                          goto gotit;                      }                      P6any nw = new P6opaque(setting.CaptureMO);                      Variable[] spos = new Variable[pos.Length - posc];                      Array.Copy(pos' posc' spos' 0' spos.Length);                      VarHash snamed = null;                      if (named != null) {                          snamed = new VarHash();                          foreach (string k in named.Keys) {                              if (namedc.Contains(k))                                  snamed[k] = named[k];                          }                      }                      nw.SetSlot(setting.CaptureMO' "$!positionals"' spos);                      nw.SetSlot(setting.CaptureMO' "$!named"' snamed);                      src = nw;                      named = null; namedc = null; posc = pos.Length;                      goto gotit;                  }                  if ((flags & Parameter.SLURPY_POS) != 0) {                      P6any l = new P6opaque(setting.ListMO);                      Kernel.IterToList(l' Kernel.IterFlatten(                                  Kernel.SlurpyHelper(pos' posc)));                      src = Kernel.NewRWListVar(l);                      posc = pos.Length;                      goto gotit;                  }                  if ((flags & Parameter.SLURPY_NAM) != 0) {                      VarHash nh = new VarHash();                      if (named != null) {                          foreach (KeyValuePair<string'Variable> kv in named)                              if (namedc.Contains(kv.Key))                                  nh[kv.Key] = kv.Value;                          named = null;                          namedc = null;                      }                      src = Kernel.BoxAnyMO(nh' setting.HashMO);                      goto gotit;                  }                  if (names != null && named != null) {                      for (int ni = 0; ni < names.Length; ni++) {                          string n = names[ni];                          if (namedc.Contains(n)) {                              namedc.Remove(n);                              src = named[n];                              obj_src_n = n;                              obj_src = -2;                              goto gotit;                          }                      }                  }                  if ((flags & Parameter.POSITIONAL) != 0 && posc != pos.Length) {                      obj_src = posc;                      src = pos[posc++];                      goto gotit;                  }  get_default:                  if ((flags & Parameter.HASDEFAULT) != 0) {                      if (param.def is Variable) {                          src = (Variable)param.def;                      } else {                          Frame thn = Kernel.GetInferiorRoot(setting)                              .MakeChild(th' (SubInfo)param.def' setting.AnyP);                          src = Kernel.RunInferior(thn);                          if (src == null)                              throw new Exception("Improper null return from sub default for '" + param.name + "' in '" + signame + "'");                      }                      goto gotit;                  }                  if ((flags & Parameter.DEFOUTER) != 0) {                      Frame f = th;                      if (th.info.outer_topic_key < 0) {                          src = setting.AnyP;                          goto gotit;                      }                      for (int i = 0; i < th.info.outer_topic_rank; i++) f = f.outer;                      src = (Variable)f.GetDynamic(th.info.outer_topic_key);                      goto gotit;                  }                  if ((flags & Parameter.OPTIONAL) != 0) {                      // Array is the "default" Positional -masak                      if ((flags & Parameter.IS_LIST) != 0)                          src = setting.CreateArray();                      else if ((flags & Parameter.IS_HASH) != 0)                          src = setting.CreateHash();                      else                          src = type.initObj;                      goto gotit;                  }                  if (quiet) return false;                  throw new NieczaException("No value for parameter '" + param.name + "' in '" + signame + "'");  gotit:                  switch ((flags & Parameter.DEF_MASK) >> Parameter.DEF_SHIFT) {                      // TODO: Failure will make these cases different                      case Parameter.TYPE_ONLY >> Parameter.DEF_SHIFT:                      case Parameter.UNDEF_ONLY >> Parameter.DEF_SHIFT:                          if (!src.Fetch().IsDefined())                              break;                          if (quiet) return false;                          throw new NieczaException("Parameter '" + param.name + "' in '" + signame + "' requires an undefined argument");                      case Parameter.DEF_ONLY >> Parameter.DEF_SHIFT:                          if (src.Fetch().IsDefined())                              break;                          if (quiet) return false;                          throw new NieczaException("Parameter '" + param.name + "' in '" + signame + "' requires a defined argument");                      default:                          break;                  }                  if ((flags & Parameter.RWTRANS) != 0) {                  } else if ((flags & Parameter.IS_COPY) != 0) {                      if ((flags & Parameter.IS_HASH) != 0)                          src = Kernel.Assign(setting.CreateHash()'                              Kernel.NewRWListVar(src.Fetch()));                      else if ((flags & Parameter.IS_LIST) != 0)                          src = Kernel.Assign(setting.CreateArray()'                              Kernel.NewRWListVar(src.Fetch()));                      else                          src = Kernel.Assign(type == null ? setting.NewMuAnyScalar() : Kernel.NewTypedScalar(type)' src);                  } else {                      bool islist = ((flags & (Parameter.IS_HASH | Parameter.IS_LIST)) != 0);                      bool rw     = ((flags & Parameter.READWRITE) != 0) && !islist;                      P6any srco  = src.Fetch();                        // XXX: in order for calling methods on Nil to work'                      // self needs to be ignored here.                      if (srco == setting.NilP && obj_src != -1 &&                              (flags & Parameter.INVOCANT) == 0) {                          obj_src = -1;                          goto get_default;                      }                      if ((flags & Parameter.IS_LIST) != 0)                          type = setting.PositionalMO;                      if ((flags & Parameter.IS_HASH) != 0)                          type = setting.AssociativeMO;                      if ((flags & Parameter.CALLABLE) != 0)                          type = setting.CallableMO;                      if (!srco.Does(type)) {                          if (quiet) return false;                          if (srco.mo.HasType(setting.JunctionMO) && obj_src != -1 && (mode & NO_JUNCTION) == 0) {                              int jrank = Kernel.UnboxAny<int>((P6any) ((P6opaque)srco).slots[0]) / 2;                              if (jrank < jun_rank) {                                  jun_rank = jrank;                                  jun_pivot = obj_src;                                  jun_pivot_n = obj_src_n;                              }                              continue;                          }                          throw new NieczaException("Nominal type check failed in binding '" + param.name + "' in '" + signame + "'; got " + srco.mo.name + "' needed " + type.name);                      }                        if (rw) {                          if (src.Rw) {                              // this will be a functional RW binding                              src.Vivify();                              goto bound;                          } else {                              if (quiet) return false;                              throw new NieczaException("Binding '" + param.name + "' in '" + signame + "'' cannot bind read-only value to is rw parameter");                          }                      }                      else {                          if (src.Mode == (islist ? Variable.LIST : Variable.RO))                              goto bound;                          src = islist ? (Variable)new ListVariable(srco) : srco;                      }  bound: ;                  }                  if (param.attribute != null) {                      object self;                      if (!th.TryGetDynamic("self"' 0' out self))                          throw new NieczaException("No 'self' available for attributive?");                      Variable selfv = (Variable)self;                      if (param.attribute[1] == '!') {                          Kernel.Assign(((Variable)(selfv.Fetch().                              GetSlot(param.attribute_type' param.attribute)))'                                  src);                      } else {                          Variable dest = Builtins.InvokeMethod(                                  param.attribute.Substring(2)' selfv);                          Kernel.Assign(dest' src);                      }                  }                  if ((flags & Parameter.INVOCANT) != 0 && th.info.self_key >= 0)                      th.SetDynamic(th.info.self_key' src);                  switch (slot + 1) {                      case 0: break;                      case 1:  th.lex0 = src; break;                      case 2:  th.lex1 = src; break;                      case 3:  th.lex2 = src; break;                      case 4:  th.lex3 = src; break;                      case 5:  th.lex4 = src; break;                      case 6:  th.lex5 = src; break;                      case 7:  th.lex6 = src; break;                      case 8:  th.lex7 = src; break;                      case 9:  th.lex8 = src; break;                      case 10: th.lex9 = src; break;                      default: th.lexn[slot - 10] = src; break;                  }                  // Really' this should be earlier (next to the :D/:U checks);                  // it's not right to be binding variables before doing                  // constraint checks.  We're compromising a bit of purity here                  // for the sake of making 'Int $odd where { $odd % 2 }' DWIM.                  if (param.post_constraints != null) {                      foreach (object c in param.post_constraints)                          if (!RunConstraint(th' signame' param' quiet' src' c))                              return false;                  }              }
Magic Number,Niecza,Frame,C:\repos\sorear_niecza\lib\Kernel.cs,BindSignature,The following statement contains a magic number: while (pix != pend) {                  Parameter param = pbuf[pix++];                  int flags = param.flags;                  int slot = param.slot;                  string[] names = param.names;                  STable type = param.type;                  obj_src = -1;                    Variable src = null;                  if ((flags & Parameter.SLURPY_PCL) != 0) {                      src = (slot >= 0) ? Kernel.BoxAnyMO(pos' setting.ParcelMO) :                          setting.AnyP;                      posc  = pos.Length;                      goto gotit;                  }                  if ((flags & Parameter.SLURPY_CAP) != 0) {                      if (slot < 0) {                          src = setting.AnyP;                          named = null; namedc = null; posc = pos.Length;                          goto gotit;                      }                      P6any nw = new P6opaque(setting.CaptureMO);                      Variable[] spos = new Variable[pos.Length - posc];                      Array.Copy(pos' posc' spos' 0' spos.Length);                      VarHash snamed = null;                      if (named != null) {                          snamed = new VarHash();                          foreach (string k in named.Keys) {                              if (namedc.Contains(k))                                  snamed[k] = named[k];                          }                      }                      nw.SetSlot(setting.CaptureMO' "$!positionals"' spos);                      nw.SetSlot(setting.CaptureMO' "$!named"' snamed);                      src = nw;                      named = null; namedc = null; posc = pos.Length;                      goto gotit;                  }                  if ((flags & Parameter.SLURPY_POS) != 0) {                      P6any l = new P6opaque(setting.ListMO);                      Kernel.IterToList(l' Kernel.IterFlatten(                                  Kernel.SlurpyHelper(pos' posc)));                      src = Kernel.NewRWListVar(l);                      posc = pos.Length;                      goto gotit;                  }                  if ((flags & Parameter.SLURPY_NAM) != 0) {                      VarHash nh = new VarHash();                      if (named != null) {                          foreach (KeyValuePair<string'Variable> kv in named)                              if (namedc.Contains(kv.Key))                                  nh[kv.Key] = kv.Value;                          named = null;                          namedc = null;                      }                      src = Kernel.BoxAnyMO(nh' setting.HashMO);                      goto gotit;                  }                  if (names != null && named != null) {                      for (int ni = 0; ni < names.Length; ni++) {                          string n = names[ni];                          if (namedc.Contains(n)) {                              namedc.Remove(n);                              src = named[n];                              obj_src_n = n;                              obj_src = -2;                              goto gotit;                          }                      }                  }                  if ((flags & Parameter.POSITIONAL) != 0 && posc != pos.Length) {                      obj_src = posc;                      src = pos[posc++];                      goto gotit;                  }  get_default:                  if ((flags & Parameter.HASDEFAULT) != 0) {                      if (param.def is Variable) {                          src = (Variable)param.def;                      } else {                          Frame thn = Kernel.GetInferiorRoot(setting)                              .MakeChild(th' (SubInfo)param.def' setting.AnyP);                          src = Kernel.RunInferior(thn);                          if (src == null)                              throw new Exception("Improper null return from sub default for '" + param.name + "' in '" + signame + "'");                      }                      goto gotit;                  }                  if ((flags & Parameter.DEFOUTER) != 0) {                      Frame f = th;                      if (th.info.outer_topic_key < 0) {                          src = setting.AnyP;                          goto gotit;                      }                      for (int i = 0; i < th.info.outer_topic_rank; i++) f = f.outer;                      src = (Variable)f.GetDynamic(th.info.outer_topic_key);                      goto gotit;                  }                  if ((flags & Parameter.OPTIONAL) != 0) {                      // Array is the "default" Positional -masak                      if ((flags & Parameter.IS_LIST) != 0)                          src = setting.CreateArray();                      else if ((flags & Parameter.IS_HASH) != 0)                          src = setting.CreateHash();                      else                          src = type.initObj;                      goto gotit;                  }                  if (quiet) return false;                  throw new NieczaException("No value for parameter '" + param.name + "' in '" + signame + "'");  gotit:                  switch ((flags & Parameter.DEF_MASK) >> Parameter.DEF_SHIFT) {                      // TODO: Failure will make these cases different                      case Parameter.TYPE_ONLY >> Parameter.DEF_SHIFT:                      case Parameter.UNDEF_ONLY >> Parameter.DEF_SHIFT:                          if (!src.Fetch().IsDefined())                              break;                          if (quiet) return false;                          throw new NieczaException("Parameter '" + param.name + "' in '" + signame + "' requires an undefined argument");                      case Parameter.DEF_ONLY >> Parameter.DEF_SHIFT:                          if (src.Fetch().IsDefined())                              break;                          if (quiet) return false;                          throw new NieczaException("Parameter '" + param.name + "' in '" + signame + "' requires a defined argument");                      default:                          break;                  }                  if ((flags & Parameter.RWTRANS) != 0) {                  } else if ((flags & Parameter.IS_COPY) != 0) {                      if ((flags & Parameter.IS_HASH) != 0)                          src = Kernel.Assign(setting.CreateHash()'                              Kernel.NewRWListVar(src.Fetch()));                      else if ((flags & Parameter.IS_LIST) != 0)                          src = Kernel.Assign(setting.CreateArray()'                              Kernel.NewRWListVar(src.Fetch()));                      else                          src = Kernel.Assign(type == null ? setting.NewMuAnyScalar() : Kernel.NewTypedScalar(type)' src);                  } else {                      bool islist = ((flags & (Parameter.IS_HASH | Parameter.IS_LIST)) != 0);                      bool rw     = ((flags & Parameter.READWRITE) != 0) && !islist;                      P6any srco  = src.Fetch();                        // XXX: in order for calling methods on Nil to work'                      // self needs to be ignored here.                      if (srco == setting.NilP && obj_src != -1 &&                              (flags & Parameter.INVOCANT) == 0) {                          obj_src = -1;                          goto get_default;                      }                      if ((flags & Parameter.IS_LIST) != 0)                          type = setting.PositionalMO;                      if ((flags & Parameter.IS_HASH) != 0)                          type = setting.AssociativeMO;                      if ((flags & Parameter.CALLABLE) != 0)                          type = setting.CallableMO;                      if (!srco.Does(type)) {                          if (quiet) return false;                          if (srco.mo.HasType(setting.JunctionMO) && obj_src != -1 && (mode & NO_JUNCTION) == 0) {                              int jrank = Kernel.UnboxAny<int>((P6any) ((P6opaque)srco).slots[0]) / 2;                              if (jrank < jun_rank) {                                  jun_rank = jrank;                                  jun_pivot = obj_src;                                  jun_pivot_n = obj_src_n;                              }                              continue;                          }                          throw new NieczaException("Nominal type check failed in binding '" + param.name + "' in '" + signame + "'; got " + srco.mo.name + "' needed " + type.name);                      }                        if (rw) {                          if (src.Rw) {                              // this will be a functional RW binding                              src.Vivify();                              goto bound;                          } else {                              if (quiet) return false;                              throw new NieczaException("Binding '" + param.name + "' in '" + signame + "'' cannot bind read-only value to is rw parameter");                          }                      }                      else {                          if (src.Mode == (islist ? Variable.LIST : Variable.RO))                              goto bound;                          src = islist ? (Variable)new ListVariable(srco) : srco;                      }  bound: ;                  }                  if (param.attribute != null) {                      object self;                      if (!th.TryGetDynamic("self"' 0' out self))                          throw new NieczaException("No 'self' available for attributive?");                      Variable selfv = (Variable)self;                      if (param.attribute[1] == '!') {                          Kernel.Assign(((Variable)(selfv.Fetch().                              GetSlot(param.attribute_type' param.attribute)))'                                  src);                      } else {                          Variable dest = Builtins.InvokeMethod(                                  param.attribute.Substring(2)' selfv);                          Kernel.Assign(dest' src);                      }                  }                  if ((flags & Parameter.INVOCANT) != 0 && th.info.self_key >= 0)                      th.SetDynamic(th.info.self_key' src);                  switch (slot + 1) {                      case 0: break;                      case 1:  th.lex0 = src; break;                      case 2:  th.lex1 = src; break;                      case 3:  th.lex2 = src; break;                      case 4:  th.lex3 = src; break;                      case 5:  th.lex4 = src; break;                      case 6:  th.lex5 = src; break;                      case 7:  th.lex6 = src; break;                      case 8:  th.lex7 = src; break;                      case 9:  th.lex8 = src; break;                      case 10: th.lex9 = src; break;                      default: th.lexn[slot - 10] = src; break;                  }                  // Really' this should be earlier (next to the :D/:U checks);                  // it's not right to be binding variables before doing                  // constraint checks.  We're compromising a bit of purity here                  // for the sake of making 'Int $odd where { $odd % 2 }' DWIM.                  if (param.post_constraints != null) {                      foreach (object c in param.post_constraints)                          if (!RunConstraint(th' signame' param' quiet' src' c))                              return false;                  }              }
Magic Number,Niecza,Frame,C:\repos\sorear_niecza\lib\Kernel.cs,BindSignature,The following statement contains a magic number: while (pix != pend) {                  Parameter param = pbuf[pix++];                  int flags = param.flags;                  int slot = param.slot;                  string[] names = param.names;                  STable type = param.type;                  obj_src = -1;                    Variable src = null;                  if ((flags & Parameter.SLURPY_PCL) != 0) {                      src = (slot >= 0) ? Kernel.BoxAnyMO(pos' setting.ParcelMO) :                          setting.AnyP;                      posc  = pos.Length;                      goto gotit;                  }                  if ((flags & Parameter.SLURPY_CAP) != 0) {                      if (slot < 0) {                          src = setting.AnyP;                          named = null; namedc = null; posc = pos.Length;                          goto gotit;                      }                      P6any nw = new P6opaque(setting.CaptureMO);                      Variable[] spos = new Variable[pos.Length - posc];                      Array.Copy(pos' posc' spos' 0' spos.Length);                      VarHash snamed = null;                      if (named != null) {                          snamed = new VarHash();                          foreach (string k in named.Keys) {                              if (namedc.Contains(k))                                  snamed[k] = named[k];                          }                      }                      nw.SetSlot(setting.CaptureMO' "$!positionals"' spos);                      nw.SetSlot(setting.CaptureMO' "$!named"' snamed);                      src = nw;                      named = null; namedc = null; posc = pos.Length;                      goto gotit;                  }                  if ((flags & Parameter.SLURPY_POS) != 0) {                      P6any l = new P6opaque(setting.ListMO);                      Kernel.IterToList(l' Kernel.IterFlatten(                                  Kernel.SlurpyHelper(pos' posc)));                      src = Kernel.NewRWListVar(l);                      posc = pos.Length;                      goto gotit;                  }                  if ((flags & Parameter.SLURPY_NAM) != 0) {                      VarHash nh = new VarHash();                      if (named != null) {                          foreach (KeyValuePair<string'Variable> kv in named)                              if (namedc.Contains(kv.Key))                                  nh[kv.Key] = kv.Value;                          named = null;                          namedc = null;                      }                      src = Kernel.BoxAnyMO(nh' setting.HashMO);                      goto gotit;                  }                  if (names != null && named != null) {                      for (int ni = 0; ni < names.Length; ni++) {                          string n = names[ni];                          if (namedc.Contains(n)) {                              namedc.Remove(n);                              src = named[n];                              obj_src_n = n;                              obj_src = -2;                              goto gotit;                          }                      }                  }                  if ((flags & Parameter.POSITIONAL) != 0 && posc != pos.Length) {                      obj_src = posc;                      src = pos[posc++];                      goto gotit;                  }  get_default:                  if ((flags & Parameter.HASDEFAULT) != 0) {                      if (param.def is Variable) {                          src = (Variable)param.def;                      } else {                          Frame thn = Kernel.GetInferiorRoot(setting)                              .MakeChild(th' (SubInfo)param.def' setting.AnyP);                          src = Kernel.RunInferior(thn);                          if (src == null)                              throw new Exception("Improper null return from sub default for '" + param.name + "' in '" + signame + "'");                      }                      goto gotit;                  }                  if ((flags & Parameter.DEFOUTER) != 0) {                      Frame f = th;                      if (th.info.outer_topic_key < 0) {                          src = setting.AnyP;                          goto gotit;                      }                      for (int i = 0; i < th.info.outer_topic_rank; i++) f = f.outer;                      src = (Variable)f.GetDynamic(th.info.outer_topic_key);                      goto gotit;                  }                  if ((flags & Parameter.OPTIONAL) != 0) {                      // Array is the "default" Positional -masak                      if ((flags & Parameter.IS_LIST) != 0)                          src = setting.CreateArray();                      else if ((flags & Parameter.IS_HASH) != 0)                          src = setting.CreateHash();                      else                          src = type.initObj;                      goto gotit;                  }                  if (quiet) return false;                  throw new NieczaException("No value for parameter '" + param.name + "' in '" + signame + "'");  gotit:                  switch ((flags & Parameter.DEF_MASK) >> Parameter.DEF_SHIFT) {                      // TODO: Failure will make these cases different                      case Parameter.TYPE_ONLY >> Parameter.DEF_SHIFT:                      case Parameter.UNDEF_ONLY >> Parameter.DEF_SHIFT:                          if (!src.Fetch().IsDefined())                              break;                          if (quiet) return false;                          throw new NieczaException("Parameter '" + param.name + "' in '" + signame + "' requires an undefined argument");                      case Parameter.DEF_ONLY >> Parameter.DEF_SHIFT:                          if (src.Fetch().IsDefined())                              break;                          if (quiet) return false;                          throw new NieczaException("Parameter '" + param.name + "' in '" + signame + "' requires a defined argument");                      default:                          break;                  }                  if ((flags & Parameter.RWTRANS) != 0) {                  } else if ((flags & Parameter.IS_COPY) != 0) {                      if ((flags & Parameter.IS_HASH) != 0)                          src = Kernel.Assign(setting.CreateHash()'                              Kernel.NewRWListVar(src.Fetch()));                      else if ((flags & Parameter.IS_LIST) != 0)                          src = Kernel.Assign(setting.CreateArray()'                              Kernel.NewRWListVar(src.Fetch()));                      else                          src = Kernel.Assign(type == null ? setting.NewMuAnyScalar() : Kernel.NewTypedScalar(type)' src);                  } else {                      bool islist = ((flags & (Parameter.IS_HASH | Parameter.IS_LIST)) != 0);                      bool rw     = ((flags & Parameter.READWRITE) != 0) && !islist;                      P6any srco  = src.Fetch();                        // XXX: in order for calling methods on Nil to work'                      // self needs to be ignored here.                      if (srco == setting.NilP && obj_src != -1 &&                              (flags & Parameter.INVOCANT) == 0) {                          obj_src = -1;                          goto get_default;                      }                      if ((flags & Parameter.IS_LIST) != 0)                          type = setting.PositionalMO;                      if ((flags & Parameter.IS_HASH) != 0)                          type = setting.AssociativeMO;                      if ((flags & Parameter.CALLABLE) != 0)                          type = setting.CallableMO;                      if (!srco.Does(type)) {                          if (quiet) return false;                          if (srco.mo.HasType(setting.JunctionMO) && obj_src != -1 && (mode & NO_JUNCTION) == 0) {                              int jrank = Kernel.UnboxAny<int>((P6any) ((P6opaque)srco).slots[0]) / 2;                              if (jrank < jun_rank) {                                  jun_rank = jrank;                                  jun_pivot = obj_src;                                  jun_pivot_n = obj_src_n;                              }                              continue;                          }                          throw new NieczaException("Nominal type check failed in binding '" + param.name + "' in '" + signame + "'; got " + srco.mo.name + "' needed " + type.name);                      }                        if (rw) {                          if (src.Rw) {                              // this will be a functional RW binding                              src.Vivify();                              goto bound;                          } else {                              if (quiet) return false;                              throw new NieczaException("Binding '" + param.name + "' in '" + signame + "'' cannot bind read-only value to is rw parameter");                          }                      }                      else {                          if (src.Mode == (islist ? Variable.LIST : Variable.RO))                              goto bound;                          src = islist ? (Variable)new ListVariable(srco) : srco;                      }  bound: ;                  }                  if (param.attribute != null) {                      object self;                      if (!th.TryGetDynamic("self"' 0' out self))                          throw new NieczaException("No 'self' available for attributive?");                      Variable selfv = (Variable)self;                      if (param.attribute[1] == '!') {                          Kernel.Assign(((Variable)(selfv.Fetch().                              GetSlot(param.attribute_type' param.attribute)))'                                  src);                      } else {                          Variable dest = Builtins.InvokeMethod(                                  param.attribute.Substring(2)' selfv);                          Kernel.Assign(dest' src);                      }                  }                  if ((flags & Parameter.INVOCANT) != 0 && th.info.self_key >= 0)                      th.SetDynamic(th.info.self_key' src);                  switch (slot + 1) {                      case 0: break;                      case 1:  th.lex0 = src; break;                      case 2:  th.lex1 = src; break;                      case 3:  th.lex2 = src; break;                      case 4:  th.lex3 = src; break;                      case 5:  th.lex4 = src; break;                      case 6:  th.lex5 = src; break;                      case 7:  th.lex6 = src; break;                      case 8:  th.lex7 = src; break;                      case 9:  th.lex8 = src; break;                      case 10: th.lex9 = src; break;                      default: th.lexn[slot - 10] = src; break;                  }                  // Really' this should be earlier (next to the :D/:U checks);                  // it's not right to be binding variables before doing                  // constraint checks.  We're compromising a bit of purity here                  // for the sake of making 'Int $odd where { $odd % 2 }' DWIM.                  if (param.post_constraints != null) {                      foreach (object c in param.post_constraints)                          if (!RunConstraint(th' signame' param' quiet' src' c))                              return false;                  }              }
Magic Number,Niecza,Frame,C:\repos\sorear_niecza\lib\Kernel.cs,BindSignature,The following statement contains a magic number: while (pix != pend) {                  Parameter param = pbuf[pix++];                  int flags = param.flags;                  int slot = param.slot;                  string[] names = param.names;                  STable type = param.type;                  obj_src = -1;                    Variable src = null;                  if ((flags & Parameter.SLURPY_PCL) != 0) {                      src = (slot >= 0) ? Kernel.BoxAnyMO(pos' setting.ParcelMO) :                          setting.AnyP;                      posc  = pos.Length;                      goto gotit;                  }                  if ((flags & Parameter.SLURPY_CAP) != 0) {                      if (slot < 0) {                          src = setting.AnyP;                          named = null; namedc = null; posc = pos.Length;                          goto gotit;                      }                      P6any nw = new P6opaque(setting.CaptureMO);                      Variable[] spos = new Variable[pos.Length - posc];                      Array.Copy(pos' posc' spos' 0' spos.Length);                      VarHash snamed = null;                      if (named != null) {                          snamed = new VarHash();                          foreach (string k in named.Keys) {                              if (namedc.Contains(k))                                  snamed[k] = named[k];                          }                      }                      nw.SetSlot(setting.CaptureMO' "$!positionals"' spos);                      nw.SetSlot(setting.CaptureMO' "$!named"' snamed);                      src = nw;                      named = null; namedc = null; posc = pos.Length;                      goto gotit;                  }                  if ((flags & Parameter.SLURPY_POS) != 0) {                      P6any l = new P6opaque(setting.ListMO);                      Kernel.IterToList(l' Kernel.IterFlatten(                                  Kernel.SlurpyHelper(pos' posc)));                      src = Kernel.NewRWListVar(l);                      posc = pos.Length;                      goto gotit;                  }                  if ((flags & Parameter.SLURPY_NAM) != 0) {                      VarHash nh = new VarHash();                      if (named != null) {                          foreach (KeyValuePair<string'Variable> kv in named)                              if (namedc.Contains(kv.Key))                                  nh[kv.Key] = kv.Value;                          named = null;                          namedc = null;                      }                      src = Kernel.BoxAnyMO(nh' setting.HashMO);                      goto gotit;                  }                  if (names != null && named != null) {                      for (int ni = 0; ni < names.Length; ni++) {                          string n = names[ni];                          if (namedc.Contains(n)) {                              namedc.Remove(n);                              src = named[n];                              obj_src_n = n;                              obj_src = -2;                              goto gotit;                          }                      }                  }                  if ((flags & Parameter.POSITIONAL) != 0 && posc != pos.Length) {                      obj_src = posc;                      src = pos[posc++];                      goto gotit;                  }  get_default:                  if ((flags & Parameter.HASDEFAULT) != 0) {                      if (param.def is Variable) {                          src = (Variable)param.def;                      } else {                          Frame thn = Kernel.GetInferiorRoot(setting)                              .MakeChild(th' (SubInfo)param.def' setting.AnyP);                          src = Kernel.RunInferior(thn);                          if (src == null)                              throw new Exception("Improper null return from sub default for '" + param.name + "' in '" + signame + "'");                      }                      goto gotit;                  }                  if ((flags & Parameter.DEFOUTER) != 0) {                      Frame f = th;                      if (th.info.outer_topic_key < 0) {                          src = setting.AnyP;                          goto gotit;                      }                      for (int i = 0; i < th.info.outer_topic_rank; i++) f = f.outer;                      src = (Variable)f.GetDynamic(th.info.outer_topic_key);                      goto gotit;                  }                  if ((flags & Parameter.OPTIONAL) != 0) {                      // Array is the "default" Positional -masak                      if ((flags & Parameter.IS_LIST) != 0)                          src = setting.CreateArray();                      else if ((flags & Parameter.IS_HASH) != 0)                          src = setting.CreateHash();                      else                          src = type.initObj;                      goto gotit;                  }                  if (quiet) return false;                  throw new NieczaException("No value for parameter '" + param.name + "' in '" + signame + "'");  gotit:                  switch ((flags & Parameter.DEF_MASK) >> Parameter.DEF_SHIFT) {                      // TODO: Failure will make these cases different                      case Parameter.TYPE_ONLY >> Parameter.DEF_SHIFT:                      case Parameter.UNDEF_ONLY >> Parameter.DEF_SHIFT:                          if (!src.Fetch().IsDefined())                              break;                          if (quiet) return false;                          throw new NieczaException("Parameter '" + param.name + "' in '" + signame + "' requires an undefined argument");                      case Parameter.DEF_ONLY >> Parameter.DEF_SHIFT:                          if (src.Fetch().IsDefined())                              break;                          if (quiet) return false;                          throw new NieczaException("Parameter '" + param.name + "' in '" + signame + "' requires a defined argument");                      default:                          break;                  }                  if ((flags & Parameter.RWTRANS) != 0) {                  } else if ((flags & Parameter.IS_COPY) != 0) {                      if ((flags & Parameter.IS_HASH) != 0)                          src = Kernel.Assign(setting.CreateHash()'                              Kernel.NewRWListVar(src.Fetch()));                      else if ((flags & Parameter.IS_LIST) != 0)                          src = Kernel.Assign(setting.CreateArray()'                              Kernel.NewRWListVar(src.Fetch()));                      else                          src = Kernel.Assign(type == null ? setting.NewMuAnyScalar() : Kernel.NewTypedScalar(type)' src);                  } else {                      bool islist = ((flags & (Parameter.IS_HASH | Parameter.IS_LIST)) != 0);                      bool rw     = ((flags & Parameter.READWRITE) != 0) && !islist;                      P6any srco  = src.Fetch();                        // XXX: in order for calling methods on Nil to work'                      // self needs to be ignored here.                      if (srco == setting.NilP && obj_src != -1 &&                              (flags & Parameter.INVOCANT) == 0) {                          obj_src = -1;                          goto get_default;                      }                      if ((flags & Parameter.IS_LIST) != 0)                          type = setting.PositionalMO;                      if ((flags & Parameter.IS_HASH) != 0)                          type = setting.AssociativeMO;                      if ((flags & Parameter.CALLABLE) != 0)                          type = setting.CallableMO;                      if (!srco.Does(type)) {                          if (quiet) return false;                          if (srco.mo.HasType(setting.JunctionMO) && obj_src != -1 && (mode & NO_JUNCTION) == 0) {                              int jrank = Kernel.UnboxAny<int>((P6any) ((P6opaque)srco).slots[0]) / 2;                              if (jrank < jun_rank) {                                  jun_rank = jrank;                                  jun_pivot = obj_src;                                  jun_pivot_n = obj_src_n;                              }                              continue;                          }                          throw new NieczaException("Nominal type check failed in binding '" + param.name + "' in '" + signame + "'; got " + srco.mo.name + "' needed " + type.name);                      }                        if (rw) {                          if (src.Rw) {                              // this will be a functional RW binding                              src.Vivify();                              goto bound;                          } else {                              if (quiet) return false;                              throw new NieczaException("Binding '" + param.name + "' in '" + signame + "'' cannot bind read-only value to is rw parameter");                          }                      }                      else {                          if (src.Mode == (islist ? Variable.LIST : Variable.RO))                              goto bound;                          src = islist ? (Variable)new ListVariable(srco) : srco;                      }  bound: ;                  }                  if (param.attribute != null) {                      object self;                      if (!th.TryGetDynamic("self"' 0' out self))                          throw new NieczaException("No 'self' available for attributive?");                      Variable selfv = (Variable)self;                      if (param.attribute[1] == '!') {                          Kernel.Assign(((Variable)(selfv.Fetch().                              GetSlot(param.attribute_type' param.attribute)))'                                  src);                      } else {                          Variable dest = Builtins.InvokeMethod(                                  param.attribute.Substring(2)' selfv);                          Kernel.Assign(dest' src);                      }                  }                  if ((flags & Parameter.INVOCANT) != 0 && th.info.self_key >= 0)                      th.SetDynamic(th.info.self_key' src);                  switch (slot + 1) {                      case 0: break;                      case 1:  th.lex0 = src; break;                      case 2:  th.lex1 = src; break;                      case 3:  th.lex2 = src; break;                      case 4:  th.lex3 = src; break;                      case 5:  th.lex4 = src; break;                      case 6:  th.lex5 = src; break;                      case 7:  th.lex6 = src; break;                      case 8:  th.lex7 = src; break;                      case 9:  th.lex8 = src; break;                      case 10: th.lex9 = src; break;                      default: th.lexn[slot - 10] = src; break;                  }                  // Really' this should be earlier (next to the :D/:U checks);                  // it's not right to be binding variables before doing                  // constraint checks.  We're compromising a bit of purity here                  // for the sake of making 'Int $odd where { $odd % 2 }' DWIM.                  if (param.post_constraints != null) {                      foreach (object c in param.post_constraints)                          if (!RunConstraint(th' signame' param' quiet' src' c))                              return false;                  }              }
Magic Number,Niecza,Frame,C:\repos\sorear_niecza\lib\Kernel.cs,BindSignature,The following statement contains a magic number: while (pix != pend) {                  Parameter param = pbuf[pix++];                  int flags = param.flags;                  int slot = param.slot;                  string[] names = param.names;                  STable type = param.type;                  obj_src = -1;                    Variable src = null;                  if ((flags & Parameter.SLURPY_PCL) != 0) {                      src = (slot >= 0) ? Kernel.BoxAnyMO(pos' setting.ParcelMO) :                          setting.AnyP;                      posc  = pos.Length;                      goto gotit;                  }                  if ((flags & Parameter.SLURPY_CAP) != 0) {                      if (slot < 0) {                          src = setting.AnyP;                          named = null; namedc = null; posc = pos.Length;                          goto gotit;                      }                      P6any nw = new P6opaque(setting.CaptureMO);                      Variable[] spos = new Variable[pos.Length - posc];                      Array.Copy(pos' posc' spos' 0' spos.Length);                      VarHash snamed = null;                      if (named != null) {                          snamed = new VarHash();                          foreach (string k in named.Keys) {                              if (namedc.Contains(k))                                  snamed[k] = named[k];                          }                      }                      nw.SetSlot(setting.CaptureMO' "$!positionals"' spos);                      nw.SetSlot(setting.CaptureMO' "$!named"' snamed);                      src = nw;                      named = null; namedc = null; posc = pos.Length;                      goto gotit;                  }                  if ((flags & Parameter.SLURPY_POS) != 0) {                      P6any l = new P6opaque(setting.ListMO);                      Kernel.IterToList(l' Kernel.IterFlatten(                                  Kernel.SlurpyHelper(pos' posc)));                      src = Kernel.NewRWListVar(l);                      posc = pos.Length;                      goto gotit;                  }                  if ((flags & Parameter.SLURPY_NAM) != 0) {                      VarHash nh = new VarHash();                      if (named != null) {                          foreach (KeyValuePair<string'Variable> kv in named)                              if (namedc.Contains(kv.Key))                                  nh[kv.Key] = kv.Value;                          named = null;                          namedc = null;                      }                      src = Kernel.BoxAnyMO(nh' setting.HashMO);                      goto gotit;                  }                  if (names != null && named != null) {                      for (int ni = 0; ni < names.Length; ni++) {                          string n = names[ni];                          if (namedc.Contains(n)) {                              namedc.Remove(n);                              src = named[n];                              obj_src_n = n;                              obj_src = -2;                              goto gotit;                          }                      }                  }                  if ((flags & Parameter.POSITIONAL) != 0 && posc != pos.Length) {                      obj_src = posc;                      src = pos[posc++];                      goto gotit;                  }  get_default:                  if ((flags & Parameter.HASDEFAULT) != 0) {                      if (param.def is Variable) {                          src = (Variable)param.def;                      } else {                          Frame thn = Kernel.GetInferiorRoot(setting)                              .MakeChild(th' (SubInfo)param.def' setting.AnyP);                          src = Kernel.RunInferior(thn);                          if (src == null)                              throw new Exception("Improper null return from sub default for '" + param.name + "' in '" + signame + "'");                      }                      goto gotit;                  }                  if ((flags & Parameter.DEFOUTER) != 0) {                      Frame f = th;                      if (th.info.outer_topic_key < 0) {                          src = setting.AnyP;                          goto gotit;                      }                      for (int i = 0; i < th.info.outer_topic_rank; i++) f = f.outer;                      src = (Variable)f.GetDynamic(th.info.outer_topic_key);                      goto gotit;                  }                  if ((flags & Parameter.OPTIONAL) != 0) {                      // Array is the "default" Positional -masak                      if ((flags & Parameter.IS_LIST) != 0)                          src = setting.CreateArray();                      else if ((flags & Parameter.IS_HASH) != 0)                          src = setting.CreateHash();                      else                          src = type.initObj;                      goto gotit;                  }                  if (quiet) return false;                  throw new NieczaException("No value for parameter '" + param.name + "' in '" + signame + "'");  gotit:                  switch ((flags & Parameter.DEF_MASK) >> Parameter.DEF_SHIFT) {                      // TODO: Failure will make these cases different                      case Parameter.TYPE_ONLY >> Parameter.DEF_SHIFT:                      case Parameter.UNDEF_ONLY >> Parameter.DEF_SHIFT:                          if (!src.Fetch().IsDefined())                              break;                          if (quiet) return false;                          throw new NieczaException("Parameter '" + param.name + "' in '" + signame + "' requires an undefined argument");                      case Parameter.DEF_ONLY >> Parameter.DEF_SHIFT:                          if (src.Fetch().IsDefined())                              break;                          if (quiet) return false;                          throw new NieczaException("Parameter '" + param.name + "' in '" + signame + "' requires a defined argument");                      default:                          break;                  }                  if ((flags & Parameter.RWTRANS) != 0) {                  } else if ((flags & Parameter.IS_COPY) != 0) {                      if ((flags & Parameter.IS_HASH) != 0)                          src = Kernel.Assign(setting.CreateHash()'                              Kernel.NewRWListVar(src.Fetch()));                      else if ((flags & Parameter.IS_LIST) != 0)                          src = Kernel.Assign(setting.CreateArray()'                              Kernel.NewRWListVar(src.Fetch()));                      else                          src = Kernel.Assign(type == null ? setting.NewMuAnyScalar() : Kernel.NewTypedScalar(type)' src);                  } else {                      bool islist = ((flags & (Parameter.IS_HASH | Parameter.IS_LIST)) != 0);                      bool rw     = ((flags & Parameter.READWRITE) != 0) && !islist;                      P6any srco  = src.Fetch();                        // XXX: in order for calling methods on Nil to work'                      // self needs to be ignored here.                      if (srco == setting.NilP && obj_src != -1 &&                              (flags & Parameter.INVOCANT) == 0) {                          obj_src = -1;                          goto get_default;                      }                      if ((flags & Parameter.IS_LIST) != 0)                          type = setting.PositionalMO;                      if ((flags & Parameter.IS_HASH) != 0)                          type = setting.AssociativeMO;                      if ((flags & Parameter.CALLABLE) != 0)                          type = setting.CallableMO;                      if (!srco.Does(type)) {                          if (quiet) return false;                          if (srco.mo.HasType(setting.JunctionMO) && obj_src != -1 && (mode & NO_JUNCTION) == 0) {                              int jrank = Kernel.UnboxAny<int>((P6any) ((P6opaque)srco).slots[0]) / 2;                              if (jrank < jun_rank) {                                  jun_rank = jrank;                                  jun_pivot = obj_src;                                  jun_pivot_n = obj_src_n;                              }                              continue;                          }                          throw new NieczaException("Nominal type check failed in binding '" + param.name + "' in '" + signame + "'; got " + srco.mo.name + "' needed " + type.name);                      }                        if (rw) {                          if (src.Rw) {                              // this will be a functional RW binding                              src.Vivify();                              goto bound;                          } else {                              if (quiet) return false;                              throw new NieczaException("Binding '" + param.name + "' in '" + signame + "'' cannot bind read-only value to is rw parameter");                          }                      }                      else {                          if (src.Mode == (islist ? Variable.LIST : Variable.RO))                              goto bound;                          src = islist ? (Variable)new ListVariable(srco) : srco;                      }  bound: ;                  }                  if (param.attribute != null) {                      object self;                      if (!th.TryGetDynamic("self"' 0' out self))                          throw new NieczaException("No 'self' available for attributive?");                      Variable selfv = (Variable)self;                      if (param.attribute[1] == '!') {                          Kernel.Assign(((Variable)(selfv.Fetch().                              GetSlot(param.attribute_type' param.attribute)))'                                  src);                      } else {                          Variable dest = Builtins.InvokeMethod(                                  param.attribute.Substring(2)' selfv);                          Kernel.Assign(dest' src);                      }                  }                  if ((flags & Parameter.INVOCANT) != 0 && th.info.self_key >= 0)                      th.SetDynamic(th.info.self_key' src);                  switch (slot + 1) {                      case 0: break;                      case 1:  th.lex0 = src; break;                      case 2:  th.lex1 = src; break;                      case 3:  th.lex2 = src; break;                      case 4:  th.lex3 = src; break;                      case 5:  th.lex4 = src; break;                      case 6:  th.lex5 = src; break;                      case 7:  th.lex6 = src; break;                      case 8:  th.lex7 = src; break;                      case 9:  th.lex8 = src; break;                      case 10: th.lex9 = src; break;                      default: th.lexn[slot - 10] = src; break;                  }                  // Really' this should be earlier (next to the :D/:U checks);                  // it's not right to be binding variables before doing                  // constraint checks.  We're compromising a bit of purity here                  // for the sake of making 'Int $odd where { $odd % 2 }' DWIM.                  if (param.post_constraints != null) {                      foreach (object c in param.post_constraints)                          if (!RunConstraint(th' signame' param' quiet' src' c))                              return false;                  }              }
Magic Number,Niecza,Frame,C:\repos\sorear_niecza\lib\Kernel.cs,BindSignature,The following statement contains a magic number: while (pix != pend) {                  Parameter param = pbuf[pix++];                  int flags = param.flags;                  int slot = param.slot;                  string[] names = param.names;                  STable type = param.type;                  obj_src = -1;                    Variable src = null;                  if ((flags & Parameter.SLURPY_PCL) != 0) {                      src = (slot >= 0) ? Kernel.BoxAnyMO(pos' setting.ParcelMO) :                          setting.AnyP;                      posc  = pos.Length;                      goto gotit;                  }                  if ((flags & Parameter.SLURPY_CAP) != 0) {                      if (slot < 0) {                          src = setting.AnyP;                          named = null; namedc = null; posc = pos.Length;                          goto gotit;                      }                      P6any nw = new P6opaque(setting.CaptureMO);                      Variable[] spos = new Variable[pos.Length - posc];                      Array.Copy(pos' posc' spos' 0' spos.Length);                      VarHash snamed = null;                      if (named != null) {                          snamed = new VarHash();                          foreach (string k in named.Keys) {                              if (namedc.Contains(k))                                  snamed[k] = named[k];                          }                      }                      nw.SetSlot(setting.CaptureMO' "$!positionals"' spos);                      nw.SetSlot(setting.CaptureMO' "$!named"' snamed);                      src = nw;                      named = null; namedc = null; posc = pos.Length;                      goto gotit;                  }                  if ((flags & Parameter.SLURPY_POS) != 0) {                      P6any l = new P6opaque(setting.ListMO);                      Kernel.IterToList(l' Kernel.IterFlatten(                                  Kernel.SlurpyHelper(pos' posc)));                      src = Kernel.NewRWListVar(l);                      posc = pos.Length;                      goto gotit;                  }                  if ((flags & Parameter.SLURPY_NAM) != 0) {                      VarHash nh = new VarHash();                      if (named != null) {                          foreach (KeyValuePair<string'Variable> kv in named)                              if (namedc.Contains(kv.Key))                                  nh[kv.Key] = kv.Value;                          named = null;                          namedc = null;                      }                      src = Kernel.BoxAnyMO(nh' setting.HashMO);                      goto gotit;                  }                  if (names != null && named != null) {                      for (int ni = 0; ni < names.Length; ni++) {                          string n = names[ni];                          if (namedc.Contains(n)) {                              namedc.Remove(n);                              src = named[n];                              obj_src_n = n;                              obj_src = -2;                              goto gotit;                          }                      }                  }                  if ((flags & Parameter.POSITIONAL) != 0 && posc != pos.Length) {                      obj_src = posc;                      src = pos[posc++];                      goto gotit;                  }  get_default:                  if ((flags & Parameter.HASDEFAULT) != 0) {                      if (param.def is Variable) {                          src = (Variable)param.def;                      } else {                          Frame thn = Kernel.GetInferiorRoot(setting)                              .MakeChild(th' (SubInfo)param.def' setting.AnyP);                          src = Kernel.RunInferior(thn);                          if (src == null)                              throw new Exception("Improper null return from sub default for '" + param.name + "' in '" + signame + "'");                      }                      goto gotit;                  }                  if ((flags & Parameter.DEFOUTER) != 0) {                      Frame f = th;                      if (th.info.outer_topic_key < 0) {                          src = setting.AnyP;                          goto gotit;                      }                      for (int i = 0; i < th.info.outer_topic_rank; i++) f = f.outer;                      src = (Variable)f.GetDynamic(th.info.outer_topic_key);                      goto gotit;                  }                  if ((flags & Parameter.OPTIONAL) != 0) {                      // Array is the "default" Positional -masak                      if ((flags & Parameter.IS_LIST) != 0)                          src = setting.CreateArray();                      else if ((flags & Parameter.IS_HASH) != 0)                          src = setting.CreateHash();                      else                          src = type.initObj;                      goto gotit;                  }                  if (quiet) return false;                  throw new NieczaException("No value for parameter '" + param.name + "' in '" + signame + "'");  gotit:                  switch ((flags & Parameter.DEF_MASK) >> Parameter.DEF_SHIFT) {                      // TODO: Failure will make these cases different                      case Parameter.TYPE_ONLY >> Parameter.DEF_SHIFT:                      case Parameter.UNDEF_ONLY >> Parameter.DEF_SHIFT:                          if (!src.Fetch().IsDefined())                              break;                          if (quiet) return false;                          throw new NieczaException("Parameter '" + param.name + "' in '" + signame + "' requires an undefined argument");                      case Parameter.DEF_ONLY >> Parameter.DEF_SHIFT:                          if (src.Fetch().IsDefined())                              break;                          if (quiet) return false;                          throw new NieczaException("Parameter '" + param.name + "' in '" + signame + "' requires a defined argument");                      default:                          break;                  }                  if ((flags & Parameter.RWTRANS) != 0) {                  } else if ((flags & Parameter.IS_COPY) != 0) {                      if ((flags & Parameter.IS_HASH) != 0)                          src = Kernel.Assign(setting.CreateHash()'                              Kernel.NewRWListVar(src.Fetch()));                      else if ((flags & Parameter.IS_LIST) != 0)                          src = Kernel.Assign(setting.CreateArray()'                              Kernel.NewRWListVar(src.Fetch()));                      else                          src = Kernel.Assign(type == null ? setting.NewMuAnyScalar() : Kernel.NewTypedScalar(type)' src);                  } else {                      bool islist = ((flags & (Parameter.IS_HASH | Parameter.IS_LIST)) != 0);                      bool rw     = ((flags & Parameter.READWRITE) != 0) && !islist;                      P6any srco  = src.Fetch();                        // XXX: in order for calling methods on Nil to work'                      // self needs to be ignored here.                      if (srco == setting.NilP && obj_src != -1 &&                              (flags & Parameter.INVOCANT) == 0) {                          obj_src = -1;                          goto get_default;                      }                      if ((flags & Parameter.IS_LIST) != 0)                          type = setting.PositionalMO;                      if ((flags & Parameter.IS_HASH) != 0)                          type = setting.AssociativeMO;                      if ((flags & Parameter.CALLABLE) != 0)                          type = setting.CallableMO;                      if (!srco.Does(type)) {                          if (quiet) return false;                          if (srco.mo.HasType(setting.JunctionMO) && obj_src != -1 && (mode & NO_JUNCTION) == 0) {                              int jrank = Kernel.UnboxAny<int>((P6any) ((P6opaque)srco).slots[0]) / 2;                              if (jrank < jun_rank) {                                  jun_rank = jrank;                                  jun_pivot = obj_src;                                  jun_pivot_n = obj_src_n;                              }                              continue;                          }                          throw new NieczaException("Nominal type check failed in binding '" + param.name + "' in '" + signame + "'; got " + srco.mo.name + "' needed " + type.name);                      }                        if (rw) {                          if (src.Rw) {                              // this will be a functional RW binding                              src.Vivify();                              goto bound;                          } else {                              if (quiet) return false;                              throw new NieczaException("Binding '" + param.name + "' in '" + signame + "'' cannot bind read-only value to is rw parameter");                          }                      }                      else {                          if (src.Mode == (islist ? Variable.LIST : Variable.RO))                              goto bound;                          src = islist ? (Variable)new ListVariable(srco) : srco;                      }  bound: ;                  }                  if (param.attribute != null) {                      object self;                      if (!th.TryGetDynamic("self"' 0' out self))                          throw new NieczaException("No 'self' available for attributive?");                      Variable selfv = (Variable)self;                      if (param.attribute[1] == '!') {                          Kernel.Assign(((Variable)(selfv.Fetch().                              GetSlot(param.attribute_type' param.attribute)))'                                  src);                      } else {                          Variable dest = Builtins.InvokeMethod(                                  param.attribute.Substring(2)' selfv);                          Kernel.Assign(dest' src);                      }                  }                  if ((flags & Parameter.INVOCANT) != 0 && th.info.self_key >= 0)                      th.SetDynamic(th.info.self_key' src);                  switch (slot + 1) {                      case 0: break;                      case 1:  th.lex0 = src; break;                      case 2:  th.lex1 = src; break;                      case 3:  th.lex2 = src; break;                      case 4:  th.lex3 = src; break;                      case 5:  th.lex4 = src; break;                      case 6:  th.lex5 = src; break;                      case 7:  th.lex6 = src; break;                      case 8:  th.lex7 = src; break;                      case 9:  th.lex8 = src; break;                      case 10: th.lex9 = src; break;                      default: th.lexn[slot - 10] = src; break;                  }                  // Really' this should be earlier (next to the :D/:U checks);                  // it's not right to be binding variables before doing                  // constraint checks.  We're compromising a bit of purity here                  // for the sake of making 'Int $odd where { $odd % 2 }' DWIM.                  if (param.post_constraints != null) {                      foreach (object c in param.post_constraints)                          if (!RunConstraint(th' signame' param' quiet' src' c))                              return false;                  }              }
Magic Number,Niecza,Frame,C:\repos\sorear_niecza\lib\Kernel.cs,BindSignature,The following statement contains a magic number: while (pix != pend) {                  Parameter param = pbuf[pix++];                  int flags = param.flags;                  int slot = param.slot;                  string[] names = param.names;                  STable type = param.type;                  obj_src = -1;                    Variable src = null;                  if ((flags & Parameter.SLURPY_PCL) != 0) {                      src = (slot >= 0) ? Kernel.BoxAnyMO(pos' setting.ParcelMO) :                          setting.AnyP;                      posc  = pos.Length;                      goto gotit;                  }                  if ((flags & Parameter.SLURPY_CAP) != 0) {                      if (slot < 0) {                          src = setting.AnyP;                          named = null; namedc = null; posc = pos.Length;                          goto gotit;                      }                      P6any nw = new P6opaque(setting.CaptureMO);                      Variable[] spos = new Variable[pos.Length - posc];                      Array.Copy(pos' posc' spos' 0' spos.Length);                      VarHash snamed = null;                      if (named != null) {                          snamed = new VarHash();                          foreach (string k in named.Keys) {                              if (namedc.Contains(k))                                  snamed[k] = named[k];                          }                      }                      nw.SetSlot(setting.CaptureMO' "$!positionals"' spos);                      nw.SetSlot(setting.CaptureMO' "$!named"' snamed);                      src = nw;                      named = null; namedc = null; posc = pos.Length;                      goto gotit;                  }                  if ((flags & Parameter.SLURPY_POS) != 0) {                      P6any l = new P6opaque(setting.ListMO);                      Kernel.IterToList(l' Kernel.IterFlatten(                                  Kernel.SlurpyHelper(pos' posc)));                      src = Kernel.NewRWListVar(l);                      posc = pos.Length;                      goto gotit;                  }                  if ((flags & Parameter.SLURPY_NAM) != 0) {                      VarHash nh = new VarHash();                      if (named != null) {                          foreach (KeyValuePair<string'Variable> kv in named)                              if (namedc.Contains(kv.Key))                                  nh[kv.Key] = kv.Value;                          named = null;                          namedc = null;                      }                      src = Kernel.BoxAnyMO(nh' setting.HashMO);                      goto gotit;                  }                  if (names != null && named != null) {                      for (int ni = 0; ni < names.Length; ni++) {                          string n = names[ni];                          if (namedc.Contains(n)) {                              namedc.Remove(n);                              src = named[n];                              obj_src_n = n;                              obj_src = -2;                              goto gotit;                          }                      }                  }                  if ((flags & Parameter.POSITIONAL) != 0 && posc != pos.Length) {                      obj_src = posc;                      src = pos[posc++];                      goto gotit;                  }  get_default:                  if ((flags & Parameter.HASDEFAULT) != 0) {                      if (param.def is Variable) {                          src = (Variable)param.def;                      } else {                          Frame thn = Kernel.GetInferiorRoot(setting)                              .MakeChild(th' (SubInfo)param.def' setting.AnyP);                          src = Kernel.RunInferior(thn);                          if (src == null)                              throw new Exception("Improper null return from sub default for '" + param.name + "' in '" + signame + "'");                      }                      goto gotit;                  }                  if ((flags & Parameter.DEFOUTER) != 0) {                      Frame f = th;                      if (th.info.outer_topic_key < 0) {                          src = setting.AnyP;                          goto gotit;                      }                      for (int i = 0; i < th.info.outer_topic_rank; i++) f = f.outer;                      src = (Variable)f.GetDynamic(th.info.outer_topic_key);                      goto gotit;                  }                  if ((flags & Parameter.OPTIONAL) != 0) {                      // Array is the "default" Positional -masak                      if ((flags & Parameter.IS_LIST) != 0)                          src = setting.CreateArray();                      else if ((flags & Parameter.IS_HASH) != 0)                          src = setting.CreateHash();                      else                          src = type.initObj;                      goto gotit;                  }                  if (quiet) return false;                  throw new NieczaException("No value for parameter '" + param.name + "' in '" + signame + "'");  gotit:                  switch ((flags & Parameter.DEF_MASK) >> Parameter.DEF_SHIFT) {                      // TODO: Failure will make these cases different                      case Parameter.TYPE_ONLY >> Parameter.DEF_SHIFT:                      case Parameter.UNDEF_ONLY >> Parameter.DEF_SHIFT:                          if (!src.Fetch().IsDefined())                              break;                          if (quiet) return false;                          throw new NieczaException("Parameter '" + param.name + "' in '" + signame + "' requires an undefined argument");                      case Parameter.DEF_ONLY >> Parameter.DEF_SHIFT:                          if (src.Fetch().IsDefined())                              break;                          if (quiet) return false;                          throw new NieczaException("Parameter '" + param.name + "' in '" + signame + "' requires a defined argument");                      default:                          break;                  }                  if ((flags & Parameter.RWTRANS) != 0) {                  } else if ((flags & Parameter.IS_COPY) != 0) {                      if ((flags & Parameter.IS_HASH) != 0)                          src = Kernel.Assign(setting.CreateHash()'                              Kernel.NewRWListVar(src.Fetch()));                      else if ((flags & Parameter.IS_LIST) != 0)                          src = Kernel.Assign(setting.CreateArray()'                              Kernel.NewRWListVar(src.Fetch()));                      else                          src = Kernel.Assign(type == null ? setting.NewMuAnyScalar() : Kernel.NewTypedScalar(type)' src);                  } else {                      bool islist = ((flags & (Parameter.IS_HASH | Parameter.IS_LIST)) != 0);                      bool rw     = ((flags & Parameter.READWRITE) != 0) && !islist;                      P6any srco  = src.Fetch();                        // XXX: in order for calling methods on Nil to work'                      // self needs to be ignored here.                      if (srco == setting.NilP && obj_src != -1 &&                              (flags & Parameter.INVOCANT) == 0) {                          obj_src = -1;                          goto get_default;                      }                      if ((flags & Parameter.IS_LIST) != 0)                          type = setting.PositionalMO;                      if ((flags & Parameter.IS_HASH) != 0)                          type = setting.AssociativeMO;                      if ((flags & Parameter.CALLABLE) != 0)                          type = setting.CallableMO;                      if (!srco.Does(type)) {                          if (quiet) return false;                          if (srco.mo.HasType(setting.JunctionMO) && obj_src != -1 && (mode & NO_JUNCTION) == 0) {                              int jrank = Kernel.UnboxAny<int>((P6any) ((P6opaque)srco).slots[0]) / 2;                              if (jrank < jun_rank) {                                  jun_rank = jrank;                                  jun_pivot = obj_src;                                  jun_pivot_n = obj_src_n;                              }                              continue;                          }                          throw new NieczaException("Nominal type check failed in binding '" + param.name + "' in '" + signame + "'; got " + srco.mo.name + "' needed " + type.name);                      }                        if (rw) {                          if (src.Rw) {                              // this will be a functional RW binding                              src.Vivify();                              goto bound;                          } else {                              if (quiet) return false;                              throw new NieczaException("Binding '" + param.name + "' in '" + signame + "'' cannot bind read-only value to is rw parameter");                          }                      }                      else {                          if (src.Mode == (islist ? Variable.LIST : Variable.RO))                              goto bound;                          src = islist ? (Variable)new ListVariable(srco) : srco;                      }  bound: ;                  }                  if (param.attribute != null) {                      object self;                      if (!th.TryGetDynamic("self"' 0' out self))                          throw new NieczaException("No 'self' available for attributive?");                      Variable selfv = (Variable)self;                      if (param.attribute[1] == '!') {                          Kernel.Assign(((Variable)(selfv.Fetch().                              GetSlot(param.attribute_type' param.attribute)))'                                  src);                      } else {                          Variable dest = Builtins.InvokeMethod(                                  param.attribute.Substring(2)' selfv);                          Kernel.Assign(dest' src);                      }                  }                  if ((flags & Parameter.INVOCANT) != 0 && th.info.self_key >= 0)                      th.SetDynamic(th.info.self_key' src);                  switch (slot + 1) {                      case 0: break;                      case 1:  th.lex0 = src; break;                      case 2:  th.lex1 = src; break;                      case 3:  th.lex2 = src; break;                      case 4:  th.lex3 = src; break;                      case 5:  th.lex4 = src; break;                      case 6:  th.lex5 = src; break;                      case 7:  th.lex6 = src; break;                      case 8:  th.lex7 = src; break;                      case 9:  th.lex8 = src; break;                      case 10: th.lex9 = src; break;                      default: th.lexn[slot - 10] = src; break;                  }                  // Really' this should be earlier (next to the :D/:U checks);                  // it's not right to be binding variables before doing                  // constraint checks.  We're compromising a bit of purity here                  // for the sake of making 'Int $odd where { $odd % 2 }' DWIM.                  if (param.post_constraints != null) {                      foreach (object c in param.post_constraints)                          if (!RunConstraint(th' signame' param' quiet' src' c))                              return false;                  }              }
Magic Number,Niecza,Frame,C:\repos\sorear_niecza\lib\Kernel.cs,DepthMark,The following statement contains a magic number: while (spacey.Count <= ix) { spacey.Add(new String(' '' spacey.Count * 2)); }
Magic Number,Niecza,CtxHashIterator,C:\repos\sorear_niecza\lib\Kernel.cs,Get,The following statement contains a magic number: return Builtins.HashIterRaw(3' obj);
Magic Number,Niecza,CtxStrSuccish,C:\repos\sorear_niecza\lib\Kernel.cs,TableGet,The following statement contains a magic number: int ah = table.Length / 4;
Magic Number,Niecza,CtxStrSuccish,C:\repos\sorear_niecza\lib\Kernel.cs,TableGet,The following statement contains a magic number: while (true) {                  if (al >= ah) {                      prev = next = it;                      return;                  }                  int am = (al + ah) / 2;                  if (it < (char)table[am*4]) {                      ah = am;                  } else if (it <= (char)table[am*4+1]) {                      prev = (it == (char)table[am*4]) ? (char)table[am*4+2] : (char)(it-1);                      next = (it == (char)table[am*4+1]) ? (char)table[am*4+3] : (char)(it+1);                      return;                  } else {                      al = am+1;                  }              }
Magic Number,Niecza,CtxStrSuccish,C:\repos\sorear_niecza\lib\Kernel.cs,TableGet,The following statement contains a magic number: while (true) {                  if (al >= ah) {                      prev = next = it;                      return;                  }                  int am = (al + ah) / 2;                  if (it < (char)table[am*4]) {                      ah = am;                  } else if (it <= (char)table[am*4+1]) {                      prev = (it == (char)table[am*4]) ? (char)table[am*4+2] : (char)(it-1);                      next = (it == (char)table[am*4+1]) ? (char)table[am*4+3] : (char)(it+1);                      return;                  } else {                      al = am+1;                  }              }
Magic Number,Niecza,CtxStrSuccish,C:\repos\sorear_niecza\lib\Kernel.cs,TableGet,The following statement contains a magic number: while (true) {                  if (al >= ah) {                      prev = next = it;                      return;                  }                  int am = (al + ah) / 2;                  if (it < (char)table[am*4]) {                      ah = am;                  } else if (it <= (char)table[am*4+1]) {                      prev = (it == (char)table[am*4]) ? (char)table[am*4+2] : (char)(it-1);                      next = (it == (char)table[am*4+1]) ? (char)table[am*4+3] : (char)(it+1);                      return;                  } else {                      al = am+1;                  }              }
Magic Number,Niecza,CtxStrSuccish,C:\repos\sorear_niecza\lib\Kernel.cs,TableGet,The following statement contains a magic number: while (true) {                  if (al >= ah) {                      prev = next = it;                      return;                  }                  int am = (al + ah) / 2;                  if (it < (char)table[am*4]) {                      ah = am;                  } else if (it <= (char)table[am*4+1]) {                      prev = (it == (char)table[am*4]) ? (char)table[am*4+2] : (char)(it-1);                      next = (it == (char)table[am*4+1]) ? (char)table[am*4+3] : (char)(it+1);                      return;                  } else {                      al = am+1;                  }              }
Magic Number,Niecza,CtxStrSuccish,C:\repos\sorear_niecza\lib\Kernel.cs,TableGet,The following statement contains a magic number: while (true) {                  if (al >= ah) {                      prev = next = it;                      return;                  }                  int am = (al + ah) / 2;                  if (it < (char)table[am*4]) {                      ah = am;                  } else if (it <= (char)table[am*4+1]) {                      prev = (it == (char)table[am*4]) ? (char)table[am*4+2] : (char)(it-1);                      next = (it == (char)table[am*4+1]) ? (char)table[am*4+3] : (char)(it+1);                      return;                  } else {                      al = am+1;                  }              }
Magic Number,Niecza,CtxStrSuccish,C:\repos\sorear_niecza\lib\Kernel.cs,TableGet,The following statement contains a magic number: while (true) {                  if (al >= ah) {                      prev = next = it;                      return;                  }                  int am = (al + ah) / 2;                  if (it < (char)table[am*4]) {                      ah = am;                  } else if (it <= (char)table[am*4+1]) {                      prev = (it == (char)table[am*4]) ? (char)table[am*4+2] : (char)(it-1);                      next = (it == (char)table[am*4+1]) ? (char)table[am*4+3] : (char)(it+1);                      return;                  } else {                      al = am+1;                  }              }
Magic Number,Niecza,CtxStrSuccish,C:\repos\sorear_niecza\lib\Kernel.cs,TableGet,The following statement contains a magic number: while (true) {                  if (al >= ah) {                      prev = next = it;                      return;                  }                  int am = (al + ah) / 2;                  if (it < (char)table[am*4]) {                      ah = am;                  } else if (it <= (char)table[am*4+1]) {                      prev = (it == (char)table[am*4]) ? (char)table[am*4+2] : (char)(it-1);                      next = (it == (char)table[am*4+1]) ? (char)table[am*4+3] : (char)(it+1);                      return;                  } else {                      al = am+1;                  }              }
Magic Number,Niecza,CtxStrSuccish,C:\repos\sorear_niecza\lib\Kernel.cs,TableGet,The following statement contains a magic number: while (true) {                  if (al >= ah) {                      prev = next = it;                      return;                  }                  int am = (al + ah) / 2;                  if (it < (char)table[am*4]) {                      ah = am;                  } else if (it <= (char)table[am*4+1]) {                      prev = (it == (char)table[am*4]) ? (char)table[am*4+2] : (char)(it-1);                      next = (it == (char)table[am*4+1]) ? (char)table[am*4+3] : (char)(it+1);                      return;                  } else {                      al = am+1;                  }              }
Magic Number,Niecza,CtxStrSuccish,C:\repos\sorear_niecza\lib\Kernel.cs,TableGet,The following statement contains a magic number: while (true) {                  if (al >= ah) {                      prev = next = it;                      return;                  }                  int am = (al + ah) / 2;                  if (it < (char)table[am*4]) {                      ah = am;                  } else if (it <= (char)table[am*4+1]) {                      prev = (it == (char)table[am*4]) ? (char)table[am*4+2] : (char)(it-1);                      next = (it == (char)table[am*4+1]) ? (char)table[am*4+3] : (char)(it+1);                      return;                  } else {                      al = am+1;                  }              }
Magic Number,Niecza,CtxJunctionBool,C:\repos\sorear_niecza\lib\Kernel.cs,Get,The following statement contains a magic number: if (jtype == 4) return true;
Magic Number,Niecza,CtxJunctionBool,C:\repos\sorear_niecza\lib\Kernel.cs,Get,The following statement contains a magic number: switch(jtype) {                  case 0: //all                      if (ix == eigen.Length) return true;                      v = eigen[ix++];                      if (!v.Fetch().mo.mro_raw_Bool.Get(v)) return false;                      goto case 0;                  case 1: //none                      if (ix == eigen.Length) return true;                      v = eigen[ix++];                      if (v.Fetch().mo.mro_raw_Bool.Get(v)) return false;                      goto case 1;                  case 2: //one' searching for first                      if (ix == eigen.Length) return false;                      v = eigen[ix++];                      if (v.Fetch().mo.mro_raw_Bool.Get(v)) goto case 1;                      goto case 2;                  case 3: //any                      if (ix == eigen.Length) return false;                      v = eigen[ix++];                      if (v.Fetch().mo.mro_raw_Bool.Get(v)) return true;                      goto case 3;                  default: throw new ArgumentException();              }
Magic Number,Niecza,CtxJunctionBool,C:\repos\sorear_niecza\lib\Kernel.cs,Get,The following statement contains a magic number: switch(jtype) {                  case 0: //all                      if (ix == eigen.Length) return true;                      v = eigen[ix++];                      if (!v.Fetch().mo.mro_raw_Bool.Get(v)) return false;                      goto case 0;                  case 1: //none                      if (ix == eigen.Length) return true;                      v = eigen[ix++];                      if (v.Fetch().mo.mro_raw_Bool.Get(v)) return false;                      goto case 1;                  case 2: //one' searching for first                      if (ix == eigen.Length) return false;                      v = eigen[ix++];                      if (v.Fetch().mo.mro_raw_Bool.Get(v)) goto case 1;                      goto case 2;                  case 3: //any                      if (ix == eigen.Length) return false;                      v = eigen[ix++];                      if (v.Fetch().mo.mro_raw_Bool.Get(v)) return true;                      goto case 3;                  default: throw new ArgumentException();              }
Magic Number,Niecza,CtxJunctionBool,C:\repos\sorear_niecza\lib\Kernel.cs,Get,The following statement contains a magic number: switch(jtype) {                  case 0: //all                      if (ix == eigen.Length) return true;                      v = eigen[ix++];                      if (!v.Fetch().mo.mro_raw_Bool.Get(v)) return false;                      goto case 0;                  case 1: //none                      if (ix == eigen.Length) return true;                      v = eigen[ix++];                      if (v.Fetch().mo.mro_raw_Bool.Get(v)) return false;                      goto case 1;                  case 2: //one' searching for first                      if (ix == eigen.Length) return false;                      v = eigen[ix++];                      if (v.Fetch().mo.mro_raw_Bool.Get(v)) goto case 1;                      goto case 2;                  case 3: //any                      if (ix == eigen.Length) return false;                      v = eigen[ix++];                      if (v.Fetch().mo.mro_raw_Bool.Get(v)) return true;                      goto case 3;                  default: throw new ArgumentException();              }
Magic Number,Niecza,CtxJunctionBool,C:\repos\sorear_niecza\lib\Kernel.cs,Get,The following statement contains a magic number: switch(jtype) {                  case 0: //all                      if (ix == eigen.Length) return true;                      v = eigen[ix++];                      if (!v.Fetch().mo.mro_raw_Bool.Get(v)) return false;                      goto case 0;                  case 1: //none                      if (ix == eigen.Length) return true;                      v = eigen[ix++];                      if (v.Fetch().mo.mro_raw_Bool.Get(v)) return false;                      goto case 1;                  case 2: //one' searching for first                      if (ix == eigen.Length) return false;                      v = eigen[ix++];                      if (v.Fetch().mo.mro_raw_Bool.Get(v)) goto case 1;                      goto case 2;                  case 3: //any                      if (ix == eigen.Length) return false;                      v = eigen[ix++];                      if (v.Fetch().mo.mro_raw_Bool.Get(v)) return true;                      goto case 3;                  default: throw new ArgumentException();              }
Magic Number,Niecza,CtxNumRangeReify,C:\repos\sorear_niecza\lib\Kernel.cs,Get,The following statement contains a magic number: const int unroll = 10;
Magic Number,Niecza,CtxNumRangeReify,C:\repos\sorear_niecza\lib\Kernel.cs,Get,The following statement contains a magic number: if (!terminate) {                  P6opaque newobj = new P6opaque(nrmo);                  newobj.slots[0] = cur;                  newobj.slots[1] = end;                  newobj.slots[2] = excl;                  buffer[wp++] = newobj;              }
Magic Number,Niecza,StashCursor,C:\repos\sorear_niecza\lib\Kernel.cs,TryLexOut,The following statement contains a magic number: if (key.Length >= 2 && key[1] == '*') {                  return TryDynamic(key' rbar_w' ref o);              }
Magic Number,Niecza,StashCursor,C:\repos\sorear_niecza\lib\Kernel.cs,TryDynamic,The following statement contains a magic number: if (key.Length >= 2 && key[1] == '*') {                  key = key.Remove(1'1);                  StashEnt bv;                    if (setting.currentGlobals.TryGetValue("\x8::GLOBAL" + key' out bv) ||                          setting.currentGlobals.TryGetValue("\x9::PROCESS" + key' out bv)) {                      if (rbar_w) { bv.Bind(o); } else { o = bv.v; }                      return true;                  }              }
Magic Number,Niecza,StashCursor,C:\repos\sorear_niecza\lib\Kernel.cs,Indirect,The following statement contains a magic number: while (true) {                  int ix2 = key.IndexOf("::"' ix1);                  if (ix2 < 0) {                      key = key.Substring(ix1);                      break;                  }                  string elt = key.Substring(ix1' ix2 - ix1);                  while (elt.Length > 0 && "$&@%?=.!*~".IndexOf(elt[0]) >= 0) {                      sigil = sigil + elt.Substring(0'1);                      elt = elt.Substring(1);                  }                  ix1 = ix2+2;                    if (elt != "") {                      sc.Core(elt' false' out r' out v' null);                      last = elt;                      sc = r;                  }              }
Magic Number,Niecza,Compartment,C:\repos\sorear_niecza\lib\Kernel.cs,CreateArray,The following statement contains a magic number: P6any v = new P6opaque(ArrayMO' 2);
Magic Number,Niecza,Compartment,C:\repos\sorear_niecza\lib\Kernel.cs,MakeJunction,The following statement contains a magic number: if (type >= 8) {                  type -= 8;                  foreach (Variable e in elems)                      if (e.List) goto need_flatten;                  goto flat_enough;      need_flatten:;                  VarDeque iter = new VarDeque(elems);                  VarDeque into = new VarDeque();                  while (Kernel.IterHasFlat(iter' true))                      into.Push(iter.Shift());                  elems = into.CopyAsArray();      flat_enough:;              }
Magic Number,Niecza,Compartment,C:\repos\sorear_niecza\lib\Kernel.cs,MakeJunction,The following statement contains a magic number: if (type >= 8) {                  type -= 8;                  foreach (Variable e in elems)                      if (e.List) goto need_flatten;                  goto flat_enough;      need_flatten:;                  VarDeque iter = new VarDeque(elems);                  VarDeque into = new VarDeque();                  while (Kernel.IterHasFlat(iter' true))                      into.Push(iter.Shift());                  elems = into.CopyAsArray();      flat_enough:;              }
Magic Number,Niecza,Kernel,C:\repos\sorear_niecza\lib\Kernel.cs,JunctionFallbackC,The following statement contains a magic number: if (th.ip == 0) {                  if (!th.pos[0].Fetch().IsDefined())                      return Kernel.Die(th' "Cannot autothread an undefined junction");                  P6opaque jo = (P6opaque)th.pos[0].Fetch();                  th.lex0 = Kernel.UnboxAny<Variable[]>((P6any)jo.slots[1]);                  th.lex1 = new Variable[((Variable[])th.lex0).Length];                  th.lex2 = jo.slots[0];                  th.lex3 = th.pos[1].Fetch().mo.mro_raw_Str.Get(th.pos[1]);                  th.lex4 = new Variable[th.pos.Length - 1];                  Array.Copy(th.pos' 2' (Variable[])th.lex4' 1' th.pos.Length-2);              }
Magic Number,Niecza,Kernel,C:\repos\sorear_niecza\lib\Kernel.cs,JunctionFallbackC,The following statement contains a magic number: if (th.ip == 0) {                  if (!th.pos[0].Fetch().IsDefined())                      return Kernel.Die(th' "Cannot autothread an undefined junction");                  P6opaque jo = (P6opaque)th.pos[0].Fetch();                  th.lex0 = Kernel.UnboxAny<Variable[]>((P6any)jo.slots[1]);                  th.lex1 = new Variable[((Variable[])th.lex0).Length];                  th.lex2 = jo.slots[0];                  th.lex3 = th.pos[1].Fetch().mo.mro_raw_Str.Get(th.pos[1]);                  th.lex4 = new Variable[th.pos.Length - 1];                  Array.Copy(th.pos' 2' (Variable[])th.lex4' 1' th.pos.Length-2);              }
Magic Number,Niecza,Kernel,C:\repos\sorear_niecza\lib\Kernel.cs,InitGlobal,The following statement contains a magic number: VarHash.hash_automorphism =                  ((uint)r.Next(int.MaxValue)) * 2 + 1;
Magic Number,Niecza,Kernel,C:\repos\sorear_niecza\lib\Kernel.cs,InitCompartment,The following statement contains a magic number: c.RunCATCH_I = new SubInfo(c' "KERNEL run_CATCH"' null'                  Builtins.RunCATCH_C' null' null' new int[] {                      0' 5' SubInfo.ON_NEXT' 1' 0'                      0' 5' SubInfo.ON_REDO' 2' 0'                      0' 5' SubInfo.ON_LAST' 4' 0'                      0' 5' SubInfo.ON_DIE'  1' 0'                  }' new string[] { "" }' 0);
Magic Number,Niecza,Kernel,C:\repos\sorear_niecza\lib\Kernel.cs,InitCompartment,The following statement contains a magic number: c.RunCATCH_I = new SubInfo(c' "KERNEL run_CATCH"' null'                  Builtins.RunCATCH_C' null' null' new int[] {                      0' 5' SubInfo.ON_NEXT' 1' 0'                      0' 5' SubInfo.ON_REDO' 2' 0'                      0' 5' SubInfo.ON_LAST' 4' 0'                      0' 5' SubInfo.ON_DIE'  1' 0'                  }' new string[] { "" }' 0);
Magic Number,Niecza,Kernel,C:\repos\sorear_niecza\lib\Kernel.cs,InitCompartment,The following statement contains a magic number: c.RunCATCH_I = new SubInfo(c' "KERNEL run_CATCH"' null'                  Builtins.RunCATCH_C' null' null' new int[] {                      0' 5' SubInfo.ON_NEXT' 1' 0'                      0' 5' SubInfo.ON_REDO' 2' 0'                      0' 5' SubInfo.ON_LAST' 4' 0'                      0' 5' SubInfo.ON_DIE'  1' 0'                  }' new string[] { "" }' 0);
Magic Number,Niecza,Kernel,C:\repos\sorear_niecza\lib\Kernel.cs,InitCompartment,The following statement contains a magic number: c.RunCATCH_I = new SubInfo(c' "KERNEL run_CATCH"' null'                  Builtins.RunCATCH_C' null' null' new int[] {                      0' 5' SubInfo.ON_NEXT' 1' 0'                      0' 5' SubInfo.ON_REDO' 2' 0'                      0' 5' SubInfo.ON_LAST' 4' 0'                      0' 5' SubInfo.ON_DIE'  1' 0'                  }' new string[] { "" }' 0);
Magic Number,Niecza,Kernel,C:\repos\sorear_niecza\lib\Kernel.cs,InitCompartment,The following statement contains a magic number: c.RunCATCH_I = new SubInfo(c' "KERNEL run_CATCH"' null'                  Builtins.RunCATCH_C' null' null' new int[] {                      0' 5' SubInfo.ON_NEXT' 1' 0'                      0' 5' SubInfo.ON_REDO' 2' 0'                      0' 5' SubInfo.ON_LAST' 4' 0'                      0' 5' SubInfo.ON_DIE'  1' 0'                  }' new string[] { "" }' 0);
Magic Number,Niecza,Kernel,C:\repos\sorear_niecza\lib\Kernel.cs,InitCompartment,The following statement contains a magic number: c.RunCATCH_I = new SubInfo(c' "KERNEL run_CATCH"' null'                  Builtins.RunCATCH_C' null' null' new int[] {                      0' 5' SubInfo.ON_NEXT' 1' 0'                      0' 5' SubInfo.ON_REDO' 2' 0'                      0' 5' SubInfo.ON_LAST' 4' 0'                      0' 5' SubInfo.ON_DIE'  1' 0'                  }' new string[] { "" }' 0);
Magic Number,Niecza,Kernel,C:\repos\sorear_niecza\lib\Kernel.cs,InitCompartment,The following statement contains a magic number: c.CommonMEMap_I = new SubInfo(c' "KERNEL map"' null'                  Builtins.CommonMEMap_C' null' null' new int[] {                      2' 3' SubInfo.ON_NEXT' 0' 0'                      2' 3' SubInfo.ON_REDO' 1' 0'                      2' 3' SubInfo.ON_LAST' 3' 0'                  }' new string[] { "" }' 0);
Magic Number,Niecza,Kernel,C:\repos\sorear_niecza\lib\Kernel.cs,InitCompartment,The following statement contains a magic number: c.CommonMEMap_I = new SubInfo(c' "KERNEL map"' null'                  Builtins.CommonMEMap_C' null' null' new int[] {                      2' 3' SubInfo.ON_NEXT' 0' 0'                      2' 3' SubInfo.ON_REDO' 1' 0'                      2' 3' SubInfo.ON_LAST' 3' 0'                  }' new string[] { "" }' 0);
Magic Number,Niecza,Kernel,C:\repos\sorear_niecza\lib\Kernel.cs,InitCompartment,The following statement contains a magic number: c.CommonMEMap_I = new SubInfo(c' "KERNEL map"' null'                  Builtins.CommonMEMap_C' null' null' new int[] {                      2' 3' SubInfo.ON_NEXT' 0' 0'                      2' 3' SubInfo.ON_REDO' 1' 0'                      2' 3' SubInfo.ON_LAST' 3' 0'                  }' new string[] { "" }' 0);
Magic Number,Niecza,Kernel,C:\repos\sorear_niecza\lib\Kernel.cs,InitCompartment,The following statement contains a magic number: c.CommonMEMap_I = new SubInfo(c' "KERNEL map"' null'                  Builtins.CommonMEMap_C' null' null' new int[] {                      2' 3' SubInfo.ON_NEXT' 0' 0'                      2' 3' SubInfo.ON_REDO' 1' 0'                      2' 3' SubInfo.ON_LAST' 3' 0'                  }' new string[] { "" }' 0);
Magic Number,Niecza,Kernel,C:\repos\sorear_niecza\lib\Kernel.cs,InitCompartment,The following statement contains a magic number: c.CommonMEMap_I = new SubInfo(c' "KERNEL map"' null'                  Builtins.CommonMEMap_C' null' null' new int[] {                      2' 3' SubInfo.ON_NEXT' 0' 0'                      2' 3' SubInfo.ON_REDO' 1' 0'                      2' 3' SubInfo.ON_LAST' 3' 0'                  }' new string[] { "" }' 0);
Magic Number,Niecza,Kernel,C:\repos\sorear_niecza\lib\Kernel.cs,InitCompartment,The following statement contains a magic number: c.CommonMEMap_I = new SubInfo(c' "KERNEL map"' null'                  Builtins.CommonMEMap_C' null' null' new int[] {                      2' 3' SubInfo.ON_NEXT' 0' 0'                      2' 3' SubInfo.ON_REDO' 1' 0'                      2' 3' SubInfo.ON_LAST' 3' 0'                  }' new string[] { "" }' 0);
Magic Number,Niecza,Kernel,C:\repos\sorear_niecza\lib\Kernel.cs,InitCompartment,The following statement contains a magic number: c.CommonMEMap_I = new SubInfo(c' "KERNEL map"' null'                  Builtins.CommonMEMap_C' null' null' new int[] {                      2' 3' SubInfo.ON_NEXT' 0' 0'                      2' 3' SubInfo.ON_REDO' 1' 0'                      2' 3' SubInfo.ON_LAST' 3' 0'                  }' new string[] { "" }' 0);
Magic Number,Niecza,Kernel,C:\repos\sorear_niecza\lib\Kernel.cs,InitCompartment,The following statement contains a magic number: c.CommonGrep_I = new SubInfo(c' "KERNEL grep"' null'                  Builtins.CommonGrep_C' null' null' new int[] {                      2' 3' SubInfo.ON_NEXT' 0' 0'                      2' 3' SubInfo.ON_REDO' 1' 0'                      2' 3' SubInfo.ON_LAST' 3' 0'                  }' new string[] { "" }' 0);
Magic Number,Niecza,Kernel,C:\repos\sorear_niecza\lib\Kernel.cs,InitCompartment,The following statement contains a magic number: c.CommonGrep_I = new SubInfo(c' "KERNEL grep"' null'                  Builtins.CommonGrep_C' null' null' new int[] {                      2' 3' SubInfo.ON_NEXT' 0' 0'                      2' 3' SubInfo.ON_REDO' 1' 0'                      2' 3' SubInfo.ON_LAST' 3' 0'                  }' new string[] { "" }' 0);
Magic Number,Niecza,Kernel,C:\repos\sorear_niecza\lib\Kernel.cs,InitCompartment,The following statement contains a magic number: c.CommonGrep_I = new SubInfo(c' "KERNEL grep"' null'                  Builtins.CommonGrep_C' null' null' new int[] {                      2' 3' SubInfo.ON_NEXT' 0' 0'                      2' 3' SubInfo.ON_REDO' 1' 0'                      2' 3' SubInfo.ON_LAST' 3' 0'                  }' new string[] { "" }' 0);
Magic Number,Niecza,Kernel,C:\repos\sorear_niecza\lib\Kernel.cs,InitCompartment,The following statement contains a magic number: c.CommonGrep_I = new SubInfo(c' "KERNEL grep"' null'                  Builtins.CommonGrep_C' null' null' new int[] {                      2' 3' SubInfo.ON_NEXT' 0' 0'                      2' 3' SubInfo.ON_REDO' 1' 0'                      2' 3' SubInfo.ON_LAST' 3' 0'                  }' new string[] { "" }' 0);
Magic Number,Niecza,Kernel,C:\repos\sorear_niecza\lib\Kernel.cs,InitCompartment,The following statement contains a magic number: c.CommonGrep_I = new SubInfo(c' "KERNEL grep"' null'                  Builtins.CommonGrep_C' null' null' new int[] {                      2' 3' SubInfo.ON_NEXT' 0' 0'                      2' 3' SubInfo.ON_REDO' 1' 0'                      2' 3' SubInfo.ON_LAST' 3' 0'                  }' new string[] { "" }' 0);
Magic Number,Niecza,Kernel,C:\repos\sorear_niecza\lib\Kernel.cs,InitCompartment,The following statement contains a magic number: c.CommonGrep_I = new SubInfo(c' "KERNEL grep"' null'                  Builtins.CommonGrep_C' null' null' new int[] {                      2' 3' SubInfo.ON_NEXT' 0' 0'                      2' 3' SubInfo.ON_REDO' 1' 0'                      2' 3' SubInfo.ON_LAST' 3' 0'                  }' new string[] { "" }' 0);
Magic Number,Niecza,Kernel,C:\repos\sorear_niecza\lib\Kernel.cs,InitCompartment,The following statement contains a magic number: c.CommonGrep_I = new SubInfo(c' "KERNEL grep"' null'                  Builtins.CommonGrep_C' null' null' new int[] {                      2' 3' SubInfo.ON_NEXT' 0' 0'                      2' 3' SubInfo.ON_REDO' 1' 0'                      2' 3' SubInfo.ON_LAST' 3' 0'                  }' new string[] { "" }' 0);
Magic Number,Niecza,Kernel,C:\repos\sorear_niecza\lib\Kernel.cs,MakeSub,The following statement contains a magic number: P6opaque n = new P6opaque(info.mo ?? info.setting.CodeMO' 2);
Magic Number,Niecza,Kernel,C:\repos\sorear_niecza\lib\Kernel.cs,DefaultNew,The following statement contains a magic number: if ((prog[i].flags & P6how.A_PUBLIC) != 0 &&                      args.TryGetValue(prog[i].name.Substring(2)' out vx)) {                  args.Remove(prog[i].name.Substring(2));                  th.resultSlot = vx;              } else if (prog[i].init == null) {                  th.resultSlot = null;              } else if (prog[i].name == null) {                  P6any init = prog[i].init;                  th.lexi0 = i;                    SubInfo si = GetInfo(init);                  VarHash build_args = new VarHash();                  foreach (Parameter pa in si.sig.parms) {                      foreach (string name in pa.names ?? new string[0]) {                          if (args.ContainsKey(name)) {                              build_args[name] = args[name];                              args.Remove(name);                          }                      }                  }                    return init.Invoke(th' new Variable[] { n }' build_args);              } else {                  P6any init = prog[i].init;                  th.lexi0 = i;                  return init.Invoke(th' new [] { n }' null);              }
Magic Number,Niecza,Kernel,C:\repos\sorear_niecza\lib\Kernel.cs,DefaultNew,The following statement contains a magic number: if ((prog[i].flags & P6how.A_PUBLIC) != 0 &&                      args.TryGetValue(prog[i].name.Substring(2)' out vx)) {                  args.Remove(prog[i].name.Substring(2));                  th.resultSlot = vx;              } else if (prog[i].init == null) {                  th.resultSlot = null;              } else if (prog[i].name == null) {                  P6any init = prog[i].init;                  th.lexi0 = i;                    SubInfo si = GetInfo(init);                  VarHash build_args = new VarHash();                  foreach (Parameter pa in si.sig.parms) {                      foreach (string name in pa.names ?? new string[0]) {                          if (args.ContainsKey(name)) {                              build_args[name] = args[name];                              args.Remove(name);                          }                      }                  }                    return init.Invoke(th' new Variable[] { n }' build_args);              } else {                  P6any init = prog[i].init;                  th.lexi0 = i;                  return init.Invoke(th' new [] { n }' null);              }
Magic Number,Niecza,Kernel,C:\repos\sorear_niecza\lib\Kernel.cs,DispIndexy,The following statement contains a magic number: Variable index = pos.Length >= 2 ? pos[1] : null;
Magic Number,Niecza,Kernel,C:\repos\sorear_niecza\lib\Kernel.cs,DispIndexy,The following statement contains a magic number: if (pos.Length > 2) {                  Variable inter = ((IndexHandler)p[0]).Get(self' index);                  Variable[] npos = new Variable[pos.Length - 1];                  Array.Copy(pos' 2' npos' 1' pos.Length - 2);                  npos[0] = inter;                  return inter.Fetch().InvokeMethod(th.Return()' (string)p[4]'                          npos' n);              } else if (index == null) {                  // TODO: handle adverbs on Zen slices (XXX does this make sense?)                  res = self.List ? self : Kernel.NewRWListVar(self.Fetch());              } else if (n == null) {                  res = ((IndexHandler)p[0]).Get(self' index);              } else if (p[1] != null && n.ContainsKey("exists")) {                  res = ((IndexHandler)p[1]).Get(self' index);              } else if (p[2] != null && n.ContainsKey("delete")) {                  res = ((IndexHandler)p[2]).Get(self' index);              } else if (n.ContainsKey("k")) {                  res =  new KeySlicer(0' p[0]) { setting = th.info.setting }.Get(self' index);              } else if (n.ContainsKey("kv")) {                  res = new KeySlicer(1' p[0]) { setting = th.info.setting }.Get(self' index);              } else if (n.ContainsKey("p")) {                  res = new KeySlicer(2' p[0]) { setting = th.info.setting }.Get(self' index);              } else if (n.ContainsKey("BIND_VALUE")) {                  res = ((BindHandler)p[3]).Bind(self' index' n["BIND_VALUE"]);              } else {                  res = ((IndexHandler)p[0]).Get(self' index);              }
Magic Number,Niecza,Kernel,C:\repos\sorear_niecza\lib\Kernel.cs,DispIndexy,The following statement contains a magic number: if (pos.Length > 2) {                  Variable inter = ((IndexHandler)p[0]).Get(self' index);                  Variable[] npos = new Variable[pos.Length - 1];                  Array.Copy(pos' 2' npos' 1' pos.Length - 2);                  npos[0] = inter;                  return inter.Fetch().InvokeMethod(th.Return()' (string)p[4]'                          npos' n);              } else if (index == null) {                  // TODO: handle adverbs on Zen slices (XXX does this make sense?)                  res = self.List ? self : Kernel.NewRWListVar(self.Fetch());              } else if (n == null) {                  res = ((IndexHandler)p[0]).Get(self' index);              } else if (p[1] != null && n.ContainsKey("exists")) {                  res = ((IndexHandler)p[1]).Get(self' index);              } else if (p[2] != null && n.ContainsKey("delete")) {                  res = ((IndexHandler)p[2]).Get(self' index);              } else if (n.ContainsKey("k")) {                  res =  new KeySlicer(0' p[0]) { setting = th.info.setting }.Get(self' index);              } else if (n.ContainsKey("kv")) {                  res = new KeySlicer(1' p[0]) { setting = th.info.setting }.Get(self' index);              } else if (n.ContainsKey("p")) {                  res = new KeySlicer(2' p[0]) { setting = th.info.setting }.Get(self' index);              } else if (n.ContainsKey("BIND_VALUE")) {                  res = ((BindHandler)p[3]).Bind(self' index' n["BIND_VALUE"]);              } else {                  res = ((IndexHandler)p[0]).Get(self' index);              }
Magic Number,Niecza,Kernel,C:\repos\sorear_niecza\lib\Kernel.cs,DispIndexy,The following statement contains a magic number: if (pos.Length > 2) {                  Variable inter = ((IndexHandler)p[0]).Get(self' index);                  Variable[] npos = new Variable[pos.Length - 1];                  Array.Copy(pos' 2' npos' 1' pos.Length - 2);                  npos[0] = inter;                  return inter.Fetch().InvokeMethod(th.Return()' (string)p[4]'                          npos' n);              } else if (index == null) {                  // TODO: handle adverbs on Zen slices (XXX does this make sense?)                  res = self.List ? self : Kernel.NewRWListVar(self.Fetch());              } else if (n == null) {                  res = ((IndexHandler)p[0]).Get(self' index);              } else if (p[1] != null && n.ContainsKey("exists")) {                  res = ((IndexHandler)p[1]).Get(self' index);              } else if (p[2] != null && n.ContainsKey("delete")) {                  res = ((IndexHandler)p[2]).Get(self' index);              } else if (n.ContainsKey("k")) {                  res =  new KeySlicer(0' p[0]) { setting = th.info.setting }.Get(self' index);              } else if (n.ContainsKey("kv")) {                  res = new KeySlicer(1' p[0]) { setting = th.info.setting }.Get(self' index);              } else if (n.ContainsKey("p")) {                  res = new KeySlicer(2' p[0]) { setting = th.info.setting }.Get(self' index);              } else if (n.ContainsKey("BIND_VALUE")) {                  res = ((BindHandler)p[3]).Bind(self' index' n["BIND_VALUE"]);              } else {                  res = ((IndexHandler)p[0]).Get(self' index);              }
Magic Number,Niecza,Kernel,C:\repos\sorear_niecza\lib\Kernel.cs,DispIndexy,The following statement contains a magic number: if (pos.Length > 2) {                  Variable inter = ((IndexHandler)p[0]).Get(self' index);                  Variable[] npos = new Variable[pos.Length - 1];                  Array.Copy(pos' 2' npos' 1' pos.Length - 2);                  npos[0] = inter;                  return inter.Fetch().InvokeMethod(th.Return()' (string)p[4]'                          npos' n);              } else if (index == null) {                  // TODO: handle adverbs on Zen slices (XXX does this make sense?)                  res = self.List ? self : Kernel.NewRWListVar(self.Fetch());              } else if (n == null) {                  res = ((IndexHandler)p[0]).Get(self' index);              } else if (p[1] != null && n.ContainsKey("exists")) {                  res = ((IndexHandler)p[1]).Get(self' index);              } else if (p[2] != null && n.ContainsKey("delete")) {                  res = ((IndexHandler)p[2]).Get(self' index);              } else if (n.ContainsKey("k")) {                  res =  new KeySlicer(0' p[0]) { setting = th.info.setting }.Get(self' index);              } else if (n.ContainsKey("kv")) {                  res = new KeySlicer(1' p[0]) { setting = th.info.setting }.Get(self' index);              } else if (n.ContainsKey("p")) {                  res = new KeySlicer(2' p[0]) { setting = th.info.setting }.Get(self' index);              } else if (n.ContainsKey("BIND_VALUE")) {                  res = ((BindHandler)p[3]).Bind(self' index' n["BIND_VALUE"]);              } else {                  res = ((IndexHandler)p[0]).Get(self' index);              }
Magic Number,Niecza,Kernel,C:\repos\sorear_niecza\lib\Kernel.cs,DispIndexy,The following statement contains a magic number: if (pos.Length > 2) {                  Variable inter = ((IndexHandler)p[0]).Get(self' index);                  Variable[] npos = new Variable[pos.Length - 1];                  Array.Copy(pos' 2' npos' 1' pos.Length - 2);                  npos[0] = inter;                  return inter.Fetch().InvokeMethod(th.Return()' (string)p[4]'                          npos' n);              } else if (index == null) {                  // TODO: handle adverbs on Zen slices (XXX does this make sense?)                  res = self.List ? self : Kernel.NewRWListVar(self.Fetch());              } else if (n == null) {                  res = ((IndexHandler)p[0]).Get(self' index);              } else if (p[1] != null && n.ContainsKey("exists")) {                  res = ((IndexHandler)p[1]).Get(self' index);              } else if (p[2] != null && n.ContainsKey("delete")) {                  res = ((IndexHandler)p[2]).Get(self' index);              } else if (n.ContainsKey("k")) {                  res =  new KeySlicer(0' p[0]) { setting = th.info.setting }.Get(self' index);              } else if (n.ContainsKey("kv")) {                  res = new KeySlicer(1' p[0]) { setting = th.info.setting }.Get(self' index);              } else if (n.ContainsKey("p")) {                  res = new KeySlicer(2' p[0]) { setting = th.info.setting }.Get(self' index);              } else if (n.ContainsKey("BIND_VALUE")) {                  res = ((BindHandler)p[3]).Bind(self' index' n["BIND_VALUE"]);              } else {                  res = ((IndexHandler)p[0]).Get(self' index);              }
Magic Number,Niecza,Kernel,C:\repos\sorear_niecza\lib\Kernel.cs,DispIndexy,The following statement contains a magic number: if (pos.Length > 2) {                  Variable inter = ((IndexHandler)p[0]).Get(self' index);                  Variable[] npos = new Variable[pos.Length - 1];                  Array.Copy(pos' 2' npos' 1' pos.Length - 2);                  npos[0] = inter;                  return inter.Fetch().InvokeMethod(th.Return()' (string)p[4]'                          npos' n);              } else if (index == null) {                  // TODO: handle adverbs on Zen slices (XXX does this make sense?)                  res = self.List ? self : Kernel.NewRWListVar(self.Fetch());              } else if (n == null) {                  res = ((IndexHandler)p[0]).Get(self' index);              } else if (p[1] != null && n.ContainsKey("exists")) {                  res = ((IndexHandler)p[1]).Get(self' index);              } else if (p[2] != null && n.ContainsKey("delete")) {                  res = ((IndexHandler)p[2]).Get(self' index);              } else if (n.ContainsKey("k")) {                  res =  new KeySlicer(0' p[0]) { setting = th.info.setting }.Get(self' index);              } else if (n.ContainsKey("kv")) {                  res = new KeySlicer(1' p[0]) { setting = th.info.setting }.Get(self' index);              } else if (n.ContainsKey("p")) {                  res = new KeySlicer(2' p[0]) { setting = th.info.setting }.Get(self' index);              } else if (n.ContainsKey("BIND_VALUE")) {                  res = ((BindHandler)p[3]).Bind(self' index' n["BIND_VALUE"]);              } else {                  res = ((IndexHandler)p[0]).Get(self' index);              }
Magic Number,Niecza,Kernel,C:\repos\sorear_niecza\lib\Kernel.cs,DispIndexy,The following statement contains a magic number: if (pos.Length > 2) {                  Variable inter = ((IndexHandler)p[0]).Get(self' index);                  Variable[] npos = new Variable[pos.Length - 1];                  Array.Copy(pos' 2' npos' 1' pos.Length - 2);                  npos[0] = inter;                  return inter.Fetch().InvokeMethod(th.Return()' (string)p[4]'                          npos' n);              } else if (index == null) {                  // TODO: handle adverbs on Zen slices (XXX does this make sense?)                  res = self.List ? self : Kernel.NewRWListVar(self.Fetch());              } else if (n == null) {                  res = ((IndexHandler)p[0]).Get(self' index);              } else if (p[1] != null && n.ContainsKey("exists")) {                  res = ((IndexHandler)p[1]).Get(self' index);              } else if (p[2] != null && n.ContainsKey("delete")) {                  res = ((IndexHandler)p[2]).Get(self' index);              } else if (n.ContainsKey("k")) {                  res =  new KeySlicer(0' p[0]) { setting = th.info.setting }.Get(self' index);              } else if (n.ContainsKey("kv")) {                  res = new KeySlicer(1' p[0]) { setting = th.info.setting }.Get(self' index);              } else if (n.ContainsKey("p")) {                  res = new KeySlicer(2' p[0]) { setting = th.info.setting }.Get(self' index);              } else if (n.ContainsKey("BIND_VALUE")) {                  res = ((BindHandler)p[3]).Bind(self' index' n["BIND_VALUE"]);              } else {                  res = ((IndexHandler)p[0]).Get(self' index);              }
Magic Number,Niecza,Kernel,C:\repos\sorear_niecza\lib\Kernel.cs,DispIndexy,The following statement contains a magic number: if (pos.Length > 2) {                  Variable inter = ((IndexHandler)p[0]).Get(self' index);                  Variable[] npos = new Variable[pos.Length - 1];                  Array.Copy(pos' 2' npos' 1' pos.Length - 2);                  npos[0] = inter;                  return inter.Fetch().InvokeMethod(th.Return()' (string)p[4]'                          npos' n);              } else if (index == null) {                  // TODO: handle adverbs on Zen slices (XXX does this make sense?)                  res = self.List ? self : Kernel.NewRWListVar(self.Fetch());              } else if (n == null) {                  res = ((IndexHandler)p[0]).Get(self' index);              } else if (p[1] != null && n.ContainsKey("exists")) {                  res = ((IndexHandler)p[1]).Get(self' index);              } else if (p[2] != null && n.ContainsKey("delete")) {                  res = ((IndexHandler)p[2]).Get(self' index);              } else if (n.ContainsKey("k")) {                  res =  new KeySlicer(0' p[0]) { setting = th.info.setting }.Get(self' index);              } else if (n.ContainsKey("kv")) {                  res = new KeySlicer(1' p[0]) { setting = th.info.setting }.Get(self' index);              } else if (n.ContainsKey("p")) {                  res = new KeySlicer(2' p[0]) { setting = th.info.setting }.Get(self' index);              } else if (n.ContainsKey("BIND_VALUE")) {                  res = ((BindHandler)p[3]).Bind(self' index' n["BIND_VALUE"]);              } else {                  res = ((IndexHandler)p[0]).Get(self' index);              }
Magic Number,Niecza,Kernel,C:\repos\sorear_niecza\lib\Kernel.cs,SetTrace,The following statement contains a magic number: if (trace != null) {                  if (trace == "all") {                      TraceFlags = TRACE_CUR;                      TraceFreq = 1;                  } else if (trace == "stat") {                      TraceFlags = TRACE_ALL;                      string p = Environment.GetEnvironmentVariable("NIECZA_TRACE_PERIOD");                      if (!int.TryParse(p' out TraceFreq))                          TraceFreq = 1000000;                  } else {                      Console.Error.WriteLine("Unknown trace option {0}"' trace);                  }                  TraceCount = TraceFreq;              }
Magic Number,Niecza,Kernel,C:\repos\sorear_niecza\lib\Kernel.cs,Main,The following statement contains a magic number: if (cmd == "-field-inventory") {                  foreach (Type ty in typeof(Kernel).Assembly.GetTypes()) {                      if (ty.GetCustomAttributes(typeof(CompilerGeneratedAttribute)' true).Length != 0)                          continue;                        foreach (FieldInfo fi in ty.GetFields(BindingFlags.Static |                              BindingFlags.Public | BindingFlags.NonPublic)) {                          if (fi.GetCustomAttributes(typeof(CompilerGeneratedAttribute)' true).Length != 0)                              continue;                          // already classified                          if (fi.GetCustomAttributes(typeof(ImmutableAttribute)' true).Length != 0)                              continue;                          if (fi.GetCustomAttributes(typeof(TrueGlobalAttribute)' true).Length != 0)                              continue;                          // ignore effectively constant fields                          if (fi.IsLiteral)                              continue;                          Type ft = fi.FieldType;                          // delegates can be stateful' but niecza                          // doesn't assign stateful delegates to initonly fields                          if (fi.IsInitOnly && (ft.IsPrimitive ||                                  ft == typeof(BigInteger) ||                                  ft == typeof(Type) ||                                  ft == typeof(Assembly) ||                                  ft == typeof(FieldInfo) ||                                  ft == typeof(ConstructorInfo) ||                                  ft == typeof(MethodInfo) ||                                  typeof(Delegate).IsAssignableFrom(ft) ||                                  //ft.IsSealed && ft.GetFields(                                  //    BindingFlags.Instance |                                  //    BindingFlags.Public |                                  //    BindingFlags.NonPublic).Length == 0 ||                                  ft == typeof(string)))                              continue;                            Console.WriteLine(ty.FullName + "." + fi.Name);                      }                  }              }              else if (cmd == "-regenerate" && args.Length == 4) {                  // Code regeneration: this is required for the bootstrap                  // procedure' because initial code generation makes Run.CORE                  // and we need to turn it into CORE for the compiler proper.                    // this needs to be rethought for the new segregation model                    string fromdir = args[1];                  string todir   = args[2];                  string newname = args[3];                    // don't try to load the assemblies (we probably can't)                  comp.obj_dirs = new [] { fromdir };                  Backend.cross_level_load = true;                    RuntimeUnit root = (RuntimeUnit)                      comp.reg.LoadUnit("MAIN").root;                    // reset for writing                  comp.obj_dirs = new [] { todir };                    RewriteUnits(root' root' new HashSet<RuntimeUnit>());                    // reset for writability                  comp.reg = new ObjectRegistry(comp);                    root.dll_name = newname + ".exe";                  root.asm_name = newname;                  root.name = newname;                  root.Save();              }              else if (cmd == "-run" && args.Length == 2) {                  MainHandler(args[1]' new string[0]);              } else {                  Console.WriteLine("usage: Kernel.dll -regenerate fromdir todir App.exe");                  Console.WriteLine("usage: Kernel.dll -run Unit.Name");              }
Magic Number,Niecza,Kernel,C:\repos\sorear_niecza\lib\Kernel.cs,Main,The following statement contains a magic number: if (cmd == "-field-inventory") {                  foreach (Type ty in typeof(Kernel).Assembly.GetTypes()) {                      if (ty.GetCustomAttributes(typeof(CompilerGeneratedAttribute)' true).Length != 0)                          continue;                        foreach (FieldInfo fi in ty.GetFields(BindingFlags.Static |                              BindingFlags.Public | BindingFlags.NonPublic)) {                          if (fi.GetCustomAttributes(typeof(CompilerGeneratedAttribute)' true).Length != 0)                              continue;                          // already classified                          if (fi.GetCustomAttributes(typeof(ImmutableAttribute)' true).Length != 0)                              continue;                          if (fi.GetCustomAttributes(typeof(TrueGlobalAttribute)' true).Length != 0)                              continue;                          // ignore effectively constant fields                          if (fi.IsLiteral)                              continue;                          Type ft = fi.FieldType;                          // delegates can be stateful' but niecza                          // doesn't assign stateful delegates to initonly fields                          if (fi.IsInitOnly && (ft.IsPrimitive ||                                  ft == typeof(BigInteger) ||                                  ft == typeof(Type) ||                                  ft == typeof(Assembly) ||                                  ft == typeof(FieldInfo) ||                                  ft == typeof(ConstructorInfo) ||                                  ft == typeof(MethodInfo) ||                                  typeof(Delegate).IsAssignableFrom(ft) ||                                  //ft.IsSealed && ft.GetFields(                                  //    BindingFlags.Instance |                                  //    BindingFlags.Public |                                  //    BindingFlags.NonPublic).Length == 0 ||                                  ft == typeof(string)))                              continue;                            Console.WriteLine(ty.FullName + "." + fi.Name);                      }                  }              }              else if (cmd == "-regenerate" && args.Length == 4) {                  // Code regeneration: this is required for the bootstrap                  // procedure' because initial code generation makes Run.CORE                  // and we need to turn it into CORE for the compiler proper.                    // this needs to be rethought for the new segregation model                    string fromdir = args[1];                  string todir   = args[2];                  string newname = args[3];                    // don't try to load the assemblies (we probably can't)                  comp.obj_dirs = new [] { fromdir };                  Backend.cross_level_load = true;                    RuntimeUnit root = (RuntimeUnit)                      comp.reg.LoadUnit("MAIN").root;                    // reset for writing                  comp.obj_dirs = new [] { todir };                    RewriteUnits(root' root' new HashSet<RuntimeUnit>());                    // reset for writability                  comp.reg = new ObjectRegistry(comp);                    root.dll_name = newname + ".exe";                  root.asm_name = newname;                  root.name = newname;                  root.Save();              }              else if (cmd == "-run" && args.Length == 2) {                  MainHandler(args[1]' new string[0]);              } else {                  Console.WriteLine("usage: Kernel.dll -regenerate fromdir todir App.exe");                  Console.WriteLine("usage: Kernel.dll -run Unit.Name");              }
Magic Number,Niecza,Kernel,C:\repos\sorear_niecza\lib\Kernel.cs,Main,The following statement contains a magic number: if (cmd == "-field-inventory") {                  foreach (Type ty in typeof(Kernel).Assembly.GetTypes()) {                      if (ty.GetCustomAttributes(typeof(CompilerGeneratedAttribute)' true).Length != 0)                          continue;                        foreach (FieldInfo fi in ty.GetFields(BindingFlags.Static |                              BindingFlags.Public | BindingFlags.NonPublic)) {                          if (fi.GetCustomAttributes(typeof(CompilerGeneratedAttribute)' true).Length != 0)                              continue;                          // already classified                          if (fi.GetCustomAttributes(typeof(ImmutableAttribute)' true).Length != 0)                              continue;                          if (fi.GetCustomAttributes(typeof(TrueGlobalAttribute)' true).Length != 0)                              continue;                          // ignore effectively constant fields                          if (fi.IsLiteral)                              continue;                          Type ft = fi.FieldType;                          // delegates can be stateful' but niecza                          // doesn't assign stateful delegates to initonly fields                          if (fi.IsInitOnly && (ft.IsPrimitive ||                                  ft == typeof(BigInteger) ||                                  ft == typeof(Type) ||                                  ft == typeof(Assembly) ||                                  ft == typeof(FieldInfo) ||                                  ft == typeof(ConstructorInfo) ||                                  ft == typeof(MethodInfo) ||                                  typeof(Delegate).IsAssignableFrom(ft) ||                                  //ft.IsSealed && ft.GetFields(                                  //    BindingFlags.Instance |                                  //    BindingFlags.Public |                                  //    BindingFlags.NonPublic).Length == 0 ||                                  ft == typeof(string)))                              continue;                            Console.WriteLine(ty.FullName + "." + fi.Name);                      }                  }              }              else if (cmd == "-regenerate" && args.Length == 4) {                  // Code regeneration: this is required for the bootstrap                  // procedure' because initial code generation makes Run.CORE                  // and we need to turn it into CORE for the compiler proper.                    // this needs to be rethought for the new segregation model                    string fromdir = args[1];                  string todir   = args[2];                  string newname = args[3];                    // don't try to load the assemblies (we probably can't)                  comp.obj_dirs = new [] { fromdir };                  Backend.cross_level_load = true;                    RuntimeUnit root = (RuntimeUnit)                      comp.reg.LoadUnit("MAIN").root;                    // reset for writing                  comp.obj_dirs = new [] { todir };                    RewriteUnits(root' root' new HashSet<RuntimeUnit>());                    // reset for writability                  comp.reg = new ObjectRegistry(comp);                    root.dll_name = newname + ".exe";                  root.asm_name = newname;                  root.name = newname;                  root.Save();              }              else if (cmd == "-run" && args.Length == 2) {                  MainHandler(args[1]' new string[0]);              } else {                  Console.WriteLine("usage: Kernel.dll -regenerate fromdir todir App.exe");                  Console.WriteLine("usage: Kernel.dll -run Unit.Name");              }
Magic Number,Niecza,Kernel,C:\repos\sorear_niecza\lib\Kernel.cs,Main,The following statement contains a magic number: if (cmd == "-field-inventory") {                  foreach (Type ty in typeof(Kernel).Assembly.GetTypes()) {                      if (ty.GetCustomAttributes(typeof(CompilerGeneratedAttribute)' true).Length != 0)                          continue;                        foreach (FieldInfo fi in ty.GetFields(BindingFlags.Static |                              BindingFlags.Public | BindingFlags.NonPublic)) {                          if (fi.GetCustomAttributes(typeof(CompilerGeneratedAttribute)' true).Length != 0)                              continue;                          // already classified                          if (fi.GetCustomAttributes(typeof(ImmutableAttribute)' true).Length != 0)                              continue;                          if (fi.GetCustomAttributes(typeof(TrueGlobalAttribute)' true).Length != 0)                              continue;                          // ignore effectively constant fields                          if (fi.IsLiteral)                              continue;                          Type ft = fi.FieldType;                          // delegates can be stateful' but niecza                          // doesn't assign stateful delegates to initonly fields                          if (fi.IsInitOnly && (ft.IsPrimitive ||                                  ft == typeof(BigInteger) ||                                  ft == typeof(Type) ||                                  ft == typeof(Assembly) ||                                  ft == typeof(FieldInfo) ||                                  ft == typeof(ConstructorInfo) ||                                  ft == typeof(MethodInfo) ||                                  typeof(Delegate).IsAssignableFrom(ft) ||                                  //ft.IsSealed && ft.GetFields(                                  //    BindingFlags.Instance |                                  //    BindingFlags.Public |                                  //    BindingFlags.NonPublic).Length == 0 ||                                  ft == typeof(string)))                              continue;                            Console.WriteLine(ty.FullName + "." + fi.Name);                      }                  }              }              else if (cmd == "-regenerate" && args.Length == 4) {                  // Code regeneration: this is required for the bootstrap                  // procedure' because initial code generation makes Run.CORE                  // and we need to turn it into CORE for the compiler proper.                    // this needs to be rethought for the new segregation model                    string fromdir = args[1];                  string todir   = args[2];                  string newname = args[3];                    // don't try to load the assemblies (we probably can't)                  comp.obj_dirs = new [] { fromdir };                  Backend.cross_level_load = true;                    RuntimeUnit root = (RuntimeUnit)                      comp.reg.LoadUnit("MAIN").root;                    // reset for writing                  comp.obj_dirs = new [] { todir };                    RewriteUnits(root' root' new HashSet<RuntimeUnit>());                    // reset for writability                  comp.reg = new ObjectRegistry(comp);                    root.dll_name = newname + ".exe";                  root.asm_name = newname;                  root.name = newname;                  root.Save();              }              else if (cmd == "-run" && args.Length == 2) {                  MainHandler(args[1]' new string[0]);              } else {                  Console.WriteLine("usage: Kernel.dll -regenerate fromdir todir App.exe");                  Console.WriteLine("usage: Kernel.dll -run Unit.Name");              }
Magic Number,Niecza,MMDParameter,C:\repos\sorear_niecza\lib\Kernel.cs,IsNarrowerThan,The following statement contains a magic number: if (other == TOP) return (this == TOP) ? 0 : 2;
Magic Number,Niecza,MMDParameter,C:\repos\sorear_niecza\lib\Kernel.cs,IsNarrowerThan,The following statement contains a magic number: if (this == BOTTOM) return 2;
Magic Number,Niecza,MMDParameter,C:\repos\sorear_niecza\lib\Kernel.cs,IsNarrowerThan,The following statement contains a magic number: if (k1 && !k2) return 2;
Magic Number,Niecza,MMDParameter,C:\repos\sorear_niecza\lib\Kernel.cs,IsNarrowerThan,The following statement contains a magic number: if (constrained && !other.constrained) return 2;
Magic Number,Niecza,MMDCandidate,C:\repos\sorear_niecza\lib\Kernel.cs,IsNarrowerThan,The following statement contains a magic number: if (!slurpy_nam && other.slurpy_nam) narrower |= 2;
Magic Number,Niecza,MMDCandidate,C:\repos\sorear_niecza\lib\Kernel.cs,IsNarrowerThan,The following statement contains a magic number: if (narrower == 0 || narrower == 3) {                      // are they the same except for constraints?                      if (narrower == 0 && extra_constraints)                          return filter_n < other.filter_n;                        return group_n < other.group_n;                  }
Magic Number,Niecza,MMDCandidate,C:\repos\sorear_niecza\lib\Kernel.cs,IsNarrowerThan,The following statement contains a magic number: return (narrower == 2);
Magic Number,Niecza,CandidateSet,C:\repos\sorear_niecza\lib\NieczaCLR.cs,CheckJunctionArg,The following statement contains a magic number: int jrank = Kernel.UnboxAny<int>((P6any) ((P6opaque)obj).slots[0]) / 2;
Magic Number,Niecza,CandidateSet,C:\repos\sorear_niecza\lib\NieczaCLR.cs,CheckJunctions,The following statement contains a magic number: if (named != null) {                  foreach (KeyValuePair<string'Variable> kv in named)                      CheckJunctionArg(kv.Value' ref jun_pivot' ref jun_pivot_n'                              ref jun_rank' -2' kv.Key);              }
Magic Number,Niecza,CandidateSet,C:\repos\sorear_niecza\lib\NieczaCLR.cs,CheckJunctions,The following statement contains a magic number: Variable jct = (jun_pivot == -2 ? named[jun_pivot_n] :                      pos[jun_pivot]);
Magic Number,Niecza,OverloadCandidate,C:\repos\sorear_niecza\lib\NieczaCLR.cs,MinDispatchArity,The following statement contains a magic number: return args.Length + 2;
Magic Number,Niecza,CLRWrapperProvider,C:\repos\sorear_niecza\lib\NieczaCLR.cs,CLRWrapperProvider,The following statement contains a magic number: delegate_methods = new MethodInfo[20];
Magic Number,Niecza,CLRWrapperProvider,C:\repos\sorear_niecza\lib\NieczaCLR.cs,CLRWrapperProvider,The following statement contains a magic number: foreach (MethodInfo mi in typeof(CLRWrapperProvider).GetMethods()) {                  string nm = mi.Name;                  if (nm[0] == 'd' && nm[1] == 'v')                      delegate_methods[2 * (nm[2] - '0')] = mi;                  if (nm[0] == 'd' && nm[1] == 'n' && nm[2] == 'v')                      delegate_methods[2 * (nm[3] - '0') + 1] = mi;              }
Magic Number,Niecza,CLRWrapperProvider,C:\repos\sorear_niecza\lib\NieczaCLR.cs,CLRWrapperProvider,The following statement contains a magic number: foreach (MethodInfo mi in typeof(CLRWrapperProvider).GetMethods()) {                  string nm = mi.Name;                  if (nm[0] == 'd' && nm[1] == 'v')                      delegate_methods[2 * (nm[2] - '0')] = mi;                  if (nm[0] == 'd' && nm[1] == 'n' && nm[2] == 'v')                      delegate_methods[2 * (nm[3] - '0') + 1] = mi;              }
Magic Number,Niecza,CLRWrapperProvider,C:\repos\sorear_niecza\lib\NieczaCLR.cs,CLRWrapperProvider,The following statement contains a magic number: foreach (MethodInfo mi in typeof(CLRWrapperProvider).GetMethods()) {                  string nm = mi.Name;                  if (nm[0] == 'd' && nm[1] == 'v')                      delegate_methods[2 * (nm[2] - '0')] = mi;                  if (nm[0] == 'd' && nm[1] == 'n' && nm[2] == 'v')                      delegate_methods[2 * (nm[3] - '0') + 1] = mi;              }
Magic Number,Niecza,CLRWrapperProvider,C:\repos\sorear_niecza\lib\NieczaCLR.cs,CLRWrapperProvider,The following statement contains a magic number: foreach (MethodInfo mi in typeof(CLRWrapperProvider).GetMethods()) {                  string nm = mi.Name;                  if (nm[0] == 'd' && nm[1] == 'v')                      delegate_methods[2 * (nm[2] - '0')] = mi;                  if (nm[0] == 'd' && nm[1] == 'n' && nm[2] == 'v')                      delegate_methods[2 * (nm[3] - '0') + 1] = mi;              }
Magic Number,Niecza,CLRWrapperProvider,C:\repos\sorear_niecza\lib\NieczaCLR.cs,CLRWrapperProvider,The following statement contains a magic number: foreach (MethodInfo mi in typeof(CLRWrapperProvider).GetMethods()) {                  string nm = mi.Name;                  if (nm[0] == 'd' && nm[1] == 'v')                      delegate_methods[2 * (nm[2] - '0')] = mi;                  if (nm[0] == 'd' && nm[1] == 'n' && nm[2] == 'v')                      delegate_methods[2 * (nm[3] - '0') + 1] = mi;              }
Magic Number,Niecza,CLRWrapperProvider,C:\repos\sorear_niecza\lib\NieczaCLR.cs,CoerceArgument,The following statement contains a magic number: if (obj.Does(s.BoolMO)) {                  clr = Kernel.UnboxAny<int>(obj) != 0;              }              // note' Bool ~~ Int ~~ Integral              else if (obj.Does(s.IntegralMO)) {                  // important type directed case!                  int small;                  BigInteger big;                  bool use_big = Builtins.GetAsInteger(var' out small' out big);                    if (ty == typeof(sbyte))                      clr = (!use_big && small >= sbyte.MinValue && small <= sbyte.MaxValue) ? (object)(sbyte)small : null;                  else if (ty == typeof(byte))                      clr = (!use_big && small >= byte.MinValue && small <= byte.MaxValue) ? (object)(byte)small : null;                  else if (ty == typeof(short))                      clr = (!use_big && small >= short.MinValue && small <= short.MaxValue) ? (object)(short)small : null;                  else if (ty == typeof(ushort))                      clr = (!use_big && small >= ushort.MinValue && small <= ushort.MaxValue) ? (object)(ushort)small : null;                  else {                      big = use_big ? big : (BigInteger) small;                        if (ty == typeof(int))                          clr = (big >= int.MinValue && big <= int.MaxValue) ? (object)(int)big : null;                      else if (ty == typeof(uint))                          clr = (big >= uint.MinValue && big <= uint.MaxValue) ? (object)(uint)big : null;                      else if (ty == typeof(long))                          clr = (big >= long.MinValue && big <= long.MaxValue) ? (object)(long)big : null;                      else if (ty == typeof(ulong))                          clr = (big >= ulong.MinValue && big <= ulong.MaxValue) ? (object)(ulong)big : null;                        else if (ty == typeof(float))                          clr = (object)(float)big;                      else if (ty == typeof(double))                          clr = (object)(double)big;                      else if (ty == typeof(decimal))                          clr = big.GetWords().Length <= 3 ? (object)(decimal)big : null;                      else if (ty == typeof(object))                          clr = use_big ? null : (object)small;                      else                          clr = obj;                  }              }              else if (obj.Does(s.RealMO)) {                  // fractional value                    if (ty == typeof(decimal)) {                      // decimal is for people who care about exactness                      int rk;                      P6any n = Builtins.GetNumber(var' obj' out rk);                      BigInteger num' den;                      if (rk == Builtins.NR_FATRAT) {                          FatRat r = Kernel.UnboxAny<FatRat>(n);                          num = r.num; den = r.den;                      }                      else if (rk == Builtins.NR_FIXRAT) {                          Rat r = Kernel.UnboxAny<Rat>(n);                          num = r.num; den = r.den;                      }                      else if (rk == Builtins.NR_BIGINT) {                          num = Kernel.UnboxAny<BigInteger>(n); den = BigInteger.One;                      }                      else if (rk == Builtins.NR_FIXINT) {                          num = Kernel.UnboxAny<int>(n); den = BigInteger.One;                      }                      else {                          return false;                      }                      BigInteger div' rem;                      int scale = 0;                      while (true) {                          div = BigInteger.DivRem(den' 10' out rem);                          if (rem.Sign != 0) break;                          den = div;                          scale++;                      }                      while (true) {                          div = BigInteger.DivRem(den' 5' out rem);                          if (rem.Sign != 0) break;                          den = div;                          num *= 2;                          scale++;                      }                      while (true) {                          div = BigInteger.DivRem(den' 2' out rem);                          if (rem.Sign != 0) break;                          den = div;                          num *= 5;                          scale++;                      }                      if (den != BigInteger.One)                          return false;                      if (scale > 28)                          return false;                      int[] bits = decimal.GetBits((decimal)num);                      bits[3] = scale << 16;                      clr = new decimal(bits);                  } else {                      double val = obj.mo.mro_raw_Numeric.Get(var);                      if (ty == typeof(float))                          clr = (object)(float)val;                      else if (ty == typeof(double) || ty == typeof(object))                          clr = (object)val;                  }              }              else if (obj.Does(s.StrMO)) {                  string st = Kernel.UnboxAny<string>(obj);                  if (ty == typeof(char) && st.Length == 1)                      clr = st[0];                  else if (ty == typeof(string))                      clr = st;                  else if (ty == typeof(object))                      clr = st;                  else                      clr = obj;              }              // "Callable"              else if (typeof(Delegate).IsAssignableFrom(ty)) {                  MethodInfo needed = ty.GetMethod("Invoke");                  ParameterInfo[] pi = needed.GetParameters();                    if (pi.Length >= 10) {                      clr = null;                  } else if (needed.ReturnType != typeof(void)) {                      Type[] args = new Type[pi.Length + 1];                      args[0] = needed.ReturnType;                      for (int i = 0; i < pi.Length; i++)                          args[i+1] = pi[i].ParameterType;                      MethodInfo compat = delegate_methods[pi.Length * 2 + 1].                          MakeGenericMethod(args);                      clr = Delegate.CreateDelegate(ty' obj' compat);                  } else {                      Type[] args = new Type[pi.Length];                      for (int i = 0; i < pi.Length; i++)                          args[i] = pi[i].ParameterType;                      MethodInfo compat = delegate_methods[pi.Length * 2];                      if (args.Length != 0)                          compat = compat.MakeGenericMethod(args);                      clr = Delegate.CreateDelegate(ty' obj' compat);                  }              }              else if (obj is BoxObject<object>) {                  clr = Kernel.UnboxAny<object>(obj);              }              else {                  clr = obj;              }
Magic Number,Niecza,CLRWrapperProvider,C:\repos\sorear_niecza\lib\NieczaCLR.cs,CoerceArgument,The following statement contains a magic number: if (obj.Does(s.BoolMO)) {                  clr = Kernel.UnboxAny<int>(obj) != 0;              }              // note' Bool ~~ Int ~~ Integral              else if (obj.Does(s.IntegralMO)) {                  // important type directed case!                  int small;                  BigInteger big;                  bool use_big = Builtins.GetAsInteger(var' out small' out big);                    if (ty == typeof(sbyte))                      clr = (!use_big && small >= sbyte.MinValue && small <= sbyte.MaxValue) ? (object)(sbyte)small : null;                  else if (ty == typeof(byte))                      clr = (!use_big && small >= byte.MinValue && small <= byte.MaxValue) ? (object)(byte)small : null;                  else if (ty == typeof(short))                      clr = (!use_big && small >= short.MinValue && small <= short.MaxValue) ? (object)(short)small : null;                  else if (ty == typeof(ushort))                      clr = (!use_big && small >= ushort.MinValue && small <= ushort.MaxValue) ? (object)(ushort)small : null;                  else {                      big = use_big ? big : (BigInteger) small;                        if (ty == typeof(int))                          clr = (big >= int.MinValue && big <= int.MaxValue) ? (object)(int)big : null;                      else if (ty == typeof(uint))                          clr = (big >= uint.MinValue && big <= uint.MaxValue) ? (object)(uint)big : null;                      else if (ty == typeof(long))                          clr = (big >= long.MinValue && big <= long.MaxValue) ? (object)(long)big : null;                      else if (ty == typeof(ulong))                          clr = (big >= ulong.MinValue && big <= ulong.MaxValue) ? (object)(ulong)big : null;                        else if (ty == typeof(float))                          clr = (object)(float)big;                      else if (ty == typeof(double))                          clr = (object)(double)big;                      else if (ty == typeof(decimal))                          clr = big.GetWords().Length <= 3 ? (object)(decimal)big : null;                      else if (ty == typeof(object))                          clr = use_big ? null : (object)small;                      else                          clr = obj;                  }              }              else if (obj.Does(s.RealMO)) {                  // fractional value                    if (ty == typeof(decimal)) {                      // decimal is for people who care about exactness                      int rk;                      P6any n = Builtins.GetNumber(var' obj' out rk);                      BigInteger num' den;                      if (rk == Builtins.NR_FATRAT) {                          FatRat r = Kernel.UnboxAny<FatRat>(n);                          num = r.num; den = r.den;                      }                      else if (rk == Builtins.NR_FIXRAT) {                          Rat r = Kernel.UnboxAny<Rat>(n);                          num = r.num; den = r.den;                      }                      else if (rk == Builtins.NR_BIGINT) {                          num = Kernel.UnboxAny<BigInteger>(n); den = BigInteger.One;                      }                      else if (rk == Builtins.NR_FIXINT) {                          num = Kernel.UnboxAny<int>(n); den = BigInteger.One;                      }                      else {                          return false;                      }                      BigInteger div' rem;                      int scale = 0;                      while (true) {                          div = BigInteger.DivRem(den' 10' out rem);                          if (rem.Sign != 0) break;                          den = div;                          scale++;                      }                      while (true) {                          div = BigInteger.DivRem(den' 5' out rem);                          if (rem.Sign != 0) break;                          den = div;                          num *= 2;                          scale++;                      }                      while (true) {                          div = BigInteger.DivRem(den' 2' out rem);                          if (rem.Sign != 0) break;                          den = div;                          num *= 5;                          scale++;                      }                      if (den != BigInteger.One)                          return false;                      if (scale > 28)                          return false;                      int[] bits = decimal.GetBits((decimal)num);                      bits[3] = scale << 16;                      clr = new decimal(bits);                  } else {                      double val = obj.mo.mro_raw_Numeric.Get(var);                      if (ty == typeof(float))                          clr = (object)(float)val;                      else if (ty == typeof(double) || ty == typeof(object))                          clr = (object)val;                  }              }              else if (obj.Does(s.StrMO)) {                  string st = Kernel.UnboxAny<string>(obj);                  if (ty == typeof(char) && st.Length == 1)                      clr = st[0];                  else if (ty == typeof(string))                      clr = st;                  else if (ty == typeof(object))                      clr = st;                  else                      clr = obj;              }              // "Callable"              else if (typeof(Delegate).IsAssignableFrom(ty)) {                  MethodInfo needed = ty.GetMethod("Invoke");                  ParameterInfo[] pi = needed.GetParameters();                    if (pi.Length >= 10) {                      clr = null;                  } else if (needed.ReturnType != typeof(void)) {                      Type[] args = new Type[pi.Length + 1];                      args[0] = needed.ReturnType;                      for (int i = 0; i < pi.Length; i++)                          args[i+1] = pi[i].ParameterType;                      MethodInfo compat = delegate_methods[pi.Length * 2 + 1].                          MakeGenericMethod(args);                      clr = Delegate.CreateDelegate(ty' obj' compat);                  } else {                      Type[] args = new Type[pi.Length];                      for (int i = 0; i < pi.Length; i++)                          args[i] = pi[i].ParameterType;                      MethodInfo compat = delegate_methods[pi.Length * 2];                      if (args.Length != 0)                          compat = compat.MakeGenericMethod(args);                      clr = Delegate.CreateDelegate(ty' obj' compat);                  }              }              else if (obj is BoxObject<object>) {                  clr = Kernel.UnboxAny<object>(obj);              }              else {                  clr = obj;              }
Magic Number,Niecza,CLRWrapperProvider,C:\repos\sorear_niecza\lib\NieczaCLR.cs,CoerceArgument,The following statement contains a magic number: if (obj.Does(s.BoolMO)) {                  clr = Kernel.UnboxAny<int>(obj) != 0;              }              // note' Bool ~~ Int ~~ Integral              else if (obj.Does(s.IntegralMO)) {                  // important type directed case!                  int small;                  BigInteger big;                  bool use_big = Builtins.GetAsInteger(var' out small' out big);                    if (ty == typeof(sbyte))                      clr = (!use_big && small >= sbyte.MinValue && small <= sbyte.MaxValue) ? (object)(sbyte)small : null;                  else if (ty == typeof(byte))                      clr = (!use_big && small >= byte.MinValue && small <= byte.MaxValue) ? (object)(byte)small : null;                  else if (ty == typeof(short))                      clr = (!use_big && small >= short.MinValue && small <= short.MaxValue) ? (object)(short)small : null;                  else if (ty == typeof(ushort))                      clr = (!use_big && small >= ushort.MinValue && small <= ushort.MaxValue) ? (object)(ushort)small : null;                  else {                      big = use_big ? big : (BigInteger) small;                        if (ty == typeof(int))                          clr = (big >= int.MinValue && big <= int.MaxValue) ? (object)(int)big : null;                      else if (ty == typeof(uint))                          clr = (big >= uint.MinValue && big <= uint.MaxValue) ? (object)(uint)big : null;                      else if (ty == typeof(long))                          clr = (big >= long.MinValue && big <= long.MaxValue) ? (object)(long)big : null;                      else if (ty == typeof(ulong))                          clr = (big >= ulong.MinValue && big <= ulong.MaxValue) ? (object)(ulong)big : null;                        else if (ty == typeof(float))                          clr = (object)(float)big;                      else if (ty == typeof(double))                          clr = (object)(double)big;                      else if (ty == typeof(decimal))                          clr = big.GetWords().Length <= 3 ? (object)(decimal)big : null;                      else if (ty == typeof(object))                          clr = use_big ? null : (object)small;                      else                          clr = obj;                  }              }              else if (obj.Does(s.RealMO)) {                  // fractional value                    if (ty == typeof(decimal)) {                      // decimal is for people who care about exactness                      int rk;                      P6any n = Builtins.GetNumber(var' obj' out rk);                      BigInteger num' den;                      if (rk == Builtins.NR_FATRAT) {                          FatRat r = Kernel.UnboxAny<FatRat>(n);                          num = r.num; den = r.den;                      }                      else if (rk == Builtins.NR_FIXRAT) {                          Rat r = Kernel.UnboxAny<Rat>(n);                          num = r.num; den = r.den;                      }                      else if (rk == Builtins.NR_BIGINT) {                          num = Kernel.UnboxAny<BigInteger>(n); den = BigInteger.One;                      }                      else if (rk == Builtins.NR_FIXINT) {                          num = Kernel.UnboxAny<int>(n); den = BigInteger.One;                      }                      else {                          return false;                      }                      BigInteger div' rem;                      int scale = 0;                      while (true) {                          div = BigInteger.DivRem(den' 10' out rem);                          if (rem.Sign != 0) break;                          den = div;                          scale++;                      }                      while (true) {                          div = BigInteger.DivRem(den' 5' out rem);                          if (rem.Sign != 0) break;                          den = div;                          num *= 2;                          scale++;                      }                      while (true) {                          div = BigInteger.DivRem(den' 2' out rem);                          if (rem.Sign != 0) break;                          den = div;                          num *= 5;                          scale++;                      }                      if (den != BigInteger.One)                          return false;                      if (scale > 28)                          return false;                      int[] bits = decimal.GetBits((decimal)num);                      bits[3] = scale << 16;                      clr = new decimal(bits);                  } else {                      double val = obj.mo.mro_raw_Numeric.Get(var);                      if (ty == typeof(float))                          clr = (object)(float)val;                      else if (ty == typeof(double) || ty == typeof(object))                          clr = (object)val;                  }              }              else if (obj.Does(s.StrMO)) {                  string st = Kernel.UnboxAny<string>(obj);                  if (ty == typeof(char) && st.Length == 1)                      clr = st[0];                  else if (ty == typeof(string))                      clr = st;                  else if (ty == typeof(object))                      clr = st;                  else                      clr = obj;              }              // "Callable"              else if (typeof(Delegate).IsAssignableFrom(ty)) {                  MethodInfo needed = ty.GetMethod("Invoke");                  ParameterInfo[] pi = needed.GetParameters();                    if (pi.Length >= 10) {                      clr = null;                  } else if (needed.ReturnType != typeof(void)) {                      Type[] args = new Type[pi.Length + 1];                      args[0] = needed.ReturnType;                      for (int i = 0; i < pi.Length; i++)                          args[i+1] = pi[i].ParameterType;                      MethodInfo compat = delegate_methods[pi.Length * 2 + 1].                          MakeGenericMethod(args);                      clr = Delegate.CreateDelegate(ty' obj' compat);                  } else {                      Type[] args = new Type[pi.Length];                      for (int i = 0; i < pi.Length; i++)                          args[i] = pi[i].ParameterType;                      MethodInfo compat = delegate_methods[pi.Length * 2];                      if (args.Length != 0)                          compat = compat.MakeGenericMethod(args);                      clr = Delegate.CreateDelegate(ty' obj' compat);                  }              }              else if (obj is BoxObject<object>) {                  clr = Kernel.UnboxAny<object>(obj);              }              else {                  clr = obj;              }
Magic Number,Niecza,CLRWrapperProvider,C:\repos\sorear_niecza\lib\NieczaCLR.cs,CoerceArgument,The following statement contains a magic number: if (obj.Does(s.BoolMO)) {                  clr = Kernel.UnboxAny<int>(obj) != 0;              }              // note' Bool ~~ Int ~~ Integral              else if (obj.Does(s.IntegralMO)) {                  // important type directed case!                  int small;                  BigInteger big;                  bool use_big = Builtins.GetAsInteger(var' out small' out big);                    if (ty == typeof(sbyte))                      clr = (!use_big && small >= sbyte.MinValue && small <= sbyte.MaxValue) ? (object)(sbyte)small : null;                  else if (ty == typeof(byte))                      clr = (!use_big && small >= byte.MinValue && small <= byte.MaxValue) ? (object)(byte)small : null;                  else if (ty == typeof(short))                      clr = (!use_big && small >= short.MinValue && small <= short.MaxValue) ? (object)(short)small : null;                  else if (ty == typeof(ushort))                      clr = (!use_big && small >= ushort.MinValue && small <= ushort.MaxValue) ? (object)(ushort)small : null;                  else {                      big = use_big ? big : (BigInteger) small;                        if (ty == typeof(int))                          clr = (big >= int.MinValue && big <= int.MaxValue) ? (object)(int)big : null;                      else if (ty == typeof(uint))                          clr = (big >= uint.MinValue && big <= uint.MaxValue) ? (object)(uint)big : null;                      else if (ty == typeof(long))                          clr = (big >= long.MinValue && big <= long.MaxValue) ? (object)(long)big : null;                      else if (ty == typeof(ulong))                          clr = (big >= ulong.MinValue && big <= ulong.MaxValue) ? (object)(ulong)big : null;                        else if (ty == typeof(float))                          clr = (object)(float)big;                      else if (ty == typeof(double))                          clr = (object)(double)big;                      else if (ty == typeof(decimal))                          clr = big.GetWords().Length <= 3 ? (object)(decimal)big : null;                      else if (ty == typeof(object))                          clr = use_big ? null : (object)small;                      else                          clr = obj;                  }              }              else if (obj.Does(s.RealMO)) {                  // fractional value                    if (ty == typeof(decimal)) {                      // decimal is for people who care about exactness                      int rk;                      P6any n = Builtins.GetNumber(var' obj' out rk);                      BigInteger num' den;                      if (rk == Builtins.NR_FATRAT) {                          FatRat r = Kernel.UnboxAny<FatRat>(n);                          num = r.num; den = r.den;                      }                      else if (rk == Builtins.NR_FIXRAT) {                          Rat r = Kernel.UnboxAny<Rat>(n);                          num = r.num; den = r.den;                      }                      else if (rk == Builtins.NR_BIGINT) {                          num = Kernel.UnboxAny<BigInteger>(n); den = BigInteger.One;                      }                      else if (rk == Builtins.NR_FIXINT) {                          num = Kernel.UnboxAny<int>(n); den = BigInteger.One;                      }                      else {                          return false;                      }                      BigInteger div' rem;                      int scale = 0;                      while (true) {                          div = BigInteger.DivRem(den' 10' out rem);                          if (rem.Sign != 0) break;                          den = div;                          scale++;                      }                      while (true) {                          div = BigInteger.DivRem(den' 5' out rem);                          if (rem.Sign != 0) break;                          den = div;                          num *= 2;                          scale++;                      }                      while (true) {                          div = BigInteger.DivRem(den' 2' out rem);                          if (rem.Sign != 0) break;                          den = div;                          num *= 5;                          scale++;                      }                      if (den != BigInteger.One)                          return false;                      if (scale > 28)                          return false;                      int[] bits = decimal.GetBits((decimal)num);                      bits[3] = scale << 16;                      clr = new decimal(bits);                  } else {                      double val = obj.mo.mro_raw_Numeric.Get(var);                      if (ty == typeof(float))                          clr = (object)(float)val;                      else if (ty == typeof(double) || ty == typeof(object))                          clr = (object)val;                  }              }              else if (obj.Does(s.StrMO)) {                  string st = Kernel.UnboxAny<string>(obj);                  if (ty == typeof(char) && st.Length == 1)                      clr = st[0];                  else if (ty == typeof(string))                      clr = st;                  else if (ty == typeof(object))                      clr = st;                  else                      clr = obj;              }              // "Callable"              else if (typeof(Delegate).IsAssignableFrom(ty)) {                  MethodInfo needed = ty.GetMethod("Invoke");                  ParameterInfo[] pi = needed.GetParameters();                    if (pi.Length >= 10) {                      clr = null;                  } else if (needed.ReturnType != typeof(void)) {                      Type[] args = new Type[pi.Length + 1];                      args[0] = needed.ReturnType;                      for (int i = 0; i < pi.Length; i++)                          args[i+1] = pi[i].ParameterType;                      MethodInfo compat = delegate_methods[pi.Length * 2 + 1].                          MakeGenericMethod(args);                      clr = Delegate.CreateDelegate(ty' obj' compat);                  } else {                      Type[] args = new Type[pi.Length];                      for (int i = 0; i < pi.Length; i++)                          args[i] = pi[i].ParameterType;                      MethodInfo compat = delegate_methods[pi.Length * 2];                      if (args.Length != 0)                          compat = compat.MakeGenericMethod(args);                      clr = Delegate.CreateDelegate(ty' obj' compat);                  }              }              else if (obj is BoxObject<object>) {                  clr = Kernel.UnboxAny<object>(obj);              }              else {                  clr = obj;              }
Magic Number,Niecza,CLRWrapperProvider,C:\repos\sorear_niecza\lib\NieczaCLR.cs,CoerceArgument,The following statement contains a magic number: if (obj.Does(s.BoolMO)) {                  clr = Kernel.UnboxAny<int>(obj) != 0;              }              // note' Bool ~~ Int ~~ Integral              else if (obj.Does(s.IntegralMO)) {                  // important type directed case!                  int small;                  BigInteger big;                  bool use_big = Builtins.GetAsInteger(var' out small' out big);                    if (ty == typeof(sbyte))                      clr = (!use_big && small >= sbyte.MinValue && small <= sbyte.MaxValue) ? (object)(sbyte)small : null;                  else if (ty == typeof(byte))                      clr = (!use_big && small >= byte.MinValue && small <= byte.MaxValue) ? (object)(byte)small : null;                  else if (ty == typeof(short))                      clr = (!use_big && small >= short.MinValue && small <= short.MaxValue) ? (object)(short)small : null;                  else if (ty == typeof(ushort))                      clr = (!use_big && small >= ushort.MinValue && small <= ushort.MaxValue) ? (object)(ushort)small : null;                  else {                      big = use_big ? big : (BigInteger) small;                        if (ty == typeof(int))                          clr = (big >= int.MinValue && big <= int.MaxValue) ? (object)(int)big : null;                      else if (ty == typeof(uint))                          clr = (big >= uint.MinValue && big <= uint.MaxValue) ? (object)(uint)big : null;                      else if (ty == typeof(long))                          clr = (big >= long.MinValue && big <= long.MaxValue) ? (object)(long)big : null;                      else if (ty == typeof(ulong))                          clr = (big >= ulong.MinValue && big <= ulong.MaxValue) ? (object)(ulong)big : null;                        else if (ty == typeof(float))                          clr = (object)(float)big;                      else if (ty == typeof(double))                          clr = (object)(double)big;                      else if (ty == typeof(decimal))                          clr = big.GetWords().Length <= 3 ? (object)(decimal)big : null;                      else if (ty == typeof(object))                          clr = use_big ? null : (object)small;                      else                          clr = obj;                  }              }              else if (obj.Does(s.RealMO)) {                  // fractional value                    if (ty == typeof(decimal)) {                      // decimal is for people who care about exactness                      int rk;                      P6any n = Builtins.GetNumber(var' obj' out rk);                      BigInteger num' den;                      if (rk == Builtins.NR_FATRAT) {                          FatRat r = Kernel.UnboxAny<FatRat>(n);                          num = r.num; den = r.den;                      }                      else if (rk == Builtins.NR_FIXRAT) {                          Rat r = Kernel.UnboxAny<Rat>(n);                          num = r.num; den = r.den;                      }                      else if (rk == Builtins.NR_BIGINT) {                          num = Kernel.UnboxAny<BigInteger>(n); den = BigInteger.One;                      }                      else if (rk == Builtins.NR_FIXINT) {                          num = Kernel.UnboxAny<int>(n); den = BigInteger.One;                      }                      else {                          return false;                      }                      BigInteger div' rem;                      int scale = 0;                      while (true) {                          div = BigInteger.DivRem(den' 10' out rem);                          if (rem.Sign != 0) break;                          den = div;                          scale++;                      }                      while (true) {                          div = BigInteger.DivRem(den' 5' out rem);                          if (rem.Sign != 0) break;                          den = div;                          num *= 2;                          scale++;                      }                      while (true) {                          div = BigInteger.DivRem(den' 2' out rem);                          if (rem.Sign != 0) break;                          den = div;                          num *= 5;                          scale++;                      }                      if (den != BigInteger.One)                          return false;                      if (scale > 28)                          return false;                      int[] bits = decimal.GetBits((decimal)num);                      bits[3] = scale << 16;                      clr = new decimal(bits);                  } else {                      double val = obj.mo.mro_raw_Numeric.Get(var);                      if (ty == typeof(float))                          clr = (object)(float)val;                      else if (ty == typeof(double) || ty == typeof(object))                          clr = (object)val;                  }              }              else if (obj.Does(s.StrMO)) {                  string st = Kernel.UnboxAny<string>(obj);                  if (ty == typeof(char) && st.Length == 1)                      clr = st[0];                  else if (ty == typeof(string))                      clr = st;                  else if (ty == typeof(object))                      clr = st;                  else                      clr = obj;              }              // "Callable"              else if (typeof(Delegate).IsAssignableFrom(ty)) {                  MethodInfo needed = ty.GetMethod("Invoke");                  ParameterInfo[] pi = needed.GetParameters();                    if (pi.Length >= 10) {                      clr = null;                  } else if (needed.ReturnType != typeof(void)) {                      Type[] args = new Type[pi.Length + 1];                      args[0] = needed.ReturnType;                      for (int i = 0; i < pi.Length; i++)                          args[i+1] = pi[i].ParameterType;                      MethodInfo compat = delegate_methods[pi.Length * 2 + 1].                          MakeGenericMethod(args);                      clr = Delegate.CreateDelegate(ty' obj' compat);                  } else {                      Type[] args = new Type[pi.Length];                      for (int i = 0; i < pi.Length; i++)                          args[i] = pi[i].ParameterType;                      MethodInfo compat = delegate_methods[pi.Length * 2];                      if (args.Length != 0)                          compat = compat.MakeGenericMethod(args);                      clr = Delegate.CreateDelegate(ty' obj' compat);                  }              }              else if (obj is BoxObject<object>) {                  clr = Kernel.UnboxAny<object>(obj);              }              else {                  clr = obj;              }
Magic Number,Niecza,CLRWrapperProvider,C:\repos\sorear_niecza\lib\NieczaCLR.cs,CoerceArgument,The following statement contains a magic number: if (obj.Does(s.BoolMO)) {                  clr = Kernel.UnboxAny<int>(obj) != 0;              }              // note' Bool ~~ Int ~~ Integral              else if (obj.Does(s.IntegralMO)) {                  // important type directed case!                  int small;                  BigInteger big;                  bool use_big = Builtins.GetAsInteger(var' out small' out big);                    if (ty == typeof(sbyte))                      clr = (!use_big && small >= sbyte.MinValue && small <= sbyte.MaxValue) ? (object)(sbyte)small : null;                  else if (ty == typeof(byte))                      clr = (!use_big && small >= byte.MinValue && small <= byte.MaxValue) ? (object)(byte)small : null;                  else if (ty == typeof(short))                      clr = (!use_big && small >= short.MinValue && small <= short.MaxValue) ? (object)(short)small : null;                  else if (ty == typeof(ushort))                      clr = (!use_big && small >= ushort.MinValue && small <= ushort.MaxValue) ? (object)(ushort)small : null;                  else {                      big = use_big ? big : (BigInteger) small;                        if (ty == typeof(int))                          clr = (big >= int.MinValue && big <= int.MaxValue) ? (object)(int)big : null;                      else if (ty == typeof(uint))                          clr = (big >= uint.MinValue && big <= uint.MaxValue) ? (object)(uint)big : null;                      else if (ty == typeof(long))                          clr = (big >= long.MinValue && big <= long.MaxValue) ? (object)(long)big : null;                      else if (ty == typeof(ulong))                          clr = (big >= ulong.MinValue && big <= ulong.MaxValue) ? (object)(ulong)big : null;                        else if (ty == typeof(float))                          clr = (object)(float)big;                      else if (ty == typeof(double))                          clr = (object)(double)big;                      else if (ty == typeof(decimal))                          clr = big.GetWords().Length <= 3 ? (object)(decimal)big : null;                      else if (ty == typeof(object))                          clr = use_big ? null : (object)small;                      else                          clr = obj;                  }              }              else if (obj.Does(s.RealMO)) {                  // fractional value                    if (ty == typeof(decimal)) {                      // decimal is for people who care about exactness                      int rk;                      P6any n = Builtins.GetNumber(var' obj' out rk);                      BigInteger num' den;                      if (rk == Builtins.NR_FATRAT) {                          FatRat r = Kernel.UnboxAny<FatRat>(n);                          num = r.num; den = r.den;                      }                      else if (rk == Builtins.NR_FIXRAT) {                          Rat r = Kernel.UnboxAny<Rat>(n);                          num = r.num; den = r.den;                      }                      else if (rk == Builtins.NR_BIGINT) {                          num = Kernel.UnboxAny<BigInteger>(n); den = BigInteger.One;                      }                      else if (rk == Builtins.NR_FIXINT) {                          num = Kernel.UnboxAny<int>(n); den = BigInteger.One;                      }                      else {                          return false;                      }                      BigInteger div' rem;                      int scale = 0;                      while (true) {                          div = BigInteger.DivRem(den' 10' out rem);                          if (rem.Sign != 0) break;                          den = div;                          scale++;                      }                      while (true) {                          div = BigInteger.DivRem(den' 5' out rem);                          if (rem.Sign != 0) break;                          den = div;                          num *= 2;                          scale++;                      }                      while (true) {                          div = BigInteger.DivRem(den' 2' out rem);                          if (rem.Sign != 0) break;                          den = div;                          num *= 5;                          scale++;                      }                      if (den != BigInteger.One)                          return false;                      if (scale > 28)                          return false;                      int[] bits = decimal.GetBits((decimal)num);                      bits[3] = scale << 16;                      clr = new decimal(bits);                  } else {                      double val = obj.mo.mro_raw_Numeric.Get(var);                      if (ty == typeof(float))                          clr = (object)(float)val;                      else if (ty == typeof(double) || ty == typeof(object))                          clr = (object)val;                  }              }              else if (obj.Does(s.StrMO)) {                  string st = Kernel.UnboxAny<string>(obj);                  if (ty == typeof(char) && st.Length == 1)                      clr = st[0];                  else if (ty == typeof(string))                      clr = st;                  else if (ty == typeof(object))                      clr = st;                  else                      clr = obj;              }              // "Callable"              else if (typeof(Delegate).IsAssignableFrom(ty)) {                  MethodInfo needed = ty.GetMethod("Invoke");                  ParameterInfo[] pi = needed.GetParameters();                    if (pi.Length >= 10) {                      clr = null;                  } else if (needed.ReturnType != typeof(void)) {                      Type[] args = new Type[pi.Length + 1];                      args[0] = needed.ReturnType;                      for (int i = 0; i < pi.Length; i++)                          args[i+1] = pi[i].ParameterType;                      MethodInfo compat = delegate_methods[pi.Length * 2 + 1].                          MakeGenericMethod(args);                      clr = Delegate.CreateDelegate(ty' obj' compat);                  } else {                      Type[] args = new Type[pi.Length];                      for (int i = 0; i < pi.Length; i++)                          args[i] = pi[i].ParameterType;                      MethodInfo compat = delegate_methods[pi.Length * 2];                      if (args.Length != 0)                          compat = compat.MakeGenericMethod(args);                      clr = Delegate.CreateDelegate(ty' obj' compat);                  }              }              else if (obj is BoxObject<object>) {                  clr = Kernel.UnboxAny<object>(obj);              }              else {                  clr = obj;              }
Magic Number,Niecza,CLRWrapperProvider,C:\repos\sorear_niecza\lib\NieczaCLR.cs,CoerceArgument,The following statement contains a magic number: if (obj.Does(s.BoolMO)) {                  clr = Kernel.UnboxAny<int>(obj) != 0;              }              // note' Bool ~~ Int ~~ Integral              else if (obj.Does(s.IntegralMO)) {                  // important type directed case!                  int small;                  BigInteger big;                  bool use_big = Builtins.GetAsInteger(var' out small' out big);                    if (ty == typeof(sbyte))                      clr = (!use_big && small >= sbyte.MinValue && small <= sbyte.MaxValue) ? (object)(sbyte)small : null;                  else if (ty == typeof(byte))                      clr = (!use_big && small >= byte.MinValue && small <= byte.MaxValue) ? (object)(byte)small : null;                  else if (ty == typeof(short))                      clr = (!use_big && small >= short.MinValue && small <= short.MaxValue) ? (object)(short)small : null;                  else if (ty == typeof(ushort))                      clr = (!use_big && small >= ushort.MinValue && small <= ushort.MaxValue) ? (object)(ushort)small : null;                  else {                      big = use_big ? big : (BigInteger) small;                        if (ty == typeof(int))                          clr = (big >= int.MinValue && big <= int.MaxValue) ? (object)(int)big : null;                      else if (ty == typeof(uint))                          clr = (big >= uint.MinValue && big <= uint.MaxValue) ? (object)(uint)big : null;                      else if (ty == typeof(long))                          clr = (big >= long.MinValue && big <= long.MaxValue) ? (object)(long)big : null;                      else if (ty == typeof(ulong))                          clr = (big >= ulong.MinValue && big <= ulong.MaxValue) ? (object)(ulong)big : null;                        else if (ty == typeof(float))                          clr = (object)(float)big;                      else if (ty == typeof(double))                          clr = (object)(double)big;                      else if (ty == typeof(decimal))                          clr = big.GetWords().Length <= 3 ? (object)(decimal)big : null;                      else if (ty == typeof(object))                          clr = use_big ? null : (object)small;                      else                          clr = obj;                  }              }              else if (obj.Does(s.RealMO)) {                  // fractional value                    if (ty == typeof(decimal)) {                      // decimal is for people who care about exactness                      int rk;                      P6any n = Builtins.GetNumber(var' obj' out rk);                      BigInteger num' den;                      if (rk == Builtins.NR_FATRAT) {                          FatRat r = Kernel.UnboxAny<FatRat>(n);                          num = r.num; den = r.den;                      }                      else if (rk == Builtins.NR_FIXRAT) {                          Rat r = Kernel.UnboxAny<Rat>(n);                          num = r.num; den = r.den;                      }                      else if (rk == Builtins.NR_BIGINT) {                          num = Kernel.UnboxAny<BigInteger>(n); den = BigInteger.One;                      }                      else if (rk == Builtins.NR_FIXINT) {                          num = Kernel.UnboxAny<int>(n); den = BigInteger.One;                      }                      else {                          return false;                      }                      BigInteger div' rem;                      int scale = 0;                      while (true) {                          div = BigInteger.DivRem(den' 10' out rem);                          if (rem.Sign != 0) break;                          den = div;                          scale++;                      }                      while (true) {                          div = BigInteger.DivRem(den' 5' out rem);                          if (rem.Sign != 0) break;                          den = div;                          num *= 2;                          scale++;                      }                      while (true) {                          div = BigInteger.DivRem(den' 2' out rem);                          if (rem.Sign != 0) break;                          den = div;                          num *= 5;                          scale++;                      }                      if (den != BigInteger.One)                          return false;                      if (scale > 28)                          return false;                      int[] bits = decimal.GetBits((decimal)num);                      bits[3] = scale << 16;                      clr = new decimal(bits);                  } else {                      double val = obj.mo.mro_raw_Numeric.Get(var);                      if (ty == typeof(float))                          clr = (object)(float)val;                      else if (ty == typeof(double) || ty == typeof(object))                          clr = (object)val;                  }              }              else if (obj.Does(s.StrMO)) {                  string st = Kernel.UnboxAny<string>(obj);                  if (ty == typeof(char) && st.Length == 1)                      clr = st[0];                  else if (ty == typeof(string))                      clr = st;                  else if (ty == typeof(object))                      clr = st;                  else                      clr = obj;              }              // "Callable"              else if (typeof(Delegate).IsAssignableFrom(ty)) {                  MethodInfo needed = ty.GetMethod("Invoke");                  ParameterInfo[] pi = needed.GetParameters();                    if (pi.Length >= 10) {                      clr = null;                  } else if (needed.ReturnType != typeof(void)) {                      Type[] args = new Type[pi.Length + 1];                      args[0] = needed.ReturnType;                      for (int i = 0; i < pi.Length; i++)                          args[i+1] = pi[i].ParameterType;                      MethodInfo compat = delegate_methods[pi.Length * 2 + 1].                          MakeGenericMethod(args);                      clr = Delegate.CreateDelegate(ty' obj' compat);                  } else {                      Type[] args = new Type[pi.Length];                      for (int i = 0; i < pi.Length; i++)                          args[i] = pi[i].ParameterType;                      MethodInfo compat = delegate_methods[pi.Length * 2];                      if (args.Length != 0)                          compat = compat.MakeGenericMethod(args);                      clr = Delegate.CreateDelegate(ty' obj' compat);                  }              }              else if (obj is BoxObject<object>) {                  clr = Kernel.UnboxAny<object>(obj);              }              else {                  clr = obj;              }
Magic Number,Niecza,CLRWrapperProvider,C:\repos\sorear_niecza\lib\NieczaCLR.cs,CoerceArgument,The following statement contains a magic number: if (obj.Does(s.BoolMO)) {                  clr = Kernel.UnboxAny<int>(obj) != 0;              }              // note' Bool ~~ Int ~~ Integral              else if (obj.Does(s.IntegralMO)) {                  // important type directed case!                  int small;                  BigInteger big;                  bool use_big = Builtins.GetAsInteger(var' out small' out big);                    if (ty == typeof(sbyte))                      clr = (!use_big && small >= sbyte.MinValue && small <= sbyte.MaxValue) ? (object)(sbyte)small : null;                  else if (ty == typeof(byte))                      clr = (!use_big && small >= byte.MinValue && small <= byte.MaxValue) ? (object)(byte)small : null;                  else if (ty == typeof(short))                      clr = (!use_big && small >= short.MinValue && small <= short.MaxValue) ? (object)(short)small : null;                  else if (ty == typeof(ushort))                      clr = (!use_big && small >= ushort.MinValue && small <= ushort.MaxValue) ? (object)(ushort)small : null;                  else {                      big = use_big ? big : (BigInteger) small;                        if (ty == typeof(int))                          clr = (big >= int.MinValue && big <= int.MaxValue) ? (object)(int)big : null;                      else if (ty == typeof(uint))                          clr = (big >= uint.MinValue && big <= uint.MaxValue) ? (object)(uint)big : null;                      else if (ty == typeof(long))                          clr = (big >= long.MinValue && big <= long.MaxValue) ? (object)(long)big : null;                      else if (ty == typeof(ulong))                          clr = (big >= ulong.MinValue && big <= ulong.MaxValue) ? (object)(ulong)big : null;                        else if (ty == typeof(float))                          clr = (object)(float)big;                      else if (ty == typeof(double))                          clr = (object)(double)big;                      else if (ty == typeof(decimal))                          clr = big.GetWords().Length <= 3 ? (object)(decimal)big : null;                      else if (ty == typeof(object))                          clr = use_big ? null : (object)small;                      else                          clr = obj;                  }              }              else if (obj.Does(s.RealMO)) {                  // fractional value                    if (ty == typeof(decimal)) {                      // decimal is for people who care about exactness                      int rk;                      P6any n = Builtins.GetNumber(var' obj' out rk);                      BigInteger num' den;                      if (rk == Builtins.NR_FATRAT) {                          FatRat r = Kernel.UnboxAny<FatRat>(n);                          num = r.num; den = r.den;                      }                      else if (rk == Builtins.NR_FIXRAT) {                          Rat r = Kernel.UnboxAny<Rat>(n);                          num = r.num; den = r.den;                      }                      else if (rk == Builtins.NR_BIGINT) {                          num = Kernel.UnboxAny<BigInteger>(n); den = BigInteger.One;                      }                      else if (rk == Builtins.NR_FIXINT) {                          num = Kernel.UnboxAny<int>(n); den = BigInteger.One;                      }                      else {                          return false;                      }                      BigInteger div' rem;                      int scale = 0;                      while (true) {                          div = BigInteger.DivRem(den' 10' out rem);                          if (rem.Sign != 0) break;                          den = div;                          scale++;                      }                      while (true) {                          div = BigInteger.DivRem(den' 5' out rem);                          if (rem.Sign != 0) break;                          den = div;                          num *= 2;                          scale++;                      }                      while (true) {                          div = BigInteger.DivRem(den' 2' out rem);                          if (rem.Sign != 0) break;                          den = div;                          num *= 5;                          scale++;                      }                      if (den != BigInteger.One)                          return false;                      if (scale > 28)                          return false;                      int[] bits = decimal.GetBits((decimal)num);                      bits[3] = scale << 16;                      clr = new decimal(bits);                  } else {                      double val = obj.mo.mro_raw_Numeric.Get(var);                      if (ty == typeof(float))                          clr = (object)(float)val;                      else if (ty == typeof(double) || ty == typeof(object))                          clr = (object)val;                  }              }              else if (obj.Does(s.StrMO)) {                  string st = Kernel.UnboxAny<string>(obj);                  if (ty == typeof(char) && st.Length == 1)                      clr = st[0];                  else if (ty == typeof(string))                      clr = st;                  else if (ty == typeof(object))                      clr = st;                  else                      clr = obj;              }              // "Callable"              else if (typeof(Delegate).IsAssignableFrom(ty)) {                  MethodInfo needed = ty.GetMethod("Invoke");                  ParameterInfo[] pi = needed.GetParameters();                    if (pi.Length >= 10) {                      clr = null;                  } else if (needed.ReturnType != typeof(void)) {                      Type[] args = new Type[pi.Length + 1];                      args[0] = needed.ReturnType;                      for (int i = 0; i < pi.Length; i++)                          args[i+1] = pi[i].ParameterType;                      MethodInfo compat = delegate_methods[pi.Length * 2 + 1].                          MakeGenericMethod(args);                      clr = Delegate.CreateDelegate(ty' obj' compat);                  } else {                      Type[] args = new Type[pi.Length];                      for (int i = 0; i < pi.Length; i++)                          args[i] = pi[i].ParameterType;                      MethodInfo compat = delegate_methods[pi.Length * 2];                      if (args.Length != 0)                          compat = compat.MakeGenericMethod(args);                      clr = Delegate.CreateDelegate(ty' obj' compat);                  }              }              else if (obj is BoxObject<object>) {                  clr = Kernel.UnboxAny<object>(obj);              }              else {                  clr = obj;              }
Magic Number,Niecza,CLRWrapperProvider,C:\repos\sorear_niecza\lib\NieczaCLR.cs,CoerceArgument,The following statement contains a magic number: if (obj.Does(s.BoolMO)) {                  clr = Kernel.UnboxAny<int>(obj) != 0;              }              // note' Bool ~~ Int ~~ Integral              else if (obj.Does(s.IntegralMO)) {                  // important type directed case!                  int small;                  BigInteger big;                  bool use_big = Builtins.GetAsInteger(var' out small' out big);                    if (ty == typeof(sbyte))                      clr = (!use_big && small >= sbyte.MinValue && small <= sbyte.MaxValue) ? (object)(sbyte)small : null;                  else if (ty == typeof(byte))                      clr = (!use_big && small >= byte.MinValue && small <= byte.MaxValue) ? (object)(byte)small : null;                  else if (ty == typeof(short))                      clr = (!use_big && small >= short.MinValue && small <= short.MaxValue) ? (object)(short)small : null;                  else if (ty == typeof(ushort))                      clr = (!use_big && small >= ushort.MinValue && small <= ushort.MaxValue) ? (object)(ushort)small : null;                  else {                      big = use_big ? big : (BigInteger) small;                        if (ty == typeof(int))                          clr = (big >= int.MinValue && big <= int.MaxValue) ? (object)(int)big : null;                      else if (ty == typeof(uint))                          clr = (big >= uint.MinValue && big <= uint.MaxValue) ? (object)(uint)big : null;                      else if (ty == typeof(long))                          clr = (big >= long.MinValue && big <= long.MaxValue) ? (object)(long)big : null;                      else if (ty == typeof(ulong))                          clr = (big >= ulong.MinValue && big <= ulong.MaxValue) ? (object)(ulong)big : null;                        else if (ty == typeof(float))                          clr = (object)(float)big;                      else if (ty == typeof(double))                          clr = (object)(double)big;                      else if (ty == typeof(decimal))                          clr = big.GetWords().Length <= 3 ? (object)(decimal)big : null;                      else if (ty == typeof(object))                          clr = use_big ? null : (object)small;                      else                          clr = obj;                  }              }              else if (obj.Does(s.RealMO)) {                  // fractional value                    if (ty == typeof(decimal)) {                      // decimal is for people who care about exactness                      int rk;                      P6any n = Builtins.GetNumber(var' obj' out rk);                      BigInteger num' den;                      if (rk == Builtins.NR_FATRAT) {                          FatRat r = Kernel.UnboxAny<FatRat>(n);                          num = r.num; den = r.den;                      }                      else if (rk == Builtins.NR_FIXRAT) {                          Rat r = Kernel.UnboxAny<Rat>(n);                          num = r.num; den = r.den;                      }                      else if (rk == Builtins.NR_BIGINT) {                          num = Kernel.UnboxAny<BigInteger>(n); den = BigInteger.One;                      }                      else if (rk == Builtins.NR_FIXINT) {                          num = Kernel.UnboxAny<int>(n); den = BigInteger.One;                      }                      else {                          return false;                      }                      BigInteger div' rem;                      int scale = 0;                      while (true) {                          div = BigInteger.DivRem(den' 10' out rem);                          if (rem.Sign != 0) break;                          den = div;                          scale++;                      }                      while (true) {                          div = BigInteger.DivRem(den' 5' out rem);                          if (rem.Sign != 0) break;                          den = div;                          num *= 2;                          scale++;                      }                      while (true) {                          div = BigInteger.DivRem(den' 2' out rem);                          if (rem.Sign != 0) break;                          den = div;                          num *= 5;                          scale++;                      }                      if (den != BigInteger.One)                          return false;                      if (scale > 28)                          return false;                      int[] bits = decimal.GetBits((decimal)num);                      bits[3] = scale << 16;                      clr = new decimal(bits);                  } else {                      double val = obj.mo.mro_raw_Numeric.Get(var);                      if (ty == typeof(float))                          clr = (object)(float)val;                      else if (ty == typeof(double) || ty == typeof(object))                          clr = (object)val;                  }              }              else if (obj.Does(s.StrMO)) {                  string st = Kernel.UnboxAny<string>(obj);                  if (ty == typeof(char) && st.Length == 1)                      clr = st[0];                  else if (ty == typeof(string))                      clr = st;                  else if (ty == typeof(object))                      clr = st;                  else                      clr = obj;              }              // "Callable"              else if (typeof(Delegate).IsAssignableFrom(ty)) {                  MethodInfo needed = ty.GetMethod("Invoke");                  ParameterInfo[] pi = needed.GetParameters();                    if (pi.Length >= 10) {                      clr = null;                  } else if (needed.ReturnType != typeof(void)) {                      Type[] args = new Type[pi.Length + 1];                      args[0] = needed.ReturnType;                      for (int i = 0; i < pi.Length; i++)                          args[i+1] = pi[i].ParameterType;                      MethodInfo compat = delegate_methods[pi.Length * 2 + 1].                          MakeGenericMethod(args);                      clr = Delegate.CreateDelegate(ty' obj' compat);                  } else {                      Type[] args = new Type[pi.Length];                      for (int i = 0; i < pi.Length; i++)                          args[i] = pi[i].ParameterType;                      MethodInfo compat = delegate_methods[pi.Length * 2];                      if (args.Length != 0)                          compat = compat.MakeGenericMethod(args);                      clr = Delegate.CreateDelegate(ty' obj' compat);                  }              }              else if (obj is BoxObject<object>) {                  clr = Kernel.UnboxAny<object>(obj);              }              else {                  clr = obj;              }
Magic Number,Niecza,CLRWrapperProvider,C:\repos\sorear_niecza\lib\NieczaCLR.cs,CoerceArgument,The following statement contains a magic number: if (obj.Does(s.BoolMO)) {                  clr = Kernel.UnboxAny<int>(obj) != 0;              }              // note' Bool ~~ Int ~~ Integral              else if (obj.Does(s.IntegralMO)) {                  // important type directed case!                  int small;                  BigInteger big;                  bool use_big = Builtins.GetAsInteger(var' out small' out big);                    if (ty == typeof(sbyte))                      clr = (!use_big && small >= sbyte.MinValue && small <= sbyte.MaxValue) ? (object)(sbyte)small : null;                  else if (ty == typeof(byte))                      clr = (!use_big && small >= byte.MinValue && small <= byte.MaxValue) ? (object)(byte)small : null;                  else if (ty == typeof(short))                      clr = (!use_big && small >= short.MinValue && small <= short.MaxValue) ? (object)(short)small : null;                  else if (ty == typeof(ushort))                      clr = (!use_big && small >= ushort.MinValue && small <= ushort.MaxValue) ? (object)(ushort)small : null;                  else {                      big = use_big ? big : (BigInteger) small;                        if (ty == typeof(int))                          clr = (big >= int.MinValue && big <= int.MaxValue) ? (object)(int)big : null;                      else if (ty == typeof(uint))                          clr = (big >= uint.MinValue && big <= uint.MaxValue) ? (object)(uint)big : null;                      else if (ty == typeof(long))                          clr = (big >= long.MinValue && big <= long.MaxValue) ? (object)(long)big : null;                      else if (ty == typeof(ulong))                          clr = (big >= ulong.MinValue && big <= ulong.MaxValue) ? (object)(ulong)big : null;                        else if (ty == typeof(float))                          clr = (object)(float)big;                      else if (ty == typeof(double))                          clr = (object)(double)big;                      else if (ty == typeof(decimal))                          clr = big.GetWords().Length <= 3 ? (object)(decimal)big : null;                      else if (ty == typeof(object))                          clr = use_big ? null : (object)small;                      else                          clr = obj;                  }              }              else if (obj.Does(s.RealMO)) {                  // fractional value                    if (ty == typeof(decimal)) {                      // decimal is for people who care about exactness                      int rk;                      P6any n = Builtins.GetNumber(var' obj' out rk);                      BigInteger num' den;                      if (rk == Builtins.NR_FATRAT) {                          FatRat r = Kernel.UnboxAny<FatRat>(n);                          num = r.num; den = r.den;                      }                      else if (rk == Builtins.NR_FIXRAT) {                          Rat r = Kernel.UnboxAny<Rat>(n);                          num = r.num; den = r.den;                      }                      else if (rk == Builtins.NR_BIGINT) {                          num = Kernel.UnboxAny<BigInteger>(n); den = BigInteger.One;                      }                      else if (rk == Builtins.NR_FIXINT) {                          num = Kernel.UnboxAny<int>(n); den = BigInteger.One;                      }                      else {                          return false;                      }                      BigInteger div' rem;                      int scale = 0;                      while (true) {                          div = BigInteger.DivRem(den' 10' out rem);                          if (rem.Sign != 0) break;                          den = div;                          scale++;                      }                      while (true) {                          div = BigInteger.DivRem(den' 5' out rem);                          if (rem.Sign != 0) break;                          den = div;                          num *= 2;                          scale++;                      }                      while (true) {                          div = BigInteger.DivRem(den' 2' out rem);                          if (rem.Sign != 0) break;                          den = div;                          num *= 5;                          scale++;                      }                      if (den != BigInteger.One)                          return false;                      if (scale > 28)                          return false;                      int[] bits = decimal.GetBits((decimal)num);                      bits[3] = scale << 16;                      clr = new decimal(bits);                  } else {                      double val = obj.mo.mro_raw_Numeric.Get(var);                      if (ty == typeof(float))                          clr = (object)(float)val;                      else if (ty == typeof(double) || ty == typeof(object))                          clr = (object)val;                  }              }              else if (obj.Does(s.StrMO)) {                  string st = Kernel.UnboxAny<string>(obj);                  if (ty == typeof(char) && st.Length == 1)                      clr = st[0];                  else if (ty == typeof(string))                      clr = st;                  else if (ty == typeof(object))                      clr = st;                  else                      clr = obj;              }              // "Callable"              else if (typeof(Delegate).IsAssignableFrom(ty)) {                  MethodInfo needed = ty.GetMethod("Invoke");                  ParameterInfo[] pi = needed.GetParameters();                    if (pi.Length >= 10) {                      clr = null;                  } else if (needed.ReturnType != typeof(void)) {                      Type[] args = new Type[pi.Length + 1];                      args[0] = needed.ReturnType;                      for (int i = 0; i < pi.Length; i++)                          args[i+1] = pi[i].ParameterType;                      MethodInfo compat = delegate_methods[pi.Length * 2 + 1].                          MakeGenericMethod(args);                      clr = Delegate.CreateDelegate(ty' obj' compat);                  } else {                      Type[] args = new Type[pi.Length];                      for (int i = 0; i < pi.Length; i++)                          args[i] = pi[i].ParameterType;                      MethodInfo compat = delegate_methods[pi.Length * 2];                      if (args.Length != 0)                          compat = compat.MakeGenericMethod(args);                      clr = Delegate.CreateDelegate(ty' obj' compat);                  }              }              else if (obj is BoxObject<object>) {                  clr = Kernel.UnboxAny<object>(obj);              }              else {                  clr = obj;              }
Magic Number,Niecza,CLRWrapperProvider,C:\repos\sorear_niecza\lib\NieczaCLR.cs,CoerceArgument,The following statement contains a magic number: if (obj.Does(s.BoolMO)) {                  clr = Kernel.UnboxAny<int>(obj) != 0;              }              // note' Bool ~~ Int ~~ Integral              else if (obj.Does(s.IntegralMO)) {                  // important type directed case!                  int small;                  BigInteger big;                  bool use_big = Builtins.GetAsInteger(var' out small' out big);                    if (ty == typeof(sbyte))                      clr = (!use_big && small >= sbyte.MinValue && small <= sbyte.MaxValue) ? (object)(sbyte)small : null;                  else if (ty == typeof(byte))                      clr = (!use_big && small >= byte.MinValue && small <= byte.MaxValue) ? (object)(byte)small : null;                  else if (ty == typeof(short))                      clr = (!use_big && small >= short.MinValue && small <= short.MaxValue) ? (object)(short)small : null;                  else if (ty == typeof(ushort))                      clr = (!use_big && small >= ushort.MinValue && small <= ushort.MaxValue) ? (object)(ushort)small : null;                  else {                      big = use_big ? big : (BigInteger) small;                        if (ty == typeof(int))                          clr = (big >= int.MinValue && big <= int.MaxValue) ? (object)(int)big : null;                      else if (ty == typeof(uint))                          clr = (big >= uint.MinValue && big <= uint.MaxValue) ? (object)(uint)big : null;                      else if (ty == typeof(long))                          clr = (big >= long.MinValue && big <= long.MaxValue) ? (object)(long)big : null;                      else if (ty == typeof(ulong))                          clr = (big >= ulong.MinValue && big <= ulong.MaxValue) ? (object)(ulong)big : null;                        else if (ty == typeof(float))                          clr = (object)(float)big;                      else if (ty == typeof(double))                          clr = (object)(double)big;                      else if (ty == typeof(decimal))                          clr = big.GetWords().Length <= 3 ? (object)(decimal)big : null;                      else if (ty == typeof(object))                          clr = use_big ? null : (object)small;                      else                          clr = obj;                  }              }              else if (obj.Does(s.RealMO)) {                  // fractional value                    if (ty == typeof(decimal)) {                      // decimal is for people who care about exactness                      int rk;                      P6any n = Builtins.GetNumber(var' obj' out rk);                      BigInteger num' den;                      if (rk == Builtins.NR_FATRAT) {                          FatRat r = Kernel.UnboxAny<FatRat>(n);                          num = r.num; den = r.den;                      }                      else if (rk == Builtins.NR_FIXRAT) {                          Rat r = Kernel.UnboxAny<Rat>(n);                          num = r.num; den = r.den;                      }                      else if (rk == Builtins.NR_BIGINT) {                          num = Kernel.UnboxAny<BigInteger>(n); den = BigInteger.One;                      }                      else if (rk == Builtins.NR_FIXINT) {                          num = Kernel.UnboxAny<int>(n); den = BigInteger.One;                      }                      else {                          return false;                      }                      BigInteger div' rem;                      int scale = 0;                      while (true) {                          div = BigInteger.DivRem(den' 10' out rem);                          if (rem.Sign != 0) break;                          den = div;                          scale++;                      }                      while (true) {                          div = BigInteger.DivRem(den' 5' out rem);                          if (rem.Sign != 0) break;                          den = div;                          num *= 2;                          scale++;                      }                      while (true) {                          div = BigInteger.DivRem(den' 2' out rem);                          if (rem.Sign != 0) break;                          den = div;                          num *= 5;                          scale++;                      }                      if (den != BigInteger.One)                          return false;                      if (scale > 28)                          return false;                      int[] bits = decimal.GetBits((decimal)num);                      bits[3] = scale << 16;                      clr = new decimal(bits);                  } else {                      double val = obj.mo.mro_raw_Numeric.Get(var);                      if (ty == typeof(float))                          clr = (object)(float)val;                      else if (ty == typeof(double) || ty == typeof(object))                          clr = (object)val;                  }              }              else if (obj.Does(s.StrMO)) {                  string st = Kernel.UnboxAny<string>(obj);                  if (ty == typeof(char) && st.Length == 1)                      clr = st[0];                  else if (ty == typeof(string))                      clr = st;                  else if (ty == typeof(object))                      clr = st;                  else                      clr = obj;              }              // "Callable"              else if (typeof(Delegate).IsAssignableFrom(ty)) {                  MethodInfo needed = ty.GetMethod("Invoke");                  ParameterInfo[] pi = needed.GetParameters();                    if (pi.Length >= 10) {                      clr = null;                  } else if (needed.ReturnType != typeof(void)) {                      Type[] args = new Type[pi.Length + 1];                      args[0] = needed.ReturnType;                      for (int i = 0; i < pi.Length; i++)                          args[i+1] = pi[i].ParameterType;                      MethodInfo compat = delegate_methods[pi.Length * 2 + 1].                          MakeGenericMethod(args);                      clr = Delegate.CreateDelegate(ty' obj' compat);                  } else {                      Type[] args = new Type[pi.Length];                      for (int i = 0; i < pi.Length; i++)                          args[i] = pi[i].ParameterType;                      MethodInfo compat = delegate_methods[pi.Length * 2];                      if (args.Length != 0)                          compat = compat.MakeGenericMethod(args);                      clr = Delegate.CreateDelegate(ty' obj' compat);                  }              }              else if (obj is BoxObject<object>) {                  clr = Kernel.UnboxAny<object>(obj);              }              else {                  clr = obj;              }
Magic Number,Niecza,CLRWrapperProvider,C:\repos\sorear_niecza\lib\NieczaCLR.cs,CoerceArgument,The following statement contains a magic number: if (obj.Does(s.BoolMO)) {                  clr = Kernel.UnboxAny<int>(obj) != 0;              }              // note' Bool ~~ Int ~~ Integral              else if (obj.Does(s.IntegralMO)) {                  // important type directed case!                  int small;                  BigInteger big;                  bool use_big = Builtins.GetAsInteger(var' out small' out big);                    if (ty == typeof(sbyte))                      clr = (!use_big && small >= sbyte.MinValue && small <= sbyte.MaxValue) ? (object)(sbyte)small : null;                  else if (ty == typeof(byte))                      clr = (!use_big && small >= byte.MinValue && small <= byte.MaxValue) ? (object)(byte)small : null;                  else if (ty == typeof(short))                      clr = (!use_big && small >= short.MinValue && small <= short.MaxValue) ? (object)(short)small : null;                  else if (ty == typeof(ushort))                      clr = (!use_big && small >= ushort.MinValue && small <= ushort.MaxValue) ? (object)(ushort)small : null;                  else {                      big = use_big ? big : (BigInteger) small;                        if (ty == typeof(int))                          clr = (big >= int.MinValue && big <= int.MaxValue) ? (object)(int)big : null;                      else if (ty == typeof(uint))                          clr = (big >= uint.MinValue && big <= uint.MaxValue) ? (object)(uint)big : null;                      else if (ty == typeof(long))                          clr = (big >= long.MinValue && big <= long.MaxValue) ? (object)(long)big : null;                      else if (ty == typeof(ulong))                          clr = (big >= ulong.MinValue && big <= ulong.MaxValue) ? (object)(ulong)big : null;                        else if (ty == typeof(float))                          clr = (object)(float)big;                      else if (ty == typeof(double))                          clr = (object)(double)big;                      else if (ty == typeof(decimal))                          clr = big.GetWords().Length <= 3 ? (object)(decimal)big : null;                      else if (ty == typeof(object))                          clr = use_big ? null : (object)small;                      else                          clr = obj;                  }              }              else if (obj.Does(s.RealMO)) {                  // fractional value                    if (ty == typeof(decimal)) {                      // decimal is for people who care about exactness                      int rk;                      P6any n = Builtins.GetNumber(var' obj' out rk);                      BigInteger num' den;                      if (rk == Builtins.NR_FATRAT) {                          FatRat r = Kernel.UnboxAny<FatRat>(n);                          num = r.num; den = r.den;                      }                      else if (rk == Builtins.NR_FIXRAT) {                          Rat r = Kernel.UnboxAny<Rat>(n);                          num = r.num; den = r.den;                      }                      else if (rk == Builtins.NR_BIGINT) {                          num = Kernel.UnboxAny<BigInteger>(n); den = BigInteger.One;                      }                      else if (rk == Builtins.NR_FIXINT) {                          num = Kernel.UnboxAny<int>(n); den = BigInteger.One;                      }                      else {                          return false;                      }                      BigInteger div' rem;                      int scale = 0;                      while (true) {                          div = BigInteger.DivRem(den' 10' out rem);                          if (rem.Sign != 0) break;                          den = div;                          scale++;                      }                      while (true) {                          div = BigInteger.DivRem(den' 5' out rem);                          if (rem.Sign != 0) break;                          den = div;                          num *= 2;                          scale++;                      }                      while (true) {                          div = BigInteger.DivRem(den' 2' out rem);                          if (rem.Sign != 0) break;                          den = div;                          num *= 5;                          scale++;                      }                      if (den != BigInteger.One)                          return false;                      if (scale > 28)                          return false;                      int[] bits = decimal.GetBits((decimal)num);                      bits[3] = scale << 16;                      clr = new decimal(bits);                  } else {                      double val = obj.mo.mro_raw_Numeric.Get(var);                      if (ty == typeof(float))                          clr = (object)(float)val;                      else if (ty == typeof(double) || ty == typeof(object))                          clr = (object)val;                  }              }              else if (obj.Does(s.StrMO)) {                  string st = Kernel.UnboxAny<string>(obj);                  if (ty == typeof(char) && st.Length == 1)                      clr = st[0];                  else if (ty == typeof(string))                      clr = st;                  else if (ty == typeof(object))                      clr = st;                  else                      clr = obj;              }              // "Callable"              else if (typeof(Delegate).IsAssignableFrom(ty)) {                  MethodInfo needed = ty.GetMethod("Invoke");                  ParameterInfo[] pi = needed.GetParameters();                    if (pi.Length >= 10) {                      clr = null;                  } else if (needed.ReturnType != typeof(void)) {                      Type[] args = new Type[pi.Length + 1];                      args[0] = needed.ReturnType;                      for (int i = 0; i < pi.Length; i++)                          args[i+1] = pi[i].ParameterType;                      MethodInfo compat = delegate_methods[pi.Length * 2 + 1].                          MakeGenericMethod(args);                      clr = Delegate.CreateDelegate(ty' obj' compat);                  } else {                      Type[] args = new Type[pi.Length];                      for (int i = 0; i < pi.Length; i++)                          args[i] = pi[i].ParameterType;                      MethodInfo compat = delegate_methods[pi.Length * 2];                      if (args.Length != 0)                          compat = compat.MakeGenericMethod(args);                      clr = Delegate.CreateDelegate(ty' obj' compat);                  }              }              else if (obj is BoxObject<object>) {                  clr = Kernel.UnboxAny<object>(obj);              }              else {                  clr = obj;              }
Magic Number,Niecza,P6any,C:\repos\sorear_niecza\lib\ObjModel.cs,InvokeMethod,The following statement contains a magic number: if (mo.mro_methods.TryGetValue("FALLBACK"' out m)) {                  Variable[] npos = new Variable[pos.Length + 1];                  Array.Copy(pos' 1' npos' 2' pos.Length - 1);                  npos[0] = pos[0];                  npos[1] = Kernel.BoxAnyMO(name' mo.setting.StrMO);                  return m.info.SetupCall(caller' m.outer' m.ip6'                          npos' named' false' m);              }
Magic Number,Niecza,P6how,C:\repos\sorear_niecza\lib\ObjModel.cs,ComputeMRO,The following statement contains a magic number: STable[][] lists = new STable[superclasses.Count + 2][];
Magic Number,Niecza,P6how,C:\repos\sorear_niecza\lib\ObjModel.cs,Freeze,The following statement contains a magic number: fb.Byte((byte)(isComposed ? 2 : isComposing ? 1 : 0));
Magic Number,Niecza,P6how,C:\repos\sorear_niecza\lib\ObjModel.cs,Thaw,The following statement contains a magic number: n.isComposed  = state >= 2;
Magic Number,Niecza,STable,C:\repos\sorear_niecza\lib\ObjModel.cs,SetupVTables,The following statement contains a magic number: mro_bind_key = _GetVTi("postcircumfix:<{ }>"' 3) as BindHandler;
Magic Number,Niecza,STable,C:\repos\sorear_niecza\lib\ObjModel.cs,SetupVTables,The following statement contains a magic number: mro_bind_pos = _GetVTi("postcircumfix:<[ ]>"' 3) as BindHandler;
Magic Number,Niecza,STable,C:\repos\sorear_niecza\lib\ObjModel.cs,SetupVTables,The following statement contains a magic number: mro_delete_key = _GetVTi("postcircumfix:<{ }>"' 2) as IndexHandler ?? s.CallDeleteKey;
Magic Number,Niecza,STable,C:\repos\sorear_niecza\lib\ObjModel.cs,HasType,The following statement contains a magic number: if (k >= 20) {                  return mo.type_set.Contains(m);              } else {                  while (k != 0) {                      if (mo.type_list[--k] == m) return true;                  }                  return false;              }
Magic Number,Niecza,Prod<T1;T2>,C:\repos\sorear_niecza\lib\Utils.cs,GetHashCode,The following statement contains a magic number: h = (h << 5) - h + (v2 == null ? 0 : v2.GetHashCode());
Magic Number,Niecza,VarDeque,C:\repos\sorear_niecza\lib\Utils.cs,VarDeque,The following statement contains a magic number: data = new Variable[8];
Magic Number,Niecza,VarDeque,C:\repos\sorear_niecza\lib\Utils.cs,VarDeque,The following statement contains a magic number: int cap = 8;
Magic Number,Niecza,VarDeque,C:\repos\sorear_niecza\lib\Utils.cs,VarDeque,The following statement contains a magic number: while (cap <= parcel.Length) cap *= 2;
Magic Number,Niecza,VarDeque,C:\repos\sorear_niecza\lib\Utils.cs,VarDeque,The following statement contains a magic number: data = new Variable[8];
Magic Number,Niecza,VarDeque,C:\repos\sorear_niecza\lib\Utils.cs,checkgrow,The following statement contains a magic number: if (count == data.Length) {                  Variable[] ndata = new Variable[data.Length * 2];                  CopyToArray(ndata);                  data = ndata;                  head = 0;              }
Magic Number,Niecza,VarHash,C:\repos\sorear_niecza\lib\Utils.cs,UniversalHash,The following statement contains a magic number: fixed(char *c = str) {                  char *cc = c;                  char *end = cc + str.Length;                  uint accum = 0;                  while (cc < end) {                      // accum <= 2^32-1-65535                      accum += *(cc++);                      // accum <= 2^32-1                      ulong temp = (ulong)accum * string_hash_argument;                      // temp <= (2^32-1) * HASH_ARG_MAX                      // temp <= 4611545284160290815                      accum = (uint)((temp & 0x7FFFFFFF) + (temp >> 31));                      // accum <= floor(temp / 2^31) + (2^31-1)                      // accum <= 4294901760 = 2^32-1-65535                  }                  ulong temp2 = (ulong)accum * (uint)buckets;                  return (int) (temp2 >> 32);              }
Magic Number,Niecza,VarHash,C:\repos\sorear_niecza\lib\Utils.cs,UniversalHash,The following statement contains a magic number: fixed(char *c = str) {                  char *cc = c;                  char *end = cc + str.Length;                  uint accum = 0;                  while (cc < end) {                      // accum <= 2^32-1-65535                      accum += *(cc++);                      // accum <= 2^32-1                      ulong temp = (ulong)accum * string_hash_argument;                      // temp <= (2^32-1) * HASH_ARG_MAX                      // temp <= 4611545284160290815                      accum = (uint)((temp & 0x7FFFFFFF) + (temp >> 31));                      // accum <= floor(temp / 2^31) + (2^31-1)                      // accum <= 4294901760 = 2^32-1-65535                  }                  ulong temp2 = (ulong)accum * (uint)buckets;                  return (int) (temp2 >> 32);              }
Magic Number,Niecza,VarHash,C:\repos\sorear_niecza\lib\Utils.cs,rehash,The following statement contains a magic number: while (heap.Length != (1 << (rank + 2))) rank++;
Magic Number,Niecza,VarHash,C:\repos\sorear_niecza\lib\Utils.cs,rehash,The following statement contains a magic number: init(1 << (rank + 2));
Magic Number,Niecza,VarHash,C:\repos\sorear_niecza\lib\Utils.cs,Remove,The following statement contains a magic number: if (count < (heap.Length >> 2) && heap.Length != INITIAL)                  rehash(-1);
Magic Number,Niecza,Utils,C:\repos\sorear_niecza\lib\Utils.cs,HashToStr,The following statement contains a magic number: char[] buf = new char[hash.Length * 2];
Magic Number,Niecza,Utils,C:\repos\sorear_niecza\lib\Utils.cs,HashToStr,The following statement contains a magic number: for (int i = 0; i < hash.Length; i++) {                  buf[i*2]   = "0123456789abcdef"[hash[i] >> 4];                  buf[i*2+1] = "0123456789abcdef"[hash[i] & 15];              }
Magic Number,Niecza,Utils,C:\repos\sorear_niecza\lib\Utils.cs,HashToStr,The following statement contains a magic number: for (int i = 0; i < hash.Length; i++) {                  buf[i*2]   = "0123456789abcdef"[hash[i] >> 4];                  buf[i*2+1] = "0123456789abcdef"[hash[i] & 15];              }
Magic Number,Niecza,Utils,C:\repos\sorear_niecza\lib\Utils.cs,HashToStr,The following statement contains a magic number: for (int i = 0; i < hash.Length; i++) {                  buf[i*2]   = "0123456789abcdef"[hash[i] >> 4];                  buf[i*2+1] = "0123456789abcdef"[hash[i] & 15];              }
Magic Number,Niecza,Utils,C:\repos\sorear_niecza\lib\Utils.cs,HashToStr,The following statement contains a magic number: for (int i = 0; i < hash.Length; i++) {                  buf[i*2]   = "0123456789abcdef"[hash[i] >> 4];                  buf[i*2+1] = "0123456789abcdef"[hash[i] & 15];              }
Magic Number,Niecza,Utils,C:\repos\sorear_niecza\lib\Utils.cs,HexDump,The following statement contains a magic number: for (int offs = 0; offs < heap.Length; offs += 16) {                  Console.Write("{0:X6}   "' offs);                  int len = heap.Length - offs;                  if (len > 16) len = 16;                  for (int col = 0; col < 16; col++) {                      if (col >= len)                          Console.Write("   ");                      else                          Console.Write("{0:X2} "' heap[offs+col]);                      if (col == 7)                          Console.Write(" ");                  }                  Console.Write("   |");                  for (int col = 0; col < len; col++)                      Console.Write(                          (heap[offs+col] < 32 || heap[offs+col] > 126)                              ? '.' : (char)heap[offs+col]);                  Console.WriteLine("|");              }
Magic Number,Niecza,Utils,C:\repos\sorear_niecza\lib\Utils.cs,HexDump,The following statement contains a magic number: for (int offs = 0; offs < heap.Length; offs += 16) {                  Console.Write("{0:X6}   "' offs);                  int len = heap.Length - offs;                  if (len > 16) len = 16;                  for (int col = 0; col < 16; col++) {                      if (col >= len)                          Console.Write("   ");                      else                          Console.Write("{0:X2} "' heap[offs+col]);                      if (col == 7)                          Console.Write(" ");                  }                  Console.Write("   |");                  for (int col = 0; col < len; col++)                      Console.Write(                          (heap[offs+col] < 32 || heap[offs+col] > 126)                              ? '.' : (char)heap[offs+col]);                  Console.WriteLine("|");              }
Magic Number,Niecza,Utils,C:\repos\sorear_niecza\lib\Utils.cs,HexDump,The following statement contains a magic number: for (int offs = 0; offs < heap.Length; offs += 16) {                  Console.Write("{0:X6}   "' offs);                  int len = heap.Length - offs;                  if (len > 16) len = 16;                  for (int col = 0; col < 16; col++) {                      if (col >= len)                          Console.Write("   ");                      else                          Console.Write("{0:X2} "' heap[offs+col]);                      if (col == 7)                          Console.Write(" ");                  }                  Console.Write("   |");                  for (int col = 0; col < len; col++)                      Console.Write(                          (heap[offs+col] < 32 || heap[offs+col] > 126)                              ? '.' : (char)heap[offs+col]);                  Console.WriteLine("|");              }
Magic Number,Niecza,Utils,C:\repos\sorear_niecza\lib\Utils.cs,HexDump,The following statement contains a magic number: for (int offs = 0; offs < heap.Length; offs += 16) {                  Console.Write("{0:X6}   "' offs);                  int len = heap.Length - offs;                  if (len > 16) len = 16;                  for (int col = 0; col < 16; col++) {                      if (col >= len)                          Console.Write("   ");                      else                          Console.Write("{0:X2} "' heap[offs+col]);                      if (col == 7)                          Console.Write(" ");                  }                  Console.Write("   |");                  for (int col = 0; col < len; col++)                      Console.Write(                          (heap[offs+col] < 32 || heap[offs+col] > 126)                              ? '.' : (char)heap[offs+col]);                  Console.WriteLine("|");              }
Magic Number,Niecza,Utils,C:\repos\sorear_niecza\lib\Utils.cs,HexDump,The following statement contains a magic number: for (int offs = 0; offs < heap.Length; offs += 16) {                  Console.Write("{0:X6}   "' offs);                  int len = heap.Length - offs;                  if (len > 16) len = 16;                  for (int col = 0; col < 16; col++) {                      if (col >= len)                          Console.Write("   ");                      else                          Console.Write("{0:X2} "' heap[offs+col]);                      if (col == 7)                          Console.Write(" ");                  }                  Console.Write("   |");                  for (int col = 0; col < len; col++)                      Console.Write(                          (heap[offs+col] < 32 || heap[offs+col] > 126)                              ? '.' : (char)heap[offs+col]);                  Console.WriteLine("|");              }
Magic Number,Niecza,Utils,C:\repos\sorear_niecza\lib\Utils.cs,HexDump,The following statement contains a magic number: for (int offs = 0; offs < heap.Length; offs += 16) {                  Console.Write("{0:X6}   "' offs);                  int len = heap.Length - offs;                  if (len > 16) len = 16;                  for (int col = 0; col < 16; col++) {                      if (col >= len)                          Console.Write("   ");                      else                          Console.Write("{0:X2} "' heap[offs+col]);                      if (col == 7)                          Console.Write(" ");                  }                  Console.Write("   |");                  for (int col = 0; col < len; col++)                      Console.Write(                          (heap[offs+col] < 32 || heap[offs+col] > 126)                              ? '.' : (char)heap[offs+col]);                  Console.WriteLine("|");              }
Magic Number,Niecza,Utils,C:\repos\sorear_niecza\lib\Utils.cs,HexDump,The following statement contains a magic number: for (int offs = 0; offs < heap.Length; offs += 16) {                  Console.Write("{0:X6}   "' offs);                  int len = heap.Length - offs;                  if (len > 16) len = 16;                  for (int col = 0; col < 16; col++) {                      if (col >= len)                          Console.Write("   ");                      else                          Console.Write("{0:X2} "' heap[offs+col]);                      if (col == 7)                          Console.Write(" ");                  }                  Console.Write("   |");                  for (int col = 0; col < len; col++)                      Console.Write(                          (heap[offs+col] < 32 || heap[offs+col] > 126)                              ? '.' : (char)heap[offs+col]);                  Console.WriteLine("|");              }
Magic Number,Niecza,Utils,C:\repos\sorear_niecza\lib\Utils.cs,Chr,The following statement contains a magic number: if (r >= 0x10000) {                  char[] rs = new char[2];                  rs[0] = (char)(0xD800 + ((r - 0x10000) >> 10));                  rs[1] = (char)(0xDC00 + (r & 0x3FF));                  return new string(rs);              }
Magic Number,Niecza,Utils,C:\repos\sorear_niecza\lib\Utils.cs,Chr,The following statement contains a magic number: if (r >= 0x10000) {                  char[] rs = new char[2];                  rs[0] = (char)(0xD800 + ((r - 0x10000) >> 10));                  rs[1] = (char)(0xDC00 + (r & 0x3FF));                  return new string(rs);              }
Magic Number,Niecza,Complex,C:\repos\sorear_niecza\lib\Utils.cs,sqrt,The following statement contains a magic number: return (this.log() / 2).exp();
Magic Number,Niecza,Complex,C:\repos\sorear_niecza\lib\Utils.cs,Acos,The following statement contains a magic number: return Math.PI / 2 - this.Asin();
Magic Number,Niecza,Complex,C:\repos\sorear_niecza\lib\Utils.cs,Atan,The following statement contains a magic number: return ((1 + this * i).log() - (1 - this * i).log()) / (2 * i);
Magic Number,Niecza,Complex,C:\repos\sorear_niecza\lib\Utils.cs,Acosh,The following statement contains a magic number: return 2 * (((1 + this) / 2).sqrt() + ((-1 + this) / 2).sqrt()).log();
Magic Number,Niecza,Complex,C:\repos\sorear_niecza\lib\Utils.cs,Acosh,The following statement contains a magic number: return 2 * (((1 + this) / 2).sqrt() + ((-1 + this) / 2).sqrt()).log();
Magic Number,Niecza,Complex,C:\repos\sorear_niecza\lib\Utils.cs,Acosh,The following statement contains a magic number: return 2 * (((1 + this) / 2).sqrt() + ((-1 + this) / 2).sqrt()).log();
Magic Number,Niecza,Complex,C:\repos\sorear_niecza\lib\Utils.cs,Atanh,The following statement contains a magic number: return ((1 + this).log() - (1 - this).log()) / 2;
Magic Number,Niecza,RatApproxer,C:\repos\sorear_niecza\lib\Utils.cs,Simplest,The following statement contains a magic number: for (int k = 0; k < 4; k++)                  CandidateSimplest(numl' denl' (k&1)!=0' numh' denh' (k&2)!=0' ref snum' ref sden);
Magic Number,Niecza,RatApproxer,C:\repos\sorear_niecza\lib\Utils.cs,Simplest,The following statement contains a magic number: for (int k = 0; k < 4; k++)                  CandidateSimplest(numl' denl' (k&1)!=0' numh' denh' (k&2)!=0' ref snum' ref sden);
Missing Default,Niecza,Builtins,C:\repos\sorear_niecza\lib\Builtins.cs,HashIterRaw,The following switch statement is missing a default case: switch (mode) {                  case 0:                      lv.Push(s.MakeStr(kv.Key));                      break;                  case 1:                      lv.Push(kv.Value);                      break;                  case 2:                      lv.Push(s.MakeStr(kv.Key));                      lv.Push(kv.Value);                      break;                  case 3:                      P6opaque p = new P6opaque(s.PairMO);                      p.slots[0] = s.MakeStr(kv.Key);                      p.slots[1] = kv.Value;                      lv.Push(p);                      break;              }
Missing Default,Niecza,BatchSource,C:\repos\sorear_niecza\lib\Builtins.cs,TryGet,The following switch statement is missing a default case: switch (TryOne(items' block)) {                      case -1: goto nomore;                      case 0:                          for (int i = pen.Count - 1; i >= 0; i--)                              items.Unshift(pen[i]);                          return false;                      case +1: pen.Add(items.Shift()); break;                  }
Missing Default,Niecza,ZipSource,C:\repos\sorear_niecza\lib\Builtins.cs,TryGet,The following switch statement is missing a default case: switch (TryOne(sources[i]' block)) {                      case -1: return true;                      case  0: return false;                  }
Missing Default,Niecza,CrossSource,C:\repos\sorear_niecza\lib\Builtins.cs,TryGet,The following switch statement is missing a default case: switch (TryOne(iter[i]' block)) {                          case -1: return true;                          case 0:  return false;                          case 1:  break;                      }
Missing Default,Niecza,CrossSource,C:\repos\sorear_niecza\lib\Builtins.cs,TryGet,The following switch statement is missing a default case: switch (TryOne(iter[wheel]' block)) {                      case 0:  return false;                      case +1:                          iter_top[wheel] = iter[wheel].Shift();                          break;                      case -1:                          if (wheel == 0) return true;                          iter[wheel] = new VarDeque(basic[wheel]);                          iter_top[wheel] = basic_top[wheel];                          state--;                          goto again;                  }
Missing Default,Niecza,P6how,C:\repos\sorear_niecza\lib\ObjModel.cs,CollectMMDs,The following switch statement is missing a default case: switch (mi.flags & M_MASK) {                      case M_PROTO:                          ds = new DispatchSet();                          ds.proto = mi.impl;                          ds.name  = mi.short_name;                          ds.defining_class = stable;                          here_protos.Add(ds);                          up_protos[ds.name] = ds;                          break;                      case P6how.M_MULTI:                          if (up_protos.ContainsKey(mi.short_name)                                  && up_protos[mi.short_name] != null) break;                          ds = new DispatchSet();                          ds.name = mi.short_name;                          ds.defining_class = stable;                          here_protos.Add(ds);                          up_protos[ds.name] = ds;                          break;                      case P6how.M_ONLY:                          up_protos[mi.short_name] = null;                          break;                  }
