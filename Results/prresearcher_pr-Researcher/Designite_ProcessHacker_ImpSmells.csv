Implementation smell,Namespace,Class,File,Method,Description
Long Method,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,menuProcess_Popup,The method has 194 lines of code.
Long Method,ProcessHacker,Program,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\Program.cs,Main,The method has 121 lines of code.
Long Method,ProcessHacker,Program,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\Program.cs,ProcessCommandLine,The method has 131 lines of code.
Long Method,ProcessHacker,Program,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\Program.cs,GetDiagnosticInformation,The method has 109 lines of code.
Long Method,ProcessHacker,Assistant,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\Assistant.cs,Main,The method has 143 lines of code.
Long Method,ProcessHacker,Dump,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\Dump.cs,DumpProcess,The method has 161 lines of code.
Long Method,ProcessHacker,ProcessToolTipProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ProcessTree\ProcessToolTipProvider.cs,GetToolTip,The method has 128 lines of code.
Long Method,ProcessHacker,ProcessTreeModel,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ProcessTree\ProcessTreeModel.cs,GetChildren,The method has 105 lines of code.
Long Method,ProcessHacker,ExtendedCmd,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\ExtendedCmd.cs,Run,The method has 222 lines of code.
Long Method,ProcessHacker,ProcessWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\ProcessWindow.cs,UpdateProcessProperties,The method has 128 lines of code.
Long Method,ProcessHacker,PEWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\PEWindow.cs,Read,The method has 189 lines of code.
Long Method,ProcessHacker,ProcessSystemProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ProcessSystemProvider.cs,QueryProcessStage1,The method has 108 lines of code.
Long Method,ProcessHacker,ProcessSystemProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ProcessSystemProvider.cs,Update,The method has 305 lines of code.
Long Method,ProcessHacker,ThreadProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ThreadProvider.cs,Update,The method has 137 lines of code.
Long Method,ProcessHacker,Save,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\Save.cs,GetProcessDetailsText,The method has 127 lines of code.
Long Method,ProcessHacker,OptionsWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\OptionsWindow.cs,LoadSettings,The method has 115 lines of code.
Long Method,ProcessHacker,OptionsWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\OptionsWindow.cs,SaveSettings,The method has 102 lines of code.
Long Method,ProcessHacker.Components,ModuleList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ModuleList.cs,unloadMenuItem_Click,The method has 101 lines of code.
Long Method,ProcessHacker.Components,HandleList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\HandleList.cs,ShowHandleProperties,The method has 144 lines of code.
Long Method,ProcessHacker.Components,TaskDialog,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\TaskDialog\TaskDialog.cs,PrivateShow,The method has 112 lines of code.
Long Method,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,menuThread_Popup,The method has 110 lines of code.
Long Method,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,analyzeWaitMenuItem_Click,The method has 148 lines of code.
Long Method,ProcessHacker.Components,TokenProperties,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\TokenProperties.cs,TokenProperties,The method has 134 lines of code.
Long Method,ProcessHacker.Structs,StructDef,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Structs\StructDef.cs,ReadOnce,The method has 133 lines of code.
Long Method,ProcessHacker.Structs,StructParser,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Structs\StructParser.cs,ParseStructDef,The method has 140 lines of code.
Complex Method,Be.Windows.Forms,DynamicFileByteProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\Be.Windows.Forms.HexBox\DynamicFileByteProvider.cs,WriteByte,Cyclomatic complexity of the method is 12
Complex Method,Be.Windows.Forms,DynamicFileByteProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\Be.Windows.Forms.HexBox\DynamicFileByteProvider.cs,InsertBytes,Cyclomatic complexity of the method is 8
Complex Method,Be.Windows.Forms,DynamicFileByteProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\Be.Windows.Forms.HexBox\DynamicFileByteProvider.cs,ApplyChanges,Cyclomatic complexity of the method is 8
Complex Method,Be.Windows.Forms,HexBox,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\Be.Windows.Forms.HexBox\HexBox.cs,_vScrollBar_Scroll,Cyclomatic complexity of the method is 33
Complex Method,Be.Windows.Forms,HexBox,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\Be.Windows.Forms.HexBox\HexBox.cs,OnPaintBackground,Cyclomatic complexity of the method is 8
Complex Method,Be.Windows.Forms,HexBox,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\Be.Windows.Forms.HexBox\HexBox.cs,PaintCurrentBytesSign,Cyclomatic complexity of the method is 18
Complex Method,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,verifyFileSignatureMenuItem_Click,Cyclomatic complexity of the method is 26
Complex Method,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,menuNetwork_Popup,Cyclomatic complexity of the method is 13
Complex Method,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,closeNetworkMenuItem_Click,Cyclomatic complexity of the method is 8
Complex Method,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,menuIcon_Popup,Cyclomatic complexity of the method is 11
Complex Method,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,menuProcess_Popup,Cyclomatic complexity of the method is 60
Complex Method,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,restartProcessMenuItem_Click,Cyclomatic complexity of the method is 8
Complex Method,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,menuService_Popup,Cyclomatic complexity of the method is 11
Complex Method,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,GetUacShieldIcon,Cyclomatic complexity of the method is 9
Complex Method,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,LoadOtherSettings,Cyclomatic complexity of the method is 10
Complex Method,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,WndProc,Cyclomatic complexity of the method is 26
Complex Method,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,LoadFixOSSpecific,Cyclomatic complexity of the method is 8
Complex Method,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,LoadFixNProcessHacker,Cyclomatic complexity of the method is 8
Complex Method,ProcessHacker,Program,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\Program.cs,Main,Cyclomatic complexity of the method is 22
Complex Method,ProcessHacker,Program,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\Program.cs,LoadSettings,Cyclomatic complexity of the method is 9
Complex Method,ProcessHacker,Program,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\Program.cs,ProcessCommandLine,Cyclomatic complexity of the method is 35
Complex Method,ProcessHacker,Program,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\Program.cs,GetDiagnosticInformation,Cyclomatic complexity of the method is 12
Complex Method,ProcessHacker,DumpHackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\DumpHackerWindow.cs,LoadProcess,Cyclomatic complexity of the method is 31
Complex Method,ProcessHacker,DumpProcessWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\DumpProcessWindow.cs,LoadProperties,Cyclomatic complexity of the method is 17
Complex Method,ProcessHacker,DumpProcessWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\DumpProcessWindow.cs,LoadToken,Cyclomatic complexity of the method is 8
Complex Method,ProcessHacker,HandleStatisticsWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HandleStatisticsWindow.cs,HandleStatisticsWindow,Cyclomatic complexity of the method is 9
Complex Method,ProcessHacker,IPInfoWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\IPInfoWindow.cs,Ping,Cyclomatic complexity of the method is 10
Complex Method,ProcessHacker,IPInfoWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\IPInfoWindow.cs,Whois,Cyclomatic complexity of the method is 9
Complex Method,ProcessHacker,ProtectProcessWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\ProtectProcessWindow.cs,buttonOK_Click,Cyclomatic complexity of the method is 11
Complex Method,ProcessHacker,VirusTotalUploaderWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\VirusTotalUploaderWindow.cs,uploadTask_RunTask,Cyclomatic complexity of the method is 13
Complex Method,ProcessHacker,Assistant,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\Assistant.cs,Main,Cyclomatic complexity of the method is 30
Complex Method,ProcessHacker,Dump,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\Dump.cs,DumpProcesses,Cyclomatic complexity of the method is 13
Complex Method,ProcessHacker,Dump,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\Dump.cs,DumpProcess,Cyclomatic complexity of the method is 47
Complex Method,ProcessHacker,Dump,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\Dump.cs,DumpProcessModules,Cyclomatic complexity of the method is 16
Complex Method,ProcessHacker,Dump,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\Dump.cs,DumpProcessToken,Cyclomatic complexity of the method is 17
Complex Method,ProcessHacker,Dump,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\Dump.cs,DumpProcessHandles,Cyclomatic complexity of the method is 8
Complex Method,ProcessHacker,Dump,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\Dump.cs,DumpServices,Cyclomatic complexity of the method is 13
Complex Method,ProcessHacker,UpdaterDownloadWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\UpdaterDownloadWindow.cs,webClient_DownloadFileCompleted,Cyclomatic complexity of the method is 9
Complex Method,ProcessHacker,Provider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\Provider.cs,Run,Cyclomatic complexity of the method is 8
Complex Method,ProcessHacker,ProviderThread,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ProviderThread.cs,Update,Cyclomatic complexity of the method is 12
Complex Method,ProcessHacker,CpuUsageIcon,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\UI\Icons\CpuUsageIcon.cs,ProviderUpdated,Cyclomatic complexity of the method is 8
Complex Method,ProcessHacker,ProcessToolTipProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ProcessTree\ProcessToolTipProvider.cs,GetToolTip,Cyclomatic complexity of the method is 35
Complex Method,ProcessHacker,ExtendedCmd,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\ExtendedCmd.cs,Run,Cyclomatic complexity of the method is 103
Complex Method,ProcessHacker,HiddenProcessesWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HiddenProcessesWindow.cs,ScanCsrHandles,Cyclomatic complexity of the method is 11
Complex Method,ProcessHacker,EditDEPWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\EditDEPWindow.cs,SetDepStatusNoKph,Cyclomatic complexity of the method is 10
Complex Method,ProcessHacker,ProcessWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\ProcessWindow.cs,FixTabs,Cyclomatic complexity of the method is 14
Complex Method,ProcessHacker,ProcessWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\ProcessWindow.cs,ProcessWindow_FormClosing,Cyclomatic complexity of the method is 10
Complex Method,ProcessHacker,ProcessWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\ProcessWindow.cs,UpdateProcessProperties,Cyclomatic complexity of the method is 29
Complex Method,ProcessHacker,ProcessWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\ProcessWindow.cs,InitializeSubControls,Cyclomatic complexity of the method is 14
Complex Method,ProcessHacker,ProcessWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\ProcessWindow.cs,UpdateDepStatus,Cyclomatic complexity of the method is 9
Complex Method,ProcessHacker,ProcessWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\ProcessWindow.cs,tabControl_SelectedIndexChanged,Cyclomatic complexity of the method is 15
Complex Method,ProcessHacker,TerminatorWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\TerminatorWindow.cs,TJ1,Cyclomatic complexity of the method is 11
Complex Method,ProcessHacker,HandleFilterWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HandleFilterWindow.cs,closeMenuItem_Click,Cyclomatic complexity of the method is 8
Complex Method,ProcessHacker,PEWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\PEWindow.cs,Read,Cyclomatic complexity of the method is 9
Complex Method,ProcessHacker,RunWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\RunWindow.cs,RunWindow,Cyclomatic complexity of the method is 8
Complex Method,ProcessHacker,RunWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\RunWindow.cs,buttonOK_Click,Cyclomatic complexity of the method is 14
Complex Method,ProcessHacker,NetworkProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\NetworkProvider.cs,Update,Cyclomatic complexity of the method is 19
Complex Method,ProcessHacker,ProcessSystemProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ProcessSystemProvider.cs,QueryProcessStage1,Cyclomatic complexity of the method is 30
Complex Method,ProcessHacker,ProcessSystemProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ProcessSystemProvider.cs,QueryProcessStage2,Cyclomatic complexity of the method is 17
Complex Method,ProcessHacker,ProcessSystemProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ProcessSystemProvider.cs,GetFileName,Cyclomatic complexity of the method is 15
Complex Method,ProcessHacker,ProcessSystemProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ProcessSystemProvider.cs,Update,Cyclomatic complexity of the method is 59
Complex Method,ProcessHacker,MemoryProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\MemoryProvider.cs,Update,Cyclomatic complexity of the method is 11
Complex Method,ProcessHacker,ModuleProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ModuleProvider.cs,Update,Cyclomatic complexity of the method is 14
Complex Method,ProcessHacker,HandleProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\HandleProvider.cs,Update,Cyclomatic complexity of the method is 10
Complex Method,ProcessHacker,ServiceProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ServiceProvider.cs,Update,Cyclomatic complexity of the method is 21
Complex Method,ProcessHacker,ThreadProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ThreadProvider.cs,Update,Cyclomatic complexity of the method is 31
Complex Method,ProcessHacker,SearchWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\SearchWindow.cs,SearchWindow,Cyclomatic complexity of the method is 18
Complex Method,ProcessHacker,SearchWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\SearchWindow.cs,buttonOK_Click,Cyclomatic complexity of the method is 9
Complex Method,ProcessHacker,ThreadWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\ThreadWindow.cs,WalkStackCallback,Cyclomatic complexity of the method is 10
Complex Method,ProcessHacker,Save,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\Save.cs,SaveToFile,Cyclomatic complexity of the method is 11
Complex Method,ProcessHacker,Save,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\Save.cs,GetProcessTreeText,Cyclomatic complexity of the method is 18
Complex Method,ProcessHacker,Save,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\Save.cs,GetProcessDetailsText,Cyclomatic complexity of the method is 29
Complex Method,ProcessHacker,OptionsWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\OptionsWindow.cs,LoadStage1,Cyclomatic complexity of the method is 13
Complex Method,ProcessHacker,OptionsWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\OptionsWindow.cs,LoadSettings,Cyclomatic complexity of the method is 30
Complex Method,ProcessHacker,OptionsWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\OptionsWindow.cs,SaveSettings,Cyclomatic complexity of the method is 27
Complex Method,ProcessHacker,WaitChainWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\WaitChainWindow.cs,DisplayThreadData,Cyclomatic complexity of the method is 8
Complex Method,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,CalculateButtonAutoSize,Cyclomatic complexity of the method is 16
Complex Method,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,CalculateButtonTextAndImageLayout,Cyclomatic complexity of the method is 23
Complex Method,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,OverlayObjectRect,Cyclomatic complexity of the method is 40
Complex Method,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,LayoutTextAboveOrBelowImage,Cyclomatic complexity of the method is 9
Complex Method,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,GetHorizontalAlignment,Cyclomatic complexity of the method is 9
Complex Method,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,GetVerticalAlignment,Cyclomatic complexity of the method is 9
Complex Method,ProcessHacker.Common,PhUtils,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Common\PhUtils.cs,FormatPriorityClass,Cyclomatic complexity of the method is 8
Complex Method,ProcessHacker.Common,PhUtils,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Common\PhUtils.cs,GetIntegrity,Cyclomatic complexity of the method is 9
Complex Method,ProcessHacker.Common,PhUtils,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Common\PhUtils.cs,OpenKeyInRegedit,Cyclomatic complexity of the method is 9
Complex Method,ProcessHacker.Components,DotNetCounters,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\DotNetCounters.cs,Initialize,Cyclomatic complexity of the method is 9
Complex Method,ProcessHacker.Components,ExtendedListView,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ExtendedListView.cs,WndProc,Cyclomatic complexity of the method is 9
Complex Method,ProcessHacker.Components,JobProperties,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\JobProperties.cs,JobProperties,Cyclomatic complexity of the method is 28
Complex Method,ProcessHacker.Components,MemoryList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\MemoryList.cs,GetProtectStr,Cyclomatic complexity of the method is 13
Complex Method,ProcessHacker.Components,MemoryList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\MemoryList.cs,dumpMemoryMenuItem_Click,Cyclomatic complexity of the method is 10
Complex Method,ProcessHacker.Components,MemoryList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\MemoryList.cs,readWriteAddressMemoryMenuItem_Click,Cyclomatic complexity of the method is 11
Complex Method,ProcessHacker.Components,ModuleList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ModuleList.cs,unloadMenuItem_Click,Cyclomatic complexity of the method is 19
Complex Method,ProcessHacker.Components,Plotter,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\Plotter.cs,Draw,Cyclomatic complexity of the method is 13
Complex Method,ProcessHacker.Components,Plotter,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\Plotter.cs,FixLongData,Cyclomatic complexity of the method is 12
Complex Method,ProcessHacker.Components,ServiceProperties,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ServiceProperties.cs,UpdateInformation,Cyclomatic complexity of the method is 20
Complex Method,ProcessHacker.Components,ServiceProperties,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ServiceProperties.cs,buttonApply_Click,Cyclomatic complexity of the method is 19
Complex Method,ProcessHacker.Components,TaskDialog,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\TaskDialog\TaskDialog.cs,PrivateShow,Cyclomatic complexity of the method is 16
Complex Method,ProcessHacker.Components,TaskDialog,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\TaskDialog\TaskDialog.cs,PrivateCallback,Cyclomatic complexity of the method is 17
Complex Method,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,listThreads_SelectedIndexChanged,Cyclomatic complexity of the method is 9
Complex Method,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,menuThread_Popup,Cyclomatic complexity of the method is 46
Complex Method,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,inspectThreadMenuItem_Click,Cyclomatic complexity of the method is 8
Complex Method,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,terminateThreadMenuItem_Click,Cyclomatic complexity of the method is 13
Complex Method,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,suspendThreadMenuItem_Click,Cyclomatic complexity of the method is 9
Complex Method,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,resumeThreadMenuItem_Click,Cyclomatic complexity of the method is 9
Complex Method,ProcessHacker.Components,TokenProperties,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\TokenProperties.cs,TokenProperties,Cyclomatic complexity of the method is 27
Complex Method,TaskbarLib,JumpListManager,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\TaskbarLib\JumpLists\JumpListManager.cs,Refresh,Cyclomatic complexity of the method is 8
Complex Method,TaskbarLib,JumpListManager,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\TaskbarLib\JumpLists\JumpListManager.cs,BeginList,Cyclomatic complexity of the method is 8
Complex Method,ProcessHacker.UI.Actions,ProcessActions,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\UI\Actions\ProcessActions.cs,Prompt,Cyclomatic complexity of the method is 18
Complex Method,ProcessHacker.UI,GenericViewMenu,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\UI\GenericViewMenu.cs,ListViewCopy,Cyclomatic complexity of the method is 10
Complex Method,ProcessHacker.UI,GenericViewMenu,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\UI\GenericViewMenu.cs,TreeViewAdvCopy,Cyclomatic complexity of the method is 14
Complex Method,ProcessHacker.UI,ColumnSettings,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\UI\ColumnSettings.cs,LoadSettings,Cyclomatic complexity of the method is 9
Complex Method,ProcessHacker.FormHelper,HandleFilter,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\UI\Async\HandleFilter.cs,DoFilter,Cyclomatic complexity of the method is 15
Complex Method,Debugger.Interop,MTA2STA,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\SharpDevelop\MTA2STA.cs,TriggerInvoke,Cyclomatic complexity of the method is 9
Complex Method,ProcessHacker.Structs,StructDef,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Structs\StructDef.cs,ReadOnce,Cyclomatic complexity of the method is 76
Complex Method,ProcessHacker.Structs,StructParser,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Structs\StructParser.cs,Preprocess,Cyclomatic complexity of the method is 10
Complex Method,ProcessHacker.Structs,StructParser,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Structs\StructParser.cs,Parse,Cyclomatic complexity of the method is 11
Complex Method,ProcessHacker.Structs,StructParser,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Structs\StructParser.cs,ParseTypeDef,Cyclomatic complexity of the method is 8
Complex Method,ProcessHacker.Structs,StructParser,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Structs\StructParser.cs,ParseStructDef,Cyclomatic complexity of the method is 31
Complex Method,ProcessHacker.Structs,StructParser,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Structs\StructParser.cs,EatWhitespace,Cyclomatic complexity of the method is 9
Complex Method,ProcessHacker.Structs,StructParser,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Structs\StructParser.cs,EatQuotedString,Cyclomatic complexity of the method is 11
Long Parameter List,Be.Windows.Forms,HexBox,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\Be.Windows.Forms.HexBox\HexBox.cs,PaintHexStringSelected,The method has 5 parameters.
Long Parameter List,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,menuIcon_Popup,The method has 15 parameters.
Long Parameter List,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,createDumpFileProcessMenuItem_Click,The method has 5 parameters.
Long Parameter List,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,CreateShutdownMenuItems,The method has 16 parameters.
Long Parameter List,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,UpdateSessions,The method has 8 parameters.
Long Parameter List,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,LoadControls,The method has 8 parameters.
Long Parameter List,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,Painting,The method has 5 parameters.
Long Parameter List,ProcessHacker,Program,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\Program.cs,StartProgramAdmin,The method has 5 parameters.
Long Parameter List,ProcessHacker,HeapsWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HeapsWindow.cs,HeapsWindow,The method has 6 parameters.
Long Parameter List,ProcessHacker,Dump,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\Dump.cs,DumpProcess,The method has 5 parameters.
Long Parameter List,ProcessHacker,Dump,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\Dump.cs,DumpProcessModules,The method has 5 parameters.
Long Parameter List,ProcessHacker,HiddenProcessesWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HiddenProcessesWindow.cs,AddProcessItem,The method has 6 parameters.
Long Parameter List,ProcessHacker,HiddenProcessesWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HiddenProcessesWindow.cs,AddErrorItem,The method has 5 parameters.
Long Parameter List,ProcessHacker,MemoryEditor,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\MemoryEditor.cs,ReadWriteMemory,The method has 5 parameters.
Long Parameter List,ProcessHacker,MemoryEditor,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\MemoryEditor.cs,ReadWriteMemory,The method has 6 parameters.
Long Parameter List,ProcessHacker,ResultsWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\ResultsWindow.cs,buttonFilter_Click,The method has 12 parameters.
Long Parameter List,ProcessHacker,OptionsWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\OptionsWindow.cs,LoadStage1,The method has 12 parameters.
Long Parameter List,ProcessHacker,WaitChainNativeMethods,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\WaitChainWindow.cs,GetThreadWaitChain,The method has 5 parameters.
Long Parameter List,ProcessHacker,WaitChainNativeMethods,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\WaitChainWindow.cs,RealGetThreadWaitChain,The method has 7 parameters.
Long Parameter List,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,LayoutTextBeforeOrAfterImage,The method has 6 parameters.
Long Parameter List,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,LayoutTextAboveOrBelowImage,The method has 6 parameters.
Long Parameter List,ProcessHacker.Common,PhUtils,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Common\PhUtils.cs,FormatFileInfo,The method has 5 parameters.
Long Parameter List,ProcessHacker.Components,MemoryList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\MemoryList.cs,readWriteAddressMemoryMenuItem_Click,The method has 5 parameters.
Long Parameter List,ProcessHacker.Components,HandleList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\HandleList.cs,ShowHandleProperties,The method has 7 parameters.
Long Parameter List,ProcessHacker.Components,TaskDialog,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\TaskDialog\TaskDialog.cs,PrivateCallback,The method has 5 parameters.
Long Parameter List,ProcessHacker.Components,TokenProperties,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\TokenProperties.cs,DumpSetTextToken,The method has 7 parameters.
Long Parameter List,ProcessHacker.Components,TokenProperties,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\TokenProperties.cs,DumpSetTextAdvanced,The method has 6 parameters.
Long Parameter List,ProcessHackerRestartRecovery,AppRestartRecoveryNativeMethods,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\RestartRecoveryLib\RestartRecoveryInterop.cs,GetApplicationRecoveryCallback,The method has 5 parameters.
Long Parameter List,ProcessHacker.UI.Actions,SessionActions,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\UI\Actions\SessionActions.cs,ElevateIfRequired,The method has 7 parameters.
Long Parameter List,ProcessHacker.UI.Actions,ServiceActions,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\UI\Actions\ServiceActions.cs,Prompt,The method has 5 parameters.
Long Parameter List,ProcessHacker.UI.Actions,ServiceActions,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\UI\Actions\ServiceActions.cs,ElevateIfRequired,The method has 7 parameters.
Long Parameter List,ProcessHacker.UI.Actions,ProcessActions,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\UI\Actions\ProcessActions.cs,Prompt,The method has 6 parameters.
Long Parameter List,ProcessHacker.UI.Actions,ProcessActions,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\UI\Actions\ProcessActions.cs,PromptForElevation,The method has 9 parameters.
Long Parameter List,ProcessHacker.UI.Actions,ProcessActions,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\UI\Actions\ProcessActions.cs,ElevateIfRequired,The method has 5 parameters.
Long Parameter List,ProcessHacker.Native.Symbols,SymbolProviderExtensions,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Symbols\SymbolProviderExtensions.cs,ShowWarning,The method has 5 parameters.
Long Identifier,TaskbarLib,JumpListManager,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\TaskbarLib\JumpLists\JumpListManager.cs,Refresh,The length of the parameter appendKnownCategoryFrequentResult is 33.
Long Identifier,TaskbarLib,JumpListManager,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\TaskbarLib\JumpLists\JumpListManager.cs,Refresh,The length of the parameter appendKnownCategoryRecentResult is 31.
Long Identifier,TaskbarLib,Windows7Taskbar,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\TaskbarLib\Windows7Taskbar.cs,SetPeekBitmap,The length of the parameter dwmSetIconicLivePreviewBitmapResult is 35.
Long Statement,Be.Windows.Forms,DynamicFileByteProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\Be.Windows.Forms.HexBox\DynamicFileByteProvider.cs,WriteByte,The length of the statement  "			suffixBlock = new FileDataBlock (fileBlock.FileOffset + index - blockOffset + 1' fileBlock.Length - (index - blockOffset + 1)); " is 127.
Long Statement,Be.Windows.Forms,DynamicFileByteProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\Be.Windows.Forms.HexBox\DynamicFileByteProvider.cs,InsertBytes,The length of the statement  "		// If the insertion point is at the start of a file block' and the previous block is a memory block' append it to that block. " is 125.
Long Statement,Be.Windows.Forms,HexBox,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\Be.Windows.Forms.HexBox\HexBox.cs,PaintHexAndStringView,The length of the statement  "	bool isStringKeyInterpreterActive = _keyInterpreter != null && _keyInterpreter.GetType () == typeof(StringKeyInterpreter); " is 122.
Long Statement,Be.Windows.Forms,HexBox,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\Be.Windows.Forms.HexBox\HexBox.cs,PaintCurrentBytesSign,The length of the statement  "					Rectangle singleLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(endSelPointF.X - startSelPointF.X + _charSize.Width)' (int)_charSize.Height); " is 167.
Long Statement,Be.Windows.Forms,HexBox,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\Be.Windows.Forms.HexBox\HexBox.cs,PaintCurrentBytesSign,The length of the statement  "					Rectangle firstLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(_recStringView.X + lineWidth - startSelPointF.X + _charSize.Width)' (int)_charSize.Height); " is 180.
Long Statement,Be.Windows.Forms,HexBox,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\Be.Windows.Forms.HexBox\HexBox.cs,PaintCurrentBytesSign,The length of the statement  "						Rectangle betweenLines = new Rectangle (_recStringView.X' (int)(startSelPointF.Y + _charSize.Height)' (int)(_recStringView.Width)' (int)(_charSize.Height * (multiLine - 1))); " is 174.
Long Statement,Be.Windows.Forms,HexBox,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\Be.Windows.Forms.HexBox\HexBox.cs,PaintCurrentBytesSign,The length of the statement  "					Rectangle lastLine = new Rectangle (_recStringView.X' (int)endSelPointF.Y' (int)(endSelPointF.X - _recStringView.X + _charSize.Width)' (int)_charSize.Height); " is 158.
Long Statement,Be.Windows.Forms,HexBox,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\Be.Windows.Forms.HexBox\HexBox.cs,PaintCurrentBytesSign,The length of the statement  "					Rectangle singleLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(endSelPointF.X - startSelPointF.X + _charSize.Width * 2)' (int)_charSize.Height); " is 171.
Long Statement,Be.Windows.Forms,HexBox,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\Be.Windows.Forms.HexBox\HexBox.cs,PaintCurrentBytesSign,The length of the statement  "					Rectangle firstLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(_recHex.X + lineWidth - startSelPointF.X + _charSize.Width * 2)' (int)_charSize.Height); " is 177.
Long Statement,Be.Windows.Forms,HexBox,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\Be.Windows.Forms.HexBox\HexBox.cs,PaintCurrentBytesSign,The length of the statement  "						Rectangle betweenLines = new Rectangle (_recHex.X' (int)(startSelPointF.Y + _charSize.Height)' (int)(lineWidth + _charSize.Width * 2)' (int)(_charSize.Height * (multiLine - 1))); " is 178.
Long Statement,Be.Windows.Forms,HexBox,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\Be.Windows.Forms.HexBox\HexBox.cs,PaintCurrentBytesSign,The length of the statement  "					Rectangle lastLine = new Rectangle (_recHex.X' (int)endSelPointF.Y' (int)(endSelPointF.X - _recHex.X + _charSize.Width * 2)' (int)_charSize.Height); " is 148.
Long Statement,Be.Windows.Forms,HexBox,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\Be.Windows.Forms.HexBox\HexBox.cs,UpdateRectanglePositioning,The length of the statement  "		_recLineInfo = new Rectangle (_recContent.X + marginLeft' _recContent.Y' (int)(_charSize.Width * 10)' _recContent.Height); " is 122.
Long Statement,Be.Windows.Forms,HexBox,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\Be.Windows.Forms.HexBox\HexBox.cs,UpdateRectanglePositioning,The length of the statement  "	_recHex = new Rectangle (_recLineInfo.X + _recLineInfo.Width' _recLineInfo.Y' _recContent.Width - _recLineInfo.Width' _recContent.Height); " is 138.
Long Statement,Be.Windows.Forms,HexBox,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\Be.Windows.Forms.HexBox\HexBox.cs,UpdateRectanglePositioning,The length of the statement  "		_recStringView = new Rectangle (_recHex.X + _recHex.Width' _recHex.Y' (int)(_charSize.Width * _iHexMaxHBytes)' _recHex.Height); " is 127.
Long Statement,Be.Windows.Forms.Design,HexFontEditor,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\Be.Windows.Forms.HexBox\Design\HexFontEditor.cs,EditValue,The length of the statement  "		IWindowsFormsEditorService service1 = (IWindowsFormsEditorService)provider.GetService (typeof(IWindowsFormsEditorService)); " is 123.
Long Statement,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,menuNetwork_Popup,The length of the statement  "				if (item.SubItems [6].Text != "Listening" && item.SubItems [6].Text != "CloseWait" && item.SubItems [6].Text != "TimeWait") { " is 125.
Long Statement,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,closeNetworkMenuItem_Click,The length of the statement  "				if (MessageBox.Show ("Could not close the TCP connection. " + "Make sure Process Hacker is running with administrative privileges."' "Process Hacker"' MessageBoxButtons.OKCancel' MessageBoxIcon.Error) == DialogResult.Cancel) " is 224.
Long Statement,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,menuIcon_Popup,The length of the statement  "			processes.RemoveRange (Settings.Instance.IconMenuProcessCount' processes.Count - Settings.Instance.IconMenuProcessCount); " is 121.
Long Statement,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,menuIcon_Popup,The length of the statement  "					ProcessWindow pForm = Program.GetProcessWindow (Program.ProcessProvider.Dictionary [item.Pid]' new Program.PWindowInvokeAction (delegate (ProcessWindow f) { " is 156.
Long Statement,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,menuProcess_Popup,The length of the statement  "				if (OSVersion.IsBelowOrEqual (WindowsVersion.XP) && Program.ProcessProvider.Dictionary [processSelectedPid].SessionId != Program.CurrentSessionId) " is 146.
Long Statement,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,menuProcess_Popup,The length of the statement  "				if (treeProcesses.SelectedTreeNodes [0].IsLeaf && (treeProcesses.Tree.Model as ProcessTreeModel).GetSortColumn () == "") " is 120.
Long Statement,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,restartProcessMenuItem_Click,The length of the statement  "	if (PhUtils.ShowConfirmMessage ("restart"' "the selected process"' "The process will be restarted with the same command line and " + "working directory' but if it is running under a different user it " + "will be restarted under the current user."' true)) { " is 257.
Long Statement,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,restartProcessMenuItem_Click,The length of the statement  "			using (var phandle = new ProcessHandle (processSelectedPid' Program.MinProcessQueryRights | Program.MinProcessReadMemoryRights)) { " is 130.
Long Statement,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,restartProcessMenuItem_Click,The length of the statement  "					ProcessHandle.CreateWin32 (null' cmdLine' false' 0' EnvironmentBlock.Zero' currentDirectory' new StartupInfo ()' out cid' out thandle).Dispose (); " is 146.
Long Statement,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,virtualizationProcessMenuItem_Click,The length of the statement  "	if (!PhUtils.ShowConfirmMessage ("set"' "virtualization for the process"' "Enabling or disabling virtualization for a process may " + "alter its functionality and produce undesirable effects."' false)) " is 201.
Long Statement,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,createDumpFileProcessMenuItem_Click,The length of the statement  "	sfd.FileName = Program.ProcessProvider.Dictionary [processSelectedPid].Name + "_" + DateTime.Now.ToString ("yyMMdd") + ".dmp"; " is 126.
Long Statement,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,createDumpFileProcessMenuItem_Click,The length of the statement  "					using (var phandle = new ProcessHandle (processSelectedPid' ProcessAccess.DupHandle | ProcessAccess.QueryInformation | ProcessAccess.SuspendResume | ProcessAccess.VmRead)) " is 171.
Long Statement,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,terminatorProcessMenuItem_Click,The length of the statement  "	w.Text = "Terminator - " + Program.ProcessProvider.Dictionary [processSelectedPid].Name + " (PID " + processSelectedPid.ToString () + ")"; " is 138.
Long Statement,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,detachFromDebuggerProcessMenuItem_Click,The length of the statement  "		using (var phandle = new ProcessHandle (processSelectedPid' ProcessAccess.QueryInformation | ProcessAccess.SuspendResume)) { " is 124.
Long Statement,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,injectDllProcessMenuItem_Click,The length of the statement  "			using (var phandle = new ProcessHandle (processSelectedPid' ProcessAccess.CreateThread | ProcessAccess.VmOperation | ProcessAccess.VmWrite)) { " is 142.
Long Statement,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,virusTotalMenuItem_Click,The length of the statement  "		VirusTotalUploaderWindow vt = new VirusTotalUploaderWindow (treeProcesses.SelectedNodes [0].Name' treeProcesses.SelectedNodes [0].FileName); " is 140.
Long Statement,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,processP_Updated,The length of the statement  "						if (string.Equals (process.Name' "explorer.exe"' StringComparison.OrdinalIgnoreCase) && process.ProcessItem.Username == Program.CurrentUsername) { " is 146.
Long Statement,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,processP_DictionaryAdded,The length of the statement  "		this.GetFirstIcon ().ShowBalloonTip (2000' "New Process"' "The process " + item.Name + " (" + item.Pid.ToString () + ") was started" + ((parentText != "") ? " by " + parent.Name + " (" + parent.Pid.ToString () + ")" : "") + "."' ToolTipIcon.Info); " is 247.
Long Statement,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,processP_DictionaryRemoved,The length of the statement  "		this.GetFirstIcon ().ShowBalloonTip (2000' "Terminated Process"' "The process " + item.Name + " (" + item.Pid.ToString () + ") was terminated."' ToolTipIcon.Info); " is 163.
Long Statement,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,serviceP_DictionaryAdded,The length of the statement  "	this.QueueMessage ("New Service: " + item.Status.ServiceName + " (" + item.Status.ServiceStatusProcess.ServiceType.ToString () + ")" + ((item.Status.DisplayName != "") ? " (" + item.Status.DisplayName + ")" : "")); " is 214.
Long Statement,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,serviceP_DictionaryAdded,The length of the statement  "		this.GetFirstIcon ().ShowBalloonTip (2000' "New Service"' "The service " + item.Status.ServiceName + " (" + item.Status.DisplayName + ") has been created."' ToolTipIcon.Info); " is 175.
Long Statement,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,serviceP_DictionaryModified,The length of the statement  "	if ((oldState == ServiceState.Paused || oldState == ServiceState.Stopped || oldState == ServiceState.StartPending) && newState == ServiceState.Running) { " is 153.
Long Statement,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,serviceP_DictionaryModified,The length of the statement  "		this.QueueMessage ("Service Started: " + newItem.Status.ServiceName + " (" + newItem.Status.ServiceStatusProcess.ServiceType.ToString () + ")" + ((newItem.Status.DisplayName != "") ? " (" + newItem.Status.DisplayName + ")" : "")); " is 230.
Long Statement,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,serviceP_DictionaryModified,The length of the statement  "			this.GetFirstIcon ().ShowBalloonTip (2000' "Service Started"' "The service " + newItem.Status.ServiceName + " (" + newItem.Status.DisplayName + ") has been started."' ToolTipIcon.Info); " is 185.
Long Statement,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,serviceP_DictionaryModified,The length of the statement  "		this.QueueMessage ("Service Paused: " + newItem.Status.ServiceName + " (" + newItem.Status.ServiceStatusProcess.ServiceType.ToString () + ")" + ((newItem.Status.DisplayName != "") ? " (" + newItem.Status.DisplayName + ")" : "")); " is 229.
Long Statement,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,serviceP_DictionaryModified,The length of the statement  "		this.QueueMessage ("Service Stopped: " + newItem.Status.ServiceName + " (" + newItem.Status.ServiceStatusProcess.ServiceType.ToString () + ")" + ((newItem.Status.DisplayName != "") ? " (" + newItem.Status.DisplayName + ")" : "")); " is 230.
Long Statement,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,serviceP_DictionaryModified,The length of the statement  "			this.GetFirstIcon ().ShowBalloonTip (2000' "Service Stopped"' "The service " + newItem.Status.ServiceName + " (" + newItem.Status.DisplayName + ") has been stopped."' ToolTipIcon.Info); " is 185.
Long Statement,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,serviceP_DictionaryRemoved,The length of the statement  "	this.QueueMessage ("Deleted Service: " + item.Status.ServiceName + " (" + item.Status.ServiceStatusProcess.ServiceType.ToString () + ")" + ((item.Status.DisplayName != "") ? " (" + item.Status.DisplayName + ")" : "")); " is 218.
Long Statement,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,serviceP_DictionaryRemoved,The length of the statement  "		this.GetFirstIcon ().ShowBalloonTip (2000' "Service Deleted"' "The service " + item.Status.ServiceName + " (" + item.Status.DisplayName + ") has been deleted."' ToolTipIcon.Info); " is 179.
Long Statement,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,menuService_Popup,The length of the statement  "			if ((item.Status.ServiceStatusProcess.ControlsAccepted & ServiceAccept.Stop) == 0 && item.Status.ServiceStatusProcess.CurrentState == ServiceState.Running) { " is 157.
Long Statement,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,goToProcessServiceMenuItem_Click,The length of the statement  "	this.SelectProcess (Program.ServiceProvider.Dictionary [listServices.SelectedItems [0].Name].Status.ServiceStatusProcess.ProcessID); " is 132.
Long Statement,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,thumbButtonManager_TaskbarButtonCreated,The length of the statement  "	//string shell32DllPath = System.IO.Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.System)' "shell32.dll"); " is 125.
Long Statement,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,thumbButtonManager_TaskbarButtonCreated,The length of the statement  "	ThumbButton sysInfoButton = thumbButtonManager.CreateThumbButton (100' Icon.FromHandle (ProcessHacker.Properties.Resources.chart_line.GetHicon ())' "System Infomation"); " is 169.
Long Statement,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,thumbButtonManager_TaskbarButtonCreated,The length of the statement  "	ThumbButton appHandleButton = thumbButtonManager.CreateThumbButton (103' Icon.FromHandle (ProcessHacker.Properties.Resources.find.GetHicon ())' "Find Handles or DLLs"); " is 168.
Long Statement,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,thumbButtonManager_TaskbarButtonCreated,The length of the statement  "	ThumbButton appLogButton = thumbButtonManager.CreateThumbButton (102' Icon.FromHandle (ProcessHacker.Properties.Resources.report.GetHicon ())' "Application Log"); " is 162.
Long Statement,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,LoadOtherSettings,The length of the statement  "			string defaultDbghelp = Environment.GetFolderPath (Environment.SpecialFolder.ProgramFiles) + "\\Debugging Tools for Windows (" + (OSVersion.Architecture == OSArch.I386 ? "x86" : "x64") + ")\\dbghelp.dll"; " is 204.
Long Statement,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,SaveSettings,The length of the statement  "	Settings.Instance.WindowState = this.WindowState == FormWindowState.Minimized ? FormWindowState.Normal : this.WindowState; " is 122.
Long Statement,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,UpdateSessions,The length of the statement  "						TerminalServerHandle.GetCurrent ().GetSession (sessionId).SendMessage (mbw.MessageBoxTitle' mbw.MessageBoxText' MessageBoxButtons.OK' mbw.MessageBoxIcon' 0' 0' mbw.MessageBoxTimeout' false); " is 190.
Long Statement,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,UpdateSessions,The length of the statement  "				var sessionInformationWindow = new SessionInformationWindow (TerminalServerHandle.GetCurrent ().GetSession (sessionId)); " is 120.
Long Statement,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,UpdateStatusInfo,The length of the statement  "	statusMemory.Text = "Phys. Memory: " + ((float)(Program.ProcessProvider.System.NumberOfPhysicalPages - Program.ProcessProvider.Performance.AvailablePages) * 100 / Program.ProcessProvider.System.NumberOfPhysicalPages).ToString ("N2") + "%"; " is 239.
Long Statement,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,HackerWindow_FormClosing,The length of the statement  "	if (e.CloseReason != CloseReason.WindowsShutDown && this.GetIconsVisibleCount () > 0 && Settings.Instance.HideWhenClosed) { " is 123.
Long Statement,ProcessHacker,Program,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\Program.cs,Main,The length of the statement  "		if (Settings.Instance.AllowOnlyOneInstance && !(pArgs.ContainsKey ("-e") || pArgs.ContainsKey ("-o") || pArgs.ContainsKey ("-pw") || pArgs.ContainsKey ("-pt"))) " is 160.
Long Statement,ProcessHacker,Program,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\Program.cs,Main,The length of the statement  "				if (ElevationType == TokenElevationType.Default && !(new WindowsPrincipal (WindowsIdentity.GetCurrent ())).IsInRole (WindowsBuiltInRole.Administrator)) " is 151.
Long Statement,ProcessHacker,Program,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\Program.cs,Main,The length of the statement  "		OSVersion.Architecture == OSArch.I386 && Settings.Instance.EnableKPH && !NoKph && // Don't load KPH if we're going to install/uninstall it. " is 139.
Long Statement,ProcessHacker,Program,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\Program.cs,Main,The length of the statement  "	Windows.GetProcessName = pid => ProcessProvider.Dictionary.ContainsKey (pid) ? ProcessProvider.Dictionary [pid].Name : null; " is 124.
Long Statement,ProcessHacker,Program,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\Program.cs,ShowCommandLineUsage,The length of the statement  "	PhUtils.ShowInformation ("Option: \tUsage:\n" + "-a\tAggressive mode.\n" + "-elevate\tStarts Process Hacker elevated.\n" + "-h\tDisplays command line usage information.\n" + "-installkph\tInstalls the KProcessHacker service.\n" + "-ip pid\tDisplays the main window' then properties for the specified process.\n" + "-m\tStarts Process Hacker hidden.\n" + "-nokph\tDisables KProcessHacker. Use this if you encounter BSODs.\n" + "-nosettings\tUses defaults for all settings and does not attempt to load or save any settings.\n" + "-o\tShows Options.\n" + "-pw pid\tDisplays properties for the specified process.\n" + "-pt pid\tDisplays properties for the specified process' token.\n" + "-settings filename\tUses the specified file name as the settings file.\n" + "-t n\tShows the specified tab. 0 is Processes' 1 is Services and 2 is Network.\n" + "-uninstallkph\tUninstalls the KProcessHacker service.\n" + "-v\tStarts Process Hacker visible.\n" + ""); " is 950.
Long Statement,ProcessHacker,Program,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\Program.cs,LoadSettings,The length of the statement  "			td.Content = "The settings file used by Process Hacker is corrupt. You can either " + "delete the settings file or start Process Hacker with default settings."; " is 160.
Long Statement,ProcessHacker,Program,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\Program.cs,LoadSettings,The length of the statement  "				new TaskDialogButton ((int)DialogResult.No' "Start with default settings\n" + "Any settings you change will not be saved.")' " is 124.
Long Statement,ProcessHacker,Program,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\Program.cs,LoadSettings,The length of the statement  "			result = MessageBox.Show ("The settings file used by Process Hacker is corrupt. It will be deleted " + "and all settings will be reset."' "Process Hacker"' MessageBoxButtons.OKCancel' MessageBoxIcon.Warning); " is 208.
Long Statement,ProcessHacker,Program,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\Program.cs,ProcessCommandLine,The length of the statement  "				using (var shandle = scm.CreateService ("KProcessHacker"' "KProcessHacker"' ServiceType.KernelDriver' ServiceStartType.SystemStart' ServiceErrorControl.Ignore' Application.StartupPath + "\\kprocesshacker.sys"' null' null' null)) { " is 230.
Long Statement,ProcessHacker,Program,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\Program.cs,Unhook,The length of the statement  "	ProcessHacker.Native.Image.MappedImage file = new ProcessHacker.Native.Image.MappedImage (Environment.SystemDirectory + "\\ntdll.dll"); " is 135.
Long Statement,ProcessHacker,Program,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\Program.cs,GetDiagnosticInformation,The length of the statement  "	info.AppendLine ("Process Hacker Build Time: " + Utils.GetAssemblyBuildDate (System.Reflection.Assembly.GetExecutingAssembly ()' false).ToString (System.Globalization.DateTimeFormatInfo.InvariantInfo)); " is 202.
Long Statement,ProcessHacker,Program,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\Program.cs,GetDiagnosticInformation,The length of the statement  "		info.AppendLine ("Settings file: " + (Settings.Instance.SettingsFileName != null ? Settings.Instance.SettingsFileName : "(volatile)")); " is 135.
Long Statement,ProcessHacker,Program,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\Program.cs,GetDiagnosticInformation,The length of the statement  "	info.AppendLine ("Worker threads: " + (maxWt - wt).ToString () + " current' " + maxWt.ToString () + " max' " + minWt.ToString () + " min"); " is 139.
Long Statement,ProcessHacker,Program,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\Program.cs,GetDiagnosticInformation,The length of the statement  "	info.AppendLine ("I/O completion threads: " + (maxIoc - ioc).ToString () + " current' " + maxIoc.ToString () + " max' " + minIoc.ToString () + " min"); " is 151.
Long Statement,ProcessHacker,Program,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\Program.cs,GetDiagnosticInformation,The length of the statement  "			info.AppendLine (provider.GetType ().FullName + " (Enabled: " + provider.Enabled + "' Busy: " + provider.Busy.ToString () + ")"); " is 129.
Long Statement,ProcessHacker,Program,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\Program.cs,GetDiagnosticInformation,The length of the statement  "			info.AppendLine (provider.GetType ().FullName + " (Enabled: " + provider.Enabled + "' Busy: " + provider.Busy.ToString () + ")"); " is 129.
Long Statement,ProcessHacker,Program,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\Program.cs,GetDiagnosticInformation,The length of the statement  "	//        "Created: " + fileCreatedInfo.ToLongDateString().ToString(System.Globalization.DateTimeFormatInfo.InvariantInfo) + " " + " is 130.
Long Statement,ProcessHacker,Program,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\Program.cs,GetDiagnosticInformation,The length of the statement  "	//        "Modified: " + fileModifiedInfo.ToLongDateString().ToString(System.Globalization.DateTimeFormatInfo.InvariantInfo) + " " + " is 132.
Long Statement,ProcessHacker,VistaSearchBox,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\VistaSearchBox.cs,OnTextChanged,The length of the statement  "	searchImage.Image = TextEntered ? ProcessHacker.Properties.Resources.active_search : ProcessHacker.Properties.Resources.inactive_search; " is 136.
Long Statement,ProcessHacker,CreateServiceWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\CreateServiceWindow.cs,buttonOK_Click,The length of the statement  "			var errorControl = (ServiceErrorControl)Enum.Parse (typeof(ServiceErrorControl)' comboErrorControl.SelectedItem.ToString ()); " is 125.
Long Statement,ProcessHacker,CreateServiceWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\CreateServiceWindow.cs,buttonOK_Click,The length of the statement  "			scmhandle.CreateService (textName.Text' textDisplayName.Text' serviceType' startType' errorControl' textBinaryPath.Text' null' null' null).Dispose (); " is 150.
Long Statement,ProcessHacker,DumpHackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\DumpHackerWindow.cs,LoadSystemInformation,The length of the statement  "		PhUtils.ShowWarning ("The dump file does not contain system information. This most likely " + "means the file is corrupt."); " is 124.
Long Statement,ProcessHacker,DumpHackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\DumpHackerWindow.cs,LoadSystemInformation,The length of the statement  "	this.Text = "Process Hacker " + _phVersion + " [" + _userName + "] (" + _osVersion + "' " + (_architecture == OSArch.I386 ? "32-bit" : "64-bit") + ")"; " is 151.
Long Statement,ProcessHacker,DumpHackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\DumpHackerWindow.cs,LoadProcesses,The length of the statement  "		PhUtils.ShowWarning ("The dump file does not contain process information. This most likely " + "means the file is corrupt."); " is 125.
Long Statement,ProcessHacker,DumpHackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\DumpHackerWindow.cs,LoadServices,The length of the statement  "		PhUtils.ShowWarning ("The dump file does not contain service information. This most likely " + "means the file is corrupt."); " is 125.
Long Statement,ProcessHacker,DumpProcessWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\DumpProcessWindow.cs,LoadToken,The length of the statement  "	string virtualization = dict.ContainsKey ("VirtualizationAllowed") ? (Dump.ParseBool (dict ["VirtualizationAllowed"]) ? (Dump.ParseBool (dict ["VirtualizationEnabled"]) ? "Enabled" : "Disabled") : "Not Allowed") : "N/A"; " is 220.
Long Statement,ProcessHacker,DumpProcessWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\DumpProcessWindow.cs,LoadToken,The length of the statement  "	_tokenProps.DumpSetTextToken (dict ["UserName"]' dict ["UserStringSid"]' dict ["OwnerName"]' dict ["PrimaryGroupName"]' Dump.ParseInt32 (dict ["SessionId"]).ToString ()' elevated' virtualization); " is 196.
Long Statement,ProcessHacker,DumpProcessWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\DumpProcessWindow.cs,LoadToken,The length of the statement  "	_tokenProps.DumpSetTextAdvanced (((TokenType)Dump.ParseInt32 (dict ["Type"])).ToString ()' ((SecurityImpersonationLevel)Dump.ParseInt32 (dict ["ImpersonationLevel"])).ToString ()' "0x" + Dump.ParseInt64 (dict ["Luid"]).ToString ("x")' "0x" + Dump.ParseInt64 (dict ["AuthenticationLuid"]).ToString ("x")' Utils.FormatSize (Dump.ParseInt32 (dict ["MemoryUsed"]))' Utils.FormatSize (Dump.ParseInt32 (dict ["MemoryAvailable"]))); " is 425.
Long Statement,ProcessHacker,HeapsWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HeapsWindow.cs,destroyMenuItem_Click,The length of the statement  "	if (!PhUtils.ShowConfirmMessage ("destroy"' "the selected heap"' "Destroying a heap may cause the process to crash."' true)) " is 124.
Long Statement,ProcessHacker,HeapsWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HeapsWindow.cs,destroyMenuItem_Click,The length of the statement  "		using (var phandle = new ProcessHandle (_pid' ProcessAccess.CreateThread | ProcessAccess.QueryInformation | ProcessAccess.VmOperation)) { " is 137.
Long Statement,ProcessHacker,HeapsWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HeapsWindow.cs,destroyMenuItem_Click,The length of the statement  "			phandle.CreateThread (Win32.GetProcAddress (Win32.GetModuleHandle ("ntdll.dll")' "RtlDestroyHeap")' ((HeapInformation)listHeaps.SelectedItems [0].Tag).Address).Dispose (); " is 171.
Long Statement,ProcessHacker,IPInfoWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\IPInfoWindow.cs,Ping,The length of the statement  "					WriteResult (string.Format ("Reply from {0}:  bytes={1}  time={2}ms  TTL={3}"' ipAddress' byteSize' pingReply.RoundtripTime' pingReply.Options.Ttl)' ""' ""); " is 157.
Long Statement,ProcessHacker,IPInfoWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\IPInfoWindow.cs,Ping,The length of the statement  "					WriteResult (string.Format ("Reply from {0}:  bytes={1}  time={2}ms  TTL={3}"' ipAddress' byteSize' pingReply.RoundtripTime' pingOptions.Ttl)' ""' ""); " is 151.
Long Statement,ProcessHacker,IPInfoWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\IPInfoWindow.cs,Ping,The length of the statement  "		WriteResult (string.Format ("        Packets: Sent = {0}' Received = {1}' Lost = {2}"' sentPings' receivedPings' lostPings)' ""' ""); " is 133.
Long Statement,ProcessHacker,IPInfoWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\IPInfoWindow.cs,Tracert,The length of the statement  "			WriteResult (string.Format ("{0}"' i)' string.Format ("{0} ms"' stopWatch.ElapsedMilliseconds)' string.Format ("{0}"' pingReply.Address)); " is 138.
Long Statement,ProcessHacker,VirusTotalUploaderWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\VirusTotalUploaderWindow.cs,VirusTotalUploaderWindow_Load,The length of the statement  "			MessageBox.Show (this' "The selected file doesn't exist or couldnt be found!"' "System Error"' MessageBoxButtons.OK' MessageBoxIcon.Exclamation); " is 145.
Long Statement,ProcessHacker,VirusTotalUploaderWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\VirusTotalUploaderWindow.cs,VirusTotalUploaderWindow_Load,The length of the statement  "			MessageBox.Show (this' "This file is larger than 20MB and is above the VirusTotal size limit!"' "VirusTotal Error"' MessageBoxButtons.OK' MessageBoxIcon.Exclamation); " is 166.
Long Statement,ProcessHacker,VirusTotalUploaderWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\VirusTotalUploaderWindow.cs,VirusTotalUploaderWindow_FormClosing,The length of the statement  "		Windows7Taskbar.SetTaskbarProgressState (Program.HackerWindowHandle' Windows7Taskbar.ThumbnailProgressState.NoProgress); " is 120.
Long Statement,ProcessHacker,VirusTotalUploaderWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\VirusTotalUploaderWindow.cs,getSessionTokenTask_RunTask,The length of the statement  "		HttpWebRequest sessionRequest = (HttpWebRequest)HttpWebRequest.Create ("http://www.virustotal.com/vt/en/identificador"); " is 120.
Long Statement,ProcessHacker,VirusTotalUploaderWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\VirusTotalUploaderWindow.cs,uploadTask_RunTask,The length of the statement  "	HttpWebRequest uploadRequest = (HttpWebRequest)WebRequest.Create ("http://www.virustotal.com/vt/en/recepcionf?" + (string)param); " is 129.
Long Statement,ProcessHacker,VirusTotalUploaderWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\VirusTotalUploaderWindow.cs,ChangeProgress,The length of the statement  "	uploadedLabel.Text = "Uploaded: " + Utils.FormatSize (bytesTransferred) + " (" + ((double)bytesTransferred * 100 / totalFileSize).ToString ("F2") + "%)"; " is 153.
Long Statement,ProcessHacker,NetworkAdapter,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\NetInfoWindow.cs,init,The length of the statement  "	// Since dlValueOld and ulValueOld are used in method refresh() to calculate network speed' they must have be initialized. " is 122.
Long Statement,ProcessHacker,Assistant,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\Assistant.cs,SetDesktopWinStaAccess,The length of the statement  "	using (var dhandle = new DesktopHandle ("Default"' false' (DesktopAccess)StandardRights.WriteDac | DesktopAccess.ReadObjects | DesktopAccess.WriteObjects)) " is 155.
Long Statement,ProcessHacker,Assistant,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\Assistant.cs,PrintUsage,The length of the statement  "	Console.Write ("Process Hacker Assistant\nCopyright (c) 2008 wj32. Licensed under the GNU GPL v3.\n\nUsage:\n" + "\tassistant [-w] [-k] [-P pid] [-u username] [-p password] [-t logontype] [-s sessionid] [-d dir] " + "[-c cmdline] [-f filename] [-E name]\n\n" + "-w\t\tSpecifies that the permissions of WinSta0 and WinSta0\\Default should be " + "modified with all access. You should use this option as a normal user (\"assistant -w\") before attempting to " + "use this program as a Windows service.\n" + "-k\t\tDebugging purposes: specifies that this program should sleep after completion.\n" + "-P pid\t\t\"Steals\" the token of the specified process to start the specified program. You must not use " + "the -u and -p options with this option.\n" + "-u username\tSpecifies the user under which the program should be run. The username can be specified " + "as username' domain\\username' or username@domain. On Windows XP' specifying NT AUTHORITY\\SYSTEM does " + "not work by itself. You must specify \"-t newcredentials\" as well.\n" + "-p password\tSpecifies the password for the user.\n" + "-t logontype\tSpecifies the logon type. For logons to normal users' specify \"interactive\". For logons " + "to NT AUTHORITY\\SYSTEM' LOCAL SERVICE or NETWORK SERVICE' specify \"service\" (see above for using SYSTEM on " + "Windows XP).\n" + "-s sessionid\tSpecifies the session ID under which the program should be run.\n" + "-d dir\t\tSpecifies the current directory for the program.\n" + "-c cmdline\tSpecifies the command line for the program. You must not use the -f option if you use this.\n" + "-f filename\tSpecifies the full path to the program.\n" + "-E name\tSpecifies the partial name of the mailslot to write a 4-byte error code to.\n" + "\n" + "This application is not useful by itself; even Administrators do not normally have " + "SeAssignPrimaryTokenPrivilege and SeTcbPrivilege' both of which are required for the useful " + "functioning of this program. You must create a Windows service for this program:\n" + "\tsc.exe create PHAssistant binPath= \"\\\"[path to this program]\\\" -u \\\"SYSTEM@NT AUTHORITY\\\" " + "-t service -s [your session Id' normally 0 on XP and 1 on Vista] -c calc.exe\"\n" + "then start it:\n\tsc.exe start PHAssistant\n" + "and finally delete it:\n\tsc.exe delete PHAssistant\n"); " is 2324.
Long Statement,ProcessHacker,Assistant,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\Assistant.cs,Exit,The length of the statement  "		using (var fhandle = new FileHandle (@"\Device\Mailslot\" + mailslotName' FileShareMode.ReadWrite' FileAccess.GenericWrite)) " is 124.
Long Statement,ProcessHacker,Assistant,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\Assistant.cs,Main,The length of the statement  "				processHandle = ProcessHandle.CreateWin32 (token' args.ContainsKey ("-f") ? args ["-f"] : null' args.ContainsKey ("-c") ? args ["-c"] : null' false' ProcessCreationFlags.CreateUnicodeEnvironment' environment' args.ContainsKey ("-d") ? args ["-d"] : null' startupInfo' out clientId' out threadHandle); " is 300.
Long Statement,ProcessHacker,Dump,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\Dump.cs,DumpProcess,The length of the statement  "		if (!processesDict.ContainsKey (process.Process.InheritedFromProcessId) || process.Process.InheritedFromProcessId == process.Process.ProcessId) { " is 145.
Long Statement,ProcessHacker,Dump,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\Dump.cs,DumpProcessModules,The length of the statement  "									DumpProcessModule (modules' new ProcessModule (memory.BaseAddress' memory.RegionSize.ToInt32 ()' IntPtr.Zero' 0' Path.GetFileName (fileName)' fileName)); " is 153.
Long Statement,ProcessHacker,Dump,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\Dump.cs,DumpProcessToken,The length of the statement  "						bw2.WriteListEntry (privileges [i].Name + ";" + privileges [i].DisplayName + ";" + ((int)privileges [i].Attributes).ToString ("x")); " is 132.
Long Statement,ProcessHacker,Dump,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\Dump.cs,DumpServices,The length of the statement  "							using (var key = Microsoft.Win32.Registry.LocalMachine.OpenSubKey ("SYSTEM\\CurrentControlSet\\Services\\" + service.ServiceName + "\\Parameters")) { " is 149.
Long Statement,ProcessHacker,Updater,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\Updater.cs,PromptWithUpdate,The length of the statement  "			td.Content = "Your Version: " + currentVersion.Version.ToString () + "\nServer Version: " + bestUpdate.Version.ToString () + "\n\n" + "\n" + bestUpdate.Message; " is 160.
Long Statement,ProcessHacker,Updater,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\Updater.cs,PromptWithUpdate,The length of the statement  "			dialogResult = MessageBox.Show (form' "Your Version: " + currentVersion.Version.ToString () + "\nServer Version: " + bestUpdate.Version.ToString () + "\n\n" + bestUpdate.Message + "\n\nDo you want to download the update now?"' "Update available"' MessageBoxButtons.YesNo' MessageBoxIcon.Exclamation); " is 300.
Long Statement,ProcessHacker,Updater,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\Updater.cs,PromptWithUpdate,The length of the statement  "			td.Content = "Your Version: " + currentVersion.Version.ToString () + "\nServer Version: " + bestUpdate.Version.ToString (); " is 123.
Long Statement,ProcessHacker,Updater,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\Updater.cs,PromptWithUpdate,The length of the statement  "			MessageBox.Show (form' "Process Hacker is up-to-date."' "No updates available"' MessageBoxButtons.OK' MessageBoxIcon.Information); " is 130.
Long Statement,ProcessHacker,Updater,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\Updater.cs,GetAssemblyBuildDate,The length of the statement  "			s = new System.IO.FileStream (System.Reflection.Assembly.GetExecutingAssembly ().Location' System.IO.FileMode.Open' System.IO.FileAccess.Read); " is 143.
Long Statement,ProcessHacker,UpdaterDownloadWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\UpdaterDownloadWindow.cs,UpdaterDownload_Load,The length of the statement  "	_webClient.Headers.Add ("User-Agent"' "PH/" + currentVersion + " (compatible; PH " + currentVersion + "; PH " + currentVersion + "; .NET CLR " + Environment.Version.ToString () + ";)"); " is 185.
Long Statement,ProcessHacker,UpdaterDownloadWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\UpdaterDownloadWindow.cs,UpdaterDownloadWindow_FormClosing,The length of the statement  "		TaskbarLib.Windows7Taskbar.SetTaskbarProgressState (Program.HackerWindowHandle' TaskbarLib.Windows7Taskbar.ThumbnailProgressState.NoProgress); " is 142.
Long Statement,ProcessHacker,UpdaterDownloadWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\UpdaterDownloadWindow.cs,webClient_DownloadProgressChanged,The length of the statement  "	labelProgress.Text = "Downloaded " + Utils.FormatSize (e.BytesReceived) + "/" + Utils.FormatSize (e.TotalBytesToReceive) + " (" + e.ProgressPercentage.ToString () + "%)"; " is 170.
Long Statement,ProcessHacker,UpdaterDownloadWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\UpdaterDownloadWindow.cs,buttonInstall_Click,The length of the statement  "		Program.StartProgramAdmin (_fileName' ""' new MethodInvoker (() => success = true)' ShowWindowType.Normal' this.Handle); " is 120.
Long Statement,ProcessHacker,Provider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\Provider.cs,DisposeObject,The length of the statement  "	Logging.Log (Logging.Importance.Information' "Provider (" + this.Name + "): disposing (" + disposing.ToString () + ")"); " is 120.
Long Statement,ProcessHacker,Provider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\Provider.cs,DisposeObject,The length of the statement  "	Logging.Log (Logging.Importance.Information' "Provider (" + this.Name + "): finished disposing (" + disposing.ToString () + ")"); " is 129.
Long Statement,ProcessHacker,CommitHistoryIcon,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\UI\Icons\CommitHistoryIcon.cs,ProviderUpdated,The length of the statement  "	this.Text = "Commit: " + Utils.FormatSize ((long)this.Provider.Performance.CommittedPages * this.Provider.System.PageSize); " is 123.
Long Statement,ProcessHacker,PhysMemHistoryIcon,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\UI\Icons\PhysMemHistoryIcon.cs,ProviderUpdated,The length of the statement  "	this.Text = "Physical Memory: " + Utils.FormatSize ((long)(this.MinMaxValue - this.Provider.Performance.AvailablePages) * this.Provider.System.PageSize); " is 153.
Long Statement,ProcessHacker,IoHistoryIcon,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\UI\Icons\IoHistoryIcon.cs,ProviderUpdated,The length of the statement  "	string text = "R: " + Utils.FormatSize (this.Provider.IoReadDelta.Delta) + "\nW: " + Utils.FormatSize (this.Provider.IoWriteDelta.Delta) + "\nO: " + Utils.FormatSize (this.Provider.IoOtherDelta.Delta); " is 201.
Long Statement,ProcessHacker,ThemingScope,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\ThemingScope.cs,Activate,The length of the statement  "	IntPtr hActCtx = (IntPtr)windowsForms.GetType ("System.Windows.Forms.UnsafeNativeMethods"' true).GetNestedType ("ThemingScope"' BindingFlags.NonPublic | BindingFlags.Static).GetField ("hActCtx"' BindingFlags.NonPublic | BindingFlags.Static).GetValue (null); " is 257.
Long Statement,ProcessHacker,ProcessToolTipProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ProcessTree\ProcessToolTipProvider.cs,GetToolTip,The length of the statement  "		string cmdText = (pNode.ProcessItem.CmdLine != null ? (Utils.CreateEllipsis (pNode.ProcessItem.CmdLine.Replace ("\0"' "")' 100) + "\n") : ""); " is 142.
Long Statement,ProcessHacker,ProcessToolTipProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ProcessTree\ProcessToolTipProvider.cs,GetToolTip,The length of the statement  "				fileText = "File:\n" + PhUtils.FormatFileInfo (info.FileName' info.FileDescription' info.CompanyName' info.FileVersion' 4); " is 123.
Long Statement,ProcessHacker,ProcessToolTipProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ProcessTree\ProcessToolTipProvider.cs,GetToolTip,The length of the statement  "		if (pNode.ProcessItem.FileName != null && pNode.ProcessItem.FileName.EndsWith ("\\rundll32.exe"' StringComparison.InvariantCultureIgnoreCase) && pNode.ProcessItem.CmdLine != null) { " is 181.
Long Statement,ProcessHacker,ProcessToolTipProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ProcessTree\ProcessToolTipProvider.cs,GetToolTip,The length of the statement  "				runDllText = "\nRunDLL target:\n    " + info.FileName + "\n    " + info.FileDescription + " " + info.FileVersion + "\n    " + info.CompanyName; " is 143.
Long Statement,ProcessHacker,ProcessToolTipProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ProcessTree\ProcessToolTipProvider.cs,GetToolTip,The length of the statement  "		if (pNode.ProcessItem.FileName != null && pNode.ProcessItem.FileName.EndsWith ("\\dllhost.exe"' StringComparison.InvariantCultureIgnoreCase) && pNode.ProcessItem.CmdLine != null) { " is 180.
Long Statement,ProcessHacker,ProcessToolTipProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ProcessTree\ProcessToolTipProvider.cs,GetToolTip,The length of the statement  "						dllhostText = "\nCOM Target:\n    " + name + " (" + clsid.ToUpper () + ")\n    " + info.FileName + "\n    " + info.FileDescription + " " + info.FileVersion + "\n    " + info.CompanyName; " is 186.
Long Statement,ProcessHacker,ProcessToolTipProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ProcessTree\ProcessToolTipProvider.cs,GetToolTip,The length of the statement  "				otherNotes += "\n    Image is probably packed - has " + pNode.ProcessItem.ImportFunctions.ToString () + " imports over " + pNode.ProcessItem.ImportModules.ToString () + " modules."; " is 181.
Long Statement,ProcessHacker,ProcessToolTipProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ProcessTree\ProcessToolTipProvider.cs,GetToolTip,The length of the statement  "				else if (pNode.ProcessItem.VerifyResult == VerifyResult.Unknown && Settings.Instance.VerifySignatures && !_tree.DumpMode) { " is 123.
Long Statement,ProcessHacker,ProcessToolTipProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ProcessTree\ProcessToolTipProvider.cs,GetToolTip,The length of the statement  "				if (Program.ImposterNames.Contains (pNode.Name.ToLowerInvariant ()) && pNode.ProcessItem.VerifyResult != VerifyResult.Trusted && pNode.ProcessItem.VerifyResult != VerifyResult.Unknown) " is 184.
Long Statement,ProcessHacker,ProcessNode,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ProcessTree\ProcessNode.cs,GetWorkingSetNumber,The length of the statement  "			if ((status = NProcessHacker.PhQueryProcessWs (phandle' WsInformationClass' out wsInfo' 4' out retLen)) < NtStatus.Error) " is 121.
Long Statement,ProcessHacker,ProcessTreeModel,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ProcessTree\ProcessTreeModel.cs,GetChildren,The length of the statement  "				return ModifySort (n1.ProcessItem.Process.VirtualMemoryCounters.PrivatePageCount.CompareTo (n2.ProcessItem.Process.VirtualMemoryCounters.PrivatePageCount)' sortO); " is 163.
Long Statement,ProcessHacker,ProcessTreeModel,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ProcessTree\ProcessTreeModel.cs,GetChildren,The length of the statement  "				return ModifySort (n1.ProcessItem.Process.VirtualMemoryCounters.WorkingSetSize.CompareTo (n2.ProcessItem.Process.VirtualMemoryCounters.WorkingSetSize)' sortO); " is 159.
Long Statement,ProcessHacker,ProcessTreeModel,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ProcessTree\ProcessTreeModel.cs,GetChildren,The length of the statement  "				return ModifySort (n1.ProcessItem.Process.VirtualMemoryCounters.PeakWorkingSetSize.CompareTo (n2.ProcessItem.Process.VirtualMemoryCounters.PeakWorkingSetSize)' sortO); " is 167.
Long Statement,ProcessHacker,ProcessTreeModel,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ProcessTree\ProcessTreeModel.cs,GetChildren,The length of the statement  "				return ModifySort (n1.ProcessItem.Process.VirtualMemoryCounters.VirtualSize.CompareTo (n2.ProcessItem.Process.VirtualMemoryCounters.VirtualSize)' sortO); " is 153.
Long Statement,ProcessHacker,ProcessTreeModel,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ProcessTree\ProcessTreeModel.cs,GetChildren,The length of the statement  "				return ModifySort (n1.ProcessItem.Process.VirtualMemoryCounters.PeakVirtualSize.CompareTo (n2.ProcessItem.Process.VirtualMemoryCounters.PeakVirtualSize)' sortO); " is 161.
Long Statement,ProcessHacker,ProcessTreeModel,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ProcessTree\ProcessTreeModel.cs,GetChildren,The length of the statement  "				return ModifySort (n1.ProcessItem.Process.VirtualMemoryCounters.PagefileUsage.CompareTo (n2.ProcessItem.Process.VirtualMemoryCounters.PagefileUsage)' sortO); " is 157.
Long Statement,ProcessHacker,ProcessTreeModel,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ProcessTree\ProcessTreeModel.cs,GetChildren,The length of the statement  "				return ModifySort (n1.ProcessItem.Process.VirtualMemoryCounters.PeakPagefileUsage.CompareTo (n2.ProcessItem.Process.VirtualMemoryCounters.PeakPagefileUsage)' sortO); " is 165.
Long Statement,ProcessHacker,ProcessTreeModel,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ProcessTree\ProcessTreeModel.cs,GetChildren,The length of the statement  "				return ModifySort (n1.ProcessItem.Process.VirtualMemoryCounters.PageFaultCount.CompareTo (n2.ProcessItem.Process.VirtualMemoryCounters.PageFaultCount)' sortO); " is 159.
Long Statement,ProcessHacker,ProcessTreeModel,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ProcessTree\ProcessTreeModel.cs,GetChildren,The length of the statement  "				return ModifySort ((n1.ProcessItem.Process.KernelTime + n1.ProcessItem.Process.UserTime).CompareTo (n2.ProcessItem.Process.KernelTime + n2.ProcessItem.Process.UserTime)' sortO); " is 177.
Long Statement,ProcessHacker,ProcessTree,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ProcessTree\ProcessTree.cs,GetProcessColor,The length of the statement  "	else if (Settings.Instance.UseColorPackedProcesses && Settings.Instance.VerifySignatures && p.Name != null && Program.ImposterNames.Contains (p.Name.ToLowerInvariant ()) && p.VerifyResult != VerifyResult.Trusted && p.VerifyResult != VerifyResult.Unknown && p.FileName != null) " is 276.
Long Statement,ProcessHacker,ProcessTree,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ProcessTree\ProcessTree.cs,GetProcessColor,The length of the statement  "	else if (Settings.Instance.UseColorPackedProcesses && Settings.Instance.VerifySignatures && p.VerifyResult != VerifyResult.Trusted && p.VerifyResult != VerifyResult.NoSignature && p.VerifyResult != VerifyResult.Unknown) " is 219.
Long Statement,ProcessHacker,ProcessTree,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ProcessTree\ProcessTree.cs,GetProcessColor,The length of the statement  "	else if (_dumpMode && Settings.Instance.UseColorServiceProcesses && DumpProcessServices.ContainsKey (p.Pid) && DumpProcessServices [p.Pid].Count > 0) " is 149.
Long Statement,ProcessHacker,ProcessTree,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ProcessTree\ProcessTree.cs,GetProcessColor,The length of the statement  "	else if (!_dumpMode && Settings.Instance.UseColorServiceProcesses && Program.HackerWindow.ProcessServices.ContainsKey (p.Pid) && Program.HackerWindow.ProcessServices [p.Pid].Count > 0) " is 184.
Long Statement,ProcessHacker,ExtendedCmd,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\ExtendedCmd.cs,Run,The length of the statement  "							using (var service = manager.CreateService (serviceName' serviceName + " (Process Hacker Assistant)"' ServiceType.Win32OwnProcess' ServiceStartType.DemandStart' ServiceErrorControl.Ignore' obj' ""' "LocalSystem"' null)) { " is 221.
Long Statement,ProcessHacker,ExtendedCmd,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\ExtendedCmd.cs,Run,The length of the statement  "								using (var mhandle = MailslotHandle.Create (FileAccess.GenericRead' @"\Device\Mailslot\" + args ["-mailslot"]' 0' 5000)) { " is 122.
Long Statement,ProcessHacker,ExtendedCmd,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\ExtendedCmd.cs,Run,The length of the statement  "								DialogResult result = MessageBox.Show (window' "Could not terminate thread with ID " + tid + ":\n\n" + ex.Message' "Process Hacker"' MessageBoxButtons.OKCancel' MessageBoxIcon.Error); " is 183.
Long Statement,ProcessHacker,ExtendedCmd,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\ExtendedCmd.cs,Run,The length of the statement  "								DialogResult result = MessageBox.Show (window' "Could not suspend thread with ID " + tid + ":\n\n" + ex.Message' "Process Hacker"' MessageBoxButtons.OKCancel' MessageBoxIcon.Error); " is 181.
Long Statement,ProcessHacker,ExtendedCmd,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\ExtendedCmd.cs,Run,The length of the statement  "								DialogResult result = MessageBox.Show (window' "Could not resume thread with ID " + tid + ":\n\n" + ex.Message' "Process Hacker"' MessageBoxButtons.OKCancel' MessageBoxIcon.Error); " is 180.
Long Statement,ProcessHacker,ExtendedCmd,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\ExtendedCmd.cs,Run,The length of the statement  "							if (!Win32.ChangeServiceConfig (service' serviceType' startType' errorControl' binaryPath' loadOrderGroup' IntPtr.Zero' null' userAccount' password' null)) " is 155.
Long Statement,ProcessHacker,HiddenProcessesWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HiddenProcessesWindow.cs,HiddenProcessesWindow_Load,The length of the statement  "	this.Location = Utils.FitRectangle (new Rectangle (Settings.Instance.HiddenProcessesWindowLocation' this.Size)' this).Location; " is 127.
Long Statement,ProcessHacker,HiddenProcessesWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HiddenProcessesWindow.cs,ScanBruteForce,The length of the statement  "				AddProcessItem (phandle' pid' ref totalCount' ref hiddenCount' ref terminatedCount' pid_ => processes.ContainsKey (pid_)); " is 122.
Long Statement,ProcessHacker,HiddenProcessesWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HiddenProcessesWindow.cs,ScanBruteForce,The length of the statement  "	labelCount.Text = totalCount.ToString () + " running processes (excl. kernel and idle)' " + hiddenCount.ToString () + " hidden' " + terminatedCount.ToString () + " terminated."; " is 177.
Long Statement,ProcessHacker,HiddenProcessesWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HiddenProcessesWindow.cs,ScanCsrHandles,The length of the statement  "						AddProcessItem (phandle' pid' ref totalCount' ref hiddenCount' ref terminatedCount' pid_ => processes.ContainsKey (pid_)); " is 122.
Long Statement,ProcessHacker,HiddenProcessesWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HiddenProcessesWindow.cs,ScanCsrHandles,The length of the statement  "		labelCount.Text = totalCount.ToString () + " running processes (excl. kernel' idle' non-Windows)' " + hiddenCount.ToString () + " hidden' " + terminatedCount.ToString () + " terminated."; " is 187.
Long Statement,ProcessHacker,HiddenProcessesWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HiddenProcessesWindow.cs,buttonTerminate_Click,The length of the statement  "	if (MessageBox.Show ("Are you sure you want to terminate " + promptMessage + "?\n" + "WARNING: Terminating a hidden process may cause the system to crash or become " + "unstable because of modifications made by rootkit activity."' "Process Hacker"' MessageBoxButtons.YesNo' MessageBoxIcon.Exclamation' MessageBoxDefaultButton.Button2) == DialogResult.Yes) { " is 357.
Long Statement,ProcessHacker,HiddenProcessesWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HiddenProcessesWindow.cs,buttonSave_Click,The length of the statement  "					sw.WriteLine ((item.BackColor == Color.Red ? "[HIDDEN] " : "") + (item.BackColor == Color.DarkGray ? "[Terminated] " : "") + item.SubItems [1].Text + ": " + item.SubItems [0].Text); " is 181.
Long Statement,ProcessHacker,EditDEPWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\EditDEPWindow.cs,SetDepStatusNoKph,The length of the statement  "		using (ProcessHandle phandle = new ProcessHandle (_pid' Program.MinProcessQueryRights | ProcessAccess.VmOperation | ProcessAccess.VmRead | ProcessAccess.CreateThread)) { " is 169.
Long Statement,ProcessHacker,ProcessWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\ProcessWindow.cs,ProcessWindow_Load,The length of the statement  "	Settings.Instance.ProcessWindowLocation = this.Location = Utils.FitRectangle (new Rectangle (location' this.Size)' this).Location; " is 130.
Long Statement,ProcessHacker,ProcessWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\ProcessWindow.cs,LoadStage1,The length of the statement  "			_processHandle = new ProcessHandle (_pid' (ProcessAccess)StandardRights.Synchronize | Program.MinProcessQueryRights | Program.MinProcessReadMemoryRights); " is 154.
Long Statement,ProcessHacker,ProcessWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\ProcessWindow.cs,LoadStage2,The length of the statement  "	plotterCPUUsage.GetToolTip = i => ((plotterCPUUsage.Data1 [i] + plotterCPUUsage.Data2 [i]) * 100).ToString ("N2") + "% (K: " + (plotterCPUUsage.Data1 [i] * 100).ToString ("N2") + "%' U: " + (plotterCPUUsage.Data2 [i] * 100).ToString ("N2") + "%)" + "\n" + Program.ProcessProvider.TimeHistory [i].ToString (); " is 308.
Long Statement,ProcessHacker,ProcessWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\ProcessWindow.cs,LoadStage2,The length of the statement  "	plotterMemory.GetToolTip = i => "Pvt. Memory: " + Utils.FormatSize (plotterMemory.LongData1 [i]) + "\n" + "Working Set: " + Utils.FormatSize (plotterMemory.LongData2 [i]) + "\n" + Program.ProcessProvider.TimeHistory [i].ToString (); " is 232.
Long Statement,ProcessHacker,ProcessWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\ProcessWindow.cs,LoadStage2,The length of the statement  "	plotterIO.GetToolTip = i => "R+O: " + Utils.FormatSize (plotterIO.LongData1 [i]) + "\n" + "W: " + Utils.FormatSize (plotterIO.LongData2 [i]) + "\n" + Program.ProcessProvider.TimeHistory [i].ToString (); " is 202.
Long Statement,ProcessHacker,ProcessWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\ProcessWindow.cs,UpdateProcessProperties,The length of the statement  "			using (ProcessHandle phandle = new ProcessHandle (_pid' Program.MinProcessQueryRights | Program.MinProcessReadMemoryRights)) { " is 126.
Long Statement,ProcessHacker,ProcessWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\ProcessWindow.cs,UpdateProcessProperties,The length of the statement  "			textParent.Text = Program.ProcessProvider.Dictionary [_processItem.ParentPid].Name + " (" + _processItem.ParentPid.ToString () + ")"; " is 133.
Long Statement,ProcessHacker,ProcessWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\ProcessWindow.cs,InitializeSubControls,The length of the statement  "				_serviceProps = new ServiceProperties (Program.HackerWindow.ProcessServices.ContainsKey (_pid) ? Program.HackerWindow.ProcessServices [_pid].ToArray () : new string[0]); " is 169.
Long Statement,ProcessHacker,ProcessWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\ProcessWindow.cs,UpdateEnvironmentVariables,The length of the statement  "			using (ProcessHandle phandle = new ProcessHandle (_pid' ProcessAccess.QueryInformation | Program.MinProcessReadMemoryRights)) { " is 127.
Long Statement,ProcessHacker,ProcessWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\ProcessWindow.cs,UpdatePerformance,The length of the statement  "	plotterCPUUsage.Text = cpuStr + " (K: " + (procKernel * 100).ToString ("F2") + "%' U: " + (procUser * 100).ToString ("F2") + "%)"; " is 130.
Long Statement,ProcessHacker,ProcessWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\ProcessWindow.cs,UpdatePerformance,The length of the statement  "	plotterMemory.Text = "Pvt: " + pvtString + "' WS: " + Utils.FormatSize (item.Process.VirtualMemoryCounters.WorkingSetSize); " is 123.
Long Statement,ProcessHacker,ProcessWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\ProcessWindow.cs,buttonInspectParent_Click,The length of the statement  "		ProcessActions.ShowProperties (this' _processItem.ParentPid' Program.ProcessProvider.Dictionary [_processItem.ParentPid].Name); " is 127.
Long Statement,ProcessHacker,ProcessWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\ProcessWindow.cs,buttonPermissions_Click,The length of the statement  "		SecurityEditor.EditSecurity (this' SecurityEditor.GetSecurableWrapper (access => new ProcessHandle (_pid' (ProcessAccess)access))' _processItem.Name' NativeTypeFactory.GetAccessEntries (NativeTypeFactory.ObjectType.Process)); " is 225.
Long Statement,ProcessHacker,SysInfoWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\SysInfoWindow.cs,LoadStage1,The length of the statement  "	plotterCPU.GetToolTip = i => Program.ProcessProvider.MostCpuHistory [i] + "\n" + ((plotterCPU.Data1 [i] + plotterCPU.Data2 [i]) * 100).ToString ("N2") + "% (K " + (plotterCPU.Data1 [i] * 100).ToString ("N2") + "%' U " + (plotterCPU.Data2 [i] * 100).ToString ("N2") + "%)" + "\n" + Program.ProcessProvider.TimeHistory [i].ToString (); " is 333.
Long Statement,ProcessHacker,SysInfoWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\SysInfoWindow.cs,LoadStage1,The length of the statement  "	plotterIO.GetToolTip = i => Program.ProcessProvider.MostIoHistory [i] + "\n" + "R+O: " + Utils.FormatSize (plotterIO.LongData1 [i]) + "\n" + "W: " + Utils.FormatSize (plotterIO.LongData2 [i]) + "\n" + Program.ProcessProvider.TimeHistory [i].ToString (); " is 253.
Long Statement,ProcessHacker,SysInfoWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\SysInfoWindow.cs,LoadStage1,The length of the statement  "	plotterMemory.GetToolTip = i => "Commit: " + Utils.FormatSize (plotterMemory.LongData1 [i]) + "\n" + "Phys. Memory: " + Utils.FormatSize (plotterMemory.LongData2 [i]) + "\n" + Program.ProcessProvider.TimeHistory [i].ToString (); " is 228.
Long Statement,ProcessHacker,SysInfoWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\SysInfoWindow.cs,LoadStage1,The length of the statement  "		plotter.GetToolTip = j => Program.ProcessProvider.MostCpuHistory [j] + "\n" + ((plotter.Data1 [j] + plotter.Data2 [j]) * 100).ToString ("N2") + "% (K " + (plotter.Data1 [j] * 100).ToString ("N2") + "%' U " + (plotter.Data2 [j] * 100).ToString ("N2") + "%)" + "\n" + Program.ProcessProvider.TimeHistory [j].ToString (); " is 318.
Long Statement,ProcessHacker,SysInfoWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\SysInfoWindow.cs,UpdateGraphs,The length of the statement  "		_cpuPlotters [i].Text = ((_cpuPlotters [i].Data1 [0] + _cpuPlotters [i].Data2 [0]) * 100).ToString ("F2") + "% (K: " + (_cpuPlotters [i].Data1 [0] * 100).ToString ("F2") + "%' U: " + (_cpuPlotters [i].Data2 [0] * 100).ToString ("F2") + "%)"; " is 241.
Long Statement,ProcessHacker,SysInfoWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\SysInfoWindow.cs,UpdateGraphs,The length of the statement  "	plotterCPU.Text = ((plotterCPU.Data1 [0] + plotterCPU.Data2 [0]) * 100).ToString ("F2") + "% (K: " + (plotterCPU.Data1 [0] * 100).ToString ("F2") + "%' U: " + (plotterCPU.Data2 [0] * 100).ToString ("F2") + "%)"; " is 211.
Long Statement,ProcessHacker,SysInfoWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\SysInfoWindow.cs,UpdateGraphs,The length of the statement  "	plotterIO.Text = "R+O: " + Utils.FormatSize (plotterIO.LongData1 [0]) + "' W: " + Utils.FormatSize (plotterIO.LongData2 [0]); " is 125.
Long Statement,ProcessHacker,SysInfoWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\SysInfoWindow.cs,UpdateGraphs,The length of the statement  "	plotterMemory.Text = "Commit: " + Utils.FormatSize (plotterMemory.LongData1 [0]) + "' Phys. Mem: " + Utils.FormatSize (plotterMemory.LongData2 [0]); " is 148.
Long Statement,ProcessHacker,SysInfoWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\SysInfoWindow.cs,GetPoolLimits,The length of the statement  "	KProcessHacker.Instance.KphReadVirtualMemoryUnsafe (ProcessHacker.Native.Objects.ProcessHandle.Current' _mmSizeOfPagedPoolInBytes.ToInt32 ()' &pagedLocal' sizeof(int)' out retLength); " is 183.
Long Statement,ProcessHacker,SysInfoWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\SysInfoWindow.cs,GetPoolLimits,The length of the statement  "	KProcessHacker.Instance.KphReadVirtualMemoryUnsafe (ProcessHacker.Native.Objects.ProcessHandle.Current' _mmMaximumNonPagedPoolInBytes.ToInt32 ()' &nonPagedLocal' sizeof(int)' out retLength); " is 190.
Long Statement,ProcessHacker,SysInfoWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\SysInfoWindow.cs,UpdateInfo,The length of the statement  "	Win32.NtQuerySystemInformation (SystemInformationClass.SystemFileCacheInformation' out cacheInfo' Marshal.SizeOf (typeof(SystemCacheInformation))' out retLen); " is 159.
Long Statement,ProcessHacker,SysInfoWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\SysInfoWindow.cs,UpdateInfo,The length of the statement  "	if (_mmSizeOfPagedPoolInBytes != IntPtr.Zero && _mmMaximumNonPagedPoolInBytes != IntPtr.Zero && KProcessHacker.Instance != null) { " is 130.
Long Statement,ProcessHacker,TerminatorWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\TerminatorWindow.cs,M1Internal,The length of the statement  "		using (ProcessHandle phandle = new ProcessHandle (_pid' ProcessAccess.QueryInformation | Program.MinProcessWriteMemoryRights)) { " is 128.
Long Statement,ProcessHacker,TerminatorWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\TerminatorWindow.cs,TP2,The length of the statement  "	using (ProcessHandle phandle = new ProcessHandle (_pid' ProcessAccess.CreateThread | ProcessAccess.VmOperation | ProcessAccess.VmWrite)) { " is 138.
Long Statement,ProcessHacker,TerminatorWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\TerminatorWindow.cs,TT2,The length of the statement  "		using (ThreadHandle thandle = new ThreadHandle (thread.ClientId.ThreadId' ThreadAccess.GetContext | ThreadAccess.SetContext)) { " is 127.
Long Statement,ProcessHacker,ErrorDialog,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\ErrorDialog.cs,submitReportButton_Click,The length of the statement  "	qc.Add ("summary"' Uri.EscapeDataString (_exception.Message) + " - " + DateTime.Now.ToString ("F"' System.Globalization.DateTimeFormatInfo.InvariantInfo) + " - " + DateTime.Now.Ticks.ToString ("x"' System.Globalization.DateTimeFormatInfo.InvariantInfo)); " is 254.
Long Statement,ProcessHacker,ErrorDialog,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\ErrorDialog.cs,GetUrl,The length of the statement  "	Match m = Regex.Match (data' @"\b([\d\w\.\/\+\-\?\:]*)((ht|f)tp(s|)\:\/\/|[\d\d\d|\d\d]\.[\d\d\d|\d\d]\.|www\.|\.com|\.net|\.org)([\d\w\.\/\%\+\-\=\&amp;\?\:\\\&quot;\'\'\|\~\;]*)\b"' RegexOptions.IgnoreCase); " is 209.
Long Statement,ProcessHacker,HandleFilterWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HandleFilterWindow.cs,HandleFilterWindow_Load,The length of the statement  "	this.Location = Utils.FitRectangle (new System.Drawing.Rectangle (Settings.Instance.HandleFilterWindowLocation' this.Size)' this).Location; " is 139.
Long Statement,ProcessHacker,HandleFilterWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HandleFilterWindow.cs,HandleFilterWindow_FormClosing,The length of the statement  "		TaskbarLib.Windows7Taskbar.SetTaskbarProgressState (Program.HackerWindowHandle' TaskbarLib.Windows7Taskbar.ThumbnailProgressState.NoProgress); " is 142.
Long Statement,ProcessHacker,HandleFilterWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HandleFilterWindow.cs,closeMenuItem_Click,The length of the statement  "		if (listHandles.Items [index].SubItems [1].Text == "DLL" || listHandles.Items [index].SubItems [1].Text == "Mapped File") " is 121.
Long Statement,ProcessHacker,HandleFilterWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HandleFilterWindow.cs,closeMenuItem_Click,The length of the statement  "			using (ProcessHandle process = new ProcessHandle (((SystemHandleEntry)listHandles.SelectedItems [0].Tag).ProcessId' ProcessAccess.DupHandle)) { " is 143.
Long Statement,ProcessHacker,HandleFilterWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HandleFilterWindow.cs,closeMenuItem_Click,The length of the statement  "			if (!PhUtils.ShowContinueMessage ("Unable to close the handle \"" + listHandles.Items [index].SubItems [2].Text + "\""' ex)) " is 124.
Long Statement,ProcessHacker,HandleFilterWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HandleFilterWindow.cs,buttonFind_Click,The length of the statement  "			TaskbarLib.Windows7Taskbar.SetTaskbarProgressState (Program.HackerWindowHandle' TaskbarLib.Windows7Taskbar.ThumbnailProgressState.NoProgress); " is 142.
Long Statement,ProcessHacker,HandleFilterWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HandleFilterWindow.cs,ResetCtls,The length of the statement  "		TaskbarLib.Windows7Taskbar.SetTaskbarProgressState (Program.HackerWindowHandle' TaskbarLib.Windows7Taskbar.ThumbnailProgressState.NoProgress); " is 142.
Long Statement,ProcessHacker,PEWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\PEWindow.cs,Read,The length of the statement  "		_mappedImage.NtHeaders->OptionalHeader.Magic == Win32.Pe32Magic ? "PE32 (0x10b)" : (_mappedImage.NtHeaders->OptionalHeader.Magic == Win32.Pe32PlusMagic ? "PE32+ (0x20b)" : "Unknown (0x" + _mappedImage.NtHeaders->OptionalHeader.Magic.ToString ("x") + ")") " is 254.
Long Statement,ProcessHacker,PEWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\PEWindow.cs,Read,The length of the statement  "		_mappedImage.NtHeaders->OptionalHeader.MajorLinkerVersion.ToString () + "." + _mappedImage.NtHeaders->OptionalHeader.MinorLinkerVersion.ToString () " is 147.
Long Statement,ProcessHacker,PEWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\PEWindow.cs,Read,The length of the statement  "		_mappedImage.NtHeaders->OptionalHeader.MajorOperatingSystemVersion.ToString () + "." + _mappedImage.NtHeaders->OptionalHeader.MinorOperatingSystemVersion.ToString () " is 165.
Long Statement,ProcessHacker,PEWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\PEWindow.cs,Read,The length of the statement  "		_mappedImage.NtHeaders->OptionalHeader.MajorImageVersion.ToString () + "." + _mappedImage.NtHeaders->OptionalHeader.MinorImageVersion.ToString () " is 145.
Long Statement,ProcessHacker,PEWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\PEWindow.cs,Read,The length of the statement  "		_mappedImage.NtHeaders->OptionalHeader.MajorSubsystemVersion.ToString () + "." + _mappedImage.NtHeaders->OptionalHeader.MinorSubsystemVersion.ToString () " is 153.
Long Statement,ProcessHacker,PEWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\PEWindow.cs,listExports_RetrieveVirtualItem,The length of the statement  "			function.ForwardedName == null ? "0x" + function.Function.Decrement (new IntPtr (_mappedImage.Memory)).ToString ("x") : "" " is 122.
Long Statement,ProcessHacker,RunWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\RunWindow.cs,buttonOK_Click,The length of the statement  "		binPath = "\"" + Application.ExecutablePath + "\" -assistant " + (omitUserAndType ? "" : ("-u \"" + comboUsername.Text + "\" -t " + comboType.SelectedItem.ToString ().ToLowerInvariant () + " ")) + (_pid != -1 ? ("-P " + _pid.ToString () + " ") : "") + "-p \"" + textPassword.Text.Replace ("\""' "\\\"") + "\" -s " + textSessionID.Text + " -c \"" + textCmdLine.Text.Replace ("\""' "\\\"") + "\" -E " + mailslotName; " is 414.
Long Statement,ProcessHacker,RunWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\RunWindow.cs,buttonOK_Click,The length of the statement  "			var result = Program.StartProcessHackerAdminWait ("-e -type processhacker -action runas -obj \"" + binPath.Replace ("\""' "\\\"") + "\" -mailslot " + mailslotName + " -hwnd " + this.Handle.ToString ()' this.Handle' 5000); " is 221.
Long Statement,ProcessHacker,RunWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\RunWindow.cs,buttonOK_Click,The length of the statement  "				using (var service = manager.CreateService (serviceName' serviceName + " (Process Hacker Assistant)"' ServiceType.Win32OwnProcess' ServiceStartType.DemandStart' ServiceErrorControl.Ignore' binPath' ""' "LocalSystem"' null)) { " is 225.
Long Statement,ProcessHacker,RunWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\RunWindow.cs,isServiceUser,The length of the statement  "	if (comboUsername.Text.ToUpper () == "NT AUTHORITY\\SYSTEM" || comboUsername.Text.ToUpper () == "NT AUTHORITY\\LOCAL SERVICE" || comboUsername.Text.ToUpper () == "NT AUTHORITY\\NETWORK SERVICE") " is 194.
Long Statement,ProcessHacker,NetworkProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\NetworkProvider.cs,Update,The length of the statement  "			string id = connection.Pid.ToString () + "-" + connection.Local.ToString () + "-" + (connection.Remote != null ? connection.Remote.ToString () : "") + "-" + connection.Protocol.ToString (); " is 189.
Long Statement,ProcessHacker,NetworkProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\NetworkProvider.cs,Update,The length of the statement  "						WorkQueue.GlobalQueueWorkItemTag (new Action<string' bool' IPAddress> (this.ResolveAddresses)' "network-resolve-local"' connection.Id' false' connection.Connection.Local.Address); " is 179.
Long Statement,ProcessHacker,NetworkProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\NetworkProvider.cs,Update,The length of the statement  "						WorkQueue.GlobalQueueWorkItemTag (new Action<string' bool' IPAddress> (this.ResolveAddresses)' "network-resolve-remote"' connection.Id' true' connection.Connection.Remote.Address); " is 180.
Long Statement,ProcessHacker,NetworkProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\NetworkProvider.cs,Update,The length of the statement  "			if (connection.Connection.State != Dictionary [connection.Id].Connection.State || Dictionary [connection.Id].JustProcessed) { " is 125.
Long Statement,ProcessHacker,ProcessSystemProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ProcessSystemProvider.cs,UpdateProcessorPerf,The length of the statement  "	Win32.NtQuerySystemInformation (SystemInformationClass.SystemProcessorPerformanceInformation' _processorPerfBuffer' _processorPerfArraySize' out retLen); " is 153.
Long Statement,ProcessHacker,ProcessSystemProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ProcessSystemProvider.cs,UpdatePerformance,The length of the statement  "	Win32.NtQuerySystemInformation (SystemInformationClass.SystemPerformanceInformation' out _performance' SystemPerformanceInformation.Size' out retLen); " is 150.
Long Statement,ProcessHacker,ProcessSystemProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ProcessSystemProvider.cs,QueryProcessStage1,The length of the statement  "	WorkQueue.GlobalQueueWorkItemTag (new QueryProcessDelegate (this.QueryProcessStage1a)' "process-stage1a"' pid' fileName' forced); " is 129.
Long Statement,ProcessHacker,ProcessSystemProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ProcessSystemProvider.cs,QueryProcessStage1,The length of the statement  "	WorkQueue.GlobalQueueWorkItemTag (new QueryProcessDelegate (this.QueryProcessStage2)' "process-stage2"' pid' fileName' forced); " is 127.
Long Statement,ProcessHacker,ProcessSystemProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ProcessSystemProvider.cs,QueryProcessStage2,The length of the statement  "				if (libraryTotal < 3 && funcTotal < 5 || ((float)funcTotal / libraryTotal < 4) && libraryTotal > 3 && libraryTotal < 30) " is 120.
Long Statement,ProcessHacker,ProcessSystemProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ProcessSystemProvider.cs,QueueProcessQuery,The length of the statement  "	WorkQueue.GlobalQueueWorkItemTag (new QueryProcessDelegate (this.QueryProcessStage1)' "process-stage1"' pid' this.Dictionary [pid].FileName' true); " is 147.
Long Statement,ProcessHacker,ProcessSystemProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ProcessSystemProvider.cs,Update,The length of the statement  "		Int64Delta.Update (ref _cpuOtherDeltas [i]' _processorPerfArray [i].IdleTime + _processorPerfArray [i].DpcTime + _processorPerfArray [i].InterruptTime); " is 152.
Long Statement,ProcessHacker,ProcessSystemProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ProcessSystemProvider.cs,Update,The length of the statement  "	UpdateCb (_physicalMemoryHistory' (long)(_system.NumberOfPhysicalPages - _performance.AvailablePages) * _system.PageSize); " is 122.
Long Statement,ProcessHacker,ProcessSystemProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ProcessSystemProvider.cs,Update,The length of the statement  "					WorkQueue.GlobalQueueWorkItemTag (new QueryProcessDelegate (this.QueryProcessStage1)' "process-stage1"' pid' item.FileName' false); " is 131.
Long Statement,ProcessHacker,ProcessSystemProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ProcessSystemProvider.cs,Update,The length of the statement  "				item.CpuUsage = (float)(item.CpuUserDelta.Delta + item.CpuKernelDelta.Delta) * 100 / (sysKernelTime + sysUserTime + otherTime); " is 127.
Long Statement,ProcessHacker,ProcessSystemProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ProcessSystemProvider.cs,Update,The length of the statement  "					WorkQueue.GlobalQueueWorkItemTag (new QueryProcessDelegate (this.QueryProcessStage2)' "process-stage2"' pid' item.FileName' true); " is 130.
Long Statement,ProcessHacker,ProcessSystemProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ProcessSystemProvider.cs,Update,The length of the statement  "		UpdateCb (_cpuMostUsageHistory' newdictionary [this.PidWithMostCpuUsage].Name + ": " + newdictionary [this.PidWithMostCpuUsage].CpuUsage.ToString ("N2") + "%"); " is 160.
Long Statement,ProcessHacker,ProcessSystemProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ProcessSystemProvider.cs,Update,The length of the statement  "		UpdateCb (_ioMostUsageHistory' newdictionary [this.PidWithMostIoActivity].Name + ": " + "R+O: " + Utils.FormatSize (newdictionary [this.PidWithMostIoActivity].IoReadOtherHistory [0]) + "' W: " + Utils.FormatSize (newdictionary [this.PidWithMostIoActivity].IoWriteHistory [0])); " is 277.
Long Statement,ProcessHacker,MemoryProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\MemoryProvider.cs,Update,The length of the statement  "			if (item.Address.IsGreaterThanOrEqualTo (lastModuleAddress) && item.Address.CompareTo (lastModuleAddress.Increment (lastModuleSize)) == -1) " is 139.
Long Statement,ProcessHacker,MemoryProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\MemoryProvider.cs,Update,The length of the statement  "			if (info.RegionSize.ToInt64 () != item.Size || info.Type != item.Type || info.State != item.State || info.Protect != item.Protection) { " is 135.
Long Statement,ProcessHacker,ModuleProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ModuleProvider.cs,Update,The length of the statement  "						modules.Add (m.BaseAddress' new ProcessModule (m.BaseAddress' m.Size' IntPtr.Zero' m.Flags' System.IO.Path.GetFileName (m.FileName)' m.FileName)); " is 146.
Long Statement,ProcessHacker,ModuleProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ModuleProvider.cs,Update,The length of the statement  "						modules.Add (info.BaseAddress' new ProcessModule (info.BaseAddress' info.RegionSize.ToInt32 ()' IntPtr.Zero' 0' fi.Name' fi.FullName)); " is 135.
Long Statement,ProcessHacker,ThreadProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ThreadProvider.cs,LoadSymbols,The length of the statement  "			SymbolProvider.Options = SymbolOptions.DeferredLoads | (Settings.Instance.DbgHelpUndecorate ? SymbolOptions.UndName : 0); " is 121.
Long Statement,ProcessHacker,ThreadProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ThreadProvider.cs,LoadSymbols,The length of the statement  "						if (module.BaseName.Equals ("kernel32.dll"' StringComparison.OrdinalIgnoreCase) || module.BaseName.Equals ("ntdll.dll"' StringComparison.OrdinalIgnoreCase)) { " is 158.
Long Statement,ProcessHacker,ThreadProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ThreadProvider.cs,QueueThreadResolveStartAddress,The length of the statement  "	_symbolsWorkQueue.QueueWorkItemTag (new ResolveThreadStartAddressDelegate (this.ResolveThreadStartAddress)' "thread-resolve"' tid' startAddress); " is 145.
Long Statement,ProcessHacker,ThreadProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ThreadProvider.cs,Update,The length of the statement  "					newitem.StartAddress = this.GetThreadBasicStartAddress (newitem.StartAddressI.ToUInt64 ()' out newitem.StartAddressLevel); " is 122.
Long Statement,ProcessHacker,ThreadProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ThreadProvider.cs,Update,The length of the statement  "			if (newitem.ContextSwitches != item.ContextSwitches || newitem.ContextSwitchesDelta != item.ContextSwitchesDelta || newitem.Cycles != item.Cycles || newitem.CyclesDelta != item.CyclesDelta || newitem.IsGuiThread != item.IsGuiThread || newitem.Priority != item.Priority || newitem.StartAddress != item.StartAddress || newitem.WaitReason != item.WaitReason || item.JustResolved) { " is 378.
Long Statement,ProcessHacker,MemoryEditor,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\MemoryEditor.cs,buttonValues_Click,The length of the statement  "		value = ((uint)hexBoxMemory.ByteProvider.ReadByte (addr + 3) << 24) + ((uint)hexBoxMemory.ByteProvider.ReadByte (addr + 2) << 16) + ((uint)hexBoxMemory.ByteProvider.ReadByte (addr + 1) << 8) + ((uint)hexBoxMemory.ByteProvider.ReadByte (addr)); " is 243.
Long Statement,ProcessHacker,MemoryEditor,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\MemoryEditor.cs,buttonValues_Click,The length of the statement  "		value = ((uint)hexBoxMemory.ByteProvider.ReadByte (addr) << 24) + ((uint)hexBoxMemory.ByteProvider.ReadByte (addr + 1) << 16) + ((uint)hexBoxMemory.ByteProvider.ReadByte (addr + 2) << 8) + ((uint)hexBoxMemory.ByteProvider.ReadByte (addr + 3)); " is 243.
Long Statement,ProcessHacker,MemoryEditor,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\MemoryEditor.cs,buttonValues_Click,The length of the statement  "		value = ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 7) << 56) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 6) << 48) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 5) << 40) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 4) << 32) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 3) << 24) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 2) << 16) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 1) << 8) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr)); " is 499.
Long Statement,ProcessHacker,MemoryEditor,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\MemoryEditor.cs,buttonValues_Click,The length of the statement  "		value = ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr) << 56) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 1) << 48) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 2) << 40) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 3) << 32) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 4) << 24) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 5) << 16) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 6) << 8) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 7)); " is 499.
Long Statement,ProcessHacker,MemoryEditor,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\MemoryEditor.cs,UpdateHexBoxSelectionInfo,The length of the statement  "	labelHexSelection.Text = string.Format ("Selection: 0x{0:x}' length 0x{1:x}"' hexBoxMemory.SelectionStart' hexBoxMemory.SelectionLength); " is 137.
Long Statement,ProcessHacker,ResultsWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\ResultsWindow.cs,EditSearch,The length of the statement  "	sw.Location = new System.Drawing.Point (location.X + (size.Width - sw.Width) / 2' location.Y + (size.Height - sw.Height) / 2); " is 126.
Long Statement,ProcessHacker,ResultsWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\ResultsWindow.cs,buttonSave_Click,The length of the statement  "			sw.Write ("0x{0:x} ({1}){2}\r\n"' Int32.Parse (s [0].Replace ("0x"' "")' System.Globalization.NumberStyles.HexNumber) + Int32.Parse (s [1].Replace ("0x"' "")' System.Globalization.NumberStyles.HexNumber)' Int32.Parse (s [2])' s [3] != "" ? (": " + s [3]) : ""); " is 261.
Long Statement,ProcessHacker,ResultsWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\ResultsWindow.cs,listResults_DoubleClick,The length of the statement  "		long s_a = (long)BaseConverter.ToNumberParse (_so.Searcher.Results [listResults.SelectedIndices [0]] [0]) + (long)BaseConverter.ToNumberParse (_so.Searcher.Results [listResults.SelectedIndices [0]] [1]); " is 203.
Long Statement,ProcessHacker,ResultsWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\ResultsWindow.cs,listResults_DoubleClick,The length of the statement  "				MemoryEditor ed = Program.GetMemoryEditor (_pid' lastInfo.BaseAddress' lastInfo.RegionSize.ToInt64 ()' new Program.MemoryEditorInvokeAction (delegate (MemoryEditor f) { " is 168.
Long Statement,ProcessHacker,ResultsWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\ResultsWindow.cs,buttonFilter_Click,The length of the statement  "				System.Text.RegularExpressions.Regex r = new System.Text.RegularExpressions.Regex (s2' System.Text.RegularExpressions.RegexOptions.IgnoreCase); " is 143.
Long Statement,ProcessHacker,Save,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\Save.cs,SaveToFile,The length of the statement  "	sfd.Filter = "Process Hacker Dump Files (*.phi)|*.phi|Text Files (*.txt;*.log)|*.txt;*.log|" + "Comma-separated values (*.csv)|*.csv|All Files (*.*)|*.*"; " is 154.
Long Statement,ProcessHacker,OptionsWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\OptionsWindow.cs,InitializeHighlightingColors,The length of the statement  "	AddToList ("ColorSystemProcesses"' "System Processes"' "Processes running under the NT AUTHORITY\\SYSTEM user account."); " is 121.
Long Statement,ProcessHacker,OptionsWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\OptionsWindow.cs,InitializeHighlightingColors,The length of the statement  "	AddToList ("ColorElevatedProcesses"' "Elevated Processes"' "Processes with full privileges on a Windows Vista system with UAC enabled."); " is 137.
Long Statement,ProcessHacker,OptionsWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\OptionsWindow.cs,InitializeHighlightingColors,The length of the statement  "	AddToList ("ColorPackedProcesses"' "Packed/Dangerous Processes"' "Executables are sometimes \"packed\" to reduce their size.\n" + "\"Dangerous processes\" includes processes with invalid signatures and unverified " + "processes with the name of a system process."); " is 265.
Long Statement,ProcessHacker,OptionsWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\OptionsWindow.cs,LoadSettings,The length of the statement  "		var key = Microsoft.Win32.Registry.LocalMachine.OpenSubKey ("Software\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options"' true); " is 147.
Long Statement,ProcessHacker,OptionsWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\OptionsWindow.cs,LoadSettings,The length of the statement  "			Microsoft.Win32.Registry.LocalMachine.OpenSubKey ("Software\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\taskmgr.exe"' true).Close (); " is 159.
Long Statement,ProcessHacker,OptionsWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\OptionsWindow.cs,LoadSettings,The length of the statement  "		using (var key = Microsoft.Win32.Registry.LocalMachine.OpenSubKey ("Software\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\taskmgr.exe"' false)) { " is 170.
Long Statement,ProcessHacker,OptionsWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\OptionsWindow.cs,LoadSettings,The length of the statement  "			if ((_oldTaskMgrDebugger = (string)key.GetValue ("Debugger"' "")).Trim ('"').Equals (ProcessHandle.Current.GetMainModule ().FileName' StringComparison.OrdinalIgnoreCase)) { " is 172.
Long Statement,ProcessHacker,OptionsWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\OptionsWindow.cs,SaveSettings,The length of the statement  "			using (var key = Microsoft.Win32.Registry.LocalMachine.OpenSubKey ("Software\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\taskmgr.exe"' true)) { " is 169.
Long Statement,ProcessHacker,OptionsWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\OptionsWindow.cs,buttonChangeReplaceTaskManager_Click,The length of the statement  "	string args = "-o -hwnd " + this.Handle.ToString () + " -rect " + this.Location.X.ToString () + "'" + this.Location.Y.ToString () + "'" + this.Size.Width.ToString () + "'" + this.Size.Height.ToString (); " is 203.
Long Statement,ProcessHacker,WaitChainWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\WaitChainWindow.cs,ShowProcessWaitChains,The length of the statement  "			threadTree.Nodes.Add (string.Format ("TID:{0} Unable to retrieve wait chains for this thread without Admin rights"' currThreadId)); " is 131.
Long Statement,ProcessHacker,WaitChainWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\WaitChainWindow.cs,DisplayThreadData,The length of the statement  "			String procName = Windows.GetProcesses ().ContainsKey (node.ProcessId) ? Windows.GetProcesses () [node.ProcessId].Name : "???"; " is 127.
Long Statement,ProcessHacker,WaitChainWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\WaitChainWindow.cs,DisplayThreadData,The length of the statement  "				sb.Append (string.Format (" Status: {0} Wait: {1} CS: {2:N0}"' node.ObjectStatus' node.WaitTime' node.ContextSwitches)); " is 120.
Long Statement,ProcessHacker,WaitChainWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\WaitChainWindow.cs,buttonProperties_Click,The length of the statement  "		ProcessWindow pForm = Program.GetProcessWindow (Program.ProcessProvider.Dictionary [processPid]' new Program.PWindowInvokeAction (delegate (ProcessWindow f) { " is 158.
Long Statement,ProcessHacker,WaitChainNativeMethods,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\WaitChainWindow.cs,GetThreadWaitChain,The length of the statement  "	return RealGetThreadWaitChain (chainHandle' IntPtr.Zero' WCT_FLAGS.All' threadId' ref NodeCount' NodeInfoArray' out IsCycle); " is 125.
Long Statement,ProcessHacker,WaitChainTraversal,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\WaitChainWindow.cs,GetThreadWaitChain,The length of the statement  "	WaitChainNativeMethods.WAITCHAIN_NODE_INFO[] data = new WaitChainNativeMethods.WAITCHAIN_NODE_INFO[WaitChainNativeMethods.WCT_MAX_NODE_COUNT]; " is 142.
Long Statement,wyDay.Controls,VistaMenu,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\VistaMenu\OwnerDrawnMenu.cs,MenuItem_MeasureItem,The length of the statement  "		+ TextRenderer.MeasureText (((MenuItem)sender).Text' font' Size.Empty' TextFormatFlags.SingleLine | TextFormatFlags.NoClipping).Width + SHORTCUT_MARGIN //shortcut text width " is 173.
Long Statement,wyDay.Controls,VistaMenu,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\VistaMenu\OwnerDrawnMenu.cs,MenuItem_MeasureItem,The length of the statement  "		+ TextRenderer.MeasureText (ShortcutToString (((MenuItem)sender).Shortcut)' font' Size.Empty' TextFormatFlags.SingleLine | TextFormatFlags.NoClipping).Width //arrow width " is 170.
Long Statement,wyDay.Controls,VistaMenu,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\VistaMenu\OwnerDrawnMenu.cs,MenuItem_DrawItem,The length of the statement  "		e.Graphics.DrawLine (SystemPens.ControlDark' e.Bounds.Left + 1' yCenter' (e.Bounds.Left + e.Bounds.Width - 2)' yCenter); " is 120.
Long Statement,wyDay.Controls,VistaMenu,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\VistaMenu\OwnerDrawnMenu.cs,MenuItem_DrawItem,The length of the statement  "		e.Graphics.DrawLine (SystemPens.ControlLightLight' e.Bounds.Left + 1' yCenter + 1' (e.Bounds.Left + e.Bounds.Width - 2)' yCenter + 1); " is 134.
Long Statement,wyDay.Controls,VistaMenu,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\VistaMenu\OwnerDrawnMenu.cs,MenuItem_DrawItem,The length of the statement  "				ControlPaint.DrawMenuGlyph (e.Graphics' e.Bounds.Left + (LEFT_MARGIN + ICON_SIZE + RIGHT_MARGIN - SystemInformation.MenuCheckSize.Width) / 2' e.Bounds.Top + (e.Bounds.Height - SystemInformation.MenuCheckSize.Height) / 2 + 1' SystemInformation.MenuCheckSize.Width' SystemInformation.MenuCheckSize.Height' MenuGlyph.Bullet' menuSelected ? SystemColors.HighlightText : SystemColors.MenuText' menuSelected ? SystemColors.Highlight : SystemColors.Menu); " is 448.
Long Statement,wyDay.Controls,VistaMenu,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\VistaMenu\OwnerDrawnMenu.cs,MenuItem_DrawItem,The length of the statement  "				ControlPaint.DrawMenuGlyph (e.Graphics' e.Bounds.Left + (LEFT_MARGIN + ICON_SIZE + RIGHT_MARGIN - SystemInformation.MenuCheckSize.Width) / 2' e.Bounds.Top + (e.Bounds.Height - SystemInformation.MenuCheckSize.Height) / 2 + 1' SystemInformation.MenuCheckSize.Width' SystemInformation.MenuCheckSize.Height' MenuGlyph.Checkmark' menuSelected ? SystemColors.HighlightText : SystemColors.MenuText' menuSelected ? SystemColors.Highlight : SystemColors.Menu); " is 451.
Long Statement,wyDay.Controls,VistaMenu,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\VistaMenu\OwnerDrawnMenu.cs,MenuItem_DrawItem,The length of the statement  "					e.Graphics.DrawImage (drawImg' e.Bounds.Left + LEFT_MARGIN' e.Bounds.Top + ((e.Bounds.Height - ICON_SIZE) / 2)' ICON_SIZE' ICON_SIZE); " is 134.
Long Statement,wyDay.Controls,VistaMenu,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\VistaMenu\OwnerDrawnMenu.cs,MenuItem_DrawItem,The length of the statement  "					ControlPaint.DrawImageDisabled (e.Graphics' drawImg' e.Bounds.Left + LEFT_MARGIN' e.Bounds.Top + ((e.Bounds.Height - ICON_SIZE) / 2)' SystemColors.Menu); " is 153.
Long Statement,wyDay.Controls,VistaMenu,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\VistaMenu\OwnerDrawnMenu.cs,DrawText,The length of the statement  "	Size textSize = TextRenderer.MeasureText (((MenuItem)sender).Text' font' Size.Empty' TextFormatFlags.SingleLine | TextFormatFlags.NoClipping); " is 142.
Long Statement,wyDay.Controls,VistaMenu,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\VistaMenu\OwnerDrawnMenu.cs,DrawText,The length of the statement  "	Rectangle textRect = new Rectangle (e.Bounds.Left + LEFT_MARGIN + ICON_SIZE + RIGHT_MARGIN' yPos' textSize.Width' textSize.Height); " is 131.
Long Statement,wyDay.Controls,VistaMenu,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\VistaMenu\OwnerDrawnMenu.cs,DrawText,The length of the statement  "		TextRenderer.DrawText (e.Graphics' ((MenuItem)sender).Text' font' textRect' SystemColors.ControlLightLight' TextFormatFlags.SingleLine | (isUsingKeyboardAccel ? 0 : TextFormatFlags.HidePrefix) | TextFormatFlags.NoClipping); " is 223.
Long Statement,wyDay.Controls,VistaMenu,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\VistaMenu\OwnerDrawnMenu.cs,DrawText,The length of the statement  "	TextRenderer.DrawText (e.Graphics' ((MenuItem)sender).Text' font' textRect' ((MenuItem)sender).Enabled ? (isSelected ? SystemColors.HighlightText : SystemColors.MenuText) : SystemColors.GrayText' TextFormatFlags.SingleLine | (isUsingKeyboardAccel ? 0 : TextFormatFlags.HidePrefix) | TextFormatFlags.NoClipping); " is 311.
Long Statement,wyDay.Controls,VistaMenu,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\VistaMenu\OwnerDrawnMenu.cs,DrawText,The length of the statement  "		textSize = TextRenderer.MeasureText (shortcutText' font' Size.Empty' TextFormatFlags.SingleLine | TextFormatFlags.NoClipping); " is 126.
Long Statement,wyDay.Controls,VistaMenu,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\VistaMenu\OwnerDrawnMenu.cs,DrawText,The length of the statement  "			TextRenderer.DrawText (e.Graphics' shortcutText' font' textRect' SystemColors.ControlLightLight' TextFormatFlags.SingleLine | (isUsingKeyboardAccel ? 0 : TextFormatFlags.HidePrefix) | TextFormatFlags.NoClipping); " is 212.
Long Statement,wyDay.Controls,VistaMenu,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\VistaMenu\OwnerDrawnMenu.cs,DrawText,The length of the statement  "		TextRenderer.DrawText (e.Graphics' shortcutText' font' textRect' ((MenuItem)sender).Enabled ? (isSelected ? SystemColors.HighlightText : SystemColors.MenuText) : SystemColors.GrayText' TextFormatFlags.SingleLine | TextFormatFlags.NoClipping); " is 242.
Long Statement,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,OnPaint,The length of the statement  "	Rectangle focusRect = new Rectangle (internalBorder - 1' internalBorder - 1' bounds.Width - dropDownRectangle.Width - internalBorder' bounds.Height - (internalBorder * 2) + 2); " is 176.
Long Statement,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,OnPaint,The length of the statement  "	bool drawSplitLine = (State == PushButtonState.Hot || State == PushButtonState.Pressed || !Application.RenderWithVisualStyles); " is 127.
Long Statement,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,OnPaint,The length of the statement  "			g.DrawLine (SystemPens.ButtonShadow' bounds.Left + SplitSectionWidth' BorderSize' bounds.Left + SplitSectionWidth' bounds.Bottom - BorderSize); " is 143.
Long Statement,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,OnPaint,The length of the statement  "			g.DrawLine (SystemPens.ButtonFace' bounds.Left + SplitSectionWidth + 1' BorderSize' bounds.Left + SplitSectionWidth + 1' bounds.Bottom - BorderSize); " is 149.
Long Statement,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,OnPaint,The length of the statement  "			g.DrawLine (SystemPens.ButtonShadow' bounds.Right - SplitSectionWidth' BorderSize' bounds.Right - SplitSectionWidth' bounds.Bottom - BorderSize); " is 145.
Long Statement,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,OnPaint,The length of the statement  "			g.DrawLine (SystemPens.ButtonFace' bounds.Right - SplitSectionWidth - 1' BorderSize' bounds.Right - SplitSectionWidth - 1' bounds.Bottom - BorderSize); " is 151.
Long Statement,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,PaintArrow,The length of the statement  "	Point middle = new Point (Convert.ToInt32 (dropDownRect.Left + dropDownRect.Width / 2)' Convert.ToInt32 (dropDownRect.Top + dropDownRect.Height / 2)); " is 150.
Long Statement,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,GetPreferredSize,The length of the statement  "		else if (!string.IsNullOrEmpty (Text) && TextRenderer.MeasureText (Text' Font).Width + SplitSectionWidth > preferredSize.Width) " is 127.
Long Statement,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,LayoutTextBeforeOrAfterImage,The length of the statement  "	else if (h_image == HorizontalAlignment.Center && (h_text == HorizontalAlignment.Left || h_text == HorizontalAlignment.Center)) " is 127.
Long Statement,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,LayoutTextBeforeOrAfterImage,The length of the statement  "		final_text_rect = new Rectangle (totalArea.Left + offset' AlignInRectangle (totalArea' textSize' TextAlign).Top' textSize.Width' textSize.Height); " is 146.
Long Statement,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,LayoutTextBeforeOrAfterImage,The length of the statement  "		final_image_rect = new Rectangle (final_text_rect.Right + element_spacing' AlignInRectangle (totalArea' imageSize' ImageAlign).Top' imageSize.Width' imageSize.Height); " is 167.
Long Statement,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,LayoutTextBeforeOrAfterImage,The length of the statement  "		final_image_rect = new Rectangle (totalArea.Left + offset' AlignInRectangle (totalArea' imageSize' ImageAlign).Top' imageSize.Width' imageSize.Height); " is 151.
Long Statement,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,LayoutTextBeforeOrAfterImage,The length of the statement  "		final_text_rect = new Rectangle (final_image_rect.Right + element_spacing' AlignInRectangle (totalArea' textSize' TextAlign).Top' textSize.Width' textSize.Height); " is 163.
Long Statement,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,LayoutTextAboveOrBelowImage,The length of the statement  "	else if (v_image == VerticalAlignment.Center && (v_text == VerticalAlignment.Top || v_text == VerticalAlignment.Center)) " is 120.
Long Statement,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,LayoutTextAboveOrBelowImage,The length of the statement  "		final_text_rect = new Rectangle (AlignInRectangle (totalArea' textSize' TextAlign).Left' totalArea.Top + offset' textSize.Width' textSize.Height); " is 146.
Long Statement,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,LayoutTextAboveOrBelowImage,The length of the statement  "		final_image_rect = new Rectangle (AlignInRectangle (totalArea' imageSize' ImageAlign).Left' final_text_rect.Bottom + element_spacing' imageSize.Width' imageSize.Height); " is 169.
Long Statement,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,LayoutTextAboveOrBelowImage,The length of the statement  "		final_image_rect = new Rectangle (AlignInRectangle (totalArea' imageSize' ImageAlign).Left' totalArea.Top + offset' imageSize.Width' imageSize.Height); " is 151.
Long Statement,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,LayoutTextAboveOrBelowImage,The length of the statement  "		final_text_rect = new Rectangle (AlignInRectangle (totalArea' textSize' TextAlign).Left' final_image_rect.Bottom + element_spacing' textSize.Width' textSize.Height); " is 165.
Long Statement,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,AlignInRectangle,The length of the statement  "	if (align == System.Drawing.ContentAlignment.BottomLeft || align == System.Drawing.ContentAlignment.MiddleLeft || align == System.Drawing.ContentAlignment.TopLeft) " is 163.
Long Statement,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,AlignInRectangle,The length of the statement  "	else if (align == System.Drawing.ContentAlignment.BottomCenter || align == System.Drawing.ContentAlignment.MiddleCenter || align == System.Drawing.ContentAlignment.TopCenter) " is 174.
Long Statement,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,AlignInRectangle,The length of the statement  "	else if (align == System.Drawing.ContentAlignment.BottomRight || align == System.Drawing.ContentAlignment.MiddleRight || align == System.Drawing.ContentAlignment.TopRight) " is 171.
Long Statement,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,AlignInRectangle,The length of the statement  "	if (align == System.Drawing.ContentAlignment.TopCenter || align == System.Drawing.ContentAlignment.TopLeft || align == System.Drawing.ContentAlignment.TopRight) " is 160.
Long Statement,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,AlignInRectangle,The length of the statement  "	else if (align == System.Drawing.ContentAlignment.MiddleCenter || align == System.Drawing.ContentAlignment.MiddleLeft || align == System.Drawing.ContentAlignment.MiddleRight) " is 174.
Long Statement,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,AlignInRectangle,The length of the statement  "	else if (align == System.Drawing.ContentAlignment.BottomCenter || align == System.Drawing.ContentAlignment.BottomRight || align == System.Drawing.ContentAlignment.BottomLeft) " is 174.
Long Statement,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,SplitMenuStrip_Closing,The length of the statement  "		skipNextOpen = (dropDownRectangle.Contains (this.PointToClient (Cursor.Position))) && Control.MouseButtons == MouseButtons.Left; " is 128.
Long Statement,ProcessHacker.Common,PhUtils,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Common\PhUtils.cs,IsDangerousPid,The length of the statement  "				if ((Environment.SystemDirectory + "\\" + s).Equals (FileUtils.GetFileName (FileUtils.GetFileName (phandle.GetImageFileName ()))' StringComparison.OrdinalIgnoreCase)) { " is 168.
Long Statement,ProcessHacker.Common,PhUtils,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Common\PhUtils.cs,OpenKeyInRegedit,The length of the statement  "	using (var regeditKey = Microsoft.Win32.Registry.CurrentUser.CreateSubKey (@"Software\Microsoft\Windows\CurrentVersion\Applets\Regedit"' Microsoft.Win32.RegistryKeyPermissionCheck.ReadWriteSubTree)) { " is 200.
Long Statement,ProcessHacker.Common,PhUtils,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Common\PhUtils.cs,OpenKeyInRegedit,The length of the statement  "		Program.StartProgramAdmin (Environment.SystemDirectory + "\\..\\regedit.exe"' ""' null' ShowWindowType.Normal' window != null ? window.Handle : IntPtr.Zero); " is 157.
Long Statement,ProcessHacker.Common,PhUtils,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Common\PhUtils.cs,ShowConfirmMessage,The length of the statement  "		return MessageBox.Show (message + " Are you sure you want to " + action + "?"' "Process Hacker"' MessageBoxButtons.YesNo' MessageBoxIcon.Warning) == DialogResult.Yes; " is 166.
Long Statement,ProcessHacker.Common,PhUtils,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Common\PhUtils.cs,ShowContinueMessage,The length of the statement  "	return MessageBox.Show (FormatException (operation' ex)' "Process Hacker"' MessageBoxButtons.OKCancel' MessageBoxIcon.Error) == DialogResult.OK; " is 144.
Long Statement,ProcessHacker.Common,PhUtils,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Common\PhUtils.cs,ShowError,The length of the statement  "	MessageBox.Show (PhUtils.GetForegroundWindow ()' message' "Process Hacker"' MessageBoxButtons.OK' MessageBoxIcon.Error); " is 120.
Long Statement,ProcessHacker.Common,PhUtils,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Common\PhUtils.cs,ShowException,The length of the statement  "	            MessageBox.Show(PhUtils.GetForegroundWindow()' FormatException(operation' ex)' "Process Hacker"' MessageBoxButtons.OK' MessageBoxIcon.Error);" is 141.
Long Statement,ProcessHacker.Common,PhUtils,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Common\PhUtils.cs,ShowException,The length of the statement  "	MessageBox.Show (PhUtils.GetForegroundWindow ()' operation + "\n\n" + ex.ToString ()' "Process Hacker"' MessageBoxButtons.OK' MessageBoxIcon.Error); " is 148.
Long Statement,ProcessHacker.Common,PhUtils,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Common\PhUtils.cs,ShowInformation,The length of the statement  "	MessageBox.Show (PhUtils.GetForegroundWindow ()' message' "Process Hacker"' MessageBoxButtons.OK' MessageBoxIcon.Information); " is 126.
Long Statement,ProcessHacker.Common,PhUtils,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Common\PhUtils.cs,ShowWarning,The length of the statement  "	MessageBox.Show (PhUtils.GetForegroundWindow ()' message' "Process Hacker"' MessageBoxButtons.OK' MessageBoxIcon.Warning); " is 122.
Long Statement,ProcessHacker.Components,DotNetCounters,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\DotNetCounters.cs,UpdateCounters,The length of the statement  "		if ((counter.CounterType == PerformanceCounterType.NumberOfItems32 || counter.CounterType == PerformanceCounterType.NumberOfItems64 || counter.CounterType == PerformanceCounterType.RawFraction) && counter.CounterName != "Not Displayed") { " is 238.
Long Statement,ProcessHacker.Components,DotNetCounters,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\DotNetCounters.cs,UpdateInfo,The length of the statement  "		if ((counter.CounterType == PerformanceCounterType.NumberOfItems32 || counter.CounterType == PerformanceCounterType.NumberOfItems64 || counter.CounterType == PerformanceCounterType.RawFraction) && counter.CounterName != "Not Displayed") { " is 238.
Long Statement,ProcessHacker.Components,Indicator,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\Indicator.cs,OnPaint,The length of the statement  "	int num9 = (int)Math.Ceiling ((double)(((this.Data1 - this.Minimum) * 1.0) / ((this.Maximum - (this.Minimum * 1.0)) / ((double)num3)))); " is 136.
Long Statement,ProcessHacker.Components,Indicator,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\Indicator.cs,OnPaint,The length of the statement  "	int num10 = (int)Math.Ceiling ((double)(((this.Data1 + this.Data2 - this.Minimum) * 1.0) / ((this.Maximum - (this.Minimum * 1.0)) / ((double)num3)))); " is 150.
Long Statement,ProcessHacker.Components,TargetWindowButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\TargetWindowButton.cs,RedrawWindow,The length of the statement  "	RedrawWindowFlags.UpdateNow | RedrawWindowFlags.AllChildren | RedrawWindowFlags.Frame// important' even more so without desktop composition " is 139.
Long Statement,ProcessHacker.Components,JobProperties,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\JobProperties.cs,buttonTerminate_Click,The length of the statement  "		if (MessageBox.Show ("Are you sure you want to terminate the job? This action will " + "terminate all processes associated with the job."' "Process Hacker"' MessageBoxButtons.YesNo' MessageBoxIcon.Exclamation) == DialogResult.No) " is 229.
Long Statement,ProcessHacker.Components,NetworkList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\NetworkList.cs,provider_DictionaryAdded,The length of the statement  "		litem.Text = Program.ProcessProvider.Dictionary [item.Connection.Pid].Name + " (" + item.Connection.Pid.ToString () + ")"; " is 122.
Long Statement,ProcessHacker.Components,NetworkList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\NetworkList.cs,provider_DictionaryAdded,The length of the statement  "	litem.SubItems.Add (new ListViewItem.ListViewSubItem (litem' item.Connection.State != 0 ? item.Connection.State.ToString () : "")); " is 131.
Long Statement,ProcessHacker.Components,MemoryList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\MemoryList.cs,readWriteAddressMemoryMenuItem_Click,The length of the statement  "		MemoryEditor m_e = MemoryEditor.ReadWriteMemory (_pid' regionAddress' (int)regionSize' false' new Program.MemoryEditorInvokeAction (delegate (MemoryEditor f) { " is 159.
Long Statement,ProcessHacker.Components,MemoryList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\MemoryList.cs,freeMenuItem_Click,The length of the statement  "	if (PhUtils.ShowConfirmMessage ("free"' "the memory region"' "Freeing memory regions may cause the process to crash."' true)) { " is 127.
Long Statement,ProcessHacker.Components,MemoryList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\MemoryList.cs,decommitMenuItem_Click,The length of the statement  "	if (PhUtils.ShowConfirmMessage ("decommit"' "the memory region"' "Decommitting memory regions may cause the process to crash."' true)) { " is 136.
Long Statement,ProcessHacker.Components,ModuleList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ModuleList.cs,SetMainModule,The length of the statement  "	SortedListViewComparer comparer = (SortedListViewComparer)(listModules.ListViewItemSorter = new SortedListViewComparer (listModules) { " is 134.
Long Statement,ProcessHacker.Components,ModuleList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ModuleList.cs,provider_DictionaryAdded,The length of the statement  "	litem.ToolTipText = PhUtils.FormatFileInfo (item.FileName' item.FileDescription' item.FileCompanyName' item.FileVersion' 0); " is 124.
Long Statement,ProcessHacker.Components,ModuleList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ModuleList.cs,inspectModuleMenuItem_Click,The length of the statement  "		PEWindow pw = Program.GetPEWindow (this.GetItemFileName (listModules.SelectedItems [0])' new Program.PEWindowInvokeAction (delegate (PEWindow f) { " is 146.
Long Statement,ProcessHacker.Components,ModuleList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ModuleList.cs,unloadMenuItem_Click,The length of the statement  "	if (!PhUtils.ShowConfirmMessage ("Unload"' _pid != 4 ? "the selected module" : "the selected driver"' _pid != 4 ? "Unloading a module may cause the process to crash." : "Unloading a driver may cause system instability."' true)) " is 227.
Long Statement,ProcessHacker.Components,ModuleList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ModuleList.cs,unloadMenuItem_Click,The length of the statement  "			if (Array.Exists<string> (servicesKey.GetSubKeyNames ()' keyName => (string.Compare (keyName' serviceName' true) == 0))) { " is 122.
Long Statement,ProcessHacker.Components,ModuleList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ModuleList.cs,unloadMenuItem_Click,The length of the statement  "			MessageBox.Show ("Unable to unload the driver. Make sure Process Hacker " + "is running with administrative privileges. Error:\n\n" + ex.Message' "Process Hacker"' MessageBoxButtons.OK' MessageBoxIcon.Error); " is 208.
Long Statement,ProcessHacker.Components,ModuleList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ModuleList.cs,unloadMenuItem_Click,The length of the statement  "			using (ProcessHandle phandle = new ProcessHandle (_pid' Program.MinProcessQueryRights | ProcessAccess.VmOperation | ProcessAccess.VmRead | ProcessAccess.VmWrite | ProcessAccess.CreateThread)) { " is 193.
Long Statement,ProcessHacker.Components,ModuleList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ModuleList.cs,unloadMenuItem_Click,The length of the statement  "						PhUtils.ShowError ("Unable to find the module to unload. This may be caused " + "by an attempt to unload a mapped file or a 32-bit module."); " is 141.
Long Statement,ProcessHacker.Components,ModuleList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ModuleList.cs,unloadMenuItem_Click,The length of the statement  "						PhUtils.ShowError ("Unable to find the module to unload. This may be caused " + "by an attempt to unload a mapped file."); " is 122.
Long Statement,ProcessHacker.Components,HandleList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\HandleList.cs,ConfirmHandleClose,The length of the statement  "		return PhUtils.ShowConfirmMessage ("close"' "the selected handle(s)"' "Closing handles may cause system instability and data corruption."' false); " is 146.
Long Statement,ProcessHacker.Components,HandleList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\HandleList.cs,provider_DictionaryModified,The length of the statement  "			(listHandles.Items [newItem.Handle.Handle.ToString ()] as HighlightedListViewItem).NormalColor = this.GetHandleColor (newItem); " is 127.
Long Statement,ProcessHacker.Components,NodePlotter,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\NodePlotter.cs,Draw,The length of the statement  "	if ((_plotter.Width != context.Bounds.Width - 1 || _plotter.Height != context.Bounds.Height - 1) && context.Bounds.Width > 1 && context.Bounds.Height > 1) " is 154.
Long Statement,ProcessHacker.Components,ServiceList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ServiceList.cs,provider_DictionaryAdded,The length of the statement  "	litem.SubItems.Add (new ListViewItem.ListViewSubItem (litem' item.Status.ServiceStatusProcess.ServiceType.ToString ())); " is 120.
Long Statement,ProcessHacker.Components,ServiceList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ServiceList.cs,provider_DictionaryAdded,The length of the statement  "	litem.SubItems.Add (new ListViewItem.ListViewSubItem (litem' item.Status.ServiceStatusProcess.CurrentState.ToString ())); " is 121.
Long Statement,ProcessHacker.Components,ServiceList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ServiceList.cs,provider_DictionaryAdded,The length of the statement  "	litem.SubItems.Add (new ListViewItem.ListViewSubItem (litem' item.Status.ServiceStatusProcess.ProcessID == 0 ? "" : item.Status.ServiceStatusProcess.ProcessID.ToString ())); " is 173.
Long Statement,ProcessHacker.Components,ServiceList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ServiceList.cs,provider_DictionaryAdded,The length of the statement  "	else if (item.Status.ServiceStatusProcess.ServiceType == ServiceType.Win32OwnProcess || item.Status.ServiceStatusProcess.ServiceType == ServiceType.Win32ShareProcess) " is 166.
Long Statement,ProcessHacker.Components,ServiceList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ServiceList.cs,provider_DictionaryModified,The length of the statement  "		litem.SubItems [5].Text = newItem.Status.ServiceStatusProcess.ProcessID == 0 ? "" : newItem.Status.ServiceStatusProcess.ProcessID.ToString (); " is 142.
Long Statement,ProcessHacker.Components,ServiceProperties,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ServiceProperties.cs,_provider_DictionaryModified,The length of the statement  "			listServices.Items [newItem.Status.ServiceName].SubItems [2].Text = newItem.Status.ServiceStatusProcess.CurrentState.ToString (); " is 129.
Long Statement,ProcessHacker.Components,ServiceProperties,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ServiceProperties.cs,UpdateInformation,The length of the statement  "			if (item.Config.ServiceType == (ProcessHacker.Native.Api.ServiceType.Win32OwnProcess | ProcessHacker.Native.Api.ServiceType.InteractiveProcess)) " is 144.
Long Statement,ProcessHacker.Components,ServiceProperties,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ServiceProperties.cs,UpdateInformation,The length of the statement  "			else if (item.Config.ServiceType == (ProcessHacker.Native.Api.ServiceType.Win32ShareProcess | ProcessHacker.Native.Api.ServiceType.InteractiveProcess)) " is 151.
Long Statement,ProcessHacker.Components,ServiceProperties,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ServiceProperties.cs,UpdateInformation,The length of the statement  "					using (var key = Microsoft.Win32.Registry.LocalMachine.OpenSubKey ("SYSTEM\\CurrentControlSet\\Services\\" + item.Status.ServiceName + "\\Parameters")) " is 151.
Long Statement,ProcessHacker.Components,ServiceProperties,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ServiceProperties.cs,buttonApply_Click,The length of the statement  "			type = ProcessHacker.Native.Api.ServiceType.Win32ShareProcess | ProcessHacker.Native.Api.ServiceType.InteractiveProcess; " is 120.
Long Statement,ProcessHacker.Components,ServiceProperties,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ServiceProperties.cs,buttonApply_Click,The length of the statement  "			type = (ProcessHacker.Native.Api.ServiceType)Enum.Parse (typeof(ProcessHacker.Native.Api.ServiceType)' comboType.SelectedItem.ToString ()); " is 139.
Long Statement,ProcessHacker.Components,ServiceProperties,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ServiceProperties.cs,buttonApply_Click,The length of the statement  "		var errorControl = (ServiceErrorControl)Enum.Parse (typeof(ServiceErrorControl)' comboErrorControl.SelectedItem.ToString ()); " is 125.
Long Statement,ProcessHacker.Components,ServiceProperties,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ServiceProperties.cs,buttonApply_Click,The length of the statement  "		if (type == ProcessHacker.Native.Api.ServiceType.KernelDriver || type == ProcessHacker.Native.Api.ServiceType.FileSystemDriver) " is 127.
Long Statement,ProcessHacker.Components,ServiceProperties,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ServiceProperties.cs,buttonApply_Click,The length of the statement  "				if (!Win32.ChangeServiceConfig (shandle.Handle' type' startType' errorControl' binaryPath' loadOrderGroup' IntPtr.Zero' null' userAccount' password' null)) " is 155.
Long Statement,ProcessHacker.Components,ServiceProperties,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ServiceProperties.cs,buttonPermissions_Click,The length of the statement  "		SecurityEditor.EditSecurity (this' SecurityEditor.GetSecurableWrapper (access => new ServiceHandle (listServices.SelectedItems [0].Name' (ServiceAccess)access))' listServices.SelectedItems [0].Name' NativeTypeFactory.GetAccessEntries (NativeTypeFactory.ObjectType.Service)); " is 274.
Long Statement,ProcessHacker.Components,ActiveTaskDialog,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\TaskDialog\ActiveTaskDialog.cs,ClickButton,The length of the statement  "	return UnsafeNativeMethods.SendMessage (this.handle' (uint)UnsafeNativeMethods.TASKDIALOG_MESSAGES.TDM_CLICK_BUTTON' (IntPtr)buttonId' IntPtr.Zero) != IntPtr.Zero; " is 163.
Long Statement,ProcessHacker.Components,ActiveTaskDialog,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\TaskDialog\ActiveTaskDialog.cs,SetMarqueeProgressBar,The length of the statement  "	return UnsafeNativeMethods.SendMessage (this.handle' (uint)UnsafeNativeMethods.TASKDIALOG_MESSAGES.TDM_SET_MARQUEE_PROGRESS_BAR' (marquee ? (IntPtr)1 : IntPtr.Zero)' IntPtr.Zero) != IntPtr.Zero; " is 194.
Long Statement,ProcessHacker.Components,ActiveTaskDialog,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\TaskDialog\ActiveTaskDialog.cs,SetProgressBarState,The length of the statement  "	return UnsafeNativeMethods.SendMessage (this.handle' (uint)UnsafeNativeMethods.TASKDIALOG_MESSAGES.TDM_SET_PROGRESS_BAR_STATE' (IntPtr)newState' IntPtr.Zero) != IntPtr.Zero; " is 173.
Long Statement,ProcessHacker.Components,ActiveTaskDialog,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\TaskDialog\ActiveTaskDialog.cs,SetProgressBarRange,The length of the statement  "	// #define MAKELONG(a' b)      ((LONG)(((WORD)(((DWORD_PTR)(a)) & 0xffff)) | ((DWORD)((WORD)(((DWORD_PTR)(b)) & 0xffff))) << 16)) " is 129.
Long Statement,ProcessHacker.Components,ActiveTaskDialog,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\TaskDialog\ActiveTaskDialog.cs,SetProgressBarRange,The length of the statement  "	return UnsafeNativeMethods.SendMessage (this.handle' (uint)UnsafeNativeMethods.TASKDIALOG_MESSAGES.TDM_SET_PROGRESS_BAR_RANGE' IntPtr.Zero' lparam) != IntPtr.Zero; " is 163.
Long Statement,ProcessHacker.Components,ActiveTaskDialog,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\TaskDialog\ActiveTaskDialog.cs,SetProgressBarPosition,The length of the statement  "	return (int)UnsafeNativeMethods.SendMessage (this.handle' (uint)UnsafeNativeMethods.TASKDIALOG_MESSAGES.TDM_SET_PROGRESS_BAR_POS' (IntPtr)newPosition' IntPtr.Zero); " is 164.
Long Statement,ProcessHacker.Components,ActiveTaskDialog,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\TaskDialog\ActiveTaskDialog.cs,SetProgressBarMarquee,The length of the statement  "	// TDM_SET_PROGRESS_BAR_MARQUEE        = WM_USER+107' // wParam = 0 (stop marquee)' wParam != 0 (start marquee)' lparam = speed (milliseconds between repaints) " is 159.
Long Statement,ProcessHacker.Components,ActiveTaskDialog,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\TaskDialog\ActiveTaskDialog.cs,SetProgressBarMarquee,The length of the statement  "	UnsafeNativeMethods.SendMessage (this.handle' (uint)UnsafeNativeMethods.TASKDIALOG_MESSAGES.TDM_SET_PROGRESS_BAR_MARQUEE' (startMarquee ? new IntPtr (1) : IntPtr.Zero)' (IntPtr)speed); " is 184.
Long Statement,ProcessHacker.Components,ActiveTaskDialog,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\TaskDialog\ActiveTaskDialog.cs,SetContent,The length of the statement  "	// TDM_SET_ELEMENT_TEXT                = WM_USER+108  // wParam = element (TASKDIALOG_ELEMENTS)' lParam = new element text (LPCWSTR) " is 132.
Long Statement,ProcessHacker.Components,ActiveTaskDialog,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\TaskDialog\ActiveTaskDialog.cs,SetContent,The length of the statement  "	return UnsafeNativeMethods.SendMessageWithString (this.handle' (uint)UnsafeNativeMethods.TASKDIALOG_MESSAGES.TDM_SET_ELEMENT_TEXT' (IntPtr)UnsafeNativeMethods.TASKDIALOG_ELEMENTS.TDE_CONTENT' content) != IntPtr.Zero; " is 216.
Long Statement,ProcessHacker.Components,ActiveTaskDialog,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\TaskDialog\ActiveTaskDialog.cs,SetExpandedInformation,The length of the statement  "	// TDM_SET_ELEMENT_TEXT                = WM_USER+108  // wParam = element (TASKDIALOG_ELEMENTS)' lParam = new element text (LPCWSTR) " is 132.
Long Statement,ProcessHacker.Components,ActiveTaskDialog,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\TaskDialog\ActiveTaskDialog.cs,SetExpandedInformation,The length of the statement  "	return UnsafeNativeMethods.SendMessageWithString (this.handle' (uint)UnsafeNativeMethods.TASKDIALOG_MESSAGES.TDM_SET_ELEMENT_TEXT' (IntPtr)UnsafeNativeMethods.TASKDIALOG_ELEMENTS.TDE_EXPANDED_INFORMATION' expandedInformation) != IntPtr.Zero; " is 241.
Long Statement,ProcessHacker.Components,ActiveTaskDialog,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\TaskDialog\ActiveTaskDialog.cs,SetFooter,The length of the statement  "	// TDM_SET_ELEMENT_TEXT                = WM_USER+108  // wParam = element (TASKDIALOG_ELEMENTS)' lParam = new element text (LPCWSTR) " is 132.
Long Statement,ProcessHacker.Components,ActiveTaskDialog,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\TaskDialog\ActiveTaskDialog.cs,SetFooter,The length of the statement  "	return UnsafeNativeMethods.SendMessageWithString (this.handle' (uint)UnsafeNativeMethods.TASKDIALOG_MESSAGES.TDM_SET_ELEMENT_TEXT' (IntPtr)UnsafeNativeMethods.TASKDIALOG_ELEMENTS.TDE_FOOTER' footer) != IntPtr.Zero; " is 214.
Long Statement,ProcessHacker.Components,ActiveTaskDialog,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\TaskDialog\ActiveTaskDialog.cs,SetMainInstruction,The length of the statement  "	// TDM_SET_ELEMENT_TEXT                = WM_USER+108  // wParam = element (TASKDIALOG_ELEMENTS)' lParam = new element text (LPCWSTR) " is 132.
Long Statement,ProcessHacker.Components,ActiveTaskDialog,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\TaskDialog\ActiveTaskDialog.cs,SetMainInstruction,The length of the statement  "	return UnsafeNativeMethods.SendMessageWithString (this.handle' (uint)UnsafeNativeMethods.TASKDIALOG_MESSAGES.TDM_SET_ELEMENT_TEXT' (IntPtr)UnsafeNativeMethods.TASKDIALOG_ELEMENTS.TDE_MAIN_INSTRUCTION' mainInstruction) != IntPtr.Zero; " is 233.
Long Statement,ProcessHacker.Components,ActiveTaskDialog,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\TaskDialog\ActiveTaskDialog.cs,ClickRadioButton,The length of the statement  "	UnsafeNativeMethods.SendMessage (this.handle' (uint)UnsafeNativeMethods.TASKDIALOG_MESSAGES.TDM_CLICK_RADIO_BUTTON' (IntPtr)buttonId' IntPtr.Zero); " is 147.
Long Statement,ProcessHacker.Components,ActiveTaskDialog,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\TaskDialog\ActiveTaskDialog.cs,EnableButton,The length of the statement  "	UnsafeNativeMethods.SendMessage (this.handle' (uint)UnsafeNativeMethods.TASKDIALOG_MESSAGES.TDM_ENABLE_BUTTON' (IntPtr)buttonId' (IntPtr)(enable ? 1 : 0)); " is 155.
Long Statement,ProcessHacker.Components,ActiveTaskDialog,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\TaskDialog\ActiveTaskDialog.cs,EnableRadioButton,The length of the statement  "	UnsafeNativeMethods.SendMessage (this.handle' (uint)UnsafeNativeMethods.TASKDIALOG_MESSAGES.TDM_ENABLE_RADIO_BUTTON' (IntPtr)buttonId' (IntPtr)(enable ? 1 : 0)); " is 161.
Long Statement,ProcessHacker.Components,ActiveTaskDialog,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\TaskDialog\ActiveTaskDialog.cs,ClickVerification,The length of the statement  "	UnsafeNativeMethods.SendMessage (this.handle' (uint)UnsafeNativeMethods.TASKDIALOG_MESSAGES.TDM_CLICK_VERIFICATION' (checkedState ? new IntPtr (1) : IntPtr.Zero)' (setKeyboardFocusToCheckBox ? new IntPtr (1) : IntPtr.Zero)); " is 224.
Long Statement,ProcessHacker.Components,ActiveTaskDialog,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\TaskDialog\ActiveTaskDialog.cs,UpdateContent,The length of the statement  "	// TDM_UPDATE_ELEMENT_TEXT             = WM_USER+114' // wParam = element (TASKDIALOG_ELEMENTS)' lParam = new element text (LPCWSTR) " is 132.
Long Statement,ProcessHacker.Components,ActiveTaskDialog,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\TaskDialog\ActiveTaskDialog.cs,UpdateContent,The length of the statement  "	UnsafeNativeMethods.SendMessageWithString (this.handle' (uint)UnsafeNativeMethods.TASKDIALOG_MESSAGES.TDM_UPDATE_ELEMENT_TEXT' (IntPtr)UnsafeNativeMethods.TASKDIALOG_ELEMENTS.TDE_CONTENT' content); " is 197.
Long Statement,ProcessHacker.Components,ActiveTaskDialog,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\TaskDialog\ActiveTaskDialog.cs,UpdateExpandedInformation,The length of the statement  "	// TDM_UPDATE_ELEMENT_TEXT             = WM_USER+114' // wParam = element (TASKDIALOG_ELEMENTS)' lParam = new element text (LPCWSTR) " is 132.
Long Statement,ProcessHacker.Components,ActiveTaskDialog,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\TaskDialog\ActiveTaskDialog.cs,UpdateExpandedInformation,The length of the statement  "	UnsafeNativeMethods.SendMessageWithString (this.handle' (uint)UnsafeNativeMethods.TASKDIALOG_MESSAGES.TDM_UPDATE_ELEMENT_TEXT' (IntPtr)UnsafeNativeMethods.TASKDIALOG_ELEMENTS.TDE_EXPANDED_INFORMATION' expandedInformation); " is 222.
Long Statement,ProcessHacker.Components,ActiveTaskDialog,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\TaskDialog\ActiveTaskDialog.cs,UpdateFooter,The length of the statement  "	// TDM_UPDATE_ELEMENT_TEXT             = WM_USER+114' // wParam = element (TASKDIALOG_ELEMENTS)' lParam = new element text (LPCWSTR) " is 132.
Long Statement,ProcessHacker.Components,ActiveTaskDialog,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\TaskDialog\ActiveTaskDialog.cs,UpdateFooter,The length of the statement  "	UnsafeNativeMethods.SendMessageWithString (this.handle' (uint)UnsafeNativeMethods.TASKDIALOG_MESSAGES.TDM_UPDATE_ELEMENT_TEXT' (IntPtr)UnsafeNativeMethods.TASKDIALOG_ELEMENTS.TDE_FOOTER' footer); " is 195.
Long Statement,ProcessHacker.Components,ActiveTaskDialog,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\TaskDialog\ActiveTaskDialog.cs,UpdateMainInstruction,The length of the statement  "	// TDM_UPDATE_ELEMENT_TEXT             = WM_USER+114' // wParam = element (TASKDIALOG_ELEMENTS)' lParam = new element text (LPCWSTR) " is 132.
Long Statement,ProcessHacker.Components,ActiveTaskDialog,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\TaskDialog\ActiveTaskDialog.cs,UpdateMainInstruction,The length of the statement  "	UnsafeNativeMethods.SendMessageWithString (this.handle' (uint)UnsafeNativeMethods.TASKDIALOG_MESSAGES.TDM_UPDATE_ELEMENT_TEXT' (IntPtr)UnsafeNativeMethods.TASKDIALOG_ELEMENTS.TDE_MAIN_INSTRUCTION' mainInstruction); " is 214.
Long Statement,ProcessHacker.Components,ActiveTaskDialog,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\TaskDialog\ActiveTaskDialog.cs,SetButtonElevationRequiredState,The length of the statement  "	// TDM_SET_BUTTON_ELEVATION_REQUIRED_STATE = WM_USER+115' // wParam = Button ID' lParam = 0 (elevation not required)' lParam != 0 (elevation required) " is 150.
Long Statement,ProcessHacker.Components,ActiveTaskDialog,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\TaskDialog\ActiveTaskDialog.cs,SetButtonElevationRequiredState,The length of the statement  "	UnsafeNativeMethods.SendMessage (this.handle' (uint)UnsafeNativeMethods.TASKDIALOG_MESSAGES.TDM_SET_BUTTON_ELEVATION_REQUIRED_STATE' (IntPtr)buttonId' (IntPtr)(elevationRequired ? new IntPtr (1) : IntPtr.Zero)); " is 211.
Long Statement,ProcessHacker.Components,ActiveTaskDialog,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\TaskDialog\ActiveTaskDialog.cs,UpdateMainIcon,The length of the statement  "	// TDM_UPDATE_ICON = WM_USER+116  // wParam = icon element (TASKDIALOG_ICON_ELEMENTS)' lParam = new icon (hIcon if TDF_USE_HICON_* was set' PCWSTR otherwise) " is 157.
Long Statement,ProcessHacker.Components,ActiveTaskDialog,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\TaskDialog\ActiveTaskDialog.cs,UpdateMainIcon,The length of the statement  "	UnsafeNativeMethods.SendMessage (this.handle' (uint)UnsafeNativeMethods.TASKDIALOG_MESSAGES.TDM_UPDATE_ICON' (IntPtr)UnsafeNativeMethods.TASKDIALOG_ICON_ELEMENTS.TDIE_ICON_MAIN' (IntPtr)icon); " is 192.
Long Statement,ProcessHacker.Components,ActiveTaskDialog,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\TaskDialog\ActiveTaskDialog.cs,UpdateMainIcon,The length of the statement  "	// TDM_UPDATE_ICON = WM_USER+116  // wParam = icon element (TASKDIALOG_ICON_ELEMENTS)' lParam = new icon (hIcon if TDF_USE_HICON_* was set' PCWSTR otherwise) " is 157.
Long Statement,ProcessHacker.Components,ActiveTaskDialog,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\TaskDialog\ActiveTaskDialog.cs,UpdateMainIcon,The length of the statement  "	UnsafeNativeMethods.SendMessage (this.handle' (uint)UnsafeNativeMethods.TASKDIALOG_MESSAGES.TDM_UPDATE_ICON' (IntPtr)UnsafeNativeMethods.TASKDIALOG_ICON_ELEMENTS.TDIE_ICON_MAIN' (icon == null ? IntPtr.Zero : icon.Handle)); " is 222.
Long Statement,ProcessHacker.Components,ActiveTaskDialog,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\TaskDialog\ActiveTaskDialog.cs,UpdateFooterIcon,The length of the statement  "	// TDM_UPDATE_ICON = WM_USER+116  // wParam = icon element (TASKDIALOG_ICON_ELEMENTS)' lParam = new icon (hIcon if TDF_USE_HICON_* was set' PCWSTR otherwise) " is 157.
Long Statement,ProcessHacker.Components,ActiveTaskDialog,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\TaskDialog\ActiveTaskDialog.cs,UpdateFooterIcon,The length of the statement  "	UnsafeNativeMethods.SendMessage (this.handle' (uint)UnsafeNativeMethods.TASKDIALOG_MESSAGES.TDM_UPDATE_ICON' (IntPtr)UnsafeNativeMethods.TASKDIALOG_ICON_ELEMENTS.TDIE_ICON_FOOTER' (IntPtr)icon); " is 194.
Long Statement,ProcessHacker.Components,ActiveTaskDialog,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\TaskDialog\ActiveTaskDialog.cs,UpdateFooterIcon,The length of the statement  "	// TDM_UPDATE_ICON = WM_USER+116  // wParam = icon element (TASKDIALOG_ICON_ELEMENTS)' lParam = new icon (hIcon if TDF_USE_HICON_* was set' PCWSTR otherwise) " is 157.
Long Statement,ProcessHacker.Components,ActiveTaskDialog,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\TaskDialog\ActiveTaskDialog.cs,UpdateFooterIcon,The length of the statement  "	UnsafeNativeMethods.SendMessage (this.handle' (uint)UnsafeNativeMethods.TASKDIALOG_MESSAGES.TDM_UPDATE_ICON' (IntPtr)UnsafeNativeMethods.TASKDIALOG_ICON_ELEMENTS.TDIE_ICON_FOOTER' (icon == null ? IntPtr.Zero : icon.Handle)); " is 224.
Long Statement,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,menuThread_Popup,The length of the statement  "			using (var thandle = new ThreadHandle (int.Parse (listThreads.SelectedItems [0].SubItems [0].Text)' Program.MinThreadQueryRights)) { " is 132.
Long Statement,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,menuThread_Popup,The length of the statement  "			using (ThreadHandle thandle = new ThreadHandle (int.Parse (listThreads.SelectedItems [0].Text)' Program.MinThreadQueryRights)) { " is 128.
Long Statement,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,inspectThreadMenuItem_Click,The length of the statement  "		PhUtils.ShowError ("Process Hacker cannot view system thread stacks without KProcessHacker. " + "Make sure Process Hacker has administrative privileges and KProcessHacker " + "supports your operating system."); " is 210.
Long Statement,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,inspectThreadMenuItem_Click,The length of the statement  "		if (!PhUtils.ShowConfirmMessage ("inspect"' "Process Hacker's threads"' "Inspecting Process Hacker's threads may lead to instability."' true)) " is 142.
Long Statement,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,inspectThreadMenuItem_Click,The length of the statement  "			if ((_provider.ProcessAccess & ProcessAccess.QueryLimitedInformation) != 0 || (_provider.ProcessAccess & ProcessAccess.QueryInformation) != 0) " is 142.
Long Statement,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,inspectThreadMenuItem_Click,The length of the statement  "		(new ThreadWindow (_pid' Int32.Parse (listThreads.SelectedItems [0].SubItems [0].Text)' _provider.Symbols' phandle)).ShowDialog (this); " is 135.
Long Statement,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,terminateThreadMenuItem_Click,The length of the statement  "		if (!PhUtils.ShowConfirmMessage ("terminate"' "the selected system thread(s)"' "Forcibly terminating system threads may cause the system to crash."' true)) " is 155.
Long Statement,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,terminateThreadMenuItem_Click,The length of the statement  "	if (!PhUtils.ShowConfirmMessage ("terminate"' "the selected thread(s)"' "Terminating a thread may cause the process to stop working."' false)) " is 142.
Long Statement,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,terminateThreadMenuItem_Click,The length of the statement  "	if (Program.ElevationType == TokenElevationType.Limited && KProcessHacker.Instance == null && Settings.Instance.ElevationLevel != (int)ElevationLevel.Never) { " is 158.
Long Statement,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,terminateThreadMenuItem_Click,The length of the statement  "			Program.StartProcessHackerAdmin ("-e -type thread -action terminate -obj \"" + objects + "\" -hwnd " + this.Handle.ToString ()' null' this.Handle); " is 147.
Long Statement,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,forceTerminateThreadMenuItem_Click,The length of the statement  "	if (!PhUtils.ShowConfirmMessage ("force terminate"' "the selected thread(s)"' "Forcibly terminating threads may cause the system to crash."' true)) " is 147.
Long Statement,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,suspendThreadMenuItem_Click,The length of the statement  "	if (Program.ElevationType == TokenElevationType.Limited && KProcessHacker.Instance == null && Settings.Instance.ElevationLevel != (int)ElevationLevel.Never) { " is 158.
Long Statement,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,suspendThreadMenuItem_Click,The length of the statement  "			Program.StartProcessHackerAdmin ("-e -type thread -action suspend -obj \"" + objects + "\" -hwnd " + this.Handle.ToString ()' null' this.Handle); " is 145.
Long Statement,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,resumeThreadMenuItem_Click,The length of the statement  "	if (Program.ElevationType == TokenElevationType.Limited && KProcessHacker.Instance == null && Settings.Instance.ElevationLevel != (int)ElevationLevel.Never) { " is 158.
Long Statement,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,resumeThreadMenuItem_Click,The length of the statement  "			Program.StartProcessHackerAdmin ("-e -type thread -action resume -obj \"" + objects + "\" -hwnd " + this.Handle.ToString ()' null' this.Handle); " is 144.
Long Statement,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,permissionsThreadMenuItem_Click,The length of the statement  "		SecurityEditor.EditSecurity (this' SecurityEditor.GetSecurableWrapper (access => new ThreadHandle (int.Parse (listThreads.SelectedItems [0].Text)' (ThreadAccess)access))' "Thread " + listThreads.SelectedItems [0].Text' NativeTypeFactory.GetAccessEntries (NativeTypeFactory.ObjectType.Thread)); " is 293.
Long Statement,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,tokenThreadMenuItem_Click,The length of the statement  "		using (ThreadHandle thandle = new ThreadHandle (int.Parse (listThreads.SelectedItems [0].Text)' Program.MinThreadQueryRights)) { " is 128.
Long Statement,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,GetHandleString,The length of the statement  "		return "Handle 0x" + handle.ToString ("x") + " (" + handleInfo.TypeName + "): " + (string.IsNullOrEmpty (handleInfo.BestName) ? "(unnamed object)" : handleInfo.BestName); " is 170.
Long Statement,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,analyzeWaitMenuItem_Click,The length of the statement  "						sb.Append ("Thread is sleeping. Timeout: " + (new TimeSpan (-timeout)).TotalMilliseconds.ToString () + " milliseconds"); " is 120.
Long Statement,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,analyzeWaitMenuItem_Click,The length of the statement  "				else if (name.StartsWith ("ntdll.dll!zwreadfile") || name.StartsWith ("ntdll.dll!ntreadfile") || name.StartsWith ("ntdll.dll!zwwritefile") || name.StartsWith ("ntdll.dll!ntwritefile")) { " is 186.
Long Statement,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,analyzeWaitMenuItem_Click,The length of the statement  "				else if (name.StartsWith ("ntdll.dll!zwreplywaitreceiveport") || name.StartsWith ("ntdll.dll!ntreplywaitreceiveport") || name.StartsWith ("ntdll.dll!zwrequestwaitreplyport") || name.StartsWith ("ntdll.dll!ntrequestwaitreplyport") || name.StartsWith ("ntdll.dll!zwalpcsendwaitreceiveport") || name.StartsWith ("ntdll.dll!ntalpcsendwaitreceiveport")) { " is 350.
Long Statement,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,analyzeWaitMenuItem_Click,The length of the statement  "				else if (name.StartsWith ("ntdll.dll!zwsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!ntsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!zwsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!ntsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaithigheventpair") || name.StartsWith ("ntdll.dll!ntwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaitloweventpair") || name.StartsWith ("ntdll.dll!ntwaitloweventpair")) { " is 454.
Long Statement,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,analyzeWaitMenuItem_Click,The length of the statement  "				else if (name.StartsWith ("ntdll.dll!zwwaitforkeyedevent") || name.StartsWith ("ntdll.dll!ntwaitforkeyedevent") || name.StartsWith ("ntdll.dll!zwreleasekeyedevent") || name.StartsWith ("ntdll.dll!ntreleasekeyedevent")) { " is 220.
Long Statement,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,analyzeWaitMenuItem_Click,The length of the statement  "					sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for a keyed event (key 0x" + key.ToString ("x") + "):"); " is 129.
Long Statement,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,analyzeWaitMenuItem_Click,The length of the statement  "				else if (name.StartsWith ("ntdll.dll!zwwaitformultipleobjects") || name.StartsWith ("ntdll.dll!ntwaitformultipleobjects") || name.StartsWith ("kernel32.dll!waitformultipleobjects")) { " is 183.
Long Statement,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,analyzeWaitMenuItem_Click,The length of the statement  "					sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + "' wait type: " + waitType.ToString () + ") for:"); " is 149.
Long Statement,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,analyzeWaitMenuItem_Click,The length of the statement  "				else if (name.StartsWith ("ntdll.dll!zwwaitforsingleobject") || name.StartsWith ("ntdll.dll!ntwaitforsingleobject") || name.StartsWith ("kernel32.dll!waitforsingleobject")) { " is 174.
Long Statement,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,analyzeWaitMenuItem_Click,The length of the statement  "				else if (name.StartsWith ("ntdll.dll!zwwaitforworkviaworkerfactory") || name.StartsWith ("ntdll.dll!ntwaitforworkviaworkerfactory")) { " is 134.
Long Statement,ProcessHacker.Components,TokenProperties,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\TokenProperties.cs,removeMenuItem_Click,The length of the statement  "	if (PhUtils.ShowConfirmMessage ("remove"' "the selected privilege(s)"' "Removing privileges may reduce the functionality of the process' " + "and is permanent for the lifetime of the process."' false)) { " is 203.
Long Statement,ProcessHacker.Components,TokenProperties,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\TokenProperties.cs,buttonPermissions_Click,The length of the statement  "		SecurityEditor.EditSecurity (this' SecurityEditor.GetSecurableWrapper (access => _object.GetToken ((TokenAccess)access))' "Token"' NativeTypeFactory.GetAccessEntries (NativeTypeFactory.ObjectType.Token)); " is 204.
Long Statement,ProcessHacker.Components,VerticleProgressBar,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\VerticleProgressBar.cs,VerticleProgressBar_Paint,The length of the statement  "	rChunk.DrawBackground (e.Graphics' new Rectangle (new Point (e.ClipRectangle.Left + 1' e.ClipRectangle.Top + 1 + (int)(this.Size.Height * (1 - _value)))' new Size (this.Size.Width - 2' (int)(this.Size.Height * _value) - 2))); " is 225.
Long Statement,ProcessHackerRestartRecovery,ApplicationRestartRecoveryManager,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\RestartRecoveryLib\RestartRecoveryManager.cs,RegisterForRestart,The length of the statement  "	// Register for automatic restart if the application was terminated for any reason other than a system reboot or a system update. " is 129.
Long Statement,ProcessHackerRestartRecovery,ApplicationRestartRecoveryManager,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\RestartRecoveryLib\RestartRecoveryManager.cs,RegisterForRestart,The length of the statement  "	ApplicationRestartRecoveryManager.RegisterForApplicationRestart (new RestartSettings ("-recovered"' RestartRestrictions.NotOnReboot | RestartRestrictions.NotOnPatch)); " is 167.
Long Statement,ProcessHackerRestartRecovery,ApplicationRestartRecoveryManager,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\RestartRecoveryLib\RestartRecoveryManager.cs,RegisterForApplicationRecovery,The length of the statement  "		HResult hr = AppRestartRecoveryNativeMethods.RegisterApplicationRecoveryCallback (AppRestartRecoveryNativeMethods.internalCallback' (IntPtr)handle' settings.PingInterval' (uint)0); " is 180.
Long Statement,ProcessHackerRestartRecovery,RecoverySettings,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\RestartRecoveryLib\RecoverySettings.cs,ToString,The length of the statement  "	return String.Format ("delegate: {0}' state: {1}' ping: {2}"' this.recoveryData.Callback.Method.ToString ()' this.recoveryData.State.ToString ()' this.PingInterval); " is 165.
Long Statement,TaskbarLib,JumpListDestinations,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\TaskbarLib\JumpLists\JumpListImpl.cs,AddDestination,The length of the statement  "	List<IJumpListDestination> destinations = _categorizedDestinations.Values.FirstOrDefault (list => list.First ().Category == destination.Category); " is 146.
Long Statement,TaskbarLib,JumpListDestinations,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\TaskbarLib\JumpLists\JumpListImpl.cs,DeleteDestination,The length of the statement  "	List<IJumpListDestination> destinations = _categorizedDestinations.Values.First (list => list.First ().Category == destination.Category); " is 137.
Long Statement,TaskbarLib,JumpListDestinations,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\TaskbarLib\JumpLists\JumpListImpl.cs,DeleteDestination,The length of the statement  "	IJumpListDestination toDelete = destinations.Find (d => d.Path == destination.Path && d.Category == destination.Category && d.Title == destination.Title); " is 154.
Long Statement,TaskbarLib,JumpListDestinations,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\TaskbarLib\JumpLists\JumpListImpl.cs,RefreshDestinations,The length of the statement  "		HResult appendCategoryResult = destinationList.AppendCategory (destinations.First ().Category' (IObjectArray)categoryContents); " is 127.
Long Statement,TaskbarLib,ShellLink,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\TaskbarLib\JumpLists\JumpListImpl.cs,GetShellRepresentation,The length of the statement  "		HResult setValueResult = propertyStore.SetValue (ref PropertyKey.PKEY_AppUserModel_IsDestListSeparator' ref propVariant); " is 121.
Long Statement,TaskbarLib,ShellItem,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\TaskbarLib\JumpLists\JumpListImpl.cs,GetShellItemFromPath,The length of the statement  "	HResult result = UnsafeNativeMethods.SHCreateItemFromParsingName (path' IntPtr.Zero' ref shellItemGuid' out resultItem); " is 120.
Long Statement,TaskbarLib,JumpListManager,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\TaskbarLib\JumpLists\JumpListManager.cs,BeginList,The length of the statement  "		throw new InvalidOperationException ("You must register for the JumpListManager.UserRemovedItems event before adding any items"); " is 129.
Long Statement,TaskbarLib,Windows7Taskbar,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\TaskbarLib\Windows7Taskbar.cs,InternalGetWindowPropertyStore,The length of the statement  "	HResult shGetPropertyStoreResult = UnsafeNativeMethods.SHGetPropertyStoreForWindow (hwnd' ref SafeNativeMethods.IID_IPropertyStore' out propStore); " is 147.
Long Statement,TaskbarLib,Windows7Taskbar,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\TaskbarLib\Windows7Taskbar.cs,InternalEnableCustomWindowPreview,The length of the statement  "	HResult setFirstAttributeResult = UnsafeNativeMethods.DwmSetWindowAttribute (hwnd' SafeNativeMethods.DWMWA_HAS_ICONIC_BITMAP' ref t' 4); " is 136.
Long Statement,TaskbarLib,Windows7Taskbar,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\TaskbarLib\Windows7Taskbar.cs,InternalEnableCustomWindowPreview,The length of the statement  "	HResult setSecondAttributeResult = UnsafeNativeMethods.DwmSetWindowAttribute (hwnd' SafeNativeMethods.DWMWA_FORCE_ICONIC_REPRESENTATION' ref t' 4); " is 147.
Long Statement,TaskbarLib,Windows7Taskbar,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\TaskbarLib\Windows7Taskbar.cs,SetIconicThumbnail,The length of the statement  "	HResult dwmSetIconicThumbnailResult = UnsafeNativeMethods.DwmSetIconicThumbnail (form.Handle' bitmap.GetHbitmap ()' SafeNativeMethods.DWM_SIT_DISPLAYFRAME); " is 156.
Long Statement,TaskbarLib,Windows7Taskbar,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\TaskbarLib\Windows7Taskbar.cs,SetPeekBitmap,The length of the statement  "	HResult dwmSetIconicLivePreviewBitmapResult = UnsafeNativeMethods.DwmSetIconicLivePreviewBitmap (form.Handle' bitmap.GetHbitmap ()' IntPtr.Zero' displayFrame ? SafeNativeMethods.DWM_SIT_DISPLAYFRAME : (uint)0); " is 210.
Long Statement,TaskbarLib,Windows7Taskbar,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\TaskbarLib\Windows7Taskbar.cs,SetPeekBitmap,The length of the statement  "	HResult dwmSetIconicLivePreviewResult = UnsafeNativeMethods.DwmSetIconicLivePreviewBitmap (form.Handle' bitmap.GetHbitmap ()' ref nativePoint' displayFrame ? SafeNativeMethods.DWM_SIT_DISPLAYFRAME : (uint)0); " is 208.
Long Statement,ProcessHacker.UI.Actions,SessionActions,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\UI\Actions\SessionActions.cs,Prompt,The length of the statement  "		result = MessageBox.Show ("Are you sure you want to " + action + " " + name + "?"' "Process Hacker"' MessageBoxButtons.YesNo' MessageBoxIcon.Exclamation' MessageBoxDefaultButton.Button2); " is 187.
Long Statement,ProcessHacker.UI.Actions,SessionActions,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\UI\Actions\SessionActions.cs,ElevateIfRequired,The length of the statement  "		if (ex.ErrorCode == Win32Error.AccessDenied && OSVersion.HasUac && Program.ElevationType == ProcessHacker.Native.Api.TokenElevationType.Limited) { " is 146.
Long Statement,ProcessHacker.UI.Actions,SessionActions,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\UI\Actions\SessionActions.cs,ElevateIfRequired,The length of the statement  "				td.Content = "The action could not be performed in the current security context. " + "Do you want Process Hacker to prompt for the appropriate credentials and elevate the action?"; " is 180.
Long Statement,ProcessHacker.UI.Actions,SessionActions,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\UI\Actions\SessionActions.cs,ElevateIfRequired,The length of the statement  "				Program.StartProcessHackerAdmin ("-e -type session -action " + actionName + " -obj \"" + session.ToString () + "\" -hwnd " + window.Handle.ToString ()' null' window.Handle); " is 173.
Long Statement,ProcessHacker.UI.Actions,ServiceActions,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\UI\Actions\ServiceActions.cs,Prompt,The length of the statement  "		result = MessageBox.Show ("Are you sure you want to " + action + " " + service + "?"' "Process Hacker"' MessageBoxButtons.YesNo' MessageBoxIcon.Exclamation' MessageBoxDefaultButton.Button2); " is 190.
Long Statement,ProcessHacker.UI.Actions,ServiceActions,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\UI\Actions\ServiceActions.cs,ElevateIfRequired,The length of the statement  "				td.Content = "The action cannot be performed in the current security context. " + "Do you want Process Hacker to prompt for the appropriate credentials and elevate the action?"; " is 177.
Long Statement,ProcessHacker.UI.Actions,ServiceActions,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\UI\Actions\ServiceActions.cs,ElevateIfRequired,The length of the statement  "				Program.StartProcessHackerAdmin ("-e -type service -action " + action + " -obj \"" + service + "\" -hwnd " + window.Handle.ToString ()' null' window.Handle); " is 157.
Long Statement,ProcessHacker.UI.Actions,ServiceActions,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\UI\Actions\ServiceActions.cs,Start,The length of the statement  "		DialogResult r = MessageBox.Show (window' "Could not start the service \"" + service + "\":\n\n" + ex.Message' "Process Hacker"' MessageBoxButtons.OK' MessageBoxIcon.Error); " is 173.
Long Statement,ProcessHacker.UI.Actions,ServiceActions,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\UI\Actions\ServiceActions.cs,Continue,The length of the statement  "		DialogResult r = MessageBox.Show (window' "Could not continue the service \"" + service + "\":\n\n" + ex.Message' "Process Hacker"' MessageBoxButtons.OK' MessageBoxIcon.Error); " is 176.
Long Statement,ProcessHacker.UI.Actions,ServiceActions,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\UI\Actions\ServiceActions.cs,Pause,The length of the statement  "		DialogResult r = MessageBox.Show (window' "Could not pause the service \"" + service + "\":\n\n" + ex.Message' "Process Hacker"' MessageBoxButtons.OK' MessageBoxIcon.Error); " is 173.
Long Statement,ProcessHacker.UI.Actions,ServiceActions,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\UI\Actions\ServiceActions.cs,Stop,The length of the statement  "		DialogResult r = MessageBox.Show (window' "Could not stop the service \"" + service + "\":\n\n" + ex.Message' "Process Hacker"' MessageBoxButtons.OK' MessageBoxIcon.Error); " is 172.
Long Statement,ProcessHacker.UI.Actions,ServiceActions,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\UI\Actions\ServiceActions.cs,Delete,The length of the statement  "	if (prompt && !Prompt (window' service' "delete"' "Deleting a service can prevent the system from starting or functioning properly. " + "Are you sure you want to continue?"' TaskDialogIcon.Warning)) " is 198.
Long Statement,ProcessHacker.UI.Actions,ServiceActions,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\UI\Actions\ServiceActions.cs,Delete,The length of the statement  "		DialogResult r = MessageBox.Show (window' "Could not delete the service \"" + service + "\":\n\n" + ex.Message' "Process Hacker"' MessageBoxButtons.OK' MessageBoxIcon.Error); " is 174.
Long Statement,ProcessHacker.UI.Actions,ProcessActions,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\UI\Actions\ProcessActions.cs,Prompt,The length of the statement  "			td.Content = "You are about to " + action + " one or more CRITICAL processes. " + "Windows is designed to break (crash) when one of these processes is terminated. " + "Are you sure you want to continue?"; " is 204.
Long Statement,ProcessHacker.UI.Actions,ProcessActions,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\UI\Actions\ProcessActions.cs,Prompt,The length of the statement  "			td.Content = "You are about to " + action + " one or more system processes. " + "Doing so will cause system instability. Are you sure you want to continue?"; " is 157.
Long Statement,ProcessHacker.UI.Actions,ProcessActions,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\UI\Actions\ProcessActions.cs,Prompt,The length of the statement  "				td.ExpandedInformation += names [i] + " (PID " + pids [i].ToString () + ")" + (dangerousPid ? " (system process) " : "") + (criticalPid ? " (CRITICAL) " : "") + "\r\n"; " is 168.
Long Statement,ProcessHacker.UI.Actions,ProcessActions,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\UI\Actions\ProcessActions.cs,Prompt,The length of the statement  "			result = MessageBox.Show ("You are about to " + action + " one or more CRITICAL processes. " + "Windows is designed to break (crash) when one of these processes is terminated. " + "Are you sure you want to " + action + " " + name + "?"' "Process Hacker"' MessageBoxButtons.YesNo' MessageBoxIcon.Exclamation' MessageBoxDefaultButton.Button2); " is 341.
Long Statement,ProcessHacker.UI.Actions,ProcessActions,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\UI\Actions\ProcessActions.cs,Prompt,The length of the statement  "			result = MessageBox.Show ("You are about to " + action + " one or more system processes. " + "Are you sure you want to " + action + " " + name + "?"' "Process Hacker"' MessageBoxButtons.YesNo' MessageBoxIcon.Exclamation' MessageBoxDefaultButton.Button2); " is 254.
Long Statement,ProcessHacker.UI.Actions,ProcessActions,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\UI\Actions\ProcessActions.cs,Prompt,The length of the statement  "			result = MessageBox.Show ("Are you sure you want to " + action + " " + name + "?"' "Process Hacker"' MessageBoxButtons.YesNo' MessageBoxIcon.Exclamation' MessageBoxDefaultButton.Button2); " is 187.
Long Statement,ProcessHacker.UI.Actions,ProcessActions,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\UI\Actions\ProcessActions.cs,PromptForElevation,The length of the statement  "	if (OSVersion.HasUac && Program.ElevationType == ProcessHacker.Native.Api.TokenElevationType.Limited && KProcessHacker.Instance == null) { " is 138.
Long Statement,ProcessHacker.UI.Actions,ProcessActions,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\UI\Actions\ProcessActions.cs,PromptForElevation,The length of the statement  "			td.Content = "The action cannot be performed in the current security context. " + "Do you want Process Hacker to prompt for the appropriate credentials and " + elevateAction + "?"; " is 180.
Long Statement,ProcessHacker.UI.Actions,ProcessActions,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\UI\Actions\ProcessActions.cs,ElevateIfRequired,The length of the statement  "		Program.StartProcessHackerAdmin ("-e -type process -action " + action + " -obj \"" + objects + "\" -hwnd " + window.Handle.ToString ()' null' window.Handle); " is 157.
Long Statement,ProcessHacker.UI.Actions,ProcessActions,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\UI\Actions\ProcessActions.cs,ShowProperties,The length of the statement  "			ProcessWindow pForm = Program.GetProcessWindow (Program.ProcessProvider.Dictionary [pid]' new Program.PWindowInvokeAction (delegate (ProcessWindow f) { " is 151.
Long Statement,ProcessHacker.UI.Actions,ProcessActions,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\UI\Actions\ProcessActions.cs,Terminate,The length of the statement  "	if (prompt && !Prompt (window' pids' names' "terminate"' "Terminating a process will cause unsaved data to be lost. " + "Terminating a system process will cause system instability. " + "Are you sure you want to continue?"' false)) " is 230.
Long Statement,ProcessHacker.UI.Actions,ProcessActions,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\UI\Actions\ProcessActions.cs,TerminateTree,The length of the statement  "	}' "terminate"' "Terminating a process tree will cause the process and its descendants to be terminated. " + "Are you sure you want to continue?"' false)) " is 154.
Long Statement,ProcessHacker.UI.Actions,ProcessActions,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\UI\Actions\ProcessActions.cs,TerminateTree,The length of the statement  "		PhUtils.ShowException ("Unable to terminate the process \"" + processes [pid].Name + "\" with PID " + pid.ToString ()' ex); " is 123.
Long Statement,ProcessHacker.UI.Actions,ProcessActions,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\UI\Actions\ProcessActions.cs,Suspend,The length of the statement  "	if (prompt && !Prompt (window' pids' names' "suspend"' "Suspending a process will pause its execution. " + "Suspending a system process will cause system instability. " + "Are you sure you want to continue?"' true)) " is 215.
Long Statement,ProcessHacker.UI.Actions,ProcessActions,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\UI\Actions\ProcessActions.cs,Resume,The length of the statement  "	if (prompt && !Prompt (window' pids' names' "resume"' "Resuming a process will begin its execution. " + "Resuming a system process may lead to system instability. " + "Are you sure you want to continue?"' true)) " is 211.
Long Statement,ProcessHacker.UI.Actions,ProcessActions,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\UI\Actions\ProcessActions.cs,ReduceWorkingSet,The length of the statement  "	if (ElevateIfRequired (window' pids' names' ProcessAccess.QueryInformation | ProcessAccess.SetQuota' "reduceworkingset")) " is 121.
Long Statement,ProcessHacker.UI.Actions,ProcessActions,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\UI\Actions\ProcessActions.cs,ReduceWorkingSet,The length of the statement  "	if (prompt && !Prompt (window' pids' names' "reduce the working set of"' "Reducing the working set of a process reduces its physical memory consumption. " + "Are you sure you want to continue?"' true)) " is 201.
Long Statement,ProcessHacker.UI,GenericViewMenu,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\UI\GenericViewMenu.cs,ListViewMenuItem_Click,The length of the statement  "	ListViewCopy ((ListView)((object[])mitem.Tag) [1]' (int)((object[])mitem.Tag) [0]' (RetrieveVirtualItemEventHandler)((object[])mitem.Tag) [2]); " is 143.
Long Statement,ProcessHacker.UI,ColumnSettings,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\UI\ColumnSettings.cs,SaveSettings,The length of the statement  "			result.Append (c.Header + "'" + c.Width.ToString () + "'" + c.SortOrder.ToString () + "'" + c.IsVisible.ToString () + "|"); " is 123.
Long Statement,ProcessHacker.FormHelper,HandleFilter,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\UI\Async\HandleFilter.cs,DoFilter,The length of the statement  "				using (var phandle = new ProcessHandle (process.Key' Program.MinProcessQueryRights | Program.MinProcessReadMemoryRights)) { " is 123.
Long Statement,ProcessHacker.FormHelper,HandleFilter,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\UI\Async\HandleFilter.cs,DoFilter,The length of the statement  "				using (var phandle = new ProcessHandle (process.Key' ProcessAccess.QueryInformation | Program.MinProcessReadMemoryRights)) { " is 124.
Long Statement,ProcessHacker.FormHelper,HandleFilter,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\UI\Async\HandleFilter.cs,CompareHandleBestNameWithFilter,The length of the statement  "			processHandles.Add (currhandle.ProcessId' new ProcessHandle (currhandle.ProcessId' Program.MinProcessGetHandleInformationRights)); " is 130.
Long Statement,ProcessHacker.FormHelper,HandleFilter,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\UI\Async\HandleFilter.cs,CompareHandleBestNameWithFilter,The length of the statement  "		if ((info.BestName != null && info.BestName.ToLowerInvariant ().Contains (strFilterLower)) || (intPtrFilter != IntPtr.Zero && currhandle.Object == intPtrFilter)) { " is 163.
Long Statement,Debugger.Wrappers,Util,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\SharpDevelop\Wrappers\Util.cs,GetString,The length of the statement  "	//Console.WriteLine("Marshaled string from COM: \"" + managedString + "\" lenght=" + managedString.Length + " arrayLenght=" + exactLenght); " is 139.
Long Statement,ProcessHacker.Native.Symbols,SymbolProviderExtensions,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Symbols\SymbolProviderExtensions.cs,ShowWarning,The length of the statement  "					td.Content = "Process Hacker is not configured correctly to obtain debugging symbols. " + "If you do not require proper symbol support' you may ignore this warning."; " is 166.
Long Statement,ProcessHacker.Native.Symbols,SymbolProviderExtensions,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Symbols\SymbolProviderExtensions.cs,ShowWarning,The length of the statement  "					td.ExpandedInformation = "To ensure you have the latest version of dbghelp.dll' download " + "<a href=\"dbghelp\">Debugging " + "Tools for Windows</a> and configure Process Hacker to " + "use its version of dbghelp.dll. If you have the latest version of dbghelp.dll' " + "ensure that symsrv.dll resides in the same directory as dbghelp.dll."; " is 342.
Long Statement,ProcessHacker.Native.Symbols,SymbolProviderExtensions,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Symbols\SymbolProviderExtensions.cs,ShowWarning,The length of the statement  "								MessageBox.Show ("Could not open the hyperlink: " + ex.ToString ()' "Process Hacker"' MessageBoxButtons.OK' MessageBoxIcon.Error); " is 130.
Long Statement,ProcessHacker.Native.Symbols,SymbolProviderExtensions,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Symbols\SymbolProviderExtensions.cs,LoadProcessWow64Modules,The length of the statement  "		buffer.Query (pid' ProcessHacker.Native.Api.RtlQueryProcessDebugFlags.Modules32 | ProcessHacker.Native.Api.RtlQueryProcessDebugFlags.NonInvasive); " is 146.
Long Statement,ProcessHacker.Structs,StructDef,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Structs\StructDef.cs,Read,The length of the statement  "			_fieldsByName [field.SetsVarOn].VarLength = field.SetsVarOnAdd + (int)(int.Parse (value.Value.ToString ()) * (decimal)field.SetsVarOnMultiply); " is 143.
Long Statement,ProcessHacker.Structs,StructDef,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Structs\StructDef.cs,Read,The length of the statement  "			_fieldsByName [field.SetsVarOn].VarArrayLength = field.SetsVarOnAdd + (int)(int.Parse (value.Value.ToString ()) * (decimal)field.SetsVarOnMultiply); " is 148.
Long Statement,ProcessHacker.Structs,StructParser,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Structs\StructParser.cs,EatNumber,The length of the statement  "			if (!(char.IsDigit (text [i]) || char.ToLower (text [i]) == 'a' || char.ToLower (text [i]) == 'b' || char.ToLower (text [i]) == 'c' || char.ToLower (text [i]) == 'd' || char.ToLower (text [i]) == 'e' || char.ToLower (text [i]) == 'f')) " is 235.
Complex Conditional,Be.Windows.Forms,HexBox,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\Be.Windows.Forms.HexBox\HexBox.cs,UpdateScrollSize,The conditional expression  "VScrollBarVisible && _byteProvider != null && _byteProvider.Length > 0 && _iHexMaxHBytes != 0"  is complex.
Complex Conditional,Be.Windows.Forms,HexBox,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\Be.Windows.Forms.HexBox\HexBox.cs,CreateCaret,The conditional expression  "_byteProvider == null || _keyInterpreter == null || _caretVisible || !this.Focused"  is complex.
Complex Conditional,Be.Windows.Forms,HexBox,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\Be.Windows.Forms.HexBox\HexBox.cs,PaintCurrentBytesSign,The conditional expression  "_keyInterpreter != null && Focused && _bytePos != -1 && Enabled"  is complex.
Complex Conditional,Be.Windows.Forms,HexBox,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\Be.Windows.Forms.HexBox\HexBox.cs,PaintCurrentByteSign,The conditional expression  "rec.Top < 0 || rec.Left < 0 || rec.Width <= 0 || rec.Height <= 0"  is complex.
Complex Conditional,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,serviceP_DictionaryModified,The conditional expression  "(oldState == ServiceState.Paused || oldState == ServiceState.Stopped || oldState == ServiceState.StartPending) && newState == ServiceState.Running"  is complex.
Complex Conditional,ProcessHacker,Program,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\Program.cs,Main,The conditional expression  "Settings.Instance.AllowOnlyOneInstance && !(pArgs.ContainsKey ("-e") || pArgs.ContainsKey ("-o") || pArgs.ContainsKey ("-pw") || pArgs.ContainsKey ("-pt"))"  is complex.
Complex Conditional,ProcessHacker,Program,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\Program.cs,Main,The conditional expression  "OSVersion.Architecture == OSArch.I386 && Settings.Instance.EnableKPH && !NoKph && // Don't load KPH if we're going to install/uninstall it.  !pArgs.ContainsKey ("-installkph") && !pArgs.ContainsKey ("-uninstallkph")"  is complex.
Complex Conditional,ProcessHacker,VistaSearchBox,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\VistaSearchBox.cs,searchImage_MouseMove,The conditional expression  "e.X < 0 || e.X > searchImage.Width || e.Y < 0 || e.Y > searchImage.Height"  is complex.
Complex Conditional,ProcessHacker,ProcessTree,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ProcessTree\ProcessTree.cs,GetProcessColor,The conditional expression  "Settings.Instance.UseColorPackedProcesses && Settings.Instance.VerifySignatures && p.Name != null && Program.ImposterNames.Contains (p.Name.ToLowerInvariant ()) && p.VerifyResult != VerifyResult.Trusted && p.VerifyResult != VerifyResult.Unknown && p.FileName != null"  is complex.
Complex Conditional,ProcessHacker,ProcessTree,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ProcessTree\ProcessTree.cs,GetProcessColor,The conditional expression  "Settings.Instance.UseColorPackedProcesses && Settings.Instance.VerifySignatures && p.VerifyResult != VerifyResult.Trusted && p.VerifyResult != VerifyResult.NoSignature && p.VerifyResult != VerifyResult.Unknown"  is complex.
Complex Conditional,ProcessHacker,ProcessTree,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ProcessTree\ProcessTree.cs,GetProcessColor,The conditional expression  "_dumpMode && Settings.Instance.UseColorServiceProcesses && DumpProcessServices.ContainsKey (p.Pid) && DumpProcessServices [p.Pid].Count > 0"  is complex.
Complex Conditional,ProcessHacker,ProcessTree,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ProcessTree\ProcessTree.cs,GetProcessColor,The conditional expression  "!_dumpMode && Settings.Instance.UseColorServiceProcesses && Program.HackerWindow.ProcessServices.ContainsKey (p.Pid) && Program.HackerWindow.ProcessServices [p.Pid].Count > 0"  is complex.
Complex Conditional,ProcessHacker,ProcessWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\ProcessWindow.cs,ProcessWindow_FormClosing,The conditional expression  "(this.Location.X < p.X && this.Location.Y < p.Y && Program.PWindows.Count > 1) || Program.PWindows.Count <= 1"  is complex.
Complex Conditional,ProcessHacker,ProcessSystemProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ProcessSystemProvider.cs,QueryProcessStage2,The conditional expression  "libraryTotal < 3 && funcTotal < 5 || ((float)funcTotal / libraryTotal < 4) && libraryTotal > 3 && libraryTotal < 30"  is complex.
Complex Conditional,ProcessHacker,MemoryProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\MemoryProvider.cs,Update,The conditional expression  "info.RegionSize.ToInt64 () != item.Size || info.Type != item.Type || info.State != item.State || info.Protect != item.Protection"  is complex.
Complex Conditional,ProcessHacker,ThreadProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ThreadProvider.cs,Update,The conditional expression  "newitem.ContextSwitches != item.ContextSwitches || newitem.ContextSwitchesDelta != item.ContextSwitchesDelta || newitem.Cycles != item.Cycles || newitem.CyclesDelta != item.CyclesDelta || newitem.IsGuiThread != item.IsGuiThread || newitem.Priority != item.Priority || newitem.StartAddress != item.StartAddress || newitem.WaitReason != item.WaitReason || item.JustResolved"  is complex.
Complex Conditional,ProcessHacker,StringSearcher,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Searchers\StringSearcher.cs,Search,The conditional expression  "unicode && isChar && isUnicode && byte1 != 0"  is complex.
Complex Conditional,ProcessHacker,StringSearcher,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Searchers\StringSearcher.cs,Search,The conditional expression  "unicode && data [i] == 0 && IsChar (byte1) && !IsChar (byte2)"  is complex.
Complex Conditional,ProcessHacker,StringSearcher,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Searchers\StringSearcher.cs,Search,The conditional expression  "unicode && data [i] == 0 && IsChar (byte1) && IsChar (byte2) && curstr.Length < minsize"  is complex.
Complex Conditional,ProcessHacker.Components,DotNetCounters,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\DotNetCounters.cs,UpdateCounters,The conditional expression  "(counter.CounterType == PerformanceCounterType.NumberOfItems32 || counter.CounterType == PerformanceCounterType.NumberOfItems64 || counter.CounterType == PerformanceCounterType.RawFraction) && counter.CounterName != "Not Displayed""  is complex.
Complex Conditional,ProcessHacker.Components,DotNetCounters,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\DotNetCounters.cs,UpdateInfo,The conditional expression  "(counter.CounterType == PerformanceCounterType.NumberOfItems32 || counter.CounterType == PerformanceCounterType.NumberOfItems64 || counter.CounterType == PerformanceCounterType.RawFraction) && counter.CounterName != "Not Displayed""  is complex.
Complex Conditional,ProcessHacker.Components,NodePlotter,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\NodePlotter.cs,Draw,The conditional expression  "(_plotter.Width != context.Bounds.Width - 1 || _plotter.Height != context.Bounds.Height - 1) && context.Bounds.Width > 1 && context.Bounds.Height > 1"  is complex.
Complex Conditional,ProcessHacker.Components,Plotter,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\Plotter.cs,Draw,The conditional expression  "_useLongData && (_longData1 == null || (this.UseSecondLine && _longData2 == null))"  is complex.
Complex Conditional,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,analyzeWaitMenuItem_Click,The conditional expression  "name.StartsWith ("ntdll.dll!zwreadfile") || name.StartsWith ("ntdll.dll!ntreadfile") || name.StartsWith ("ntdll.dll!zwwritefile") || name.StartsWith ("ntdll.dll!ntwritefile")"  is complex.
Complex Conditional,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,analyzeWaitMenuItem_Click,The conditional expression  "name.StartsWith ("ntdll.dll!zwreplywaitreceiveport") || name.StartsWith ("ntdll.dll!ntreplywaitreceiveport") || name.StartsWith ("ntdll.dll!zwrequestwaitreplyport") || name.StartsWith ("ntdll.dll!ntrequestwaitreplyport") || name.StartsWith ("ntdll.dll!zwalpcsendwaitreceiveport") || name.StartsWith ("ntdll.dll!ntalpcsendwaitreceiveport")"  is complex.
Complex Conditional,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,analyzeWaitMenuItem_Click,The conditional expression  "name.StartsWith ("ntdll.dll!zwsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!ntsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!zwsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!ntsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaithigheventpair") || name.StartsWith ("ntdll.dll!ntwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaitloweventpair") || name.StartsWith ("ntdll.dll!ntwaitloweventpair")"  is complex.
Complex Conditional,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,analyzeWaitMenuItem_Click,The conditional expression  "name.StartsWith ("ntdll.dll!zwwaitforkeyedevent") || name.StartsWith ("ntdll.dll!ntwaitforkeyedevent") || name.StartsWith ("ntdll.dll!zwreleasekeyedevent") || name.StartsWith ("ntdll.dll!ntreleasekeyedevent")"  is complex.
Complex Conditional,ProcessHacker.FormHelper,HandleFilter,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\UI\Async\HandleFilter.cs,CompareHandleBestNameWithFilter,The conditional expression  "(info.BestName != null && info.BestName.ToLowerInvariant ().Contains (strFilterLower)) || (intPtrFilter != IntPtr.Zero && currhandle.Object == intPtrFilter)"  is complex.
Complex Conditional,ProcessHacker.Structs,StructParser,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Structs\StructParser.cs,EatWhitespace,The conditional expression  "!(text [i] == '\r' || text [i] == '\n' || text [i] == ' ' || text [i] == '\t') && !inComment"  is complex.
Complex Conditional,ProcessHacker.Structs,StructParser,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Structs\StructParser.cs,EatNumber,The conditional expression  "!(char.IsDigit (text [i]) || char.ToLower (text [i]) == 'a' || char.ToLower (text [i]) == 'b' || char.ToLower (text [i]) == 'c' || char.ToLower (text [i]) == 'd' || char.ToLower (text [i]) == 'e' || char.ToLower (text [i]) == 'f')"  is complex.
Empty Catch Block,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,menuProcess_Popup,The method has an empty catch block.
Empty Catch Block,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,terminateMenuItem_Click,The method has an empty catch block.
Empty Catch Block,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,terminateProcessTreeMenuItem_Click,The method has an empty catch block.
Empty Catch Block,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,processP_Updated,The method has an empty catch block.
Empty Catch Block,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,processP_Updated,The method has an empty catch block.
Empty Catch Block,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,LoadOtherSettings,The method has an empty catch block.
Empty Catch Block,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,WndProc,The method has an empty catch block.
Empty Catch Block,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,Exit,The method has an empty catch block.
Empty Catch Block,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,LoadOther,The method has an empty catch block.
Empty Catch Block,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,Painting,The method has an empty catch block.
Empty Catch Block,ProcessHacker,Program,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\Program.cs,Main,The method has an empty catch block.
Empty Catch Block,ProcessHacker,Program,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\Program.cs,Main,The method has an empty catch block.
Empty Catch Block,ProcessHacker,Program,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\Program.cs,LoadSettings,The method has an empty catch block.
Empty Catch Block,ProcessHacker,Program,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\Program.cs,ProcessCommandLine,The method has an empty catch block.
Empty Catch Block,ProcessHacker,Program,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\Program.cs,ProcessCommandLine,The method has an empty catch block.
Empty Catch Block,ProcessHacker,Program,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\Program.cs,ProcessCommandLine,The method has an empty catch block.
Empty Catch Block,ProcessHacker,Program,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\Program.cs,CheckPreviousInstance,The method has an empty catch block.
Empty Catch Block,ProcessHacker,DumpServiceWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\DumpServiceWindow.cs,DumpServiceWindow,The method has an empty catch block.
Empty Catch Block,ProcessHacker,HeapsWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HeapsWindow.cs,HeapsWindow,The method has an empty catch block.
Empty Catch Block,ProcessHacker,ProtectProcessWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\ProtectProcessWindow.cs,buttonOK_Click,The method has an empty catch block.
Empty Catch Block,ProcessHacker,ProtectProcessWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\ProtectProcessWindow.cs,buttonOK_Click,The method has an empty catch block.
Empty Catch Block,ProcessHacker,NetInfoWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\NetInfoWindow.cs,timer1_Tick,The method has an empty catch block.
Empty Catch Block,ProcessHacker,Dump,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\Dump.cs,DumpProcess,The method has an empty catch block.
Empty Catch Block,ProcessHacker,Dump,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\Dump.cs,DumpProcess,The method has an empty catch block.
Empty Catch Block,ProcessHacker,Dump,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\Dump.cs,DumpProcess,The method has an empty catch block.
Empty Catch Block,ProcessHacker,Dump,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\Dump.cs,DumpProcess,The method has an empty catch block.
Empty Catch Block,ProcessHacker,Dump,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\Dump.cs,DumpProcess,The method has an empty catch block.
Empty Catch Block,ProcessHacker,Dump,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\Dump.cs,DumpProcess,The method has an empty catch block.
Empty Catch Block,ProcessHacker,Dump,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\Dump.cs,DumpProcess,The method has an empty catch block.
Empty Catch Block,ProcessHacker,Dump,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\Dump.cs,DumpProcess,The method has an empty catch block.
Empty Catch Block,ProcessHacker,Dump,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\Dump.cs,DumpProcess,The method has an empty catch block.
Empty Catch Block,ProcessHacker,Dump,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\Dump.cs,DumpProcessModules,The method has an empty catch block.
Empty Catch Block,ProcessHacker,Dump,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\Dump.cs,DumpProcessModules,The method has an empty catch block.
Empty Catch Block,ProcessHacker,Dump,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\Dump.cs,DumpProcessModule,The method has an empty catch block.
Empty Catch Block,ProcessHacker,Dump,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\Dump.cs,DumpProcessToken,The method has an empty catch block.
Empty Catch Block,ProcessHacker,Dump,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\Dump.cs,DumpProcessHandles,The method has an empty catch block.
Empty Catch Block,ProcessHacker,Dump,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\Dump.cs,DumpServices,The method has an empty catch block.
Empty Catch Block,ProcessHacker,Dump,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\Dump.cs,DumpServices,The method has an empty catch block.
Empty Catch Block,ProcessHacker,Provider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\Provider.cs,Run,The method has an empty catch block.
Empty Catch Block,ProcessHacker,Provider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\Provider.cs,Run,The method has an empty catch block.
Empty Catch Block,ProcessHacker,Provider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\Provider.cs,Run,The method has an empty catch block.
Empty Catch Block,ProcessHacker,ProcessNode,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ProcessTree\ProcessNode.cs,GetWorkingSetNumber,The method has an empty catch block.
Empty Catch Block,ProcessHacker,ExtendedCmd,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\ExtendedCmd.cs,Run,The method has an empty catch block.
Empty Catch Block,ProcessHacker,ExtendedCmd,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\ExtendedCmd.cs,Run,The method has an empty catch block.
Empty Catch Block,ProcessHacker,HiddenProcessesWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HiddenProcessesWindow.cs,AddProcessItem,The method has an empty catch block.
Empty Catch Block,ProcessHacker,HiddenProcessesWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HiddenProcessesWindow.cs,GetCsrProcesses,The method has an empty catch block.
Empty Catch Block,ProcessHacker,HiddenProcessesWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HiddenProcessesWindow.cs,OpenProcessCsr,The method has an empty catch block.
Empty Catch Block,ProcessHacker,EditDEPWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\EditDEPWindow.cs,EditDEPWindow,The method has an empty catch block.
Empty Catch Block,ProcessHacker,LogWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\LogWindow.cs,UpdateLog,The method has an empty catch block.
Empty Catch Block,ProcessHacker,ProcessWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\ProcessWindow.cs,LoadStage1,The method has an empty catch block.
Empty Catch Block,ProcessHacker,ProcessWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\ProcessWindow.cs,InitializeSubControls,The method has an empty catch block.
Empty Catch Block,ProcessHacker,ProcessWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\ProcessWindow.cs,InitializeSubControls,The method has an empty catch block.
Empty Catch Block,ProcessHacker,ProcessWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\ProcessWindow.cs,InitializeSubControls,The method has an empty catch block.
Empty Catch Block,ProcessHacker,ProcessWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\ProcessWindow.cs,UpdateEnvironmentVariables,The method has an empty catch block.
Empty Catch Block,ProcessHacker,ProcessWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\ProcessWindow.cs,buttonInspectPEB_Click,The method has an empty catch block.
Empty Catch Block,ProcessHacker,ProcessWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\ProcessWindow.cs,inspectImageFileMenuItem_Click,The method has an empty catch block.
Empty Catch Block,ProcessHacker,ProcessWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\ProcessWindow.cs,ProcessProvider_Updated,The method has an empty catch block.
Empty Catch Block,ProcessHacker,SysInfoWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\SysInfoWindow.cs,SysInfoWindow,The method has an empty catch block.
Empty Catch Block,ProcessHacker,SysInfoWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\SysInfoWindow.cs,UpdateInfo,The method has an empty catch block.
Empty Catch Block,ProcessHacker,TerminatorWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\TerminatorWindow.cs,CH1,The method has an empty catch block.
Empty Catch Block,ProcessHacker,TerminatorWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\TerminatorWindow.cs,M1Internal,The method has an empty catch block.
Empty Catch Block,ProcessHacker,TerminatorWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\TerminatorWindow.cs,TJ1,The method has an empty catch block.
Empty Catch Block,ProcessHacker,TerminatorWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\TerminatorWindow.cs,TP1a,The method has an empty catch block.
Empty Catch Block,ProcessHacker,TerminatorWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\TerminatorWindow.cs,TT1a,The method has an empty catch block.
Empty Catch Block,ProcessHacker,TerminatorWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\TerminatorWindow.cs,TT2,The method has an empty catch block.
Empty Catch Block,ProcessHacker,RunWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\RunWindow.cs,RunWindow,The method has an empty catch block.
Empty Catch Block,ProcessHacker,RunWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\RunWindow.cs,buttonBrowse_Click,The method has an empty catch block.
Empty Catch Block,ProcessHacker,RunWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\RunWindow.cs,buttonOK_Click,The method has an empty catch block.
Empty Catch Block,ProcessHacker,RunWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\RunWindow.cs,buttonOK_Click,The method has an empty catch block.
Empty Catch Block,ProcessHacker,ProcessSystemProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ProcessSystemProvider.cs,QueryProcessStage1,The method has an empty catch block.
Empty Catch Block,ProcessHacker,ProcessSystemProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ProcessSystemProvider.cs,QueryProcessStage1,The method has an empty catch block.
Empty Catch Block,ProcessHacker,ProcessSystemProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ProcessSystemProvider.cs,QueryProcessStage1,The method has an empty catch block.
Empty Catch Block,ProcessHacker,ProcessSystemProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ProcessSystemProvider.cs,QueryProcessStage1,The method has an empty catch block.
Empty Catch Block,ProcessHacker,ProcessSystemProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ProcessSystemProvider.cs,QueryProcessStage1,The method has an empty catch block.
Empty Catch Block,ProcessHacker,ProcessSystemProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ProcessSystemProvider.cs,QueryProcessStage1,The method has an empty catch block.
Empty Catch Block,ProcessHacker,ProcessSystemProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ProcessSystemProvider.cs,QueryProcessStage1,The method has an empty catch block.
Empty Catch Block,ProcessHacker,ProcessSystemProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ProcessSystemProvider.cs,QueryProcessStage1,The method has an empty catch block.
Empty Catch Block,ProcessHacker,ProcessSystemProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ProcessSystemProvider.cs,QueryProcessStage1,The method has an empty catch block.
Empty Catch Block,ProcessHacker,ProcessSystemProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ProcessSystemProvider.cs,QueryProcessStage1,The method has an empty catch block.
Empty Catch Block,ProcessHacker,ProcessSystemProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ProcessSystemProvider.cs,QueryProcessStage1a,The method has an empty catch block.
Empty Catch Block,ProcessHacker,ProcessSystemProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ProcessSystemProvider.cs,QueryProcessStage2,The method has an empty catch block.
Empty Catch Block,ProcessHacker,ProcessSystemProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ProcessSystemProvider.cs,QueryProcessStage2,The method has an empty catch block.
Empty Catch Block,ProcessHacker,ProcessSystemProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ProcessSystemProvider.cs,GetFileName,The method has an empty catch block.
Empty Catch Block,ProcessHacker,ProcessSystemProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ProcessSystemProvider.cs,GetFileName,The method has an empty catch block.
Empty Catch Block,ProcessHacker,ProcessSystemProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ProcessSystemProvider.cs,GetFileName,The method has an empty catch block.
Empty Catch Block,ProcessHacker,ProcessSystemProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ProcessSystemProvider.cs,GetFileName,The method has an empty catch block.
Empty Catch Block,ProcessHacker,ProcessSystemProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ProcessSystemProvider.cs,GetFileName,The method has an empty catch block.
Empty Catch Block,ProcessHacker,ProcessSystemProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ProcessSystemProvider.cs,GetFileName,The method has an empty catch block.
Empty Catch Block,ProcessHacker,ProcessSystemProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ProcessSystemProvider.cs,GetFileName,The method has an empty catch block.
Empty Catch Block,ProcessHacker,ProcessSystemProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ProcessSystemProvider.cs,Update,The method has an empty catch block.
Empty Catch Block,ProcessHacker,ProcessSystemProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ProcessSystemProvider.cs,Update,The method has an empty catch block.
Empty Catch Block,ProcessHacker,ProcessSystemProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ProcessSystemProvider.cs,Update,The method has an empty catch block.
Empty Catch Block,ProcessHacker,ProcessSystemProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ProcessSystemProvider.cs,Update,The method has an empty catch block.
Empty Catch Block,ProcessHacker,ProcessSystemProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ProcessSystemProvider.cs,Update,The method has an empty catch block.
Empty Catch Block,ProcessHacker,ProcessSystemProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ProcessSystemProvider.cs,Update,The method has an empty catch block.
Empty Catch Block,ProcessHacker,ProcessSystemProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ProcessSystemProvider.cs,Update,The method has an empty catch block.
Empty Catch Block,ProcessHacker,ProcessSystemProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ProcessSystemProvider.cs,Update,The method has an empty catch block.
Empty Catch Block,ProcessHacker,ProcessSystemProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ProcessSystemProvider.cs,Update,The method has an empty catch block.
Empty Catch Block,ProcessHacker,MemoryProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\MemoryProvider.cs,MemoryProvider,The method has an empty catch block.
Empty Catch Block,ProcessHacker,MemoryProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\MemoryProvider.cs,Update,The method has an empty catch block.
Empty Catch Block,ProcessHacker,ModuleProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ModuleProvider.cs,ModuleProvider,The method has an empty catch block.
Empty Catch Block,ProcessHacker,ModuleProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ModuleProvider.cs,ModuleProvider,The method has an empty catch block.
Empty Catch Block,ProcessHacker,ModuleProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ModuleProvider.cs,Update,The method has an empty catch block.
Empty Catch Block,ProcessHacker,ModuleProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ModuleProvider.cs,Update,The method has an empty catch block.
Empty Catch Block,ProcessHacker,ModuleProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ModuleProvider.cs,Update,The method has an empty catch block.
Empty Catch Block,ProcessHacker,HandleProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\HandleProvider.cs,HandleProvider,The method has an empty catch block.
Empty Catch Block,ProcessHacker,ServiceProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ServiceProvider.cs,Update,The method has an empty catch block.
Empty Catch Block,ProcessHacker,ThreadProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ThreadProvider.cs,LoadSymbols,The method has an empty catch block.
Empty Catch Block,ProcessHacker,ThreadProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ThreadProvider.cs,LoadSymbols,The method has an empty catch block.
Empty Catch Block,ProcessHacker,ThreadProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ThreadProvider.cs,ResolveThreadStartAddress,The method has an empty catch block.
Empty Catch Block,ProcessHacker,ThreadProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ThreadProvider.cs,Update,The method has an empty catch block.
Empty Catch Block,ProcessHacker,ThreadProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ThreadProvider.cs,Update,The method has an empty catch block.
Empty Catch Block,ProcessHacker,ThreadProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ThreadProvider.cs,Update,The method has an empty catch block.
Empty Catch Block,ProcessHacker,ThreadProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ThreadProvider.cs,Update,The method has an empty catch block.
Empty Catch Block,ProcessHacker,ThreadProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ThreadProvider.cs,Update,The method has an empty catch block.
Empty Catch Block,ProcessHacker,ThreadProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ThreadProvider.cs,Update,The method has an empty catch block.
Empty Catch Block,ProcessHacker,ThreadProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ThreadProvider.cs,Update,The method has an empty catch block.
Empty Catch Block,ProcessHacker,ThreadProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ThreadProvider.cs,Update,The method has an empty catch block.
Empty Catch Block,ProcessHacker,ThreadProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ThreadProvider.cs,Update,The method has an empty catch block.
Empty Catch Block,ProcessHacker,MemoryEditor,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\MemoryEditor.cs,textSearchMemory_TextChanged,The method has an empty catch block.
Empty Catch Block,ProcessHacker,MemoryEditor,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\MemoryEditor.cs,buttonGoToMemory_Click,The method has an empty catch block.
Empty Catch Block,ProcessHacker,MemoryEditor,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\MemoryEditor.cs,buttonStruct_Click,The method has an empty catch block.
Empty Catch Block,ProcessHacker,ResultsWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\ResultsWindow.cs,listResults_DoubleClick,The method has an empty catch block.
Empty Catch Block,ProcessHacker,ResultsWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\ResultsWindow.cs,listResults_DoubleClick,The method has an empty catch block.
Empty Catch Block,ProcessHacker,ThreadWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\ThreadWindow.cs,WalkStackCallback,The method has an empty catch block.
Empty Catch Block,ProcessHacker,StructSearcher,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Searchers\StructSearcher.cs,Search,The method has an empty catch block.
Empty Catch Block,ProcessHacker,OptionsWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\OptionsWindow.cs,LoadSettings,The method has an empty catch block.
Empty Catch Block,ProcessHacker.Common,PhUtils,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Common\PhUtils.cs,IsDangerousPid,The method has an empty catch block.
Empty Catch Block,ProcessHacker.Components,DotNetCounters,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\DotNetCounters.cs,Initialize,The method has an empty catch block.
Empty Catch Block,ProcessHacker.Components,ProcessStatistics,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ProcessStatistics.cs,UpdateStatistics,The method has an empty catch block.
Empty Catch Block,ProcessHacker.Components,JobProperties,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\JobProperties.cs,JobProperties,The method has an empty catch block.
Empty Catch Block,ProcessHacker.Components,JobProperties,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\JobProperties.cs,JobProperties,The method has an empty catch block.
Empty Catch Block,ProcessHacker.Components,JobProperties,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\JobProperties.cs,JobProperties,The method has an empty catch block.
Empty Catch Block,ProcessHacker.Components,JobProperties,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\JobProperties.cs,UpdateStatistics,The method has an empty catch block.
Empty Catch Block,ProcessHacker.Components,MemoryList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\MemoryList.cs,dumpMemoryMenuItem_Click,The method has an empty catch block.
Empty Catch Block,ProcessHacker.Components,ModuleList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ModuleList.cs,unloadMenuItem_Click,The method has an empty catch block.
Empty Catch Block,ProcessHacker.Components,HandleList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\HandleList.cs,ShowHandleProperties,The method has an empty catch block.
Empty Catch Block,ProcessHacker.Components,ServiceProperties,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ServiceProperties.cs,UpdateInformation,The method has an empty catch block.
Empty Catch Block,ProcessHacker.Components,ServiceProperties,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ServiceProperties.cs,UpdateInformation,The method has an empty catch block.
Empty Catch Block,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,listThreads_SelectedIndexChanged,The method has an empty catch block.
Empty Catch Block,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,listThreads_SelectedIndexChanged,The method has an empty catch block.
Empty Catch Block,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,inspectThreadMenuItem_Click,The method has an empty catch block.
Empty Catch Block,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,tokenThreadMenuItem_Click,The method has an empty catch block.
Empty Catch Block,ProcessHackerRestartRecovery,ApplicationRestartRecoveryManager,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\RestartRecoveryLib\RestartRecoveryManager.cs,RecoveryProcedure,The method has an empty catch block.
Empty Catch Block,TaskbarLib,JumpListManager,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\TaskbarLib\JumpLists\JumpListManager.cs,ClearApplicationDestinations,The method has an empty catch block.
Empty Catch Block,TaskbarLib,JumpListManager,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\TaskbarLib\JumpLists\JumpListManager.cs,GetApplicationDestinations,The method has an empty catch block.
Empty Catch Block,TaskbarLib,JumpListManager,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\TaskbarLib\JumpLists\JumpListManager.cs,ClearCustomDestinations,The method has an empty catch block.
Empty Catch Block,TaskbarLib,JumpListManager,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\TaskbarLib\JumpLists\JumpListManager.cs,BeginList,The method has an empty catch block.
Empty Catch Block,ProcessHacker.UI.Actions,ProcessActions,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\UI\Actions\ProcessActions.cs,Prompt,The method has an empty catch block.
Empty Catch Block,ProcessHacker.UI,ColumnSettings,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\UI\ColumnSettings.cs,SaveSettings,The method has an empty catch block.
Empty Catch Block,ProcessHacker.UI,ColumnSettings,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\UI\ColumnSettings.cs,SaveSettings,The method has an empty catch block.
Empty Catch Block,ProcessHacker.UI,ColumnSettings,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\UI\ColumnSettings.cs,LoadSettings,The method has an empty catch block.
Empty Catch Block,ProcessHacker.FormHelper,AsyncOperation,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\UI\Async\AsyncUtils.cs,InternalStart,The method has an empty catch block.
Empty Catch Block,ProcessHacker.FormHelper,HandleFilter,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\UI\Async\HandleFilter.cs,HandleFilter,The method has an empty catch block.
Empty Catch Block,Debugger.Wrappers,ResourceManager,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\SharpDevelop\Wrappers\ResourceManager.cs,ReleaseCOMObject,The method has an empty catch block.
Empty Catch Block,ProcessHacker.Structs,ProcessMemoryIO,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Structs\ProcessMemoryIO.cs,ProcessMemoryIO,The method has an empty catch block.
Empty Catch Block,ProcessHacker.Structs,ProcessMemoryIO,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Structs\ProcessMemoryIO.cs,ProcessMemoryIO,The method has an empty catch block.
Magic Number,Be.Windows.Forms,HexBox,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\Be.Windows.Forms.HexBox\HexBox.cs,HexBox,The following statement contains a magic number: _thumbTrackTimer.Interval = 50;  
Magic Number,Be.Windows.Forms,HexBox,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\Be.Windows.Forms.HexBox\HexBox.cs,ToScrollPos,The following statement contains a magic number: if (_scrollVmax < max)  	return (int)value;  else {  	double valperc = (double)value / (double)_scrollVmax * (double)100;  	int res = (int)Math.Floor ((double)max / (double)100 * valperc);  	res = (int)Math.Max (_scrollVmin' res);  	res = (int)Math.Min (_scrollVmax' res);  	return res;  }  
Magic Number,Be.Windows.Forms,HexBox,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\Be.Windows.Forms.HexBox\HexBox.cs,ToScrollPos,The following statement contains a magic number: if (_scrollVmax < max)  	return (int)value;  else {  	double valperc = (double)value / (double)_scrollVmax * (double)100;  	int res = (int)Math.Floor ((double)max / (double)100 * valperc);  	res = (int)Math.Max (_scrollVmin' res);  	res = (int)Math.Min (_scrollVmax' res);  	return res;  }  
Magic Number,Be.Windows.Forms,HexBox,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\Be.Windows.Forms.HexBox\HexBox.cs,FromScrollPos,The following statement contains a magic number: if (_scrollVmax < max) {  	return (long)value;  }  else {  	double valperc = (double)value / (double)max * (double)100;  	long res = (int)Math.Floor ((double)_scrollVmax / (double)100 * valperc);  	return res;  }  
Magic Number,Be.Windows.Forms,HexBox,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\Be.Windows.Forms.HexBox\HexBox.cs,FromScrollPos,The following statement contains a magic number: if (_scrollVmax < max) {  	return (long)value;  }  else {  	double valperc = (double)value / (double)max * (double)100;  	long res = (int)Math.Floor ((double)_scrollVmax / (double)100 * valperc);  	return res;  }  
Magic Number,Be.Windows.Forms,HexBox,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\Be.Windows.Forms.HexBox\HexBox.cs,GetHexBytePositionInfo,The following statement contains a magic number: byteCharaterPos = (iX % 3);  
Magic Number,Be.Windows.Forms,HexBox,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\Be.Windows.Forms.HexBox\HexBox.cs,Find,The following statement contains a magic number: for (long pos = startIndex; pos < _byteProvider.Length; pos++) {  	if (_abortFind)  		return -2;  	if (pos % 1000 == 0)  		// for performance reasons: DoEvents only 1 times per 1000 loops  		Application.DoEvents ();  	if (_byteProvider.ReadByte (pos) != bytes [match]) {  		pos -= match;  		match = 0;  		_findingPos = pos;  		continue;  	}  	match++;  	if (match == bytesLength) {  		long bytePos = pos - bytesLength + 1;  		Select (bytePos' bytesLength);  		ScrollByteIntoView (_bytePos + _selectionLength);  		ScrollByteIntoView (_bytePos);  		return bytePos;  	}  }  
Magic Number,Be.Windows.Forms,HexBox,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\Be.Windows.Forms.HexBox\HexBox.cs,Find,The following statement contains a magic number: for (long pos = startIndex; pos < _byteProvider.Length; pos++) {  	if (_abortFind)  		return -2;  	if (pos % 1000 == 0)  		// for performance reasons: DoEvents only 1 times per 1000 loops  		Application.DoEvents ();  	if (_byteProvider.ReadByte (pos) != bytes [match]) {  		pos -= match;  		match = 0;  		_findingPos = pos;  		continue;  	}  	match++;  	if (match == bytesLength) {  		long bytePos = pos - bytesLength + 1;  		Select (bytePos' bytesLength);  		ScrollByteIntoView (_bytePos + _selectionLength);  		ScrollByteIntoView (_bytePos);  		return bytePos;  	}  }  
Magic Number,Be.Windows.Forms,HexBox,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\Be.Windows.Forms.HexBox\HexBox.cs,Find,The following statement contains a magic number: if (_abortFind)  	return -2;  
Magic Number,Be.Windows.Forms,HexBox,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\Be.Windows.Forms.HexBox\HexBox.cs,Find,The following statement contains a magic number: return -2;  
Magic Number,Be.Windows.Forms,HexBox,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\Be.Windows.Forms.HexBox\HexBox.cs,Find,The following statement contains a magic number: if (pos % 1000 == 0)  	// for performance reasons: DoEvents only 1 times per 1000 loops  	Application.DoEvents ();  
Magic Number,Be.Windows.Forms,HexBox,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\Be.Windows.Forms.HexBox\HexBox.cs,PaintLineInfo,The following statement contains a magic number: for (int i = 0; i < maxLine; i++) {  	long firstLineByte = startByte + (_iHexMaxHBytes) * i;  	PointF bytePointF = GetBytePointF (new Point (0' 0 + i));  	string info = firstLineByte.ToString (_hexStringFormat' System.Threading.Thread.CurrentThread.CurrentCulture);  	int nulls = 8 - info.Length;  	string formattedInfo;  	if (nulls > -1) {  		formattedInfo = new string ('0'' 8 - info.Length) + info;  	}  	else {  		formattedInfo = new string ('~'' 8);  	}  	g.DrawString (formattedInfo' Font' brush' new PointF (_recLineInfo.X' bytePointF.Y)' _stringFormat);  }  
Magic Number,Be.Windows.Forms,HexBox,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\Be.Windows.Forms.HexBox\HexBox.cs,PaintLineInfo,The following statement contains a magic number: for (int i = 0; i < maxLine; i++) {  	long firstLineByte = startByte + (_iHexMaxHBytes) * i;  	PointF bytePointF = GetBytePointF (new Point (0' 0 + i));  	string info = firstLineByte.ToString (_hexStringFormat' System.Threading.Thread.CurrentThread.CurrentCulture);  	int nulls = 8 - info.Length;  	string formattedInfo;  	if (nulls > -1) {  		formattedInfo = new string ('0'' 8 - info.Length) + info;  	}  	else {  		formattedInfo = new string ('~'' 8);  	}  	g.DrawString (formattedInfo' Font' brush' new PointF (_recLineInfo.X' bytePointF.Y)' _stringFormat);  }  
Magic Number,Be.Windows.Forms,HexBox,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\Be.Windows.Forms.HexBox\HexBox.cs,PaintLineInfo,The following statement contains a magic number: for (int i = 0; i < maxLine; i++) {  	long firstLineByte = startByte + (_iHexMaxHBytes) * i;  	PointF bytePointF = GetBytePointF (new Point (0' 0 + i));  	string info = firstLineByte.ToString (_hexStringFormat' System.Threading.Thread.CurrentThread.CurrentCulture);  	int nulls = 8 - info.Length;  	string formattedInfo;  	if (nulls > -1) {  		formattedInfo = new string ('0'' 8 - info.Length) + info;  	}  	else {  		formattedInfo = new string ('~'' 8);  	}  	g.DrawString (formattedInfo' Font' brush' new PointF (_recLineInfo.X' bytePointF.Y)' _stringFormat);  }  
Magic Number,Be.Windows.Forms,HexBox,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\Be.Windows.Forms.HexBox\HexBox.cs,PaintLineInfo,The following statement contains a magic number: if (nulls > -1) {  	formattedInfo = new string ('0'' 8 - info.Length) + info;  }  else {  	formattedInfo = new string ('~'' 8);  }  
Magic Number,Be.Windows.Forms,HexBox,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\Be.Windows.Forms.HexBox\HexBox.cs,PaintLineInfo,The following statement contains a magic number: if (nulls > -1) {  	formattedInfo = new string ('0'' 8 - info.Length) + info;  }  else {  	formattedInfo = new string ('~'' 8);  }  
Magic Number,Be.Windows.Forms,HexBox,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\Be.Windows.Forms.HexBox\HexBox.cs,PaintLineInfo,The following statement contains a magic number: formattedInfo = new string ('0'' 8 - info.Length) + info;  
Magic Number,Be.Windows.Forms,HexBox,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\Be.Windows.Forms.HexBox\HexBox.cs,PaintLineInfo,The following statement contains a magic number: formattedInfo = new string ('~'' 8);  
Magic Number,Be.Windows.Forms,HexBox,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\Be.Windows.Forms.HexBox\HexBox.cs,PaintCurrentBytesSign,The following statement contains a magic number: if (_keyInterpreter != null && Focused && _bytePos != -1 && Enabled) {  	if (_keyInterpreter.GetType () == typeof(KeyInterpreter)) {  		if (_selectionLength == 0) {  			Point gp = GetGridBytePoint (_bytePos - _startByte);  			PointF pf = GetByteStringPointF (gp);  			Size s = new Size ((int)_charSize.Width' (int)_charSize.Height);  			Rectangle r = new Rectangle ((int)pf.X' (int)pf.Y' s.Width' s.Height);  			if (r.IntersectsWith (_recStringView)) {  				r.Intersect (_recStringView);  				PaintCurrentByteSign (g' r);  			}  		}  		else {  			int lineWidth = (int)(_recStringView.Width - _charSize.Width);  			Point startSelGridPoint = GetGridBytePoint (_bytePos - _startByte);  			PointF startSelPointF = GetByteStringPointF (startSelGridPoint);  			Point endSelGridPoint = GetGridBytePoint (_bytePos - _startByte + _selectionLength - 1);  			PointF endSelPointF = GetByteStringPointF (endSelGridPoint);  			int multiLine = endSelGridPoint.Y - startSelGridPoint.Y;  			if (multiLine == 0) {  				Rectangle singleLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(endSelPointF.X - startSelPointF.X + _charSize.Width)' (int)_charSize.Height);  				if (singleLine.IntersectsWith (_recStringView)) {  					singleLine.Intersect (_recStringView);  					PaintCurrentByteSign (g' singleLine);  				}  			}  			else {  				Rectangle firstLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(_recStringView.X + lineWidth - startSelPointF.X + _charSize.Width)' (int)_charSize.Height);  				if (firstLine.IntersectsWith (_recStringView)) {  					firstLine.Intersect (_recStringView);  					PaintCurrentByteSign (g' firstLine);  				}  				if (multiLine > 1) {  					Rectangle betweenLines = new Rectangle (_recStringView.X' (int)(startSelPointF.Y + _charSize.Height)' (int)(_recStringView.Width)' (int)(_charSize.Height * (multiLine - 1)));  					if (betweenLines.IntersectsWith (_recStringView)) {  						betweenLines.Intersect (_recStringView);  						PaintCurrentByteSign (g' betweenLines);  					}  				}  				Rectangle lastLine = new Rectangle (_recStringView.X' (int)endSelPointF.Y' (int)(endSelPointF.X - _recStringView.X + _charSize.Width)' (int)_charSize.Height);  				if (lastLine.IntersectsWith (_recStringView)) {  					lastLine.Intersect (_recStringView);  					PaintCurrentByteSign (g' lastLine);  				}  			}  		}  	}  	else {  		if (_selectionLength == 0) {  			Point gp = GetGridBytePoint (_bytePos - _startByte);  			PointF pf = GetBytePointF (gp);  			Size s = new Size ((int)_charSize.Width * 2' (int)_charSize.Height);  			Rectangle r = new Rectangle ((int)pf.X' (int)pf.Y' s.Width' s.Height);  			PaintCurrentByteSign (g' r);  		}  		else {  			int lineWidth = (int)(_recHex.Width - _charSize.Width * 5);  			Point startSelGridPoint = GetGridBytePoint (_bytePos - _startByte);  			PointF startSelPointF = GetBytePointF (startSelGridPoint);  			Point endSelGridPoint = GetGridBytePoint (_bytePos - _startByte + _selectionLength - 1);  			PointF endSelPointF = GetBytePointF (endSelGridPoint);  			int multiLine = endSelGridPoint.Y - startSelGridPoint.Y;  			if (multiLine == 0) {  				Rectangle singleLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(endSelPointF.X - startSelPointF.X + _charSize.Width * 2)' (int)_charSize.Height);  				if (singleLine.IntersectsWith (_recHex)) {  					singleLine.Intersect (_recHex);  					PaintCurrentByteSign (g' singleLine);  				}  			}  			else {  				Rectangle firstLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(_recHex.X + lineWidth - startSelPointF.X + _charSize.Width * 2)' (int)_charSize.Height);  				if (firstLine.IntersectsWith (_recHex)) {  					firstLine.Intersect (_recHex);  					PaintCurrentByteSign (g' firstLine);  				}  				if (multiLine > 1) {  					Rectangle betweenLines = new Rectangle (_recHex.X' (int)(startSelPointF.Y + _charSize.Height)' (int)(lineWidth + _charSize.Width * 2)' (int)(_charSize.Height * (multiLine - 1)));  					if (betweenLines.IntersectsWith (_recHex)) {  						betweenLines.Intersect (_recHex);  						PaintCurrentByteSign (g' betweenLines);  					}  				}  				Rectangle lastLine = new Rectangle (_recHex.X' (int)endSelPointF.Y' (int)(endSelPointF.X - _recHex.X + _charSize.Width * 2)' (int)_charSize.Height);  				if (lastLine.IntersectsWith (_recHex)) {  					lastLine.Intersect (_recHex);  					PaintCurrentByteSign (g' lastLine);  				}  			}  		}  	}  }  
Magic Number,Be.Windows.Forms,HexBox,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\Be.Windows.Forms.HexBox\HexBox.cs,PaintCurrentBytesSign,The following statement contains a magic number: if (_keyInterpreter != null && Focused && _bytePos != -1 && Enabled) {  	if (_keyInterpreter.GetType () == typeof(KeyInterpreter)) {  		if (_selectionLength == 0) {  			Point gp = GetGridBytePoint (_bytePos - _startByte);  			PointF pf = GetByteStringPointF (gp);  			Size s = new Size ((int)_charSize.Width' (int)_charSize.Height);  			Rectangle r = new Rectangle ((int)pf.X' (int)pf.Y' s.Width' s.Height);  			if (r.IntersectsWith (_recStringView)) {  				r.Intersect (_recStringView);  				PaintCurrentByteSign (g' r);  			}  		}  		else {  			int lineWidth = (int)(_recStringView.Width - _charSize.Width);  			Point startSelGridPoint = GetGridBytePoint (_bytePos - _startByte);  			PointF startSelPointF = GetByteStringPointF (startSelGridPoint);  			Point endSelGridPoint = GetGridBytePoint (_bytePos - _startByte + _selectionLength - 1);  			PointF endSelPointF = GetByteStringPointF (endSelGridPoint);  			int multiLine = endSelGridPoint.Y - startSelGridPoint.Y;  			if (multiLine == 0) {  				Rectangle singleLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(endSelPointF.X - startSelPointF.X + _charSize.Width)' (int)_charSize.Height);  				if (singleLine.IntersectsWith (_recStringView)) {  					singleLine.Intersect (_recStringView);  					PaintCurrentByteSign (g' singleLine);  				}  			}  			else {  				Rectangle firstLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(_recStringView.X + lineWidth - startSelPointF.X + _charSize.Width)' (int)_charSize.Height);  				if (firstLine.IntersectsWith (_recStringView)) {  					firstLine.Intersect (_recStringView);  					PaintCurrentByteSign (g' firstLine);  				}  				if (multiLine > 1) {  					Rectangle betweenLines = new Rectangle (_recStringView.X' (int)(startSelPointF.Y + _charSize.Height)' (int)(_recStringView.Width)' (int)(_charSize.Height * (multiLine - 1)));  					if (betweenLines.IntersectsWith (_recStringView)) {  						betweenLines.Intersect (_recStringView);  						PaintCurrentByteSign (g' betweenLines);  					}  				}  				Rectangle lastLine = new Rectangle (_recStringView.X' (int)endSelPointF.Y' (int)(endSelPointF.X - _recStringView.X + _charSize.Width)' (int)_charSize.Height);  				if (lastLine.IntersectsWith (_recStringView)) {  					lastLine.Intersect (_recStringView);  					PaintCurrentByteSign (g' lastLine);  				}  			}  		}  	}  	else {  		if (_selectionLength == 0) {  			Point gp = GetGridBytePoint (_bytePos - _startByte);  			PointF pf = GetBytePointF (gp);  			Size s = new Size ((int)_charSize.Width * 2' (int)_charSize.Height);  			Rectangle r = new Rectangle ((int)pf.X' (int)pf.Y' s.Width' s.Height);  			PaintCurrentByteSign (g' r);  		}  		else {  			int lineWidth = (int)(_recHex.Width - _charSize.Width * 5);  			Point startSelGridPoint = GetGridBytePoint (_bytePos - _startByte);  			PointF startSelPointF = GetBytePointF (startSelGridPoint);  			Point endSelGridPoint = GetGridBytePoint (_bytePos - _startByte + _selectionLength - 1);  			PointF endSelPointF = GetBytePointF (endSelGridPoint);  			int multiLine = endSelGridPoint.Y - startSelGridPoint.Y;  			if (multiLine == 0) {  				Rectangle singleLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(endSelPointF.X - startSelPointF.X + _charSize.Width * 2)' (int)_charSize.Height);  				if (singleLine.IntersectsWith (_recHex)) {  					singleLine.Intersect (_recHex);  					PaintCurrentByteSign (g' singleLine);  				}  			}  			else {  				Rectangle firstLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(_recHex.X + lineWidth - startSelPointF.X + _charSize.Width * 2)' (int)_charSize.Height);  				if (firstLine.IntersectsWith (_recHex)) {  					firstLine.Intersect (_recHex);  					PaintCurrentByteSign (g' firstLine);  				}  				if (multiLine > 1) {  					Rectangle betweenLines = new Rectangle (_recHex.X' (int)(startSelPointF.Y + _charSize.Height)' (int)(lineWidth + _charSize.Width * 2)' (int)(_charSize.Height * (multiLine - 1)));  					if (betweenLines.IntersectsWith (_recHex)) {  						betweenLines.Intersect (_recHex);  						PaintCurrentByteSign (g' betweenLines);  					}  				}  				Rectangle lastLine = new Rectangle (_recHex.X' (int)endSelPointF.Y' (int)(endSelPointF.X - _recHex.X + _charSize.Width * 2)' (int)_charSize.Height);  				if (lastLine.IntersectsWith (_recHex)) {  					lastLine.Intersect (_recHex);  					PaintCurrentByteSign (g' lastLine);  				}  			}  		}  	}  }  
Magic Number,Be.Windows.Forms,HexBox,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\Be.Windows.Forms.HexBox\HexBox.cs,PaintCurrentBytesSign,The following statement contains a magic number: if (_keyInterpreter != null && Focused && _bytePos != -1 && Enabled) {  	if (_keyInterpreter.GetType () == typeof(KeyInterpreter)) {  		if (_selectionLength == 0) {  			Point gp = GetGridBytePoint (_bytePos - _startByte);  			PointF pf = GetByteStringPointF (gp);  			Size s = new Size ((int)_charSize.Width' (int)_charSize.Height);  			Rectangle r = new Rectangle ((int)pf.X' (int)pf.Y' s.Width' s.Height);  			if (r.IntersectsWith (_recStringView)) {  				r.Intersect (_recStringView);  				PaintCurrentByteSign (g' r);  			}  		}  		else {  			int lineWidth = (int)(_recStringView.Width - _charSize.Width);  			Point startSelGridPoint = GetGridBytePoint (_bytePos - _startByte);  			PointF startSelPointF = GetByteStringPointF (startSelGridPoint);  			Point endSelGridPoint = GetGridBytePoint (_bytePos - _startByte + _selectionLength - 1);  			PointF endSelPointF = GetByteStringPointF (endSelGridPoint);  			int multiLine = endSelGridPoint.Y - startSelGridPoint.Y;  			if (multiLine == 0) {  				Rectangle singleLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(endSelPointF.X - startSelPointF.X + _charSize.Width)' (int)_charSize.Height);  				if (singleLine.IntersectsWith (_recStringView)) {  					singleLine.Intersect (_recStringView);  					PaintCurrentByteSign (g' singleLine);  				}  			}  			else {  				Rectangle firstLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(_recStringView.X + lineWidth - startSelPointF.X + _charSize.Width)' (int)_charSize.Height);  				if (firstLine.IntersectsWith (_recStringView)) {  					firstLine.Intersect (_recStringView);  					PaintCurrentByteSign (g' firstLine);  				}  				if (multiLine > 1) {  					Rectangle betweenLines = new Rectangle (_recStringView.X' (int)(startSelPointF.Y + _charSize.Height)' (int)(_recStringView.Width)' (int)(_charSize.Height * (multiLine - 1)));  					if (betweenLines.IntersectsWith (_recStringView)) {  						betweenLines.Intersect (_recStringView);  						PaintCurrentByteSign (g' betweenLines);  					}  				}  				Rectangle lastLine = new Rectangle (_recStringView.X' (int)endSelPointF.Y' (int)(endSelPointF.X - _recStringView.X + _charSize.Width)' (int)_charSize.Height);  				if (lastLine.IntersectsWith (_recStringView)) {  					lastLine.Intersect (_recStringView);  					PaintCurrentByteSign (g' lastLine);  				}  			}  		}  	}  	else {  		if (_selectionLength == 0) {  			Point gp = GetGridBytePoint (_bytePos - _startByte);  			PointF pf = GetBytePointF (gp);  			Size s = new Size ((int)_charSize.Width * 2' (int)_charSize.Height);  			Rectangle r = new Rectangle ((int)pf.X' (int)pf.Y' s.Width' s.Height);  			PaintCurrentByteSign (g' r);  		}  		else {  			int lineWidth = (int)(_recHex.Width - _charSize.Width * 5);  			Point startSelGridPoint = GetGridBytePoint (_bytePos - _startByte);  			PointF startSelPointF = GetBytePointF (startSelGridPoint);  			Point endSelGridPoint = GetGridBytePoint (_bytePos - _startByte + _selectionLength - 1);  			PointF endSelPointF = GetBytePointF (endSelGridPoint);  			int multiLine = endSelGridPoint.Y - startSelGridPoint.Y;  			if (multiLine == 0) {  				Rectangle singleLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(endSelPointF.X - startSelPointF.X + _charSize.Width * 2)' (int)_charSize.Height);  				if (singleLine.IntersectsWith (_recHex)) {  					singleLine.Intersect (_recHex);  					PaintCurrentByteSign (g' singleLine);  				}  			}  			else {  				Rectangle firstLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(_recHex.X + lineWidth - startSelPointF.X + _charSize.Width * 2)' (int)_charSize.Height);  				if (firstLine.IntersectsWith (_recHex)) {  					firstLine.Intersect (_recHex);  					PaintCurrentByteSign (g' firstLine);  				}  				if (multiLine > 1) {  					Rectangle betweenLines = new Rectangle (_recHex.X' (int)(startSelPointF.Y + _charSize.Height)' (int)(lineWidth + _charSize.Width * 2)' (int)(_charSize.Height * (multiLine - 1)));  					if (betweenLines.IntersectsWith (_recHex)) {  						betweenLines.Intersect (_recHex);  						PaintCurrentByteSign (g' betweenLines);  					}  				}  				Rectangle lastLine = new Rectangle (_recHex.X' (int)endSelPointF.Y' (int)(endSelPointF.X - _recHex.X + _charSize.Width * 2)' (int)_charSize.Height);  				if (lastLine.IntersectsWith (_recHex)) {  					lastLine.Intersect (_recHex);  					PaintCurrentByteSign (g' lastLine);  				}  			}  		}  	}  }  
Magic Number,Be.Windows.Forms,HexBox,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\Be.Windows.Forms.HexBox\HexBox.cs,PaintCurrentBytesSign,The following statement contains a magic number: if (_keyInterpreter != null && Focused && _bytePos != -1 && Enabled) {  	if (_keyInterpreter.GetType () == typeof(KeyInterpreter)) {  		if (_selectionLength == 0) {  			Point gp = GetGridBytePoint (_bytePos - _startByte);  			PointF pf = GetByteStringPointF (gp);  			Size s = new Size ((int)_charSize.Width' (int)_charSize.Height);  			Rectangle r = new Rectangle ((int)pf.X' (int)pf.Y' s.Width' s.Height);  			if (r.IntersectsWith (_recStringView)) {  				r.Intersect (_recStringView);  				PaintCurrentByteSign (g' r);  			}  		}  		else {  			int lineWidth = (int)(_recStringView.Width - _charSize.Width);  			Point startSelGridPoint = GetGridBytePoint (_bytePos - _startByte);  			PointF startSelPointF = GetByteStringPointF (startSelGridPoint);  			Point endSelGridPoint = GetGridBytePoint (_bytePos - _startByte + _selectionLength - 1);  			PointF endSelPointF = GetByteStringPointF (endSelGridPoint);  			int multiLine = endSelGridPoint.Y - startSelGridPoint.Y;  			if (multiLine == 0) {  				Rectangle singleLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(endSelPointF.X - startSelPointF.X + _charSize.Width)' (int)_charSize.Height);  				if (singleLine.IntersectsWith (_recStringView)) {  					singleLine.Intersect (_recStringView);  					PaintCurrentByteSign (g' singleLine);  				}  			}  			else {  				Rectangle firstLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(_recStringView.X + lineWidth - startSelPointF.X + _charSize.Width)' (int)_charSize.Height);  				if (firstLine.IntersectsWith (_recStringView)) {  					firstLine.Intersect (_recStringView);  					PaintCurrentByteSign (g' firstLine);  				}  				if (multiLine > 1) {  					Rectangle betweenLines = new Rectangle (_recStringView.X' (int)(startSelPointF.Y + _charSize.Height)' (int)(_recStringView.Width)' (int)(_charSize.Height * (multiLine - 1)));  					if (betweenLines.IntersectsWith (_recStringView)) {  						betweenLines.Intersect (_recStringView);  						PaintCurrentByteSign (g' betweenLines);  					}  				}  				Rectangle lastLine = new Rectangle (_recStringView.X' (int)endSelPointF.Y' (int)(endSelPointF.X - _recStringView.X + _charSize.Width)' (int)_charSize.Height);  				if (lastLine.IntersectsWith (_recStringView)) {  					lastLine.Intersect (_recStringView);  					PaintCurrentByteSign (g' lastLine);  				}  			}  		}  	}  	else {  		if (_selectionLength == 0) {  			Point gp = GetGridBytePoint (_bytePos - _startByte);  			PointF pf = GetBytePointF (gp);  			Size s = new Size ((int)_charSize.Width * 2' (int)_charSize.Height);  			Rectangle r = new Rectangle ((int)pf.X' (int)pf.Y' s.Width' s.Height);  			PaintCurrentByteSign (g' r);  		}  		else {  			int lineWidth = (int)(_recHex.Width - _charSize.Width * 5);  			Point startSelGridPoint = GetGridBytePoint (_bytePos - _startByte);  			PointF startSelPointF = GetBytePointF (startSelGridPoint);  			Point endSelGridPoint = GetGridBytePoint (_bytePos - _startByte + _selectionLength - 1);  			PointF endSelPointF = GetBytePointF (endSelGridPoint);  			int multiLine = endSelGridPoint.Y - startSelGridPoint.Y;  			if (multiLine == 0) {  				Rectangle singleLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(endSelPointF.X - startSelPointF.X + _charSize.Width * 2)' (int)_charSize.Height);  				if (singleLine.IntersectsWith (_recHex)) {  					singleLine.Intersect (_recHex);  					PaintCurrentByteSign (g' singleLine);  				}  			}  			else {  				Rectangle firstLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(_recHex.X + lineWidth - startSelPointF.X + _charSize.Width * 2)' (int)_charSize.Height);  				if (firstLine.IntersectsWith (_recHex)) {  					firstLine.Intersect (_recHex);  					PaintCurrentByteSign (g' firstLine);  				}  				if (multiLine > 1) {  					Rectangle betweenLines = new Rectangle (_recHex.X' (int)(startSelPointF.Y + _charSize.Height)' (int)(lineWidth + _charSize.Width * 2)' (int)(_charSize.Height * (multiLine - 1)));  					if (betweenLines.IntersectsWith (_recHex)) {  						betweenLines.Intersect (_recHex);  						PaintCurrentByteSign (g' betweenLines);  					}  				}  				Rectangle lastLine = new Rectangle (_recHex.X' (int)endSelPointF.Y' (int)(endSelPointF.X - _recHex.X + _charSize.Width * 2)' (int)_charSize.Height);  				if (lastLine.IntersectsWith (_recHex)) {  					lastLine.Intersect (_recHex);  					PaintCurrentByteSign (g' lastLine);  				}  			}  		}  	}  }  
Magic Number,Be.Windows.Forms,HexBox,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\Be.Windows.Forms.HexBox\HexBox.cs,PaintCurrentBytesSign,The following statement contains a magic number: if (_keyInterpreter != null && Focused && _bytePos != -1 && Enabled) {  	if (_keyInterpreter.GetType () == typeof(KeyInterpreter)) {  		if (_selectionLength == 0) {  			Point gp = GetGridBytePoint (_bytePos - _startByte);  			PointF pf = GetByteStringPointF (gp);  			Size s = new Size ((int)_charSize.Width' (int)_charSize.Height);  			Rectangle r = new Rectangle ((int)pf.X' (int)pf.Y' s.Width' s.Height);  			if (r.IntersectsWith (_recStringView)) {  				r.Intersect (_recStringView);  				PaintCurrentByteSign (g' r);  			}  		}  		else {  			int lineWidth = (int)(_recStringView.Width - _charSize.Width);  			Point startSelGridPoint = GetGridBytePoint (_bytePos - _startByte);  			PointF startSelPointF = GetByteStringPointF (startSelGridPoint);  			Point endSelGridPoint = GetGridBytePoint (_bytePos - _startByte + _selectionLength - 1);  			PointF endSelPointF = GetByteStringPointF (endSelGridPoint);  			int multiLine = endSelGridPoint.Y - startSelGridPoint.Y;  			if (multiLine == 0) {  				Rectangle singleLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(endSelPointF.X - startSelPointF.X + _charSize.Width)' (int)_charSize.Height);  				if (singleLine.IntersectsWith (_recStringView)) {  					singleLine.Intersect (_recStringView);  					PaintCurrentByteSign (g' singleLine);  				}  			}  			else {  				Rectangle firstLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(_recStringView.X + lineWidth - startSelPointF.X + _charSize.Width)' (int)_charSize.Height);  				if (firstLine.IntersectsWith (_recStringView)) {  					firstLine.Intersect (_recStringView);  					PaintCurrentByteSign (g' firstLine);  				}  				if (multiLine > 1) {  					Rectangle betweenLines = new Rectangle (_recStringView.X' (int)(startSelPointF.Y + _charSize.Height)' (int)(_recStringView.Width)' (int)(_charSize.Height * (multiLine - 1)));  					if (betweenLines.IntersectsWith (_recStringView)) {  						betweenLines.Intersect (_recStringView);  						PaintCurrentByteSign (g' betweenLines);  					}  				}  				Rectangle lastLine = new Rectangle (_recStringView.X' (int)endSelPointF.Y' (int)(endSelPointF.X - _recStringView.X + _charSize.Width)' (int)_charSize.Height);  				if (lastLine.IntersectsWith (_recStringView)) {  					lastLine.Intersect (_recStringView);  					PaintCurrentByteSign (g' lastLine);  				}  			}  		}  	}  	else {  		if (_selectionLength == 0) {  			Point gp = GetGridBytePoint (_bytePos - _startByte);  			PointF pf = GetBytePointF (gp);  			Size s = new Size ((int)_charSize.Width * 2' (int)_charSize.Height);  			Rectangle r = new Rectangle ((int)pf.X' (int)pf.Y' s.Width' s.Height);  			PaintCurrentByteSign (g' r);  		}  		else {  			int lineWidth = (int)(_recHex.Width - _charSize.Width * 5);  			Point startSelGridPoint = GetGridBytePoint (_bytePos - _startByte);  			PointF startSelPointF = GetBytePointF (startSelGridPoint);  			Point endSelGridPoint = GetGridBytePoint (_bytePos - _startByte + _selectionLength - 1);  			PointF endSelPointF = GetBytePointF (endSelGridPoint);  			int multiLine = endSelGridPoint.Y - startSelGridPoint.Y;  			if (multiLine == 0) {  				Rectangle singleLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(endSelPointF.X - startSelPointF.X + _charSize.Width * 2)' (int)_charSize.Height);  				if (singleLine.IntersectsWith (_recHex)) {  					singleLine.Intersect (_recHex);  					PaintCurrentByteSign (g' singleLine);  				}  			}  			else {  				Rectangle firstLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(_recHex.X + lineWidth - startSelPointF.X + _charSize.Width * 2)' (int)_charSize.Height);  				if (firstLine.IntersectsWith (_recHex)) {  					firstLine.Intersect (_recHex);  					PaintCurrentByteSign (g' firstLine);  				}  				if (multiLine > 1) {  					Rectangle betweenLines = new Rectangle (_recHex.X' (int)(startSelPointF.Y + _charSize.Height)' (int)(lineWidth + _charSize.Width * 2)' (int)(_charSize.Height * (multiLine - 1)));  					if (betweenLines.IntersectsWith (_recHex)) {  						betweenLines.Intersect (_recHex);  						PaintCurrentByteSign (g' betweenLines);  					}  				}  				Rectangle lastLine = new Rectangle (_recHex.X' (int)endSelPointF.Y' (int)(endSelPointF.X - _recHex.X + _charSize.Width * 2)' (int)_charSize.Height);  				if (lastLine.IntersectsWith (_recHex)) {  					lastLine.Intersect (_recHex);  					PaintCurrentByteSign (g' lastLine);  				}  			}  		}  	}  }  
Magic Number,Be.Windows.Forms,HexBox,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\Be.Windows.Forms.HexBox\HexBox.cs,PaintCurrentBytesSign,The following statement contains a magic number: if (_keyInterpreter != null && Focused && _bytePos != -1 && Enabled) {  	if (_keyInterpreter.GetType () == typeof(KeyInterpreter)) {  		if (_selectionLength == 0) {  			Point gp = GetGridBytePoint (_bytePos - _startByte);  			PointF pf = GetByteStringPointF (gp);  			Size s = new Size ((int)_charSize.Width' (int)_charSize.Height);  			Rectangle r = new Rectangle ((int)pf.X' (int)pf.Y' s.Width' s.Height);  			if (r.IntersectsWith (_recStringView)) {  				r.Intersect (_recStringView);  				PaintCurrentByteSign (g' r);  			}  		}  		else {  			int lineWidth = (int)(_recStringView.Width - _charSize.Width);  			Point startSelGridPoint = GetGridBytePoint (_bytePos - _startByte);  			PointF startSelPointF = GetByteStringPointF (startSelGridPoint);  			Point endSelGridPoint = GetGridBytePoint (_bytePos - _startByte + _selectionLength - 1);  			PointF endSelPointF = GetByteStringPointF (endSelGridPoint);  			int multiLine = endSelGridPoint.Y - startSelGridPoint.Y;  			if (multiLine == 0) {  				Rectangle singleLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(endSelPointF.X - startSelPointF.X + _charSize.Width)' (int)_charSize.Height);  				if (singleLine.IntersectsWith (_recStringView)) {  					singleLine.Intersect (_recStringView);  					PaintCurrentByteSign (g' singleLine);  				}  			}  			else {  				Rectangle firstLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(_recStringView.X + lineWidth - startSelPointF.X + _charSize.Width)' (int)_charSize.Height);  				if (firstLine.IntersectsWith (_recStringView)) {  					firstLine.Intersect (_recStringView);  					PaintCurrentByteSign (g' firstLine);  				}  				if (multiLine > 1) {  					Rectangle betweenLines = new Rectangle (_recStringView.X' (int)(startSelPointF.Y + _charSize.Height)' (int)(_recStringView.Width)' (int)(_charSize.Height * (multiLine - 1)));  					if (betweenLines.IntersectsWith (_recStringView)) {  						betweenLines.Intersect (_recStringView);  						PaintCurrentByteSign (g' betweenLines);  					}  				}  				Rectangle lastLine = new Rectangle (_recStringView.X' (int)endSelPointF.Y' (int)(endSelPointF.X - _recStringView.X + _charSize.Width)' (int)_charSize.Height);  				if (lastLine.IntersectsWith (_recStringView)) {  					lastLine.Intersect (_recStringView);  					PaintCurrentByteSign (g' lastLine);  				}  			}  		}  	}  	else {  		if (_selectionLength == 0) {  			Point gp = GetGridBytePoint (_bytePos - _startByte);  			PointF pf = GetBytePointF (gp);  			Size s = new Size ((int)_charSize.Width * 2' (int)_charSize.Height);  			Rectangle r = new Rectangle ((int)pf.X' (int)pf.Y' s.Width' s.Height);  			PaintCurrentByteSign (g' r);  		}  		else {  			int lineWidth = (int)(_recHex.Width - _charSize.Width * 5);  			Point startSelGridPoint = GetGridBytePoint (_bytePos - _startByte);  			PointF startSelPointF = GetBytePointF (startSelGridPoint);  			Point endSelGridPoint = GetGridBytePoint (_bytePos - _startByte + _selectionLength - 1);  			PointF endSelPointF = GetBytePointF (endSelGridPoint);  			int multiLine = endSelGridPoint.Y - startSelGridPoint.Y;  			if (multiLine == 0) {  				Rectangle singleLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(endSelPointF.X - startSelPointF.X + _charSize.Width * 2)' (int)_charSize.Height);  				if (singleLine.IntersectsWith (_recHex)) {  					singleLine.Intersect (_recHex);  					PaintCurrentByteSign (g' singleLine);  				}  			}  			else {  				Rectangle firstLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(_recHex.X + lineWidth - startSelPointF.X + _charSize.Width * 2)' (int)_charSize.Height);  				if (firstLine.IntersectsWith (_recHex)) {  					firstLine.Intersect (_recHex);  					PaintCurrentByteSign (g' firstLine);  				}  				if (multiLine > 1) {  					Rectangle betweenLines = new Rectangle (_recHex.X' (int)(startSelPointF.Y + _charSize.Height)' (int)(lineWidth + _charSize.Width * 2)' (int)(_charSize.Height * (multiLine - 1)));  					if (betweenLines.IntersectsWith (_recHex)) {  						betweenLines.Intersect (_recHex);  						PaintCurrentByteSign (g' betweenLines);  					}  				}  				Rectangle lastLine = new Rectangle (_recHex.X' (int)endSelPointF.Y' (int)(endSelPointF.X - _recHex.X + _charSize.Width * 2)' (int)_charSize.Height);  				if (lastLine.IntersectsWith (_recHex)) {  					lastLine.Intersect (_recHex);  					PaintCurrentByteSign (g' lastLine);  				}  			}  		}  	}  }  
Magic Number,Be.Windows.Forms,HexBox,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\Be.Windows.Forms.HexBox\HexBox.cs,PaintCurrentBytesSign,The following statement contains a magic number: if (_keyInterpreter.GetType () == typeof(KeyInterpreter)) {  	if (_selectionLength == 0) {  		Point gp = GetGridBytePoint (_bytePos - _startByte);  		PointF pf = GetByteStringPointF (gp);  		Size s = new Size ((int)_charSize.Width' (int)_charSize.Height);  		Rectangle r = new Rectangle ((int)pf.X' (int)pf.Y' s.Width' s.Height);  		if (r.IntersectsWith (_recStringView)) {  			r.Intersect (_recStringView);  			PaintCurrentByteSign (g' r);  		}  	}  	else {  		int lineWidth = (int)(_recStringView.Width - _charSize.Width);  		Point startSelGridPoint = GetGridBytePoint (_bytePos - _startByte);  		PointF startSelPointF = GetByteStringPointF (startSelGridPoint);  		Point endSelGridPoint = GetGridBytePoint (_bytePos - _startByte + _selectionLength - 1);  		PointF endSelPointF = GetByteStringPointF (endSelGridPoint);  		int multiLine = endSelGridPoint.Y - startSelGridPoint.Y;  		if (multiLine == 0) {  			Rectangle singleLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(endSelPointF.X - startSelPointF.X + _charSize.Width)' (int)_charSize.Height);  			if (singleLine.IntersectsWith (_recStringView)) {  				singleLine.Intersect (_recStringView);  				PaintCurrentByteSign (g' singleLine);  			}  		}  		else {  			Rectangle firstLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(_recStringView.X + lineWidth - startSelPointF.X + _charSize.Width)' (int)_charSize.Height);  			if (firstLine.IntersectsWith (_recStringView)) {  				firstLine.Intersect (_recStringView);  				PaintCurrentByteSign (g' firstLine);  			}  			if (multiLine > 1) {  				Rectangle betweenLines = new Rectangle (_recStringView.X' (int)(startSelPointF.Y + _charSize.Height)' (int)(_recStringView.Width)' (int)(_charSize.Height * (multiLine - 1)));  				if (betweenLines.IntersectsWith (_recStringView)) {  					betweenLines.Intersect (_recStringView);  					PaintCurrentByteSign (g' betweenLines);  				}  			}  			Rectangle lastLine = new Rectangle (_recStringView.X' (int)endSelPointF.Y' (int)(endSelPointF.X - _recStringView.X + _charSize.Width)' (int)_charSize.Height);  			if (lastLine.IntersectsWith (_recStringView)) {  				lastLine.Intersect (_recStringView);  				PaintCurrentByteSign (g' lastLine);  			}  		}  	}  }  else {  	if (_selectionLength == 0) {  		Point gp = GetGridBytePoint (_bytePos - _startByte);  		PointF pf = GetBytePointF (gp);  		Size s = new Size ((int)_charSize.Width * 2' (int)_charSize.Height);  		Rectangle r = new Rectangle ((int)pf.X' (int)pf.Y' s.Width' s.Height);  		PaintCurrentByteSign (g' r);  	}  	else {  		int lineWidth = (int)(_recHex.Width - _charSize.Width * 5);  		Point startSelGridPoint = GetGridBytePoint (_bytePos - _startByte);  		PointF startSelPointF = GetBytePointF (startSelGridPoint);  		Point endSelGridPoint = GetGridBytePoint (_bytePos - _startByte + _selectionLength - 1);  		PointF endSelPointF = GetBytePointF (endSelGridPoint);  		int multiLine = endSelGridPoint.Y - startSelGridPoint.Y;  		if (multiLine == 0) {  			Rectangle singleLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(endSelPointF.X - startSelPointF.X + _charSize.Width * 2)' (int)_charSize.Height);  			if (singleLine.IntersectsWith (_recHex)) {  				singleLine.Intersect (_recHex);  				PaintCurrentByteSign (g' singleLine);  			}  		}  		else {  			Rectangle firstLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(_recHex.X + lineWidth - startSelPointF.X + _charSize.Width * 2)' (int)_charSize.Height);  			if (firstLine.IntersectsWith (_recHex)) {  				firstLine.Intersect (_recHex);  				PaintCurrentByteSign (g' firstLine);  			}  			if (multiLine > 1) {  				Rectangle betweenLines = new Rectangle (_recHex.X' (int)(startSelPointF.Y + _charSize.Height)' (int)(lineWidth + _charSize.Width * 2)' (int)(_charSize.Height * (multiLine - 1)));  				if (betweenLines.IntersectsWith (_recHex)) {  					betweenLines.Intersect (_recHex);  					PaintCurrentByteSign (g' betweenLines);  				}  			}  			Rectangle lastLine = new Rectangle (_recHex.X' (int)endSelPointF.Y' (int)(endSelPointF.X - _recHex.X + _charSize.Width * 2)' (int)_charSize.Height);  			if (lastLine.IntersectsWith (_recHex)) {  				lastLine.Intersect (_recHex);  				PaintCurrentByteSign (g' lastLine);  			}  		}  	}  }  
Magic Number,Be.Windows.Forms,HexBox,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\Be.Windows.Forms.HexBox\HexBox.cs,PaintCurrentBytesSign,The following statement contains a magic number: if (_keyInterpreter.GetType () == typeof(KeyInterpreter)) {  	if (_selectionLength == 0) {  		Point gp = GetGridBytePoint (_bytePos - _startByte);  		PointF pf = GetByteStringPointF (gp);  		Size s = new Size ((int)_charSize.Width' (int)_charSize.Height);  		Rectangle r = new Rectangle ((int)pf.X' (int)pf.Y' s.Width' s.Height);  		if (r.IntersectsWith (_recStringView)) {  			r.Intersect (_recStringView);  			PaintCurrentByteSign (g' r);  		}  	}  	else {  		int lineWidth = (int)(_recStringView.Width - _charSize.Width);  		Point startSelGridPoint = GetGridBytePoint (_bytePos - _startByte);  		PointF startSelPointF = GetByteStringPointF (startSelGridPoint);  		Point endSelGridPoint = GetGridBytePoint (_bytePos - _startByte + _selectionLength - 1);  		PointF endSelPointF = GetByteStringPointF (endSelGridPoint);  		int multiLine = endSelGridPoint.Y - startSelGridPoint.Y;  		if (multiLine == 0) {  			Rectangle singleLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(endSelPointF.X - startSelPointF.X + _charSize.Width)' (int)_charSize.Height);  			if (singleLine.IntersectsWith (_recStringView)) {  				singleLine.Intersect (_recStringView);  				PaintCurrentByteSign (g' singleLine);  			}  		}  		else {  			Rectangle firstLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(_recStringView.X + lineWidth - startSelPointF.X + _charSize.Width)' (int)_charSize.Height);  			if (firstLine.IntersectsWith (_recStringView)) {  				firstLine.Intersect (_recStringView);  				PaintCurrentByteSign (g' firstLine);  			}  			if (multiLine > 1) {  				Rectangle betweenLines = new Rectangle (_recStringView.X' (int)(startSelPointF.Y + _charSize.Height)' (int)(_recStringView.Width)' (int)(_charSize.Height * (multiLine - 1)));  				if (betweenLines.IntersectsWith (_recStringView)) {  					betweenLines.Intersect (_recStringView);  					PaintCurrentByteSign (g' betweenLines);  				}  			}  			Rectangle lastLine = new Rectangle (_recStringView.X' (int)endSelPointF.Y' (int)(endSelPointF.X - _recStringView.X + _charSize.Width)' (int)_charSize.Height);  			if (lastLine.IntersectsWith (_recStringView)) {  				lastLine.Intersect (_recStringView);  				PaintCurrentByteSign (g' lastLine);  			}  		}  	}  }  else {  	if (_selectionLength == 0) {  		Point gp = GetGridBytePoint (_bytePos - _startByte);  		PointF pf = GetBytePointF (gp);  		Size s = new Size ((int)_charSize.Width * 2' (int)_charSize.Height);  		Rectangle r = new Rectangle ((int)pf.X' (int)pf.Y' s.Width' s.Height);  		PaintCurrentByteSign (g' r);  	}  	else {  		int lineWidth = (int)(_recHex.Width - _charSize.Width * 5);  		Point startSelGridPoint = GetGridBytePoint (_bytePos - _startByte);  		PointF startSelPointF = GetBytePointF (startSelGridPoint);  		Point endSelGridPoint = GetGridBytePoint (_bytePos - _startByte + _selectionLength - 1);  		PointF endSelPointF = GetBytePointF (endSelGridPoint);  		int multiLine = endSelGridPoint.Y - startSelGridPoint.Y;  		if (multiLine == 0) {  			Rectangle singleLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(endSelPointF.X - startSelPointF.X + _charSize.Width * 2)' (int)_charSize.Height);  			if (singleLine.IntersectsWith (_recHex)) {  				singleLine.Intersect (_recHex);  				PaintCurrentByteSign (g' singleLine);  			}  		}  		else {  			Rectangle firstLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(_recHex.X + lineWidth - startSelPointF.X + _charSize.Width * 2)' (int)_charSize.Height);  			if (firstLine.IntersectsWith (_recHex)) {  				firstLine.Intersect (_recHex);  				PaintCurrentByteSign (g' firstLine);  			}  			if (multiLine > 1) {  				Rectangle betweenLines = new Rectangle (_recHex.X' (int)(startSelPointF.Y + _charSize.Height)' (int)(lineWidth + _charSize.Width * 2)' (int)(_charSize.Height * (multiLine - 1)));  				if (betweenLines.IntersectsWith (_recHex)) {  					betweenLines.Intersect (_recHex);  					PaintCurrentByteSign (g' betweenLines);  				}  			}  			Rectangle lastLine = new Rectangle (_recHex.X' (int)endSelPointF.Y' (int)(endSelPointF.X - _recHex.X + _charSize.Width * 2)' (int)_charSize.Height);  			if (lastLine.IntersectsWith (_recHex)) {  				lastLine.Intersect (_recHex);  				PaintCurrentByteSign (g' lastLine);  			}  		}  	}  }  
Magic Number,Be.Windows.Forms,HexBox,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\Be.Windows.Forms.HexBox\HexBox.cs,PaintCurrentBytesSign,The following statement contains a magic number: if (_keyInterpreter.GetType () == typeof(KeyInterpreter)) {  	if (_selectionLength == 0) {  		Point gp = GetGridBytePoint (_bytePos - _startByte);  		PointF pf = GetByteStringPointF (gp);  		Size s = new Size ((int)_charSize.Width' (int)_charSize.Height);  		Rectangle r = new Rectangle ((int)pf.X' (int)pf.Y' s.Width' s.Height);  		if (r.IntersectsWith (_recStringView)) {  			r.Intersect (_recStringView);  			PaintCurrentByteSign (g' r);  		}  	}  	else {  		int lineWidth = (int)(_recStringView.Width - _charSize.Width);  		Point startSelGridPoint = GetGridBytePoint (_bytePos - _startByte);  		PointF startSelPointF = GetByteStringPointF (startSelGridPoint);  		Point endSelGridPoint = GetGridBytePoint (_bytePos - _startByte + _selectionLength - 1);  		PointF endSelPointF = GetByteStringPointF (endSelGridPoint);  		int multiLine = endSelGridPoint.Y - startSelGridPoint.Y;  		if (multiLine == 0) {  			Rectangle singleLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(endSelPointF.X - startSelPointF.X + _charSize.Width)' (int)_charSize.Height);  			if (singleLine.IntersectsWith (_recStringView)) {  				singleLine.Intersect (_recStringView);  				PaintCurrentByteSign (g' singleLine);  			}  		}  		else {  			Rectangle firstLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(_recStringView.X + lineWidth - startSelPointF.X + _charSize.Width)' (int)_charSize.Height);  			if (firstLine.IntersectsWith (_recStringView)) {  				firstLine.Intersect (_recStringView);  				PaintCurrentByteSign (g' firstLine);  			}  			if (multiLine > 1) {  				Rectangle betweenLines = new Rectangle (_recStringView.X' (int)(startSelPointF.Y + _charSize.Height)' (int)(_recStringView.Width)' (int)(_charSize.Height * (multiLine - 1)));  				if (betweenLines.IntersectsWith (_recStringView)) {  					betweenLines.Intersect (_recStringView);  					PaintCurrentByteSign (g' betweenLines);  				}  			}  			Rectangle lastLine = new Rectangle (_recStringView.X' (int)endSelPointF.Y' (int)(endSelPointF.X - _recStringView.X + _charSize.Width)' (int)_charSize.Height);  			if (lastLine.IntersectsWith (_recStringView)) {  				lastLine.Intersect (_recStringView);  				PaintCurrentByteSign (g' lastLine);  			}  		}  	}  }  else {  	if (_selectionLength == 0) {  		Point gp = GetGridBytePoint (_bytePos - _startByte);  		PointF pf = GetBytePointF (gp);  		Size s = new Size ((int)_charSize.Width * 2' (int)_charSize.Height);  		Rectangle r = new Rectangle ((int)pf.X' (int)pf.Y' s.Width' s.Height);  		PaintCurrentByteSign (g' r);  	}  	else {  		int lineWidth = (int)(_recHex.Width - _charSize.Width * 5);  		Point startSelGridPoint = GetGridBytePoint (_bytePos - _startByte);  		PointF startSelPointF = GetBytePointF (startSelGridPoint);  		Point endSelGridPoint = GetGridBytePoint (_bytePos - _startByte + _selectionLength - 1);  		PointF endSelPointF = GetBytePointF (endSelGridPoint);  		int multiLine = endSelGridPoint.Y - startSelGridPoint.Y;  		if (multiLine == 0) {  			Rectangle singleLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(endSelPointF.X - startSelPointF.X + _charSize.Width * 2)' (int)_charSize.Height);  			if (singleLine.IntersectsWith (_recHex)) {  				singleLine.Intersect (_recHex);  				PaintCurrentByteSign (g' singleLine);  			}  		}  		else {  			Rectangle firstLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(_recHex.X + lineWidth - startSelPointF.X + _charSize.Width * 2)' (int)_charSize.Height);  			if (firstLine.IntersectsWith (_recHex)) {  				firstLine.Intersect (_recHex);  				PaintCurrentByteSign (g' firstLine);  			}  			if (multiLine > 1) {  				Rectangle betweenLines = new Rectangle (_recHex.X' (int)(startSelPointF.Y + _charSize.Height)' (int)(lineWidth + _charSize.Width * 2)' (int)(_charSize.Height * (multiLine - 1)));  				if (betweenLines.IntersectsWith (_recHex)) {  					betweenLines.Intersect (_recHex);  					PaintCurrentByteSign (g' betweenLines);  				}  			}  			Rectangle lastLine = new Rectangle (_recHex.X' (int)endSelPointF.Y' (int)(endSelPointF.X - _recHex.X + _charSize.Width * 2)' (int)_charSize.Height);  			if (lastLine.IntersectsWith (_recHex)) {  				lastLine.Intersect (_recHex);  				PaintCurrentByteSign (g' lastLine);  			}  		}  	}  }  
Magic Number,Be.Windows.Forms,HexBox,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\Be.Windows.Forms.HexBox\HexBox.cs,PaintCurrentBytesSign,The following statement contains a magic number: if (_keyInterpreter.GetType () == typeof(KeyInterpreter)) {  	if (_selectionLength == 0) {  		Point gp = GetGridBytePoint (_bytePos - _startByte);  		PointF pf = GetByteStringPointF (gp);  		Size s = new Size ((int)_charSize.Width' (int)_charSize.Height);  		Rectangle r = new Rectangle ((int)pf.X' (int)pf.Y' s.Width' s.Height);  		if (r.IntersectsWith (_recStringView)) {  			r.Intersect (_recStringView);  			PaintCurrentByteSign (g' r);  		}  	}  	else {  		int lineWidth = (int)(_recStringView.Width - _charSize.Width);  		Point startSelGridPoint = GetGridBytePoint (_bytePos - _startByte);  		PointF startSelPointF = GetByteStringPointF (startSelGridPoint);  		Point endSelGridPoint = GetGridBytePoint (_bytePos - _startByte + _selectionLength - 1);  		PointF endSelPointF = GetByteStringPointF (endSelGridPoint);  		int multiLine = endSelGridPoint.Y - startSelGridPoint.Y;  		if (multiLine == 0) {  			Rectangle singleLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(endSelPointF.X - startSelPointF.X + _charSize.Width)' (int)_charSize.Height);  			if (singleLine.IntersectsWith (_recStringView)) {  				singleLine.Intersect (_recStringView);  				PaintCurrentByteSign (g' singleLine);  			}  		}  		else {  			Rectangle firstLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(_recStringView.X + lineWidth - startSelPointF.X + _charSize.Width)' (int)_charSize.Height);  			if (firstLine.IntersectsWith (_recStringView)) {  				firstLine.Intersect (_recStringView);  				PaintCurrentByteSign (g' firstLine);  			}  			if (multiLine > 1) {  				Rectangle betweenLines = new Rectangle (_recStringView.X' (int)(startSelPointF.Y + _charSize.Height)' (int)(_recStringView.Width)' (int)(_charSize.Height * (multiLine - 1)));  				if (betweenLines.IntersectsWith (_recStringView)) {  					betweenLines.Intersect (_recStringView);  					PaintCurrentByteSign (g' betweenLines);  				}  			}  			Rectangle lastLine = new Rectangle (_recStringView.X' (int)endSelPointF.Y' (int)(endSelPointF.X - _recStringView.X + _charSize.Width)' (int)_charSize.Height);  			if (lastLine.IntersectsWith (_recStringView)) {  				lastLine.Intersect (_recStringView);  				PaintCurrentByteSign (g' lastLine);  			}  		}  	}  }  else {  	if (_selectionLength == 0) {  		Point gp = GetGridBytePoint (_bytePos - _startByte);  		PointF pf = GetBytePointF (gp);  		Size s = new Size ((int)_charSize.Width * 2' (int)_charSize.Height);  		Rectangle r = new Rectangle ((int)pf.X' (int)pf.Y' s.Width' s.Height);  		PaintCurrentByteSign (g' r);  	}  	else {  		int lineWidth = (int)(_recHex.Width - _charSize.Width * 5);  		Point startSelGridPoint = GetGridBytePoint (_bytePos - _startByte);  		PointF startSelPointF = GetBytePointF (startSelGridPoint);  		Point endSelGridPoint = GetGridBytePoint (_bytePos - _startByte + _selectionLength - 1);  		PointF endSelPointF = GetBytePointF (endSelGridPoint);  		int multiLine = endSelGridPoint.Y - startSelGridPoint.Y;  		if (multiLine == 0) {  			Rectangle singleLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(endSelPointF.X - startSelPointF.X + _charSize.Width * 2)' (int)_charSize.Height);  			if (singleLine.IntersectsWith (_recHex)) {  				singleLine.Intersect (_recHex);  				PaintCurrentByteSign (g' singleLine);  			}  		}  		else {  			Rectangle firstLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(_recHex.X + lineWidth - startSelPointF.X + _charSize.Width * 2)' (int)_charSize.Height);  			if (firstLine.IntersectsWith (_recHex)) {  				firstLine.Intersect (_recHex);  				PaintCurrentByteSign (g' firstLine);  			}  			if (multiLine > 1) {  				Rectangle betweenLines = new Rectangle (_recHex.X' (int)(startSelPointF.Y + _charSize.Height)' (int)(lineWidth + _charSize.Width * 2)' (int)(_charSize.Height * (multiLine - 1)));  				if (betweenLines.IntersectsWith (_recHex)) {  					betweenLines.Intersect (_recHex);  					PaintCurrentByteSign (g' betweenLines);  				}  			}  			Rectangle lastLine = new Rectangle (_recHex.X' (int)endSelPointF.Y' (int)(endSelPointF.X - _recHex.X + _charSize.Width * 2)' (int)_charSize.Height);  			if (lastLine.IntersectsWith (_recHex)) {  				lastLine.Intersect (_recHex);  				PaintCurrentByteSign (g' lastLine);  			}  		}  	}  }  
Magic Number,Be.Windows.Forms,HexBox,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\Be.Windows.Forms.HexBox\HexBox.cs,PaintCurrentBytesSign,The following statement contains a magic number: if (_keyInterpreter.GetType () == typeof(KeyInterpreter)) {  	if (_selectionLength == 0) {  		Point gp = GetGridBytePoint (_bytePos - _startByte);  		PointF pf = GetByteStringPointF (gp);  		Size s = new Size ((int)_charSize.Width' (int)_charSize.Height);  		Rectangle r = new Rectangle ((int)pf.X' (int)pf.Y' s.Width' s.Height);  		if (r.IntersectsWith (_recStringView)) {  			r.Intersect (_recStringView);  			PaintCurrentByteSign (g' r);  		}  	}  	else {  		int lineWidth = (int)(_recStringView.Width - _charSize.Width);  		Point startSelGridPoint = GetGridBytePoint (_bytePos - _startByte);  		PointF startSelPointF = GetByteStringPointF (startSelGridPoint);  		Point endSelGridPoint = GetGridBytePoint (_bytePos - _startByte + _selectionLength - 1);  		PointF endSelPointF = GetByteStringPointF (endSelGridPoint);  		int multiLine = endSelGridPoint.Y - startSelGridPoint.Y;  		if (multiLine == 0) {  			Rectangle singleLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(endSelPointF.X - startSelPointF.X + _charSize.Width)' (int)_charSize.Height);  			if (singleLine.IntersectsWith (_recStringView)) {  				singleLine.Intersect (_recStringView);  				PaintCurrentByteSign (g' singleLine);  			}  		}  		else {  			Rectangle firstLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(_recStringView.X + lineWidth - startSelPointF.X + _charSize.Width)' (int)_charSize.Height);  			if (firstLine.IntersectsWith (_recStringView)) {  				firstLine.Intersect (_recStringView);  				PaintCurrentByteSign (g' firstLine);  			}  			if (multiLine > 1) {  				Rectangle betweenLines = new Rectangle (_recStringView.X' (int)(startSelPointF.Y + _charSize.Height)' (int)(_recStringView.Width)' (int)(_charSize.Height * (multiLine - 1)));  				if (betweenLines.IntersectsWith (_recStringView)) {  					betweenLines.Intersect (_recStringView);  					PaintCurrentByteSign (g' betweenLines);  				}  			}  			Rectangle lastLine = new Rectangle (_recStringView.X' (int)endSelPointF.Y' (int)(endSelPointF.X - _recStringView.X + _charSize.Width)' (int)_charSize.Height);  			if (lastLine.IntersectsWith (_recStringView)) {  				lastLine.Intersect (_recStringView);  				PaintCurrentByteSign (g' lastLine);  			}  		}  	}  }  else {  	if (_selectionLength == 0) {  		Point gp = GetGridBytePoint (_bytePos - _startByte);  		PointF pf = GetBytePointF (gp);  		Size s = new Size ((int)_charSize.Width * 2' (int)_charSize.Height);  		Rectangle r = new Rectangle ((int)pf.X' (int)pf.Y' s.Width' s.Height);  		PaintCurrentByteSign (g' r);  	}  	else {  		int lineWidth = (int)(_recHex.Width - _charSize.Width * 5);  		Point startSelGridPoint = GetGridBytePoint (_bytePos - _startByte);  		PointF startSelPointF = GetBytePointF (startSelGridPoint);  		Point endSelGridPoint = GetGridBytePoint (_bytePos - _startByte + _selectionLength - 1);  		PointF endSelPointF = GetBytePointF (endSelGridPoint);  		int multiLine = endSelGridPoint.Y - startSelGridPoint.Y;  		if (multiLine == 0) {  			Rectangle singleLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(endSelPointF.X - startSelPointF.X + _charSize.Width * 2)' (int)_charSize.Height);  			if (singleLine.IntersectsWith (_recHex)) {  				singleLine.Intersect (_recHex);  				PaintCurrentByteSign (g' singleLine);  			}  		}  		else {  			Rectangle firstLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(_recHex.X + lineWidth - startSelPointF.X + _charSize.Width * 2)' (int)_charSize.Height);  			if (firstLine.IntersectsWith (_recHex)) {  				firstLine.Intersect (_recHex);  				PaintCurrentByteSign (g' firstLine);  			}  			if (multiLine > 1) {  				Rectangle betweenLines = new Rectangle (_recHex.X' (int)(startSelPointF.Y + _charSize.Height)' (int)(lineWidth + _charSize.Width * 2)' (int)(_charSize.Height * (multiLine - 1)));  				if (betweenLines.IntersectsWith (_recHex)) {  					betweenLines.Intersect (_recHex);  					PaintCurrentByteSign (g' betweenLines);  				}  			}  			Rectangle lastLine = new Rectangle (_recHex.X' (int)endSelPointF.Y' (int)(endSelPointF.X - _recHex.X + _charSize.Width * 2)' (int)_charSize.Height);  			if (lastLine.IntersectsWith (_recHex)) {  				lastLine.Intersect (_recHex);  				PaintCurrentByteSign (g' lastLine);  			}  		}  	}  }  
Magic Number,Be.Windows.Forms,HexBox,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\Be.Windows.Forms.HexBox\HexBox.cs,PaintCurrentBytesSign,The following statement contains a magic number: if (_keyInterpreter.GetType () == typeof(KeyInterpreter)) {  	if (_selectionLength == 0) {  		Point gp = GetGridBytePoint (_bytePos - _startByte);  		PointF pf = GetByteStringPointF (gp);  		Size s = new Size ((int)_charSize.Width' (int)_charSize.Height);  		Rectangle r = new Rectangle ((int)pf.X' (int)pf.Y' s.Width' s.Height);  		if (r.IntersectsWith (_recStringView)) {  			r.Intersect (_recStringView);  			PaintCurrentByteSign (g' r);  		}  	}  	else {  		int lineWidth = (int)(_recStringView.Width - _charSize.Width);  		Point startSelGridPoint = GetGridBytePoint (_bytePos - _startByte);  		PointF startSelPointF = GetByteStringPointF (startSelGridPoint);  		Point endSelGridPoint = GetGridBytePoint (_bytePos - _startByte + _selectionLength - 1);  		PointF endSelPointF = GetByteStringPointF (endSelGridPoint);  		int multiLine = endSelGridPoint.Y - startSelGridPoint.Y;  		if (multiLine == 0) {  			Rectangle singleLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(endSelPointF.X - startSelPointF.X + _charSize.Width)' (int)_charSize.Height);  			if (singleLine.IntersectsWith (_recStringView)) {  				singleLine.Intersect (_recStringView);  				PaintCurrentByteSign (g' singleLine);  			}  		}  		else {  			Rectangle firstLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(_recStringView.X + lineWidth - startSelPointF.X + _charSize.Width)' (int)_charSize.Height);  			if (firstLine.IntersectsWith (_recStringView)) {  				firstLine.Intersect (_recStringView);  				PaintCurrentByteSign (g' firstLine);  			}  			if (multiLine > 1) {  				Rectangle betweenLines = new Rectangle (_recStringView.X' (int)(startSelPointF.Y + _charSize.Height)' (int)(_recStringView.Width)' (int)(_charSize.Height * (multiLine - 1)));  				if (betweenLines.IntersectsWith (_recStringView)) {  					betweenLines.Intersect (_recStringView);  					PaintCurrentByteSign (g' betweenLines);  				}  			}  			Rectangle lastLine = new Rectangle (_recStringView.X' (int)endSelPointF.Y' (int)(endSelPointF.X - _recStringView.X + _charSize.Width)' (int)_charSize.Height);  			if (lastLine.IntersectsWith (_recStringView)) {  				lastLine.Intersect (_recStringView);  				PaintCurrentByteSign (g' lastLine);  			}  		}  	}  }  else {  	if (_selectionLength == 0) {  		Point gp = GetGridBytePoint (_bytePos - _startByte);  		PointF pf = GetBytePointF (gp);  		Size s = new Size ((int)_charSize.Width * 2' (int)_charSize.Height);  		Rectangle r = new Rectangle ((int)pf.X' (int)pf.Y' s.Width' s.Height);  		PaintCurrentByteSign (g' r);  	}  	else {  		int lineWidth = (int)(_recHex.Width - _charSize.Width * 5);  		Point startSelGridPoint = GetGridBytePoint (_bytePos - _startByte);  		PointF startSelPointF = GetBytePointF (startSelGridPoint);  		Point endSelGridPoint = GetGridBytePoint (_bytePos - _startByte + _selectionLength - 1);  		PointF endSelPointF = GetBytePointF (endSelGridPoint);  		int multiLine = endSelGridPoint.Y - startSelGridPoint.Y;  		if (multiLine == 0) {  			Rectangle singleLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(endSelPointF.X - startSelPointF.X + _charSize.Width * 2)' (int)_charSize.Height);  			if (singleLine.IntersectsWith (_recHex)) {  				singleLine.Intersect (_recHex);  				PaintCurrentByteSign (g' singleLine);  			}  		}  		else {  			Rectangle firstLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(_recHex.X + lineWidth - startSelPointF.X + _charSize.Width * 2)' (int)_charSize.Height);  			if (firstLine.IntersectsWith (_recHex)) {  				firstLine.Intersect (_recHex);  				PaintCurrentByteSign (g' firstLine);  			}  			if (multiLine > 1) {  				Rectangle betweenLines = new Rectangle (_recHex.X' (int)(startSelPointF.Y + _charSize.Height)' (int)(lineWidth + _charSize.Width * 2)' (int)(_charSize.Height * (multiLine - 1)));  				if (betweenLines.IntersectsWith (_recHex)) {  					betweenLines.Intersect (_recHex);  					PaintCurrentByteSign (g' betweenLines);  				}  			}  			Rectangle lastLine = new Rectangle (_recHex.X' (int)endSelPointF.Y' (int)(endSelPointF.X - _recHex.X + _charSize.Width * 2)' (int)_charSize.Height);  			if (lastLine.IntersectsWith (_recHex)) {  				lastLine.Intersect (_recHex);  				PaintCurrentByteSign (g' lastLine);  			}  		}  	}  }  
Magic Number,Be.Windows.Forms,HexBox,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\Be.Windows.Forms.HexBox\HexBox.cs,PaintCurrentBytesSign,The following statement contains a magic number: if (_selectionLength == 0) {  	Point gp = GetGridBytePoint (_bytePos - _startByte);  	PointF pf = GetBytePointF (gp);  	Size s = new Size ((int)_charSize.Width * 2' (int)_charSize.Height);  	Rectangle r = new Rectangle ((int)pf.X' (int)pf.Y' s.Width' s.Height);  	PaintCurrentByteSign (g' r);  }  else {  	int lineWidth = (int)(_recHex.Width - _charSize.Width * 5);  	Point startSelGridPoint = GetGridBytePoint (_bytePos - _startByte);  	PointF startSelPointF = GetBytePointF (startSelGridPoint);  	Point endSelGridPoint = GetGridBytePoint (_bytePos - _startByte + _selectionLength - 1);  	PointF endSelPointF = GetBytePointF (endSelGridPoint);  	int multiLine = endSelGridPoint.Y - startSelGridPoint.Y;  	if (multiLine == 0) {  		Rectangle singleLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(endSelPointF.X - startSelPointF.X + _charSize.Width * 2)' (int)_charSize.Height);  		if (singleLine.IntersectsWith (_recHex)) {  			singleLine.Intersect (_recHex);  			PaintCurrentByteSign (g' singleLine);  		}  	}  	else {  		Rectangle firstLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(_recHex.X + lineWidth - startSelPointF.X + _charSize.Width * 2)' (int)_charSize.Height);  		if (firstLine.IntersectsWith (_recHex)) {  			firstLine.Intersect (_recHex);  			PaintCurrentByteSign (g' firstLine);  		}  		if (multiLine > 1) {  			Rectangle betweenLines = new Rectangle (_recHex.X' (int)(startSelPointF.Y + _charSize.Height)' (int)(lineWidth + _charSize.Width * 2)' (int)(_charSize.Height * (multiLine - 1)));  			if (betweenLines.IntersectsWith (_recHex)) {  				betweenLines.Intersect (_recHex);  				PaintCurrentByteSign (g' betweenLines);  			}  		}  		Rectangle lastLine = new Rectangle (_recHex.X' (int)endSelPointF.Y' (int)(endSelPointF.X - _recHex.X + _charSize.Width * 2)' (int)_charSize.Height);  		if (lastLine.IntersectsWith (_recHex)) {  			lastLine.Intersect (_recHex);  			PaintCurrentByteSign (g' lastLine);  		}  	}  }  
Magic Number,Be.Windows.Forms,HexBox,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\Be.Windows.Forms.HexBox\HexBox.cs,PaintCurrentBytesSign,The following statement contains a magic number: if (_selectionLength == 0) {  	Point gp = GetGridBytePoint (_bytePos - _startByte);  	PointF pf = GetBytePointF (gp);  	Size s = new Size ((int)_charSize.Width * 2' (int)_charSize.Height);  	Rectangle r = new Rectangle ((int)pf.X' (int)pf.Y' s.Width' s.Height);  	PaintCurrentByteSign (g' r);  }  else {  	int lineWidth = (int)(_recHex.Width - _charSize.Width * 5);  	Point startSelGridPoint = GetGridBytePoint (_bytePos - _startByte);  	PointF startSelPointF = GetBytePointF (startSelGridPoint);  	Point endSelGridPoint = GetGridBytePoint (_bytePos - _startByte + _selectionLength - 1);  	PointF endSelPointF = GetBytePointF (endSelGridPoint);  	int multiLine = endSelGridPoint.Y - startSelGridPoint.Y;  	if (multiLine == 0) {  		Rectangle singleLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(endSelPointF.X - startSelPointF.X + _charSize.Width * 2)' (int)_charSize.Height);  		if (singleLine.IntersectsWith (_recHex)) {  			singleLine.Intersect (_recHex);  			PaintCurrentByteSign (g' singleLine);  		}  	}  	else {  		Rectangle firstLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(_recHex.X + lineWidth - startSelPointF.X + _charSize.Width * 2)' (int)_charSize.Height);  		if (firstLine.IntersectsWith (_recHex)) {  			firstLine.Intersect (_recHex);  			PaintCurrentByteSign (g' firstLine);  		}  		if (multiLine > 1) {  			Rectangle betweenLines = new Rectangle (_recHex.X' (int)(startSelPointF.Y + _charSize.Height)' (int)(lineWidth + _charSize.Width * 2)' (int)(_charSize.Height * (multiLine - 1)));  			if (betweenLines.IntersectsWith (_recHex)) {  				betweenLines.Intersect (_recHex);  				PaintCurrentByteSign (g' betweenLines);  			}  		}  		Rectangle lastLine = new Rectangle (_recHex.X' (int)endSelPointF.Y' (int)(endSelPointF.X - _recHex.X + _charSize.Width * 2)' (int)_charSize.Height);  		if (lastLine.IntersectsWith (_recHex)) {  			lastLine.Intersect (_recHex);  			PaintCurrentByteSign (g' lastLine);  		}  	}  }  
Magic Number,Be.Windows.Forms,HexBox,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\Be.Windows.Forms.HexBox\HexBox.cs,PaintCurrentBytesSign,The following statement contains a magic number: if (_selectionLength == 0) {  	Point gp = GetGridBytePoint (_bytePos - _startByte);  	PointF pf = GetBytePointF (gp);  	Size s = new Size ((int)_charSize.Width * 2' (int)_charSize.Height);  	Rectangle r = new Rectangle ((int)pf.X' (int)pf.Y' s.Width' s.Height);  	PaintCurrentByteSign (g' r);  }  else {  	int lineWidth = (int)(_recHex.Width - _charSize.Width * 5);  	Point startSelGridPoint = GetGridBytePoint (_bytePos - _startByte);  	PointF startSelPointF = GetBytePointF (startSelGridPoint);  	Point endSelGridPoint = GetGridBytePoint (_bytePos - _startByte + _selectionLength - 1);  	PointF endSelPointF = GetBytePointF (endSelGridPoint);  	int multiLine = endSelGridPoint.Y - startSelGridPoint.Y;  	if (multiLine == 0) {  		Rectangle singleLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(endSelPointF.X - startSelPointF.X + _charSize.Width * 2)' (int)_charSize.Height);  		if (singleLine.IntersectsWith (_recHex)) {  			singleLine.Intersect (_recHex);  			PaintCurrentByteSign (g' singleLine);  		}  	}  	else {  		Rectangle firstLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(_recHex.X + lineWidth - startSelPointF.X + _charSize.Width * 2)' (int)_charSize.Height);  		if (firstLine.IntersectsWith (_recHex)) {  			firstLine.Intersect (_recHex);  			PaintCurrentByteSign (g' firstLine);  		}  		if (multiLine > 1) {  			Rectangle betweenLines = new Rectangle (_recHex.X' (int)(startSelPointF.Y + _charSize.Height)' (int)(lineWidth + _charSize.Width * 2)' (int)(_charSize.Height * (multiLine - 1)));  			if (betweenLines.IntersectsWith (_recHex)) {  				betweenLines.Intersect (_recHex);  				PaintCurrentByteSign (g' betweenLines);  			}  		}  		Rectangle lastLine = new Rectangle (_recHex.X' (int)endSelPointF.Y' (int)(endSelPointF.X - _recHex.X + _charSize.Width * 2)' (int)_charSize.Height);  		if (lastLine.IntersectsWith (_recHex)) {  			lastLine.Intersect (_recHex);  			PaintCurrentByteSign (g' lastLine);  		}  	}  }  
Magic Number,Be.Windows.Forms,HexBox,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\Be.Windows.Forms.HexBox\HexBox.cs,PaintCurrentBytesSign,The following statement contains a magic number: if (_selectionLength == 0) {  	Point gp = GetGridBytePoint (_bytePos - _startByte);  	PointF pf = GetBytePointF (gp);  	Size s = new Size ((int)_charSize.Width * 2' (int)_charSize.Height);  	Rectangle r = new Rectangle ((int)pf.X' (int)pf.Y' s.Width' s.Height);  	PaintCurrentByteSign (g' r);  }  else {  	int lineWidth = (int)(_recHex.Width - _charSize.Width * 5);  	Point startSelGridPoint = GetGridBytePoint (_bytePos - _startByte);  	PointF startSelPointF = GetBytePointF (startSelGridPoint);  	Point endSelGridPoint = GetGridBytePoint (_bytePos - _startByte + _selectionLength - 1);  	PointF endSelPointF = GetBytePointF (endSelGridPoint);  	int multiLine = endSelGridPoint.Y - startSelGridPoint.Y;  	if (multiLine == 0) {  		Rectangle singleLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(endSelPointF.X - startSelPointF.X + _charSize.Width * 2)' (int)_charSize.Height);  		if (singleLine.IntersectsWith (_recHex)) {  			singleLine.Intersect (_recHex);  			PaintCurrentByteSign (g' singleLine);  		}  	}  	else {  		Rectangle firstLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(_recHex.X + lineWidth - startSelPointF.X + _charSize.Width * 2)' (int)_charSize.Height);  		if (firstLine.IntersectsWith (_recHex)) {  			firstLine.Intersect (_recHex);  			PaintCurrentByteSign (g' firstLine);  		}  		if (multiLine > 1) {  			Rectangle betweenLines = new Rectangle (_recHex.X' (int)(startSelPointF.Y + _charSize.Height)' (int)(lineWidth + _charSize.Width * 2)' (int)(_charSize.Height * (multiLine - 1)));  			if (betweenLines.IntersectsWith (_recHex)) {  				betweenLines.Intersect (_recHex);  				PaintCurrentByteSign (g' betweenLines);  			}  		}  		Rectangle lastLine = new Rectangle (_recHex.X' (int)endSelPointF.Y' (int)(endSelPointF.X - _recHex.X + _charSize.Width * 2)' (int)_charSize.Height);  		if (lastLine.IntersectsWith (_recHex)) {  			lastLine.Intersect (_recHex);  			PaintCurrentByteSign (g' lastLine);  		}  	}  }  
Magic Number,Be.Windows.Forms,HexBox,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\Be.Windows.Forms.HexBox\HexBox.cs,PaintCurrentBytesSign,The following statement contains a magic number: if (_selectionLength == 0) {  	Point gp = GetGridBytePoint (_bytePos - _startByte);  	PointF pf = GetBytePointF (gp);  	Size s = new Size ((int)_charSize.Width * 2' (int)_charSize.Height);  	Rectangle r = new Rectangle ((int)pf.X' (int)pf.Y' s.Width' s.Height);  	PaintCurrentByteSign (g' r);  }  else {  	int lineWidth = (int)(_recHex.Width - _charSize.Width * 5);  	Point startSelGridPoint = GetGridBytePoint (_bytePos - _startByte);  	PointF startSelPointF = GetBytePointF (startSelGridPoint);  	Point endSelGridPoint = GetGridBytePoint (_bytePos - _startByte + _selectionLength - 1);  	PointF endSelPointF = GetBytePointF (endSelGridPoint);  	int multiLine = endSelGridPoint.Y - startSelGridPoint.Y;  	if (multiLine == 0) {  		Rectangle singleLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(endSelPointF.X - startSelPointF.X + _charSize.Width * 2)' (int)_charSize.Height);  		if (singleLine.IntersectsWith (_recHex)) {  			singleLine.Intersect (_recHex);  			PaintCurrentByteSign (g' singleLine);  		}  	}  	else {  		Rectangle firstLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(_recHex.X + lineWidth - startSelPointF.X + _charSize.Width * 2)' (int)_charSize.Height);  		if (firstLine.IntersectsWith (_recHex)) {  			firstLine.Intersect (_recHex);  			PaintCurrentByteSign (g' firstLine);  		}  		if (multiLine > 1) {  			Rectangle betweenLines = new Rectangle (_recHex.X' (int)(startSelPointF.Y + _charSize.Height)' (int)(lineWidth + _charSize.Width * 2)' (int)(_charSize.Height * (multiLine - 1)));  			if (betweenLines.IntersectsWith (_recHex)) {  				betweenLines.Intersect (_recHex);  				PaintCurrentByteSign (g' betweenLines);  			}  		}  		Rectangle lastLine = new Rectangle (_recHex.X' (int)endSelPointF.Y' (int)(endSelPointF.X - _recHex.X + _charSize.Width * 2)' (int)_charSize.Height);  		if (lastLine.IntersectsWith (_recHex)) {  			lastLine.Intersect (_recHex);  			PaintCurrentByteSign (g' lastLine);  		}  	}  }  
Magic Number,Be.Windows.Forms,HexBox,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\Be.Windows.Forms.HexBox\HexBox.cs,PaintCurrentBytesSign,The following statement contains a magic number: if (_selectionLength == 0) {  	Point gp = GetGridBytePoint (_bytePos - _startByte);  	PointF pf = GetBytePointF (gp);  	Size s = new Size ((int)_charSize.Width * 2' (int)_charSize.Height);  	Rectangle r = new Rectangle ((int)pf.X' (int)pf.Y' s.Width' s.Height);  	PaintCurrentByteSign (g' r);  }  else {  	int lineWidth = (int)(_recHex.Width - _charSize.Width * 5);  	Point startSelGridPoint = GetGridBytePoint (_bytePos - _startByte);  	PointF startSelPointF = GetBytePointF (startSelGridPoint);  	Point endSelGridPoint = GetGridBytePoint (_bytePos - _startByte + _selectionLength - 1);  	PointF endSelPointF = GetBytePointF (endSelGridPoint);  	int multiLine = endSelGridPoint.Y - startSelGridPoint.Y;  	if (multiLine == 0) {  		Rectangle singleLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(endSelPointF.X - startSelPointF.X + _charSize.Width * 2)' (int)_charSize.Height);  		if (singleLine.IntersectsWith (_recHex)) {  			singleLine.Intersect (_recHex);  			PaintCurrentByteSign (g' singleLine);  		}  	}  	else {  		Rectangle firstLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(_recHex.X + lineWidth - startSelPointF.X + _charSize.Width * 2)' (int)_charSize.Height);  		if (firstLine.IntersectsWith (_recHex)) {  			firstLine.Intersect (_recHex);  			PaintCurrentByteSign (g' firstLine);  		}  		if (multiLine > 1) {  			Rectangle betweenLines = new Rectangle (_recHex.X' (int)(startSelPointF.Y + _charSize.Height)' (int)(lineWidth + _charSize.Width * 2)' (int)(_charSize.Height * (multiLine - 1)));  			if (betweenLines.IntersectsWith (_recHex)) {  				betweenLines.Intersect (_recHex);  				PaintCurrentByteSign (g' betweenLines);  			}  		}  		Rectangle lastLine = new Rectangle (_recHex.X' (int)endSelPointF.Y' (int)(endSelPointF.X - _recHex.X + _charSize.Width * 2)' (int)_charSize.Height);  		if (lastLine.IntersectsWith (_recHex)) {  			lastLine.Intersect (_recHex);  			PaintCurrentByteSign (g' lastLine);  		}  	}  }  
Magic Number,Be.Windows.Forms,HexBox,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\Be.Windows.Forms.HexBox\HexBox.cs,PaintCurrentBytesSign,The following statement contains a magic number: if (multiLine == 0) {  	Rectangle singleLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(endSelPointF.X - startSelPointF.X + _charSize.Width * 2)' (int)_charSize.Height);  	if (singleLine.IntersectsWith (_recHex)) {  		singleLine.Intersect (_recHex);  		PaintCurrentByteSign (g' singleLine);  	}  }  else {  	Rectangle firstLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(_recHex.X + lineWidth - startSelPointF.X + _charSize.Width * 2)' (int)_charSize.Height);  	if (firstLine.IntersectsWith (_recHex)) {  		firstLine.Intersect (_recHex);  		PaintCurrentByteSign (g' firstLine);  	}  	if (multiLine > 1) {  		Rectangle betweenLines = new Rectangle (_recHex.X' (int)(startSelPointF.Y + _charSize.Height)' (int)(lineWidth + _charSize.Width * 2)' (int)(_charSize.Height * (multiLine - 1)));  		if (betweenLines.IntersectsWith (_recHex)) {  			betweenLines.Intersect (_recHex);  			PaintCurrentByteSign (g' betweenLines);  		}  	}  	Rectangle lastLine = new Rectangle (_recHex.X' (int)endSelPointF.Y' (int)(endSelPointF.X - _recHex.X + _charSize.Width * 2)' (int)_charSize.Height);  	if (lastLine.IntersectsWith (_recHex)) {  		lastLine.Intersect (_recHex);  		PaintCurrentByteSign (g' lastLine);  	}  }  
Magic Number,Be.Windows.Forms,HexBox,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\Be.Windows.Forms.HexBox\HexBox.cs,PaintCurrentBytesSign,The following statement contains a magic number: if (multiLine == 0) {  	Rectangle singleLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(endSelPointF.X - startSelPointF.X + _charSize.Width * 2)' (int)_charSize.Height);  	if (singleLine.IntersectsWith (_recHex)) {  		singleLine.Intersect (_recHex);  		PaintCurrentByteSign (g' singleLine);  	}  }  else {  	Rectangle firstLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(_recHex.X + lineWidth - startSelPointF.X + _charSize.Width * 2)' (int)_charSize.Height);  	if (firstLine.IntersectsWith (_recHex)) {  		firstLine.Intersect (_recHex);  		PaintCurrentByteSign (g' firstLine);  	}  	if (multiLine > 1) {  		Rectangle betweenLines = new Rectangle (_recHex.X' (int)(startSelPointF.Y + _charSize.Height)' (int)(lineWidth + _charSize.Width * 2)' (int)(_charSize.Height * (multiLine - 1)));  		if (betweenLines.IntersectsWith (_recHex)) {  			betweenLines.Intersect (_recHex);  			PaintCurrentByteSign (g' betweenLines);  		}  	}  	Rectangle lastLine = new Rectangle (_recHex.X' (int)endSelPointF.Y' (int)(endSelPointF.X - _recHex.X + _charSize.Width * 2)' (int)_charSize.Height);  	if (lastLine.IntersectsWith (_recHex)) {  		lastLine.Intersect (_recHex);  		PaintCurrentByteSign (g' lastLine);  	}  }  
Magic Number,Be.Windows.Forms,HexBox,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\Be.Windows.Forms.HexBox\HexBox.cs,PaintCurrentBytesSign,The following statement contains a magic number: if (multiLine == 0) {  	Rectangle singleLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(endSelPointF.X - startSelPointF.X + _charSize.Width * 2)' (int)_charSize.Height);  	if (singleLine.IntersectsWith (_recHex)) {  		singleLine.Intersect (_recHex);  		PaintCurrentByteSign (g' singleLine);  	}  }  else {  	Rectangle firstLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(_recHex.X + lineWidth - startSelPointF.X + _charSize.Width * 2)' (int)_charSize.Height);  	if (firstLine.IntersectsWith (_recHex)) {  		firstLine.Intersect (_recHex);  		PaintCurrentByteSign (g' firstLine);  	}  	if (multiLine > 1) {  		Rectangle betweenLines = new Rectangle (_recHex.X' (int)(startSelPointF.Y + _charSize.Height)' (int)(lineWidth + _charSize.Width * 2)' (int)(_charSize.Height * (multiLine - 1)));  		if (betweenLines.IntersectsWith (_recHex)) {  			betweenLines.Intersect (_recHex);  			PaintCurrentByteSign (g' betweenLines);  		}  	}  	Rectangle lastLine = new Rectangle (_recHex.X' (int)endSelPointF.Y' (int)(endSelPointF.X - _recHex.X + _charSize.Width * 2)' (int)_charSize.Height);  	if (lastLine.IntersectsWith (_recHex)) {  		lastLine.Intersect (_recHex);  		PaintCurrentByteSign (g' lastLine);  	}  }  
Magic Number,Be.Windows.Forms,HexBox,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\Be.Windows.Forms.HexBox\HexBox.cs,PaintCurrentBytesSign,The following statement contains a magic number: if (multiLine == 0) {  	Rectangle singleLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(endSelPointF.X - startSelPointF.X + _charSize.Width * 2)' (int)_charSize.Height);  	if (singleLine.IntersectsWith (_recHex)) {  		singleLine.Intersect (_recHex);  		PaintCurrentByteSign (g' singleLine);  	}  }  else {  	Rectangle firstLine = new Rectangle ((int)startSelPointF.X' (int)startSelPointF.Y' (int)(_recHex.X + lineWidth - startSelPointF.X + _charSize.Width * 2)' (int)_charSize.Height);  	if (firstLine.IntersectsWith (_recHex)) {  		firstLine.Intersect (_recHex);  		PaintCurrentByteSign (g' firstLine);  	}  	if (multiLine > 1) {  		Rectangle betweenLines = new Rectangle (_recHex.X' (int)(startSelPointF.Y + _charSize.Height)' (int)(lineWidth + _charSize.Width * 2)' (int)(_charSize.Height * (multiLine - 1)));  		if (betweenLines.IntersectsWith (_recHex)) {  			betweenLines.Intersect (_recHex);  			PaintCurrentByteSign (g' betweenLines);  		}  	}  	Rectangle lastLine = new Rectangle (_recHex.X' (int)endSelPointF.Y' (int)(endSelPointF.X - _recHex.X + _charSize.Width * 2)' (int)_charSize.Height);  	if (lastLine.IntersectsWith (_recHex)) {  		lastLine.Intersect (_recHex);  		PaintCurrentByteSign (g' lastLine);  	}  }  
Magic Number,Be.Windows.Forms,HexBox,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\Be.Windows.Forms.HexBox\HexBox.cs,PaintCurrentBytesSign,The following statement contains a magic number: if (multiLine > 1) {  	Rectangle betweenLines = new Rectangle (_recHex.X' (int)(startSelPointF.Y + _charSize.Height)' (int)(lineWidth + _charSize.Width * 2)' (int)(_charSize.Height * (multiLine - 1)));  	if (betweenLines.IntersectsWith (_recHex)) {  		betweenLines.Intersect (_recHex);  		PaintCurrentByteSign (g' betweenLines);  	}  }  
Magic Number,Be.Windows.Forms,HexBox,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\Be.Windows.Forms.HexBox\HexBox.cs,UpdateRectanglePositioning,The following statement contains a magic number: if (_lineInfoVisible) {  	_recLineInfo = new Rectangle (_recContent.X + marginLeft' _recContent.Y' (int)(_charSize.Width * 10)' _recContent.Height);  }  else {  	_recLineInfo = Rectangle.Empty;  	_recLineInfo.X = marginLeft;  }  
Magic Number,Be.Windows.Forms,HexBox,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\Be.Windows.Forms.HexBox\HexBox.cs,UpdateRectanglePositioning,The following statement contains a magic number: _recLineInfo = new Rectangle (_recContent.X + marginLeft' _recContent.Y' (int)(_charSize.Width * 10)' _recContent.Height);  
Magic Number,Be.Windows.Forms,HexBox,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\Be.Windows.Forms.HexBox\HexBox.cs,UpdateRectanglePositioning,The following statement contains a magic number: if (UseFixedBytesPerLine) {  	SetHorizontalByteCount (_bytesPerLine);  	_recHex.Width = (int)Math.Floor (((double)_iHexMaxHBytes) * _charSize.Width * 3 + (2 * _charSize.Width));  }  else {  	int hmax = (int)Math.Floor ((double)_recHex.Width / (double)_charSize.Width);  	if (hmax > 1)  		SetHorizontalByteCount ((int)Math.Floor ((double)hmax / 3));  	else  		SetHorizontalByteCount (hmax);  }  
Magic Number,Be.Windows.Forms,HexBox,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\Be.Windows.Forms.HexBox\HexBox.cs,UpdateRectanglePositioning,The following statement contains a magic number: if (UseFixedBytesPerLine) {  	SetHorizontalByteCount (_bytesPerLine);  	_recHex.Width = (int)Math.Floor (((double)_iHexMaxHBytes) * _charSize.Width * 3 + (2 * _charSize.Width));  }  else {  	int hmax = (int)Math.Floor ((double)_recHex.Width / (double)_charSize.Width);  	if (hmax > 1)  		SetHorizontalByteCount ((int)Math.Floor ((double)hmax / 3));  	else  		SetHorizontalByteCount (hmax);  }  
Magic Number,Be.Windows.Forms,HexBox,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\Be.Windows.Forms.HexBox\HexBox.cs,UpdateRectanglePositioning,The following statement contains a magic number: if (UseFixedBytesPerLine) {  	SetHorizontalByteCount (_bytesPerLine);  	_recHex.Width = (int)Math.Floor (((double)_iHexMaxHBytes) * _charSize.Width * 3 + (2 * _charSize.Width));  }  else {  	int hmax = (int)Math.Floor ((double)_recHex.Width / (double)_charSize.Width);  	if (hmax > 1)  		SetHorizontalByteCount ((int)Math.Floor ((double)hmax / 3));  	else  		SetHorizontalByteCount (hmax);  }  
Magic Number,Be.Windows.Forms,HexBox,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\Be.Windows.Forms.HexBox\HexBox.cs,UpdateRectanglePositioning,The following statement contains a magic number: _recHex.Width = (int)Math.Floor (((double)_iHexMaxHBytes) * _charSize.Width * 3 + (2 * _charSize.Width));  
Magic Number,Be.Windows.Forms,HexBox,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\Be.Windows.Forms.HexBox\HexBox.cs,UpdateRectanglePositioning,The following statement contains a magic number: _recHex.Width = (int)Math.Floor (((double)_iHexMaxHBytes) * _charSize.Width * 3 + (2 * _charSize.Width));  
Magic Number,Be.Windows.Forms,HexBox,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\Be.Windows.Forms.HexBox\HexBox.cs,UpdateRectanglePositioning,The following statement contains a magic number: if (hmax > 1)  	SetHorizontalByteCount ((int)Math.Floor ((double)hmax / 3));  else  	SetHorizontalByteCount (hmax);  
Magic Number,Be.Windows.Forms,HexBox,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\Be.Windows.Forms.HexBox\HexBox.cs,UpdateRectanglePositioning,The following statement contains a magic number: SetHorizontalByteCount ((int)Math.Floor ((double)hmax / 3));  
Magic Number,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,menuNetwork_Popup,The following statement contains a magic number: try {  	bool hasValid = false;  	foreach (ListViewItem item in listNetwork.SelectedItems) {  		if (item.SubItems [5].Text == "TCP") {  			if (item.SubItems [6].Text != "Listening" && item.SubItems [6].Text != "CloseWait" && item.SubItems [6].Text != "TimeWait") {  				hasValid = true;  				break;  			}  		}  	}  	if (!hasValid)  		closeNetworkMenuItem.Enabled = false;  }  catch (Exception ex) {  	Logging.Log (ex);  }  
Magic Number,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,menuNetwork_Popup,The following statement contains a magic number: try {  	bool hasValid = false;  	foreach (ListViewItem item in listNetwork.SelectedItems) {  		if (item.SubItems [5].Text == "TCP") {  			if (item.SubItems [6].Text != "Listening" && item.SubItems [6].Text != "CloseWait" && item.SubItems [6].Text != "TimeWait") {  				hasValid = true;  				break;  			}  		}  	}  	if (!hasValid)  		closeNetworkMenuItem.Enabled = false;  }  catch (Exception ex) {  	Logging.Log (ex);  }  
Magic Number,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,menuNetwork_Popup,The following statement contains a magic number: try {  	bool hasValid = false;  	foreach (ListViewItem item in listNetwork.SelectedItems) {  		if (item.SubItems [5].Text == "TCP") {  			if (item.SubItems [6].Text != "Listening" && item.SubItems [6].Text != "CloseWait" && item.SubItems [6].Text != "TimeWait") {  				hasValid = true;  				break;  			}  		}  	}  	if (!hasValid)  		closeNetworkMenuItem.Enabled = false;  }  catch (Exception ex) {  	Logging.Log (ex);  }  
Magic Number,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,menuNetwork_Popup,The following statement contains a magic number: try {  	bool hasValid = false;  	foreach (ListViewItem item in listNetwork.SelectedItems) {  		if (item.SubItems [5].Text == "TCP") {  			if (item.SubItems [6].Text != "Listening" && item.SubItems [6].Text != "CloseWait" && item.SubItems [6].Text != "TimeWait") {  				hasValid = true;  				break;  			}  		}  	}  	if (!hasValid)  		closeNetworkMenuItem.Enabled = false;  }  catch (Exception ex) {  	Logging.Log (ex);  }  
Magic Number,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,menuNetwork_Popup,The following statement contains a magic number: foreach (ListViewItem item in listNetwork.SelectedItems) {  	if (item.SubItems [5].Text == "TCP") {  		if (item.SubItems [6].Text != "Listening" && item.SubItems [6].Text != "CloseWait" && item.SubItems [6].Text != "TimeWait") {  			hasValid = true;  			break;  		}  	}  }  
Magic Number,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,menuNetwork_Popup,The following statement contains a magic number: foreach (ListViewItem item in listNetwork.SelectedItems) {  	if (item.SubItems [5].Text == "TCP") {  		if (item.SubItems [6].Text != "Listening" && item.SubItems [6].Text != "CloseWait" && item.SubItems [6].Text != "TimeWait") {  			hasValid = true;  			break;  		}  	}  }  
Magic Number,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,menuNetwork_Popup,The following statement contains a magic number: foreach (ListViewItem item in listNetwork.SelectedItems) {  	if (item.SubItems [5].Text == "TCP") {  		if (item.SubItems [6].Text != "Listening" && item.SubItems [6].Text != "CloseWait" && item.SubItems [6].Text != "TimeWait") {  			hasValid = true;  			break;  		}  	}  }  
Magic Number,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,menuNetwork_Popup,The following statement contains a magic number: foreach (ListViewItem item in listNetwork.SelectedItems) {  	if (item.SubItems [5].Text == "TCP") {  		if (item.SubItems [6].Text != "Listening" && item.SubItems [6].Text != "CloseWait" && item.SubItems [6].Text != "TimeWait") {  			hasValid = true;  			break;  		}  	}  }  
Magic Number,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,menuNetwork_Popup,The following statement contains a magic number: if (item.SubItems [5].Text == "TCP") {  	if (item.SubItems [6].Text != "Listening" && item.SubItems [6].Text != "CloseWait" && item.SubItems [6].Text != "TimeWait") {  		hasValid = true;  		break;  	}  }  
Magic Number,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,menuNetwork_Popup,The following statement contains a magic number: if (item.SubItems [5].Text == "TCP") {  	if (item.SubItems [6].Text != "Listening" && item.SubItems [6].Text != "CloseWait" && item.SubItems [6].Text != "TimeWait") {  		hasValid = true;  		break;  	}  }  
Magic Number,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,menuNetwork_Popup,The following statement contains a magic number: if (item.SubItems [5].Text == "TCP") {  	if (item.SubItems [6].Text != "Listening" && item.SubItems [6].Text != "CloseWait" && item.SubItems [6].Text != "TimeWait") {  		hasValid = true;  		break;  	}  }  
Magic Number,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,menuNetwork_Popup,The following statement contains a magic number: if (item.SubItems [5].Text == "TCP") {  	if (item.SubItems [6].Text != "Listening" && item.SubItems [6].Text != "CloseWait" && item.SubItems [6].Text != "TimeWait") {  		hasValid = true;  		break;  	}  }  
Magic Number,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,menuNetwork_Popup,The following statement contains a magic number: if (item.SubItems [6].Text != "Listening" && item.SubItems [6].Text != "CloseWait" && item.SubItems [6].Text != "TimeWait") {  	hasValid = true;  	break;  }  
Magic Number,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,menuNetwork_Popup,The following statement contains a magic number: if (item.SubItems [6].Text != "Listening" && item.SubItems [6].Text != "CloseWait" && item.SubItems [6].Text != "TimeWait") {  	hasValid = true;  	break;  }  
Magic Number,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,menuNetwork_Popup,The following statement contains a magic number: if (item.SubItems [6].Text != "Listening" && item.SubItems [6].Text != "CloseWait" && item.SubItems [6].Text != "TimeWait") {  	hasValid = true;  	break;  }  
Magic Number,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,menuNetwork_Popup,The following statement contains a magic number: try {  	bool hasValid = false;  	foreach (ListViewItem item in listNetwork.SelectedItems) {  		if (item.SubItems [3].Text.Length > 0) {  			hasValid = true;  			break;  		}  	}  	if (!hasValid) {  		whoisNetworkMenuItem.Enabled = false;  		tracertNetworkMenuItem.Enabled = false;  		pingNetworkMenuItem.Enabled = false;  	}  	else {  		whoisNetworkMenuItem.Enabled = true;  		tracertNetworkMenuItem.Enabled = true;  		pingNetworkMenuItem.Enabled = true;  	}  }  catch (Exception ex) {  	Logging.Log (ex);  }  
Magic Number,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,menuNetwork_Popup,The following statement contains a magic number: foreach (ListViewItem item in listNetwork.SelectedItems) {  	if (item.SubItems [3].Text.Length > 0) {  		hasValid = true;  		break;  	}  }  
Magic Number,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,menuNetwork_Popup,The following statement contains a magic number: if (item.SubItems [3].Text.Length > 0) {  	hasValid = true;  	break;  }  
Magic Number,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,closeNetworkMenuItem_Click,The following statement contains a magic number: try {  	foreach (ListViewItem item in listNetwork.SelectedItems) {  		if (item.SubItems [5].Text != "TCP" || item.SubItems [6].Text != "Established")  			continue;  		try {  			Program.NetworkProvider.Dictionary [item.Name].Connection.CloseTcpConnection ();  		}  		catch {  			allGood = false;  			if (MessageBox.Show ("Could not close the TCP connection. " + "Make sure Process Hacker is running with administrative privileges."' "Process Hacker"' MessageBoxButtons.OKCancel' MessageBoxIcon.Error) == DialogResult.Cancel)  				return;  		}  	}  }  catch (Exception ex) {  	Logging.Log (ex);  }  
Magic Number,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,closeNetworkMenuItem_Click,The following statement contains a magic number: try {  	foreach (ListViewItem item in listNetwork.SelectedItems) {  		if (item.SubItems [5].Text != "TCP" || item.SubItems [6].Text != "Established")  			continue;  		try {  			Program.NetworkProvider.Dictionary [item.Name].Connection.CloseTcpConnection ();  		}  		catch {  			allGood = false;  			if (MessageBox.Show ("Could not close the TCP connection. " + "Make sure Process Hacker is running with administrative privileges."' "Process Hacker"' MessageBoxButtons.OKCancel' MessageBoxIcon.Error) == DialogResult.Cancel)  				return;  		}  	}  }  catch (Exception ex) {  	Logging.Log (ex);  }  
Magic Number,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,closeNetworkMenuItem_Click,The following statement contains a magic number: foreach (ListViewItem item in listNetwork.SelectedItems) {  	if (item.SubItems [5].Text != "TCP" || item.SubItems [6].Text != "Established")  		continue;  	try {  		Program.NetworkProvider.Dictionary [item.Name].Connection.CloseTcpConnection ();  	}  	catch {  		allGood = false;  		if (MessageBox.Show ("Could not close the TCP connection. " + "Make sure Process Hacker is running with administrative privileges."' "Process Hacker"' MessageBoxButtons.OKCancel' MessageBoxIcon.Error) == DialogResult.Cancel)  			return;  	}  }  
Magic Number,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,closeNetworkMenuItem_Click,The following statement contains a magic number: foreach (ListViewItem item in listNetwork.SelectedItems) {  	if (item.SubItems [5].Text != "TCP" || item.SubItems [6].Text != "Established")  		continue;  	try {  		Program.NetworkProvider.Dictionary [item.Name].Connection.CloseTcpConnection ();  	}  	catch {  		allGood = false;  		if (MessageBox.Show ("Could not close the TCP connection. " + "Make sure Process Hacker is running with administrative privileges."' "Process Hacker"' MessageBoxButtons.OKCancel' MessageBoxIcon.Error) == DialogResult.Cancel)  			return;  	}  }  
Magic Number,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,closeNetworkMenuItem_Click,The following statement contains a magic number: if (item.SubItems [5].Text != "TCP" || item.SubItems [6].Text != "Established")  	continue;  
Magic Number,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,closeNetworkMenuItem_Click,The following statement contains a magic number: if (item.SubItems [5].Text != "TCP" || item.SubItems [6].Text != "Established")  	continue;  
Magic Number,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,menuProcess_Popup,The following statement contains a magic number: if (treeProcesses.SelectedTreeNodes.Count == 0) {  	// If nothing is selected' disable everything.  	// The Select All menu item will be enabled later if   	// we have at least one process in the tree.  	menuProcess.DisableAll ();  }  else if (treeProcesses.SelectedTreeNodes.Count == 1) {  	// All actions should work with one process selected.  	menuProcess.EnableAll ();  	// Singular nouns.  	priorityMenuItem.Text = "&Priority";  	terminateMenuItem.Text = "&Terminate Process";  	suspendMenuItem.Text = "&Suspend Process";  	resumeMenuItem.Text = "&Resume Process";  	// Clear the priority menu items.  	realTimeMenuItem.Checked = false;  	highMenuItem.Checked = false;  	aboveNormalMenuItem.Checked = false;  	normalMenuItem.Checked = false;  	belowNormalMenuItem.Checked = false;  	idleMenuItem.Checked = false;  	// Clear the I/O priority menu items.  	ioPriorityThreadMenuItem.Enabled = true;  	ioPriority0ThreadMenuItem.Checked = false;  	ioPriority1ThreadMenuItem.Checked = false;  	ioPriority2ThreadMenuItem.Checked = false;  	ioPriority3ThreadMenuItem.Checked = false;  	try {  		using (var phandle = new ProcessHandle (processSelectedPid' Program.MinProcessQueryRights)) {  			try {  				switch (phandle.GetPriorityClass ()) {  				case ProcessPriorityClass.RealTime:  					realTimeMenuItem.Checked = true;  					break;  				case ProcessPriorityClass.High:  					highMenuItem.Checked = true;  					break;  				case ProcessPriorityClass.AboveNormal:  					aboveNormalMenuItem.Checked = true;  					break;  				case ProcessPriorityClass.Normal:  					normalMenuItem.Checked = true;  					break;  				case ProcessPriorityClass.BelowNormal:  					belowNormalMenuItem.Checked = true;  					break;  				case ProcessPriorityClass.Idle:  					idleMenuItem.Checked = true;  					break;  				}  			}  			catch {  				priorityMenuItem.Enabled = false;  			}  			try {  				if (OSVersion.HasIoPriority) {  					switch (phandle.GetIoPriority ()) {  					case 0:  						ioPriority0ThreadMenuItem.Checked = true;  						break;  					case 1:  						ioPriority1ThreadMenuItem.Checked = true;  						break;  					case 2:  						ioPriority2ThreadMenuItem.Checked = true;  						break;  					case 3:  						ioPriority3ThreadMenuItem.Checked = true;  						break;  					}  				}  			}  			catch {  				ioPriorityThreadMenuItem.Enabled = false;  			}  		}  	}  	catch {  		priorityMenuItem.Enabled = false;  		ioPriorityThreadMenuItem.Enabled = false;  	}  	// Check if we think the process exists. If we don't' disable all menu items  	// to avoid random exceptions occurring when the user clicks on certain things.  	if (!Program.ProcessProvider.Dictionary.ContainsKey (processSelectedPid)) {  		menuProcess.DisableAll ();  	}  	else {  		// Check the virtualization menu item.  		try {  			using (var phandle = new ProcessHandle (processSelectedPid' Program.MinProcessQueryRights)) {  				try {  					using (var thandle = phandle.GetToken (TokenAccess.Query)) {  						if (virtualizationProcessMenuItem.Enabled = thandle.IsVirtualizationAllowed ())  							virtualizationProcessMenuItem.Checked = thandle.IsVirtualizationEnabled ();  					}  				}  				catch {  				}  			}  		}  		catch {  			virtualizationProcessMenuItem.Enabled = false;  		}  		// Enable/disable DLL injection based on the process' session ID. This only applies   		// on XP and above.  		try {  			if (OSVersion.IsBelowOrEqual (WindowsVersion.XP) && Program.ProcessProvider.Dictionary [processSelectedPid].SessionId != Program.CurrentSessionId)  				injectDllProcessMenuItem.Enabled = false;  			else  				injectDllProcessMenuItem.Enabled = true;  		}  		catch (Exception ex) {  			Logging.Log (ex);  		}  		// Disable Terminate Process Tree if the selected process doesn't   		// have any children. Note that this may also happen if the user   		// is sorting the list (!).  		try {  			if (treeProcesses.SelectedTreeNodes [0].IsLeaf && (treeProcesses.Tree.Model as ProcessTreeModel).GetSortColumn () == "")  				terminateProcessTreeMenuItem.Visible = false;  			else  				terminateProcessTreeMenuItem.Visible = true;  		}  		catch (Exception ex) {  			Logging.Log (ex);  		}  		// Find the process' window (if any).  		windowHandle = WindowHandle.Zero;  		WindowHandle.Enumerate (handle =>  {  			// GetWindowLong  			// Shell_TrayWnd  			if (handle.IsWindow () && handle.IsVisible () && handle.IsParent ()) {  				int pid;  				Win32.GetWindowThreadProcessId (handle' out pid);  				if (pid == processSelectedPid) {  					windowHandle = handle;  					return false;  				}  			}  			return true;  		});  		// Enable the Window submenu if we found window owned   		// by the process. Otherwise' disable the submenu.  		if (windowHandle.IsInvalid) {  			windowProcessMenuItem.Enabled = false;  		}  		else {  			windowProcessMenuItem.Enabled = true;  			windowProcessMenuItem.EnableAll ();  			switch (windowHandle.GetPlacement ().ShowState) {  			case ShowWindowType.ShowMinimized:  				minimizeProcessMenuItem.Enabled = false;  				break;  			case ShowWindowType.ShowMaximized:  				maximizeProcessMenuItem.Enabled = false;  				break;  			case ShowWindowType.ShowNormal:  				restoreProcessMenuItem.Enabled = false;  				break;  			}  		}  	}  }  else {  	// Assume most process actions will not work with more than one process.  	menuProcess.DisableAll ();  	// Use plural nouns.  	terminateMenuItem.Text = "&Terminate Processes";  	suspendMenuItem.Text = "&Suspend Processes";  	resumeMenuItem.Text = "&Resume Processes";  	// Enable a specific set of actions.  	terminateMenuItem.Enabled = true;  	suspendMenuItem.Enabled = true;  	resumeMenuItem.Enabled = true;  	reduceWorkingSetProcessMenuItem.Enabled = true;  	copyProcessMenuItem.Enabled = true;  }  
Magic Number,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,menuProcess_Popup,The following statement contains a magic number: if (treeProcesses.SelectedTreeNodes.Count == 0) {  	// If nothing is selected' disable everything.  	// The Select All menu item will be enabled later if   	// we have at least one process in the tree.  	menuProcess.DisableAll ();  }  else if (treeProcesses.SelectedTreeNodes.Count == 1) {  	// All actions should work with one process selected.  	menuProcess.EnableAll ();  	// Singular nouns.  	priorityMenuItem.Text = "&Priority";  	terminateMenuItem.Text = "&Terminate Process";  	suspendMenuItem.Text = "&Suspend Process";  	resumeMenuItem.Text = "&Resume Process";  	// Clear the priority menu items.  	realTimeMenuItem.Checked = false;  	highMenuItem.Checked = false;  	aboveNormalMenuItem.Checked = false;  	normalMenuItem.Checked = false;  	belowNormalMenuItem.Checked = false;  	idleMenuItem.Checked = false;  	// Clear the I/O priority menu items.  	ioPriorityThreadMenuItem.Enabled = true;  	ioPriority0ThreadMenuItem.Checked = false;  	ioPriority1ThreadMenuItem.Checked = false;  	ioPriority2ThreadMenuItem.Checked = false;  	ioPriority3ThreadMenuItem.Checked = false;  	try {  		using (var phandle = new ProcessHandle (processSelectedPid' Program.MinProcessQueryRights)) {  			try {  				switch (phandle.GetPriorityClass ()) {  				case ProcessPriorityClass.RealTime:  					realTimeMenuItem.Checked = true;  					break;  				case ProcessPriorityClass.High:  					highMenuItem.Checked = true;  					break;  				case ProcessPriorityClass.AboveNormal:  					aboveNormalMenuItem.Checked = true;  					break;  				case ProcessPriorityClass.Normal:  					normalMenuItem.Checked = true;  					break;  				case ProcessPriorityClass.BelowNormal:  					belowNormalMenuItem.Checked = true;  					break;  				case ProcessPriorityClass.Idle:  					idleMenuItem.Checked = true;  					break;  				}  			}  			catch {  				priorityMenuItem.Enabled = false;  			}  			try {  				if (OSVersion.HasIoPriority) {  					switch (phandle.GetIoPriority ()) {  					case 0:  						ioPriority0ThreadMenuItem.Checked = true;  						break;  					case 1:  						ioPriority1ThreadMenuItem.Checked = true;  						break;  					case 2:  						ioPriority2ThreadMenuItem.Checked = true;  						break;  					case 3:  						ioPriority3ThreadMenuItem.Checked = true;  						break;  					}  				}  			}  			catch {  				ioPriorityThreadMenuItem.Enabled = false;  			}  		}  	}  	catch {  		priorityMenuItem.Enabled = false;  		ioPriorityThreadMenuItem.Enabled = false;  	}  	// Check if we think the process exists. If we don't' disable all menu items  	// to avoid random exceptions occurring when the user clicks on certain things.  	if (!Program.ProcessProvider.Dictionary.ContainsKey (processSelectedPid)) {  		menuProcess.DisableAll ();  	}  	else {  		// Check the virtualization menu item.  		try {  			using (var phandle = new ProcessHandle (processSelectedPid' Program.MinProcessQueryRights)) {  				try {  					using (var thandle = phandle.GetToken (TokenAccess.Query)) {  						if (virtualizationProcessMenuItem.Enabled = thandle.IsVirtualizationAllowed ())  							virtualizationProcessMenuItem.Checked = thandle.IsVirtualizationEnabled ();  					}  				}  				catch {  				}  			}  		}  		catch {  			virtualizationProcessMenuItem.Enabled = false;  		}  		// Enable/disable DLL injection based on the process' session ID. This only applies   		// on XP and above.  		try {  			if (OSVersion.IsBelowOrEqual (WindowsVersion.XP) && Program.ProcessProvider.Dictionary [processSelectedPid].SessionId != Program.CurrentSessionId)  				injectDllProcessMenuItem.Enabled = false;  			else  				injectDllProcessMenuItem.Enabled = true;  		}  		catch (Exception ex) {  			Logging.Log (ex);  		}  		// Disable Terminate Process Tree if the selected process doesn't   		// have any children. Note that this may also happen if the user   		// is sorting the list (!).  		try {  			if (treeProcesses.SelectedTreeNodes [0].IsLeaf && (treeProcesses.Tree.Model as ProcessTreeModel).GetSortColumn () == "")  				terminateProcessTreeMenuItem.Visible = false;  			else  				terminateProcessTreeMenuItem.Visible = true;  		}  		catch (Exception ex) {  			Logging.Log (ex);  		}  		// Find the process' window (if any).  		windowHandle = WindowHandle.Zero;  		WindowHandle.Enumerate (handle =>  {  			// GetWindowLong  			// Shell_TrayWnd  			if (handle.IsWindow () && handle.IsVisible () && handle.IsParent ()) {  				int pid;  				Win32.GetWindowThreadProcessId (handle' out pid);  				if (pid == processSelectedPid) {  					windowHandle = handle;  					return false;  				}  			}  			return true;  		});  		// Enable the Window submenu if we found window owned   		// by the process. Otherwise' disable the submenu.  		if (windowHandle.IsInvalid) {  			windowProcessMenuItem.Enabled = false;  		}  		else {  			windowProcessMenuItem.Enabled = true;  			windowProcessMenuItem.EnableAll ();  			switch (windowHandle.GetPlacement ().ShowState) {  			case ShowWindowType.ShowMinimized:  				minimizeProcessMenuItem.Enabled = false;  				break;  			case ShowWindowType.ShowMaximized:  				maximizeProcessMenuItem.Enabled = false;  				break;  			case ShowWindowType.ShowNormal:  				restoreProcessMenuItem.Enabled = false;  				break;  			}  		}  	}  }  else {  	// Assume most process actions will not work with more than one process.  	menuProcess.DisableAll ();  	// Use plural nouns.  	terminateMenuItem.Text = "&Terminate Processes";  	suspendMenuItem.Text = "&Suspend Processes";  	resumeMenuItem.Text = "&Resume Processes";  	// Enable a specific set of actions.  	terminateMenuItem.Enabled = true;  	suspendMenuItem.Enabled = true;  	resumeMenuItem.Enabled = true;  	reduceWorkingSetProcessMenuItem.Enabled = true;  	copyProcessMenuItem.Enabled = true;  }  
Magic Number,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,menuProcess_Popup,The following statement contains a magic number: if (treeProcesses.SelectedTreeNodes.Count == 1) {  	// All actions should work with one process selected.  	menuProcess.EnableAll ();  	// Singular nouns.  	priorityMenuItem.Text = "&Priority";  	terminateMenuItem.Text = "&Terminate Process";  	suspendMenuItem.Text = "&Suspend Process";  	resumeMenuItem.Text = "&Resume Process";  	// Clear the priority menu items.  	realTimeMenuItem.Checked = false;  	highMenuItem.Checked = false;  	aboveNormalMenuItem.Checked = false;  	normalMenuItem.Checked = false;  	belowNormalMenuItem.Checked = false;  	idleMenuItem.Checked = false;  	// Clear the I/O priority menu items.  	ioPriorityThreadMenuItem.Enabled = true;  	ioPriority0ThreadMenuItem.Checked = false;  	ioPriority1ThreadMenuItem.Checked = false;  	ioPriority2ThreadMenuItem.Checked = false;  	ioPriority3ThreadMenuItem.Checked = false;  	try {  		using (var phandle = new ProcessHandle (processSelectedPid' Program.MinProcessQueryRights)) {  			try {  				switch (phandle.GetPriorityClass ()) {  				case ProcessPriorityClass.RealTime:  					realTimeMenuItem.Checked = true;  					break;  				case ProcessPriorityClass.High:  					highMenuItem.Checked = true;  					break;  				case ProcessPriorityClass.AboveNormal:  					aboveNormalMenuItem.Checked = true;  					break;  				case ProcessPriorityClass.Normal:  					normalMenuItem.Checked = true;  					break;  				case ProcessPriorityClass.BelowNormal:  					belowNormalMenuItem.Checked = true;  					break;  				case ProcessPriorityClass.Idle:  					idleMenuItem.Checked = true;  					break;  				}  			}  			catch {  				priorityMenuItem.Enabled = false;  			}  			try {  				if (OSVersion.HasIoPriority) {  					switch (phandle.GetIoPriority ()) {  					case 0:  						ioPriority0ThreadMenuItem.Checked = true;  						break;  					case 1:  						ioPriority1ThreadMenuItem.Checked = true;  						break;  					case 2:  						ioPriority2ThreadMenuItem.Checked = true;  						break;  					case 3:  						ioPriority3ThreadMenuItem.Checked = true;  						break;  					}  				}  			}  			catch {  				ioPriorityThreadMenuItem.Enabled = false;  			}  		}  	}  	catch {  		priorityMenuItem.Enabled = false;  		ioPriorityThreadMenuItem.Enabled = false;  	}  	// Check if we think the process exists. If we don't' disable all menu items  	// to avoid random exceptions occurring when the user clicks on certain things.  	if (!Program.ProcessProvider.Dictionary.ContainsKey (processSelectedPid)) {  		menuProcess.DisableAll ();  	}  	else {  		// Check the virtualization menu item.  		try {  			using (var phandle = new ProcessHandle (processSelectedPid' Program.MinProcessQueryRights)) {  				try {  					using (var thandle = phandle.GetToken (TokenAccess.Query)) {  						if (virtualizationProcessMenuItem.Enabled = thandle.IsVirtualizationAllowed ())  							virtualizationProcessMenuItem.Checked = thandle.IsVirtualizationEnabled ();  					}  				}  				catch {  				}  			}  		}  		catch {  			virtualizationProcessMenuItem.Enabled = false;  		}  		// Enable/disable DLL injection based on the process' session ID. This only applies   		// on XP and above.  		try {  			if (OSVersion.IsBelowOrEqual (WindowsVersion.XP) && Program.ProcessProvider.Dictionary [processSelectedPid].SessionId != Program.CurrentSessionId)  				injectDllProcessMenuItem.Enabled = false;  			else  				injectDllProcessMenuItem.Enabled = true;  		}  		catch (Exception ex) {  			Logging.Log (ex);  		}  		// Disable Terminate Process Tree if the selected process doesn't   		// have any children. Note that this may also happen if the user   		// is sorting the list (!).  		try {  			if (treeProcesses.SelectedTreeNodes [0].IsLeaf && (treeProcesses.Tree.Model as ProcessTreeModel).GetSortColumn () == "")  				terminateProcessTreeMenuItem.Visible = false;  			else  				terminateProcessTreeMenuItem.Visible = true;  		}  		catch (Exception ex) {  			Logging.Log (ex);  		}  		// Find the process' window (if any).  		windowHandle = WindowHandle.Zero;  		WindowHandle.Enumerate (handle =>  {  			// GetWindowLong  			// Shell_TrayWnd  			if (handle.IsWindow () && handle.IsVisible () && handle.IsParent ()) {  				int pid;  				Win32.GetWindowThreadProcessId (handle' out pid);  				if (pid == processSelectedPid) {  					windowHandle = handle;  					return false;  				}  			}  			return true;  		});  		// Enable the Window submenu if we found window owned   		// by the process. Otherwise' disable the submenu.  		if (windowHandle.IsInvalid) {  			windowProcessMenuItem.Enabled = false;  		}  		else {  			windowProcessMenuItem.Enabled = true;  			windowProcessMenuItem.EnableAll ();  			switch (windowHandle.GetPlacement ().ShowState) {  			case ShowWindowType.ShowMinimized:  				minimizeProcessMenuItem.Enabled = false;  				break;  			case ShowWindowType.ShowMaximized:  				maximizeProcessMenuItem.Enabled = false;  				break;  			case ShowWindowType.ShowNormal:  				restoreProcessMenuItem.Enabled = false;  				break;  			}  		}  	}  }  else {  	// Assume most process actions will not work with more than one process.  	menuProcess.DisableAll ();  	// Use plural nouns.  	terminateMenuItem.Text = "&Terminate Processes";  	suspendMenuItem.Text = "&Suspend Processes";  	resumeMenuItem.Text = "&Resume Processes";  	// Enable a specific set of actions.  	terminateMenuItem.Enabled = true;  	suspendMenuItem.Enabled = true;  	resumeMenuItem.Enabled = true;  	reduceWorkingSetProcessMenuItem.Enabled = true;  	copyProcessMenuItem.Enabled = true;  }  
Magic Number,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,menuProcess_Popup,The following statement contains a magic number: if (treeProcesses.SelectedTreeNodes.Count == 1) {  	// All actions should work with one process selected.  	menuProcess.EnableAll ();  	// Singular nouns.  	priorityMenuItem.Text = "&Priority";  	terminateMenuItem.Text = "&Terminate Process";  	suspendMenuItem.Text = "&Suspend Process";  	resumeMenuItem.Text = "&Resume Process";  	// Clear the priority menu items.  	realTimeMenuItem.Checked = false;  	highMenuItem.Checked = false;  	aboveNormalMenuItem.Checked = false;  	normalMenuItem.Checked = false;  	belowNormalMenuItem.Checked = false;  	idleMenuItem.Checked = false;  	// Clear the I/O priority menu items.  	ioPriorityThreadMenuItem.Enabled = true;  	ioPriority0ThreadMenuItem.Checked = false;  	ioPriority1ThreadMenuItem.Checked = false;  	ioPriority2ThreadMenuItem.Checked = false;  	ioPriority3ThreadMenuItem.Checked = false;  	try {  		using (var phandle = new ProcessHandle (processSelectedPid' Program.MinProcessQueryRights)) {  			try {  				switch (phandle.GetPriorityClass ()) {  				case ProcessPriorityClass.RealTime:  					realTimeMenuItem.Checked = true;  					break;  				case ProcessPriorityClass.High:  					highMenuItem.Checked = true;  					break;  				case ProcessPriorityClass.AboveNormal:  					aboveNormalMenuItem.Checked = true;  					break;  				case ProcessPriorityClass.Normal:  					normalMenuItem.Checked = true;  					break;  				case ProcessPriorityClass.BelowNormal:  					belowNormalMenuItem.Checked = true;  					break;  				case ProcessPriorityClass.Idle:  					idleMenuItem.Checked = true;  					break;  				}  			}  			catch {  				priorityMenuItem.Enabled = false;  			}  			try {  				if (OSVersion.HasIoPriority) {  					switch (phandle.GetIoPriority ()) {  					case 0:  						ioPriority0ThreadMenuItem.Checked = true;  						break;  					case 1:  						ioPriority1ThreadMenuItem.Checked = true;  						break;  					case 2:  						ioPriority2ThreadMenuItem.Checked = true;  						break;  					case 3:  						ioPriority3ThreadMenuItem.Checked = true;  						break;  					}  				}  			}  			catch {  				ioPriorityThreadMenuItem.Enabled = false;  			}  		}  	}  	catch {  		priorityMenuItem.Enabled = false;  		ioPriorityThreadMenuItem.Enabled = false;  	}  	// Check if we think the process exists. If we don't' disable all menu items  	// to avoid random exceptions occurring when the user clicks on certain things.  	if (!Program.ProcessProvider.Dictionary.ContainsKey (processSelectedPid)) {  		menuProcess.DisableAll ();  	}  	else {  		// Check the virtualization menu item.  		try {  			using (var phandle = new ProcessHandle (processSelectedPid' Program.MinProcessQueryRights)) {  				try {  					using (var thandle = phandle.GetToken (TokenAccess.Query)) {  						if (virtualizationProcessMenuItem.Enabled = thandle.IsVirtualizationAllowed ())  							virtualizationProcessMenuItem.Checked = thandle.IsVirtualizationEnabled ();  					}  				}  				catch {  				}  			}  		}  		catch {  			virtualizationProcessMenuItem.Enabled = false;  		}  		// Enable/disable DLL injection based on the process' session ID. This only applies   		// on XP and above.  		try {  			if (OSVersion.IsBelowOrEqual (WindowsVersion.XP) && Program.ProcessProvider.Dictionary [processSelectedPid].SessionId != Program.CurrentSessionId)  				injectDllProcessMenuItem.Enabled = false;  			else  				injectDllProcessMenuItem.Enabled = true;  		}  		catch (Exception ex) {  			Logging.Log (ex);  		}  		// Disable Terminate Process Tree if the selected process doesn't   		// have any children. Note that this may also happen if the user   		// is sorting the list (!).  		try {  			if (treeProcesses.SelectedTreeNodes [0].IsLeaf && (treeProcesses.Tree.Model as ProcessTreeModel).GetSortColumn () == "")  				terminateProcessTreeMenuItem.Visible = false;  			else  				terminateProcessTreeMenuItem.Visible = true;  		}  		catch (Exception ex) {  			Logging.Log (ex);  		}  		// Find the process' window (if any).  		windowHandle = WindowHandle.Zero;  		WindowHandle.Enumerate (handle =>  {  			// GetWindowLong  			// Shell_TrayWnd  			if (handle.IsWindow () && handle.IsVisible () && handle.IsParent ()) {  				int pid;  				Win32.GetWindowThreadProcessId (handle' out pid);  				if (pid == processSelectedPid) {  					windowHandle = handle;  					return false;  				}  			}  			return true;  		});  		// Enable the Window submenu if we found window owned   		// by the process. Otherwise' disable the submenu.  		if (windowHandle.IsInvalid) {  			windowProcessMenuItem.Enabled = false;  		}  		else {  			windowProcessMenuItem.Enabled = true;  			windowProcessMenuItem.EnableAll ();  			switch (windowHandle.GetPlacement ().ShowState) {  			case ShowWindowType.ShowMinimized:  				minimizeProcessMenuItem.Enabled = false;  				break;  			case ShowWindowType.ShowMaximized:  				maximizeProcessMenuItem.Enabled = false;  				break;  			case ShowWindowType.ShowNormal:  				restoreProcessMenuItem.Enabled = false;  				break;  			}  		}  	}  }  else {  	// Assume most process actions will not work with more than one process.  	menuProcess.DisableAll ();  	// Use plural nouns.  	terminateMenuItem.Text = "&Terminate Processes";  	suspendMenuItem.Text = "&Suspend Processes";  	resumeMenuItem.Text = "&Resume Processes";  	// Enable a specific set of actions.  	terminateMenuItem.Enabled = true;  	suspendMenuItem.Enabled = true;  	resumeMenuItem.Enabled = true;  	reduceWorkingSetProcessMenuItem.Enabled = true;  	copyProcessMenuItem.Enabled = true;  }  
Magic Number,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,menuProcess_Popup,The following statement contains a magic number: try {  	using (var phandle = new ProcessHandle (processSelectedPid' Program.MinProcessQueryRights)) {  		try {  			switch (phandle.GetPriorityClass ()) {  			case ProcessPriorityClass.RealTime:  				realTimeMenuItem.Checked = true;  				break;  			case ProcessPriorityClass.High:  				highMenuItem.Checked = true;  				break;  			case ProcessPriorityClass.AboveNormal:  				aboveNormalMenuItem.Checked = true;  				break;  			case ProcessPriorityClass.Normal:  				normalMenuItem.Checked = true;  				break;  			case ProcessPriorityClass.BelowNormal:  				belowNormalMenuItem.Checked = true;  				break;  			case ProcessPriorityClass.Idle:  				idleMenuItem.Checked = true;  				break;  			}  		}  		catch {  			priorityMenuItem.Enabled = false;  		}  		try {  			if (OSVersion.HasIoPriority) {  				switch (phandle.GetIoPriority ()) {  				case 0:  					ioPriority0ThreadMenuItem.Checked = true;  					break;  				case 1:  					ioPriority1ThreadMenuItem.Checked = true;  					break;  				case 2:  					ioPriority2ThreadMenuItem.Checked = true;  					break;  				case 3:  					ioPriority3ThreadMenuItem.Checked = true;  					break;  				}  			}  		}  		catch {  			ioPriorityThreadMenuItem.Enabled = false;  		}  	}  }  catch {  	priorityMenuItem.Enabled = false;  	ioPriorityThreadMenuItem.Enabled = false;  }  
Magic Number,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,menuProcess_Popup,The following statement contains a magic number: try {  	using (var phandle = new ProcessHandle (processSelectedPid' Program.MinProcessQueryRights)) {  		try {  			switch (phandle.GetPriorityClass ()) {  			case ProcessPriorityClass.RealTime:  				realTimeMenuItem.Checked = true;  				break;  			case ProcessPriorityClass.High:  				highMenuItem.Checked = true;  				break;  			case ProcessPriorityClass.AboveNormal:  				aboveNormalMenuItem.Checked = true;  				break;  			case ProcessPriorityClass.Normal:  				normalMenuItem.Checked = true;  				break;  			case ProcessPriorityClass.BelowNormal:  				belowNormalMenuItem.Checked = true;  				break;  			case ProcessPriorityClass.Idle:  				idleMenuItem.Checked = true;  				break;  			}  		}  		catch {  			priorityMenuItem.Enabled = false;  		}  		try {  			if (OSVersion.HasIoPriority) {  				switch (phandle.GetIoPriority ()) {  				case 0:  					ioPriority0ThreadMenuItem.Checked = true;  					break;  				case 1:  					ioPriority1ThreadMenuItem.Checked = true;  					break;  				case 2:  					ioPriority2ThreadMenuItem.Checked = true;  					break;  				case 3:  					ioPriority3ThreadMenuItem.Checked = true;  					break;  				}  			}  		}  		catch {  			ioPriorityThreadMenuItem.Enabled = false;  		}  	}  }  catch {  	priorityMenuItem.Enabled = false;  	ioPriorityThreadMenuItem.Enabled = false;  }  
Magic Number,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,menuProcess_Popup,The following statement contains a magic number: using (var phandle = new ProcessHandle (processSelectedPid' Program.MinProcessQueryRights)) {  	try {  		switch (phandle.GetPriorityClass ()) {  		case ProcessPriorityClass.RealTime:  			realTimeMenuItem.Checked = true;  			break;  		case ProcessPriorityClass.High:  			highMenuItem.Checked = true;  			break;  		case ProcessPriorityClass.AboveNormal:  			aboveNormalMenuItem.Checked = true;  			break;  		case ProcessPriorityClass.Normal:  			normalMenuItem.Checked = true;  			break;  		case ProcessPriorityClass.BelowNormal:  			belowNormalMenuItem.Checked = true;  			break;  		case ProcessPriorityClass.Idle:  			idleMenuItem.Checked = true;  			break;  		}  	}  	catch {  		priorityMenuItem.Enabled = false;  	}  	try {  		if (OSVersion.HasIoPriority) {  			switch (phandle.GetIoPriority ()) {  			case 0:  				ioPriority0ThreadMenuItem.Checked = true;  				break;  			case 1:  				ioPriority1ThreadMenuItem.Checked = true;  				break;  			case 2:  				ioPriority2ThreadMenuItem.Checked = true;  				break;  			case 3:  				ioPriority3ThreadMenuItem.Checked = true;  				break;  			}  		}  	}  	catch {  		ioPriorityThreadMenuItem.Enabled = false;  	}  }  
Magic Number,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,menuProcess_Popup,The following statement contains a magic number: using (var phandle = new ProcessHandle (processSelectedPid' Program.MinProcessQueryRights)) {  	try {  		switch (phandle.GetPriorityClass ()) {  		case ProcessPriorityClass.RealTime:  			realTimeMenuItem.Checked = true;  			break;  		case ProcessPriorityClass.High:  			highMenuItem.Checked = true;  			break;  		case ProcessPriorityClass.AboveNormal:  			aboveNormalMenuItem.Checked = true;  			break;  		case ProcessPriorityClass.Normal:  			normalMenuItem.Checked = true;  			break;  		case ProcessPriorityClass.BelowNormal:  			belowNormalMenuItem.Checked = true;  			break;  		case ProcessPriorityClass.Idle:  			idleMenuItem.Checked = true;  			break;  		}  	}  	catch {  		priorityMenuItem.Enabled = false;  	}  	try {  		if (OSVersion.HasIoPriority) {  			switch (phandle.GetIoPriority ()) {  			case 0:  				ioPriority0ThreadMenuItem.Checked = true;  				break;  			case 1:  				ioPriority1ThreadMenuItem.Checked = true;  				break;  			case 2:  				ioPriority2ThreadMenuItem.Checked = true;  				break;  			case 3:  				ioPriority3ThreadMenuItem.Checked = true;  				break;  			}  		}  	}  	catch {  		ioPriorityThreadMenuItem.Enabled = false;  	}  }  
Magic Number,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,menuProcess_Popup,The following statement contains a magic number: try {  	if (OSVersion.HasIoPriority) {  		switch (phandle.GetIoPriority ()) {  		case 0:  			ioPriority0ThreadMenuItem.Checked = true;  			break;  		case 1:  			ioPriority1ThreadMenuItem.Checked = true;  			break;  		case 2:  			ioPriority2ThreadMenuItem.Checked = true;  			break;  		case 3:  			ioPriority3ThreadMenuItem.Checked = true;  			break;  		}  	}  }  catch {  	ioPriorityThreadMenuItem.Enabled = false;  }  
Magic Number,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,menuProcess_Popup,The following statement contains a magic number: try {  	if (OSVersion.HasIoPriority) {  		switch (phandle.GetIoPriority ()) {  		case 0:  			ioPriority0ThreadMenuItem.Checked = true;  			break;  		case 1:  			ioPriority1ThreadMenuItem.Checked = true;  			break;  		case 2:  			ioPriority2ThreadMenuItem.Checked = true;  			break;  		case 3:  			ioPriority3ThreadMenuItem.Checked = true;  			break;  		}  	}  }  catch {  	ioPriorityThreadMenuItem.Enabled = false;  }  
Magic Number,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,menuProcess_Popup,The following statement contains a magic number: if (OSVersion.HasIoPriority) {  	switch (phandle.GetIoPriority ()) {  	case 0:  		ioPriority0ThreadMenuItem.Checked = true;  		break;  	case 1:  		ioPriority1ThreadMenuItem.Checked = true;  		break;  	case 2:  		ioPriority2ThreadMenuItem.Checked = true;  		break;  	case 3:  		ioPriority3ThreadMenuItem.Checked = true;  		break;  	}  }  
Magic Number,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,menuProcess_Popup,The following statement contains a magic number: if (OSVersion.HasIoPriority) {  	switch (phandle.GetIoPriority ()) {  	case 0:  		ioPriority0ThreadMenuItem.Checked = true;  		break;  	case 1:  		ioPriority1ThreadMenuItem.Checked = true;  		break;  	case 2:  		ioPriority2ThreadMenuItem.Checked = true;  		break;  	case 3:  		ioPriority3ThreadMenuItem.Checked = true;  		break;  	}  }  
Magic Number,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,menuProcess_Popup,The following statement contains a magic number: switch (phandle.GetIoPriority ()) {  case 0:  	ioPriority0ThreadMenuItem.Checked = true;  	break;  case 1:  	ioPriority1ThreadMenuItem.Checked = true;  	break;  case 2:  	ioPriority2ThreadMenuItem.Checked = true;  	break;  case 3:  	ioPriority3ThreadMenuItem.Checked = true;  	break;  }  
Magic Number,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,menuProcess_Popup,The following statement contains a magic number: switch (phandle.GetIoPriority ()) {  case 0:  	ioPriority0ThreadMenuItem.Checked = true;  	break;  case 1:  	ioPriority1ThreadMenuItem.Checked = true;  	break;  case 2:  	ioPriority2ThreadMenuItem.Checked = true;  	break;  case 3:  	ioPriority3ThreadMenuItem.Checked = true;  	break;  }  
Magic Number,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,createDumpFileProcessMenuItem_Click,The following statement contains a magic number: if (sfd.ShowDialog () == DialogResult.OK) {  	this.Cursor = Cursors.WaitCursor;  	try {  		Exception exception = null;  		ThreadStart dumpProcess = () =>  {  			try {  				using (var phandle = new ProcessHandle (processSelectedPid' ProcessAccess.DupHandle | ProcessAccess.QueryInformation | ProcessAccess.SuspendResume | ProcessAccess.VmRead))  					phandle.WriteDump (sfd.FileName);  			}  			catch (Exception ex2) {  				exception = ex2;  			}  		};  		if (OSVersion.HasTaskDialogs) {  			// Use a task dialog to display a fancy progress bar.  			TaskDialog td = new TaskDialog ();  			Thread t = new Thread (dumpProcess' Utils.SixteenthStackSize);  			td.AllowDialogCancellation = false;  			td.Buttons = new TaskDialogButton[] {  				new TaskDialogButton ((int)DialogResult.OK' "Close")  			};  			td.WindowTitle = "Process Hacker";  			td.MainInstruction = "Creating the dump file...";  			td.ShowMarqueeProgressBar = true;  			td.EnableHyperlinks = true;  			td.CallbackTimer = true;  			td.Callback = (taskDialog' args' userData) =>  {  				if (args.Notification == TaskDialogNotification.Created) {  					taskDialog.SetMarqueeProgressBar (true);  					taskDialog.SetProgressBarState (ProgressBarState.Normal);  					taskDialog.SetProgressBarMarquee (true' 100);  					taskDialog.EnableButton ((int)DialogResult.OK' false);  				}  				else if (args.Notification == TaskDialogNotification.Timer) {  					if (!t.IsAlive) {  						taskDialog.EnableButton ((int)DialogResult.OK' true);  						taskDialog.SetProgressBarMarquee (false' 0);  						taskDialog.SetMarqueeProgressBar (false);  						if (exception == null) {  							taskDialog.SetMainInstruction ("The dump file has been created.");  							taskDialog.SetContent ("The dump file has been saved at: <a href=\"file\">" + sfd.FileName + "</a>.");  						}  						else {  							taskDialog.UpdateMainIcon (TaskDialogIcon.Warning);  							taskDialog.SetMainInstruction ("Unable to create the dump file.");  							taskDialog.SetContent ("The dump file could not be created: " + exception.Message);  						}  					}  				}  				else if (args.Notification == TaskDialogNotification.HyperlinkClicked) {  					if (args.Hyperlink == "file")  						Utils.ShowFileInExplorer (sfd.FileName);  					return true;  				}  				return false;  			};  			t.Start ();  			td.Show (this);  		}  		else {  			// No task dialogs' do the thing on the GUI thread.  			dumpProcess ();  			if (exception != null)  				PhUtils.ShowException ("Unable to create the dump file"' exception);  		}  	}  	catch (Exception ex) {  		PhUtils.ShowException ("Unable to create the dump file"' ex);  	}  	finally {  		this.Cursor = Cursors.Default;  	}  }  
Magic Number,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,createDumpFileProcessMenuItem_Click,The following statement contains a magic number: try {  	Exception exception = null;  	ThreadStart dumpProcess = () =>  {  		try {  			using (var phandle = new ProcessHandle (processSelectedPid' ProcessAccess.DupHandle | ProcessAccess.QueryInformation | ProcessAccess.SuspendResume | ProcessAccess.VmRead))  				phandle.WriteDump (sfd.FileName);  		}  		catch (Exception ex2) {  			exception = ex2;  		}  	};  	if (OSVersion.HasTaskDialogs) {  		// Use a task dialog to display a fancy progress bar.  		TaskDialog td = new TaskDialog ();  		Thread t = new Thread (dumpProcess' Utils.SixteenthStackSize);  		td.AllowDialogCancellation = false;  		td.Buttons = new TaskDialogButton[] {  			new TaskDialogButton ((int)DialogResult.OK' "Close")  		};  		td.WindowTitle = "Process Hacker";  		td.MainInstruction = "Creating the dump file...";  		td.ShowMarqueeProgressBar = true;  		td.EnableHyperlinks = true;  		td.CallbackTimer = true;  		td.Callback = (taskDialog' args' userData) =>  {  			if (args.Notification == TaskDialogNotification.Created) {  				taskDialog.SetMarqueeProgressBar (true);  				taskDialog.SetProgressBarState (ProgressBarState.Normal);  				taskDialog.SetProgressBarMarquee (true' 100);  				taskDialog.EnableButton ((int)DialogResult.OK' false);  			}  			else if (args.Notification == TaskDialogNotification.Timer) {  				if (!t.IsAlive) {  					taskDialog.EnableButton ((int)DialogResult.OK' true);  					taskDialog.SetProgressBarMarquee (false' 0);  					taskDialog.SetMarqueeProgressBar (false);  					if (exception == null) {  						taskDialog.SetMainInstruction ("The dump file has been created.");  						taskDialog.SetContent ("The dump file has been saved at: <a href=\"file\">" + sfd.FileName + "</a>.");  					}  					else {  						taskDialog.UpdateMainIcon (TaskDialogIcon.Warning);  						taskDialog.SetMainInstruction ("Unable to create the dump file.");  						taskDialog.SetContent ("The dump file could not be created: " + exception.Message);  					}  				}  			}  			else if (args.Notification == TaskDialogNotification.HyperlinkClicked) {  				if (args.Hyperlink == "file")  					Utils.ShowFileInExplorer (sfd.FileName);  				return true;  			}  			return false;  		};  		t.Start ();  		td.Show (this);  	}  	else {  		// No task dialogs' do the thing on the GUI thread.  		dumpProcess ();  		if (exception != null)  			PhUtils.ShowException ("Unable to create the dump file"' exception);  	}  }  catch (Exception ex) {  	PhUtils.ShowException ("Unable to create the dump file"' ex);  }  finally {  	this.Cursor = Cursors.Default;  }  
Magic Number,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,createDumpFileProcessMenuItem_Click,The following statement contains a magic number: if (OSVersion.HasTaskDialogs) {  	// Use a task dialog to display a fancy progress bar.  	TaskDialog td = new TaskDialog ();  	Thread t = new Thread (dumpProcess' Utils.SixteenthStackSize);  	td.AllowDialogCancellation = false;  	td.Buttons = new TaskDialogButton[] {  		new TaskDialogButton ((int)DialogResult.OK' "Close")  	};  	td.WindowTitle = "Process Hacker";  	td.MainInstruction = "Creating the dump file...";  	td.ShowMarqueeProgressBar = true;  	td.EnableHyperlinks = true;  	td.CallbackTimer = true;  	td.Callback = (taskDialog' args' userData) =>  {  		if (args.Notification == TaskDialogNotification.Created) {  			taskDialog.SetMarqueeProgressBar (true);  			taskDialog.SetProgressBarState (ProgressBarState.Normal);  			taskDialog.SetProgressBarMarquee (true' 100);  			taskDialog.EnableButton ((int)DialogResult.OK' false);  		}  		else if (args.Notification == TaskDialogNotification.Timer) {  			if (!t.IsAlive) {  				taskDialog.EnableButton ((int)DialogResult.OK' true);  				taskDialog.SetProgressBarMarquee (false' 0);  				taskDialog.SetMarqueeProgressBar (false);  				if (exception == null) {  					taskDialog.SetMainInstruction ("The dump file has been created.");  					taskDialog.SetContent ("The dump file has been saved at: <a href=\"file\">" + sfd.FileName + "</a>.");  				}  				else {  					taskDialog.UpdateMainIcon (TaskDialogIcon.Warning);  					taskDialog.SetMainInstruction ("Unable to create the dump file.");  					taskDialog.SetContent ("The dump file could not be created: " + exception.Message);  				}  			}  		}  		else if (args.Notification == TaskDialogNotification.HyperlinkClicked) {  			if (args.Hyperlink == "file")  				Utils.ShowFileInExplorer (sfd.FileName);  			return true;  		}  		return false;  	};  	t.Start ();  	td.Show (this);  }  else {  	// No task dialogs' do the thing on the GUI thread.  	dumpProcess ();  	if (exception != null)  		PhUtils.ShowException ("Unable to create the dump file"' exception);  }  
Magic Number,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,createDumpFileProcessMenuItem_Click,The following statement contains a magic number: td.Callback = (taskDialog' args' userData) =>  {  	if (args.Notification == TaskDialogNotification.Created) {  		taskDialog.SetMarqueeProgressBar (true);  		taskDialog.SetProgressBarState (ProgressBarState.Normal);  		taskDialog.SetProgressBarMarquee (true' 100);  		taskDialog.EnableButton ((int)DialogResult.OK' false);  	}  	else if (args.Notification == TaskDialogNotification.Timer) {  		if (!t.IsAlive) {  			taskDialog.EnableButton ((int)DialogResult.OK' true);  			taskDialog.SetProgressBarMarquee (false' 0);  			taskDialog.SetMarqueeProgressBar (false);  			if (exception == null) {  				taskDialog.SetMainInstruction ("The dump file has been created.");  				taskDialog.SetContent ("The dump file has been saved at: <a href=\"file\">" + sfd.FileName + "</a>.");  			}  			else {  				taskDialog.UpdateMainIcon (TaskDialogIcon.Warning);  				taskDialog.SetMainInstruction ("Unable to create the dump file.");  				taskDialog.SetContent ("The dump file could not be created: " + exception.Message);  			}  		}  	}  	else if (args.Notification == TaskDialogNotification.HyperlinkClicked) {  		if (args.Hyperlink == "file")  			Utils.ShowFileInExplorer (sfd.FileName);  		return true;  	}  	return false;  };  
Magic Number,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,createDumpFileProcessMenuItem_Click,The following statement contains a magic number: if (args.Notification == TaskDialogNotification.Created) {  	taskDialog.SetMarqueeProgressBar (true);  	taskDialog.SetProgressBarState (ProgressBarState.Normal);  	taskDialog.SetProgressBarMarquee (true' 100);  	taskDialog.EnableButton ((int)DialogResult.OK' false);  }  else if (args.Notification == TaskDialogNotification.Timer) {  	if (!t.IsAlive) {  		taskDialog.EnableButton ((int)DialogResult.OK' true);  		taskDialog.SetProgressBarMarquee (false' 0);  		taskDialog.SetMarqueeProgressBar (false);  		if (exception == null) {  			taskDialog.SetMainInstruction ("The dump file has been created.");  			taskDialog.SetContent ("The dump file has been saved at: <a href=\"file\">" + sfd.FileName + "</a>.");  		}  		else {  			taskDialog.UpdateMainIcon (TaskDialogIcon.Warning);  			taskDialog.SetMainInstruction ("Unable to create the dump file.");  			taskDialog.SetContent ("The dump file could not be created: " + exception.Message);  		}  	}  }  else if (args.Notification == TaskDialogNotification.HyperlinkClicked) {  	if (args.Hyperlink == "file")  		Utils.ShowFileInExplorer (sfd.FileName);  	return true;  }  
Magic Number,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,createDumpFileProcessMenuItem_Click,The following statement contains a magic number: taskDialog.SetProgressBarMarquee (true' 100);  
Magic Number,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,injectDllProcessMenuItem_Click,The following statement contains a magic number: if (ofd.ShowDialog () == DialogResult.OK) {  	try {  		using (var phandle = new ProcessHandle (processSelectedPid' ProcessAccess.CreateThread | ProcessAccess.VmOperation | ProcessAccess.VmWrite)) {  			phandle.InjectDll (ofd.FileName' 5000);  		}  	}  	catch (Exception ex) {  		PhUtils.ShowException ("Unable to inject the DLL"' ex);  	}  }  
Magic Number,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,injectDllProcessMenuItem_Click,The following statement contains a magic number: try {  	using (var phandle = new ProcessHandle (processSelectedPid' ProcessAccess.CreateThread | ProcessAccess.VmOperation | ProcessAccess.VmWrite)) {  		phandle.InjectDll (ofd.FileName' 5000);  	}  }  catch (Exception ex) {  	PhUtils.ShowException ("Unable to inject the DLL"' ex);  }  
Magic Number,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,injectDllProcessMenuItem_Click,The following statement contains a magic number: using (var phandle = new ProcessHandle (processSelectedPid' ProcessAccess.CreateThread | ProcessAccess.VmOperation | ProcessAccess.VmWrite)) {  	phandle.InjectDll (ofd.FileName' 5000);  }  
Magic Number,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,injectDllProcessMenuItem_Click,The following statement contains a magic number: phandle.InjectDll (ofd.FileName' 5000);  
Magic Number,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,ioPriority2ThreadMenuItem_Click,The following statement contains a magic number: SetProcessIoPriority (2);  
Magic Number,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,ioPriority3ThreadMenuItem_Click,The following statement contains a magic number: SetProcessIoPriority (3);  
Magic Number,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,virusTotalMenuItem_Click,The following statement contains a magic number: if (PhUtils.IsInternetConnected ()) {  	if (string.IsNullOrEmpty (treeProcesses.SelectedNodes [0].FileName)) {  		PhUtils.ShowWarning ("Unable to upload because the process' file location could not be determined.");  		return;  	}  	VirusTotalUploaderWindow vt = new VirusTotalUploaderWindow (treeProcesses.SelectedNodes [0].Name' treeProcesses.SelectedNodes [0].FileName);  	int Y = this.Top + (this.Height - vt.Height) / 2;  	int X = this.Left + (this.Width - vt.Width) / 2;  	vt.Location = new Point (X' Y);  	vt.Show ();  }  else  	PhUtils.ShowError ("An Internet session could not be established. Please verify connectivity.");  
Magic Number,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,virusTotalMenuItem_Click,The following statement contains a magic number: if (PhUtils.IsInternetConnected ()) {  	if (string.IsNullOrEmpty (treeProcesses.SelectedNodes [0].FileName)) {  		PhUtils.ShowWarning ("Unable to upload because the process' file location could not be determined.");  		return;  	}  	VirusTotalUploaderWindow vt = new VirusTotalUploaderWindow (treeProcesses.SelectedNodes [0].Name' treeProcesses.SelectedNodes [0].FileName);  	int Y = this.Top + (this.Height - vt.Height) / 2;  	int X = this.Left + (this.Width - vt.Width) / 2;  	vt.Location = new Point (X' Y);  	vt.Show ();  }  else  	PhUtils.ShowError ("An Internet session could not be established. Please verify connectivity.");  
Magic Number,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,processP_DictionaryAdded,The following statement contains a magic number: if (NPMenuItem.Checked)  	this.GetFirstIcon ().ShowBalloonTip (2000' "New Process"' "The process " + item.Name + " (" + item.Pid.ToString () + ") was started" + ((parentText != "") ? " by " + parent.Name + " (" + parent.Pid.ToString () + ")" : "") + "."' ToolTipIcon.Info);  
Magic Number,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,processP_DictionaryAdded,The following statement contains a magic number: this.GetFirstIcon ().ShowBalloonTip (2000' "New Process"' "The process " + item.Name + " (" + item.Pid.ToString () + ") was started" + ((parentText != "") ? " by " + parent.Name + " (" + parent.Pid.ToString () + ")" : "") + "."' ToolTipIcon.Info);  
Magic Number,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,processP_DictionaryRemoved,The following statement contains a magic number: if (TPMenuItem.Checked)  	this.GetFirstIcon ().ShowBalloonTip (2000' "Terminated Process"' "The process " + item.Name + " (" + item.Pid.ToString () + ") was terminated."' ToolTipIcon.Info);  
Magic Number,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,processP_DictionaryRemoved,The following statement contains a magic number: this.GetFirstIcon ().ShowBalloonTip (2000' "Terminated Process"' "The process " + item.Name + " (" + item.Pid.ToString () + ") was terminated."' ToolTipIcon.Info);  
Magic Number,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,serviceP_DictionaryAdded,The following statement contains a magic number: if (NSMenuItem.Checked)  	this.GetFirstIcon ().ShowBalloonTip (2000' "New Service"' "The service " + item.Status.ServiceName + " (" + item.Status.DisplayName + ") has been created."' ToolTipIcon.Info);  
Magic Number,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,serviceP_DictionaryAdded,The following statement contains a magic number: this.GetFirstIcon ().ShowBalloonTip (2000' "New Service"' "The service " + item.Status.ServiceName + " (" + item.Status.DisplayName + ") has been created."' ToolTipIcon.Info);  
Magic Number,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,serviceP_DictionaryModified,The following statement contains a magic number: if ((oldState == ServiceState.Paused || oldState == ServiceState.Stopped || oldState == ServiceState.StartPending) && newState == ServiceState.Running) {  	this.QueueMessage ("Service Started: " + newItem.Status.ServiceName + " (" + newItem.Status.ServiceStatusProcess.ServiceType.ToString () + ")" + ((newItem.Status.DisplayName != "") ? " (" + newItem.Status.DisplayName + ")" : ""));  	if (startedSMenuItem.Checked)  		this.GetFirstIcon ().ShowBalloonTip (2000' "Service Started"' "The service " + newItem.Status.ServiceName + " (" + newItem.Status.DisplayName + ") has been started."' ToolTipIcon.Info);  }  
Magic Number,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,serviceP_DictionaryModified,The following statement contains a magic number: if (startedSMenuItem.Checked)  	this.GetFirstIcon ().ShowBalloonTip (2000' "Service Started"' "The service " + newItem.Status.ServiceName + " (" + newItem.Status.DisplayName + ") has been started."' ToolTipIcon.Info);  
Magic Number,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,serviceP_DictionaryModified,The following statement contains a magic number: this.GetFirstIcon ().ShowBalloonTip (2000' "Service Started"' "The service " + newItem.Status.ServiceName + " (" + newItem.Status.DisplayName + ") has been started."' ToolTipIcon.Info);  
Magic Number,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,serviceP_DictionaryModified,The following statement contains a magic number: if (oldState == ServiceState.Running && newState == ServiceState.Stopped) {  	this.QueueMessage ("Service Stopped: " + newItem.Status.ServiceName + " (" + newItem.Status.ServiceStatusProcess.ServiceType.ToString () + ")" + ((newItem.Status.DisplayName != "") ? " (" + newItem.Status.DisplayName + ")" : ""));  	if (stoppedSMenuItem.Checked)  		this.GetFirstIcon ().ShowBalloonTip (2000' "Service Stopped"' "The service " + newItem.Status.ServiceName + " (" + newItem.Status.DisplayName + ") has been stopped."' ToolTipIcon.Info);  }  
Magic Number,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,serviceP_DictionaryModified,The following statement contains a magic number: if (stoppedSMenuItem.Checked)  	this.GetFirstIcon ().ShowBalloonTip (2000' "Service Stopped"' "The service " + newItem.Status.ServiceName + " (" + newItem.Status.DisplayName + ") has been stopped."' ToolTipIcon.Info);  
Magic Number,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,serviceP_DictionaryModified,The following statement contains a magic number: this.GetFirstIcon ().ShowBalloonTip (2000' "Service Stopped"' "The service " + newItem.Status.ServiceName + " (" + newItem.Status.DisplayName + ") has been stopped."' ToolTipIcon.Info);  
Magic Number,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,serviceP_DictionaryRemoved,The following statement contains a magic number: if (DSMenuItem.Checked)  	this.GetFirstIcon ().ShowBalloonTip (2000' "Service Deleted"' "The service " + item.Status.ServiceName + " (" + item.Status.DisplayName + ") has been deleted."' ToolTipIcon.Info);  
Magic Number,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,serviceP_DictionaryRemoved,The following statement contains a magic number: this.GetFirstIcon ().ShowBalloonTip (2000' "Service Deleted"' "The service " + item.Status.ServiceName + " (" + item.Status.DisplayName + ") has been deleted."' ToolTipIcon.Info);  
Magic Number,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,ApplyFont,The following statement contains a magic number: if (f.Height > 16)  	treeProcesses.Tree.RowHeight = f.Height;  else  	treeProcesses.Tree.RowHeight = 16;  
Magic Number,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,ApplyFont,The following statement contains a magic number: if (f.Height > 16)  	treeProcesses.Tree.RowHeight = f.Height;  else  	treeProcesses.Tree.RowHeight = 16;  
Magic Number,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,ApplyFont,The following statement contains a magic number: treeProcesses.Tree.RowHeight = 16;  
Magic Number,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,LoadOtherSettings,The following statement contains a magic number: if (Settings.Instance.ToolStripDisplayStyle == 1) {  	findHandlesToolStripButton.DisplayStyle = ToolStripItemDisplayStyle.ImageAndText;  	sysInfoToolStripButton.DisplayStyle = ToolStripItemDisplayStyle.ImageAndText;  	refreshToolStripButton.DisplayStyle = ToolStripItemDisplayStyle.ImageAndText;  	optionsToolStripButton.DisplayStyle = ToolStripItemDisplayStyle.ImageAndText;  	shutDownToolStripMenuItem.DisplayStyle = ToolStripItemDisplayStyle.Image;  }  else if (Settings.Instance.ToolStripDisplayStyle == 2) {  	refreshToolStripButton.DisplayStyle = ToolStripItemDisplayStyle.ImageAndText;  	optionsToolStripButton.DisplayStyle = ToolStripItemDisplayStyle.ImageAndText;  	shutDownToolStripMenuItem.DisplayStyle = ToolStripItemDisplayStyle.ImageAndText;  	findHandlesToolStripButton.DisplayStyle = ToolStripItemDisplayStyle.ImageAndText;  	sysInfoToolStripButton.DisplayStyle = ToolStripItemDisplayStyle.ImageAndText;  }  else {  	refreshToolStripButton.DisplayStyle = ToolStripItemDisplayStyle.Image;  	optionsToolStripButton.DisplayStyle = ToolStripItemDisplayStyle.Image;  	shutDownToolStripMenuItem.DisplayStyle = ToolStripItemDisplayStyle.Image;  	findHandlesToolStripButton.DisplayStyle = ToolStripItemDisplayStyle.Image;  	sysInfoToolStripButton.DisplayStyle = ToolStripItemDisplayStyle.Image;  }  
Magic Number,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,LoadOtherSettings,The following statement contains a magic number: if (Settings.Instance.ToolStripDisplayStyle == 2) {  	refreshToolStripButton.DisplayStyle = ToolStripItemDisplayStyle.ImageAndText;  	optionsToolStripButton.DisplayStyle = ToolStripItemDisplayStyle.ImageAndText;  	shutDownToolStripMenuItem.DisplayStyle = ToolStripItemDisplayStyle.ImageAndText;  	findHandlesToolStripButton.DisplayStyle = ToolStripItemDisplayStyle.ImageAndText;  	sysInfoToolStripButton.DisplayStyle = ToolStripItemDisplayStyle.ImageAndText;  }  else {  	refreshToolStripButton.DisplayStyle = ToolStripItemDisplayStyle.Image;  	optionsToolStripButton.DisplayStyle = ToolStripItemDisplayStyle.Image;  	shutDownToolStripMenuItem.DisplayStyle = ToolStripItemDisplayStyle.Image;  	findHandlesToolStripButton.DisplayStyle = ToolStripItemDisplayStyle.Image;  	sysInfoToolStripButton.DisplayStyle = ToolStripItemDisplayStyle.Image;  }  
Magic Number,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,UpdateStatusInfo,The following statement contains a magic number: if (Program.ProcessProvider.RunCount >= 1)  	statusGeneral.Text = string.Format ("{0} processes"' Program.ProcessProvider.Dictionary.Count - 2);  else  	statusGeneral.Text = "Loading...";  
Magic Number,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,UpdateStatusInfo,The following statement contains a magic number: statusGeneral.Text = string.Format ("{0} processes"' Program.ProcessProvider.Dictionary.Count - 2);  
Magic Number,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,UpdateStatusInfo,The following statement contains a magic number: statusCPU.Text = "CPU: " + (Program.ProcessProvider.CurrentCpuUsage * 100).ToString ("N2") + "%";  
Magic Number,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,UpdateStatusInfo,The following statement contains a magic number: statusMemory.Text = "Phys. Memory: " + ((float)(Program.ProcessProvider.System.NumberOfPhysicalPages - Program.ProcessProvider.Performance.AvailablePages) * 100 / Program.ProcessProvider.System.NumberOfPhysicalPages).ToString ("N2") + "%";  
Magic Number,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,LoadNotificationIcons,The following statement contains a magic number: using (Bitmap b = new Bitmap (16' 16)) {  	using (Graphics g = Graphics.FromImage (b)) {  		g.FillRectangle (new SolidBrush (Color.Black)' 0' 0' b.Width' b.Height);  		blackIcon = Icon.FromHandle (b.GetHicon ());  	}  }  
Magic Number,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,LoadNotificationIcons,The following statement contains a magic number: using (Bitmap b = new Bitmap (16' 16)) {  	using (Graphics g = Graphics.FromImage (b)) {  		g.FillRectangle (new SolidBrush (Color.Black)' 0' 0' b.Width' b.Height);  		blackIcon = Icon.FromHandle (b.GetHicon ());  	}  }  
Magic Number,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,HackerWindow,The following statement contains a magic number: _enableNetworkProviderSync = new ActionSync (() =>  {  	Program.NetworkProvider.Enabled = true;  	Program.NetworkProvider.Boost ();  }' 2);  
Magic Number,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,HackerWindow,The following statement contains a magic number: _refreshHighlightingSync = new ActionSync (() =>  {  	this.BeginInvoke (new Action (treeProcesses.RefreshItems)' null);  }' 2);  
Magic Number,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,OnLayout,The following statement contains a magic number: if (_layoutCount < 3)  	return;  
Magic Number,ProcessHacker,Program,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\Program.cs,Main,The following statement contains a magic number: if (Environment.Version.Major < 2) {  	PhUtils.ShowError ("You must have .NET Framework 2.0 or higher to use Process Hacker.");  	Environment.Exit (1);  }  
Magic Number,ProcessHacker,Program,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\Program.cs,Main,The following statement contains a magic number: ThreadPool.SetMaxThreads (2' 2);  
Magic Number,ProcessHacker,Program,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\Program.cs,Main,The following statement contains a magic number: ThreadPool.SetMaxThreads (2' 2);  
Magic Number,ProcessHacker,Program,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\Program.cs,Main,The following statement contains a magic number: WorkQueue.GlobalWorkQueue.MaxWorkerThreads = 2;  
Magic Number,ProcessHacker,Program,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\Program.cs,ProcessCommandLine,The following statement contains a magic number: if (pArgs.ContainsKey ("-o")) {  	OptionsWindow options = new OptionsWindow (true) {  		StartPosition = FormStartPosition.CenterScreen  	};  	IWin32Window window;  	if (pArgs.ContainsKey ("-hwnd"))  		window = new WindowFromHandle (new IntPtr (int.Parse (pArgs ["-hwnd"])));  	else  		window = new WindowFromHandle (IntPtr.Zero);  	if (pArgs.ContainsKey ("-rect")) {  		Rectangle rect = Utils.GetRectangle (pArgs ["-rect"]);  		options.Location = new Point (rect.X + 20' rect.Y + 20);  		options.StartPosition = FormStartPosition.Manual;  	}  	options.SelectedTab = options.TabPages ["tabAdvanced"];  	options.ShowDialog (window);  	return true;  }  
Magic Number,ProcessHacker,Program,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\Program.cs,ProcessCommandLine,The following statement contains a magic number: if (pArgs.ContainsKey ("-o")) {  	OptionsWindow options = new OptionsWindow (true) {  		StartPosition = FormStartPosition.CenterScreen  	};  	IWin32Window window;  	if (pArgs.ContainsKey ("-hwnd"))  		window = new WindowFromHandle (new IntPtr (int.Parse (pArgs ["-hwnd"])));  	else  		window = new WindowFromHandle (IntPtr.Zero);  	if (pArgs.ContainsKey ("-rect")) {  		Rectangle rect = Utils.GetRectangle (pArgs ["-rect"]);  		options.Location = new Point (rect.X + 20' rect.Y + 20);  		options.StartPosition = FormStartPosition.Manual;  	}  	options.SelectedTab = options.TabPages ["tabAdvanced"];  	options.ShowDialog (window);  	return true;  }  
Magic Number,ProcessHacker,Program,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\Program.cs,ProcessCommandLine,The following statement contains a magic number: if (pArgs.ContainsKey ("-rect")) {  	Rectangle rect = Utils.GetRectangle (pArgs ["-rect"]);  	options.Location = new Point (rect.X + 20' rect.Y + 20);  	options.StartPosition = FormStartPosition.Manual;  }  
Magic Number,ProcessHacker,Program,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\Program.cs,ProcessCommandLine,The following statement contains a magic number: if (pArgs.ContainsKey ("-rect")) {  	Rectangle rect = Utils.GetRectangle (pArgs ["-rect"]);  	options.Location = new Point (rect.X + 20' rect.Y + 20);  	options.StartPosition = FormStartPosition.Manual;  }  
Magic Number,ProcessHacker,Program,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\Program.cs,ProcessCommandLine,The following statement contains a magic number: options.Location = new Point (rect.X + 20' rect.Y + 20);  
Magic Number,ProcessHacker,Program,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\Program.cs,ProcessCommandLine,The following statement contains a magic number: options.Location = new Point (rect.X + 20' rect.Y + 20);  
Magic Number,ProcessHacker,Program,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\Program.cs,Unhook,The following statement contains a magic number: for (int i = 0; i < file.Exports.Count; i++) {  	var entry = file.Exports.GetEntry (i);  	if (!entry.Name.StartsWith ("Nt") || entry.Name.StartsWith ("Ntdll"))  		continue;  	byte[] fileData = new byte[5];  	unsafe {  		IntPtr function = file.Exports.GetFunction (entry.Ordinal).Function;  		Win32.RtlMoveMemory (function.Decrement (new IntPtr (file.Memory)).Increment (ntdll)' function' (5).ToIntPtr ());  	}  }  
Magic Number,ProcessHacker,Program,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\Program.cs,Unhook,The following statement contains a magic number: for (int i = 0; i < file.Exports.Count; i++) {  	var entry = file.Exports.GetEntry (i);  	if (!entry.Name.StartsWith ("Nt") || entry.Name.StartsWith ("Ntdll"))  		continue;  	byte[] fileData = new byte[5];  	unsafe {  		IntPtr function = file.Exports.GetFunction (entry.Ordinal).Function;  		Win32.RtlMoveMemory (function.Decrement (new IntPtr (file.Memory)).Increment (ntdll)' function' (5).ToIntPtr ());  	}  }  
Magic Number,ProcessHacker,Program,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\Program.cs,Unhook,The following statement contains a magic number: unsafe {  	IntPtr function = file.Exports.GetFunction (entry.Ordinal).Function;  	Win32.RtlMoveMemory (function.Decrement (new IntPtr (file.Memory)).Increment (ntdll)' function' (5).ToIntPtr ());  }  
Magic Number,ProcessHacker,Program,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\Program.cs,Unhook,The following statement contains a magic number: Win32.RtlMoveMemory (function.Decrement (new IntPtr (file.Memory)).Increment (ntdll)' function' (5).ToIntPtr ());  
Magic Number,ProcessHacker,Program,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\Program.cs,NopNtYieldExecution,The following statement contains a magic number: if (ntYieldExecution != IntPtr.Zero) {  	ProcessHandle.Current.ProtectMemory (ntYieldExecution' 12' MemoryProtection.ExecuteReadWrite);  	Win32.RtlFillMemory (ntYieldExecution' (12).ToIntPtr ()' 0x90);  	ProcessHandle.Current.ProtectMemory (ntYieldExecution' 12' MemoryProtection.ExecuteRead);  }  
Magic Number,ProcessHacker,Program,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\Program.cs,NopNtYieldExecution,The following statement contains a magic number: if (ntYieldExecution != IntPtr.Zero) {  	ProcessHandle.Current.ProtectMemory (ntYieldExecution' 12' MemoryProtection.ExecuteReadWrite);  	Win32.RtlFillMemory (ntYieldExecution' (12).ToIntPtr ()' 0x90);  	ProcessHandle.Current.ProtectMemory (ntYieldExecution' 12' MemoryProtection.ExecuteRead);  }  
Magic Number,ProcessHacker,Program,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\Program.cs,NopNtYieldExecution,The following statement contains a magic number: if (ntYieldExecution != IntPtr.Zero) {  	ProcessHandle.Current.ProtectMemory (ntYieldExecution' 12' MemoryProtection.ExecuteReadWrite);  	Win32.RtlFillMemory (ntYieldExecution' (12).ToIntPtr ()' 0x90);  	ProcessHandle.Current.ProtectMemory (ntYieldExecution' 12' MemoryProtection.ExecuteRead);  }  
Magic Number,ProcessHacker,Program,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\Program.cs,NopNtYieldExecution,The following statement contains a magic number: ProcessHandle.Current.ProtectMemory (ntYieldExecution' 12' MemoryProtection.ExecuteReadWrite);  
Magic Number,ProcessHacker,Program,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\Program.cs,NopNtYieldExecution,The following statement contains a magic number: Win32.RtlFillMemory (ntYieldExecution' (12).ToIntPtr ()' 0x90);  
Magic Number,ProcessHacker,Program,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\Program.cs,NopNtYieldExecution,The following statement contains a magic number: ProcessHandle.Current.ProtectMemory (ntYieldExecution' 12' MemoryProtection.ExecuteRead);  
Magic Number,ProcessHacker,Program,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\Program.cs,ActivatePreviousInstance,The following statement contains a magic number: WindowHandle.Enumerate (window =>  {  	if (window.GetText ().Contains ("Process Hacker [")) {  		int result;  		window.SendMessageTimeout ((WindowMessage)0x9991' 0' 0' SmtoFlags.Block' 5000' out result);  		if (result == 0x1119) {  			window.SetForeground ();  			found = true;  			return false;  		}  	}  	return true;  });  
Magic Number,ProcessHacker,Program,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\Program.cs,ActivatePreviousInstance,The following statement contains a magic number: if (window.GetText ().Contains ("Process Hacker [")) {  	int result;  	window.SendMessageTimeout ((WindowMessage)0x9991' 0' 0' SmtoFlags.Block' 5000' out result);  	if (result == 0x1119) {  		window.SetForeground ();  		found = true;  		return false;  	}  }  
Magic Number,ProcessHacker,Program,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\Program.cs,ActivatePreviousInstance,The following statement contains a magic number: window.SendMessageTimeout ((WindowMessage)0x9991' 0' 0' SmtoFlags.Block' 5000' out result);  
Magic Number,ProcessHacker,Program,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\Program.cs,TryStart,The following statement contains a magic number: try {  	System.Diagnostics.Process.Start (command);  }  catch (Exception ex) {  	if (command.StartsWith ("http://")) {  		if (ex is System.ComponentModel.Win32Exception) {  			// Ignore file not found errors when opening web pages.  			if ((ex as System.ComponentModel.Win32Exception).NativeErrorCode == 2)  				return;  		}  	}  	PhUtils.ShowException ("Unable to start the process"' ex);  }  
Magic Number,ProcessHacker,Program,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\Program.cs,TryStart,The following statement contains a magic number: if (command.StartsWith ("http://")) {  	if (ex is System.ComponentModel.Win32Exception) {  		// Ignore file not found errors when opening web pages.  		if ((ex as System.ComponentModel.Win32Exception).NativeErrorCode == 2)  			return;  	}  }  
Magic Number,ProcessHacker,Program,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\Program.cs,TryStart,The following statement contains a magic number: if (ex is System.ComponentModel.Win32Exception) {  	// Ignore file not found errors when opening web pages.  	if ((ex as System.ComponentModel.Win32Exception).NativeErrorCode == 2)  		return;  }  
Magic Number,ProcessHacker,Program,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\Program.cs,TryStart,The following statement contains a magic number: if ((ex as System.ComponentModel.Win32Exception).NativeErrorCode == 2)  	return;  
Magic Number,ProcessHacker,PromptBox,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\PromptBox.cs,PromptBox,The following statement contains a magic number: if (multiline) {  	textValue.Multiline = true;  	textValue.ScrollBars = ScrollBars.Vertical;  	this.Size = new Size (this.Size.Width' this.Size.Height + 100);  	this.AcceptButton = null;  }  else {  	this.AcceptButton = buttonOK;  }  
Magic Number,ProcessHacker,PromptBox,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\PromptBox.cs,PromptBox,The following statement contains a magic number: this.Size = new Size (this.Size.Width' this.Size.Height + 100);  
Magic Number,ProcessHacker,DumpProcessWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\DumpProcessWindow.cs,LoadToken,The following statement contains a magic number: using (var privileges = token.GetChild ("Privileges")) {  	var privilegesList = Dump.GetList (privileges);  	foreach (var privilege in privilegesList) {  		var split = privilege.Split (';');  		_tokenProps.DumpAddPrivilege (split [0]' split [1]' (SePrivilegeAttributes)Dump.ParseInt32 (split [2]));  	}  }  
Magic Number,ProcessHacker,DumpProcessWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\DumpProcessWindow.cs,LoadToken,The following statement contains a magic number: foreach (var privilege in privilegesList) {  	var split = privilege.Split (';');  	_tokenProps.DumpAddPrivilege (split [0]' split [1]' (SePrivilegeAttributes)Dump.ParseInt32 (split [2]));  }  
Magic Number,ProcessHacker,DumpProcessWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\DumpProcessWindow.cs,LoadToken,The following statement contains a magic number: _tokenProps.DumpAddPrivilege (split [0]' split [1]' (SePrivilegeAttributes)Dump.ParseInt32 (split [2]));  
Magic Number,ProcessHacker,HeapsWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HeapsWindow.cs,HeapsWindow,The following statement contains a magic number: comparer.CustomSorters.Add (2' (l1' l2) =>  {  	HeapInformation heap1 = l1.Tag as HeapInformation;  	HeapInformation heap2 = l2.Tag as HeapInformation;  	return heap1.BytesCommitted.CompareTo (heap2.BytesCommitted);  });  
Magic Number,ProcessHacker,HeapsWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HeapsWindow.cs,checkSizesInBytes_CheckedChanged,The following statement contains a magic number: foreach (ListViewItem item in listHeaps.Items) {  	HeapInformation heap = item.Tag as HeapInformation;  	if (checkSizesInBytes.Checked) {  		item.SubItems [1].Text = heap.BytesAllocated.ToString ("N0") + " B";  		item.SubItems [2].Text = heap.BytesCommitted.ToString ("N0") + " B";  	}  	else {  		item.SubItems [1].Text = Utils.FormatSize (heap.BytesAllocated);  		item.SubItems [2].Text = Utils.FormatSize (heap.BytesCommitted);  	}  }  
Magic Number,ProcessHacker,HeapsWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HeapsWindow.cs,checkSizesInBytes_CheckedChanged,The following statement contains a magic number: foreach (ListViewItem item in listHeaps.Items) {  	HeapInformation heap = item.Tag as HeapInformation;  	if (checkSizesInBytes.Checked) {  		item.SubItems [1].Text = heap.BytesAllocated.ToString ("N0") + " B";  		item.SubItems [2].Text = heap.BytesCommitted.ToString ("N0") + " B";  	}  	else {  		item.SubItems [1].Text = Utils.FormatSize (heap.BytesAllocated);  		item.SubItems [2].Text = Utils.FormatSize (heap.BytesCommitted);  	}  }  
Magic Number,ProcessHacker,HeapsWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HeapsWindow.cs,checkSizesInBytes_CheckedChanged,The following statement contains a magic number: if (checkSizesInBytes.Checked) {  	item.SubItems [1].Text = heap.BytesAllocated.ToString ("N0") + " B";  	item.SubItems [2].Text = heap.BytesCommitted.ToString ("N0") + " B";  }  else {  	item.SubItems [1].Text = Utils.FormatSize (heap.BytesAllocated);  	item.SubItems [2].Text = Utils.FormatSize (heap.BytesCommitted);  }  
Magic Number,ProcessHacker,HeapsWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HeapsWindow.cs,checkSizesInBytes_CheckedChanged,The following statement contains a magic number: if (checkSizesInBytes.Checked) {  	item.SubItems [1].Text = heap.BytesAllocated.ToString ("N0") + " B";  	item.SubItems [2].Text = heap.BytesCommitted.ToString ("N0") + " B";  }  else {  	item.SubItems [1].Text = Utils.FormatSize (heap.BytesAllocated);  	item.SubItems [2].Text = Utils.FormatSize (heap.BytesCommitted);  }  
Magic Number,ProcessHacker,HeapsWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HeapsWindow.cs,checkSizesInBytes_CheckedChanged,The following statement contains a magic number: item.SubItems [2].Text = heap.BytesCommitted.ToString ("N0") + " B";  
Magic Number,ProcessHacker,HeapsWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HeapsWindow.cs,checkSizesInBytes_CheckedChanged,The following statement contains a magic number: item.SubItems [2].Text = Utils.FormatSize (heap.BytesCommitted);  
Magic Number,ProcessHacker,IPInfoWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\IPInfoWindow.cs,Ping,The following statement contains a magic number: using (Ping pingSender = new Ping ()) {  	PingOptions pingOptions = new PingOptions ();  	PingReply pingReply = null;  	IPAddress ipAddress = (IPAddress)ip;  	int numberOfPings = 4;  	int pingTimeout = 1000;  	int byteSize = 32;  	byte[] buffer = new byte[byteSize];  	int sentPings = 0;  	int receivedPings = 0;  	int lostPings = 0;  	long minPingResponse = 0;  	long maxPingResponse = 0;  	//pingOptions.DontFragment = true;  	//pingOptions.Ttl = 128;  	WriteStatus (string.Format ("Pinging {0} with {1} bytes of data:"' ipAddress' byteSize) + Environment.NewLine' true);  	for (int i = 0; i < numberOfPings; i++) {  		sentPings++;  		try {  			pingReply = pingSender.Send (ipAddress' pingTimeout' buffer' pingOptions);  		}  		catch (Exception ex) {  			WriteStatus ("Ping error: " + ex.Message' false);  			break;  		}  		if (pingReply.Status == IPStatus.Success) {  			if (pingReply.Options != null)//IPv6 ping causes pingReply.Options to become null   			 {  				WriteResult (string.Format ("Reply from {0}:  bytes={1}  time={2}ms  TTL={3}"' ipAddress' byteSize' pingReply.RoundtripTime' pingReply.Options.Ttl)' ""' "");  			}  			else {  				WriteResult (string.Format ("Reply from {0}:  bytes={1}  time={2}ms  TTL={3}"' ipAddress' byteSize' pingReply.RoundtripTime' pingOptions.Ttl)' ""' "");  			}  			if (minPingResponse == 0) {  				minPingResponse = pingReply.RoundtripTime;  				maxPingResponse = minPingResponse;  			}  			else if (pingReply.RoundtripTime < minPingResponse) {  				minPingResponse = pingReply.RoundtripTime;  			}  			else if (pingReply.RoundtripTime > maxPingResponse) {  				maxPingResponse = pingReply.RoundtripTime;  			}  			receivedPings++;  		}  		else {  			WriteResult (pingReply.Status.ToString ()' ""' "");  			lostPings++;  		}  	}  	WriteResult (""' ""' "");  	WriteResult (string.Format ("Ping statistics for {0}:"' ipAddress)' ""' "");  	WriteResult (string.Format ("        Packets: Sent = {0}' Received = {1}' Lost = {2}"' sentPings' receivedPings' lostPings)' ""' "");  	WriteResult ("Approximate round trip times in milli-seconds:"' ""' "");  	WriteResult (string.Format ("        Minimum = {0}ms' Maximum = {1}ms"' minPingResponse' maxPingResponse)' ""' "");  }  
Magic Number,ProcessHacker,IPInfoWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\IPInfoWindow.cs,Ping,The following statement contains a magic number: using (Ping pingSender = new Ping ()) {  	PingOptions pingOptions = new PingOptions ();  	PingReply pingReply = null;  	IPAddress ipAddress = (IPAddress)ip;  	int numberOfPings = 4;  	int pingTimeout = 1000;  	int byteSize = 32;  	byte[] buffer = new byte[byteSize];  	int sentPings = 0;  	int receivedPings = 0;  	int lostPings = 0;  	long minPingResponse = 0;  	long maxPingResponse = 0;  	//pingOptions.DontFragment = true;  	//pingOptions.Ttl = 128;  	WriteStatus (string.Format ("Pinging {0} with {1} bytes of data:"' ipAddress' byteSize) + Environment.NewLine' true);  	for (int i = 0; i < numberOfPings; i++) {  		sentPings++;  		try {  			pingReply = pingSender.Send (ipAddress' pingTimeout' buffer' pingOptions);  		}  		catch (Exception ex) {  			WriteStatus ("Ping error: " + ex.Message' false);  			break;  		}  		if (pingReply.Status == IPStatus.Success) {  			if (pingReply.Options != null)//IPv6 ping causes pingReply.Options to become null   			 {  				WriteResult (string.Format ("Reply from {0}:  bytes={1}  time={2}ms  TTL={3}"' ipAddress' byteSize' pingReply.RoundtripTime' pingReply.Options.Ttl)' ""' "");  			}  			else {  				WriteResult (string.Format ("Reply from {0}:  bytes={1}  time={2}ms  TTL={3}"' ipAddress' byteSize' pingReply.RoundtripTime' pingOptions.Ttl)' ""' "");  			}  			if (minPingResponse == 0) {  				minPingResponse = pingReply.RoundtripTime;  				maxPingResponse = minPingResponse;  			}  			else if (pingReply.RoundtripTime < minPingResponse) {  				minPingResponse = pingReply.RoundtripTime;  			}  			else if (pingReply.RoundtripTime > maxPingResponse) {  				maxPingResponse = pingReply.RoundtripTime;  			}  			receivedPings++;  		}  		else {  			WriteResult (pingReply.Status.ToString ()' ""' "");  			lostPings++;  		}  	}  	WriteResult (""' ""' "");  	WriteResult (string.Format ("Ping statistics for {0}:"' ipAddress)' ""' "");  	WriteResult (string.Format ("        Packets: Sent = {0}' Received = {1}' Lost = {2}"' sentPings' receivedPings' lostPings)' ""' "");  	WriteResult ("Approximate round trip times in milli-seconds:"' ""' "");  	WriteResult (string.Format ("        Minimum = {0}ms' Maximum = {1}ms"' minPingResponse' maxPingResponse)' ""' "");  }  
Magic Number,ProcessHacker,IPInfoWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\IPInfoWindow.cs,Ping,The following statement contains a magic number: using (Ping pingSender = new Ping ()) {  	PingOptions pingOptions = new PingOptions ();  	PingReply pingReply = null;  	IPAddress ipAddress = (IPAddress)ip;  	int numberOfPings = 4;  	int pingTimeout = 1000;  	int byteSize = 32;  	byte[] buffer = new byte[byteSize];  	int sentPings = 0;  	int receivedPings = 0;  	int lostPings = 0;  	long minPingResponse = 0;  	long maxPingResponse = 0;  	//pingOptions.DontFragment = true;  	//pingOptions.Ttl = 128;  	WriteStatus (string.Format ("Pinging {0} with {1} bytes of data:"' ipAddress' byteSize) + Environment.NewLine' true);  	for (int i = 0; i < numberOfPings; i++) {  		sentPings++;  		try {  			pingReply = pingSender.Send (ipAddress' pingTimeout' buffer' pingOptions);  		}  		catch (Exception ex) {  			WriteStatus ("Ping error: " + ex.Message' false);  			break;  		}  		if (pingReply.Status == IPStatus.Success) {  			if (pingReply.Options != null)//IPv6 ping causes pingReply.Options to become null   			 {  				WriteResult (string.Format ("Reply from {0}:  bytes={1}  time={2}ms  TTL={3}"' ipAddress' byteSize' pingReply.RoundtripTime' pingReply.Options.Ttl)' ""' "");  			}  			else {  				WriteResult (string.Format ("Reply from {0}:  bytes={1}  time={2}ms  TTL={3}"' ipAddress' byteSize' pingReply.RoundtripTime' pingOptions.Ttl)' ""' "");  			}  			if (minPingResponse == 0) {  				minPingResponse = pingReply.RoundtripTime;  				maxPingResponse = minPingResponse;  			}  			else if (pingReply.RoundtripTime < minPingResponse) {  				minPingResponse = pingReply.RoundtripTime;  			}  			else if (pingReply.RoundtripTime > maxPingResponse) {  				maxPingResponse = pingReply.RoundtripTime;  			}  			receivedPings++;  		}  		else {  			WriteResult (pingReply.Status.ToString ()' ""' "");  			lostPings++;  		}  	}  	WriteResult (""' ""' "");  	WriteResult (string.Format ("Ping statistics for {0}:"' ipAddress)' ""' "");  	WriteResult (string.Format ("        Packets: Sent = {0}' Received = {1}' Lost = {2}"' sentPings' receivedPings' lostPings)' ""' "");  	WriteResult ("Approximate round trip times in milli-seconds:"' ""' "");  	WriteResult (string.Format ("        Minimum = {0}ms' Maximum = {1}ms"' minPingResponse' maxPingResponse)' ""' "");  }  
Magic Number,ProcessHacker,IPInfoWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\IPInfoWindow.cs,Tracert,The following statement contains a magic number: using (Ping pingSender = new Ping ()) {  	PingOptions pingOptions = new PingOptions ();  	Stopwatch stopWatch = new Stopwatch ();  	byte[] bytes = new byte[32];  	pingOptions.DontFragment = true;  	pingOptions.Ttl = 1;  	int maxHops = 30;  	WriteStatus (string.Format ("Tracing route to {0} over a maximum of {1} hops:"' ipAddress' maxHops)' true);  	for (int i = 1; i < maxHops + 1; i++) {  		stopWatch.Reset ();  		stopWatch.Start ();  		PingReply pingReply;  		try {  			pingReply = pingSender.Send (ipAddress' 5000' new byte[32]' pingOptions);  		}  		catch (Exception ex) {  			WriteStatus ("Trace error: " + ex.Message' false);  			break;  		}  		finally {  			stopWatch.Stop ();  		}  		WriteResult (string.Format ("{0}"' i)' string.Format ("{0} ms"' stopWatch.ElapsedMilliseconds)' string.Format ("{0}"' pingReply.Address));  		WorkQueue.GlobalQueueWorkItemTag (new Action<IPAddress' int> ((address' hopNumber) =>  {  			string hostName;  			try {  				hostName = Dns.GetHostEntry (address).HostName;  			}  			catch {  				hostName = "";  			}  			if (this.IsHandleCreated) {  				this.BeginInvoke (new MethodInvoker (() =>  {  					foreach (ListViewItem item in listInfo.Items) {  						if (item.Text == hopNumber.ToString ()) {  							item.SubItems [3].Text = hostName;  							break;  						}  					}  				}));  			}  		})' "ipinfowindow-resolveaddress"' pingReply.Address' i);  		if (pingReply.Status == IPStatus.Success) {  			WriteStatus ("Trace complete."' false);  			break;  		}  		pingOptions.Ttl++;  	}  }  
Magic Number,ProcessHacker,IPInfoWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\IPInfoWindow.cs,Tracert,The following statement contains a magic number: using (Ping pingSender = new Ping ()) {  	PingOptions pingOptions = new PingOptions ();  	Stopwatch stopWatch = new Stopwatch ();  	byte[] bytes = new byte[32];  	pingOptions.DontFragment = true;  	pingOptions.Ttl = 1;  	int maxHops = 30;  	WriteStatus (string.Format ("Tracing route to {0} over a maximum of {1} hops:"' ipAddress' maxHops)' true);  	for (int i = 1; i < maxHops + 1; i++) {  		stopWatch.Reset ();  		stopWatch.Start ();  		PingReply pingReply;  		try {  			pingReply = pingSender.Send (ipAddress' 5000' new byte[32]' pingOptions);  		}  		catch (Exception ex) {  			WriteStatus ("Trace error: " + ex.Message' false);  			break;  		}  		finally {  			stopWatch.Stop ();  		}  		WriteResult (string.Format ("{0}"' i)' string.Format ("{0} ms"' stopWatch.ElapsedMilliseconds)' string.Format ("{0}"' pingReply.Address));  		WorkQueue.GlobalQueueWorkItemTag (new Action<IPAddress' int> ((address' hopNumber) =>  {  			string hostName;  			try {  				hostName = Dns.GetHostEntry (address).HostName;  			}  			catch {  				hostName = "";  			}  			if (this.IsHandleCreated) {  				this.BeginInvoke (new MethodInvoker (() =>  {  					foreach (ListViewItem item in listInfo.Items) {  						if (item.Text == hopNumber.ToString ()) {  							item.SubItems [3].Text = hostName;  							break;  						}  					}  				}));  			}  		})' "ipinfowindow-resolveaddress"' pingReply.Address' i);  		if (pingReply.Status == IPStatus.Success) {  			WriteStatus ("Trace complete."' false);  			break;  		}  		pingOptions.Ttl++;  	}  }  
Magic Number,ProcessHacker,IPInfoWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\IPInfoWindow.cs,Tracert,The following statement contains a magic number: using (Ping pingSender = new Ping ()) {  	PingOptions pingOptions = new PingOptions ();  	Stopwatch stopWatch = new Stopwatch ();  	byte[] bytes = new byte[32];  	pingOptions.DontFragment = true;  	pingOptions.Ttl = 1;  	int maxHops = 30;  	WriteStatus (string.Format ("Tracing route to {0} over a maximum of {1} hops:"' ipAddress' maxHops)' true);  	for (int i = 1; i < maxHops + 1; i++) {  		stopWatch.Reset ();  		stopWatch.Start ();  		PingReply pingReply;  		try {  			pingReply = pingSender.Send (ipAddress' 5000' new byte[32]' pingOptions);  		}  		catch (Exception ex) {  			WriteStatus ("Trace error: " + ex.Message' false);  			break;  		}  		finally {  			stopWatch.Stop ();  		}  		WriteResult (string.Format ("{0}"' i)' string.Format ("{0} ms"' stopWatch.ElapsedMilliseconds)' string.Format ("{0}"' pingReply.Address));  		WorkQueue.GlobalQueueWorkItemTag (new Action<IPAddress' int> ((address' hopNumber) =>  {  			string hostName;  			try {  				hostName = Dns.GetHostEntry (address).HostName;  			}  			catch {  				hostName = "";  			}  			if (this.IsHandleCreated) {  				this.BeginInvoke (new MethodInvoker (() =>  {  					foreach (ListViewItem item in listInfo.Items) {  						if (item.Text == hopNumber.ToString ()) {  							item.SubItems [3].Text = hostName;  							break;  						}  					}  				}));  			}  		})' "ipinfowindow-resolveaddress"' pingReply.Address' i);  		if (pingReply.Status == IPStatus.Success) {  			WriteStatus ("Trace complete."' false);  			break;  		}  		pingOptions.Ttl++;  	}  }  
Magic Number,ProcessHacker,IPInfoWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\IPInfoWindow.cs,Tracert,The following statement contains a magic number: using (Ping pingSender = new Ping ()) {  	PingOptions pingOptions = new PingOptions ();  	Stopwatch stopWatch = new Stopwatch ();  	byte[] bytes = new byte[32];  	pingOptions.DontFragment = true;  	pingOptions.Ttl = 1;  	int maxHops = 30;  	WriteStatus (string.Format ("Tracing route to {0} over a maximum of {1} hops:"' ipAddress' maxHops)' true);  	for (int i = 1; i < maxHops + 1; i++) {  		stopWatch.Reset ();  		stopWatch.Start ();  		PingReply pingReply;  		try {  			pingReply = pingSender.Send (ipAddress' 5000' new byte[32]' pingOptions);  		}  		catch (Exception ex) {  			WriteStatus ("Trace error: " + ex.Message' false);  			break;  		}  		finally {  			stopWatch.Stop ();  		}  		WriteResult (string.Format ("{0}"' i)' string.Format ("{0} ms"' stopWatch.ElapsedMilliseconds)' string.Format ("{0}"' pingReply.Address));  		WorkQueue.GlobalQueueWorkItemTag (new Action<IPAddress' int> ((address' hopNumber) =>  {  			string hostName;  			try {  				hostName = Dns.GetHostEntry (address).HostName;  			}  			catch {  				hostName = "";  			}  			if (this.IsHandleCreated) {  				this.BeginInvoke (new MethodInvoker (() =>  {  					foreach (ListViewItem item in listInfo.Items) {  						if (item.Text == hopNumber.ToString ()) {  							item.SubItems [3].Text = hostName;  							break;  						}  					}  				}));  			}  		})' "ipinfowindow-resolveaddress"' pingReply.Address' i);  		if (pingReply.Status == IPStatus.Success) {  			WriteStatus ("Trace complete."' false);  			break;  		}  		pingOptions.Ttl++;  	}  }  
Magic Number,ProcessHacker,IPInfoWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\IPInfoWindow.cs,Tracert,The following statement contains a magic number: using (Ping pingSender = new Ping ()) {  	PingOptions pingOptions = new PingOptions ();  	Stopwatch stopWatch = new Stopwatch ();  	byte[] bytes = new byte[32];  	pingOptions.DontFragment = true;  	pingOptions.Ttl = 1;  	int maxHops = 30;  	WriteStatus (string.Format ("Tracing route to {0} over a maximum of {1} hops:"' ipAddress' maxHops)' true);  	for (int i = 1; i < maxHops + 1; i++) {  		stopWatch.Reset ();  		stopWatch.Start ();  		PingReply pingReply;  		try {  			pingReply = pingSender.Send (ipAddress' 5000' new byte[32]' pingOptions);  		}  		catch (Exception ex) {  			WriteStatus ("Trace error: " + ex.Message' false);  			break;  		}  		finally {  			stopWatch.Stop ();  		}  		WriteResult (string.Format ("{0}"' i)' string.Format ("{0} ms"' stopWatch.ElapsedMilliseconds)' string.Format ("{0}"' pingReply.Address));  		WorkQueue.GlobalQueueWorkItemTag (new Action<IPAddress' int> ((address' hopNumber) =>  {  			string hostName;  			try {  				hostName = Dns.GetHostEntry (address).HostName;  			}  			catch {  				hostName = "";  			}  			if (this.IsHandleCreated) {  				this.BeginInvoke (new MethodInvoker (() =>  {  					foreach (ListViewItem item in listInfo.Items) {  						if (item.Text == hopNumber.ToString ()) {  							item.SubItems [3].Text = hostName;  							break;  						}  					}  				}));  			}  		})' "ipinfowindow-resolveaddress"' pingReply.Address' i);  		if (pingReply.Status == IPStatus.Success) {  			WriteStatus ("Trace complete."' false);  			break;  		}  		pingOptions.Ttl++;  	}  }  
Magic Number,ProcessHacker,IPInfoWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\IPInfoWindow.cs,Tracert,The following statement contains a magic number: for (int i = 1; i < maxHops + 1; i++) {  	stopWatch.Reset ();  	stopWatch.Start ();  	PingReply pingReply;  	try {  		pingReply = pingSender.Send (ipAddress' 5000' new byte[32]' pingOptions);  	}  	catch (Exception ex) {  		WriteStatus ("Trace error: " + ex.Message' false);  		break;  	}  	finally {  		stopWatch.Stop ();  	}  	WriteResult (string.Format ("{0}"' i)' string.Format ("{0} ms"' stopWatch.ElapsedMilliseconds)' string.Format ("{0}"' pingReply.Address));  	WorkQueue.GlobalQueueWorkItemTag (new Action<IPAddress' int> ((address' hopNumber) =>  {  		string hostName;  		try {  			hostName = Dns.GetHostEntry (address).HostName;  		}  		catch {  			hostName = "";  		}  		if (this.IsHandleCreated) {  			this.BeginInvoke (new MethodInvoker (() =>  {  				foreach (ListViewItem item in listInfo.Items) {  					if (item.Text == hopNumber.ToString ()) {  						item.SubItems [3].Text = hostName;  						break;  					}  				}  			}));  		}  	})' "ipinfowindow-resolveaddress"' pingReply.Address' i);  	if (pingReply.Status == IPStatus.Success) {  		WriteStatus ("Trace complete."' false);  		break;  	}  	pingOptions.Ttl++;  }  
Magic Number,ProcessHacker,IPInfoWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\IPInfoWindow.cs,Tracert,The following statement contains a magic number: for (int i = 1; i < maxHops + 1; i++) {  	stopWatch.Reset ();  	stopWatch.Start ();  	PingReply pingReply;  	try {  		pingReply = pingSender.Send (ipAddress' 5000' new byte[32]' pingOptions);  	}  	catch (Exception ex) {  		WriteStatus ("Trace error: " + ex.Message' false);  		break;  	}  	finally {  		stopWatch.Stop ();  	}  	WriteResult (string.Format ("{0}"' i)' string.Format ("{0} ms"' stopWatch.ElapsedMilliseconds)' string.Format ("{0}"' pingReply.Address));  	WorkQueue.GlobalQueueWorkItemTag (new Action<IPAddress' int> ((address' hopNumber) =>  {  		string hostName;  		try {  			hostName = Dns.GetHostEntry (address).HostName;  		}  		catch {  			hostName = "";  		}  		if (this.IsHandleCreated) {  			this.BeginInvoke (new MethodInvoker (() =>  {  				foreach (ListViewItem item in listInfo.Items) {  					if (item.Text == hopNumber.ToString ()) {  						item.SubItems [3].Text = hostName;  						break;  					}  				}  			}));  		}  	})' "ipinfowindow-resolveaddress"' pingReply.Address' i);  	if (pingReply.Status == IPStatus.Success) {  		WriteStatus ("Trace complete."' false);  		break;  	}  	pingOptions.Ttl++;  }  
Magic Number,ProcessHacker,IPInfoWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\IPInfoWindow.cs,Tracert,The following statement contains a magic number: for (int i = 1; i < maxHops + 1; i++) {  	stopWatch.Reset ();  	stopWatch.Start ();  	PingReply pingReply;  	try {  		pingReply = pingSender.Send (ipAddress' 5000' new byte[32]' pingOptions);  	}  	catch (Exception ex) {  		WriteStatus ("Trace error: " + ex.Message' false);  		break;  	}  	finally {  		stopWatch.Stop ();  	}  	WriteResult (string.Format ("{0}"' i)' string.Format ("{0} ms"' stopWatch.ElapsedMilliseconds)' string.Format ("{0}"' pingReply.Address));  	WorkQueue.GlobalQueueWorkItemTag (new Action<IPAddress' int> ((address' hopNumber) =>  {  		string hostName;  		try {  			hostName = Dns.GetHostEntry (address).HostName;  		}  		catch {  			hostName = "";  		}  		if (this.IsHandleCreated) {  			this.BeginInvoke (new MethodInvoker (() =>  {  				foreach (ListViewItem item in listInfo.Items) {  					if (item.Text == hopNumber.ToString ()) {  						item.SubItems [3].Text = hostName;  						break;  					}  				}  			}));  		}  	})' "ipinfowindow-resolveaddress"' pingReply.Address' i);  	if (pingReply.Status == IPStatus.Success) {  		WriteStatus ("Trace complete."' false);  		break;  	}  	pingOptions.Ttl++;  }  
Magic Number,ProcessHacker,IPInfoWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\IPInfoWindow.cs,Tracert,The following statement contains a magic number: try {  	pingReply = pingSender.Send (ipAddress' 5000' new byte[32]' pingOptions);  }  catch (Exception ex) {  	WriteStatus ("Trace error: " + ex.Message' false);  	break;  }  finally {  	stopWatch.Stop ();  }  
Magic Number,ProcessHacker,IPInfoWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\IPInfoWindow.cs,Tracert,The following statement contains a magic number: try {  	pingReply = pingSender.Send (ipAddress' 5000' new byte[32]' pingOptions);  }  catch (Exception ex) {  	WriteStatus ("Trace error: " + ex.Message' false);  	break;  }  finally {  	stopWatch.Stop ();  }  
Magic Number,ProcessHacker,IPInfoWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\IPInfoWindow.cs,Tracert,The following statement contains a magic number: pingReply = pingSender.Send (ipAddress' 5000' new byte[32]' pingOptions);  
Magic Number,ProcessHacker,IPInfoWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\IPInfoWindow.cs,Tracert,The following statement contains a magic number: pingReply = pingSender.Send (ipAddress' 5000' new byte[32]' pingOptions);  
Magic Number,ProcessHacker,IPInfoWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\IPInfoWindow.cs,Tracert,The following statement contains a magic number: WorkQueue.GlobalQueueWorkItemTag (new Action<IPAddress' int> ((address' hopNumber) =>  {  	string hostName;  	try {  		hostName = Dns.GetHostEntry (address).HostName;  	}  	catch {  		hostName = "";  	}  	if (this.IsHandleCreated) {  		this.BeginInvoke (new MethodInvoker (() =>  {  			foreach (ListViewItem item in listInfo.Items) {  				if (item.Text == hopNumber.ToString ()) {  					item.SubItems [3].Text = hostName;  					break;  				}  			}  		}));  	}  })' "ipinfowindow-resolveaddress"' pingReply.Address' i);  
Magic Number,ProcessHacker,IPInfoWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\IPInfoWindow.cs,Tracert,The following statement contains a magic number: if (this.IsHandleCreated) {  	this.BeginInvoke (new MethodInvoker (() =>  {  		foreach (ListViewItem item in listInfo.Items) {  			if (item.Text == hopNumber.ToString ()) {  				item.SubItems [3].Text = hostName;  				break;  			}  		}  	}));  }  
Magic Number,ProcessHacker,IPInfoWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\IPInfoWindow.cs,Tracert,The following statement contains a magic number: this.BeginInvoke (new MethodInvoker (() =>  {  	foreach (ListViewItem item in listInfo.Items) {  		if (item.Text == hopNumber.ToString ()) {  			item.SubItems [3].Text = hostName;  			break;  		}  	}  }));  
Magic Number,ProcessHacker,IPInfoWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\IPInfoWindow.cs,Tracert,The following statement contains a magic number: foreach (ListViewItem item in listInfo.Items) {  	if (item.Text == hopNumber.ToString ()) {  		item.SubItems [3].Text = hostName;  		break;  	}  }  
Magic Number,ProcessHacker,IPInfoWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\IPInfoWindow.cs,Tracert,The following statement contains a magic number: if (item.Text == hopNumber.ToString ()) {  	item.SubItems [3].Text = hostName;  	break;  }  
Magic Number,ProcessHacker,IPInfoWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\IPInfoWindow.cs,Tracert,The following statement contains a magic number: item.SubItems [3].Text = hostName;  
Magic Number,ProcessHacker,IPInfoWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\IPInfoWindow.cs,Whois,The following statement contains a magic number: try {  	using (TcpClient tcpClinetWhois = new TcpClient ("wq.apnic.net"' 43))  		using (NetworkStream networkStreamWhois = tcpClinetWhois.GetStream ())  			using (BufferedStream bufferedStreamWhois = new BufferedStream (networkStreamWhois))  				using (StreamWriter streamWriter = new StreamWriter (bufferedStreamWhois)) {  					streamWriter.WriteLine (((IPAddress)ip).ToString ());  					streamWriter.Flush ();  					StreamReader streamReaderReceive = new StreamReader (bufferedStreamWhois);  					while (!streamReaderReceive.EndOfStream) {  						string data = streamReaderReceive.ReadLine ();  						if (!data.Contains ("#") | !data.Contains ("?")) {  							WriteResult (data' ""' "");  						}  					}  				}  	WriteStatus ("Whois complete."' false);  }  catch (Exception ex) {  	WriteStatus ("Whois error: " + ex.Message' false);  }  
Magic Number,ProcessHacker,IPInfoWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\IPInfoWindow.cs,Whois,The following statement contains a magic number: using (TcpClient tcpClinetWhois = new TcpClient ("wq.apnic.net"' 43))  	using (NetworkStream networkStreamWhois = tcpClinetWhois.GetStream ())  		using (BufferedStream bufferedStreamWhois = new BufferedStream (networkStreamWhois))  			using (StreamWriter streamWriter = new StreamWriter (bufferedStreamWhois)) {  				streamWriter.WriteLine (((IPAddress)ip).ToString ());  				streamWriter.Flush ();  				StreamReader streamReaderReceive = new StreamReader (bufferedStreamWhois);  				while (!streamReaderReceive.EndOfStream) {  					string data = streamReaderReceive.ReadLine ();  					if (!data.Contains ("#") | !data.Contains ("?")) {  						WriteResult (data' ""' "");  					}  				}  			}  
Magic Number,ProcessHacker,SessionInformationWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\SessionInformationWindow.cs,SessionInformationWindow,The following statement contains a magic number: if (session.ClientDisplay.ColorDepth != 0 && session.ClientDisplay.ColorDepth != 2)  	// HACK  	labelClientDisplayResolution.Text = session.ClientDisplay.HorizontalResolution + "x" + session.ClientDisplay.VerticalResolution + "@" + session.ClientDisplay.ColorDepth;  
Magic Number,ProcessHacker,VirusTotalUploaderWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\VirusTotalUploaderWindow.cs,VirusTotalUploaderWindow_Load,The following statement contains a magic number: if (!finfo.Exists) {  	if (OSVersion.HasTaskDialogs) {  		TaskDialog td = new TaskDialog ();  		td.PositionRelativeToWindow = true;  		td.Content = "The selected file doesn't exist or couldnt be found!";  		td.MainInstruction = "File Location not Available!";  		td.WindowTitle = "System Error";  		td.MainIcon = TaskDialogIcon.CircleX;  		td.CommonButtons = TaskDialogCommonButtons.Ok;  		td.Show (Program.HackerWindow.Handle);  	}  	else {  		MessageBox.Show (this' "The selected file doesn't exist or couldnt be found!"' "System Error"' MessageBoxButtons.OK' MessageBoxIcon.Exclamation);  	}  	this.Close ();  }  else if (finfo.Length >= 20971520/* 20MB */) {  	if (OSVersion.HasTaskDialogs) {  		TaskDialog td = new TaskDialog ();  		td.PositionRelativeToWindow = true;  		td.Content = "This file is larger than 20MB' above the VirusTotal limit!";  		td.MainInstruction = "File is too large";  		td.WindowTitle = "VirusTotal Error";  		td.MainIcon = TaskDialogIcon.CircleX;  		td.CommonButtons = TaskDialogCommonButtons.Ok;  		td.Show (Program.HackerWindow.Handle);  	}  	else {  		MessageBox.Show (this' "This file is larger than 20MB and is above the VirusTotal size limit!"' "VirusTotal Error"' MessageBoxButtons.OK' MessageBoxIcon.Exclamation);  	}  	this.Close ();  }  else {  	totalFileSize = finfo.Length;  }  
Magic Number,ProcessHacker,VirusTotalUploaderWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\VirusTotalUploaderWindow.cs,VirusTotalUploaderWindow_Load,The following statement contains a magic number: if (finfo.Length >= 20971520/* 20MB */) {  	if (OSVersion.HasTaskDialogs) {  		TaskDialog td = new TaskDialog ();  		td.PositionRelativeToWindow = true;  		td.Content = "This file is larger than 20MB' above the VirusTotal limit!";  		td.MainInstruction = "File is too large";  		td.WindowTitle = "VirusTotal Error";  		td.MainIcon = TaskDialogIcon.CircleX;  		td.CommonButtons = TaskDialogCommonButtons.Ok;  		td.Show (Program.HackerWindow.Handle);  	}  	else {  		MessageBox.Show (this' "This file is larger than 20MB and is above the VirusTotal size limit!"' "VirusTotal Error"' MessageBoxButtons.OK' MessageBoxIcon.Exclamation);  	}  	this.Close ();  }  else {  	totalFileSize = finfo.Length;  }  
Magic Number,ProcessHacker,VirusTotalUploaderWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\VirusTotalUploaderWindow.cs,getSessionTokenTask_RunTask,The following statement contains a magic number: try {  	HttpWebRequest sessionRequest = (HttpWebRequest)HttpWebRequest.Create ("http://www.virustotal.com/vt/en/identificador");  	sessionRequest.ServicePoint.ConnectionLimit = 20;  	sessionRequest.UserAgent = "Process Hacker " + Application.ProductVersion;  	sessionRequest.Timeout = System.Threading.Timeout.Infinite;  	sessionRequest.KeepAlive = true;  	using (WebResponse Response = sessionRequest.GetResponse ())  		using (Stream WebStream = Response.GetResponseStream ())  			using (StreamReader Reader = new StreamReader (WebStream)) {  				result = Reader.ReadToEnd ();  			}  }  catch (Exception ex) {  	PhUtils.ShowException ("Unable to contact VirusTotal"' ex);  	if (this.IsHandleCreated)  		this.BeginInvoke (new MethodInvoker (this.Close));  }  
Magic Number,ProcessHacker,VirusTotalUploaderWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\VirusTotalUploaderWindow.cs,getSessionTokenTask_RunTask,The following statement contains a magic number: sessionRequest.ServicePoint.ConnectionLimit = 20;  
Magic Number,ProcessHacker,VirusTotalUploaderWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\VirusTotalUploaderWindow.cs,uploadTask_RunTask,The following statement contains a magic number: uploadRequest.ServicePoint.ConnectionLimit = 20;  
Magic Number,ProcessHacker,VirusTotalUploaderWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\VirusTotalUploaderWindow.cs,uploadTask_RunTask,The following statement contains a magic number: try {  	uploadStopwatch = new Stopwatch ();  	uploadStopwatch.Start ();  	using (FileStream fileStream = new FileStream (fileName' FileMode.Open' FileAccess.Read)) {  		uploadRequest.ContentLength = postHeaderBytes.Length + fileStream.Length + boundaryBytes.Length;  		using (Stream requestStream = uploadRequest.GetRequestStream ()) {  			// Write out our post header  			requestStream.Write (postHeaderBytes' 0' postHeaderBytes.Length);  			// Write out the file contents  			byte[] buffer = new Byte[checked((uint)Math.Min (32' (int)fileStream.Length))];  			int bytesRead = 0;  			while ((bytesRead = fileStream.Read (buffer' 0' buffer.Length)) != 0) {  				if (uploadTask.Cancelled) {  					uploadRequest.Abort ();  					return;  				}  				requestStream.Write (buffer' 0' bytesRead);  				int progress = (int)(((double)fileStream.Position * 100 / fileStream.Length));  				if (uploadStopwatch.ElapsedMilliseconds > 0)  					bytesPerSecond = fileStream.Position * 1000 / uploadStopwatch.ElapsedMilliseconds;  				bytesTransferred = fileStream.Position;  				if (this.IsHandleCreated)  					this.BeginInvoke (new Action<int> (this.ChangeProgress)' progress);  			}  			if (uploadTask.Cancelled) {  				uploadRequest.Abort ();  				return;  			}  			// Write out the trailing boundary  			requestStream.Write (boundaryBytes' 0' boundaryBytes.Length);  			requestStream.Close ();  		}  	}  }  catch (WebException ex) {  	// RequestCanceled will occour when we cancel the WebRequest.  	// Filter out that exception but log all others.  	if (ex != null) {  		if (ex.Status != WebExceptionStatus.RequestCanceled) {  			PhUtils.ShowException ("Unable to upload the file"' ex);  			Logging.Log (ex);  			if (this.IsHandleCreated)  				this.BeginInvoke (new MethodInvoker (this.Close));  		}  	}  }  
Magic Number,ProcessHacker,VirusTotalUploaderWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\VirusTotalUploaderWindow.cs,uploadTask_RunTask,The following statement contains a magic number: try {  	uploadStopwatch = new Stopwatch ();  	uploadStopwatch.Start ();  	using (FileStream fileStream = new FileStream (fileName' FileMode.Open' FileAccess.Read)) {  		uploadRequest.ContentLength = postHeaderBytes.Length + fileStream.Length + boundaryBytes.Length;  		using (Stream requestStream = uploadRequest.GetRequestStream ()) {  			// Write out our post header  			requestStream.Write (postHeaderBytes' 0' postHeaderBytes.Length);  			// Write out the file contents  			byte[] buffer = new Byte[checked((uint)Math.Min (32' (int)fileStream.Length))];  			int bytesRead = 0;  			while ((bytesRead = fileStream.Read (buffer' 0' buffer.Length)) != 0) {  				if (uploadTask.Cancelled) {  					uploadRequest.Abort ();  					return;  				}  				requestStream.Write (buffer' 0' bytesRead);  				int progress = (int)(((double)fileStream.Position * 100 / fileStream.Length));  				if (uploadStopwatch.ElapsedMilliseconds > 0)  					bytesPerSecond = fileStream.Position * 1000 / uploadStopwatch.ElapsedMilliseconds;  				bytesTransferred = fileStream.Position;  				if (this.IsHandleCreated)  					this.BeginInvoke (new Action<int> (this.ChangeProgress)' progress);  			}  			if (uploadTask.Cancelled) {  				uploadRequest.Abort ();  				return;  			}  			// Write out the trailing boundary  			requestStream.Write (boundaryBytes' 0' boundaryBytes.Length);  			requestStream.Close ();  		}  	}  }  catch (WebException ex) {  	// RequestCanceled will occour when we cancel the WebRequest.  	// Filter out that exception but log all others.  	if (ex != null) {  		if (ex.Status != WebExceptionStatus.RequestCanceled) {  			PhUtils.ShowException ("Unable to upload the file"' ex);  			Logging.Log (ex);  			if (this.IsHandleCreated)  				this.BeginInvoke (new MethodInvoker (this.Close));  		}  	}  }  
Magic Number,ProcessHacker,VirusTotalUploaderWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\VirusTotalUploaderWindow.cs,uploadTask_RunTask,The following statement contains a magic number: try {  	uploadStopwatch = new Stopwatch ();  	uploadStopwatch.Start ();  	using (FileStream fileStream = new FileStream (fileName' FileMode.Open' FileAccess.Read)) {  		uploadRequest.ContentLength = postHeaderBytes.Length + fileStream.Length + boundaryBytes.Length;  		using (Stream requestStream = uploadRequest.GetRequestStream ()) {  			// Write out our post header  			requestStream.Write (postHeaderBytes' 0' postHeaderBytes.Length);  			// Write out the file contents  			byte[] buffer = new Byte[checked((uint)Math.Min (32' (int)fileStream.Length))];  			int bytesRead = 0;  			while ((bytesRead = fileStream.Read (buffer' 0' buffer.Length)) != 0) {  				if (uploadTask.Cancelled) {  					uploadRequest.Abort ();  					return;  				}  				requestStream.Write (buffer' 0' bytesRead);  				int progress = (int)(((double)fileStream.Position * 100 / fileStream.Length));  				if (uploadStopwatch.ElapsedMilliseconds > 0)  					bytesPerSecond = fileStream.Position * 1000 / uploadStopwatch.ElapsedMilliseconds;  				bytesTransferred = fileStream.Position;  				if (this.IsHandleCreated)  					this.BeginInvoke (new Action<int> (this.ChangeProgress)' progress);  			}  			if (uploadTask.Cancelled) {  				uploadRequest.Abort ();  				return;  			}  			// Write out the trailing boundary  			requestStream.Write (boundaryBytes' 0' boundaryBytes.Length);  			requestStream.Close ();  		}  	}  }  catch (WebException ex) {  	// RequestCanceled will occour when we cancel the WebRequest.  	// Filter out that exception but log all others.  	if (ex != null) {  		if (ex.Status != WebExceptionStatus.RequestCanceled) {  			PhUtils.ShowException ("Unable to upload the file"' ex);  			Logging.Log (ex);  			if (this.IsHandleCreated)  				this.BeginInvoke (new MethodInvoker (this.Close));  		}  	}  }  
Magic Number,ProcessHacker,VirusTotalUploaderWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\VirusTotalUploaderWindow.cs,uploadTask_RunTask,The following statement contains a magic number: using (FileStream fileStream = new FileStream (fileName' FileMode.Open' FileAccess.Read)) {  	uploadRequest.ContentLength = postHeaderBytes.Length + fileStream.Length + boundaryBytes.Length;  	using (Stream requestStream = uploadRequest.GetRequestStream ()) {  		// Write out our post header  		requestStream.Write (postHeaderBytes' 0' postHeaderBytes.Length);  		// Write out the file contents  		byte[] buffer = new Byte[checked((uint)Math.Min (32' (int)fileStream.Length))];  		int bytesRead = 0;  		while ((bytesRead = fileStream.Read (buffer' 0' buffer.Length)) != 0) {  			if (uploadTask.Cancelled) {  				uploadRequest.Abort ();  				return;  			}  			requestStream.Write (buffer' 0' bytesRead);  			int progress = (int)(((double)fileStream.Position * 100 / fileStream.Length));  			if (uploadStopwatch.ElapsedMilliseconds > 0)  				bytesPerSecond = fileStream.Position * 1000 / uploadStopwatch.ElapsedMilliseconds;  			bytesTransferred = fileStream.Position;  			if (this.IsHandleCreated)  				this.BeginInvoke (new Action<int> (this.ChangeProgress)' progress);  		}  		if (uploadTask.Cancelled) {  			uploadRequest.Abort ();  			return;  		}  		// Write out the trailing boundary  		requestStream.Write (boundaryBytes' 0' boundaryBytes.Length);  		requestStream.Close ();  	}  }  
Magic Number,ProcessHacker,VirusTotalUploaderWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\VirusTotalUploaderWindow.cs,uploadTask_RunTask,The following statement contains a magic number: using (FileStream fileStream = new FileStream (fileName' FileMode.Open' FileAccess.Read)) {  	uploadRequest.ContentLength = postHeaderBytes.Length + fileStream.Length + boundaryBytes.Length;  	using (Stream requestStream = uploadRequest.GetRequestStream ()) {  		// Write out our post header  		requestStream.Write (postHeaderBytes' 0' postHeaderBytes.Length);  		// Write out the file contents  		byte[] buffer = new Byte[checked((uint)Math.Min (32' (int)fileStream.Length))];  		int bytesRead = 0;  		while ((bytesRead = fileStream.Read (buffer' 0' buffer.Length)) != 0) {  			if (uploadTask.Cancelled) {  				uploadRequest.Abort ();  				return;  			}  			requestStream.Write (buffer' 0' bytesRead);  			int progress = (int)(((double)fileStream.Position * 100 / fileStream.Length));  			if (uploadStopwatch.ElapsedMilliseconds > 0)  				bytesPerSecond = fileStream.Position * 1000 / uploadStopwatch.ElapsedMilliseconds;  			bytesTransferred = fileStream.Position;  			if (this.IsHandleCreated)  				this.BeginInvoke (new Action<int> (this.ChangeProgress)' progress);  		}  		if (uploadTask.Cancelled) {  			uploadRequest.Abort ();  			return;  		}  		// Write out the trailing boundary  		requestStream.Write (boundaryBytes' 0' boundaryBytes.Length);  		requestStream.Close ();  	}  }  
Magic Number,ProcessHacker,VirusTotalUploaderWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\VirusTotalUploaderWindow.cs,uploadTask_RunTask,The following statement contains a magic number: using (FileStream fileStream = new FileStream (fileName' FileMode.Open' FileAccess.Read)) {  	uploadRequest.ContentLength = postHeaderBytes.Length + fileStream.Length + boundaryBytes.Length;  	using (Stream requestStream = uploadRequest.GetRequestStream ()) {  		// Write out our post header  		requestStream.Write (postHeaderBytes' 0' postHeaderBytes.Length);  		// Write out the file contents  		byte[] buffer = new Byte[checked((uint)Math.Min (32' (int)fileStream.Length))];  		int bytesRead = 0;  		while ((bytesRead = fileStream.Read (buffer' 0' buffer.Length)) != 0) {  			if (uploadTask.Cancelled) {  				uploadRequest.Abort ();  				return;  			}  			requestStream.Write (buffer' 0' bytesRead);  			int progress = (int)(((double)fileStream.Position * 100 / fileStream.Length));  			if (uploadStopwatch.ElapsedMilliseconds > 0)  				bytesPerSecond = fileStream.Position * 1000 / uploadStopwatch.ElapsedMilliseconds;  			bytesTransferred = fileStream.Position;  			if (this.IsHandleCreated)  				this.BeginInvoke (new Action<int> (this.ChangeProgress)' progress);  		}  		if (uploadTask.Cancelled) {  			uploadRequest.Abort ();  			return;  		}  		// Write out the trailing boundary  		requestStream.Write (boundaryBytes' 0' boundaryBytes.Length);  		requestStream.Close ();  	}  }  
Magic Number,ProcessHacker,VirusTotalUploaderWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\VirusTotalUploaderWindow.cs,uploadTask_RunTask,The following statement contains a magic number: using (Stream requestStream = uploadRequest.GetRequestStream ()) {  	// Write out our post header  	requestStream.Write (postHeaderBytes' 0' postHeaderBytes.Length);  	// Write out the file contents  	byte[] buffer = new Byte[checked((uint)Math.Min (32' (int)fileStream.Length))];  	int bytesRead = 0;  	while ((bytesRead = fileStream.Read (buffer' 0' buffer.Length)) != 0) {  		if (uploadTask.Cancelled) {  			uploadRequest.Abort ();  			return;  		}  		requestStream.Write (buffer' 0' bytesRead);  		int progress = (int)(((double)fileStream.Position * 100 / fileStream.Length));  		if (uploadStopwatch.ElapsedMilliseconds > 0)  			bytesPerSecond = fileStream.Position * 1000 / uploadStopwatch.ElapsedMilliseconds;  		bytesTransferred = fileStream.Position;  		if (this.IsHandleCreated)  			this.BeginInvoke (new Action<int> (this.ChangeProgress)' progress);  	}  	if (uploadTask.Cancelled) {  		uploadRequest.Abort ();  		return;  	}  	// Write out the trailing boundary  	requestStream.Write (boundaryBytes' 0' boundaryBytes.Length);  	requestStream.Close ();  }  
Magic Number,ProcessHacker,VirusTotalUploaderWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\VirusTotalUploaderWindow.cs,uploadTask_RunTask,The following statement contains a magic number: using (Stream requestStream = uploadRequest.GetRequestStream ()) {  	// Write out our post header  	requestStream.Write (postHeaderBytes' 0' postHeaderBytes.Length);  	// Write out the file contents  	byte[] buffer = new Byte[checked((uint)Math.Min (32' (int)fileStream.Length))];  	int bytesRead = 0;  	while ((bytesRead = fileStream.Read (buffer' 0' buffer.Length)) != 0) {  		if (uploadTask.Cancelled) {  			uploadRequest.Abort ();  			return;  		}  		requestStream.Write (buffer' 0' bytesRead);  		int progress = (int)(((double)fileStream.Position * 100 / fileStream.Length));  		if (uploadStopwatch.ElapsedMilliseconds > 0)  			bytesPerSecond = fileStream.Position * 1000 / uploadStopwatch.ElapsedMilliseconds;  		bytesTransferred = fileStream.Position;  		if (this.IsHandleCreated)  			this.BeginInvoke (new Action<int> (this.ChangeProgress)' progress);  	}  	if (uploadTask.Cancelled) {  		uploadRequest.Abort ();  		return;  	}  	// Write out the trailing boundary  	requestStream.Write (boundaryBytes' 0' boundaryBytes.Length);  	requestStream.Close ();  }  
Magic Number,ProcessHacker,VirusTotalUploaderWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\VirusTotalUploaderWindow.cs,uploadTask_RunTask,The following statement contains a magic number: using (Stream requestStream = uploadRequest.GetRequestStream ()) {  	// Write out our post header  	requestStream.Write (postHeaderBytes' 0' postHeaderBytes.Length);  	// Write out the file contents  	byte[] buffer = new Byte[checked((uint)Math.Min (32' (int)fileStream.Length))];  	int bytesRead = 0;  	while ((bytesRead = fileStream.Read (buffer' 0' buffer.Length)) != 0) {  		if (uploadTask.Cancelled) {  			uploadRequest.Abort ();  			return;  		}  		requestStream.Write (buffer' 0' bytesRead);  		int progress = (int)(((double)fileStream.Position * 100 / fileStream.Length));  		if (uploadStopwatch.ElapsedMilliseconds > 0)  			bytesPerSecond = fileStream.Position * 1000 / uploadStopwatch.ElapsedMilliseconds;  		bytesTransferred = fileStream.Position;  		if (this.IsHandleCreated)  			this.BeginInvoke (new Action<int> (this.ChangeProgress)' progress);  	}  	if (uploadTask.Cancelled) {  		uploadRequest.Abort ();  		return;  	}  	// Write out the trailing boundary  	requestStream.Write (boundaryBytes' 0' boundaryBytes.Length);  	requestStream.Close ();  }  
Magic Number,ProcessHacker,VirusTotalUploaderWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\VirusTotalUploaderWindow.cs,uploadTask_RunTask,The following statement contains a magic number: while ((bytesRead = fileStream.Read (buffer' 0' buffer.Length)) != 0) {  	if (uploadTask.Cancelled) {  		uploadRequest.Abort ();  		return;  	}  	requestStream.Write (buffer' 0' bytesRead);  	int progress = (int)(((double)fileStream.Position * 100 / fileStream.Length));  	if (uploadStopwatch.ElapsedMilliseconds > 0)  		bytesPerSecond = fileStream.Position * 1000 / uploadStopwatch.ElapsedMilliseconds;  	bytesTransferred = fileStream.Position;  	if (this.IsHandleCreated)  		this.BeginInvoke (new Action<int> (this.ChangeProgress)' progress);  }  
Magic Number,ProcessHacker,VirusTotalUploaderWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\VirusTotalUploaderWindow.cs,uploadTask_RunTask,The following statement contains a magic number: while ((bytesRead = fileStream.Read (buffer' 0' buffer.Length)) != 0) {  	if (uploadTask.Cancelled) {  		uploadRequest.Abort ();  		return;  	}  	requestStream.Write (buffer' 0' bytesRead);  	int progress = (int)(((double)fileStream.Position * 100 / fileStream.Length));  	if (uploadStopwatch.ElapsedMilliseconds > 0)  		bytesPerSecond = fileStream.Position * 1000 / uploadStopwatch.ElapsedMilliseconds;  	bytesTransferred = fileStream.Position;  	if (this.IsHandleCreated)  		this.BeginInvoke (new Action<int> (this.ChangeProgress)' progress);  }  
Magic Number,ProcessHacker,VirusTotalUploaderWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\VirusTotalUploaderWindow.cs,uploadTask_RunTask,The following statement contains a magic number: if (uploadStopwatch.ElapsedMilliseconds > 0)  	bytesPerSecond = fileStream.Position * 1000 / uploadStopwatch.ElapsedMilliseconds;  
Magic Number,ProcessHacker,VirusTotalUploaderWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\VirusTotalUploaderWindow.cs,uploadTask_RunTask,The following statement contains a magic number: bytesPerSecond = fileStream.Position * 1000 / uploadStopwatch.ElapsedMilliseconds;  
Magic Number,ProcessHacker,VirusTotalUploaderWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\VirusTotalUploaderWindow.cs,ChangeProgress,The following statement contains a magic number: uploadedLabel.Text = "Uploaded: " + Utils.FormatSize (bytesTransferred) + " (" + ((double)bytesTransferred * 100 / totalFileSize).ToString ("F2") + "%)";  
Magic Number,ProcessHacker,NetworkMonitor,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\NetInfoWindow.cs,NetworkMonitor,The following statement contains a magic number: this.timer = new System.Timers.Timer (1000);  
Magic Number,ProcessHacker,Dump,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\Dump.cs,DumpProcess,The following statement contains a magic number: using (var general = processMo.CreateChild ("General")) {  	BinaryWriter bw = new BinaryWriter (general.GetWriteStream ());  	if (pid < 0) {  		bw.Write ("ProcessId"' pid);  		bw.Write ("Name"' process.Name);  		bw.Write ("ParentPid"' 0);  		bw.Write ("HasParent"' true);  		if (item != null)  			bw.Write ("CpuUsage"' item.CpuUsage.ToString ());  		bw.Close ();  		return;  	}  	bw.Write ("ProcessId"' pid);  	bw.Write ("Name"' pid != 0 ? process.Name : "System Idle Process");  	bw.Write ("ParentPid"' process.Process.InheritedFromProcessId);  	bw.Write ("StartTime"' DateTime.FromFileTime (process.Process.CreateTime));  	bw.Write ("SessionId"' process.Process.SessionId);  	bool hasParent = true;  	if (!processesDict.ContainsKey (process.Process.InheritedFromProcessId) || process.Process.InheritedFromProcessId == process.Process.ProcessId) {  		hasParent = false;  	}  	else if (processesDict.ContainsKey (process.Process.InheritedFromProcessId)) {  		ulong parentStartTime = (ulong)processesDict [process.Process.InheritedFromProcessId].Process.CreateTime;  		ulong thisStartTime = (ulong)process.Process.CreateTime;  		if (parentStartTime > thisStartTime)  			hasParent = false;  	}  	bw.Write ("HasParent"' hasParent);  	try {  		string fileName;  		if (pid != 4) {  			using (var phandle = new ProcessHandle (pid' Program.MinProcessQueryRights))  				fileName = FileUtils.GetFileName (phandle.GetImageFileName ());  		}  		else {  			fileName = Windows.KernelFileName;  		}  		bw.Write ("FileName"' fileName);  		var info = System.Diagnostics.FileVersionInfo.GetVersionInfo (fileName);  		bw.Write ("FileDescription"' info.FileDescription);  		bw.Write ("FileCompanyName"' info.CompanyName);  		bw.Write ("FileVersion"' info.FileVersion);  		try {  			Icon icon;  			icon = FileUtils.GetFileIcon (fileName' false);  			if (icon != null) {  				using (var smallIcon = processMo.CreateChild ("SmallIcon")) {  					using (var s = smallIcon.GetWriteStream ()) {  						using (var b = icon.ToBitmap ())  							b.Save (s' System.Drawing.Imaging.ImageFormat.Png);  					}  				}  				Win32.DestroyIcon (icon.Handle);  			}  			icon = FileUtils.GetFileIcon (fileName' true);  			if (icon != null) {  				using (var largeIcon = processMo.CreateChild ("LargeIcon")) {  					using (var s = largeIcon.GetWriteStream ()) {  						using (var b = icon.ToBitmap ())  							b.Save (s' System.Drawing.Imaging.ImageFormat.Png);  					}  				}  				Win32.DestroyIcon (icon.Handle);  			}  		}  		catch {  		}  	}  	catch {  	}  	try {  		using (var phandle = new ProcessHandle (pid' Program.MinProcessQueryRights | ProcessAccess.VmRead)) {  			bw.Write ("CommandLine"' phandle.GetCommandLine ());  			bw.Write ("CurrentDirectory"' phandle.GetPebString (PebOffset.CurrentDirectoryPath));  			bw.Write ("IsPosix"' phandle.IsPosix ());  		}  	}  	catch {  	}  	try {  		using (var phandle = new ProcessHandle (pid' Program.MinProcessQueryRights)) {  			if (OSVersion.Architecture == OSArch.Amd64)  				bw.Write ("IsWow64"' phandle.IsWow64 ());  		}  		using (var phandle = new ProcessHandle (pid' ProcessAccess.QueryInformation)) {  			bw.Write ("IsBeingDebugged"' phandle.IsBeingDebugged ());  			bw.Write ("IsCritical"' phandle.IsCritical ());  			bw.Write ("DepStatus"' (int)phandle.GetDepStatus ());  		}  	}  	catch {  	}  	bool userNameWritten = false;  	try {  		using (var phandle = new ProcessHandle (pid' Program.MinProcessQueryRights)) {  			using (var thandle = phandle.GetToken (TokenAccess.Query)) {  				bw.Write ("UserName"' thandle.GetUser ().GetFullName (true));  				userNameWritten = true;  				if (OSVersion.HasUac)  					bw.Write ("ElevationType"' (int)thandle.GetElevationType ());  			}  		}  	}  	catch {  	}  	if (!userNameWritten && pid <= 4)  		bw.Write ("UserName"' "NT AUTHORITY\\SYSTEM");  	if (item != null) {  		bw.Write ("CpuUsage"' item.CpuUsage.ToString ());  		bw.Write ("JobName"' item.JobName);  		bw.Write ("IsInJob"' item.IsInJob);  		bw.Write ("IsInSignificantJob"' item.IsInSignificantJob);  		bw.Write ("Integrity"' item.Integrity);  		bw.Write ("IntegrityLevel"' item.IntegrityLevel);  		bw.Write ("IsDotNet"' item.IsDotNet);  		bw.Write ("IsPacked"' item.IsPacked);  		bw.Write ("VerifyResult"' (int)item.VerifyResult);  		bw.Write ("VerifySignerName"' item.VerifySignerName);  		bw.Write ("ImportFunctions"' item.ImportFunctions);  		bw.Write ("ImportModules"' item.ImportModules);  	}  	bw.Close ();  }  
Magic Number,ProcessHacker,Dump,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\Dump.cs,DumpProcess,The following statement contains a magic number: using (var general = processMo.CreateChild ("General")) {  	BinaryWriter bw = new BinaryWriter (general.GetWriteStream ());  	if (pid < 0) {  		bw.Write ("ProcessId"' pid);  		bw.Write ("Name"' process.Name);  		bw.Write ("ParentPid"' 0);  		bw.Write ("HasParent"' true);  		if (item != null)  			bw.Write ("CpuUsage"' item.CpuUsage.ToString ());  		bw.Close ();  		return;  	}  	bw.Write ("ProcessId"' pid);  	bw.Write ("Name"' pid != 0 ? process.Name : "System Idle Process");  	bw.Write ("ParentPid"' process.Process.InheritedFromProcessId);  	bw.Write ("StartTime"' DateTime.FromFileTime (process.Process.CreateTime));  	bw.Write ("SessionId"' process.Process.SessionId);  	bool hasParent = true;  	if (!processesDict.ContainsKey (process.Process.InheritedFromProcessId) || process.Process.InheritedFromProcessId == process.Process.ProcessId) {  		hasParent = false;  	}  	else if (processesDict.ContainsKey (process.Process.InheritedFromProcessId)) {  		ulong parentStartTime = (ulong)processesDict [process.Process.InheritedFromProcessId].Process.CreateTime;  		ulong thisStartTime = (ulong)process.Process.CreateTime;  		if (parentStartTime > thisStartTime)  			hasParent = false;  	}  	bw.Write ("HasParent"' hasParent);  	try {  		string fileName;  		if (pid != 4) {  			using (var phandle = new ProcessHandle (pid' Program.MinProcessQueryRights))  				fileName = FileUtils.GetFileName (phandle.GetImageFileName ());  		}  		else {  			fileName = Windows.KernelFileName;  		}  		bw.Write ("FileName"' fileName);  		var info = System.Diagnostics.FileVersionInfo.GetVersionInfo (fileName);  		bw.Write ("FileDescription"' info.FileDescription);  		bw.Write ("FileCompanyName"' info.CompanyName);  		bw.Write ("FileVersion"' info.FileVersion);  		try {  			Icon icon;  			icon = FileUtils.GetFileIcon (fileName' false);  			if (icon != null) {  				using (var smallIcon = processMo.CreateChild ("SmallIcon")) {  					using (var s = smallIcon.GetWriteStream ()) {  						using (var b = icon.ToBitmap ())  							b.Save (s' System.Drawing.Imaging.ImageFormat.Png);  					}  				}  				Win32.DestroyIcon (icon.Handle);  			}  			icon = FileUtils.GetFileIcon (fileName' true);  			if (icon != null) {  				using (var largeIcon = processMo.CreateChild ("LargeIcon")) {  					using (var s = largeIcon.GetWriteStream ()) {  						using (var b = icon.ToBitmap ())  							b.Save (s' System.Drawing.Imaging.ImageFormat.Png);  					}  				}  				Win32.DestroyIcon (icon.Handle);  			}  		}  		catch {  		}  	}  	catch {  	}  	try {  		using (var phandle = new ProcessHandle (pid' Program.MinProcessQueryRights | ProcessAccess.VmRead)) {  			bw.Write ("CommandLine"' phandle.GetCommandLine ());  			bw.Write ("CurrentDirectory"' phandle.GetPebString (PebOffset.CurrentDirectoryPath));  			bw.Write ("IsPosix"' phandle.IsPosix ());  		}  	}  	catch {  	}  	try {  		using (var phandle = new ProcessHandle (pid' Program.MinProcessQueryRights)) {  			if (OSVersion.Architecture == OSArch.Amd64)  				bw.Write ("IsWow64"' phandle.IsWow64 ());  		}  		using (var phandle = new ProcessHandle (pid' ProcessAccess.QueryInformation)) {  			bw.Write ("IsBeingDebugged"' phandle.IsBeingDebugged ());  			bw.Write ("IsCritical"' phandle.IsCritical ());  			bw.Write ("DepStatus"' (int)phandle.GetDepStatus ());  		}  	}  	catch {  	}  	bool userNameWritten = false;  	try {  		using (var phandle = new ProcessHandle (pid' Program.MinProcessQueryRights)) {  			using (var thandle = phandle.GetToken (TokenAccess.Query)) {  				bw.Write ("UserName"' thandle.GetUser ().GetFullName (true));  				userNameWritten = true;  				if (OSVersion.HasUac)  					bw.Write ("ElevationType"' (int)thandle.GetElevationType ());  			}  		}  	}  	catch {  	}  	if (!userNameWritten && pid <= 4)  		bw.Write ("UserName"' "NT AUTHORITY\\SYSTEM");  	if (item != null) {  		bw.Write ("CpuUsage"' item.CpuUsage.ToString ());  		bw.Write ("JobName"' item.JobName);  		bw.Write ("IsInJob"' item.IsInJob);  		bw.Write ("IsInSignificantJob"' item.IsInSignificantJob);  		bw.Write ("Integrity"' item.Integrity);  		bw.Write ("IntegrityLevel"' item.IntegrityLevel);  		bw.Write ("IsDotNet"' item.IsDotNet);  		bw.Write ("IsPacked"' item.IsPacked);  		bw.Write ("VerifyResult"' (int)item.VerifyResult);  		bw.Write ("VerifySignerName"' item.VerifySignerName);  		bw.Write ("ImportFunctions"' item.ImportFunctions);  		bw.Write ("ImportModules"' item.ImportModules);  	}  	bw.Close ();  }  
Magic Number,ProcessHacker,Dump,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\Dump.cs,DumpProcess,The following statement contains a magic number: try {  	string fileName;  	if (pid != 4) {  		using (var phandle = new ProcessHandle (pid' Program.MinProcessQueryRights))  			fileName = FileUtils.GetFileName (phandle.GetImageFileName ());  	}  	else {  		fileName = Windows.KernelFileName;  	}  	bw.Write ("FileName"' fileName);  	var info = System.Diagnostics.FileVersionInfo.GetVersionInfo (fileName);  	bw.Write ("FileDescription"' info.FileDescription);  	bw.Write ("FileCompanyName"' info.CompanyName);  	bw.Write ("FileVersion"' info.FileVersion);  	try {  		Icon icon;  		icon = FileUtils.GetFileIcon (fileName' false);  		if (icon != null) {  			using (var smallIcon = processMo.CreateChild ("SmallIcon")) {  				using (var s = smallIcon.GetWriteStream ()) {  					using (var b = icon.ToBitmap ())  						b.Save (s' System.Drawing.Imaging.ImageFormat.Png);  				}  			}  			Win32.DestroyIcon (icon.Handle);  		}  		icon = FileUtils.GetFileIcon (fileName' true);  		if (icon != null) {  			using (var largeIcon = processMo.CreateChild ("LargeIcon")) {  				using (var s = largeIcon.GetWriteStream ()) {  					using (var b = icon.ToBitmap ())  						b.Save (s' System.Drawing.Imaging.ImageFormat.Png);  				}  			}  			Win32.DestroyIcon (icon.Handle);  		}  	}  	catch {  	}  }  catch {  }  
Magic Number,ProcessHacker,Dump,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\Dump.cs,DumpProcess,The following statement contains a magic number: if (pid != 4) {  	using (var phandle = new ProcessHandle (pid' Program.MinProcessQueryRights))  		fileName = FileUtils.GetFileName (phandle.GetImageFileName ());  }  else {  	fileName = Windows.KernelFileName;  }  
Magic Number,ProcessHacker,Dump,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\Dump.cs,DumpProcess,The following statement contains a magic number: if (!userNameWritten && pid <= 4)  	bw.Write ("UserName"' "NT AUTHORITY\\SYSTEM");  
Magic Number,ProcessHacker,Dump,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\Dump.cs,DumpProcessModules,The following statement contains a magic number: using (var modules = processMo.CreateChild ("Modules")) {  	if (pid != 4) {  		var baseAddressList = new Dictionary<IntPtr' object> ();  		bool isWow64 = false;  		using (var phandle = new ProcessHandle (pid' Program.MinProcessQueryRights | ProcessAccess.VmRead)) {  			if (OSVersion.Architecture == OSArch.Amd64)  				isWow64 = phandle.IsWow64 ();  			phandle.EnumModules (module =>  {  				if (!baseAddressList.ContainsKey (module.BaseAddress)) {  					DumpProcessModule (modules' module);  					baseAddressList.Add (module.BaseAddress' null);  				}  				return true;  			});  		}  		try {  			using (var phandle = new ProcessHandle (pid' ProcessAccess.QueryInformation | ProcessAccess.VmRead)) {  				phandle.EnumMemory (memory =>  {  					if (memory.Type == MemoryType.Mapped) {  						if (!baseAddressList.ContainsKey (memory.BaseAddress)) {  							string fileName = phandle.GetMappedFileName (memory.BaseAddress);  							if (fileName != null) {  								fileName = FileUtils.GetFileName (fileName);  								DumpProcessModule (modules' new ProcessModule (memory.BaseAddress' memory.RegionSize.ToInt32 ()' IntPtr.Zero' 0' Path.GetFileName (fileName)' fileName));  								baseAddressList.Add (memory.BaseAddress' null);  							}  						}  					}  					return true;  				});  			}  		}  		catch {  		}  		if (isWow64) {  			try {  				using (var buffer = new ProcessHacker.Native.Debugging.DebugBuffer ()) {  					buffer.Query (pid' RtlQueryProcessDebugFlags.Modules32 | RtlQueryProcessDebugFlags.NonInvasive);  					buffer.EnumModules (module =>  {  						if (!baseAddressList.ContainsKey (module.BaseAddress)) {  							DumpProcessModule (modules' module);  							baseAddressList.Add (module.BaseAddress' null);  						}  						return true;  					});  				}  			}  			catch {  			}  		}  	}  	else {  		foreach (var module in Windows.GetKernelModules ())  			DumpProcessModule (modules' module);  	}  }  
Magic Number,ProcessHacker,Dump,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\Dump.cs,DumpProcessModules,The following statement contains a magic number: if (pid != 4) {  	var baseAddressList = new Dictionary<IntPtr' object> ();  	bool isWow64 = false;  	using (var phandle = new ProcessHandle (pid' Program.MinProcessQueryRights | ProcessAccess.VmRead)) {  		if (OSVersion.Architecture == OSArch.Amd64)  			isWow64 = phandle.IsWow64 ();  		phandle.EnumModules (module =>  {  			if (!baseAddressList.ContainsKey (module.BaseAddress)) {  				DumpProcessModule (modules' module);  				baseAddressList.Add (module.BaseAddress' null);  			}  			return true;  		});  	}  	try {  		using (var phandle = new ProcessHandle (pid' ProcessAccess.QueryInformation | ProcessAccess.VmRead)) {  			phandle.EnumMemory (memory =>  {  				if (memory.Type == MemoryType.Mapped) {  					if (!baseAddressList.ContainsKey (memory.BaseAddress)) {  						string fileName = phandle.GetMappedFileName (memory.BaseAddress);  						if (fileName != null) {  							fileName = FileUtils.GetFileName (fileName);  							DumpProcessModule (modules' new ProcessModule (memory.BaseAddress' memory.RegionSize.ToInt32 ()' IntPtr.Zero' 0' Path.GetFileName (fileName)' fileName));  							baseAddressList.Add (memory.BaseAddress' null);  						}  					}  				}  				return true;  			});  		}  	}  	catch {  	}  	if (isWow64) {  		try {  			using (var buffer = new ProcessHacker.Native.Debugging.DebugBuffer ()) {  				buffer.Query (pid' RtlQueryProcessDebugFlags.Modules32 | RtlQueryProcessDebugFlags.NonInvasive);  				buffer.EnumModules (module =>  {  					if (!baseAddressList.ContainsKey (module.BaseAddress)) {  						DumpProcessModule (modules' module);  						baseAddressList.Add (module.BaseAddress' null);  					}  					return true;  				});  			}  		}  		catch {  		}  	}  }  else {  	foreach (var module in Windows.GetKernelModules ())  		DumpProcessModule (modules' module);  }  
Magic Number,ProcessHacker,Updater,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\Updater.cs,GetAssemblyBuildDate,The following statement contains a magic number: if (AssemblyBuildDate != null)//Performance fix - Prevent reading current Assembly multiple times   {  	return (DateTime)AssemblyBuildDate;  }  else {  	const int PeHeaderOffset = 60;  	const int LinkerTimestampOffset = 8;  	byte[] b = new byte[2048];  	System.IO.Stream s = default(System.IO.Stream);  	try {  		s = new System.IO.FileStream (System.Reflection.Assembly.GetExecutingAssembly ().Location' System.IO.FileMode.Open' System.IO.FileAccess.Read);  		s.Read (b' 0' 2048);  	}  	finally {  		if ((s != null))  			s.Close ();  	}  	int i = BitConverter.ToInt32 (b' PeHeaderOffset);  	int SecondsSince1970 = BitConverter.ToInt32 (b' i + LinkerTimestampOffset);  	DateTime dt = new DateTime (1970' 1' 1' 0' 0' 0);  	dt = dt.AddSeconds (SecondsSince1970);  	dt = dt.AddHours (TimeZone.CurrentTimeZone.GetUtcOffset (dt).Hours);  	AssemblyBuildDate = dt;  	return (DateTime)AssemblyBuildDate;  }  
Magic Number,ProcessHacker,Updater,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\Updater.cs,GetAssemblyBuildDate,The following statement contains a magic number: if (AssemblyBuildDate != null)//Performance fix - Prevent reading current Assembly multiple times   {  	return (DateTime)AssemblyBuildDate;  }  else {  	const int PeHeaderOffset = 60;  	const int LinkerTimestampOffset = 8;  	byte[] b = new byte[2048];  	System.IO.Stream s = default(System.IO.Stream);  	try {  		s = new System.IO.FileStream (System.Reflection.Assembly.GetExecutingAssembly ().Location' System.IO.FileMode.Open' System.IO.FileAccess.Read);  		s.Read (b' 0' 2048);  	}  	finally {  		if ((s != null))  			s.Close ();  	}  	int i = BitConverter.ToInt32 (b' PeHeaderOffset);  	int SecondsSince1970 = BitConverter.ToInt32 (b' i + LinkerTimestampOffset);  	DateTime dt = new DateTime (1970' 1' 1' 0' 0' 0);  	dt = dt.AddSeconds (SecondsSince1970);  	dt = dt.AddHours (TimeZone.CurrentTimeZone.GetUtcOffset (dt).Hours);  	AssemblyBuildDate = dt;  	return (DateTime)AssemblyBuildDate;  }  
Magic Number,ProcessHacker,Updater,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\Updater.cs,GetAssemblyBuildDate,The following statement contains a magic number: if (AssemblyBuildDate != null)//Performance fix - Prevent reading current Assembly multiple times   {  	return (DateTime)AssemblyBuildDate;  }  else {  	const int PeHeaderOffset = 60;  	const int LinkerTimestampOffset = 8;  	byte[] b = new byte[2048];  	System.IO.Stream s = default(System.IO.Stream);  	try {  		s = new System.IO.FileStream (System.Reflection.Assembly.GetExecutingAssembly ().Location' System.IO.FileMode.Open' System.IO.FileAccess.Read);  		s.Read (b' 0' 2048);  	}  	finally {  		if ((s != null))  			s.Close ();  	}  	int i = BitConverter.ToInt32 (b' PeHeaderOffset);  	int SecondsSince1970 = BitConverter.ToInt32 (b' i + LinkerTimestampOffset);  	DateTime dt = new DateTime (1970' 1' 1' 0' 0' 0);  	dt = dt.AddSeconds (SecondsSince1970);  	dt = dt.AddHours (TimeZone.CurrentTimeZone.GetUtcOffset (dt).Hours);  	AssemblyBuildDate = dt;  	return (DateTime)AssemblyBuildDate;  }  
Magic Number,ProcessHacker,Updater,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\Updater.cs,GetAssemblyBuildDate,The following statement contains a magic number: if (AssemblyBuildDate != null)//Performance fix - Prevent reading current Assembly multiple times   {  	return (DateTime)AssemblyBuildDate;  }  else {  	const int PeHeaderOffset = 60;  	const int LinkerTimestampOffset = 8;  	byte[] b = new byte[2048];  	System.IO.Stream s = default(System.IO.Stream);  	try {  		s = new System.IO.FileStream (System.Reflection.Assembly.GetExecutingAssembly ().Location' System.IO.FileMode.Open' System.IO.FileAccess.Read);  		s.Read (b' 0' 2048);  	}  	finally {  		if ((s != null))  			s.Close ();  	}  	int i = BitConverter.ToInt32 (b' PeHeaderOffset);  	int SecondsSince1970 = BitConverter.ToInt32 (b' i + LinkerTimestampOffset);  	DateTime dt = new DateTime (1970' 1' 1' 0' 0' 0);  	dt = dt.AddSeconds (SecondsSince1970);  	dt = dt.AddHours (TimeZone.CurrentTimeZone.GetUtcOffset (dt).Hours);  	AssemblyBuildDate = dt;  	return (DateTime)AssemblyBuildDate;  }  
Magic Number,ProcessHacker,Updater,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\Updater.cs,GetAssemblyBuildDate,The following statement contains a magic number: if (AssemblyBuildDate != null)//Performance fix - Prevent reading current Assembly multiple times   {  	return (DateTime)AssemblyBuildDate;  }  else {  	const int PeHeaderOffset = 60;  	const int LinkerTimestampOffset = 8;  	byte[] b = new byte[2048];  	System.IO.Stream s = default(System.IO.Stream);  	try {  		s = new System.IO.FileStream (System.Reflection.Assembly.GetExecutingAssembly ().Location' System.IO.FileMode.Open' System.IO.FileAccess.Read);  		s.Read (b' 0' 2048);  	}  	finally {  		if ((s != null))  			s.Close ();  	}  	int i = BitConverter.ToInt32 (b' PeHeaderOffset);  	int SecondsSince1970 = BitConverter.ToInt32 (b' i + LinkerTimestampOffset);  	DateTime dt = new DateTime (1970' 1' 1' 0' 0' 0);  	dt = dt.AddSeconds (SecondsSince1970);  	dt = dt.AddHours (TimeZone.CurrentTimeZone.GetUtcOffset (dt).Hours);  	AssemblyBuildDate = dt;  	return (DateTime)AssemblyBuildDate;  }  
Magic Number,ProcessHacker,Updater,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\Updater.cs,GetAssemblyBuildDate,The following statement contains a magic number: try {  	s = new System.IO.FileStream (System.Reflection.Assembly.GetExecutingAssembly ().Location' System.IO.FileMode.Open' System.IO.FileAccess.Read);  	s.Read (b' 0' 2048);  }  finally {  	if ((s != null))  		s.Close ();  }  
Magic Number,ProcessHacker,Updater,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\Updater.cs,GetAssemblyBuildDate,The following statement contains a magic number: s.Read (b' 0' 2048);  
Magic Number,ProcessHacker,UpdaterDownloadWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\UpdaterDownloadWindow.cs,webClient_DownloadFileCompleted,The following statement contains a magic number: if (!_redirected) {  	_redirected = true;  	try {  		bool isHtml = false;  		using (var file = new BinaryReader (File.OpenRead (_fileName))) {  			if (!file.ReadChars (2).Equals ("MZ".ToCharArray ())) {  				isHtml = true;  			}  		}  		if (isHtml) {  			string text = File.ReadAllText (_fileName);  			// Assume this is from Ohloh.  			int iframeIndex = text.IndexOf ("window.delayed_iframe");  			if (iframeIndex == -1)  				return;  			int httpIndex = text.IndexOf ("http://"' iframeIndex);  			if (httpIndex == -1)  				return;  			int quoteIndex = text.IndexOf ("'"' httpIndex);  			if (quoteIndex == -1)  				return;  			_webClient.DownloadFileAsync (new Uri (text.Substring (httpIndex' quoteIndex - httpIndex))' _fileName);  			return;  		}  	}  	catch (Exception ex) {  		Logging.Log (ex);  	}  }  
Magic Number,ProcessHacker,UpdaterDownloadWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\UpdaterDownloadWindow.cs,webClient_DownloadFileCompleted,The following statement contains a magic number: try {  	bool isHtml = false;  	using (var file = new BinaryReader (File.OpenRead (_fileName))) {  		if (!file.ReadChars (2).Equals ("MZ".ToCharArray ())) {  			isHtml = true;  		}  	}  	if (isHtml) {  		string text = File.ReadAllText (_fileName);  		// Assume this is from Ohloh.  		int iframeIndex = text.IndexOf ("window.delayed_iframe");  		if (iframeIndex == -1)  			return;  		int httpIndex = text.IndexOf ("http://"' iframeIndex);  		if (httpIndex == -1)  			return;  		int quoteIndex = text.IndexOf ("'"' httpIndex);  		if (quoteIndex == -1)  			return;  		_webClient.DownloadFileAsync (new Uri (text.Substring (httpIndex' quoteIndex - httpIndex))' _fileName);  		return;  	}  }  catch (Exception ex) {  	Logging.Log (ex);  }  
Magic Number,ProcessHacker,UpdaterDownloadWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\UpdaterDownloadWindow.cs,webClient_DownloadFileCompleted,The following statement contains a magic number: using (var file = new BinaryReader (File.OpenRead (_fileName))) {  	if (!file.ReadChars (2).Equals ("MZ".ToCharArray ())) {  		isHtml = true;  	}  }  
Magic Number,ProcessHacker,UpdaterDownloadWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\UpdaterDownloadWindow.cs,webClient_DownloadFileCompleted,The following statement contains a magic number: if (!file.ReadChars (2).Equals ("MZ".ToCharArray ())) {  	isHtml = true;  }  
Magic Number,ProcessHacker,UpdaterDownloadWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\UpdaterDownloadWindow.cs,verifyTask_RunTask,The following statement contains a magic number: using (Stream stream = File.OpenRead (_fileName))  	//Change to MD5.Create for MD5 verification  	using (System.Security.Cryptography.HashAlgorithm hashAlgorithm = System.Security.Cryptography.SHA1.Create ()) {  		size = stream.Length;  		buffer = new byte[4096];  		bytesRead = stream.Read (buffer' 0' buffer.Length);  		totalBytesRead += bytesRead;  		do {  			if (_verifyTask.Cancelled)  				return;  			oldBytesRead = bytesRead;  			oldBuffer = buffer;  			buffer = new byte[4096];  			bytesRead = stream.Read (buffer' 0' buffer.Length);  			totalBytesRead += bytesRead;  			if (bytesRead == 0) {  				hashAlgorithm.TransformFinalBlock (oldBuffer' 0' oldBytesRead);  			}  			else {  				hashAlgorithm.TransformBlock (oldBuffer' 0' oldBytesRead' oldBuffer' 0);  			}  			if (this.IsHandleCreated) {  				this.BeginInvoke (new MethodInvoker (() =>  {  					int value = (int)((double)totalBytesRead * 100 / size);  					if (value >= this.progressDownload.Minimum && value <= this.progressDownload.Maximum) {  						this.progressDownload.Value = value;  					}  				}));  			}  		}  		while (bytesRead != 0);  		result = hashAlgorithm.Hash;  	}  
Magic Number,ProcessHacker,UpdaterDownloadWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\UpdaterDownloadWindow.cs,verifyTask_RunTask,The following statement contains a magic number: using (Stream stream = File.OpenRead (_fileName))  	//Change to MD5.Create for MD5 verification  	using (System.Security.Cryptography.HashAlgorithm hashAlgorithm = System.Security.Cryptography.SHA1.Create ()) {  		size = stream.Length;  		buffer = new byte[4096];  		bytesRead = stream.Read (buffer' 0' buffer.Length);  		totalBytesRead += bytesRead;  		do {  			if (_verifyTask.Cancelled)  				return;  			oldBytesRead = bytesRead;  			oldBuffer = buffer;  			buffer = new byte[4096];  			bytesRead = stream.Read (buffer' 0' buffer.Length);  			totalBytesRead += bytesRead;  			if (bytesRead == 0) {  				hashAlgorithm.TransformFinalBlock (oldBuffer' 0' oldBytesRead);  			}  			else {  				hashAlgorithm.TransformBlock (oldBuffer' 0' oldBytesRead' oldBuffer' 0);  			}  			if (this.IsHandleCreated) {  				this.BeginInvoke (new MethodInvoker (() =>  {  					int value = (int)((double)totalBytesRead * 100 / size);  					if (value >= this.progressDownload.Minimum && value <= this.progressDownload.Maximum) {  						this.progressDownload.Value = value;  					}  				}));  			}  		}  		while (bytesRead != 0);  		result = hashAlgorithm.Hash;  	}  
Magic Number,ProcessHacker,UpdaterDownloadWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\UpdaterDownloadWindow.cs,verifyTask_RunTask,The following statement contains a magic number: using (Stream stream = File.OpenRead (_fileName))  	//Change to MD5.Create for MD5 verification  	using (System.Security.Cryptography.HashAlgorithm hashAlgorithm = System.Security.Cryptography.SHA1.Create ()) {  		size = stream.Length;  		buffer = new byte[4096];  		bytesRead = stream.Read (buffer' 0' buffer.Length);  		totalBytesRead += bytesRead;  		do {  			if (_verifyTask.Cancelled)  				return;  			oldBytesRead = bytesRead;  			oldBuffer = buffer;  			buffer = new byte[4096];  			bytesRead = stream.Read (buffer' 0' buffer.Length);  			totalBytesRead += bytesRead;  			if (bytesRead == 0) {  				hashAlgorithm.TransformFinalBlock (oldBuffer' 0' oldBytesRead);  			}  			else {  				hashAlgorithm.TransformBlock (oldBuffer' 0' oldBytesRead' oldBuffer' 0);  			}  			if (this.IsHandleCreated) {  				this.BeginInvoke (new MethodInvoker (() =>  {  					int value = (int)((double)totalBytesRead * 100 / size);  					if (value >= this.progressDownload.Minimum && value <= this.progressDownload.Maximum) {  						this.progressDownload.Value = value;  					}  				}));  			}  		}  		while (bytesRead != 0);  		result = hashAlgorithm.Hash;  	}  
Magic Number,ProcessHacker,UpdaterDownloadWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\UpdaterDownloadWindow.cs,verifyTask_RunTask,The following statement contains a magic number: using (System.Security.Cryptography.HashAlgorithm hashAlgorithm = System.Security.Cryptography.SHA1.Create ()) {  	size = stream.Length;  	buffer = new byte[4096];  	bytesRead = stream.Read (buffer' 0' buffer.Length);  	totalBytesRead += bytesRead;  	do {  		if (_verifyTask.Cancelled)  			return;  		oldBytesRead = bytesRead;  		oldBuffer = buffer;  		buffer = new byte[4096];  		bytesRead = stream.Read (buffer' 0' buffer.Length);  		totalBytesRead += bytesRead;  		if (bytesRead == 0) {  			hashAlgorithm.TransformFinalBlock (oldBuffer' 0' oldBytesRead);  		}  		else {  			hashAlgorithm.TransformBlock (oldBuffer' 0' oldBytesRead' oldBuffer' 0);  		}  		if (this.IsHandleCreated) {  			this.BeginInvoke (new MethodInvoker (() =>  {  				int value = (int)((double)totalBytesRead * 100 / size);  				if (value >= this.progressDownload.Minimum && value <= this.progressDownload.Maximum) {  					this.progressDownload.Value = value;  				}  			}));  		}  	}  	while (bytesRead != 0);  	result = hashAlgorithm.Hash;  }  
Magic Number,ProcessHacker,UpdaterDownloadWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\UpdaterDownloadWindow.cs,verifyTask_RunTask,The following statement contains a magic number: using (System.Security.Cryptography.HashAlgorithm hashAlgorithm = System.Security.Cryptography.SHA1.Create ()) {  	size = stream.Length;  	buffer = new byte[4096];  	bytesRead = stream.Read (buffer' 0' buffer.Length);  	totalBytesRead += bytesRead;  	do {  		if (_verifyTask.Cancelled)  			return;  		oldBytesRead = bytesRead;  		oldBuffer = buffer;  		buffer = new byte[4096];  		bytesRead = stream.Read (buffer' 0' buffer.Length);  		totalBytesRead += bytesRead;  		if (bytesRead == 0) {  			hashAlgorithm.TransformFinalBlock (oldBuffer' 0' oldBytesRead);  		}  		else {  			hashAlgorithm.TransformBlock (oldBuffer' 0' oldBytesRead' oldBuffer' 0);  		}  		if (this.IsHandleCreated) {  			this.BeginInvoke (new MethodInvoker (() =>  {  				int value = (int)((double)totalBytesRead * 100 / size);  				if (value >= this.progressDownload.Minimum && value <= this.progressDownload.Maximum) {  					this.progressDownload.Value = value;  				}  			}));  		}  	}  	while (bytesRead != 0);  	result = hashAlgorithm.Hash;  }  
Magic Number,ProcessHacker,UpdaterDownloadWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\UpdaterDownloadWindow.cs,verifyTask_RunTask,The following statement contains a magic number: using (System.Security.Cryptography.HashAlgorithm hashAlgorithm = System.Security.Cryptography.SHA1.Create ()) {  	size = stream.Length;  	buffer = new byte[4096];  	bytesRead = stream.Read (buffer' 0' buffer.Length);  	totalBytesRead += bytesRead;  	do {  		if (_verifyTask.Cancelled)  			return;  		oldBytesRead = bytesRead;  		oldBuffer = buffer;  		buffer = new byte[4096];  		bytesRead = stream.Read (buffer' 0' buffer.Length);  		totalBytesRead += bytesRead;  		if (bytesRead == 0) {  			hashAlgorithm.TransformFinalBlock (oldBuffer' 0' oldBytesRead);  		}  		else {  			hashAlgorithm.TransformBlock (oldBuffer' 0' oldBytesRead' oldBuffer' 0);  		}  		if (this.IsHandleCreated) {  			this.BeginInvoke (new MethodInvoker (() =>  {  				int value = (int)((double)totalBytesRead * 100 / size);  				if (value >= this.progressDownload.Minimum && value <= this.progressDownload.Maximum) {  					this.progressDownload.Value = value;  				}  			}));  		}  	}  	while (bytesRead != 0);  	result = hashAlgorithm.Hash;  }  
Magic Number,ProcessHacker,UpdaterDownloadWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\UpdaterDownloadWindow.cs,verifyTask_RunTask,The following statement contains a magic number: buffer = new byte[4096];  
Magic Number,ProcessHacker,UpdaterDownloadWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\UpdaterDownloadWindow.cs,verifyTask_RunTask,The following statement contains a magic number: do {  	if (_verifyTask.Cancelled)  		return;  	oldBytesRead = bytesRead;  	oldBuffer = buffer;  	buffer = new byte[4096];  	bytesRead = stream.Read (buffer' 0' buffer.Length);  	totalBytesRead += bytesRead;  	if (bytesRead == 0) {  		hashAlgorithm.TransformFinalBlock (oldBuffer' 0' oldBytesRead);  	}  	else {  		hashAlgorithm.TransformBlock (oldBuffer' 0' oldBytesRead' oldBuffer' 0);  	}  	if (this.IsHandleCreated) {  		this.BeginInvoke (new MethodInvoker (() =>  {  			int value = (int)((double)totalBytesRead * 100 / size);  			if (value >= this.progressDownload.Minimum && value <= this.progressDownload.Maximum) {  				this.progressDownload.Value = value;  			}  		}));  	}  }  while (bytesRead != 0);  
Magic Number,ProcessHacker,UpdaterDownloadWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\UpdaterDownloadWindow.cs,verifyTask_RunTask,The following statement contains a magic number: do {  	if (_verifyTask.Cancelled)  		return;  	oldBytesRead = bytesRead;  	oldBuffer = buffer;  	buffer = new byte[4096];  	bytesRead = stream.Read (buffer' 0' buffer.Length);  	totalBytesRead += bytesRead;  	if (bytesRead == 0) {  		hashAlgorithm.TransformFinalBlock (oldBuffer' 0' oldBytesRead);  	}  	else {  		hashAlgorithm.TransformBlock (oldBuffer' 0' oldBytesRead' oldBuffer' 0);  	}  	if (this.IsHandleCreated) {  		this.BeginInvoke (new MethodInvoker (() =>  {  			int value = (int)((double)totalBytesRead * 100 / size);  			if (value >= this.progressDownload.Minimum && value <= this.progressDownload.Maximum) {  				this.progressDownload.Value = value;  			}  		}));  	}  }  while (bytesRead != 0);  
Magic Number,ProcessHacker,UpdaterDownloadWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\UpdaterDownloadWindow.cs,verifyTask_RunTask,The following statement contains a magic number: buffer = new byte[4096];  
Magic Number,ProcessHacker,UpdaterDownloadWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\UpdaterDownloadWindow.cs,verifyTask_RunTask,The following statement contains a magic number: if (this.IsHandleCreated) {  	this.BeginInvoke (new MethodInvoker (() =>  {  		int value = (int)((double)totalBytesRead * 100 / size);  		if (value >= this.progressDownload.Minimum && value <= this.progressDownload.Maximum) {  			this.progressDownload.Value = value;  		}  	}));  }  
Magic Number,ProcessHacker,UpdaterDownloadWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\UpdaterDownloadWindow.cs,verifyTask_RunTask,The following statement contains a magic number: this.BeginInvoke (new MethodInvoker (() =>  {  	int value = (int)((double)totalBytesRead * 100 / size);  	if (value >= this.progressDownload.Minimum && value <= this.progressDownload.Maximum) {  		this.progressDownload.Value = value;  	}  }));  
Magic Number,ProcessHacker,CpuUsageIcon,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\UI\Icons\CpuUsageIcon.cs,ProviderUpdated,The following statement contains a magic number: using (Bitmap b = new Bitmap (width' height)) {  	using (Graphics g = Graphics.FromImage (b)) {  		int kl = (int)(k * height);  		int ul = (int)(u * height);  		Color kline = Settings.Instance.PlotterCPUKernelColor;  		Color kfill = Color.FromArgb (100' kline);  		Color uline = Settings.Instance.PlotterCPUUserColor;  		Color ufill = Color.FromArgb (100' uline);  		g.FillRectangle (new SolidBrush (Color.Black)' g.ClipBounds);  		if (kl + ul == 0)  			g.DrawLine (new Pen (uline)' 0' height - 1' width - 1' height - 1);  		g.FillRectangle (new SolidBrush (ufill)' 0' height - (ul + kl)' width' ul);  		g.DrawLine (new Pen (uline)' 0' height - (ul + kl) - 1' width' height - (ul + kl) - 1);  		if (kl > 0) {  			g.FillRectangle (new SolidBrush (kfill)' 0' height - kl' width' kl);  			g.DrawLine (new Pen (kline)' 0' height - kl - 1' width' height - kl - 1);  		}  	}  	var newIcon = Icon.FromHandle (b.GetHicon ());  	var oldIcon = this.Icon;  	this.Icon = newIcon;  	ProcessHacker.Native.Api.Win32.DestroyIcon (oldIcon.Handle);  }  
Magic Number,ProcessHacker,CpuUsageIcon,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\UI\Icons\CpuUsageIcon.cs,ProviderUpdated,The following statement contains a magic number: using (Bitmap b = new Bitmap (width' height)) {  	using (Graphics g = Graphics.FromImage (b)) {  		int kl = (int)(k * height);  		int ul = (int)(u * height);  		Color kline = Settings.Instance.PlotterCPUKernelColor;  		Color kfill = Color.FromArgb (100' kline);  		Color uline = Settings.Instance.PlotterCPUUserColor;  		Color ufill = Color.FromArgb (100' uline);  		g.FillRectangle (new SolidBrush (Color.Black)' g.ClipBounds);  		if (kl + ul == 0)  			g.DrawLine (new Pen (uline)' 0' height - 1' width - 1' height - 1);  		g.FillRectangle (new SolidBrush (ufill)' 0' height - (ul + kl)' width' ul);  		g.DrawLine (new Pen (uline)' 0' height - (ul + kl) - 1' width' height - (ul + kl) - 1);  		if (kl > 0) {  			g.FillRectangle (new SolidBrush (kfill)' 0' height - kl' width' kl);  			g.DrawLine (new Pen (kline)' 0' height - kl - 1' width' height - kl - 1);  		}  	}  	var newIcon = Icon.FromHandle (b.GetHicon ());  	var oldIcon = this.Icon;  	this.Icon = newIcon;  	ProcessHacker.Native.Api.Win32.DestroyIcon (oldIcon.Handle);  }  
Magic Number,ProcessHacker,CpuUsageIcon,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\UI\Icons\CpuUsageIcon.cs,ProviderUpdated,The following statement contains a magic number: using (Graphics g = Graphics.FromImage (b)) {  	int kl = (int)(k * height);  	int ul = (int)(u * height);  	Color kline = Settings.Instance.PlotterCPUKernelColor;  	Color kfill = Color.FromArgb (100' kline);  	Color uline = Settings.Instance.PlotterCPUUserColor;  	Color ufill = Color.FromArgb (100' uline);  	g.FillRectangle (new SolidBrush (Color.Black)' g.ClipBounds);  	if (kl + ul == 0)  		g.DrawLine (new Pen (uline)' 0' height - 1' width - 1' height - 1);  	g.FillRectangle (new SolidBrush (ufill)' 0' height - (ul + kl)' width' ul);  	g.DrawLine (new Pen (uline)' 0' height - (ul + kl) - 1' width' height - (ul + kl) - 1);  	if (kl > 0) {  		g.FillRectangle (new SolidBrush (kfill)' 0' height - kl' width' kl);  		g.DrawLine (new Pen (kline)' 0' height - kl - 1' width' height - kl - 1);  	}  }  
Magic Number,ProcessHacker,CpuUsageIcon,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\UI\Icons\CpuUsageIcon.cs,ProviderUpdated,The following statement contains a magic number: using (Graphics g = Graphics.FromImage (b)) {  	int kl = (int)(k * height);  	int ul = (int)(u * height);  	Color kline = Settings.Instance.PlotterCPUKernelColor;  	Color kfill = Color.FromArgb (100' kline);  	Color uline = Settings.Instance.PlotterCPUUserColor;  	Color ufill = Color.FromArgb (100' uline);  	g.FillRectangle (new SolidBrush (Color.Black)' g.ClipBounds);  	if (kl + ul == 0)  		g.DrawLine (new Pen (uline)' 0' height - 1' width - 1' height - 1);  	g.FillRectangle (new SolidBrush (ufill)' 0' height - (ul + kl)' width' ul);  	g.DrawLine (new Pen (uline)' 0' height - (ul + kl) - 1' width' height - (ul + kl) - 1);  	if (kl > 0) {  		g.FillRectangle (new SolidBrush (kfill)' 0' height - kl' width' kl);  		g.DrawLine (new Pen (kline)' 0' height - kl - 1' width' height - kl - 1);  	}  }  
Magic Number,ProcessHacker,CpuUsageIcon,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\UI\Icons\CpuUsageIcon.cs,ProviderUpdated,The following statement contains a magic number: if (text.Length + mostCpuProcess.Length + 1 < 64)  	text += "\n" + mostCpuProcess;  
Magic Number,ProcessHacker,UsageIcon,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\UI\Icons\UsageIcon.cs,GetSmallIconSize,The following statement contains a magic number: return new Size (Win32.GetSystemMetrics (49)' // SM_CXSMICON  Win32.GetSystemMetrics (50)// SM_CYSMICON  );  
Magic Number,ProcessHacker,UsageIcon,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\UI\Icons\UsageIcon.cs,GetSmallIconSize,The following statement contains a magic number: return new Size (Win32.GetSystemMetrics (49)' // SM_CXSMICON  Win32.GetSystemMetrics (50)// SM_CYSMICON  );  
Magic Number,ProcessHacker,IoHistoryIcon,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\UI\Icons\IoHistoryIcon.cs,IoHistoryIcon,The following statement contains a magic number: this.MinMaxValue = 128 * 1024;  
Magic Number,ProcessHacker,IoHistoryIcon,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\UI\Icons\IoHistoryIcon.cs,IoHistoryIcon,The following statement contains a magic number: this.MinMaxValue = 128 * 1024;  
Magic Number,ProcessHacker,IoHistoryIcon,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\UI\Icons\IoHistoryIcon.cs,ProviderUpdated,The following statement contains a magic number: if (this.Provider.RunCount < 2)  	return;  
Magic Number,ProcessHacker,IoHistoryIcon,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\UI\Icons\IoHistoryIcon.cs,ProviderUpdated,The following statement contains a magic number: if (this.Provider.Dictionary.ContainsKey (this.Provider.PidWithMostIoActivity)) {  	string mostIoName = this.Provider.Dictionary [this.Provider.PidWithMostIoActivity].Name;  	if (text.Length + mostIoName.Length + 1 < 64)  		// 1 char for the LF  		text += "\n" + mostIoName;  }  
Magic Number,ProcessHacker,IoHistoryIcon,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\UI\Icons\IoHistoryIcon.cs,ProviderUpdated,The following statement contains a magic number: if (text.Length + mostIoName.Length + 1 < 64)  	// 1 char for the LF  	text += "\n" + mostIoName;  
Magic Number,ProcessHacker,CpuHistoryIcon,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\UI\Icons\CpuHistoryIcon.cs,ProviderUpdated,The following statement contains a magic number: if (text.Length + mostCpuText.Length + 1 < 64)  	// 1 char for the LF  	text += "\n" + mostCpuText;  
Magic Number,ProcessHacker,ProcessToolTipProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ProcessTree\ProcessToolTipProvider.cs,GetToolTip,The following statement contains a magic number: try {  	string cmdText = (pNode.ProcessItem.CmdLine != null ? (Utils.CreateEllipsis (pNode.ProcessItem.CmdLine.Replace ("\0"' "")' 100) + "\n") : "");  	string fileText = "";  	try {  		if (pNode.ProcessItem.VersionInfo != null) {  			var info = pNode.ProcessItem.VersionInfo;  			fileText = "File:\n" + PhUtils.FormatFileInfo (info.FileName' info.FileDescription' info.CompanyName' info.FileVersion' 4);  		}  	}  	catch {  		if (pNode.ProcessItem.FileName != null)  			fileText = "File:\n    " + pNode.ProcessItem.FileName;  	}  	string runDllText = "";  	if (pNode.ProcessItem.FileName != null && pNode.ProcessItem.FileName.EndsWith ("\\rundll32.exe"' StringComparison.InvariantCultureIgnoreCase) && pNode.ProcessItem.CmdLine != null) {  		try {  			// TODO: fix crappy method  			string targetFile = pNode.ProcessItem.CmdLine.Split (new char[] {  				' '  			}' 2) [1].Split (''') [0];  			// if it doesn't specify an absolute path' assume it's in system32.  			if (!targetFile.Contains (":"))  				targetFile = Environment.SystemDirectory + "\\" + targetFile;  			FileVersionInfo info = FileVersionInfo.GetVersionInfo (targetFile);  			runDllText = "\nRunDLL target:\n    " + info.FileName + "\n    " + info.FileDescription + " " + info.FileVersion + "\n    " + info.CompanyName;  		}  		catch (Exception ex) {  			Logging.Log (ex);  		}  	}  	string dllhostText = "";  	if (pNode.ProcessItem.FileName != null && pNode.ProcessItem.FileName.EndsWith ("\\dllhost.exe"' StringComparison.InvariantCultureIgnoreCase) && pNode.ProcessItem.CmdLine != null) {  		try {  			string clsid = pNode.ProcessItem.CmdLine.ToLowerInvariant ().Split (new string[] {  				"/processid:"  			}' StringSplitOptions.None) [1].Split (' ') [0];  			using (var key = Microsoft.Win32.Registry.ClassesRoot.OpenSubKey ("CLSID\\" + clsid)) {  				using (var inprocServer32 = key.OpenSubKey ("InprocServer32")) {  					string name = key.GetValue ("") as string;  					string fileName = inprocServer32.GetValue ("") as string;  					FileVersionInfo info = FileVersionInfo.GetVersionInfo (Environment.ExpandEnvironmentVariables (fileName));  					dllhostText = "\nCOM Target:\n    " + name + " (" + clsid.ToUpper () + ")\n    " + info.FileName + "\n    " + info.FileDescription + " " + info.FileVersion + "\n    " + info.CompanyName;  				}  			}  		}  		catch (Exception ex) {  			Logging.Log (ex);  		}  	}  	string servicesText = "";  	try {  		IDictionary<int' List<string>> processServices;  		IDictionary<string' ServiceItem> services;  		if (!_tree.DumpMode) {  			processServices = Program.HackerWindow.ProcessServices;  			services = Program.ServiceProvider.Dictionary;  		}  		else {  			processServices = _tree.DumpProcessServices;  			services = _tree.DumpServices;  		}  		if (processServices.ContainsKey (pNode.Pid)) {  			foreach (string service in processServices [pNode.Pid]) {  				if (services.ContainsKey (service)) {  					if (services [service].Status.DisplayName != "")  						servicesText += "    " + service + " (" + services [service].Status.DisplayName + ")\n";  					else  						servicesText += "    " + service + "\n";  				}  				else {  					servicesText += "    " + service + "\n";  				}  			}  			servicesText = "\nServices:\n" + servicesText.TrimEnd ('\n');  		}  	}  	catch (Exception ex) {  		Logging.Log (ex);  	}  	string otherNotes = "";  	try {  		if (pNode.ProcessItem.IsPacked && pNode.ProcessItem.ImportModules > 0)  			otherNotes += "\n    Image is probably packed - has " + pNode.ProcessItem.ImportFunctions.ToString () + " imports over " + pNode.ProcessItem.ImportModules.ToString () + " modules.";  		else if (pNode.ProcessItem.IsPacked)  			otherNotes += "\n    Image is probably packed - error reading PE file.";  		if (pNode.ProcessItem.FileName != null) {  			if (pNode.ProcessItem.VerifyResult == VerifyResult.Trusted) {  				if (!string.IsNullOrEmpty (pNode.ProcessItem.VerifySignerName))  					otherNotes += "\n    Signer: " + pNode.ProcessItem.VerifySignerName;  				else  					otherNotes += "\n    Signed.";  			}  			else if (pNode.ProcessItem.VerifyResult == VerifyResult.Unknown && !Settings.Instance.VerifySignatures) {  				otherNotes += "";  			}  			else if (pNode.ProcessItem.VerifyResult == VerifyResult.Unknown && Settings.Instance.VerifySignatures && !_tree.DumpMode) {  				otherNotes += "\n    File has not been processed yet. Please wait...";  			}  			else if (pNode.ProcessItem.VerifyResult != VerifyResult.NoSignature) {  				otherNotes += "\n    Signature invalid.";  			}  			if (Program.ImposterNames.Contains (pNode.Name.ToLowerInvariant ()) && pNode.ProcessItem.VerifyResult != VerifyResult.Trusted && pNode.ProcessItem.VerifyResult != VerifyResult.Unknown)  				otherNotes += "\n    Process is using the name of a known process but its signature could not be verified.";  		}  		if (pNode.ProcessItem.IsInJob)  			otherNotes += "\n    Process is in a job.";  		if (pNode.ProcessItem.ElevationType == TokenElevationType.Full)  			otherNotes += "\n    Process is elevated.";  		if (pNode.ProcessItem.IsDotNet)  			otherNotes += "\n    Process is managed (.NET).";  		if (pNode.ProcessItem.IsPosix)  			otherNotes += "\n    Process is POSIX.";  		if (pNode.ProcessItem.IsWow64)  			otherNotes += "\n    Process is 32-bit (running under WOW64).";  		if (otherNotes != "")  			otherNotes = "\nNotes:" + otherNotes;  	}  	catch (Exception ex) {  		Logging.Log (ex);  	}  	return (cmdText + fileText + otherNotes + runDllText + dllhostText + servicesText).Trim (' '' '\n'' '\r');  }  catch (Exception ex) {  	Logging.Log (ex);  }  
Magic Number,ProcessHacker,ProcessToolTipProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ProcessTree\ProcessToolTipProvider.cs,GetToolTip,The following statement contains a magic number: try {  	string cmdText = (pNode.ProcessItem.CmdLine != null ? (Utils.CreateEllipsis (pNode.ProcessItem.CmdLine.Replace ("\0"' "")' 100) + "\n") : "");  	string fileText = "";  	try {  		if (pNode.ProcessItem.VersionInfo != null) {  			var info = pNode.ProcessItem.VersionInfo;  			fileText = "File:\n" + PhUtils.FormatFileInfo (info.FileName' info.FileDescription' info.CompanyName' info.FileVersion' 4);  		}  	}  	catch {  		if (pNode.ProcessItem.FileName != null)  			fileText = "File:\n    " + pNode.ProcessItem.FileName;  	}  	string runDllText = "";  	if (pNode.ProcessItem.FileName != null && pNode.ProcessItem.FileName.EndsWith ("\\rundll32.exe"' StringComparison.InvariantCultureIgnoreCase) && pNode.ProcessItem.CmdLine != null) {  		try {  			// TODO: fix crappy method  			string targetFile = pNode.ProcessItem.CmdLine.Split (new char[] {  				' '  			}' 2) [1].Split (''') [0];  			// if it doesn't specify an absolute path' assume it's in system32.  			if (!targetFile.Contains (":"))  				targetFile = Environment.SystemDirectory + "\\" + targetFile;  			FileVersionInfo info = FileVersionInfo.GetVersionInfo (targetFile);  			runDllText = "\nRunDLL target:\n    " + info.FileName + "\n    " + info.FileDescription + " " + info.FileVersion + "\n    " + info.CompanyName;  		}  		catch (Exception ex) {  			Logging.Log (ex);  		}  	}  	string dllhostText = "";  	if (pNode.ProcessItem.FileName != null && pNode.ProcessItem.FileName.EndsWith ("\\dllhost.exe"' StringComparison.InvariantCultureIgnoreCase) && pNode.ProcessItem.CmdLine != null) {  		try {  			string clsid = pNode.ProcessItem.CmdLine.ToLowerInvariant ().Split (new string[] {  				"/processid:"  			}' StringSplitOptions.None) [1].Split (' ') [0];  			using (var key = Microsoft.Win32.Registry.ClassesRoot.OpenSubKey ("CLSID\\" + clsid)) {  				using (var inprocServer32 = key.OpenSubKey ("InprocServer32")) {  					string name = key.GetValue ("") as string;  					string fileName = inprocServer32.GetValue ("") as string;  					FileVersionInfo info = FileVersionInfo.GetVersionInfo (Environment.ExpandEnvironmentVariables (fileName));  					dllhostText = "\nCOM Target:\n    " + name + " (" + clsid.ToUpper () + ")\n    " + info.FileName + "\n    " + info.FileDescription + " " + info.FileVersion + "\n    " + info.CompanyName;  				}  			}  		}  		catch (Exception ex) {  			Logging.Log (ex);  		}  	}  	string servicesText = "";  	try {  		IDictionary<int' List<string>> processServices;  		IDictionary<string' ServiceItem> services;  		if (!_tree.DumpMode) {  			processServices = Program.HackerWindow.ProcessServices;  			services = Program.ServiceProvider.Dictionary;  		}  		else {  			processServices = _tree.DumpProcessServices;  			services = _tree.DumpServices;  		}  		if (processServices.ContainsKey (pNode.Pid)) {  			foreach (string service in processServices [pNode.Pid]) {  				if (services.ContainsKey (service)) {  					if (services [service].Status.DisplayName != "")  						servicesText += "    " + service + " (" + services [service].Status.DisplayName + ")\n";  					else  						servicesText += "    " + service + "\n";  				}  				else {  					servicesText += "    " + service + "\n";  				}  			}  			servicesText = "\nServices:\n" + servicesText.TrimEnd ('\n');  		}  	}  	catch (Exception ex) {  		Logging.Log (ex);  	}  	string otherNotes = "";  	try {  		if (pNode.ProcessItem.IsPacked && pNode.ProcessItem.ImportModules > 0)  			otherNotes += "\n    Image is probably packed - has " + pNode.ProcessItem.ImportFunctions.ToString () + " imports over " + pNode.ProcessItem.ImportModules.ToString () + " modules.";  		else if (pNode.ProcessItem.IsPacked)  			otherNotes += "\n    Image is probably packed - error reading PE file.";  		if (pNode.ProcessItem.FileName != null) {  			if (pNode.ProcessItem.VerifyResult == VerifyResult.Trusted) {  				if (!string.IsNullOrEmpty (pNode.ProcessItem.VerifySignerName))  					otherNotes += "\n    Signer: " + pNode.ProcessItem.VerifySignerName;  				else  					otherNotes += "\n    Signed.";  			}  			else if (pNode.ProcessItem.VerifyResult == VerifyResult.Unknown && !Settings.Instance.VerifySignatures) {  				otherNotes += "";  			}  			else if (pNode.ProcessItem.VerifyResult == VerifyResult.Unknown && Settings.Instance.VerifySignatures && !_tree.DumpMode) {  				otherNotes += "\n    File has not been processed yet. Please wait...";  			}  			else if (pNode.ProcessItem.VerifyResult != VerifyResult.NoSignature) {  				otherNotes += "\n    Signature invalid.";  			}  			if (Program.ImposterNames.Contains (pNode.Name.ToLowerInvariant ()) && pNode.ProcessItem.VerifyResult != VerifyResult.Trusted && pNode.ProcessItem.VerifyResult != VerifyResult.Unknown)  				otherNotes += "\n    Process is using the name of a known process but its signature could not be verified.";  		}  		if (pNode.ProcessItem.IsInJob)  			otherNotes += "\n    Process is in a job.";  		if (pNode.ProcessItem.ElevationType == TokenElevationType.Full)  			otherNotes += "\n    Process is elevated.";  		if (pNode.ProcessItem.IsDotNet)  			otherNotes += "\n    Process is managed (.NET).";  		if (pNode.ProcessItem.IsPosix)  			otherNotes += "\n    Process is POSIX.";  		if (pNode.ProcessItem.IsWow64)  			otherNotes += "\n    Process is 32-bit (running under WOW64).";  		if (otherNotes != "")  			otherNotes = "\nNotes:" + otherNotes;  	}  	catch (Exception ex) {  		Logging.Log (ex);  	}  	return (cmdText + fileText + otherNotes + runDllText + dllhostText + servicesText).Trim (' '' '\n'' '\r');  }  catch (Exception ex) {  	Logging.Log (ex);  }  
Magic Number,ProcessHacker,ProcessToolTipProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ProcessTree\ProcessToolTipProvider.cs,GetToolTip,The following statement contains a magic number: try {  	string cmdText = (pNode.ProcessItem.CmdLine != null ? (Utils.CreateEllipsis (pNode.ProcessItem.CmdLine.Replace ("\0"' "")' 100) + "\n") : "");  	string fileText = "";  	try {  		if (pNode.ProcessItem.VersionInfo != null) {  			var info = pNode.ProcessItem.VersionInfo;  			fileText = "File:\n" + PhUtils.FormatFileInfo (info.FileName' info.FileDescription' info.CompanyName' info.FileVersion' 4);  		}  	}  	catch {  		if (pNode.ProcessItem.FileName != null)  			fileText = "File:\n    " + pNode.ProcessItem.FileName;  	}  	string runDllText = "";  	if (pNode.ProcessItem.FileName != null && pNode.ProcessItem.FileName.EndsWith ("\\rundll32.exe"' StringComparison.InvariantCultureIgnoreCase) && pNode.ProcessItem.CmdLine != null) {  		try {  			// TODO: fix crappy method  			string targetFile = pNode.ProcessItem.CmdLine.Split (new char[] {  				' '  			}' 2) [1].Split (''') [0];  			// if it doesn't specify an absolute path' assume it's in system32.  			if (!targetFile.Contains (":"))  				targetFile = Environment.SystemDirectory + "\\" + targetFile;  			FileVersionInfo info = FileVersionInfo.GetVersionInfo (targetFile);  			runDllText = "\nRunDLL target:\n    " + info.FileName + "\n    " + info.FileDescription + " " + info.FileVersion + "\n    " + info.CompanyName;  		}  		catch (Exception ex) {  			Logging.Log (ex);  		}  	}  	string dllhostText = "";  	if (pNode.ProcessItem.FileName != null && pNode.ProcessItem.FileName.EndsWith ("\\dllhost.exe"' StringComparison.InvariantCultureIgnoreCase) && pNode.ProcessItem.CmdLine != null) {  		try {  			string clsid = pNode.ProcessItem.CmdLine.ToLowerInvariant ().Split (new string[] {  				"/processid:"  			}' StringSplitOptions.None) [1].Split (' ') [0];  			using (var key = Microsoft.Win32.Registry.ClassesRoot.OpenSubKey ("CLSID\\" + clsid)) {  				using (var inprocServer32 = key.OpenSubKey ("InprocServer32")) {  					string name = key.GetValue ("") as string;  					string fileName = inprocServer32.GetValue ("") as string;  					FileVersionInfo info = FileVersionInfo.GetVersionInfo (Environment.ExpandEnvironmentVariables (fileName));  					dllhostText = "\nCOM Target:\n    " + name + " (" + clsid.ToUpper () + ")\n    " + info.FileName + "\n    " + info.FileDescription + " " + info.FileVersion + "\n    " + info.CompanyName;  				}  			}  		}  		catch (Exception ex) {  			Logging.Log (ex);  		}  	}  	string servicesText = "";  	try {  		IDictionary<int' List<string>> processServices;  		IDictionary<string' ServiceItem> services;  		if (!_tree.DumpMode) {  			processServices = Program.HackerWindow.ProcessServices;  			services = Program.ServiceProvider.Dictionary;  		}  		else {  			processServices = _tree.DumpProcessServices;  			services = _tree.DumpServices;  		}  		if (processServices.ContainsKey (pNode.Pid)) {  			foreach (string service in processServices [pNode.Pid]) {  				if (services.ContainsKey (service)) {  					if (services [service].Status.DisplayName != "")  						servicesText += "    " + service + " (" + services [service].Status.DisplayName + ")\n";  					else  						servicesText += "    " + service + "\n";  				}  				else {  					servicesText += "    " + service + "\n";  				}  			}  			servicesText = "\nServices:\n" + servicesText.TrimEnd ('\n');  		}  	}  	catch (Exception ex) {  		Logging.Log (ex);  	}  	string otherNotes = "";  	try {  		if (pNode.ProcessItem.IsPacked && pNode.ProcessItem.ImportModules > 0)  			otherNotes += "\n    Image is probably packed - has " + pNode.ProcessItem.ImportFunctions.ToString () + " imports over " + pNode.ProcessItem.ImportModules.ToString () + " modules.";  		else if (pNode.ProcessItem.IsPacked)  			otherNotes += "\n    Image is probably packed - error reading PE file.";  		if (pNode.ProcessItem.FileName != null) {  			if (pNode.ProcessItem.VerifyResult == VerifyResult.Trusted) {  				if (!string.IsNullOrEmpty (pNode.ProcessItem.VerifySignerName))  					otherNotes += "\n    Signer: " + pNode.ProcessItem.VerifySignerName;  				else  					otherNotes += "\n    Signed.";  			}  			else if (pNode.ProcessItem.VerifyResult == VerifyResult.Unknown && !Settings.Instance.VerifySignatures) {  				otherNotes += "";  			}  			else if (pNode.ProcessItem.VerifyResult == VerifyResult.Unknown && Settings.Instance.VerifySignatures && !_tree.DumpMode) {  				otherNotes += "\n    File has not been processed yet. Please wait...";  			}  			else if (pNode.ProcessItem.VerifyResult != VerifyResult.NoSignature) {  				otherNotes += "\n    Signature invalid.";  			}  			if (Program.ImposterNames.Contains (pNode.Name.ToLowerInvariant ()) && pNode.ProcessItem.VerifyResult != VerifyResult.Trusted && pNode.ProcessItem.VerifyResult != VerifyResult.Unknown)  				otherNotes += "\n    Process is using the name of a known process but its signature could not be verified.";  		}  		if (pNode.ProcessItem.IsInJob)  			otherNotes += "\n    Process is in a job.";  		if (pNode.ProcessItem.ElevationType == TokenElevationType.Full)  			otherNotes += "\n    Process is elevated.";  		if (pNode.ProcessItem.IsDotNet)  			otherNotes += "\n    Process is managed (.NET).";  		if (pNode.ProcessItem.IsPosix)  			otherNotes += "\n    Process is POSIX.";  		if (pNode.ProcessItem.IsWow64)  			otherNotes += "\n    Process is 32-bit (running under WOW64).";  		if (otherNotes != "")  			otherNotes = "\nNotes:" + otherNotes;  	}  	catch (Exception ex) {  		Logging.Log (ex);  	}  	return (cmdText + fileText + otherNotes + runDllText + dllhostText + servicesText).Trim (' '' '\n'' '\r');  }  catch (Exception ex) {  	Logging.Log (ex);  }  
Magic Number,ProcessHacker,ProcessToolTipProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ProcessTree\ProcessToolTipProvider.cs,GetToolTip,The following statement contains a magic number: try {  	if (pNode.ProcessItem.VersionInfo != null) {  		var info = pNode.ProcessItem.VersionInfo;  		fileText = "File:\n" + PhUtils.FormatFileInfo (info.FileName' info.FileDescription' info.CompanyName' info.FileVersion' 4);  	}  }  catch {  	if (pNode.ProcessItem.FileName != null)  		fileText = "File:\n    " + pNode.ProcessItem.FileName;  }  
Magic Number,ProcessHacker,ProcessToolTipProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ProcessTree\ProcessToolTipProvider.cs,GetToolTip,The following statement contains a magic number: if (pNode.ProcessItem.VersionInfo != null) {  	var info = pNode.ProcessItem.VersionInfo;  	fileText = "File:\n" + PhUtils.FormatFileInfo (info.FileName' info.FileDescription' info.CompanyName' info.FileVersion' 4);  }  
Magic Number,ProcessHacker,ProcessToolTipProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ProcessTree\ProcessToolTipProvider.cs,GetToolTip,The following statement contains a magic number: fileText = "File:\n" + PhUtils.FormatFileInfo (info.FileName' info.FileDescription' info.CompanyName' info.FileVersion' 4);  
Magic Number,ProcessHacker,ProcessToolTipProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ProcessTree\ProcessToolTipProvider.cs,GetToolTip,The following statement contains a magic number: if (pNode.ProcessItem.FileName != null && pNode.ProcessItem.FileName.EndsWith ("\\rundll32.exe"' StringComparison.InvariantCultureIgnoreCase) && pNode.ProcessItem.CmdLine != null) {  	try {  		// TODO: fix crappy method  		string targetFile = pNode.ProcessItem.CmdLine.Split (new char[] {  			' '  		}' 2) [1].Split (''') [0];  		// if it doesn't specify an absolute path' assume it's in system32.  		if (!targetFile.Contains (":"))  			targetFile = Environment.SystemDirectory + "\\" + targetFile;  		FileVersionInfo info = FileVersionInfo.GetVersionInfo (targetFile);  		runDllText = "\nRunDLL target:\n    " + info.FileName + "\n    " + info.FileDescription + " " + info.FileVersion + "\n    " + info.CompanyName;  	}  	catch (Exception ex) {  		Logging.Log (ex);  	}  }  
Magic Number,ProcessHacker,ProcessToolTipProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ProcessTree\ProcessToolTipProvider.cs,GetToolTip,The following statement contains a magic number: try {  	// TODO: fix crappy method  	string targetFile = pNode.ProcessItem.CmdLine.Split (new char[] {  		' '  	}' 2) [1].Split (''') [0];  	// if it doesn't specify an absolute path' assume it's in system32.  	if (!targetFile.Contains (":"))  		targetFile = Environment.SystemDirectory + "\\" + targetFile;  	FileVersionInfo info = FileVersionInfo.GetVersionInfo (targetFile);  	runDllText = "\nRunDLL target:\n    " + info.FileName + "\n    " + info.FileDescription + " " + info.FileVersion + "\n    " + info.CompanyName;  }  catch (Exception ex) {  	Logging.Log (ex);  }  
Magic Number,ProcessHacker,ProcessNode,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ProcessTree\ProcessNode.cs,GetWorkingSetNumber,The following statement contains a magic number: try {  	using (var phandle = new ProcessHandle (_pitem.Pid' ProcessAccess.QueryInformation | ProcessAccess.VmRead)) {  		if ((status = NProcessHacker.PhQueryProcessWs (phandle' WsInformationClass' out wsInfo' 4' out retLen)) < NtStatus.Error)  			return wsInfo * Program.ProcessProvider.System.PageSize;  	}  }  catch {  }  
Magic Number,ProcessHacker,ProcessNode,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ProcessTree\ProcessNode.cs,GetWorkingSetNumber,The following statement contains a magic number: using (var phandle = new ProcessHandle (_pitem.Pid' ProcessAccess.QueryInformation | ProcessAccess.VmRead)) {  	if ((status = NProcessHacker.PhQueryProcessWs (phandle' WsInformationClass' out wsInfo' 4' out retLen)) < NtStatus.Error)  		return wsInfo * Program.ProcessProvider.System.PageSize;  }  
Magic Number,ProcessHacker,ProcessNode,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ProcessTree\ProcessNode.cs,GetWorkingSetNumber,The following statement contains a magic number: if ((status = NProcessHacker.PhQueryProcessWs (phandle' WsInformationClass' out wsInfo' 4' out retLen)) < NtStatus.Error)  	return wsInfo * Program.ProcessProvider.System.PageSize;  
Magic Number,ProcessHacker,ProcessTree,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ProcessTree\ProcessTree.cs,ProcessTree,The following statement contains a magic number: column.MinColumnWidth = 10;  
Magic Number,ProcessHacker,ProcessTree,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ProcessTree\ProcessTree.cs,ProcessTree,The following statement contains a magic number: column = new TreeColumn ("I/O History"' 60);  
Magic Number,ProcessHacker,ProcessTree,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ProcessTree\ProcessTree.cs,ProcessTree,The following statement contains a magic number: column.MinColumnWidth = 10;  
Magic Number,ProcessHacker,ExtendedCmd,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\ExtendedCmd.cs,Run,The following statement contains a magic number: try {  	switch (type) {  	case "processhacker":  		{  			switch (action) {  			case "runas":  				{  					using (var manager = new ServiceManagerHandle (ScManagerAccess.CreateService)) {  						Random r = new Random ((int)(DateTime.Now.ToFileTime () & 0xffffffff));  						string serviceName = "";  						for (int i = 0; i < 8; i++)  							serviceName += (char)('A' + r.Next (25));  						using (var service = manager.CreateService (serviceName' serviceName + " (Process Hacker Assistant)"' ServiceType.Win32OwnProcess' ServiceStartType.DemandStart' ServiceErrorControl.Ignore' obj' ""' "LocalSystem"' null)) {  							// Create a mailslot so we can receive the error code for Assistant.  							using (var mhandle = MailslotHandle.Create (FileAccess.GenericRead' @"\Device\Mailslot\" + args ["-mailslot"]' 0' 5000)) {  								try {  									service.Start ();  								}  								catch {  								}  								service.Delete ();  								Win32Error errorCode = (Win32Error)mhandle.Read (4).ToInt32 ();  								if (errorCode != Win32Error.Success)  									throw new WindowsException (errorCode);  							}  						}  					}  				}  				break;  			default:  				throw new Exception ("Unknown action '" + action + "'");  			}  		}  		break;  	case "process":  		{  			var processes = Windows.GetProcesses ();  			string[] pidStrings = obj.Split (new char[] {  				'''  			}' StringSplitOptions.RemoveEmptyEntries);  			int[] pids = new int[pidStrings.Length];  			string[] names = new string[pidStrings.Length];  			for (int i = 0; i < pidStrings.Length; i++) {  				pids [i] = int.Parse (pidStrings [i]);  				names [i] = processes [pids [i]].Name;  			}  			switch (action) {  			case "terminate":  				ProcessActions.Terminate (window' pids' names' true);  				break;  			case "suspend":  				ProcessActions.Suspend (window' pids' names' true);  				break;  			case "resume":  				ProcessActions.Resume (window' pids' names' true);  				break;  			case "reduceworkingset":  				ProcessActions.ReduceWorkingSet (window' pids' names' false);  				break;  			default:  				throw new Exception ("Unknown action '" + action + "'");  			}  		}  		break;  	case "thread":  		{  			foreach (string tid in obj.Split (new char[] {  				'''  			}' StringSplitOptions.RemoveEmptyEntries)) {  				switch (action) {  				case "terminate":  					{  						try {  							using (var thandle = new ThreadHandle (int.Parse (tid)' ThreadAccess.Terminate))  								thandle.Terminate ();  						}  						catch (Exception ex) {  							DialogResult result = MessageBox.Show (window' "Could not terminate thread with ID " + tid + ":\n\n" + ex.Message' "Process Hacker"' MessageBoxButtons.OKCancel' MessageBoxIcon.Error);  							if (result == DialogResult.Cancel)  								return;  						}  					}  					break;  				case "suspend":  					{  						try {  							using (var thandle = new ThreadHandle (int.Parse (tid)' ThreadAccess.SuspendResume))  								thandle.Suspend ();  						}  						catch (Exception ex) {  							DialogResult result = MessageBox.Show (window' "Could not suspend thread with ID " + tid + ":\n\n" + ex.Message' "Process Hacker"' MessageBoxButtons.OKCancel' MessageBoxIcon.Error);  							if (result == DialogResult.Cancel)  								return;  						}  					}  					break;  				case "resume":  					{  						try {  							using (var thandle = new ThreadHandle (int.Parse (tid)' ThreadAccess.SuspendResume))  								thandle.Resume ();  						}  						catch (Exception ex) {  							DialogResult result = MessageBox.Show (window' "Could not resume thread with ID " + tid + ":\n\n" + ex.Message' "Process Hacker"' MessageBoxButtons.OKCancel' MessageBoxIcon.Error);  							if (result == DialogResult.Cancel)  								return;  						}  					}  					break;  				default:  					throw new Exception ("Unknown action '" + action + "'");  				}  			}  		}  		break;  	case "service":  		{  			switch (action) {  			case "start":  				{  					ServiceActions.Start (window' obj' false);  				}  				break;  			case "continue":  				{  					ServiceActions.Continue (window' obj' false);  				}  				break;  			case "pause":  				{  					ServiceActions.Pause (window' obj' false);  				}  				break;  			case "stop":  				{  					ServiceActions.Stop (window' obj' false);  				}  				break;  			case "delete":  				{  					ServiceActions.Delete (window' obj' true);  				}  				break;  			case "config":  				{  					using (ServiceHandle service = new ServiceHandle (obj' ServiceAccess.ChangeConfig)) {  						ServiceType serviceType;  						if (args ["-servicetype"] == "Win32OwnProcess' InteractiveProcess")  							serviceType = ServiceType.Win32OwnProcess | ServiceType.InteractiveProcess;  						else if (args ["-servicetype"] == "Win32ShareProcess' InteractiveProcess")  							serviceType = ServiceType.Win32ShareProcess | ServiceType.InteractiveProcess;  						else  							serviceType = (ServiceType)Enum.Parse (typeof(ServiceType)' args ["-servicetype"]);  						var startType = (ServiceStartType)Enum.Parse (typeof(ServiceStartType)' args ["-servicestarttype"]);  						var errorControl = (ServiceErrorControl)Enum.Parse (typeof(ServiceErrorControl)' args ["-serviceerrorcontrol"]);  						string binaryPath = null;  						string loadOrderGroup = null;  						string userAccount = null;  						string password = null;  						if (args.ContainsKey ("-servicebinarypath"))  							binaryPath = args ["-servicebinarypath"];  						if (args.ContainsKey ("-serviceloadordergroup"))  							loadOrderGroup = args ["-serviceloadordergroup"];  						if (args.ContainsKey ("-serviceuseraccount"))  							userAccount = args ["-serviceuseraccount"];  						if (args.ContainsKey ("-servicepassword"))  							password = args ["-servicepassword"];  						if (!Win32.ChangeServiceConfig (service' serviceType' startType' errorControl' binaryPath' loadOrderGroup' IntPtr.Zero' null' userAccount' password' null))  							Win32.Throw ();  					}  				}  				break;  			default:  				throw new Exception ("Unknown action '" + action + "'");  			}  		}  		break;  	case "session":  		{  			int sessionId = int.Parse (obj);  			switch (action) {  			case "disconnect":  				{  					SessionActions.Disconnect (window' sessionId' false);  				}  				break;  			case "logoff":  				{  					SessionActions.Logoff (window' sessionId' false);  				}  				break;  			default:  				throw new Exception ("Unknown action '" + action + "'");  			}  		}  		break;  	default:  		throw new Exception ("Unknown object type '" + type + "'");  	}  }  catch (Exception ex) {  	MessageBox.Show (window' ex.Message' "Process Hacker"' MessageBoxButtons.OK' MessageBoxIcon.Error);  }  
Magic Number,ProcessHacker,ExtendedCmd,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\ExtendedCmd.cs,Run,The following statement contains a magic number: try {  	switch (type) {  	case "processhacker":  		{  			switch (action) {  			case "runas":  				{  					using (var manager = new ServiceManagerHandle (ScManagerAccess.CreateService)) {  						Random r = new Random ((int)(DateTime.Now.ToFileTime () & 0xffffffff));  						string serviceName = "";  						for (int i = 0; i < 8; i++)  							serviceName += (char)('A' + r.Next (25));  						using (var service = manager.CreateService (serviceName' serviceName + " (Process Hacker Assistant)"' ServiceType.Win32OwnProcess' ServiceStartType.DemandStart' ServiceErrorControl.Ignore' obj' ""' "LocalSystem"' null)) {  							// Create a mailslot so we can receive the error code for Assistant.  							using (var mhandle = MailslotHandle.Create (FileAccess.GenericRead' @"\Device\Mailslot\" + args ["-mailslot"]' 0' 5000)) {  								try {  									service.Start ();  								}  								catch {  								}  								service.Delete ();  								Win32Error errorCode = (Win32Error)mhandle.Read (4).ToInt32 ();  								if (errorCode != Win32Error.Success)  									throw new WindowsException (errorCode);  							}  						}  					}  				}  				break;  			default:  				throw new Exception ("Unknown action '" + action + "'");  			}  		}  		break;  	case "process":  		{  			var processes = Windows.GetProcesses ();  			string[] pidStrings = obj.Split (new char[] {  				'''  			}' StringSplitOptions.RemoveEmptyEntries);  			int[] pids = new int[pidStrings.Length];  			string[] names = new string[pidStrings.Length];  			for (int i = 0; i < pidStrings.Length; i++) {  				pids [i] = int.Parse (pidStrings [i]);  				names [i] = processes [pids [i]].Name;  			}  			switch (action) {  			case "terminate":  				ProcessActions.Terminate (window' pids' names' true);  				break;  			case "suspend":  				ProcessActions.Suspend (window' pids' names' true);  				break;  			case "resume":  				ProcessActions.Resume (window' pids' names' true);  				break;  			case "reduceworkingset":  				ProcessActions.ReduceWorkingSet (window' pids' names' false);  				break;  			default:  				throw new Exception ("Unknown action '" + action + "'");  			}  		}  		break;  	case "thread":  		{  			foreach (string tid in obj.Split (new char[] {  				'''  			}' StringSplitOptions.RemoveEmptyEntries)) {  				switch (action) {  				case "terminate":  					{  						try {  							using (var thandle = new ThreadHandle (int.Parse (tid)' ThreadAccess.Terminate))  								thandle.Terminate ();  						}  						catch (Exception ex) {  							DialogResult result = MessageBox.Show (window' "Could not terminate thread with ID " + tid + ":\n\n" + ex.Message' "Process Hacker"' MessageBoxButtons.OKCancel' MessageBoxIcon.Error);  							if (result == DialogResult.Cancel)  								return;  						}  					}  					break;  				case "suspend":  					{  						try {  							using (var thandle = new ThreadHandle (int.Parse (tid)' ThreadAccess.SuspendResume))  								thandle.Suspend ();  						}  						catch (Exception ex) {  							DialogResult result = MessageBox.Show (window' "Could not suspend thread with ID " + tid + ":\n\n" + ex.Message' "Process Hacker"' MessageBoxButtons.OKCancel' MessageBoxIcon.Error);  							if (result == DialogResult.Cancel)  								return;  						}  					}  					break;  				case "resume":  					{  						try {  							using (var thandle = new ThreadHandle (int.Parse (tid)' ThreadAccess.SuspendResume))  								thandle.Resume ();  						}  						catch (Exception ex) {  							DialogResult result = MessageBox.Show (window' "Could not resume thread with ID " + tid + ":\n\n" + ex.Message' "Process Hacker"' MessageBoxButtons.OKCancel' MessageBoxIcon.Error);  							if (result == DialogResult.Cancel)  								return;  						}  					}  					break;  				default:  					throw new Exception ("Unknown action '" + action + "'");  				}  			}  		}  		break;  	case "service":  		{  			switch (action) {  			case "start":  				{  					ServiceActions.Start (window' obj' false);  				}  				break;  			case "continue":  				{  					ServiceActions.Continue (window' obj' false);  				}  				break;  			case "pause":  				{  					ServiceActions.Pause (window' obj' false);  				}  				break;  			case "stop":  				{  					ServiceActions.Stop (window' obj' false);  				}  				break;  			case "delete":  				{  					ServiceActions.Delete (window' obj' true);  				}  				break;  			case "config":  				{  					using (ServiceHandle service = new ServiceHandle (obj' ServiceAccess.ChangeConfig)) {  						ServiceType serviceType;  						if (args ["-servicetype"] == "Win32OwnProcess' InteractiveProcess")  							serviceType = ServiceType.Win32OwnProcess | ServiceType.InteractiveProcess;  						else if (args ["-servicetype"] == "Win32ShareProcess' InteractiveProcess")  							serviceType = ServiceType.Win32ShareProcess | ServiceType.InteractiveProcess;  						else  							serviceType = (ServiceType)Enum.Parse (typeof(ServiceType)' args ["-servicetype"]);  						var startType = (ServiceStartType)Enum.Parse (typeof(ServiceStartType)' args ["-servicestarttype"]);  						var errorControl = (ServiceErrorControl)Enum.Parse (typeof(ServiceErrorControl)' args ["-serviceerrorcontrol"]);  						string binaryPath = null;  						string loadOrderGroup = null;  						string userAccount = null;  						string password = null;  						if (args.ContainsKey ("-servicebinarypath"))  							binaryPath = args ["-servicebinarypath"];  						if (args.ContainsKey ("-serviceloadordergroup"))  							loadOrderGroup = args ["-serviceloadordergroup"];  						if (args.ContainsKey ("-serviceuseraccount"))  							userAccount = args ["-serviceuseraccount"];  						if (args.ContainsKey ("-servicepassword"))  							password = args ["-servicepassword"];  						if (!Win32.ChangeServiceConfig (service' serviceType' startType' errorControl' binaryPath' loadOrderGroup' IntPtr.Zero' null' userAccount' password' null))  							Win32.Throw ();  					}  				}  				break;  			default:  				throw new Exception ("Unknown action '" + action + "'");  			}  		}  		break;  	case "session":  		{  			int sessionId = int.Parse (obj);  			switch (action) {  			case "disconnect":  				{  					SessionActions.Disconnect (window' sessionId' false);  				}  				break;  			case "logoff":  				{  					SessionActions.Logoff (window' sessionId' false);  				}  				break;  			default:  				throw new Exception ("Unknown action '" + action + "'");  			}  		}  		break;  	default:  		throw new Exception ("Unknown object type '" + type + "'");  	}  }  catch (Exception ex) {  	MessageBox.Show (window' ex.Message' "Process Hacker"' MessageBoxButtons.OK' MessageBoxIcon.Error);  }  
Magic Number,ProcessHacker,ExtendedCmd,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\ExtendedCmd.cs,Run,The following statement contains a magic number: try {  	switch (type) {  	case "processhacker":  		{  			switch (action) {  			case "runas":  				{  					using (var manager = new ServiceManagerHandle (ScManagerAccess.CreateService)) {  						Random r = new Random ((int)(DateTime.Now.ToFileTime () & 0xffffffff));  						string serviceName = "";  						for (int i = 0; i < 8; i++)  							serviceName += (char)('A' + r.Next (25));  						using (var service = manager.CreateService (serviceName' serviceName + " (Process Hacker Assistant)"' ServiceType.Win32OwnProcess' ServiceStartType.DemandStart' ServiceErrorControl.Ignore' obj' ""' "LocalSystem"' null)) {  							// Create a mailslot so we can receive the error code for Assistant.  							using (var mhandle = MailslotHandle.Create (FileAccess.GenericRead' @"\Device\Mailslot\" + args ["-mailslot"]' 0' 5000)) {  								try {  									service.Start ();  								}  								catch {  								}  								service.Delete ();  								Win32Error errorCode = (Win32Error)mhandle.Read (4).ToInt32 ();  								if (errorCode != Win32Error.Success)  									throw new WindowsException (errorCode);  							}  						}  					}  				}  				break;  			default:  				throw new Exception ("Unknown action '" + action + "'");  			}  		}  		break;  	case "process":  		{  			var processes = Windows.GetProcesses ();  			string[] pidStrings = obj.Split (new char[] {  				'''  			}' StringSplitOptions.RemoveEmptyEntries);  			int[] pids = new int[pidStrings.Length];  			string[] names = new string[pidStrings.Length];  			for (int i = 0; i < pidStrings.Length; i++) {  				pids [i] = int.Parse (pidStrings [i]);  				names [i] = processes [pids [i]].Name;  			}  			switch (action) {  			case "terminate":  				ProcessActions.Terminate (window' pids' names' true);  				break;  			case "suspend":  				ProcessActions.Suspend (window' pids' names' true);  				break;  			case "resume":  				ProcessActions.Resume (window' pids' names' true);  				break;  			case "reduceworkingset":  				ProcessActions.ReduceWorkingSet (window' pids' names' false);  				break;  			default:  				throw new Exception ("Unknown action '" + action + "'");  			}  		}  		break;  	case "thread":  		{  			foreach (string tid in obj.Split (new char[] {  				'''  			}' StringSplitOptions.RemoveEmptyEntries)) {  				switch (action) {  				case "terminate":  					{  						try {  							using (var thandle = new ThreadHandle (int.Parse (tid)' ThreadAccess.Terminate))  								thandle.Terminate ();  						}  						catch (Exception ex) {  							DialogResult result = MessageBox.Show (window' "Could not terminate thread with ID " + tid + ":\n\n" + ex.Message' "Process Hacker"' MessageBoxButtons.OKCancel' MessageBoxIcon.Error);  							if (result == DialogResult.Cancel)  								return;  						}  					}  					break;  				case "suspend":  					{  						try {  							using (var thandle = new ThreadHandle (int.Parse (tid)' ThreadAccess.SuspendResume))  								thandle.Suspend ();  						}  						catch (Exception ex) {  							DialogResult result = MessageBox.Show (window' "Could not suspend thread with ID " + tid + ":\n\n" + ex.Message' "Process Hacker"' MessageBoxButtons.OKCancel' MessageBoxIcon.Error);  							if (result == DialogResult.Cancel)  								return;  						}  					}  					break;  				case "resume":  					{  						try {  							using (var thandle = new ThreadHandle (int.Parse (tid)' ThreadAccess.SuspendResume))  								thandle.Resume ();  						}  						catch (Exception ex) {  							DialogResult result = MessageBox.Show (window' "Could not resume thread with ID " + tid + ":\n\n" + ex.Message' "Process Hacker"' MessageBoxButtons.OKCancel' MessageBoxIcon.Error);  							if (result == DialogResult.Cancel)  								return;  						}  					}  					break;  				default:  					throw new Exception ("Unknown action '" + action + "'");  				}  			}  		}  		break;  	case "service":  		{  			switch (action) {  			case "start":  				{  					ServiceActions.Start (window' obj' false);  				}  				break;  			case "continue":  				{  					ServiceActions.Continue (window' obj' false);  				}  				break;  			case "pause":  				{  					ServiceActions.Pause (window' obj' false);  				}  				break;  			case "stop":  				{  					ServiceActions.Stop (window' obj' false);  				}  				break;  			case "delete":  				{  					ServiceActions.Delete (window' obj' true);  				}  				break;  			case "config":  				{  					using (ServiceHandle service = new ServiceHandle (obj' ServiceAccess.ChangeConfig)) {  						ServiceType serviceType;  						if (args ["-servicetype"] == "Win32OwnProcess' InteractiveProcess")  							serviceType = ServiceType.Win32OwnProcess | ServiceType.InteractiveProcess;  						else if (args ["-servicetype"] == "Win32ShareProcess' InteractiveProcess")  							serviceType = ServiceType.Win32ShareProcess | ServiceType.InteractiveProcess;  						else  							serviceType = (ServiceType)Enum.Parse (typeof(ServiceType)' args ["-servicetype"]);  						var startType = (ServiceStartType)Enum.Parse (typeof(ServiceStartType)' args ["-servicestarttype"]);  						var errorControl = (ServiceErrorControl)Enum.Parse (typeof(ServiceErrorControl)' args ["-serviceerrorcontrol"]);  						string binaryPath = null;  						string loadOrderGroup = null;  						string userAccount = null;  						string password = null;  						if (args.ContainsKey ("-servicebinarypath"))  							binaryPath = args ["-servicebinarypath"];  						if (args.ContainsKey ("-serviceloadordergroup"))  							loadOrderGroup = args ["-serviceloadordergroup"];  						if (args.ContainsKey ("-serviceuseraccount"))  							userAccount = args ["-serviceuseraccount"];  						if (args.ContainsKey ("-servicepassword"))  							password = args ["-servicepassword"];  						if (!Win32.ChangeServiceConfig (service' serviceType' startType' errorControl' binaryPath' loadOrderGroup' IntPtr.Zero' null' userAccount' password' null))  							Win32.Throw ();  					}  				}  				break;  			default:  				throw new Exception ("Unknown action '" + action + "'");  			}  		}  		break;  	case "session":  		{  			int sessionId = int.Parse (obj);  			switch (action) {  			case "disconnect":  				{  					SessionActions.Disconnect (window' sessionId' false);  				}  				break;  			case "logoff":  				{  					SessionActions.Logoff (window' sessionId' false);  				}  				break;  			default:  				throw new Exception ("Unknown action '" + action + "'");  			}  		}  		break;  	default:  		throw new Exception ("Unknown object type '" + type + "'");  	}  }  catch (Exception ex) {  	MessageBox.Show (window' ex.Message' "Process Hacker"' MessageBoxButtons.OK' MessageBoxIcon.Error);  }  
Magic Number,ProcessHacker,ExtendedCmd,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\ExtendedCmd.cs,Run,The following statement contains a magic number: try {  	switch (type) {  	case "processhacker":  		{  			switch (action) {  			case "runas":  				{  					using (var manager = new ServiceManagerHandle (ScManagerAccess.CreateService)) {  						Random r = new Random ((int)(DateTime.Now.ToFileTime () & 0xffffffff));  						string serviceName = "";  						for (int i = 0; i < 8; i++)  							serviceName += (char)('A' + r.Next (25));  						using (var service = manager.CreateService (serviceName' serviceName + " (Process Hacker Assistant)"' ServiceType.Win32OwnProcess' ServiceStartType.DemandStart' ServiceErrorControl.Ignore' obj' ""' "LocalSystem"' null)) {  							// Create a mailslot so we can receive the error code for Assistant.  							using (var mhandle = MailslotHandle.Create (FileAccess.GenericRead' @"\Device\Mailslot\" + args ["-mailslot"]' 0' 5000)) {  								try {  									service.Start ();  								}  								catch {  								}  								service.Delete ();  								Win32Error errorCode = (Win32Error)mhandle.Read (4).ToInt32 ();  								if (errorCode != Win32Error.Success)  									throw new WindowsException (errorCode);  							}  						}  					}  				}  				break;  			default:  				throw new Exception ("Unknown action '" + action + "'");  			}  		}  		break;  	case "process":  		{  			var processes = Windows.GetProcesses ();  			string[] pidStrings = obj.Split (new char[] {  				'''  			}' StringSplitOptions.RemoveEmptyEntries);  			int[] pids = new int[pidStrings.Length];  			string[] names = new string[pidStrings.Length];  			for (int i = 0; i < pidStrings.Length; i++) {  				pids [i] = int.Parse (pidStrings [i]);  				names [i] = processes [pids [i]].Name;  			}  			switch (action) {  			case "terminate":  				ProcessActions.Terminate (window' pids' names' true);  				break;  			case "suspend":  				ProcessActions.Suspend (window' pids' names' true);  				break;  			case "resume":  				ProcessActions.Resume (window' pids' names' true);  				break;  			case "reduceworkingset":  				ProcessActions.ReduceWorkingSet (window' pids' names' false);  				break;  			default:  				throw new Exception ("Unknown action '" + action + "'");  			}  		}  		break;  	case "thread":  		{  			foreach (string tid in obj.Split (new char[] {  				'''  			}' StringSplitOptions.RemoveEmptyEntries)) {  				switch (action) {  				case "terminate":  					{  						try {  							using (var thandle = new ThreadHandle (int.Parse (tid)' ThreadAccess.Terminate))  								thandle.Terminate ();  						}  						catch (Exception ex) {  							DialogResult result = MessageBox.Show (window' "Could not terminate thread with ID " + tid + ":\n\n" + ex.Message' "Process Hacker"' MessageBoxButtons.OKCancel' MessageBoxIcon.Error);  							if (result == DialogResult.Cancel)  								return;  						}  					}  					break;  				case "suspend":  					{  						try {  							using (var thandle = new ThreadHandle (int.Parse (tid)' ThreadAccess.SuspendResume))  								thandle.Suspend ();  						}  						catch (Exception ex) {  							DialogResult result = MessageBox.Show (window' "Could not suspend thread with ID " + tid + ":\n\n" + ex.Message' "Process Hacker"' MessageBoxButtons.OKCancel' MessageBoxIcon.Error);  							if (result == DialogResult.Cancel)  								return;  						}  					}  					break;  				case "resume":  					{  						try {  							using (var thandle = new ThreadHandle (int.Parse (tid)' ThreadAccess.SuspendResume))  								thandle.Resume ();  						}  						catch (Exception ex) {  							DialogResult result = MessageBox.Show (window' "Could not resume thread with ID " + tid + ":\n\n" + ex.Message' "Process Hacker"' MessageBoxButtons.OKCancel' MessageBoxIcon.Error);  							if (result == DialogResult.Cancel)  								return;  						}  					}  					break;  				default:  					throw new Exception ("Unknown action '" + action + "'");  				}  			}  		}  		break;  	case "service":  		{  			switch (action) {  			case "start":  				{  					ServiceActions.Start (window' obj' false);  				}  				break;  			case "continue":  				{  					ServiceActions.Continue (window' obj' false);  				}  				break;  			case "pause":  				{  					ServiceActions.Pause (window' obj' false);  				}  				break;  			case "stop":  				{  					ServiceActions.Stop (window' obj' false);  				}  				break;  			case "delete":  				{  					ServiceActions.Delete (window' obj' true);  				}  				break;  			case "config":  				{  					using (ServiceHandle service = new ServiceHandle (obj' ServiceAccess.ChangeConfig)) {  						ServiceType serviceType;  						if (args ["-servicetype"] == "Win32OwnProcess' InteractiveProcess")  							serviceType = ServiceType.Win32OwnProcess | ServiceType.InteractiveProcess;  						else if (args ["-servicetype"] == "Win32ShareProcess' InteractiveProcess")  							serviceType = ServiceType.Win32ShareProcess | ServiceType.InteractiveProcess;  						else  							serviceType = (ServiceType)Enum.Parse (typeof(ServiceType)' args ["-servicetype"]);  						var startType = (ServiceStartType)Enum.Parse (typeof(ServiceStartType)' args ["-servicestarttype"]);  						var errorControl = (ServiceErrorControl)Enum.Parse (typeof(ServiceErrorControl)' args ["-serviceerrorcontrol"]);  						string binaryPath = null;  						string loadOrderGroup = null;  						string userAccount = null;  						string password = null;  						if (args.ContainsKey ("-servicebinarypath"))  							binaryPath = args ["-servicebinarypath"];  						if (args.ContainsKey ("-serviceloadordergroup"))  							loadOrderGroup = args ["-serviceloadordergroup"];  						if (args.ContainsKey ("-serviceuseraccount"))  							userAccount = args ["-serviceuseraccount"];  						if (args.ContainsKey ("-servicepassword"))  							password = args ["-servicepassword"];  						if (!Win32.ChangeServiceConfig (service' serviceType' startType' errorControl' binaryPath' loadOrderGroup' IntPtr.Zero' null' userAccount' password' null))  							Win32.Throw ();  					}  				}  				break;  			default:  				throw new Exception ("Unknown action '" + action + "'");  			}  		}  		break;  	case "session":  		{  			int sessionId = int.Parse (obj);  			switch (action) {  			case "disconnect":  				{  					SessionActions.Disconnect (window' sessionId' false);  				}  				break;  			case "logoff":  				{  					SessionActions.Logoff (window' sessionId' false);  				}  				break;  			default:  				throw new Exception ("Unknown action '" + action + "'");  			}  		}  		break;  	default:  		throw new Exception ("Unknown object type '" + type + "'");  	}  }  catch (Exception ex) {  	MessageBox.Show (window' ex.Message' "Process Hacker"' MessageBoxButtons.OK' MessageBoxIcon.Error);  }  
Magic Number,ProcessHacker,ExtendedCmd,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\ExtendedCmd.cs,Run,The following statement contains a magic number: switch (type) {  case "processhacker":  	{  		switch (action) {  		case "runas":  			{  				using (var manager = new ServiceManagerHandle (ScManagerAccess.CreateService)) {  					Random r = new Random ((int)(DateTime.Now.ToFileTime () & 0xffffffff));  					string serviceName = "";  					for (int i = 0; i < 8; i++)  						serviceName += (char)('A' + r.Next (25));  					using (var service = manager.CreateService (serviceName' serviceName + " (Process Hacker Assistant)"' ServiceType.Win32OwnProcess' ServiceStartType.DemandStart' ServiceErrorControl.Ignore' obj' ""' "LocalSystem"' null)) {  						// Create a mailslot so we can receive the error code for Assistant.  						using (var mhandle = MailslotHandle.Create (FileAccess.GenericRead' @"\Device\Mailslot\" + args ["-mailslot"]' 0' 5000)) {  							try {  								service.Start ();  							}  							catch {  							}  							service.Delete ();  							Win32Error errorCode = (Win32Error)mhandle.Read (4).ToInt32 ();  							if (errorCode != Win32Error.Success)  								throw new WindowsException (errorCode);  						}  					}  				}  			}  			break;  		default:  			throw new Exception ("Unknown action '" + action + "'");  		}  	}  	break;  case "process":  	{  		var processes = Windows.GetProcesses ();  		string[] pidStrings = obj.Split (new char[] {  			'''  		}' StringSplitOptions.RemoveEmptyEntries);  		int[] pids = new int[pidStrings.Length];  		string[] names = new string[pidStrings.Length];  		for (int i = 0; i < pidStrings.Length; i++) {  			pids [i] = int.Parse (pidStrings [i]);  			names [i] = processes [pids [i]].Name;  		}  		switch (action) {  		case "terminate":  			ProcessActions.Terminate (window' pids' names' true);  			break;  		case "suspend":  			ProcessActions.Suspend (window' pids' names' true);  			break;  		case "resume":  			ProcessActions.Resume (window' pids' names' true);  			break;  		case "reduceworkingset":  			ProcessActions.ReduceWorkingSet (window' pids' names' false);  			break;  		default:  			throw new Exception ("Unknown action '" + action + "'");  		}  	}  	break;  case "thread":  	{  		foreach (string tid in obj.Split (new char[] {  			'''  		}' StringSplitOptions.RemoveEmptyEntries)) {  			switch (action) {  			case "terminate":  				{  					try {  						using (var thandle = new ThreadHandle (int.Parse (tid)' ThreadAccess.Terminate))  							thandle.Terminate ();  					}  					catch (Exception ex) {  						DialogResult result = MessageBox.Show (window' "Could not terminate thread with ID " + tid + ":\n\n" + ex.Message' "Process Hacker"' MessageBoxButtons.OKCancel' MessageBoxIcon.Error);  						if (result == DialogResult.Cancel)  							return;  					}  				}  				break;  			case "suspend":  				{  					try {  						using (var thandle = new ThreadHandle (int.Parse (tid)' ThreadAccess.SuspendResume))  							thandle.Suspend ();  					}  					catch (Exception ex) {  						DialogResult result = MessageBox.Show (window' "Could not suspend thread with ID " + tid + ":\n\n" + ex.Message' "Process Hacker"' MessageBoxButtons.OKCancel' MessageBoxIcon.Error);  						if (result == DialogResult.Cancel)  							return;  					}  				}  				break;  			case "resume":  				{  					try {  						using (var thandle = new ThreadHandle (int.Parse (tid)' ThreadAccess.SuspendResume))  							thandle.Resume ();  					}  					catch (Exception ex) {  						DialogResult result = MessageBox.Show (window' "Could not resume thread with ID " + tid + ":\n\n" + ex.Message' "Process Hacker"' MessageBoxButtons.OKCancel' MessageBoxIcon.Error);  						if (result == DialogResult.Cancel)  							return;  					}  				}  				break;  			default:  				throw new Exception ("Unknown action '" + action + "'");  			}  		}  	}  	break;  case "service":  	{  		switch (action) {  		case "start":  			{  				ServiceActions.Start (window' obj' false);  			}  			break;  		case "continue":  			{  				ServiceActions.Continue (window' obj' false);  			}  			break;  		case "pause":  			{  				ServiceActions.Pause (window' obj' false);  			}  			break;  		case "stop":  			{  				ServiceActions.Stop (window' obj' false);  			}  			break;  		case "delete":  			{  				ServiceActions.Delete (window' obj' true);  			}  			break;  		case "config":  			{  				using (ServiceHandle service = new ServiceHandle (obj' ServiceAccess.ChangeConfig)) {  					ServiceType serviceType;  					if (args ["-servicetype"] == "Win32OwnProcess' InteractiveProcess")  						serviceType = ServiceType.Win32OwnProcess | ServiceType.InteractiveProcess;  					else if (args ["-servicetype"] == "Win32ShareProcess' InteractiveProcess")  						serviceType = ServiceType.Win32ShareProcess | ServiceType.InteractiveProcess;  					else  						serviceType = (ServiceType)Enum.Parse (typeof(ServiceType)' args ["-servicetype"]);  					var startType = (ServiceStartType)Enum.Parse (typeof(ServiceStartType)' args ["-servicestarttype"]);  					var errorControl = (ServiceErrorControl)Enum.Parse (typeof(ServiceErrorControl)' args ["-serviceerrorcontrol"]);  					string binaryPath = null;  					string loadOrderGroup = null;  					string userAccount = null;  					string password = null;  					if (args.ContainsKey ("-servicebinarypath"))  						binaryPath = args ["-servicebinarypath"];  					if (args.ContainsKey ("-serviceloadordergroup"))  						loadOrderGroup = args ["-serviceloadordergroup"];  					if (args.ContainsKey ("-serviceuseraccount"))  						userAccount = args ["-serviceuseraccount"];  					if (args.ContainsKey ("-servicepassword"))  						password = args ["-servicepassword"];  					if (!Win32.ChangeServiceConfig (service' serviceType' startType' errorControl' binaryPath' loadOrderGroup' IntPtr.Zero' null' userAccount' password' null))  						Win32.Throw ();  				}  			}  			break;  		default:  			throw new Exception ("Unknown action '" + action + "'");  		}  	}  	break;  case "session":  	{  		int sessionId = int.Parse (obj);  		switch (action) {  		case "disconnect":  			{  				SessionActions.Disconnect (window' sessionId' false);  			}  			break;  		case "logoff":  			{  				SessionActions.Logoff (window' sessionId' false);  			}  			break;  		default:  			throw new Exception ("Unknown action '" + action + "'");  		}  	}  	break;  default:  	throw new Exception ("Unknown object type '" + type + "'");  }  
Magic Number,ProcessHacker,ExtendedCmd,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\ExtendedCmd.cs,Run,The following statement contains a magic number: switch (type) {  case "processhacker":  	{  		switch (action) {  		case "runas":  			{  				using (var manager = new ServiceManagerHandle (ScManagerAccess.CreateService)) {  					Random r = new Random ((int)(DateTime.Now.ToFileTime () & 0xffffffff));  					string serviceName = "";  					for (int i = 0; i < 8; i++)  						serviceName += (char)('A' + r.Next (25));  					using (var service = manager.CreateService (serviceName' serviceName + " (Process Hacker Assistant)"' ServiceType.Win32OwnProcess' ServiceStartType.DemandStart' ServiceErrorControl.Ignore' obj' ""' "LocalSystem"' null)) {  						// Create a mailslot so we can receive the error code for Assistant.  						using (var mhandle = MailslotHandle.Create (FileAccess.GenericRead' @"\Device\Mailslot\" + args ["-mailslot"]' 0' 5000)) {  							try {  								service.Start ();  							}  							catch {  							}  							service.Delete ();  							Win32Error errorCode = (Win32Error)mhandle.Read (4).ToInt32 ();  							if (errorCode != Win32Error.Success)  								throw new WindowsException (errorCode);  						}  					}  				}  			}  			break;  		default:  			throw new Exception ("Unknown action '" + action + "'");  		}  	}  	break;  case "process":  	{  		var processes = Windows.GetProcesses ();  		string[] pidStrings = obj.Split (new char[] {  			'''  		}' StringSplitOptions.RemoveEmptyEntries);  		int[] pids = new int[pidStrings.Length];  		string[] names = new string[pidStrings.Length];  		for (int i = 0; i < pidStrings.Length; i++) {  			pids [i] = int.Parse (pidStrings [i]);  			names [i] = processes [pids [i]].Name;  		}  		switch (action) {  		case "terminate":  			ProcessActions.Terminate (window' pids' names' true);  			break;  		case "suspend":  			ProcessActions.Suspend (window' pids' names' true);  			break;  		case "resume":  			ProcessActions.Resume (window' pids' names' true);  			break;  		case "reduceworkingset":  			ProcessActions.ReduceWorkingSet (window' pids' names' false);  			break;  		default:  			throw new Exception ("Unknown action '" + action + "'");  		}  	}  	break;  case "thread":  	{  		foreach (string tid in obj.Split (new char[] {  			'''  		}' StringSplitOptions.RemoveEmptyEntries)) {  			switch (action) {  			case "terminate":  				{  					try {  						using (var thandle = new ThreadHandle (int.Parse (tid)' ThreadAccess.Terminate))  							thandle.Terminate ();  					}  					catch (Exception ex) {  						DialogResult result = MessageBox.Show (window' "Could not terminate thread with ID " + tid + ":\n\n" + ex.Message' "Process Hacker"' MessageBoxButtons.OKCancel' MessageBoxIcon.Error);  						if (result == DialogResult.Cancel)  							return;  					}  				}  				break;  			case "suspend":  				{  					try {  						using (var thandle = new ThreadHandle (int.Parse (tid)' ThreadAccess.SuspendResume))  							thandle.Suspend ();  					}  					catch (Exception ex) {  						DialogResult result = MessageBox.Show (window' "Could not suspend thread with ID " + tid + ":\n\n" + ex.Message' "Process Hacker"' MessageBoxButtons.OKCancel' MessageBoxIcon.Error);  						if (result == DialogResult.Cancel)  							return;  					}  				}  				break;  			case "resume":  				{  					try {  						using (var thandle = new ThreadHandle (int.Parse (tid)' ThreadAccess.SuspendResume))  							thandle.Resume ();  					}  					catch (Exception ex) {  						DialogResult result = MessageBox.Show (window' "Could not resume thread with ID " + tid + ":\n\n" + ex.Message' "Process Hacker"' MessageBoxButtons.OKCancel' MessageBoxIcon.Error);  						if (result == DialogResult.Cancel)  							return;  					}  				}  				break;  			default:  				throw new Exception ("Unknown action '" + action + "'");  			}  		}  	}  	break;  case "service":  	{  		switch (action) {  		case "start":  			{  				ServiceActions.Start (window' obj' false);  			}  			break;  		case "continue":  			{  				ServiceActions.Continue (window' obj' false);  			}  			break;  		case "pause":  			{  				ServiceActions.Pause (window' obj' false);  			}  			break;  		case "stop":  			{  				ServiceActions.Stop (window' obj' false);  			}  			break;  		case "delete":  			{  				ServiceActions.Delete (window' obj' true);  			}  			break;  		case "config":  			{  				using (ServiceHandle service = new ServiceHandle (obj' ServiceAccess.ChangeConfig)) {  					ServiceType serviceType;  					if (args ["-servicetype"] == "Win32OwnProcess' InteractiveProcess")  						serviceType = ServiceType.Win32OwnProcess | ServiceType.InteractiveProcess;  					else if (args ["-servicetype"] == "Win32ShareProcess' InteractiveProcess")  						serviceType = ServiceType.Win32ShareProcess | ServiceType.InteractiveProcess;  					else  						serviceType = (ServiceType)Enum.Parse (typeof(ServiceType)' args ["-servicetype"]);  					var startType = (ServiceStartType)Enum.Parse (typeof(ServiceStartType)' args ["-servicestarttype"]);  					var errorControl = (ServiceErrorControl)Enum.Parse (typeof(ServiceErrorControl)' args ["-serviceerrorcontrol"]);  					string binaryPath = null;  					string loadOrderGroup = null;  					string userAccount = null;  					string password = null;  					if (args.ContainsKey ("-servicebinarypath"))  						binaryPath = args ["-servicebinarypath"];  					if (args.ContainsKey ("-serviceloadordergroup"))  						loadOrderGroup = args ["-serviceloadordergroup"];  					if (args.ContainsKey ("-serviceuseraccount"))  						userAccount = args ["-serviceuseraccount"];  					if (args.ContainsKey ("-servicepassword"))  						password = args ["-servicepassword"];  					if (!Win32.ChangeServiceConfig (service' serviceType' startType' errorControl' binaryPath' loadOrderGroup' IntPtr.Zero' null' userAccount' password' null))  						Win32.Throw ();  				}  			}  			break;  		default:  			throw new Exception ("Unknown action '" + action + "'");  		}  	}  	break;  case "session":  	{  		int sessionId = int.Parse (obj);  		switch (action) {  		case "disconnect":  			{  				SessionActions.Disconnect (window' sessionId' false);  			}  			break;  		case "logoff":  			{  				SessionActions.Logoff (window' sessionId' false);  			}  			break;  		default:  			throw new Exception ("Unknown action '" + action + "'");  		}  	}  	break;  default:  	throw new Exception ("Unknown object type '" + type + "'");  }  
Magic Number,ProcessHacker,ExtendedCmd,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\ExtendedCmd.cs,Run,The following statement contains a magic number: switch (type) {  case "processhacker":  	{  		switch (action) {  		case "runas":  			{  				using (var manager = new ServiceManagerHandle (ScManagerAccess.CreateService)) {  					Random r = new Random ((int)(DateTime.Now.ToFileTime () & 0xffffffff));  					string serviceName = "";  					for (int i = 0; i < 8; i++)  						serviceName += (char)('A' + r.Next (25));  					using (var service = manager.CreateService (serviceName' serviceName + " (Process Hacker Assistant)"' ServiceType.Win32OwnProcess' ServiceStartType.DemandStart' ServiceErrorControl.Ignore' obj' ""' "LocalSystem"' null)) {  						// Create a mailslot so we can receive the error code for Assistant.  						using (var mhandle = MailslotHandle.Create (FileAccess.GenericRead' @"\Device\Mailslot\" + args ["-mailslot"]' 0' 5000)) {  							try {  								service.Start ();  							}  							catch {  							}  							service.Delete ();  							Win32Error errorCode = (Win32Error)mhandle.Read (4).ToInt32 ();  							if (errorCode != Win32Error.Success)  								throw new WindowsException (errorCode);  						}  					}  				}  			}  			break;  		default:  			throw new Exception ("Unknown action '" + action + "'");  		}  	}  	break;  case "process":  	{  		var processes = Windows.GetProcesses ();  		string[] pidStrings = obj.Split (new char[] {  			'''  		}' StringSplitOptions.RemoveEmptyEntries);  		int[] pids = new int[pidStrings.Length];  		string[] names = new string[pidStrings.Length];  		for (int i = 0; i < pidStrings.Length; i++) {  			pids [i] = int.Parse (pidStrings [i]);  			names [i] = processes [pids [i]].Name;  		}  		switch (action) {  		case "terminate":  			ProcessActions.Terminate (window' pids' names' true);  			break;  		case "suspend":  			ProcessActions.Suspend (window' pids' names' true);  			break;  		case "resume":  			ProcessActions.Resume (window' pids' names' true);  			break;  		case "reduceworkingset":  			ProcessActions.ReduceWorkingSet (window' pids' names' false);  			break;  		default:  			throw new Exception ("Unknown action '" + action + "'");  		}  	}  	break;  case "thread":  	{  		foreach (string tid in obj.Split (new char[] {  			'''  		}' StringSplitOptions.RemoveEmptyEntries)) {  			switch (action) {  			case "terminate":  				{  					try {  						using (var thandle = new ThreadHandle (int.Parse (tid)' ThreadAccess.Terminate))  							thandle.Terminate ();  					}  					catch (Exception ex) {  						DialogResult result = MessageBox.Show (window' "Could not terminate thread with ID " + tid + ":\n\n" + ex.Message' "Process Hacker"' MessageBoxButtons.OKCancel' MessageBoxIcon.Error);  						if (result == DialogResult.Cancel)  							return;  					}  				}  				break;  			case "suspend":  				{  					try {  						using (var thandle = new ThreadHandle (int.Parse (tid)' ThreadAccess.SuspendResume))  							thandle.Suspend ();  					}  					catch (Exception ex) {  						DialogResult result = MessageBox.Show (window' "Could not suspend thread with ID " + tid + ":\n\n" + ex.Message' "Process Hacker"' MessageBoxButtons.OKCancel' MessageBoxIcon.Error);  						if (result == DialogResult.Cancel)  							return;  					}  				}  				break;  			case "resume":  				{  					try {  						using (var thandle = new ThreadHandle (int.Parse (tid)' ThreadAccess.SuspendResume))  							thandle.Resume ();  					}  					catch (Exception ex) {  						DialogResult result = MessageBox.Show (window' "Could not resume thread with ID " + tid + ":\n\n" + ex.Message' "Process Hacker"' MessageBoxButtons.OKCancel' MessageBoxIcon.Error);  						if (result == DialogResult.Cancel)  							return;  					}  				}  				break;  			default:  				throw new Exception ("Unknown action '" + action + "'");  			}  		}  	}  	break;  case "service":  	{  		switch (action) {  		case "start":  			{  				ServiceActions.Start (window' obj' false);  			}  			break;  		case "continue":  			{  				ServiceActions.Continue (window' obj' false);  			}  			break;  		case "pause":  			{  				ServiceActions.Pause (window' obj' false);  			}  			break;  		case "stop":  			{  				ServiceActions.Stop (window' obj' false);  			}  			break;  		case "delete":  			{  				ServiceActions.Delete (window' obj' true);  			}  			break;  		case "config":  			{  				using (ServiceHandle service = new ServiceHandle (obj' ServiceAccess.ChangeConfig)) {  					ServiceType serviceType;  					if (args ["-servicetype"] == "Win32OwnProcess' InteractiveProcess")  						serviceType = ServiceType.Win32OwnProcess | ServiceType.InteractiveProcess;  					else if (args ["-servicetype"] == "Win32ShareProcess' InteractiveProcess")  						serviceType = ServiceType.Win32ShareProcess | ServiceType.InteractiveProcess;  					else  						serviceType = (ServiceType)Enum.Parse (typeof(ServiceType)' args ["-servicetype"]);  					var startType = (ServiceStartType)Enum.Parse (typeof(ServiceStartType)' args ["-servicestarttype"]);  					var errorControl = (ServiceErrorControl)Enum.Parse (typeof(ServiceErrorControl)' args ["-serviceerrorcontrol"]);  					string binaryPath = null;  					string loadOrderGroup = null;  					string userAccount = null;  					string password = null;  					if (args.ContainsKey ("-servicebinarypath"))  						binaryPath = args ["-servicebinarypath"];  					if (args.ContainsKey ("-serviceloadordergroup"))  						loadOrderGroup = args ["-serviceloadordergroup"];  					if (args.ContainsKey ("-serviceuseraccount"))  						userAccount = args ["-serviceuseraccount"];  					if (args.ContainsKey ("-servicepassword"))  						password = args ["-servicepassword"];  					if (!Win32.ChangeServiceConfig (service' serviceType' startType' errorControl' binaryPath' loadOrderGroup' IntPtr.Zero' null' userAccount' password' null))  						Win32.Throw ();  				}  			}  			break;  		default:  			throw new Exception ("Unknown action '" + action + "'");  		}  	}  	break;  case "session":  	{  		int sessionId = int.Parse (obj);  		switch (action) {  		case "disconnect":  			{  				SessionActions.Disconnect (window' sessionId' false);  			}  			break;  		case "logoff":  			{  				SessionActions.Logoff (window' sessionId' false);  			}  			break;  		default:  			throw new Exception ("Unknown action '" + action + "'");  		}  	}  	break;  default:  	throw new Exception ("Unknown object type '" + type + "'");  }  
Magic Number,ProcessHacker,ExtendedCmd,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\ExtendedCmd.cs,Run,The following statement contains a magic number: switch (type) {  case "processhacker":  	{  		switch (action) {  		case "runas":  			{  				using (var manager = new ServiceManagerHandle (ScManagerAccess.CreateService)) {  					Random r = new Random ((int)(DateTime.Now.ToFileTime () & 0xffffffff));  					string serviceName = "";  					for (int i = 0; i < 8; i++)  						serviceName += (char)('A' + r.Next (25));  					using (var service = manager.CreateService (serviceName' serviceName + " (Process Hacker Assistant)"' ServiceType.Win32OwnProcess' ServiceStartType.DemandStart' ServiceErrorControl.Ignore' obj' ""' "LocalSystem"' null)) {  						// Create a mailslot so we can receive the error code for Assistant.  						using (var mhandle = MailslotHandle.Create (FileAccess.GenericRead' @"\Device\Mailslot\" + args ["-mailslot"]' 0' 5000)) {  							try {  								service.Start ();  							}  							catch {  							}  							service.Delete ();  							Win32Error errorCode = (Win32Error)mhandle.Read (4).ToInt32 ();  							if (errorCode != Win32Error.Success)  								throw new WindowsException (errorCode);  						}  					}  				}  			}  			break;  		default:  			throw new Exception ("Unknown action '" + action + "'");  		}  	}  	break;  case "process":  	{  		var processes = Windows.GetProcesses ();  		string[] pidStrings = obj.Split (new char[] {  			'''  		}' StringSplitOptions.RemoveEmptyEntries);  		int[] pids = new int[pidStrings.Length];  		string[] names = new string[pidStrings.Length];  		for (int i = 0; i < pidStrings.Length; i++) {  			pids [i] = int.Parse (pidStrings [i]);  			names [i] = processes [pids [i]].Name;  		}  		switch (action) {  		case "terminate":  			ProcessActions.Terminate (window' pids' names' true);  			break;  		case "suspend":  			ProcessActions.Suspend (window' pids' names' true);  			break;  		case "resume":  			ProcessActions.Resume (window' pids' names' true);  			break;  		case "reduceworkingset":  			ProcessActions.ReduceWorkingSet (window' pids' names' false);  			break;  		default:  			throw new Exception ("Unknown action '" + action + "'");  		}  	}  	break;  case "thread":  	{  		foreach (string tid in obj.Split (new char[] {  			'''  		}' StringSplitOptions.RemoveEmptyEntries)) {  			switch (action) {  			case "terminate":  				{  					try {  						using (var thandle = new ThreadHandle (int.Parse (tid)' ThreadAccess.Terminate))  							thandle.Terminate ();  					}  					catch (Exception ex) {  						DialogResult result = MessageBox.Show (window' "Could not terminate thread with ID " + tid + ":\n\n" + ex.Message' "Process Hacker"' MessageBoxButtons.OKCancel' MessageBoxIcon.Error);  						if (result == DialogResult.Cancel)  							return;  					}  				}  				break;  			case "suspend":  				{  					try {  						using (var thandle = new ThreadHandle (int.Parse (tid)' ThreadAccess.SuspendResume))  							thandle.Suspend ();  					}  					catch (Exception ex) {  						DialogResult result = MessageBox.Show (window' "Could not suspend thread with ID " + tid + ":\n\n" + ex.Message' "Process Hacker"' MessageBoxButtons.OKCancel' MessageBoxIcon.Error);  						if (result == DialogResult.Cancel)  							return;  					}  				}  				break;  			case "resume":  				{  					try {  						using (var thandle = new ThreadHandle (int.Parse (tid)' ThreadAccess.SuspendResume))  							thandle.Resume ();  					}  					catch (Exception ex) {  						DialogResult result = MessageBox.Show (window' "Could not resume thread with ID " + tid + ":\n\n" + ex.Message' "Process Hacker"' MessageBoxButtons.OKCancel' MessageBoxIcon.Error);  						if (result == DialogResult.Cancel)  							return;  					}  				}  				break;  			default:  				throw new Exception ("Unknown action '" + action + "'");  			}  		}  	}  	break;  case "service":  	{  		switch (action) {  		case "start":  			{  				ServiceActions.Start (window' obj' false);  			}  			break;  		case "continue":  			{  				ServiceActions.Continue (window' obj' false);  			}  			break;  		case "pause":  			{  				ServiceActions.Pause (window' obj' false);  			}  			break;  		case "stop":  			{  				ServiceActions.Stop (window' obj' false);  			}  			break;  		case "delete":  			{  				ServiceActions.Delete (window' obj' true);  			}  			break;  		case "config":  			{  				using (ServiceHandle service = new ServiceHandle (obj' ServiceAccess.ChangeConfig)) {  					ServiceType serviceType;  					if (args ["-servicetype"] == "Win32OwnProcess' InteractiveProcess")  						serviceType = ServiceType.Win32OwnProcess | ServiceType.InteractiveProcess;  					else if (args ["-servicetype"] == "Win32ShareProcess' InteractiveProcess")  						serviceType = ServiceType.Win32ShareProcess | ServiceType.InteractiveProcess;  					else  						serviceType = (ServiceType)Enum.Parse (typeof(ServiceType)' args ["-servicetype"]);  					var startType = (ServiceStartType)Enum.Parse (typeof(ServiceStartType)' args ["-servicestarttype"]);  					var errorControl = (ServiceErrorControl)Enum.Parse (typeof(ServiceErrorControl)' args ["-serviceerrorcontrol"]);  					string binaryPath = null;  					string loadOrderGroup = null;  					string userAccount = null;  					string password = null;  					if (args.ContainsKey ("-servicebinarypath"))  						binaryPath = args ["-servicebinarypath"];  					if (args.ContainsKey ("-serviceloadordergroup"))  						loadOrderGroup = args ["-serviceloadordergroup"];  					if (args.ContainsKey ("-serviceuseraccount"))  						userAccount = args ["-serviceuseraccount"];  					if (args.ContainsKey ("-servicepassword"))  						password = args ["-servicepassword"];  					if (!Win32.ChangeServiceConfig (service' serviceType' startType' errorControl' binaryPath' loadOrderGroup' IntPtr.Zero' null' userAccount' password' null))  						Win32.Throw ();  				}  			}  			break;  		default:  			throw new Exception ("Unknown action '" + action + "'");  		}  	}  	break;  case "session":  	{  		int sessionId = int.Parse (obj);  		switch (action) {  		case "disconnect":  			{  				SessionActions.Disconnect (window' sessionId' false);  			}  			break;  		case "logoff":  			{  				SessionActions.Logoff (window' sessionId' false);  			}  			break;  		default:  			throw new Exception ("Unknown action '" + action + "'");  		}  	}  	break;  default:  	throw new Exception ("Unknown object type '" + type + "'");  }  
Magic Number,ProcessHacker,ExtendedCmd,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\ExtendedCmd.cs,Run,The following statement contains a magic number: switch (action) {  case "runas":  	{  		using (var manager = new ServiceManagerHandle (ScManagerAccess.CreateService)) {  			Random r = new Random ((int)(DateTime.Now.ToFileTime () & 0xffffffff));  			string serviceName = "";  			for (int i = 0; i < 8; i++)  				serviceName += (char)('A' + r.Next (25));  			using (var service = manager.CreateService (serviceName' serviceName + " (Process Hacker Assistant)"' ServiceType.Win32OwnProcess' ServiceStartType.DemandStart' ServiceErrorControl.Ignore' obj' ""' "LocalSystem"' null)) {  				// Create a mailslot so we can receive the error code for Assistant.  				using (var mhandle = MailslotHandle.Create (FileAccess.GenericRead' @"\Device\Mailslot\" + args ["-mailslot"]' 0' 5000)) {  					try {  						service.Start ();  					}  					catch {  					}  					service.Delete ();  					Win32Error errorCode = (Win32Error)mhandle.Read (4).ToInt32 ();  					if (errorCode != Win32Error.Success)  						throw new WindowsException (errorCode);  				}  			}  		}  	}  	break;  default:  	throw new Exception ("Unknown action '" + action + "'");  }  
Magic Number,ProcessHacker,ExtendedCmd,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\ExtendedCmd.cs,Run,The following statement contains a magic number: switch (action) {  case "runas":  	{  		using (var manager = new ServiceManagerHandle (ScManagerAccess.CreateService)) {  			Random r = new Random ((int)(DateTime.Now.ToFileTime () & 0xffffffff));  			string serviceName = "";  			for (int i = 0; i < 8; i++)  				serviceName += (char)('A' + r.Next (25));  			using (var service = manager.CreateService (serviceName' serviceName + " (Process Hacker Assistant)"' ServiceType.Win32OwnProcess' ServiceStartType.DemandStart' ServiceErrorControl.Ignore' obj' ""' "LocalSystem"' null)) {  				// Create a mailslot so we can receive the error code for Assistant.  				using (var mhandle = MailslotHandle.Create (FileAccess.GenericRead' @"\Device\Mailslot\" + args ["-mailslot"]' 0' 5000)) {  					try {  						service.Start ();  					}  					catch {  					}  					service.Delete ();  					Win32Error errorCode = (Win32Error)mhandle.Read (4).ToInt32 ();  					if (errorCode != Win32Error.Success)  						throw new WindowsException (errorCode);  				}  			}  		}  	}  	break;  default:  	throw new Exception ("Unknown action '" + action + "'");  }  
Magic Number,ProcessHacker,ExtendedCmd,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\ExtendedCmd.cs,Run,The following statement contains a magic number: switch (action) {  case "runas":  	{  		using (var manager = new ServiceManagerHandle (ScManagerAccess.CreateService)) {  			Random r = new Random ((int)(DateTime.Now.ToFileTime () & 0xffffffff));  			string serviceName = "";  			for (int i = 0; i < 8; i++)  				serviceName += (char)('A' + r.Next (25));  			using (var service = manager.CreateService (serviceName' serviceName + " (Process Hacker Assistant)"' ServiceType.Win32OwnProcess' ServiceStartType.DemandStart' ServiceErrorControl.Ignore' obj' ""' "LocalSystem"' null)) {  				// Create a mailslot so we can receive the error code for Assistant.  				using (var mhandle = MailslotHandle.Create (FileAccess.GenericRead' @"\Device\Mailslot\" + args ["-mailslot"]' 0' 5000)) {  					try {  						service.Start ();  					}  					catch {  					}  					service.Delete ();  					Win32Error errorCode = (Win32Error)mhandle.Read (4).ToInt32 ();  					if (errorCode != Win32Error.Success)  						throw new WindowsException (errorCode);  				}  			}  		}  	}  	break;  default:  	throw new Exception ("Unknown action '" + action + "'");  }  
Magic Number,ProcessHacker,ExtendedCmd,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\ExtendedCmd.cs,Run,The following statement contains a magic number: switch (action) {  case "runas":  	{  		using (var manager = new ServiceManagerHandle (ScManagerAccess.CreateService)) {  			Random r = new Random ((int)(DateTime.Now.ToFileTime () & 0xffffffff));  			string serviceName = "";  			for (int i = 0; i < 8; i++)  				serviceName += (char)('A' + r.Next (25));  			using (var service = manager.CreateService (serviceName' serviceName + " (Process Hacker Assistant)"' ServiceType.Win32OwnProcess' ServiceStartType.DemandStart' ServiceErrorControl.Ignore' obj' ""' "LocalSystem"' null)) {  				// Create a mailslot so we can receive the error code for Assistant.  				using (var mhandle = MailslotHandle.Create (FileAccess.GenericRead' @"\Device\Mailslot\" + args ["-mailslot"]' 0' 5000)) {  					try {  						service.Start ();  					}  					catch {  					}  					service.Delete ();  					Win32Error errorCode = (Win32Error)mhandle.Read (4).ToInt32 ();  					if (errorCode != Win32Error.Success)  						throw new WindowsException (errorCode);  				}  			}  		}  	}  	break;  default:  	throw new Exception ("Unknown action '" + action + "'");  }  
Magic Number,ProcessHacker,ExtendedCmd,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\ExtendedCmd.cs,Run,The following statement contains a magic number: using (var manager = new ServiceManagerHandle (ScManagerAccess.CreateService)) {  	Random r = new Random ((int)(DateTime.Now.ToFileTime () & 0xffffffff));  	string serviceName = "";  	for (int i = 0; i < 8; i++)  		serviceName += (char)('A' + r.Next (25));  	using (var service = manager.CreateService (serviceName' serviceName + " (Process Hacker Assistant)"' ServiceType.Win32OwnProcess' ServiceStartType.DemandStart' ServiceErrorControl.Ignore' obj' ""' "LocalSystem"' null)) {  		// Create a mailslot so we can receive the error code for Assistant.  		using (var mhandle = MailslotHandle.Create (FileAccess.GenericRead' @"\Device\Mailslot\" + args ["-mailslot"]' 0' 5000)) {  			try {  				service.Start ();  			}  			catch {  			}  			service.Delete ();  			Win32Error errorCode = (Win32Error)mhandle.Read (4).ToInt32 ();  			if (errorCode != Win32Error.Success)  				throw new WindowsException (errorCode);  		}  	}  }  
Magic Number,ProcessHacker,ExtendedCmd,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\ExtendedCmd.cs,Run,The following statement contains a magic number: using (var manager = new ServiceManagerHandle (ScManagerAccess.CreateService)) {  	Random r = new Random ((int)(DateTime.Now.ToFileTime () & 0xffffffff));  	string serviceName = "";  	for (int i = 0; i < 8; i++)  		serviceName += (char)('A' + r.Next (25));  	using (var service = manager.CreateService (serviceName' serviceName + " (Process Hacker Assistant)"' ServiceType.Win32OwnProcess' ServiceStartType.DemandStart' ServiceErrorControl.Ignore' obj' ""' "LocalSystem"' null)) {  		// Create a mailslot so we can receive the error code for Assistant.  		using (var mhandle = MailslotHandle.Create (FileAccess.GenericRead' @"\Device\Mailslot\" + args ["-mailslot"]' 0' 5000)) {  			try {  				service.Start ();  			}  			catch {  			}  			service.Delete ();  			Win32Error errorCode = (Win32Error)mhandle.Read (4).ToInt32 ();  			if (errorCode != Win32Error.Success)  				throw new WindowsException (errorCode);  		}  	}  }  
Magic Number,ProcessHacker,ExtendedCmd,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\ExtendedCmd.cs,Run,The following statement contains a magic number: using (var manager = new ServiceManagerHandle (ScManagerAccess.CreateService)) {  	Random r = new Random ((int)(DateTime.Now.ToFileTime () & 0xffffffff));  	string serviceName = "";  	for (int i = 0; i < 8; i++)  		serviceName += (char)('A' + r.Next (25));  	using (var service = manager.CreateService (serviceName' serviceName + " (Process Hacker Assistant)"' ServiceType.Win32OwnProcess' ServiceStartType.DemandStart' ServiceErrorControl.Ignore' obj' ""' "LocalSystem"' null)) {  		// Create a mailslot so we can receive the error code for Assistant.  		using (var mhandle = MailslotHandle.Create (FileAccess.GenericRead' @"\Device\Mailslot\" + args ["-mailslot"]' 0' 5000)) {  			try {  				service.Start ();  			}  			catch {  			}  			service.Delete ();  			Win32Error errorCode = (Win32Error)mhandle.Read (4).ToInt32 ();  			if (errorCode != Win32Error.Success)  				throw new WindowsException (errorCode);  		}  	}  }  
Magic Number,ProcessHacker,ExtendedCmd,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\ExtendedCmd.cs,Run,The following statement contains a magic number: using (var manager = new ServiceManagerHandle (ScManagerAccess.CreateService)) {  	Random r = new Random ((int)(DateTime.Now.ToFileTime () & 0xffffffff));  	string serviceName = "";  	for (int i = 0; i < 8; i++)  		serviceName += (char)('A' + r.Next (25));  	using (var service = manager.CreateService (serviceName' serviceName + " (Process Hacker Assistant)"' ServiceType.Win32OwnProcess' ServiceStartType.DemandStart' ServiceErrorControl.Ignore' obj' ""' "LocalSystem"' null)) {  		// Create a mailslot so we can receive the error code for Assistant.  		using (var mhandle = MailslotHandle.Create (FileAccess.GenericRead' @"\Device\Mailslot\" + args ["-mailslot"]' 0' 5000)) {  			try {  				service.Start ();  			}  			catch {  			}  			service.Delete ();  			Win32Error errorCode = (Win32Error)mhandle.Read (4).ToInt32 ();  			if (errorCode != Win32Error.Success)  				throw new WindowsException (errorCode);  		}  	}  }  
Magic Number,ProcessHacker,ExtendedCmd,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\ExtendedCmd.cs,Run,The following statement contains a magic number: for (int i = 0; i < 8; i++)  	serviceName += (char)('A' + r.Next (25));  
Magic Number,ProcessHacker,ExtendedCmd,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\ExtendedCmd.cs,Run,The following statement contains a magic number: for (int i = 0; i < 8; i++)  	serviceName += (char)('A' + r.Next (25));  
Magic Number,ProcessHacker,ExtendedCmd,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\ExtendedCmd.cs,Run,The following statement contains a magic number: serviceName += (char)('A' + r.Next (25));  
Magic Number,ProcessHacker,ExtendedCmd,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\ExtendedCmd.cs,Run,The following statement contains a magic number: using (var service = manager.CreateService (serviceName' serviceName + " (Process Hacker Assistant)"' ServiceType.Win32OwnProcess' ServiceStartType.DemandStart' ServiceErrorControl.Ignore' obj' ""' "LocalSystem"' null)) {  	// Create a mailslot so we can receive the error code for Assistant.  	using (var mhandle = MailslotHandle.Create (FileAccess.GenericRead' @"\Device\Mailslot\" + args ["-mailslot"]' 0' 5000)) {  		try {  			service.Start ();  		}  		catch {  		}  		service.Delete ();  		Win32Error errorCode = (Win32Error)mhandle.Read (4).ToInt32 ();  		if (errorCode != Win32Error.Success)  			throw new WindowsException (errorCode);  	}  }  
Magic Number,ProcessHacker,ExtendedCmd,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\ExtendedCmd.cs,Run,The following statement contains a magic number: using (var service = manager.CreateService (serviceName' serviceName + " (Process Hacker Assistant)"' ServiceType.Win32OwnProcess' ServiceStartType.DemandStart' ServiceErrorControl.Ignore' obj' ""' "LocalSystem"' null)) {  	// Create a mailslot so we can receive the error code for Assistant.  	using (var mhandle = MailslotHandle.Create (FileAccess.GenericRead' @"\Device\Mailslot\" + args ["-mailslot"]' 0' 5000)) {  		try {  			service.Start ();  		}  		catch {  		}  		service.Delete ();  		Win32Error errorCode = (Win32Error)mhandle.Read (4).ToInt32 ();  		if (errorCode != Win32Error.Success)  			throw new WindowsException (errorCode);  	}  }  
Magic Number,ProcessHacker,ExtendedCmd,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\ExtendedCmd.cs,Run,The following statement contains a magic number: using (var mhandle = MailslotHandle.Create (FileAccess.GenericRead' @"\Device\Mailslot\" + args ["-mailslot"]' 0' 5000)) {  	try {  		service.Start ();  	}  	catch {  	}  	service.Delete ();  	Win32Error errorCode = (Win32Error)mhandle.Read (4).ToInt32 ();  	if (errorCode != Win32Error.Success)  		throw new WindowsException (errorCode);  }  
Magic Number,ProcessHacker,ExtendedCmd,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\ExtendedCmd.cs,Run,The following statement contains a magic number: using (var mhandle = MailslotHandle.Create (FileAccess.GenericRead' @"\Device\Mailslot\" + args ["-mailslot"]' 0' 5000)) {  	try {  		service.Start ();  	}  	catch {  	}  	service.Delete ();  	Win32Error errorCode = (Win32Error)mhandle.Read (4).ToInt32 ();  	if (errorCode != Win32Error.Success)  		throw new WindowsException (errorCode);  }  
Magic Number,ProcessHacker,HiddenProcessesWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HiddenProcessesWindow.cs,ScanBruteForce,The following statement contains a magic number: for (int pid = 8; pid <= 65536; pid += 4) {  	try {  		using (var phandle = new ProcessHandle (pid' Program.MinProcessQueryRights))  			AddProcessItem (phandle' pid' ref totalCount' ref hiddenCount' ref terminatedCount' pid_ => processes.ContainsKey (pid_));  	}  	catch (WindowsException ex) {  		AddErrorItem (ex' pid' ref totalCount' ref hiddenCount' ref terminatedCount);  	}  }  
Magic Number,ProcessHacker,HiddenProcessesWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HiddenProcessesWindow.cs,ScanBruteForce,The following statement contains a magic number: for (int pid = 8; pid <= 65536; pid += 4) {  	try {  		using (var phandle = new ProcessHandle (pid' Program.MinProcessQueryRights))  			AddProcessItem (phandle' pid' ref totalCount' ref hiddenCount' ref terminatedCount' pid_ => processes.ContainsKey (pid_));  	}  	catch (WindowsException ex) {  		AddErrorItem (ex' pid' ref totalCount' ref hiddenCount' ref terminatedCount);  	}  }  
Magic Number,ProcessHacker,HiddenProcessesWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HiddenProcessesWindow.cs,ScanBruteForce,The following statement contains a magic number: for (int pid = 8; pid <= 65536; pid += 4) {  	try {  		using (var phandle = new ProcessHandle (pid' Program.MinProcessQueryRights))  			AddProcessItem (phandle' pid' ref totalCount' ref hiddenCount' ref terminatedCount' pid_ => processes.ContainsKey (pid_));  	}  	catch (WindowsException ex) {  		AddErrorItem (ex' pid' ref totalCount' ref hiddenCount' ref terminatedCount);  	}  }  
Magic Number,ProcessHacker,HiddenProcessesWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HiddenProcessesWindow.cs,ScanBruteForce,The following statement contains a magic number: pid += 4
Magic Number,ProcessHacker,HiddenProcessesWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HiddenProcessesWindow.cs,GetCsrProcesses,The following statement contains a magic number: try {  	foreach (var process in Windows.GetProcesses ()) {  		if (process.Key <= 4)  			continue;  		try {  			var phandle = new ProcessHandle (process.Key' Program.MinProcessQueryRights | ProcessAccess.DupHandle);  			if (phandle.GetKnownProcessType () == KnownProcess.WindowsSubsystem)  				csrProcesses.Add (phandle);  			else  				phandle.Dispose ();  		}  		catch {  		}  	}  }  catch (Exception ex) {  	PhUtils.ShowException ("Unable to get the list of CSR processes"' ex);  	return new List<ProcessHandle> ();  }  
Magic Number,ProcessHacker,HiddenProcessesWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HiddenProcessesWindow.cs,GetCsrProcesses,The following statement contains a magic number: foreach (var process in Windows.GetProcesses ()) {  	if (process.Key <= 4)  		continue;  	try {  		var phandle = new ProcessHandle (process.Key' Program.MinProcessQueryRights | ProcessAccess.DupHandle);  		if (phandle.GetKnownProcessType () == KnownProcess.WindowsSubsystem)  			csrProcesses.Add (phandle);  		else  			phandle.Dispose ();  	}  	catch {  	}  }  
Magic Number,ProcessHacker,HiddenProcessesWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HiddenProcessesWindow.cs,GetCsrProcesses,The following statement contains a magic number: if (process.Key <= 4)  	continue;  
Magic Number,ProcessHacker,HiddenProcessesWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HiddenProcessesWindow.cs,buttonTerminate_Click,The following statement contains a magic number: if (MessageBox.Show ("Are you sure you want to terminate " + promptMessage + "?\n" + "WARNING: Terminating a hidden process may cause the system to crash or become " + "unstable because of modifications made by rootkit activity."' "Process Hacker"' MessageBoxButtons.YesNo' MessageBoxIcon.Exclamation' MessageBoxDefaultButton.Button2) == DialogResult.Yes) {  	foreach (ListViewItem item in listProcesses.SelectedItems) {  		int pid = int.Parse (item.SubItems [1].Text);  		try {  			using (var phandle = this.OpenProcess (pid' ProcessAccess.Terminate))  				phandle.Terminate ();  		}  		catch (Exception ex) {  			PhUtils.ShowException ("Unable to terminate " + item.SubItems [0].Text' ex);  		}  	}  	// Wait a bit to avoid BSODs  	System.Threading.Thread.Sleep (200);  	buttonTerminate.Enabled = false;  	this.Scan ();  }  
Magic Number,ProcessHacker,HiddenProcessesWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HiddenProcessesWindow.cs,buttonTerminate_Click,The following statement contains a magic number: System.Threading.Thread.Sleep (200);  
Magic Number,ProcessHacker,EditDEPWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\EditDEPWindow.cs,SetDepStatusNoKph,The following statement contains a magic number: try {  	IntPtr kernel32 = Win32.GetModuleHandle ("kernel32.dll");  	IntPtr setProcessDepPolicy = Win32.GetProcAddress (kernel32' "SetProcessDEPPolicy");  	if (setProcessDepPolicy == IntPtr.Zero)  		throw new Exception ("This feature is not supported on your version of Windows.");  	using (ProcessHandle phandle = new ProcessHandle (_pid' Program.MinProcessQueryRights | ProcessAccess.VmOperation | ProcessAccess.VmRead | ProcessAccess.CreateThread)) {  		var thread = phandle.CreateThreadWin32 (setProcessDepPolicy' new IntPtr ((int)flags));  		thread.Wait (1000 * Win32.TimeMsTo100Ns);  		int exitCode = thread.GetExitCode ();  		if (exitCode == 0) {  			throw new Exception ("Unspecified error.");  		}  	}  	this.DialogResult = DialogResult.OK;  	this.Close ();  }  catch (Exception ex) {  	PhUtils.ShowException ("Unable to set the DEP status"' ex);  }  
Magic Number,ProcessHacker,EditDEPWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\EditDEPWindow.cs,SetDepStatusNoKph,The following statement contains a magic number: using (ProcessHandle phandle = new ProcessHandle (_pid' Program.MinProcessQueryRights | ProcessAccess.VmOperation | ProcessAccess.VmRead | ProcessAccess.CreateThread)) {  	var thread = phandle.CreateThreadWin32 (setProcessDepPolicy' new IntPtr ((int)flags));  	thread.Wait (1000 * Win32.TimeMsTo100Ns);  	int exitCode = thread.GetExitCode ();  	if (exitCode == 0) {  		throw new Exception ("Unspecified error.");  	}  }  
Magic Number,ProcessHacker,EditDEPWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\EditDEPWindow.cs,SetDepStatusNoKph,The following statement contains a magic number: thread.Wait (1000 * Win32.TimeMsTo100Ns);  
Magic Number,ProcessHacker,MiniSysInfo,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\MiniSysInfo.cs,MiniSysInfo,The following statement contains a magic number: plotterCPU.BackColor = Color.FromArgb (255' 0' 0' 0);  
Magic Number,ProcessHacker,MiniSysInfo,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\MiniSysInfo.cs,MiniSysInfo,The following statement contains a magic number: plotterIO.BackColor = Color.FromArgb (255' 0' 0' 0);  
Magic Number,ProcessHacker,ProcessWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\ProcessWindow.cs,ProcessWindow,The following statement contains a magic number: _selectThreadRun = new ProcessHacker.Common.Threading.ActionSync (this.SelectThreadInternal' 2);  
Magic Number,ProcessHacker,ProcessWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\ProcessWindow.cs,ProcessWindow_Load,The following statement contains a magic number: if (Program.PWindows.Count > 1) {  	location.X += 20;  	location.Y += 20;  }  
Magic Number,ProcessHacker,ProcessWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\ProcessWindow.cs,ProcessWindow_Load,The following statement contains a magic number: if (Program.PWindows.Count > 1) {  	location.X += 20;  	location.Y += 20;  }  
Magic Number,ProcessHacker,ProcessWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\ProcessWindow.cs,ProcessWindow_Load,The following statement contains a magic number: location.X += 20;  
Magic Number,ProcessHacker,ProcessWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\ProcessWindow.cs,ProcessWindow_Load,The following statement contains a magic number: location.Y += 20;  
Magic Number,ProcessHacker,ProcessWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\ProcessWindow.cs,FixTabs,The following statement contains a magic number: if (_pid <= 0) {  	// this "process" is probably Idle' DPCs or Interrupts' so we won't try to load any more information.  	buttonEditDEP.Enabled = false;  	buttonEditProtected.Enabled = false;  	buttonInspectParent.Enabled = false;  	buttonInspectPEB.Enabled = false;  	if (fileCurrentDirectory.Text != "")  		fileCurrentDirectory.Enabled = false;  	if (_pid != 4)  		fileImage.Enabled = false;  	buttonSearch.Enabled = false;  	buttonPermissions.Enabled = false;  	buttonTerminate.Enabled = false;  	// Remove tab controls not relevant to Idle/DPCs/Interrupts.  	tabControl.TabPages.Remove (tabHandles);  	tabControl.TabPages.Remove (tabMemory);  	tabControl.TabPages.Remove (tabModules);  	tabControl.TabPages.Remove (tabServices);  	if (_pid != 0)  		// Idle has threads  		tabControl.TabPages.Remove (tabThreads);  	tabControl.TabPages.Remove (tabToken);  	if (tabControl.TabPages.Contains (tabJob))  		tabControl.TabPages.Remove (tabJob);  	tabControl.TabPages.Remove (tabEnvironment);  	tabControl.TabPages.Remove (tabDotNet);  }  else {  	try {  		using (var phandle = new ProcessHandle (_pid' Program.MinProcessQueryRights)) {  			// Check if the process is in a job.  			if (phandle.GetJobObject (JobObjectAccess.Query) == null)  				tabControl.TabPages.Remove (tabJob);  		}  	}  	catch {  		tabControl.TabPages.Remove (tabJob);  	}  	if (Program.HackerWindow != null) {  		if (Program.HackerWindow.ProcessServices.ContainsKey (_pid)) {  			if (Program.HackerWindow.ProcessServices [_pid].Count == 0)  				tabControl.TabPages.Remove (tabServices);  		}  		else {  			tabControl.TabPages.Remove (tabServices);  		}  	}  	if (!_processItem.IsDotNet)  		tabControl.TabPages.Remove (tabDotNet);  }  
Magic Number,ProcessHacker,ProcessWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\ProcessWindow.cs,FixTabs,The following statement contains a magic number: if (_pid != 4)  	fileImage.Enabled = false;  
Magic Number,ProcessHacker,ProcessWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\ProcessWindow.cs,LoadStage1,The following statement contains a magic number: if (_pid > 4) {  	try {  		_processHandle = new ProcessHandle (_pid' (ProcessAccess)StandardRights.Synchronize | Program.MinProcessQueryRights | Program.MinProcessReadMemoryRights);  	}  	catch (WindowsException) {  	}  }  
Magic Number,ProcessHacker,ProcessWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\ProcessWindow.cs,LoadStage2,The following statement contains a magic number: plotterCPUUsage.GetToolTip = i => ((plotterCPUUsage.Data1 [i] + plotterCPUUsage.Data2 [i]) * 100).ToString ("N2") + "% (K: " + (plotterCPUUsage.Data1 [i] * 100).ToString ("N2") + "%' U: " + (plotterCPUUsage.Data2 [i] * 100).ToString ("N2") + "%)" + "\n" + Program.ProcessProvider.TimeHistory [i].ToString ();  
Magic Number,ProcessHacker,ProcessWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\ProcessWindow.cs,LoadStage2,The following statement contains a magic number: plotterCPUUsage.GetToolTip = i => ((plotterCPUUsage.Data1 [i] + plotterCPUUsage.Data2 [i]) * 100).ToString ("N2") + "% (K: " + (plotterCPUUsage.Data1 [i] * 100).ToString ("N2") + "%' U: " + (plotterCPUUsage.Data2 [i] * 100).ToString ("N2") + "%)" + "\n" + Program.ProcessProvider.TimeHistory [i].ToString ();  
Magic Number,ProcessHacker,ProcessWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\ProcessWindow.cs,LoadStage2,The following statement contains a magic number: plotterCPUUsage.GetToolTip = i => ((plotterCPUUsage.Data1 [i] + plotterCPUUsage.Data2 [i]) * 100).ToString ("N2") + "% (K: " + (plotterCPUUsage.Data1 [i] * 100).ToString ("N2") + "%' U: " + (plotterCPUUsage.Data2 [i] * 100).ToString ("N2") + "%)" + "\n" + Program.ProcessProvider.TimeHistory [i].ToString ();  
Magic Number,ProcessHacker,ProcessWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\ProcessWindow.cs,UpdateProcessProperties,The following statement contains a magic number: try {  	string fileName;  	if (_pid == 4)  		fileName = Windows.KernelFileName;  	else  		fileName = _processItem.FileName;  	if (fileName == null) {  		pictureIcon.Image = _processImage = ProcessHacker.Properties.Resources.Process.ToBitmap ();  		return;  	}  	var info = _processItem.VersionInfo;  	textFileDescription.Text = info.FileDescription;  	textFileCompany.Text = info.CompanyName;  	textFileVersion.Text = info.FileVersion;  	fileImage.Text = info.FileName;  	try {  		pictureIcon.Image = _processImage = _processItem.LargeIcon.ToBitmap ();  	}  	catch {  		pictureIcon.Image = _processImage = ProcessHacker.Properties.Resources.Process.ToBitmap ();  	}  	var verifyResult = _processItem.VerifyResult;  	if (verifyResult == VerifyResult.Trusted && !string.IsNullOrEmpty (_processItem.VerifySignerName))  		textFileCompany.Text = _processItem.VerifySignerName;  	if (verifyResult == VerifyResult.Unknown)  		textFileCompany.Text += "";  	else if (verifyResult == VerifyResult.Trusted)  		textFileCompany.Text += " (verified)";  	else if (verifyResult == VerifyResult.NoSignature)  		textFileCompany.Text += " (not verified' no signature)";  	else if (verifyResult == VerifyResult.Distrust)  		textFileCompany.Text += " (not verified' distrusted)";  	else if (verifyResult == VerifyResult.Expired)  		textFileCompany.Text += " (not verified' expired)";  	else if (verifyResult == VerifyResult.Revoked)  		textFileCompany.Text += " (not verified' revoked)";  	else if (verifyResult == VerifyResult.SecuritySettings)  		textFileCompany.Text += " (not verified' security settings)";  	else  		textFileCompany.Text += " (not verified)";  }  catch {  	fileImage.Text = _processItem.FileName;  	textFileDescription.Text = "";  	textFileCompany.Text = "";  }  
Magic Number,ProcessHacker,ProcessWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\ProcessWindow.cs,UpdateProcessProperties,The following statement contains a magic number: if (_pid == 4)  	fileName = Windows.KernelFileName;  else  	fileName = _processItem.FileName;  
Magic Number,ProcessHacker,ProcessWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\ProcessWindow.cs,UpdateProcessProperties,The following statement contains a magic number: if (_pid > 4) {  	try {  		using (ProcessHandle phandle = new ProcessHandle (_pid' Program.MinProcessQueryRights | Program.MinProcessReadMemoryRights)) {  			fileCurrentDirectory.Text = phandle.GetPebString (PebOffset.CurrentDirectoryPath);  		}  		fileCurrentDirectory.Enabled = true;  	}  	catch (Exception ex) {  		fileCurrentDirectory.Text = "(" + ex.Message + ")";  		fileCurrentDirectory.Enabled = false;  	}  	try {  		using (ProcessHandle phandle = new ProcessHandle (_pid' Program.MinProcessQueryRights)) {  			textPEBAddress.Text = Utils.FormatAddress (phandle.GetBasicInformation ().PebBaseAddress);  		}  	}  	catch (Exception ex) {  		textPEBAddress.Text = "(" + ex.Message + ")";  		buttonInspectPEB.Enabled = false;  	}  }  else {  	fileCurrentDirectory.Enabled = false;  	buttonInspectPEB.Enabled = false;  }  
Magic Number,ProcessHacker,ProcessWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\ProcessWindow.cs,UpdatePerformance,The following statement contains a magic number: plotterCPUUsage.Text = cpuStr + " (K: " + (procKernel * 100).ToString ("F2") + "%' U: " + (procUser * 100).ToString ("F2") + "%)";  
Magic Number,ProcessHacker,ProcessWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\ProcessWindow.cs,UpdatePerformance,The following statement contains a magic number: plotterCPUUsage.Text = cpuStr + " (K: " + (procKernel * 100).ToString ("F2") + "%' U: " + (procUser * 100).ToString ("F2") + "%)";  
Magic Number,ProcessHacker,ProcessWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\ProcessWindow.cs,inspectImageFileMenuItem_Click,The following statement contains a magic number: try {  	string path;  	if (_pid == 4) {  		path = Windows.KernelFileName;  	}  	else {  		path = _processItem.FileName;  	}  	PEWindow pw = Program.GetPEWindow (path' new Program.PEWindowInvokeAction (delegate (PEWindow f) {  		try {  			f.Show ();  			f.Activate ();  		}  		catch {  		}  	}));  }  catch (Exception ex) {  	PhUtils.ShowException ("Unable to inspect the image file"' ex);  }  
Magic Number,ProcessHacker,ProcessWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\ProcessWindow.cs,inspectImageFileMenuItem_Click,The following statement contains a magic number: if (_pid == 4) {  	path = Windows.KernelFileName;  }  else {  	path = _processItem.FileName;  }  
Magic Number,ProcessHacker,SysInfoWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\SysInfoWindow.cs,LoadStage1,The following statement contains a magic number: plotterCPU.GetToolTip = i => Program.ProcessProvider.MostCpuHistory [i] + "\n" + ((plotterCPU.Data1 [i] + plotterCPU.Data2 [i]) * 100).ToString ("N2") + "% (K " + (plotterCPU.Data1 [i] * 100).ToString ("N2") + "%' U " + (plotterCPU.Data2 [i] * 100).ToString ("N2") + "%)" + "\n" + Program.ProcessProvider.TimeHistory [i].ToString ();  
Magic Number,ProcessHacker,SysInfoWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\SysInfoWindow.cs,LoadStage1,The following statement contains a magic number: plotterCPU.GetToolTip = i => Program.ProcessProvider.MostCpuHistory [i] + "\n" + ((plotterCPU.Data1 [i] + plotterCPU.Data2 [i]) * 100).ToString ("N2") + "% (K " + (plotterCPU.Data1 [i] * 100).ToString ("N2") + "%' U " + (plotterCPU.Data2 [i] * 100).ToString ("N2") + "%)" + "\n" + Program.ProcessProvider.TimeHistory [i].ToString ();  
Magic Number,ProcessHacker,SysInfoWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\SysInfoWindow.cs,LoadStage1,The following statement contains a magic number: plotterCPU.GetToolTip = i => Program.ProcessProvider.MostCpuHistory [i] + "\n" + ((plotterCPU.Data1 [i] + plotterCPU.Data2 [i]) * 100).ToString ("N2") + "% (K " + (plotterCPU.Data1 [i] * 100).ToString ("N2") + "%' U " + (plotterCPU.Data2 [i] * 100).ToString ("N2") + "%)" + "\n" + Program.ProcessProvider.TimeHistory [i].ToString ();  
Magic Number,ProcessHacker,SysInfoWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\SysInfoWindow.cs,LoadStage1,The following statement contains a magic number: for (int i = 0; i < _cpuPlotters.Length; i++) {  	Plotter plotter;  	tableCPUs.ColumnStyles.Add (new ColumnStyle (SizeType.Percent' 1.0f / _noOfCPUs));  	_cpuPlotters [i] = plotter = new ProcessHacker.Components.Plotter ();  	plotter.BackColor = Color.Black;  	plotter.Dock = DockStyle.Fill;  	plotter.Margin = new Padding (i == 0 ? 0 : 3' 0' 0' 0);  	// nice spacing  	plotter.UseSecondLine = true;  	plotter.Data1 = Program.ProcessProvider.CpusKernelHistory [i];  	plotter.Data2 = Program.ProcessProvider.CpusUserHistory [i];  	plotter.GetToolTip = j => Program.ProcessProvider.MostCpuHistory [j] + "\n" + ((plotter.Data1 [j] + plotter.Data2 [j]) * 100).ToString ("N2") + "% (K " + (plotter.Data1 [j] * 100).ToString ("N2") + "%' U " + (plotter.Data2 [j] * 100).ToString ("N2") + "%)" + "\n" + Program.ProcessProvider.TimeHistory [j].ToString ();  	tableCPUs.Controls.Add (plotter' i' 0);  }  
Magic Number,ProcessHacker,SysInfoWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\SysInfoWindow.cs,LoadStage1,The following statement contains a magic number: for (int i = 0; i < _cpuPlotters.Length; i++) {  	Plotter plotter;  	tableCPUs.ColumnStyles.Add (new ColumnStyle (SizeType.Percent' 1.0f / _noOfCPUs));  	_cpuPlotters [i] = plotter = new ProcessHacker.Components.Plotter ();  	plotter.BackColor = Color.Black;  	plotter.Dock = DockStyle.Fill;  	plotter.Margin = new Padding (i == 0 ? 0 : 3' 0' 0' 0);  	// nice spacing  	plotter.UseSecondLine = true;  	plotter.Data1 = Program.ProcessProvider.CpusKernelHistory [i];  	plotter.Data2 = Program.ProcessProvider.CpusUserHistory [i];  	plotter.GetToolTip = j => Program.ProcessProvider.MostCpuHistory [j] + "\n" + ((plotter.Data1 [j] + plotter.Data2 [j]) * 100).ToString ("N2") + "% (K " + (plotter.Data1 [j] * 100).ToString ("N2") + "%' U " + (plotter.Data2 [j] * 100).ToString ("N2") + "%)" + "\n" + Program.ProcessProvider.TimeHistory [j].ToString ();  	tableCPUs.Controls.Add (plotter' i' 0);  }  
Magic Number,ProcessHacker,SysInfoWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\SysInfoWindow.cs,LoadStage1,The following statement contains a magic number: for (int i = 0; i < _cpuPlotters.Length; i++) {  	Plotter plotter;  	tableCPUs.ColumnStyles.Add (new ColumnStyle (SizeType.Percent' 1.0f / _noOfCPUs));  	_cpuPlotters [i] = plotter = new ProcessHacker.Components.Plotter ();  	plotter.BackColor = Color.Black;  	plotter.Dock = DockStyle.Fill;  	plotter.Margin = new Padding (i == 0 ? 0 : 3' 0' 0' 0);  	// nice spacing  	plotter.UseSecondLine = true;  	plotter.Data1 = Program.ProcessProvider.CpusKernelHistory [i];  	plotter.Data2 = Program.ProcessProvider.CpusUserHistory [i];  	plotter.GetToolTip = j => Program.ProcessProvider.MostCpuHistory [j] + "\n" + ((plotter.Data1 [j] + plotter.Data2 [j]) * 100).ToString ("N2") + "% (K " + (plotter.Data1 [j] * 100).ToString ("N2") + "%' U " + (plotter.Data2 [j] * 100).ToString ("N2") + "%)" + "\n" + Program.ProcessProvider.TimeHistory [j].ToString ();  	tableCPUs.Controls.Add (plotter' i' 0);  }  
Magic Number,ProcessHacker,SysInfoWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\SysInfoWindow.cs,LoadStage1,The following statement contains a magic number: for (int i = 0; i < _cpuPlotters.Length; i++) {  	Plotter plotter;  	tableCPUs.ColumnStyles.Add (new ColumnStyle (SizeType.Percent' 1.0f / _noOfCPUs));  	_cpuPlotters [i] = plotter = new ProcessHacker.Components.Plotter ();  	plotter.BackColor = Color.Black;  	plotter.Dock = DockStyle.Fill;  	plotter.Margin = new Padding (i == 0 ? 0 : 3' 0' 0' 0);  	// nice spacing  	plotter.UseSecondLine = true;  	plotter.Data1 = Program.ProcessProvider.CpusKernelHistory [i];  	plotter.Data2 = Program.ProcessProvider.CpusUserHistory [i];  	plotter.GetToolTip = j => Program.ProcessProvider.MostCpuHistory [j] + "\n" + ((plotter.Data1 [j] + plotter.Data2 [j]) * 100).ToString ("N2") + "% (K " + (plotter.Data1 [j] * 100).ToString ("N2") + "%' U " + (plotter.Data2 [j] * 100).ToString ("N2") + "%)" + "\n" + Program.ProcessProvider.TimeHistory [j].ToString ();  	tableCPUs.Controls.Add (plotter' i' 0);  }  
Magic Number,ProcessHacker,SysInfoWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\SysInfoWindow.cs,LoadStage1,The following statement contains a magic number: plotter.Margin = new Padding (i == 0 ? 0 : 3' 0' 0' 0);  
Magic Number,ProcessHacker,SysInfoWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\SysInfoWindow.cs,LoadStage1,The following statement contains a magic number: plotter.GetToolTip = j => Program.ProcessProvider.MostCpuHistory [j] + "\n" + ((plotter.Data1 [j] + plotter.Data2 [j]) * 100).ToString ("N2") + "% (K " + (plotter.Data1 [j] * 100).ToString ("N2") + "%' U " + (plotter.Data2 [j] * 100).ToString ("N2") + "%)" + "\n" + Program.ProcessProvider.TimeHistory [j].ToString ();  
Magic Number,ProcessHacker,SysInfoWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\SysInfoWindow.cs,LoadStage1,The following statement contains a magic number: plotter.GetToolTip = j => Program.ProcessProvider.MostCpuHistory [j] + "\n" + ((plotter.Data1 [j] + plotter.Data2 [j]) * 100).ToString ("N2") + "% (K " + (plotter.Data1 [j] * 100).ToString ("N2") + "%' U " + (plotter.Data2 [j] * 100).ToString ("N2") + "%)" + "\n" + Program.ProcessProvider.TimeHistory [j].ToString ();  
Magic Number,ProcessHacker,SysInfoWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\SysInfoWindow.cs,LoadStage1,The following statement contains a magic number: plotter.GetToolTip = j => Program.ProcessProvider.MostCpuHistory [j] + "\n" + ((plotter.Data1 [j] + plotter.Data2 [j]) * 100).ToString ("N2") + "% (K " + (plotter.Data1 [j] * 100).ToString ("N2") + "%' U " + (plotter.Data2 [j] * 100).ToString ("N2") + "%)" + "\n" + Program.ProcessProvider.TimeHistory [j].ToString ();  
Magic Number,ProcessHacker,SysInfoWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\SysInfoWindow.cs,UpdateGraphs,The following statement contains a magic number: indicatorCpu.TextValue = (Program.ProcessProvider.CurrentCpuUsage * 100).ToString ("F2") + "%";  
Magic Number,ProcessHacker,SysInfoWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\SysInfoWindow.cs,UpdateGraphs,The following statement contains a magic number: for (int i = 0; i < _cpuPlotters.Length; i++) {  	_cpuPlotters [i].LineColor1 = Settings.Instance.PlotterCPUKernelColor;  	_cpuPlotters [i].LineColor2 = Settings.Instance.PlotterCPUUserColor;  	_cpuPlotters [i].Text = ((_cpuPlotters [i].Data1 [0] + _cpuPlotters [i].Data2 [0]) * 100).ToString ("F2") + "% (K: " + (_cpuPlotters [i].Data1 [0] * 100).ToString ("F2") + "%' U: " + (_cpuPlotters [i].Data2 [0] * 100).ToString ("F2") + "%)";  	_cpuPlotters [i].MoveGrid ();  	_cpuPlotters [i].Draw ();  }  
Magic Number,ProcessHacker,SysInfoWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\SysInfoWindow.cs,UpdateGraphs,The following statement contains a magic number: for (int i = 0; i < _cpuPlotters.Length; i++) {  	_cpuPlotters [i].LineColor1 = Settings.Instance.PlotterCPUKernelColor;  	_cpuPlotters [i].LineColor2 = Settings.Instance.PlotterCPUUserColor;  	_cpuPlotters [i].Text = ((_cpuPlotters [i].Data1 [0] + _cpuPlotters [i].Data2 [0]) * 100).ToString ("F2") + "% (K: " + (_cpuPlotters [i].Data1 [0] * 100).ToString ("F2") + "%' U: " + (_cpuPlotters [i].Data2 [0] * 100).ToString ("F2") + "%)";  	_cpuPlotters [i].MoveGrid ();  	_cpuPlotters [i].Draw ();  }  
Magic Number,ProcessHacker,SysInfoWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\SysInfoWindow.cs,UpdateGraphs,The following statement contains a magic number: for (int i = 0; i < _cpuPlotters.Length; i++) {  	_cpuPlotters [i].LineColor1 = Settings.Instance.PlotterCPUKernelColor;  	_cpuPlotters [i].LineColor2 = Settings.Instance.PlotterCPUUserColor;  	_cpuPlotters [i].Text = ((_cpuPlotters [i].Data1 [0] + _cpuPlotters [i].Data2 [0]) * 100).ToString ("F2") + "% (K: " + (_cpuPlotters [i].Data1 [0] * 100).ToString ("F2") + "%' U: " + (_cpuPlotters [i].Data2 [0] * 100).ToString ("F2") + "%)";  	_cpuPlotters [i].MoveGrid ();  	_cpuPlotters [i].Draw ();  }  
Magic Number,ProcessHacker,SysInfoWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\SysInfoWindow.cs,UpdateGraphs,The following statement contains a magic number: _cpuPlotters [i].Text = ((_cpuPlotters [i].Data1 [0] + _cpuPlotters [i].Data2 [0]) * 100).ToString ("F2") + "% (K: " + (_cpuPlotters [i].Data1 [0] * 100).ToString ("F2") + "%' U: " + (_cpuPlotters [i].Data2 [0] * 100).ToString ("F2") + "%)";  
Magic Number,ProcessHacker,SysInfoWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\SysInfoWindow.cs,UpdateGraphs,The following statement contains a magic number: _cpuPlotters [i].Text = ((_cpuPlotters [i].Data1 [0] + _cpuPlotters [i].Data2 [0]) * 100).ToString ("F2") + "% (K: " + (_cpuPlotters [i].Data1 [0] * 100).ToString ("F2") + "%' U: " + (_cpuPlotters [i].Data2 [0] * 100).ToString ("F2") + "%)";  
Magic Number,ProcessHacker,SysInfoWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\SysInfoWindow.cs,UpdateGraphs,The following statement contains a magic number: _cpuPlotters [i].Text = ((_cpuPlotters [i].Data1 [0] + _cpuPlotters [i].Data2 [0]) * 100).ToString ("F2") + "% (K: " + (_cpuPlotters [i].Data1 [0] * 100).ToString ("F2") + "%' U: " + (_cpuPlotters [i].Data2 [0] * 100).ToString ("F2") + "%)";  
Magic Number,ProcessHacker,SysInfoWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\SysInfoWindow.cs,UpdateGraphs,The following statement contains a magic number: plotterCPU.Text = ((plotterCPU.Data1 [0] + plotterCPU.Data2 [0]) * 100).ToString ("F2") + "% (K: " + (plotterCPU.Data1 [0] * 100).ToString ("F2") + "%' U: " + (plotterCPU.Data2 [0] * 100).ToString ("F2") + "%)";  
Magic Number,ProcessHacker,SysInfoWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\SysInfoWindow.cs,UpdateGraphs,The following statement contains a magic number: plotterCPU.Text = ((plotterCPU.Data1 [0] + plotterCPU.Data2 [0]) * 100).ToString ("F2") + "% (K: " + (plotterCPU.Data1 [0] * 100).ToString ("F2") + "%' U: " + (plotterCPU.Data2 [0] * 100).ToString ("F2") + "%)";  
Magic Number,ProcessHacker,SysInfoWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\SysInfoWindow.cs,UpdateGraphs,The following statement contains a magic number: plotterCPU.Text = ((plotterCPU.Data1 [0] + plotterCPU.Data2 [0]) * 100).ToString ("F2") + "% (K: " + (plotterCPU.Data1 [0] * 100).ToString ("F2") + "%' U: " + (plotterCPU.Data2 [0] * 100).ToString ("F2") + "%)";  
Magic Number,ProcessHacker,TerminatorWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\TerminatorWindow.cs,RunTest,The following statement contains a magic number: System.Threading.Thread.Sleep (1000);  
Magic Number,ProcessHacker,TerminatorWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\TerminatorWindow.cs,TP1a,The following statement contains a magic number: for (int count = 0; count < 1000; count++) {  	try {  		phandle = phandle.GetNextProcess (Program.MinProcessQueryRights | ProcessAccess.Terminate);  		if (phandle.GetProcessId () == _pid) {  			found = true;  			break;  		}  	}  	catch {  	}  }  
Magic Number,ProcessHacker,TerminatorWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\TerminatorWindow.cs,TT1a,The following statement contains a magic number: using (var phandle = new ProcessHandle (_pid' ProcessAccess.QueryInformation)) {  	ThreadHandle thandle = null;  	// Loop through the process' threads and terminate each one.  	for (int count = 0; count < 1000; count++) {  		try {  			thandle = phandle.GetNextThread (thandle' ThreadAccess.Terminate);  			thandle.Terminate ();  		}  		catch {  		}  	}  }  
Magic Number,ProcessHacker,TerminatorWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\TerminatorWindow.cs,TT1a,The following statement contains a magic number: for (int count = 0; count < 1000; count++) {  	try {  		thandle = phandle.GetNextThread (thandle' ThreadAccess.Terminate);  		thandle.Terminate ();  	}  	catch {  	}  }  
Magic Number,ProcessHacker,ProcessAffinity,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\ProcessAffinity.cs,ProcessAffinity,The following statement contains a magic number: try {  	using (ProcessHandle phandle = new ProcessHandle (pid' ProcessAccess.QueryInformation)) {  		long systemMask;  		long processMask;  		processMask = phandle.GetAffinityMask (out systemMask);  		for (int i = 0; (systemMask & (1 << i)) != 0; i++) {  			CheckBox c = new CheckBox ();  			c.Name = "cpu" + i.ToString ();  			c.Text = "CPU " + i.ToString ();  			c.Tag = i;  			c.FlatStyle = FlatStyle.System;  			c.Checked = (processMask & (1 << i)) != 0;  			c.Margin = new Padding (3' 3' 3' 0);  			flowPanel.Controls.Add (c);  		}  	}  }  catch (Exception ex) {  	PhUtils.ShowException ("Unable to get process affinity"' ex);  	this.Close ();  	return;  }  
Magic Number,ProcessHacker,ProcessAffinity,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\ProcessAffinity.cs,ProcessAffinity,The following statement contains a magic number: try {  	using (ProcessHandle phandle = new ProcessHandle (pid' ProcessAccess.QueryInformation)) {  		long systemMask;  		long processMask;  		processMask = phandle.GetAffinityMask (out systemMask);  		for (int i = 0; (systemMask & (1 << i)) != 0; i++) {  			CheckBox c = new CheckBox ();  			c.Name = "cpu" + i.ToString ();  			c.Text = "CPU " + i.ToString ();  			c.Tag = i;  			c.FlatStyle = FlatStyle.System;  			c.Checked = (processMask & (1 << i)) != 0;  			c.Margin = new Padding (3' 3' 3' 0);  			flowPanel.Controls.Add (c);  		}  	}  }  catch (Exception ex) {  	PhUtils.ShowException ("Unable to get process affinity"' ex);  	this.Close ();  	return;  }  
Magic Number,ProcessHacker,ProcessAffinity,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\ProcessAffinity.cs,ProcessAffinity,The following statement contains a magic number: try {  	using (ProcessHandle phandle = new ProcessHandle (pid' ProcessAccess.QueryInformation)) {  		long systemMask;  		long processMask;  		processMask = phandle.GetAffinityMask (out systemMask);  		for (int i = 0; (systemMask & (1 << i)) != 0; i++) {  			CheckBox c = new CheckBox ();  			c.Name = "cpu" + i.ToString ();  			c.Text = "CPU " + i.ToString ();  			c.Tag = i;  			c.FlatStyle = FlatStyle.System;  			c.Checked = (processMask & (1 << i)) != 0;  			c.Margin = new Padding (3' 3' 3' 0);  			flowPanel.Controls.Add (c);  		}  	}  }  catch (Exception ex) {  	PhUtils.ShowException ("Unable to get process affinity"' ex);  	this.Close ();  	return;  }  
Magic Number,ProcessHacker,ProcessAffinity,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\ProcessAffinity.cs,ProcessAffinity,The following statement contains a magic number: using (ProcessHandle phandle = new ProcessHandle (pid' ProcessAccess.QueryInformation)) {  	long systemMask;  	long processMask;  	processMask = phandle.GetAffinityMask (out systemMask);  	for (int i = 0; (systemMask & (1 << i)) != 0; i++) {  		CheckBox c = new CheckBox ();  		c.Name = "cpu" + i.ToString ();  		c.Text = "CPU " + i.ToString ();  		c.Tag = i;  		c.FlatStyle = FlatStyle.System;  		c.Checked = (processMask & (1 << i)) != 0;  		c.Margin = new Padding (3' 3' 3' 0);  		flowPanel.Controls.Add (c);  	}  }  
Magic Number,ProcessHacker,ProcessAffinity,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\ProcessAffinity.cs,ProcessAffinity,The following statement contains a magic number: using (ProcessHandle phandle = new ProcessHandle (pid' ProcessAccess.QueryInformation)) {  	long systemMask;  	long processMask;  	processMask = phandle.GetAffinityMask (out systemMask);  	for (int i = 0; (systemMask & (1 << i)) != 0; i++) {  		CheckBox c = new CheckBox ();  		c.Name = "cpu" + i.ToString ();  		c.Text = "CPU " + i.ToString ();  		c.Tag = i;  		c.FlatStyle = FlatStyle.System;  		c.Checked = (processMask & (1 << i)) != 0;  		c.Margin = new Padding (3' 3' 3' 0);  		flowPanel.Controls.Add (c);  	}  }  
Magic Number,ProcessHacker,ProcessAffinity,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\ProcessAffinity.cs,ProcessAffinity,The following statement contains a magic number: using (ProcessHandle phandle = new ProcessHandle (pid' ProcessAccess.QueryInformation)) {  	long systemMask;  	long processMask;  	processMask = phandle.GetAffinityMask (out systemMask);  	for (int i = 0; (systemMask & (1 << i)) != 0; i++) {  		CheckBox c = new CheckBox ();  		c.Name = "cpu" + i.ToString ();  		c.Text = "CPU " + i.ToString ();  		c.Tag = i;  		c.FlatStyle = FlatStyle.System;  		c.Checked = (processMask & (1 << i)) != 0;  		c.Margin = new Padding (3' 3' 3' 0);  		flowPanel.Controls.Add (c);  	}  }  
Magic Number,ProcessHacker,ProcessAffinity,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\ProcessAffinity.cs,ProcessAffinity,The following statement contains a magic number: for (int i = 0; (systemMask & (1 << i)) != 0; i++) {  	CheckBox c = new CheckBox ();  	c.Name = "cpu" + i.ToString ();  	c.Text = "CPU " + i.ToString ();  	c.Tag = i;  	c.FlatStyle = FlatStyle.System;  	c.Checked = (processMask & (1 << i)) != 0;  	c.Margin = new Padding (3' 3' 3' 0);  	flowPanel.Controls.Add (c);  }  
Magic Number,ProcessHacker,ProcessAffinity,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\ProcessAffinity.cs,ProcessAffinity,The following statement contains a magic number: for (int i = 0; (systemMask & (1 << i)) != 0; i++) {  	CheckBox c = new CheckBox ();  	c.Name = "cpu" + i.ToString ();  	c.Text = "CPU " + i.ToString ();  	c.Tag = i;  	c.FlatStyle = FlatStyle.System;  	c.Checked = (processMask & (1 << i)) != 0;  	c.Margin = new Padding (3' 3' 3' 0);  	flowPanel.Controls.Add (c);  }  
Magic Number,ProcessHacker,ProcessAffinity,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\ProcessAffinity.cs,ProcessAffinity,The following statement contains a magic number: for (int i = 0; (systemMask & (1 << i)) != 0; i++) {  	CheckBox c = new CheckBox ();  	c.Name = "cpu" + i.ToString ();  	c.Text = "CPU " + i.ToString ();  	c.Tag = i;  	c.FlatStyle = FlatStyle.System;  	c.Checked = (processMask & (1 << i)) != 0;  	c.Margin = new Padding (3' 3' 3' 0);  	flowPanel.Controls.Add (c);  }  
Magic Number,ProcessHacker,ProcessAffinity,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\ProcessAffinity.cs,ProcessAffinity,The following statement contains a magic number: c.Margin = new Padding (3' 3' 3' 0);  
Magic Number,ProcessHacker,ProcessAffinity,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\ProcessAffinity.cs,ProcessAffinity,The following statement contains a magic number: c.Margin = new Padding (3' 3' 3' 0);  
Magic Number,ProcessHacker,ProcessAffinity,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\ProcessAffinity.cs,ProcessAffinity,The following statement contains a magic number: c.Margin = new Padding (3' 3' 3' 0);  
Magic Number,ProcessHacker,HandleFilterWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HandleFilterWindow.cs,HandleFilterWindow,The following statement contains a magic number: comparer.ColumnSortOrder.Add (2);  
Magic Number,ProcessHacker,HandleFilterWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HandleFilterWindow.cs,HandleFilterWindow,The following statement contains a magic number: comparer.ColumnSortOrder.Add (3);  
Magic Number,ProcessHacker,HandleFilterWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HandleFilterWindow.cs,closeMenuItem_Click,The following statement contains a magic number: foreach (int index in listHandles.SelectedIndices) {  	if (listHandles.Items [index].SubItems [1].Text == "DLL" || listHandles.Items [index].SubItems [1].Text == "Mapped File")  		continue;  	try {  		IntPtr handle = new IntPtr ((int)BaseConverter.ToNumberParse (listHandles.Items [index].SubItems [3].Text));  		using (ProcessHandle process = new ProcessHandle (((SystemHandleEntry)listHandles.SelectedItems [0].Tag).ProcessId' ProcessAccess.DupHandle)) {  			Win32.DuplicateObject (process.Handle' handle' 0' 0' DuplicateOptions.CloseSource);  			remove.Add (listHandles.Items [index]);  		}  	}  	catch (Exception ex) {  		if (!PhUtils.ShowContinueMessage ("Unable to close the handle \"" + listHandles.Items [index].SubItems [2].Text + "\""' ex))  			return;  	}  }  
Magic Number,ProcessHacker,HandleFilterWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HandleFilterWindow.cs,closeMenuItem_Click,The following statement contains a magic number: foreach (int index in listHandles.SelectedIndices) {  	if (listHandles.Items [index].SubItems [1].Text == "DLL" || listHandles.Items [index].SubItems [1].Text == "Mapped File")  		continue;  	try {  		IntPtr handle = new IntPtr ((int)BaseConverter.ToNumberParse (listHandles.Items [index].SubItems [3].Text));  		using (ProcessHandle process = new ProcessHandle (((SystemHandleEntry)listHandles.SelectedItems [0].Tag).ProcessId' ProcessAccess.DupHandle)) {  			Win32.DuplicateObject (process.Handle' handle' 0' 0' DuplicateOptions.CloseSource);  			remove.Add (listHandles.Items [index]);  		}  	}  	catch (Exception ex) {  		if (!PhUtils.ShowContinueMessage ("Unable to close the handle \"" + listHandles.Items [index].SubItems [2].Text + "\""' ex))  			return;  	}  }  
Magic Number,ProcessHacker,HandleFilterWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HandleFilterWindow.cs,closeMenuItem_Click,The following statement contains a magic number: try {  	IntPtr handle = new IntPtr ((int)BaseConverter.ToNumberParse (listHandles.Items [index].SubItems [3].Text));  	using (ProcessHandle process = new ProcessHandle (((SystemHandleEntry)listHandles.SelectedItems [0].Tag).ProcessId' ProcessAccess.DupHandle)) {  		Win32.DuplicateObject (process.Handle' handle' 0' 0' DuplicateOptions.CloseSource);  		remove.Add (listHandles.Items [index]);  	}  }  catch (Exception ex) {  	if (!PhUtils.ShowContinueMessage ("Unable to close the handle \"" + listHandles.Items [index].SubItems [2].Text + "\""' ex))  		return;  }  
Magic Number,ProcessHacker,HandleFilterWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HandleFilterWindow.cs,closeMenuItem_Click,The following statement contains a magic number: try {  	IntPtr handle = new IntPtr ((int)BaseConverter.ToNumberParse (listHandles.Items [index].SubItems [3].Text));  	using (ProcessHandle process = new ProcessHandle (((SystemHandleEntry)listHandles.SelectedItems [0].Tag).ProcessId' ProcessAccess.DupHandle)) {  		Win32.DuplicateObject (process.Handle' handle' 0' 0' DuplicateOptions.CloseSource);  		remove.Add (listHandles.Items [index]);  	}  }  catch (Exception ex) {  	if (!PhUtils.ShowContinueMessage ("Unable to close the handle \"" + listHandles.Items [index].SubItems [2].Text + "\""' ex))  		return;  }  
Magic Number,ProcessHacker,HandleFilterWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HandleFilterWindow.cs,closeMenuItem_Click,The following statement contains a magic number: if (!PhUtils.ShowContinueMessage ("Unable to close the handle \"" + listHandles.Items [index].SubItems [2].Text + "\""' ex))  	return;  
Magic Number,ProcessHacker,HandleFilterWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HandleFilterWindow.cs,propertiesMenuItem_Click,The following statement contains a magic number: if (type == "DLL" || type == "Mapped File") {  	FileUtils.ShowProperties (listHandles.SelectedItems [0].SubItems [2].Text);  	return;  }  
Magic Number,ProcessHacker,HandleFilterWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HandleFilterWindow.cs,propertiesMenuItem_Click,The following statement contains a magic number: FileUtils.ShowProperties (listHandles.SelectedItems [0].SubItems [2].Text);  
Magic Number,ProcessHacker,RunWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\RunWindow.cs,buttonOK_Click,The following statement contains a magic number: try {  	string binPath;  	string mailslotName;  	bool omitUserAndType = false;  	if (_pid != -1)  		omitUserAndType = true;  	mailslotName = "ProcessHackerAssistant" + Utils.CreateRandomString (8);  	binPath = "\"" + Application.ExecutablePath + "\" -assistant " + (omitUserAndType ? "" : ("-u \"" + comboUsername.Text + "\" -t " + comboType.SelectedItem.ToString ().ToLowerInvariant () + " ")) + (_pid != -1 ? ("-P " + _pid.ToString () + " ") : "") + "-p \"" + textPassword.Text.Replace ("\""' "\\\"") + "\" -s " + textSessionID.Text + " -c \"" + textCmdLine.Text.Replace ("\""' "\\\"") + "\" -E " + mailslotName;  	if (Program.ElevationType == TokenElevationType.Limited) {  		var result = Program.StartProcessHackerAdminWait ("-e -type processhacker -action runas -obj \"" + binPath.Replace ("\""' "\\\"") + "\" -mailslot " + mailslotName + " -hwnd " + this.Handle.ToString ()' this.Handle' 5000);  		if (result == WaitResult.Object0)  			this.Close ();  	}  	else {  		string serviceName = Utils.CreateRandomString (8);  		using (var manager = new ServiceManagerHandle (ScManagerAccess.CreateService)) {  			using (var service = manager.CreateService (serviceName' serviceName + " (Process Hacker Assistant)"' ServiceType.Win32OwnProcess' ServiceStartType.DemandStart' ServiceErrorControl.Ignore' binPath' ""' "LocalSystem"' null)) {  				// Create a mailslot so we can receive the error code for Assistant.  				using (var mhandle = MailslotHandle.Create (FileAccess.GenericRead' @"\Device\Mailslot\" + mailslotName' 0' 5000)) {  					try {  						service.Start ();  					}  					catch {  					}  					service.Delete ();  					Win32Error errorCode = (Win32Error)mhandle.Read (4).ToInt32 ();  					if (errorCode != Win32Error.Success)  						throw new WindowsException (errorCode);  				}  			}  		}  		this.Close ();  	}  }  catch (Exception ex) {  	PhUtils.ShowException ("Unable to start the program"' ex);  }  
Magic Number,ProcessHacker,RunWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\RunWindow.cs,buttonOK_Click,The following statement contains a magic number: try {  	string binPath;  	string mailslotName;  	bool omitUserAndType = false;  	if (_pid != -1)  		omitUserAndType = true;  	mailslotName = "ProcessHackerAssistant" + Utils.CreateRandomString (8);  	binPath = "\"" + Application.ExecutablePath + "\" -assistant " + (omitUserAndType ? "" : ("-u \"" + comboUsername.Text + "\" -t " + comboType.SelectedItem.ToString ().ToLowerInvariant () + " ")) + (_pid != -1 ? ("-P " + _pid.ToString () + " ") : "") + "-p \"" + textPassword.Text.Replace ("\""' "\\\"") + "\" -s " + textSessionID.Text + " -c \"" + textCmdLine.Text.Replace ("\""' "\\\"") + "\" -E " + mailslotName;  	if (Program.ElevationType == TokenElevationType.Limited) {  		var result = Program.StartProcessHackerAdminWait ("-e -type processhacker -action runas -obj \"" + binPath.Replace ("\""' "\\\"") + "\" -mailslot " + mailslotName + " -hwnd " + this.Handle.ToString ()' this.Handle' 5000);  		if (result == WaitResult.Object0)  			this.Close ();  	}  	else {  		string serviceName = Utils.CreateRandomString (8);  		using (var manager = new ServiceManagerHandle (ScManagerAccess.CreateService)) {  			using (var service = manager.CreateService (serviceName' serviceName + " (Process Hacker Assistant)"' ServiceType.Win32OwnProcess' ServiceStartType.DemandStart' ServiceErrorControl.Ignore' binPath' ""' "LocalSystem"' null)) {  				// Create a mailslot so we can receive the error code for Assistant.  				using (var mhandle = MailslotHandle.Create (FileAccess.GenericRead' @"\Device\Mailslot\" + mailslotName' 0' 5000)) {  					try {  						service.Start ();  					}  					catch {  					}  					service.Delete ();  					Win32Error errorCode = (Win32Error)mhandle.Read (4).ToInt32 ();  					if (errorCode != Win32Error.Success)  						throw new WindowsException (errorCode);  				}  			}  		}  		this.Close ();  	}  }  catch (Exception ex) {  	PhUtils.ShowException ("Unable to start the program"' ex);  }  
Magic Number,ProcessHacker,RunWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\RunWindow.cs,buttonOK_Click,The following statement contains a magic number: try {  	string binPath;  	string mailslotName;  	bool omitUserAndType = false;  	if (_pid != -1)  		omitUserAndType = true;  	mailslotName = "ProcessHackerAssistant" + Utils.CreateRandomString (8);  	binPath = "\"" + Application.ExecutablePath + "\" -assistant " + (omitUserAndType ? "" : ("-u \"" + comboUsername.Text + "\" -t " + comboType.SelectedItem.ToString ().ToLowerInvariant () + " ")) + (_pid != -1 ? ("-P " + _pid.ToString () + " ") : "") + "-p \"" + textPassword.Text.Replace ("\""' "\\\"") + "\" -s " + textSessionID.Text + " -c \"" + textCmdLine.Text.Replace ("\""' "\\\"") + "\" -E " + mailslotName;  	if (Program.ElevationType == TokenElevationType.Limited) {  		var result = Program.StartProcessHackerAdminWait ("-e -type processhacker -action runas -obj \"" + binPath.Replace ("\""' "\\\"") + "\" -mailslot " + mailslotName + " -hwnd " + this.Handle.ToString ()' this.Handle' 5000);  		if (result == WaitResult.Object0)  			this.Close ();  	}  	else {  		string serviceName = Utils.CreateRandomString (8);  		using (var manager = new ServiceManagerHandle (ScManagerAccess.CreateService)) {  			using (var service = manager.CreateService (serviceName' serviceName + " (Process Hacker Assistant)"' ServiceType.Win32OwnProcess' ServiceStartType.DemandStart' ServiceErrorControl.Ignore' binPath' ""' "LocalSystem"' null)) {  				// Create a mailslot so we can receive the error code for Assistant.  				using (var mhandle = MailslotHandle.Create (FileAccess.GenericRead' @"\Device\Mailslot\" + mailslotName' 0' 5000)) {  					try {  						service.Start ();  					}  					catch {  					}  					service.Delete ();  					Win32Error errorCode = (Win32Error)mhandle.Read (4).ToInt32 ();  					if (errorCode != Win32Error.Success)  						throw new WindowsException (errorCode);  				}  			}  		}  		this.Close ();  	}  }  catch (Exception ex) {  	PhUtils.ShowException ("Unable to start the program"' ex);  }  
Magic Number,ProcessHacker,RunWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\RunWindow.cs,buttonOK_Click,The following statement contains a magic number: try {  	string binPath;  	string mailslotName;  	bool omitUserAndType = false;  	if (_pid != -1)  		omitUserAndType = true;  	mailslotName = "ProcessHackerAssistant" + Utils.CreateRandomString (8);  	binPath = "\"" + Application.ExecutablePath + "\" -assistant " + (omitUserAndType ? "" : ("-u \"" + comboUsername.Text + "\" -t " + comboType.SelectedItem.ToString ().ToLowerInvariant () + " ")) + (_pid != -1 ? ("-P " + _pid.ToString () + " ") : "") + "-p \"" + textPassword.Text.Replace ("\""' "\\\"") + "\" -s " + textSessionID.Text + " -c \"" + textCmdLine.Text.Replace ("\""' "\\\"") + "\" -E " + mailslotName;  	if (Program.ElevationType == TokenElevationType.Limited) {  		var result = Program.StartProcessHackerAdminWait ("-e -type processhacker -action runas -obj \"" + binPath.Replace ("\""' "\\\"") + "\" -mailslot " + mailslotName + " -hwnd " + this.Handle.ToString ()' this.Handle' 5000);  		if (result == WaitResult.Object0)  			this.Close ();  	}  	else {  		string serviceName = Utils.CreateRandomString (8);  		using (var manager = new ServiceManagerHandle (ScManagerAccess.CreateService)) {  			using (var service = manager.CreateService (serviceName' serviceName + " (Process Hacker Assistant)"' ServiceType.Win32OwnProcess' ServiceStartType.DemandStart' ServiceErrorControl.Ignore' binPath' ""' "LocalSystem"' null)) {  				// Create a mailslot so we can receive the error code for Assistant.  				using (var mhandle = MailslotHandle.Create (FileAccess.GenericRead' @"\Device\Mailslot\" + mailslotName' 0' 5000)) {  					try {  						service.Start ();  					}  					catch {  					}  					service.Delete ();  					Win32Error errorCode = (Win32Error)mhandle.Read (4).ToInt32 ();  					if (errorCode != Win32Error.Success)  						throw new WindowsException (errorCode);  				}  			}  		}  		this.Close ();  	}  }  catch (Exception ex) {  	PhUtils.ShowException ("Unable to start the program"' ex);  }  
Magic Number,ProcessHacker,RunWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\RunWindow.cs,buttonOK_Click,The following statement contains a magic number: try {  	string binPath;  	string mailslotName;  	bool omitUserAndType = false;  	if (_pid != -1)  		omitUserAndType = true;  	mailslotName = "ProcessHackerAssistant" + Utils.CreateRandomString (8);  	binPath = "\"" + Application.ExecutablePath + "\" -assistant " + (omitUserAndType ? "" : ("-u \"" + comboUsername.Text + "\" -t " + comboType.SelectedItem.ToString ().ToLowerInvariant () + " ")) + (_pid != -1 ? ("-P " + _pid.ToString () + " ") : "") + "-p \"" + textPassword.Text.Replace ("\""' "\\\"") + "\" -s " + textSessionID.Text + " -c \"" + textCmdLine.Text.Replace ("\""' "\\\"") + "\" -E " + mailslotName;  	if (Program.ElevationType == TokenElevationType.Limited) {  		var result = Program.StartProcessHackerAdminWait ("-e -type processhacker -action runas -obj \"" + binPath.Replace ("\""' "\\\"") + "\" -mailslot " + mailslotName + " -hwnd " + this.Handle.ToString ()' this.Handle' 5000);  		if (result == WaitResult.Object0)  			this.Close ();  	}  	else {  		string serviceName = Utils.CreateRandomString (8);  		using (var manager = new ServiceManagerHandle (ScManagerAccess.CreateService)) {  			using (var service = manager.CreateService (serviceName' serviceName + " (Process Hacker Assistant)"' ServiceType.Win32OwnProcess' ServiceStartType.DemandStart' ServiceErrorControl.Ignore' binPath' ""' "LocalSystem"' null)) {  				// Create a mailslot so we can receive the error code for Assistant.  				using (var mhandle = MailslotHandle.Create (FileAccess.GenericRead' @"\Device\Mailslot\" + mailslotName' 0' 5000)) {  					try {  						service.Start ();  					}  					catch {  					}  					service.Delete ();  					Win32Error errorCode = (Win32Error)mhandle.Read (4).ToInt32 ();  					if (errorCode != Win32Error.Success)  						throw new WindowsException (errorCode);  				}  			}  		}  		this.Close ();  	}  }  catch (Exception ex) {  	PhUtils.ShowException ("Unable to start the program"' ex);  }  
Magic Number,ProcessHacker,RunWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\RunWindow.cs,buttonOK_Click,The following statement contains a magic number: mailslotName = "ProcessHackerAssistant" + Utils.CreateRandomString (8);  
Magic Number,ProcessHacker,RunWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\RunWindow.cs,buttonOK_Click,The following statement contains a magic number: if (Program.ElevationType == TokenElevationType.Limited) {  	var result = Program.StartProcessHackerAdminWait ("-e -type processhacker -action runas -obj \"" + binPath.Replace ("\""' "\\\"") + "\" -mailslot " + mailslotName + " -hwnd " + this.Handle.ToString ()' this.Handle' 5000);  	if (result == WaitResult.Object0)  		this.Close ();  }  else {  	string serviceName = Utils.CreateRandomString (8);  	using (var manager = new ServiceManagerHandle (ScManagerAccess.CreateService)) {  		using (var service = manager.CreateService (serviceName' serviceName + " (Process Hacker Assistant)"' ServiceType.Win32OwnProcess' ServiceStartType.DemandStart' ServiceErrorControl.Ignore' binPath' ""' "LocalSystem"' null)) {  			// Create a mailslot so we can receive the error code for Assistant.  			using (var mhandle = MailslotHandle.Create (FileAccess.GenericRead' @"\Device\Mailslot\" + mailslotName' 0' 5000)) {  				try {  					service.Start ();  				}  				catch {  				}  				service.Delete ();  				Win32Error errorCode = (Win32Error)mhandle.Read (4).ToInt32 ();  				if (errorCode != Win32Error.Success)  					throw new WindowsException (errorCode);  			}  		}  	}  	this.Close ();  }  
Magic Number,ProcessHacker,RunWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\RunWindow.cs,buttonOK_Click,The following statement contains a magic number: if (Program.ElevationType == TokenElevationType.Limited) {  	var result = Program.StartProcessHackerAdminWait ("-e -type processhacker -action runas -obj \"" + binPath.Replace ("\""' "\\\"") + "\" -mailslot " + mailslotName + " -hwnd " + this.Handle.ToString ()' this.Handle' 5000);  	if (result == WaitResult.Object0)  		this.Close ();  }  else {  	string serviceName = Utils.CreateRandomString (8);  	using (var manager = new ServiceManagerHandle (ScManagerAccess.CreateService)) {  		using (var service = manager.CreateService (serviceName' serviceName + " (Process Hacker Assistant)"' ServiceType.Win32OwnProcess' ServiceStartType.DemandStart' ServiceErrorControl.Ignore' binPath' ""' "LocalSystem"' null)) {  			// Create a mailslot so we can receive the error code for Assistant.  			using (var mhandle = MailslotHandle.Create (FileAccess.GenericRead' @"\Device\Mailslot\" + mailslotName' 0' 5000)) {  				try {  					service.Start ();  				}  				catch {  				}  				service.Delete ();  				Win32Error errorCode = (Win32Error)mhandle.Read (4).ToInt32 ();  				if (errorCode != Win32Error.Success)  					throw new WindowsException (errorCode);  			}  		}  	}  	this.Close ();  }  
Magic Number,ProcessHacker,RunWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\RunWindow.cs,buttonOK_Click,The following statement contains a magic number: if (Program.ElevationType == TokenElevationType.Limited) {  	var result = Program.StartProcessHackerAdminWait ("-e -type processhacker -action runas -obj \"" + binPath.Replace ("\""' "\\\"") + "\" -mailslot " + mailslotName + " -hwnd " + this.Handle.ToString ()' this.Handle' 5000);  	if (result == WaitResult.Object0)  		this.Close ();  }  else {  	string serviceName = Utils.CreateRandomString (8);  	using (var manager = new ServiceManagerHandle (ScManagerAccess.CreateService)) {  		using (var service = manager.CreateService (serviceName' serviceName + " (Process Hacker Assistant)"' ServiceType.Win32OwnProcess' ServiceStartType.DemandStart' ServiceErrorControl.Ignore' binPath' ""' "LocalSystem"' null)) {  			// Create a mailslot so we can receive the error code for Assistant.  			using (var mhandle = MailslotHandle.Create (FileAccess.GenericRead' @"\Device\Mailslot\" + mailslotName' 0' 5000)) {  				try {  					service.Start ();  				}  				catch {  				}  				service.Delete ();  				Win32Error errorCode = (Win32Error)mhandle.Read (4).ToInt32 ();  				if (errorCode != Win32Error.Success)  					throw new WindowsException (errorCode);  			}  		}  	}  	this.Close ();  }  
Magic Number,ProcessHacker,RunWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\RunWindow.cs,buttonOK_Click,The following statement contains a magic number: if (Program.ElevationType == TokenElevationType.Limited) {  	var result = Program.StartProcessHackerAdminWait ("-e -type processhacker -action runas -obj \"" + binPath.Replace ("\""' "\\\"") + "\" -mailslot " + mailslotName + " -hwnd " + this.Handle.ToString ()' this.Handle' 5000);  	if (result == WaitResult.Object0)  		this.Close ();  }  else {  	string serviceName = Utils.CreateRandomString (8);  	using (var manager = new ServiceManagerHandle (ScManagerAccess.CreateService)) {  		using (var service = manager.CreateService (serviceName' serviceName + " (Process Hacker Assistant)"' ServiceType.Win32OwnProcess' ServiceStartType.DemandStart' ServiceErrorControl.Ignore' binPath' ""' "LocalSystem"' null)) {  			// Create a mailslot so we can receive the error code for Assistant.  			using (var mhandle = MailslotHandle.Create (FileAccess.GenericRead' @"\Device\Mailslot\" + mailslotName' 0' 5000)) {  				try {  					service.Start ();  				}  				catch {  				}  				service.Delete ();  				Win32Error errorCode = (Win32Error)mhandle.Read (4).ToInt32 ();  				if (errorCode != Win32Error.Success)  					throw new WindowsException (errorCode);  			}  		}  	}  	this.Close ();  }  
Magic Number,ProcessHacker,RunWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\RunWindow.cs,buttonOK_Click,The following statement contains a magic number: using (var manager = new ServiceManagerHandle (ScManagerAccess.CreateService)) {  	using (var service = manager.CreateService (serviceName' serviceName + " (Process Hacker Assistant)"' ServiceType.Win32OwnProcess' ServiceStartType.DemandStart' ServiceErrorControl.Ignore' binPath' ""' "LocalSystem"' null)) {  		// Create a mailslot so we can receive the error code for Assistant.  		using (var mhandle = MailslotHandle.Create (FileAccess.GenericRead' @"\Device\Mailslot\" + mailslotName' 0' 5000)) {  			try {  				service.Start ();  			}  			catch {  			}  			service.Delete ();  			Win32Error errorCode = (Win32Error)mhandle.Read (4).ToInt32 ();  			if (errorCode != Win32Error.Success)  				throw new WindowsException (errorCode);  		}  	}  }  
Magic Number,ProcessHacker,RunWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\RunWindow.cs,buttonOK_Click,The following statement contains a magic number: using (var manager = new ServiceManagerHandle (ScManagerAccess.CreateService)) {  	using (var service = manager.CreateService (serviceName' serviceName + " (Process Hacker Assistant)"' ServiceType.Win32OwnProcess' ServiceStartType.DemandStart' ServiceErrorControl.Ignore' binPath' ""' "LocalSystem"' null)) {  		// Create a mailslot so we can receive the error code for Assistant.  		using (var mhandle = MailslotHandle.Create (FileAccess.GenericRead' @"\Device\Mailslot\" + mailslotName' 0' 5000)) {  			try {  				service.Start ();  			}  			catch {  			}  			service.Delete ();  			Win32Error errorCode = (Win32Error)mhandle.Read (4).ToInt32 ();  			if (errorCode != Win32Error.Success)  				throw new WindowsException (errorCode);  		}  	}  }  
Magic Number,ProcessHacker,RunWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\RunWindow.cs,buttonOK_Click,The following statement contains a magic number: using (var service = manager.CreateService (serviceName' serviceName + " (Process Hacker Assistant)"' ServiceType.Win32OwnProcess' ServiceStartType.DemandStart' ServiceErrorControl.Ignore' binPath' ""' "LocalSystem"' null)) {  	// Create a mailslot so we can receive the error code for Assistant.  	using (var mhandle = MailslotHandle.Create (FileAccess.GenericRead' @"\Device\Mailslot\" + mailslotName' 0' 5000)) {  		try {  			service.Start ();  		}  		catch {  		}  		service.Delete ();  		Win32Error errorCode = (Win32Error)mhandle.Read (4).ToInt32 ();  		if (errorCode != Win32Error.Success)  			throw new WindowsException (errorCode);  	}  }  
Magic Number,ProcessHacker,RunWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\RunWindow.cs,buttonOK_Click,The following statement contains a magic number: using (var service = manager.CreateService (serviceName' serviceName + " (Process Hacker Assistant)"' ServiceType.Win32OwnProcess' ServiceStartType.DemandStart' ServiceErrorControl.Ignore' binPath' ""' "LocalSystem"' null)) {  	// Create a mailslot so we can receive the error code for Assistant.  	using (var mhandle = MailslotHandle.Create (FileAccess.GenericRead' @"\Device\Mailslot\" + mailslotName' 0' 5000)) {  		try {  			service.Start ();  		}  		catch {  		}  		service.Delete ();  		Win32Error errorCode = (Win32Error)mhandle.Read (4).ToInt32 ();  		if (errorCode != Win32Error.Success)  			throw new WindowsException (errorCode);  	}  }  
Magic Number,ProcessHacker,RunWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\RunWindow.cs,buttonOK_Click,The following statement contains a magic number: using (var mhandle = MailslotHandle.Create (FileAccess.GenericRead' @"\Device\Mailslot\" + mailslotName' 0' 5000)) {  	try {  		service.Start ();  	}  	catch {  	}  	service.Delete ();  	Win32Error errorCode = (Win32Error)mhandle.Read (4).ToInt32 ();  	if (errorCode != Win32Error.Success)  		throw new WindowsException (errorCode);  }  
Magic Number,ProcessHacker,RunWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\RunWindow.cs,buttonOK_Click,The following statement contains a magic number: using (var mhandle = MailslotHandle.Create (FileAccess.GenericRead' @"\Device\Mailslot\" + mailslotName' 0' 5000)) {  	try {  		service.Start ();  	}  	catch {  	}  	service.Delete ();  	Win32Error errorCode = (Win32Error)mhandle.Read (4).ToInt32 ();  	if (errorCode != Win32Error.Success)  		throw new WindowsException (errorCode);  }  
Magic Number,ProcessHacker,PlotterIcon,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\UI\Icons\PlotterIcon.cs,PlotterIcon,The following statement contains a magic number: _dataHistory1 = new CircularBuffer<float> (20);  
Magic Number,ProcessHacker,PlotterIcon,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\UI\Icons\PlotterIcon.cs,PlotterIcon,The following statement contains a magic number: _dataHistory2 = new CircularBuffer<float> (20);  
Magic Number,ProcessHacker,PlotterIcon,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\UI\Icons\PlotterIcon.cs,PlotterIcon,The following statement contains a magic number: _longDataHistory1 = new CircularBuffer<long> (20);  
Magic Number,ProcessHacker,PlotterIcon,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\UI\Icons\PlotterIcon.cs,PlotterIcon,The following statement contains a magic number: _longDataHistory2 = new CircularBuffer<long> (20);  
Magic Number,ProcessHacker,PlotterIcon,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\UI\Icons\PlotterIcon.cs,PlotterIcon,The following statement contains a magic number: _plotter = new Plotter () {  	Size = this.Size'  	ShowGrid = false'  	BackColor = Color.Black'  	MoveStep = 2'  	Data1 = _dataHistory1'  	Data2 = _dataHistory2'  	LongData1 = _longDataHistory1'  	LongData2 = _longDataHistory2  };  
Magic Number,ProcessHacker,ProcessSystemProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ProcessSystemProvider.cs,QueryProcessStage1,The following statement contains a magic number: if (pid > 4) {  	try {  		using (var phandle = new ProcessHandle (pid' Program.MinProcessQueryRights | Program.MinProcessReadMemoryRights)) {  			fpResult.CmdLine = phandle.GetCommandLine ();  			fpResult.IsPosix = phandle.IsPosix ();  		}  	}  	catch {  	}  }  
Magic Number,ProcessHacker,ProcessSystemProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ProcessSystemProvider.cs,QueryProcessStage1a,The following statement contains a magic number: if (pid > 4) {  	try {  		fpResult.IsDotNet = PhUtils.IsDotNetProcess (pid);  	}  	catch {  	}  }  
Magic Number,ProcessHacker,ProcessSystemProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ProcessSystemProvider.cs,QueryProcessStage2,The following statement contains a magic number: try {  	if ((new global::System.IO.FileInfo (fileName)).Length > 32 * 1024 * 1024)  		return null;  }  catch {  	return null;  }  
Magic Number,ProcessHacker,ProcessSystemProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ProcessSystemProvider.cs,QueryProcessStage2,The following statement contains a magic number: try {  	if ((new global::System.IO.FileInfo (fileName)).Length > 32 * 1024 * 1024)  		return null;  }  catch {  	return null;  }  
Magic Number,ProcessHacker,ProcessSystemProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ProcessSystemProvider.cs,QueryProcessStage2,The following statement contains a magic number: try {  	if ((new global::System.IO.FileInfo (fileName)).Length > 32 * 1024 * 1024)  		return null;  }  catch {  	return null;  }  
Magic Number,ProcessHacker,ProcessSystemProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ProcessSystemProvider.cs,QueryProcessStage2,The following statement contains a magic number: if ((new global::System.IO.FileInfo (fileName)).Length > 32 * 1024 * 1024)  	return null;  
Magic Number,ProcessHacker,ProcessSystemProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ProcessSystemProvider.cs,QueryProcessStage2,The following statement contains a magic number: if ((new global::System.IO.FileInfo (fileName)).Length > 32 * 1024 * 1024)  	return null;  
Magic Number,ProcessHacker,ProcessSystemProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ProcessSystemProvider.cs,QueryProcessStage2,The following statement contains a magic number: if ((new global::System.IO.FileInfo (fileName)).Length > 32 * 1024 * 1024)  	return null;  
Magic Number,ProcessHacker,ProcessSystemProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ProcessSystemProvider.cs,QueryProcessStage2,The following statement contains a magic number: if (fileName != null && (Settings.Instance.VerifySignatures || forced)) {  	try {  		using (var mappedImage = new MappedImage (fileName)) {  			int libraryTotal = mappedImage.Imports.Count;  			int funcTotal = 0;  			for (int i = 0; i < mappedImage.Imports.Count; i++)  				funcTotal += mappedImage.Imports [i].Count;  			fpResult.ImportModules = libraryTotal;  			fpResult.ImportFunctions = funcTotal;  			if (libraryTotal < 3 && funcTotal < 5 || ((float)funcTotal / libraryTotal < 4) && libraryTotal > 3 && libraryTotal < 30)  				fpResult.IsPacked = true;  		}  	}  	catch (AccessViolationException) {  		if (pid > 4)  			fpResult.IsPacked = true;  	}  	catch {  	}  }  
Magic Number,ProcessHacker,ProcessSystemProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ProcessSystemProvider.cs,QueryProcessStage2,The following statement contains a magic number: if (fileName != null && (Settings.Instance.VerifySignatures || forced)) {  	try {  		using (var mappedImage = new MappedImage (fileName)) {  			int libraryTotal = mappedImage.Imports.Count;  			int funcTotal = 0;  			for (int i = 0; i < mappedImage.Imports.Count; i++)  				funcTotal += mappedImage.Imports [i].Count;  			fpResult.ImportModules = libraryTotal;  			fpResult.ImportFunctions = funcTotal;  			if (libraryTotal < 3 && funcTotal < 5 || ((float)funcTotal / libraryTotal < 4) && libraryTotal > 3 && libraryTotal < 30)  				fpResult.IsPacked = true;  		}  	}  	catch (AccessViolationException) {  		if (pid > 4)  			fpResult.IsPacked = true;  	}  	catch {  	}  }  
Magic Number,ProcessHacker,ProcessSystemProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ProcessSystemProvider.cs,QueryProcessStage2,The following statement contains a magic number: if (fileName != null && (Settings.Instance.VerifySignatures || forced)) {  	try {  		using (var mappedImage = new MappedImage (fileName)) {  			int libraryTotal = mappedImage.Imports.Count;  			int funcTotal = 0;  			for (int i = 0; i < mappedImage.Imports.Count; i++)  				funcTotal += mappedImage.Imports [i].Count;  			fpResult.ImportModules = libraryTotal;  			fpResult.ImportFunctions = funcTotal;  			if (libraryTotal < 3 && funcTotal < 5 || ((float)funcTotal / libraryTotal < 4) && libraryTotal > 3 && libraryTotal < 30)  				fpResult.IsPacked = true;  		}  	}  	catch (AccessViolationException) {  		if (pid > 4)  			fpResult.IsPacked = true;  	}  	catch {  	}  }  
Magic Number,ProcessHacker,ProcessSystemProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ProcessSystemProvider.cs,QueryProcessStage2,The following statement contains a magic number: if (fileName != null && (Settings.Instance.VerifySignatures || forced)) {  	try {  		using (var mappedImage = new MappedImage (fileName)) {  			int libraryTotal = mappedImage.Imports.Count;  			int funcTotal = 0;  			for (int i = 0; i < mappedImage.Imports.Count; i++)  				funcTotal += mappedImage.Imports [i].Count;  			fpResult.ImportModules = libraryTotal;  			fpResult.ImportFunctions = funcTotal;  			if (libraryTotal < 3 && funcTotal < 5 || ((float)funcTotal / libraryTotal < 4) && libraryTotal > 3 && libraryTotal < 30)  				fpResult.IsPacked = true;  		}  	}  	catch (AccessViolationException) {  		if (pid > 4)  			fpResult.IsPacked = true;  	}  	catch {  	}  }  
Magic Number,ProcessHacker,ProcessSystemProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ProcessSystemProvider.cs,QueryProcessStage2,The following statement contains a magic number: if (fileName != null && (Settings.Instance.VerifySignatures || forced)) {  	try {  		using (var mappedImage = new MappedImage (fileName)) {  			int libraryTotal = mappedImage.Imports.Count;  			int funcTotal = 0;  			for (int i = 0; i < mappedImage.Imports.Count; i++)  				funcTotal += mappedImage.Imports [i].Count;  			fpResult.ImportModules = libraryTotal;  			fpResult.ImportFunctions = funcTotal;  			if (libraryTotal < 3 && funcTotal < 5 || ((float)funcTotal / libraryTotal < 4) && libraryTotal > 3 && libraryTotal < 30)  				fpResult.IsPacked = true;  		}  	}  	catch (AccessViolationException) {  		if (pid > 4)  			fpResult.IsPacked = true;  	}  	catch {  	}  }  
Magic Number,ProcessHacker,ProcessSystemProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ProcessSystemProvider.cs,QueryProcessStage2,The following statement contains a magic number: if (fileName != null && (Settings.Instance.VerifySignatures || forced)) {  	try {  		using (var mappedImage = new MappedImage (fileName)) {  			int libraryTotal = mappedImage.Imports.Count;  			int funcTotal = 0;  			for (int i = 0; i < mappedImage.Imports.Count; i++)  				funcTotal += mappedImage.Imports [i].Count;  			fpResult.ImportModules = libraryTotal;  			fpResult.ImportFunctions = funcTotal;  			if (libraryTotal < 3 && funcTotal < 5 || ((float)funcTotal / libraryTotal < 4) && libraryTotal > 3 && libraryTotal < 30)  				fpResult.IsPacked = true;  		}  	}  	catch (AccessViolationException) {  		if (pid > 4)  			fpResult.IsPacked = true;  	}  	catch {  	}  }  
Magic Number,ProcessHacker,ProcessSystemProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ProcessSystemProvider.cs,QueryProcessStage2,The following statement contains a magic number: try {  	using (var mappedImage = new MappedImage (fileName)) {  		int libraryTotal = mappedImage.Imports.Count;  		int funcTotal = 0;  		for (int i = 0; i < mappedImage.Imports.Count; i++)  			funcTotal += mappedImage.Imports [i].Count;  		fpResult.ImportModules = libraryTotal;  		fpResult.ImportFunctions = funcTotal;  		if (libraryTotal < 3 && funcTotal < 5 || ((float)funcTotal / libraryTotal < 4) && libraryTotal > 3 && libraryTotal < 30)  			fpResult.IsPacked = true;  	}  }  catch (AccessViolationException) {  	if (pid > 4)  		fpResult.IsPacked = true;  }  catch {  }  
Magic Number,ProcessHacker,ProcessSystemProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ProcessSystemProvider.cs,QueryProcessStage2,The following statement contains a magic number: try {  	using (var mappedImage = new MappedImage (fileName)) {  		int libraryTotal = mappedImage.Imports.Count;  		int funcTotal = 0;  		for (int i = 0; i < mappedImage.Imports.Count; i++)  			funcTotal += mappedImage.Imports [i].Count;  		fpResult.ImportModules = libraryTotal;  		fpResult.ImportFunctions = funcTotal;  		if (libraryTotal < 3 && funcTotal < 5 || ((float)funcTotal / libraryTotal < 4) && libraryTotal > 3 && libraryTotal < 30)  			fpResult.IsPacked = true;  	}  }  catch (AccessViolationException) {  	if (pid > 4)  		fpResult.IsPacked = true;  }  catch {  }  
Magic Number,ProcessHacker,ProcessSystemProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ProcessSystemProvider.cs,QueryProcessStage2,The following statement contains a magic number: try {  	using (var mappedImage = new MappedImage (fileName)) {  		int libraryTotal = mappedImage.Imports.Count;  		int funcTotal = 0;  		for (int i = 0; i < mappedImage.Imports.Count; i++)  			funcTotal += mappedImage.Imports [i].Count;  		fpResult.ImportModules = libraryTotal;  		fpResult.ImportFunctions = funcTotal;  		if (libraryTotal < 3 && funcTotal < 5 || ((float)funcTotal / libraryTotal < 4) && libraryTotal > 3 && libraryTotal < 30)  			fpResult.IsPacked = true;  	}  }  catch (AccessViolationException) {  	if (pid > 4)  		fpResult.IsPacked = true;  }  catch {  }  
Magic Number,ProcessHacker,ProcessSystemProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ProcessSystemProvider.cs,QueryProcessStage2,The following statement contains a magic number: try {  	using (var mappedImage = new MappedImage (fileName)) {  		int libraryTotal = mappedImage.Imports.Count;  		int funcTotal = 0;  		for (int i = 0; i < mappedImage.Imports.Count; i++)  			funcTotal += mappedImage.Imports [i].Count;  		fpResult.ImportModules = libraryTotal;  		fpResult.ImportFunctions = funcTotal;  		if (libraryTotal < 3 && funcTotal < 5 || ((float)funcTotal / libraryTotal < 4) && libraryTotal > 3 && libraryTotal < 30)  			fpResult.IsPacked = true;  	}  }  catch (AccessViolationException) {  	if (pid > 4)  		fpResult.IsPacked = true;  }  catch {  }  
Magic Number,ProcessHacker,ProcessSystemProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ProcessSystemProvider.cs,QueryProcessStage2,The following statement contains a magic number: try {  	using (var mappedImage = new MappedImage (fileName)) {  		int libraryTotal = mappedImage.Imports.Count;  		int funcTotal = 0;  		for (int i = 0; i < mappedImage.Imports.Count; i++)  			funcTotal += mappedImage.Imports [i].Count;  		fpResult.ImportModules = libraryTotal;  		fpResult.ImportFunctions = funcTotal;  		if (libraryTotal < 3 && funcTotal < 5 || ((float)funcTotal / libraryTotal < 4) && libraryTotal > 3 && libraryTotal < 30)  			fpResult.IsPacked = true;  	}  }  catch (AccessViolationException) {  	if (pid > 4)  		fpResult.IsPacked = true;  }  catch {  }  
Magic Number,ProcessHacker,ProcessSystemProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ProcessSystemProvider.cs,QueryProcessStage2,The following statement contains a magic number: try {  	using (var mappedImage = new MappedImage (fileName)) {  		int libraryTotal = mappedImage.Imports.Count;  		int funcTotal = 0;  		for (int i = 0; i < mappedImage.Imports.Count; i++)  			funcTotal += mappedImage.Imports [i].Count;  		fpResult.ImportModules = libraryTotal;  		fpResult.ImportFunctions = funcTotal;  		if (libraryTotal < 3 && funcTotal < 5 || ((float)funcTotal / libraryTotal < 4) && libraryTotal > 3 && libraryTotal < 30)  			fpResult.IsPacked = true;  	}  }  catch (AccessViolationException) {  	if (pid > 4)  		fpResult.IsPacked = true;  }  catch {  }  
Magic Number,ProcessHacker,ProcessSystemProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ProcessSystemProvider.cs,QueryProcessStage2,The following statement contains a magic number: using (var mappedImage = new MappedImage (fileName)) {  	int libraryTotal = mappedImage.Imports.Count;  	int funcTotal = 0;  	for (int i = 0; i < mappedImage.Imports.Count; i++)  		funcTotal += mappedImage.Imports [i].Count;  	fpResult.ImportModules = libraryTotal;  	fpResult.ImportFunctions = funcTotal;  	if (libraryTotal < 3 && funcTotal < 5 || ((float)funcTotal / libraryTotal < 4) && libraryTotal > 3 && libraryTotal < 30)  		fpResult.IsPacked = true;  }  
Magic Number,ProcessHacker,ProcessSystemProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ProcessSystemProvider.cs,QueryProcessStage2,The following statement contains a magic number: using (var mappedImage = new MappedImage (fileName)) {  	int libraryTotal = mappedImage.Imports.Count;  	int funcTotal = 0;  	for (int i = 0; i < mappedImage.Imports.Count; i++)  		funcTotal += mappedImage.Imports [i].Count;  	fpResult.ImportModules = libraryTotal;  	fpResult.ImportFunctions = funcTotal;  	if (libraryTotal < 3 && funcTotal < 5 || ((float)funcTotal / libraryTotal < 4) && libraryTotal > 3 && libraryTotal < 30)  		fpResult.IsPacked = true;  }  
Magic Number,ProcessHacker,ProcessSystemProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ProcessSystemProvider.cs,QueryProcessStage2,The following statement contains a magic number: using (var mappedImage = new MappedImage (fileName)) {  	int libraryTotal = mappedImage.Imports.Count;  	int funcTotal = 0;  	for (int i = 0; i < mappedImage.Imports.Count; i++)  		funcTotal += mappedImage.Imports [i].Count;  	fpResult.ImportModules = libraryTotal;  	fpResult.ImportFunctions = funcTotal;  	if (libraryTotal < 3 && funcTotal < 5 || ((float)funcTotal / libraryTotal < 4) && libraryTotal > 3 && libraryTotal < 30)  		fpResult.IsPacked = true;  }  
Magic Number,ProcessHacker,ProcessSystemProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ProcessSystemProvider.cs,QueryProcessStage2,The following statement contains a magic number: using (var mappedImage = new MappedImage (fileName)) {  	int libraryTotal = mappedImage.Imports.Count;  	int funcTotal = 0;  	for (int i = 0; i < mappedImage.Imports.Count; i++)  		funcTotal += mappedImage.Imports [i].Count;  	fpResult.ImportModules = libraryTotal;  	fpResult.ImportFunctions = funcTotal;  	if (libraryTotal < 3 && funcTotal < 5 || ((float)funcTotal / libraryTotal < 4) && libraryTotal > 3 && libraryTotal < 30)  		fpResult.IsPacked = true;  }  
Magic Number,ProcessHacker,ProcessSystemProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ProcessSystemProvider.cs,QueryProcessStage2,The following statement contains a magic number: using (var mappedImage = new MappedImage (fileName)) {  	int libraryTotal = mappedImage.Imports.Count;  	int funcTotal = 0;  	for (int i = 0; i < mappedImage.Imports.Count; i++)  		funcTotal += mappedImage.Imports [i].Count;  	fpResult.ImportModules = libraryTotal;  	fpResult.ImportFunctions = funcTotal;  	if (libraryTotal < 3 && funcTotal < 5 || ((float)funcTotal / libraryTotal < 4) && libraryTotal > 3 && libraryTotal < 30)  		fpResult.IsPacked = true;  }  
Magic Number,ProcessHacker,ProcessSystemProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ProcessSystemProvider.cs,QueryProcessStage2,The following statement contains a magic number: if (libraryTotal < 3 && funcTotal < 5 || ((float)funcTotal / libraryTotal < 4) && libraryTotal > 3 && libraryTotal < 30)  	fpResult.IsPacked = true;  
Magic Number,ProcessHacker,ProcessSystemProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ProcessSystemProvider.cs,QueryProcessStage2,The following statement contains a magic number: if (libraryTotal < 3 && funcTotal < 5 || ((float)funcTotal / libraryTotal < 4) && libraryTotal > 3 && libraryTotal < 30)  	fpResult.IsPacked = true;  
Magic Number,ProcessHacker,ProcessSystemProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ProcessSystemProvider.cs,QueryProcessStage2,The following statement contains a magic number: if (libraryTotal < 3 && funcTotal < 5 || ((float)funcTotal / libraryTotal < 4) && libraryTotal > 3 && libraryTotal < 30)  	fpResult.IsPacked = true;  
Magic Number,ProcessHacker,ProcessSystemProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ProcessSystemProvider.cs,QueryProcessStage2,The following statement contains a magic number: if (libraryTotal < 3 && funcTotal < 5 || ((float)funcTotal / libraryTotal < 4) && libraryTotal > 3 && libraryTotal < 30)  	fpResult.IsPacked = true;  
Magic Number,ProcessHacker,ProcessSystemProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ProcessSystemProvider.cs,QueryProcessStage2,The following statement contains a magic number: if (libraryTotal < 3 && funcTotal < 5 || ((float)funcTotal / libraryTotal < 4) && libraryTotal > 3 && libraryTotal < 30)  	fpResult.IsPacked = true;  
Magic Number,ProcessHacker,ProcessSystemProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ProcessSystemProvider.cs,QueryProcessStage2,The following statement contains a magic number: if (pid > 4)  	fpResult.IsPacked = true;  
Magic Number,ProcessHacker,ProcessSystemProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ProcessSystemProvider.cs,GetFileName,The following statement contains a magic number: if (pid != 4) {  	try {  		using (var phandle = new ProcessHandle (pid' Program.MinProcessQueryRights)) {  			// First try to get the native file name' to prevent PEB  			// file name spoofing.  			try {  				fileName = FileUtils.GetFileName (phandle.GetImageFileName ());  			}  			catch {  			}  			// If we couldn't get it or we couldn't resolve the \Device prefix'  			// we'll use the Win32 variant.  			if ((fileName == null || fileName.StartsWith ("\\")) && OSVersion.HasWin32ImageFileName) {  				try {  					fileName = phandle.GetImageFileNameWin32 ();  				}  				catch {  				}  			}  		}  	}  	catch {  	}  	if (fileName == null || fileName.StartsWith ("\\Device\\")) {  		try {  			using (var phandle = new ProcessHandle (pid' ProcessAccess.QueryInformation | ProcessAccess.VmRead)) {  				// We can try to use the PEB.  				try {  					fileName = FileUtils.GetFileName (FileUtils.GetFileName (phandle.GetPebString (PebOffset.ImagePathName)));  				}  				catch {  				}  				// If all else failed' we get the main module file name.  				try {  					fileName = phandle.GetMainModule ().FileName;  				}  				catch {  				}  			}  		}  		catch {  		}  	}  }  else {  	try {  		fileName = Windows.KernelFileName;  	}  	catch {  	}  }  
Magic Number,ProcessHacker,ProcessSystemProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ProcessSystemProvider.cs,Update,The following statement contains a magic number: if (this.RunCount % 3 == 0)  	FileUtils.RefreshFileNamePrefixes ();  
Magic Number,ProcessHacker,ProcessSystemProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ProcessSystemProvider.cs,Update,The following statement contains a magic number: if (this.RunCount < 3) {  	_ioReadDelta.Update (_ioReadDelta.Value);  	_ioWriteDelta.Update (_ioWriteDelta.Value);  	_ioOtherDelta.Update (_ioOtherDelta.Value);  }  
Magic Number,ProcessHacker,ProcessSystemProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ProcessSystemProvider.cs,Update,The following statement contains a magic number: procs.Add (-2' _dpcs);  
Magic Number,ProcessHacker,ProcessSystemProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ProcessSystemProvider.cs,Update,The following statement contains a magic number: procs.Add (-3' _interrupts);  
Magic Number,ProcessHacker,ProcessSystemProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ProcessSystemProvider.cs,Update,The following statement contains a magic number: foreach (int pid in procs.Keys) {  	var processInfo = procs [pid].Process;  	if (!Dictionary.ContainsKey (pid)) {  		ProcessItem item = new ProcessItem ();  		// Set up basic process information.  		item.RunId = this.RunCount;  		item.Pid = pid;  		item.Process = processInfo;  		item.SessionId = processInfo.SessionId;  		item.ProcessingAttempts = 1;  		item.Name = procs [pid].Name;  		// Create the delta and history managers.  		item.CpuKernelDelta = new Int64Delta (processInfo.KernelTime);  		item.CpuUserDelta = new Int64Delta (processInfo.UserTime);  		item.IoReadDelta = new Int64Delta ((long)processInfo.IoCounters.ReadTransferCount);  		item.IoWriteDelta = new Int64Delta ((long)processInfo.IoCounters.WriteTransferCount);  		item.IoOtherDelta = new Int64Delta ((long)processInfo.IoCounters.OtherTransferCount);  		item.CpuKernelHistory = new CircularBuffer<float> (_historyMaxSize);  		item.CpuUserHistory = new CircularBuffer<float> (_historyMaxSize);  		item.IoReadHistory = new CircularBuffer<long> (_historyMaxSize);  		item.IoWriteHistory = new CircularBuffer<long> (_historyMaxSize);  		item.IoOtherHistory = new CircularBuffer<long> (_historyMaxSize);  		item.IoReadOtherHistory = new CircularBuffer<long> (_historyMaxSize);  		item.PrivateMemoryHistory = new CircularBuffer<long> (_historyMaxSize);  		item.WorkingSetHistory = new CircularBuffer<long> (_historyMaxSize);  		// HACK: Shouldn't happen' but it does - sometimes   		// the process name is null.  		if (item.Name == null) {  			try {  				using (var phandle = new ProcessHandle (pid' ProcessAccess.QueryInformation | ProcessAccess.VmRead))  					item.Name = phandle.GetMainModule ().BaseName;  			}  			catch {  				item.Name = "";  			}  		}  		// Get the process' creation time and check the   		// parent process ID.  		try {  			item.CreateTime = DateTime.FromFileTime (processInfo.CreateTime);  		}  		catch {  		}  		if (pid > 0) {  			item.ParentPid = processInfo.InheritedFromProcessId;  			item.HasParent = true;  			if (!procs.ContainsKey (item.ParentPid) || item.ParentPid == pid) {  				item.HasParent = false;  			}  			else if (procs.ContainsKey (item.ParentPid)) {  				// Check the parent's creation time to see if it's actually the parent.  				ulong parentStartTime = (ulong)procs [item.ParentPid].Process.CreateTime;  				ulong thisStartTime = (ulong)processInfo.CreateTime;  				if (parentStartTime > thisStartTime)  					item.HasParent = false;  			}  			// Get the process' token's username.  			try {  				using (var queryLimitedHandle = new ProcessHandle (pid' Program.MinProcessQueryRights)) {  					try {  						using (var thandle = queryLimitedHandle.GetToken (TokenAccess.Query)) {  							try {  								using (var sid = thandle.GetUser ())  									item.Username = sid.GetFullName (true);  							}  							catch {  							}  						}  					}  					catch {  					}  				}  			}  			catch {  			}  			// Get a process handle with QUERY_INFORMATION access' and   			// see if it's being debugged.  			try {  				item.ProcessQueryHandle = new ProcessHandle (pid' ProcessAccess.QueryInformation);  				try {  					item.IsBeingDebugged = item.ProcessQueryHandle.IsBeingDebugged ();  				}  				catch {  				}  			}  			catch {  			}  		}  		// Update the process name if it's a fake process.  		if (pid == 0) {  			item.Name = "System Idle Process";  		}  		else if (pid == -2) {  			item.ParentPid = 0;  			item.HasParent = true;  		}  		else if (pid == -3) {  			item.ParentPid = 0;  			item.HasParent = true;  		}  		// If this is not the first run' we process the item immediately.  		if (this.RunCount > 0) {  			this.FillPqResult (item' this.QueryProcessStage1 (pid' null' false' false));  		}  		else {  			if (pid > 0) {  				WorkQueue.GlobalQueueWorkItemTag (new QueryProcessDelegate (this.QueryProcessStage1)' "process-stage1"' pid' item.FileName' false);  			}  		}  		// Set the username for System Idle Process and System.  		if (pid == 0 || pid == 4) {  			// TODO: Potential localization problem. Need to create   			// a well-known SID and use that.  			item.Username = "NT AUTHORITY\\SYSTEM";  		}  		// If we didn't get a username' try to use Terminal Services   		// to get the SID of the process' token's user.  		if (pid > 4 && item.Username == null) {  			if (tsProcesses == null) {  				// Delay loading until this point.  				tsProcesses = new Dictionary<int' IntPtr> ();  				wtsEnumData = Win32.TSEnumProcessesFast ();  				for (int i = 0; i < wtsEnumData.PIDs.Length; i++)  					tsProcesses.Add (wtsEnumData.PIDs [i]' wtsEnumData.SIDs [i]);  			}  			try {  				item.Username = Sid.FromPointer (tsProcesses [pid]).GetFullName (true);  			}  			catch {  			}  		}  		newdictionary.Add (pid' item);  		this.OnDictionaryAdded (item);  	}  	// look for modified processes  	else {  		ProcessItem item = this.Dictionary [pid];  		bool fullUpdate = false;  		// Update process performance information.  		item.CpuKernelDelta.Update (processInfo.KernelTime);  		item.CpuUserDelta.Update (processInfo.UserTime);  		item.IoReadDelta.Update ((long)processInfo.IoCounters.ReadTransferCount);  		item.IoWriteDelta.Update ((long)processInfo.IoCounters.WriteTransferCount);  		item.IoOtherDelta.Update ((long)processInfo.IoCounters.OtherTransferCount);  		UpdateCb (item.CpuKernelHistory' (float)item.CpuKernelDelta.Delta / (sysKernelTime + sysUserTime + otherTime));  		UpdateCb (item.CpuUserHistory' (float)item.CpuUserDelta.Delta / (sysKernelTime + sysUserTime + otherTime));  		UpdateCb (item.IoReadHistory' item.IoReadDelta.Delta);  		UpdateCb (item.IoWriteHistory' item.IoWriteDelta.Delta);  		UpdateCb (item.IoOtherHistory' item.IoOtherDelta.Delta);  		UpdateCb (item.IoReadOtherHistory' item.IoReadDelta.Delta + item.IoOtherDelta.Delta);  		UpdateCb (item.PrivateMemoryHistory' processInfo.VirtualMemoryCounters.PrivatePageCount.ToInt64 ());  		UpdateCb (item.WorkingSetHistory' processInfo.VirtualMemoryCounters.WorkingSetSize.ToInt64 ());  		// Update the struct.  		item.Process = processInfo;  		// Update CPU usage' and update PIDs with most activity.  		try {  			item.CpuUsage = (float)(item.CpuUserDelta.Delta + item.CpuKernelDelta.Delta) * 100 / (sysKernelTime + sysUserTime + otherTime);  			// HACK.  			if (item.CpuUsage > 400.0f)  				item.CpuUsage /= 8.0f;  			else if (item.CpuUsage > 200.0f)  				item.CpuUsage /= 4.0f;  			else if (item.CpuUsage > 100.0f)  				item.CpuUsage /= 2.0f;  			if (pid != 0 && item.CpuUsage > mostCPUUsage) {  				mostCPUUsage = item.CpuUsage;  				this.PidWithMostCpuUsage = pid;  			}  			if (pid != 0 && (item.IoReadDelta.Delta + item.IoWriteDelta.Delta) > mostIOActivity) {  				mostIOActivity = item.IoReadDelta.Delta + item.IoWriteDelta.Delta;  				this.PidWithMostIoActivity = pid;  			}  		}  		catch {  		}  		// Determine whether the process is being debugged.  		if (item.ProcessQueryHandle != null) {  			try {  				bool isBeingDebugged = item.ProcessQueryHandle.IsBeingDebugged ();  				if (isBeingDebugged != item.IsBeingDebugged) {  					item.IsBeingDebugged = isBeingDebugged;  					fullUpdate = true;  				}  			}  			catch {  			}  		}  		// Processes sometimes mistakenly get labeled as packed.   		// Try again if it is packed.  		if (pid > 0) {  			if (item.IsPacked && item.ProcessingAttempts < 3) {  				WorkQueue.GlobalQueueWorkItemTag (new QueryProcessDelegate (this.QueryProcessStage2)' "process-stage2"' pid' item.FileName' true);  				item.ProcessingAttempts++;  			}  		}  		if (item.JustProcessed)  			fullUpdate = true;  		// If we need a full update' call the dictionary modified   		// event so the process tree updates the process'   		// highlighting color.  		if (fullUpdate) {  			this.OnDictionaryModified (null' item);  		}  		item.JustProcessed = false;  	}  }  
Magic Number,ProcessHacker,ProcessSystemProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ProcessSystemProvider.cs,Update,The following statement contains a magic number: foreach (int pid in procs.Keys) {  	var processInfo = procs [pid].Process;  	if (!Dictionary.ContainsKey (pid)) {  		ProcessItem item = new ProcessItem ();  		// Set up basic process information.  		item.RunId = this.RunCount;  		item.Pid = pid;  		item.Process = processInfo;  		item.SessionId = processInfo.SessionId;  		item.ProcessingAttempts = 1;  		item.Name = procs [pid].Name;  		// Create the delta and history managers.  		item.CpuKernelDelta = new Int64Delta (processInfo.KernelTime);  		item.CpuUserDelta = new Int64Delta (processInfo.UserTime);  		item.IoReadDelta = new Int64Delta ((long)processInfo.IoCounters.ReadTransferCount);  		item.IoWriteDelta = new Int64Delta ((long)processInfo.IoCounters.WriteTransferCount);  		item.IoOtherDelta = new Int64Delta ((long)processInfo.IoCounters.OtherTransferCount);  		item.CpuKernelHistory = new CircularBuffer<float> (_historyMaxSize);  		item.CpuUserHistory = new CircularBuffer<float> (_historyMaxSize);  		item.IoReadHistory = new CircularBuffer<long> (_historyMaxSize);  		item.IoWriteHistory = new CircularBuffer<long> (_historyMaxSize);  		item.IoOtherHistory = new CircularBuffer<long> (_historyMaxSize);  		item.IoReadOtherHistory = new CircularBuffer<long> (_historyMaxSize);  		item.PrivateMemoryHistory = new CircularBuffer<long> (_historyMaxSize);  		item.WorkingSetHistory = new CircularBuffer<long> (_historyMaxSize);  		// HACK: Shouldn't happen' but it does - sometimes   		// the process name is null.  		if (item.Name == null) {  			try {  				using (var phandle = new ProcessHandle (pid' ProcessAccess.QueryInformation | ProcessAccess.VmRead))  					item.Name = phandle.GetMainModule ().BaseName;  			}  			catch {  				item.Name = "";  			}  		}  		// Get the process' creation time and check the   		// parent process ID.  		try {  			item.CreateTime = DateTime.FromFileTime (processInfo.CreateTime);  		}  		catch {  		}  		if (pid > 0) {  			item.ParentPid = processInfo.InheritedFromProcessId;  			item.HasParent = true;  			if (!procs.ContainsKey (item.ParentPid) || item.ParentPid == pid) {  				item.HasParent = false;  			}  			else if (procs.ContainsKey (item.ParentPid)) {  				// Check the parent's creation time to see if it's actually the parent.  				ulong parentStartTime = (ulong)procs [item.ParentPid].Process.CreateTime;  				ulong thisStartTime = (ulong)processInfo.CreateTime;  				if (parentStartTime > thisStartTime)  					item.HasParent = false;  			}  			// Get the process' token's username.  			try {  				using (var queryLimitedHandle = new ProcessHandle (pid' Program.MinProcessQueryRights)) {  					try {  						using (var thandle = queryLimitedHandle.GetToken (TokenAccess.Query)) {  							try {  								using (var sid = thandle.GetUser ())  									item.Username = sid.GetFullName (true);  							}  							catch {  							}  						}  					}  					catch {  					}  				}  			}  			catch {  			}  			// Get a process handle with QUERY_INFORMATION access' and   			// see if it's being debugged.  			try {  				item.ProcessQueryHandle = new ProcessHandle (pid' ProcessAccess.QueryInformation);  				try {  					item.IsBeingDebugged = item.ProcessQueryHandle.IsBeingDebugged ();  				}  				catch {  				}  			}  			catch {  			}  		}  		// Update the process name if it's a fake process.  		if (pid == 0) {  			item.Name = "System Idle Process";  		}  		else if (pid == -2) {  			item.ParentPid = 0;  			item.HasParent = true;  		}  		else if (pid == -3) {  			item.ParentPid = 0;  			item.HasParent = true;  		}  		// If this is not the first run' we process the item immediately.  		if (this.RunCount > 0) {  			this.FillPqResult (item' this.QueryProcessStage1 (pid' null' false' false));  		}  		else {  			if (pid > 0) {  				WorkQueue.GlobalQueueWorkItemTag (new QueryProcessDelegate (this.QueryProcessStage1)' "process-stage1"' pid' item.FileName' false);  			}  		}  		// Set the username for System Idle Process and System.  		if (pid == 0 || pid == 4) {  			// TODO: Potential localization problem. Need to create   			// a well-known SID and use that.  			item.Username = "NT AUTHORITY\\SYSTEM";  		}  		// If we didn't get a username' try to use Terminal Services   		// to get the SID of the process' token's user.  		if (pid > 4 && item.Username == null) {  			if (tsProcesses == null) {  				// Delay loading until this point.  				tsProcesses = new Dictionary<int' IntPtr> ();  				wtsEnumData = Win32.TSEnumProcessesFast ();  				for (int i = 0; i < wtsEnumData.PIDs.Length; i++)  					tsProcesses.Add (wtsEnumData.PIDs [i]' wtsEnumData.SIDs [i]);  			}  			try {  				item.Username = Sid.FromPointer (tsProcesses [pid]).GetFullName (true);  			}  			catch {  			}  		}  		newdictionary.Add (pid' item);  		this.OnDictionaryAdded (item);  	}  	// look for modified processes  	else {  		ProcessItem item = this.Dictionary [pid];  		bool fullUpdate = false;  		// Update process performance information.  		item.CpuKernelDelta.Update (processInfo.KernelTime);  		item.CpuUserDelta.Update (processInfo.UserTime);  		item.IoReadDelta.Update ((long)processInfo.IoCounters.ReadTransferCount);  		item.IoWriteDelta.Update ((long)processInfo.IoCounters.WriteTransferCount);  		item.IoOtherDelta.Update ((long)processInfo.IoCounters.OtherTransferCount);  		UpdateCb (item.CpuKernelHistory' (float)item.CpuKernelDelta.Delta / (sysKernelTime + sysUserTime + otherTime));  		UpdateCb (item.CpuUserHistory' (float)item.CpuUserDelta.Delta / (sysKernelTime + sysUserTime + otherTime));  		UpdateCb (item.IoReadHistory' item.IoReadDelta.Delta);  		UpdateCb (item.IoWriteHistory' item.IoWriteDelta.Delta);  		UpdateCb (item.IoOtherHistory' item.IoOtherDelta.Delta);  		UpdateCb (item.IoReadOtherHistory' item.IoReadDelta.Delta + item.IoOtherDelta.Delta);  		UpdateCb (item.PrivateMemoryHistory' processInfo.VirtualMemoryCounters.PrivatePageCount.ToInt64 ());  		UpdateCb (item.WorkingSetHistory' processInfo.VirtualMemoryCounters.WorkingSetSize.ToInt64 ());  		// Update the struct.  		item.Process = processInfo;  		// Update CPU usage' and update PIDs with most activity.  		try {  			item.CpuUsage = (float)(item.CpuUserDelta.Delta + item.CpuKernelDelta.Delta) * 100 / (sysKernelTime + sysUserTime + otherTime);  			// HACK.  			if (item.CpuUsage > 400.0f)  				item.CpuUsage /= 8.0f;  			else if (item.CpuUsage > 200.0f)  				item.CpuUsage /= 4.0f;  			else if (item.CpuUsage > 100.0f)  				item.CpuUsage /= 2.0f;  			if (pid != 0 && item.CpuUsage > mostCPUUsage) {  				mostCPUUsage = item.CpuUsage;  				this.PidWithMostCpuUsage = pid;  			}  			if (pid != 0 && (item.IoReadDelta.Delta + item.IoWriteDelta.Delta) > mostIOActivity) {  				mostIOActivity = item.IoReadDelta.Delta + item.IoWriteDelta.Delta;  				this.PidWithMostIoActivity = pid;  			}  		}  		catch {  		}  		// Determine whether the process is being debugged.  		if (item.ProcessQueryHandle != null) {  			try {  				bool isBeingDebugged = item.ProcessQueryHandle.IsBeingDebugged ();  				if (isBeingDebugged != item.IsBeingDebugged) {  					item.IsBeingDebugged = isBeingDebugged;  					fullUpdate = true;  				}  			}  			catch {  			}  		}  		// Processes sometimes mistakenly get labeled as packed.   		// Try again if it is packed.  		if (pid > 0) {  			if (item.IsPacked && item.ProcessingAttempts < 3) {  				WorkQueue.GlobalQueueWorkItemTag (new QueryProcessDelegate (this.QueryProcessStage2)' "process-stage2"' pid' item.FileName' true);  				item.ProcessingAttempts++;  			}  		}  		if (item.JustProcessed)  			fullUpdate = true;  		// If we need a full update' call the dictionary modified   		// event so the process tree updates the process'   		// highlighting color.  		if (fullUpdate) {  			this.OnDictionaryModified (null' item);  		}  		item.JustProcessed = false;  	}  }  
Magic Number,ProcessHacker,ProcessSystemProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ProcessSystemProvider.cs,Update,The following statement contains a magic number: foreach (int pid in procs.Keys) {  	var processInfo = procs [pid].Process;  	if (!Dictionary.ContainsKey (pid)) {  		ProcessItem item = new ProcessItem ();  		// Set up basic process information.  		item.RunId = this.RunCount;  		item.Pid = pid;  		item.Process = processInfo;  		item.SessionId = processInfo.SessionId;  		item.ProcessingAttempts = 1;  		item.Name = procs [pid].Name;  		// Create the delta and history managers.  		item.CpuKernelDelta = new Int64Delta (processInfo.KernelTime);  		item.CpuUserDelta = new Int64Delta (processInfo.UserTime);  		item.IoReadDelta = new Int64Delta ((long)processInfo.IoCounters.ReadTransferCount);  		item.IoWriteDelta = new Int64Delta ((long)processInfo.IoCounters.WriteTransferCount);  		item.IoOtherDelta = new Int64Delta ((long)processInfo.IoCounters.OtherTransferCount);  		item.CpuKernelHistory = new CircularBuffer<float> (_historyMaxSize);  		item.CpuUserHistory = new CircularBuffer<float> (_historyMaxSize);  		item.IoReadHistory = new CircularBuffer<long> (_historyMaxSize);  		item.IoWriteHistory = new CircularBuffer<long> (_historyMaxSize);  		item.IoOtherHistory = new CircularBuffer<long> (_historyMaxSize);  		item.IoReadOtherHistory = new CircularBuffer<long> (_historyMaxSize);  		item.PrivateMemoryHistory = new CircularBuffer<long> (_historyMaxSize);  		item.WorkingSetHistory = new CircularBuffer<long> (_historyMaxSize);  		// HACK: Shouldn't happen' but it does - sometimes   		// the process name is null.  		if (item.Name == null) {  			try {  				using (var phandle = new ProcessHandle (pid' ProcessAccess.QueryInformation | ProcessAccess.VmRead))  					item.Name = phandle.GetMainModule ().BaseName;  			}  			catch {  				item.Name = "";  			}  		}  		// Get the process' creation time and check the   		// parent process ID.  		try {  			item.CreateTime = DateTime.FromFileTime (processInfo.CreateTime);  		}  		catch {  		}  		if (pid > 0) {  			item.ParentPid = processInfo.InheritedFromProcessId;  			item.HasParent = true;  			if (!procs.ContainsKey (item.ParentPid) || item.ParentPid == pid) {  				item.HasParent = false;  			}  			else if (procs.ContainsKey (item.ParentPid)) {  				// Check the parent's creation time to see if it's actually the parent.  				ulong parentStartTime = (ulong)procs [item.ParentPid].Process.CreateTime;  				ulong thisStartTime = (ulong)processInfo.CreateTime;  				if (parentStartTime > thisStartTime)  					item.HasParent = false;  			}  			// Get the process' token's username.  			try {  				using (var queryLimitedHandle = new ProcessHandle (pid' Program.MinProcessQueryRights)) {  					try {  						using (var thandle = queryLimitedHandle.GetToken (TokenAccess.Query)) {  							try {  								using (var sid = thandle.GetUser ())  									item.Username = sid.GetFullName (true);  							}  							catch {  							}  						}  					}  					catch {  					}  				}  			}  			catch {  			}  			// Get a process handle with QUERY_INFORMATION access' and   			// see if it's being debugged.  			try {  				item.ProcessQueryHandle = new ProcessHandle (pid' ProcessAccess.QueryInformation);  				try {  					item.IsBeingDebugged = item.ProcessQueryHandle.IsBeingDebugged ();  				}  				catch {  				}  			}  			catch {  			}  		}  		// Update the process name if it's a fake process.  		if (pid == 0) {  			item.Name = "System Idle Process";  		}  		else if (pid == -2) {  			item.ParentPid = 0;  			item.HasParent = true;  		}  		else if (pid == -3) {  			item.ParentPid = 0;  			item.HasParent = true;  		}  		// If this is not the first run' we process the item immediately.  		if (this.RunCount > 0) {  			this.FillPqResult (item' this.QueryProcessStage1 (pid' null' false' false));  		}  		else {  			if (pid > 0) {  				WorkQueue.GlobalQueueWorkItemTag (new QueryProcessDelegate (this.QueryProcessStage1)' "process-stage1"' pid' item.FileName' false);  			}  		}  		// Set the username for System Idle Process and System.  		if (pid == 0 || pid == 4) {  			// TODO: Potential localization problem. Need to create   			// a well-known SID and use that.  			item.Username = "NT AUTHORITY\\SYSTEM";  		}  		// If we didn't get a username' try to use Terminal Services   		// to get the SID of the process' token's user.  		if (pid > 4 && item.Username == null) {  			if (tsProcesses == null) {  				// Delay loading until this point.  				tsProcesses = new Dictionary<int' IntPtr> ();  				wtsEnumData = Win32.TSEnumProcessesFast ();  				for (int i = 0; i < wtsEnumData.PIDs.Length; i++)  					tsProcesses.Add (wtsEnumData.PIDs [i]' wtsEnumData.SIDs [i]);  			}  			try {  				item.Username = Sid.FromPointer (tsProcesses [pid]).GetFullName (true);  			}  			catch {  			}  		}  		newdictionary.Add (pid' item);  		this.OnDictionaryAdded (item);  	}  	// look for modified processes  	else {  		ProcessItem item = this.Dictionary [pid];  		bool fullUpdate = false;  		// Update process performance information.  		item.CpuKernelDelta.Update (processInfo.KernelTime);  		item.CpuUserDelta.Update (processInfo.UserTime);  		item.IoReadDelta.Update ((long)processInfo.IoCounters.ReadTransferCount);  		item.IoWriteDelta.Update ((long)processInfo.IoCounters.WriteTransferCount);  		item.IoOtherDelta.Update ((long)processInfo.IoCounters.OtherTransferCount);  		UpdateCb (item.CpuKernelHistory' (float)item.CpuKernelDelta.Delta / (sysKernelTime + sysUserTime + otherTime));  		UpdateCb (item.CpuUserHistory' (float)item.CpuUserDelta.Delta / (sysKernelTime + sysUserTime + otherTime));  		UpdateCb (item.IoReadHistory' item.IoReadDelta.Delta);  		UpdateCb (item.IoWriteHistory' item.IoWriteDelta.Delta);  		UpdateCb (item.IoOtherHistory' item.IoOtherDelta.Delta);  		UpdateCb (item.IoReadOtherHistory' item.IoReadDelta.Delta + item.IoOtherDelta.Delta);  		UpdateCb (item.PrivateMemoryHistory' processInfo.VirtualMemoryCounters.PrivatePageCount.ToInt64 ());  		UpdateCb (item.WorkingSetHistory' processInfo.VirtualMemoryCounters.WorkingSetSize.ToInt64 ());  		// Update the struct.  		item.Process = processInfo;  		// Update CPU usage' and update PIDs with most activity.  		try {  			item.CpuUsage = (float)(item.CpuUserDelta.Delta + item.CpuKernelDelta.Delta) * 100 / (sysKernelTime + sysUserTime + otherTime);  			// HACK.  			if (item.CpuUsage > 400.0f)  				item.CpuUsage /= 8.0f;  			else if (item.CpuUsage > 200.0f)  				item.CpuUsage /= 4.0f;  			else if (item.CpuUsage > 100.0f)  				item.CpuUsage /= 2.0f;  			if (pid != 0 && item.CpuUsage > mostCPUUsage) {  				mostCPUUsage = item.CpuUsage;  				this.PidWithMostCpuUsage = pid;  			}  			if (pid != 0 && (item.IoReadDelta.Delta + item.IoWriteDelta.Delta) > mostIOActivity) {  				mostIOActivity = item.IoReadDelta.Delta + item.IoWriteDelta.Delta;  				this.PidWithMostIoActivity = pid;  			}  		}  		catch {  		}  		// Determine whether the process is being debugged.  		if (item.ProcessQueryHandle != null) {  			try {  				bool isBeingDebugged = item.ProcessQueryHandle.IsBeingDebugged ();  				if (isBeingDebugged != item.IsBeingDebugged) {  					item.IsBeingDebugged = isBeingDebugged;  					fullUpdate = true;  				}  			}  			catch {  			}  		}  		// Processes sometimes mistakenly get labeled as packed.   		// Try again if it is packed.  		if (pid > 0) {  			if (item.IsPacked && item.ProcessingAttempts < 3) {  				WorkQueue.GlobalQueueWorkItemTag (new QueryProcessDelegate (this.QueryProcessStage2)' "process-stage2"' pid' item.FileName' true);  				item.ProcessingAttempts++;  			}  		}  		if (item.JustProcessed)  			fullUpdate = true;  		// If we need a full update' call the dictionary modified   		// event so the process tree updates the process'   		// highlighting color.  		if (fullUpdate) {  			this.OnDictionaryModified (null' item);  		}  		item.JustProcessed = false;  	}  }  
Magic Number,ProcessHacker,ProcessSystemProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ProcessSystemProvider.cs,Update,The following statement contains a magic number: foreach (int pid in procs.Keys) {  	var processInfo = procs [pid].Process;  	if (!Dictionary.ContainsKey (pid)) {  		ProcessItem item = new ProcessItem ();  		// Set up basic process information.  		item.RunId = this.RunCount;  		item.Pid = pid;  		item.Process = processInfo;  		item.SessionId = processInfo.SessionId;  		item.ProcessingAttempts = 1;  		item.Name = procs [pid].Name;  		// Create the delta and history managers.  		item.CpuKernelDelta = new Int64Delta (processInfo.KernelTime);  		item.CpuUserDelta = new Int64Delta (processInfo.UserTime);  		item.IoReadDelta = new Int64Delta ((long)processInfo.IoCounters.ReadTransferCount);  		item.IoWriteDelta = new Int64Delta ((long)processInfo.IoCounters.WriteTransferCount);  		item.IoOtherDelta = new Int64Delta ((long)processInfo.IoCounters.OtherTransferCount);  		item.CpuKernelHistory = new CircularBuffer<float> (_historyMaxSize);  		item.CpuUserHistory = new CircularBuffer<float> (_historyMaxSize);  		item.IoReadHistory = new CircularBuffer<long> (_historyMaxSize);  		item.IoWriteHistory = new CircularBuffer<long> (_historyMaxSize);  		item.IoOtherHistory = new CircularBuffer<long> (_historyMaxSize);  		item.IoReadOtherHistory = new CircularBuffer<long> (_historyMaxSize);  		item.PrivateMemoryHistory = new CircularBuffer<long> (_historyMaxSize);  		item.WorkingSetHistory = new CircularBuffer<long> (_historyMaxSize);  		// HACK: Shouldn't happen' but it does - sometimes   		// the process name is null.  		if (item.Name == null) {  			try {  				using (var phandle = new ProcessHandle (pid' ProcessAccess.QueryInformation | ProcessAccess.VmRead))  					item.Name = phandle.GetMainModule ().BaseName;  			}  			catch {  				item.Name = "";  			}  		}  		// Get the process' creation time and check the   		// parent process ID.  		try {  			item.CreateTime = DateTime.FromFileTime (processInfo.CreateTime);  		}  		catch {  		}  		if (pid > 0) {  			item.ParentPid = processInfo.InheritedFromProcessId;  			item.HasParent = true;  			if (!procs.ContainsKey (item.ParentPid) || item.ParentPid == pid) {  				item.HasParent = false;  			}  			else if (procs.ContainsKey (item.ParentPid)) {  				// Check the parent's creation time to see if it's actually the parent.  				ulong parentStartTime = (ulong)procs [item.ParentPid].Process.CreateTime;  				ulong thisStartTime = (ulong)processInfo.CreateTime;  				if (parentStartTime > thisStartTime)  					item.HasParent = false;  			}  			// Get the process' token's username.  			try {  				using (var queryLimitedHandle = new ProcessHandle (pid' Program.MinProcessQueryRights)) {  					try {  						using (var thandle = queryLimitedHandle.GetToken (TokenAccess.Query)) {  							try {  								using (var sid = thandle.GetUser ())  									item.Username = sid.GetFullName (true);  							}  							catch {  							}  						}  					}  					catch {  					}  				}  			}  			catch {  			}  			// Get a process handle with QUERY_INFORMATION access' and   			// see if it's being debugged.  			try {  				item.ProcessQueryHandle = new ProcessHandle (pid' ProcessAccess.QueryInformation);  				try {  					item.IsBeingDebugged = item.ProcessQueryHandle.IsBeingDebugged ();  				}  				catch {  				}  			}  			catch {  			}  		}  		// Update the process name if it's a fake process.  		if (pid == 0) {  			item.Name = "System Idle Process";  		}  		else if (pid == -2) {  			item.ParentPid = 0;  			item.HasParent = true;  		}  		else if (pid == -3) {  			item.ParentPid = 0;  			item.HasParent = true;  		}  		// If this is not the first run' we process the item immediately.  		if (this.RunCount > 0) {  			this.FillPqResult (item' this.QueryProcessStage1 (pid' null' false' false));  		}  		else {  			if (pid > 0) {  				WorkQueue.GlobalQueueWorkItemTag (new QueryProcessDelegate (this.QueryProcessStage1)' "process-stage1"' pid' item.FileName' false);  			}  		}  		// Set the username for System Idle Process and System.  		if (pid == 0 || pid == 4) {  			// TODO: Potential localization problem. Need to create   			// a well-known SID and use that.  			item.Username = "NT AUTHORITY\\SYSTEM";  		}  		// If we didn't get a username' try to use Terminal Services   		// to get the SID of the process' token's user.  		if (pid > 4 && item.Username == null) {  			if (tsProcesses == null) {  				// Delay loading until this point.  				tsProcesses = new Dictionary<int' IntPtr> ();  				wtsEnumData = Win32.TSEnumProcessesFast ();  				for (int i = 0; i < wtsEnumData.PIDs.Length; i++)  					tsProcesses.Add (wtsEnumData.PIDs [i]' wtsEnumData.SIDs [i]);  			}  			try {  				item.Username = Sid.FromPointer (tsProcesses [pid]).GetFullName (true);  			}  			catch {  			}  		}  		newdictionary.Add (pid' item);  		this.OnDictionaryAdded (item);  	}  	// look for modified processes  	else {  		ProcessItem item = this.Dictionary [pid];  		bool fullUpdate = false;  		// Update process performance information.  		item.CpuKernelDelta.Update (processInfo.KernelTime);  		item.CpuUserDelta.Update (processInfo.UserTime);  		item.IoReadDelta.Update ((long)processInfo.IoCounters.ReadTransferCount);  		item.IoWriteDelta.Update ((long)processInfo.IoCounters.WriteTransferCount);  		item.IoOtherDelta.Update ((long)processInfo.IoCounters.OtherTransferCount);  		UpdateCb (item.CpuKernelHistory' (float)item.CpuKernelDelta.Delta / (sysKernelTime + sysUserTime + otherTime));  		UpdateCb (item.CpuUserHistory' (float)item.CpuUserDelta.Delta / (sysKernelTime + sysUserTime + otherTime));  		UpdateCb (item.IoReadHistory' item.IoReadDelta.Delta);  		UpdateCb (item.IoWriteHistory' item.IoWriteDelta.Delta);  		UpdateCb (item.IoOtherHistory' item.IoOtherDelta.Delta);  		UpdateCb (item.IoReadOtherHistory' item.IoReadDelta.Delta + item.IoOtherDelta.Delta);  		UpdateCb (item.PrivateMemoryHistory' processInfo.VirtualMemoryCounters.PrivatePageCount.ToInt64 ());  		UpdateCb (item.WorkingSetHistory' processInfo.VirtualMemoryCounters.WorkingSetSize.ToInt64 ());  		// Update the struct.  		item.Process = processInfo;  		// Update CPU usage' and update PIDs with most activity.  		try {  			item.CpuUsage = (float)(item.CpuUserDelta.Delta + item.CpuKernelDelta.Delta) * 100 / (sysKernelTime + sysUserTime + otherTime);  			// HACK.  			if (item.CpuUsage > 400.0f)  				item.CpuUsage /= 8.0f;  			else if (item.CpuUsage > 200.0f)  				item.CpuUsage /= 4.0f;  			else if (item.CpuUsage > 100.0f)  				item.CpuUsage /= 2.0f;  			if (pid != 0 && item.CpuUsage > mostCPUUsage) {  				mostCPUUsage = item.CpuUsage;  				this.PidWithMostCpuUsage = pid;  			}  			if (pid != 0 && (item.IoReadDelta.Delta + item.IoWriteDelta.Delta) > mostIOActivity) {  				mostIOActivity = item.IoReadDelta.Delta + item.IoWriteDelta.Delta;  				this.PidWithMostIoActivity = pid;  			}  		}  		catch {  		}  		// Determine whether the process is being debugged.  		if (item.ProcessQueryHandle != null) {  			try {  				bool isBeingDebugged = item.ProcessQueryHandle.IsBeingDebugged ();  				if (isBeingDebugged != item.IsBeingDebugged) {  					item.IsBeingDebugged = isBeingDebugged;  					fullUpdate = true;  				}  			}  			catch {  			}  		}  		// Processes sometimes mistakenly get labeled as packed.   		// Try again if it is packed.  		if (pid > 0) {  			if (item.IsPacked && item.ProcessingAttempts < 3) {  				WorkQueue.GlobalQueueWorkItemTag (new QueryProcessDelegate (this.QueryProcessStage2)' "process-stage2"' pid' item.FileName' true);  				item.ProcessingAttempts++;  			}  		}  		if (item.JustProcessed)  			fullUpdate = true;  		// If we need a full update' call the dictionary modified   		// event so the process tree updates the process'   		// highlighting color.  		if (fullUpdate) {  			this.OnDictionaryModified (null' item);  		}  		item.JustProcessed = false;  	}  }  
Magic Number,ProcessHacker,ProcessSystemProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ProcessSystemProvider.cs,Update,The following statement contains a magic number: foreach (int pid in procs.Keys) {  	var processInfo = procs [pid].Process;  	if (!Dictionary.ContainsKey (pid)) {  		ProcessItem item = new ProcessItem ();  		// Set up basic process information.  		item.RunId = this.RunCount;  		item.Pid = pid;  		item.Process = processInfo;  		item.SessionId = processInfo.SessionId;  		item.ProcessingAttempts = 1;  		item.Name = procs [pid].Name;  		// Create the delta and history managers.  		item.CpuKernelDelta = new Int64Delta (processInfo.KernelTime);  		item.CpuUserDelta = new Int64Delta (processInfo.UserTime);  		item.IoReadDelta = new Int64Delta ((long)processInfo.IoCounters.ReadTransferCount);  		item.IoWriteDelta = new Int64Delta ((long)processInfo.IoCounters.WriteTransferCount);  		item.IoOtherDelta = new Int64Delta ((long)processInfo.IoCounters.OtherTransferCount);  		item.CpuKernelHistory = new CircularBuffer<float> (_historyMaxSize);  		item.CpuUserHistory = new CircularBuffer<float> (_historyMaxSize);  		item.IoReadHistory = new CircularBuffer<long> (_historyMaxSize);  		item.IoWriteHistory = new CircularBuffer<long> (_historyMaxSize);  		item.IoOtherHistory = new CircularBuffer<long> (_historyMaxSize);  		item.IoReadOtherHistory = new CircularBuffer<long> (_historyMaxSize);  		item.PrivateMemoryHistory = new CircularBuffer<long> (_historyMaxSize);  		item.WorkingSetHistory = new CircularBuffer<long> (_historyMaxSize);  		// HACK: Shouldn't happen' but it does - sometimes   		// the process name is null.  		if (item.Name == null) {  			try {  				using (var phandle = new ProcessHandle (pid' ProcessAccess.QueryInformation | ProcessAccess.VmRead))  					item.Name = phandle.GetMainModule ().BaseName;  			}  			catch {  				item.Name = "";  			}  		}  		// Get the process' creation time and check the   		// parent process ID.  		try {  			item.CreateTime = DateTime.FromFileTime (processInfo.CreateTime);  		}  		catch {  		}  		if (pid > 0) {  			item.ParentPid = processInfo.InheritedFromProcessId;  			item.HasParent = true;  			if (!procs.ContainsKey (item.ParentPid) || item.ParentPid == pid) {  				item.HasParent = false;  			}  			else if (procs.ContainsKey (item.ParentPid)) {  				// Check the parent's creation time to see if it's actually the parent.  				ulong parentStartTime = (ulong)procs [item.ParentPid].Process.CreateTime;  				ulong thisStartTime = (ulong)processInfo.CreateTime;  				if (parentStartTime > thisStartTime)  					item.HasParent = false;  			}  			// Get the process' token's username.  			try {  				using (var queryLimitedHandle = new ProcessHandle (pid' Program.MinProcessQueryRights)) {  					try {  						using (var thandle = queryLimitedHandle.GetToken (TokenAccess.Query)) {  							try {  								using (var sid = thandle.GetUser ())  									item.Username = sid.GetFullName (true);  							}  							catch {  							}  						}  					}  					catch {  					}  				}  			}  			catch {  			}  			// Get a process handle with QUERY_INFORMATION access' and   			// see if it's being debugged.  			try {  				item.ProcessQueryHandle = new ProcessHandle (pid' ProcessAccess.QueryInformation);  				try {  					item.IsBeingDebugged = item.ProcessQueryHandle.IsBeingDebugged ();  				}  				catch {  				}  			}  			catch {  			}  		}  		// Update the process name if it's a fake process.  		if (pid == 0) {  			item.Name = "System Idle Process";  		}  		else if (pid == -2) {  			item.ParentPid = 0;  			item.HasParent = true;  		}  		else if (pid == -3) {  			item.ParentPid = 0;  			item.HasParent = true;  		}  		// If this is not the first run' we process the item immediately.  		if (this.RunCount > 0) {  			this.FillPqResult (item' this.QueryProcessStage1 (pid' null' false' false));  		}  		else {  			if (pid > 0) {  				WorkQueue.GlobalQueueWorkItemTag (new QueryProcessDelegate (this.QueryProcessStage1)' "process-stage1"' pid' item.FileName' false);  			}  		}  		// Set the username for System Idle Process and System.  		if (pid == 0 || pid == 4) {  			// TODO: Potential localization problem. Need to create   			// a well-known SID and use that.  			item.Username = "NT AUTHORITY\\SYSTEM";  		}  		// If we didn't get a username' try to use Terminal Services   		// to get the SID of the process' token's user.  		if (pid > 4 && item.Username == null) {  			if (tsProcesses == null) {  				// Delay loading until this point.  				tsProcesses = new Dictionary<int' IntPtr> ();  				wtsEnumData = Win32.TSEnumProcessesFast ();  				for (int i = 0; i < wtsEnumData.PIDs.Length; i++)  					tsProcesses.Add (wtsEnumData.PIDs [i]' wtsEnumData.SIDs [i]);  			}  			try {  				item.Username = Sid.FromPointer (tsProcesses [pid]).GetFullName (true);  			}  			catch {  			}  		}  		newdictionary.Add (pid' item);  		this.OnDictionaryAdded (item);  	}  	// look for modified processes  	else {  		ProcessItem item = this.Dictionary [pid];  		bool fullUpdate = false;  		// Update process performance information.  		item.CpuKernelDelta.Update (processInfo.KernelTime);  		item.CpuUserDelta.Update (processInfo.UserTime);  		item.IoReadDelta.Update ((long)processInfo.IoCounters.ReadTransferCount);  		item.IoWriteDelta.Update ((long)processInfo.IoCounters.WriteTransferCount);  		item.IoOtherDelta.Update ((long)processInfo.IoCounters.OtherTransferCount);  		UpdateCb (item.CpuKernelHistory' (float)item.CpuKernelDelta.Delta / (sysKernelTime + sysUserTime + otherTime));  		UpdateCb (item.CpuUserHistory' (float)item.CpuUserDelta.Delta / (sysKernelTime + sysUserTime + otherTime));  		UpdateCb (item.IoReadHistory' item.IoReadDelta.Delta);  		UpdateCb (item.IoWriteHistory' item.IoWriteDelta.Delta);  		UpdateCb (item.IoOtherHistory' item.IoOtherDelta.Delta);  		UpdateCb (item.IoReadOtherHistory' item.IoReadDelta.Delta + item.IoOtherDelta.Delta);  		UpdateCb (item.PrivateMemoryHistory' processInfo.VirtualMemoryCounters.PrivatePageCount.ToInt64 ());  		UpdateCb (item.WorkingSetHistory' processInfo.VirtualMemoryCounters.WorkingSetSize.ToInt64 ());  		// Update the struct.  		item.Process = processInfo;  		// Update CPU usage' and update PIDs with most activity.  		try {  			item.CpuUsage = (float)(item.CpuUserDelta.Delta + item.CpuKernelDelta.Delta) * 100 / (sysKernelTime + sysUserTime + otherTime);  			// HACK.  			if (item.CpuUsage > 400.0f)  				item.CpuUsage /= 8.0f;  			else if (item.CpuUsage > 200.0f)  				item.CpuUsage /= 4.0f;  			else if (item.CpuUsage > 100.0f)  				item.CpuUsage /= 2.0f;  			if (pid != 0 && item.CpuUsage > mostCPUUsage) {  				mostCPUUsage = item.CpuUsage;  				this.PidWithMostCpuUsage = pid;  			}  			if (pid != 0 && (item.IoReadDelta.Delta + item.IoWriteDelta.Delta) > mostIOActivity) {  				mostIOActivity = item.IoReadDelta.Delta + item.IoWriteDelta.Delta;  				this.PidWithMostIoActivity = pid;  			}  		}  		catch {  		}  		// Determine whether the process is being debugged.  		if (item.ProcessQueryHandle != null) {  			try {  				bool isBeingDebugged = item.ProcessQueryHandle.IsBeingDebugged ();  				if (isBeingDebugged != item.IsBeingDebugged) {  					item.IsBeingDebugged = isBeingDebugged;  					fullUpdate = true;  				}  			}  			catch {  			}  		}  		// Processes sometimes mistakenly get labeled as packed.   		// Try again if it is packed.  		if (pid > 0) {  			if (item.IsPacked && item.ProcessingAttempts < 3) {  				WorkQueue.GlobalQueueWorkItemTag (new QueryProcessDelegate (this.QueryProcessStage2)' "process-stage2"' pid' item.FileName' true);  				item.ProcessingAttempts++;  			}  		}  		if (item.JustProcessed)  			fullUpdate = true;  		// If we need a full update' call the dictionary modified   		// event so the process tree updates the process'   		// highlighting color.  		if (fullUpdate) {  			this.OnDictionaryModified (null' item);  		}  		item.JustProcessed = false;  	}  }  
Magic Number,ProcessHacker,ProcessSystemProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ProcessSystemProvider.cs,Update,The following statement contains a magic number: foreach (int pid in procs.Keys) {  	var processInfo = procs [pid].Process;  	if (!Dictionary.ContainsKey (pid)) {  		ProcessItem item = new ProcessItem ();  		// Set up basic process information.  		item.RunId = this.RunCount;  		item.Pid = pid;  		item.Process = processInfo;  		item.SessionId = processInfo.SessionId;  		item.ProcessingAttempts = 1;  		item.Name = procs [pid].Name;  		// Create the delta and history managers.  		item.CpuKernelDelta = new Int64Delta (processInfo.KernelTime);  		item.CpuUserDelta = new Int64Delta (processInfo.UserTime);  		item.IoReadDelta = new Int64Delta ((long)processInfo.IoCounters.ReadTransferCount);  		item.IoWriteDelta = new Int64Delta ((long)processInfo.IoCounters.WriteTransferCount);  		item.IoOtherDelta = new Int64Delta ((long)processInfo.IoCounters.OtherTransferCount);  		item.CpuKernelHistory = new CircularBuffer<float> (_historyMaxSize);  		item.CpuUserHistory = new CircularBuffer<float> (_historyMaxSize);  		item.IoReadHistory = new CircularBuffer<long> (_historyMaxSize);  		item.IoWriteHistory = new CircularBuffer<long> (_historyMaxSize);  		item.IoOtherHistory = new CircularBuffer<long> (_historyMaxSize);  		item.IoReadOtherHistory = new CircularBuffer<long> (_historyMaxSize);  		item.PrivateMemoryHistory = new CircularBuffer<long> (_historyMaxSize);  		item.WorkingSetHistory = new CircularBuffer<long> (_historyMaxSize);  		// HACK: Shouldn't happen' but it does - sometimes   		// the process name is null.  		if (item.Name == null) {  			try {  				using (var phandle = new ProcessHandle (pid' ProcessAccess.QueryInformation | ProcessAccess.VmRead))  					item.Name = phandle.GetMainModule ().BaseName;  			}  			catch {  				item.Name = "";  			}  		}  		// Get the process' creation time and check the   		// parent process ID.  		try {  			item.CreateTime = DateTime.FromFileTime (processInfo.CreateTime);  		}  		catch {  		}  		if (pid > 0) {  			item.ParentPid = processInfo.InheritedFromProcessId;  			item.HasParent = true;  			if (!procs.ContainsKey (item.ParentPid) || item.ParentPid == pid) {  				item.HasParent = false;  			}  			else if (procs.ContainsKey (item.ParentPid)) {  				// Check the parent's creation time to see if it's actually the parent.  				ulong parentStartTime = (ulong)procs [item.ParentPid].Process.CreateTime;  				ulong thisStartTime = (ulong)processInfo.CreateTime;  				if (parentStartTime > thisStartTime)  					item.HasParent = false;  			}  			// Get the process' token's username.  			try {  				using (var queryLimitedHandle = new ProcessHandle (pid' Program.MinProcessQueryRights)) {  					try {  						using (var thandle = queryLimitedHandle.GetToken (TokenAccess.Query)) {  							try {  								using (var sid = thandle.GetUser ())  									item.Username = sid.GetFullName (true);  							}  							catch {  							}  						}  					}  					catch {  					}  				}  			}  			catch {  			}  			// Get a process handle with QUERY_INFORMATION access' and   			// see if it's being debugged.  			try {  				item.ProcessQueryHandle = new ProcessHandle (pid' ProcessAccess.QueryInformation);  				try {  					item.IsBeingDebugged = item.ProcessQueryHandle.IsBeingDebugged ();  				}  				catch {  				}  			}  			catch {  			}  		}  		// Update the process name if it's a fake process.  		if (pid == 0) {  			item.Name = "System Idle Process";  		}  		else if (pid == -2) {  			item.ParentPid = 0;  			item.HasParent = true;  		}  		else if (pid == -3) {  			item.ParentPid = 0;  			item.HasParent = true;  		}  		// If this is not the first run' we process the item immediately.  		if (this.RunCount > 0) {  			this.FillPqResult (item' this.QueryProcessStage1 (pid' null' false' false));  		}  		else {  			if (pid > 0) {  				WorkQueue.GlobalQueueWorkItemTag (new QueryProcessDelegate (this.QueryProcessStage1)' "process-stage1"' pid' item.FileName' false);  			}  		}  		// Set the username for System Idle Process and System.  		if (pid == 0 || pid == 4) {  			// TODO: Potential localization problem. Need to create   			// a well-known SID and use that.  			item.Username = "NT AUTHORITY\\SYSTEM";  		}  		// If we didn't get a username' try to use Terminal Services   		// to get the SID of the process' token's user.  		if (pid > 4 && item.Username == null) {  			if (tsProcesses == null) {  				// Delay loading until this point.  				tsProcesses = new Dictionary<int' IntPtr> ();  				wtsEnumData = Win32.TSEnumProcessesFast ();  				for (int i = 0; i < wtsEnumData.PIDs.Length; i++)  					tsProcesses.Add (wtsEnumData.PIDs [i]' wtsEnumData.SIDs [i]);  			}  			try {  				item.Username = Sid.FromPointer (tsProcesses [pid]).GetFullName (true);  			}  			catch {  			}  		}  		newdictionary.Add (pid' item);  		this.OnDictionaryAdded (item);  	}  	// look for modified processes  	else {  		ProcessItem item = this.Dictionary [pid];  		bool fullUpdate = false;  		// Update process performance information.  		item.CpuKernelDelta.Update (processInfo.KernelTime);  		item.CpuUserDelta.Update (processInfo.UserTime);  		item.IoReadDelta.Update ((long)processInfo.IoCounters.ReadTransferCount);  		item.IoWriteDelta.Update ((long)processInfo.IoCounters.WriteTransferCount);  		item.IoOtherDelta.Update ((long)processInfo.IoCounters.OtherTransferCount);  		UpdateCb (item.CpuKernelHistory' (float)item.CpuKernelDelta.Delta / (sysKernelTime + sysUserTime + otherTime));  		UpdateCb (item.CpuUserHistory' (float)item.CpuUserDelta.Delta / (sysKernelTime + sysUserTime + otherTime));  		UpdateCb (item.IoReadHistory' item.IoReadDelta.Delta);  		UpdateCb (item.IoWriteHistory' item.IoWriteDelta.Delta);  		UpdateCb (item.IoOtherHistory' item.IoOtherDelta.Delta);  		UpdateCb (item.IoReadOtherHistory' item.IoReadDelta.Delta + item.IoOtherDelta.Delta);  		UpdateCb (item.PrivateMemoryHistory' processInfo.VirtualMemoryCounters.PrivatePageCount.ToInt64 ());  		UpdateCb (item.WorkingSetHistory' processInfo.VirtualMemoryCounters.WorkingSetSize.ToInt64 ());  		// Update the struct.  		item.Process = processInfo;  		// Update CPU usage' and update PIDs with most activity.  		try {  			item.CpuUsage = (float)(item.CpuUserDelta.Delta + item.CpuKernelDelta.Delta) * 100 / (sysKernelTime + sysUserTime + otherTime);  			// HACK.  			if (item.CpuUsage > 400.0f)  				item.CpuUsage /= 8.0f;  			else if (item.CpuUsage > 200.0f)  				item.CpuUsage /= 4.0f;  			else if (item.CpuUsage > 100.0f)  				item.CpuUsage /= 2.0f;  			if (pid != 0 && item.CpuUsage > mostCPUUsage) {  				mostCPUUsage = item.CpuUsage;  				this.PidWithMostCpuUsage = pid;  			}  			if (pid != 0 && (item.IoReadDelta.Delta + item.IoWriteDelta.Delta) > mostIOActivity) {  				mostIOActivity = item.IoReadDelta.Delta + item.IoWriteDelta.Delta;  				this.PidWithMostIoActivity = pid;  			}  		}  		catch {  		}  		// Determine whether the process is being debugged.  		if (item.ProcessQueryHandle != null) {  			try {  				bool isBeingDebugged = item.ProcessQueryHandle.IsBeingDebugged ();  				if (isBeingDebugged != item.IsBeingDebugged) {  					item.IsBeingDebugged = isBeingDebugged;  					fullUpdate = true;  				}  			}  			catch {  			}  		}  		// Processes sometimes mistakenly get labeled as packed.   		// Try again if it is packed.  		if (pid > 0) {  			if (item.IsPacked && item.ProcessingAttempts < 3) {  				WorkQueue.GlobalQueueWorkItemTag (new QueryProcessDelegate (this.QueryProcessStage2)' "process-stage2"' pid' item.FileName' true);  				item.ProcessingAttempts++;  			}  		}  		if (item.JustProcessed)  			fullUpdate = true;  		// If we need a full update' call the dictionary modified   		// event so the process tree updates the process'   		// highlighting color.  		if (fullUpdate) {  			this.OnDictionaryModified (null' item);  		}  		item.JustProcessed = false;  	}  }  
Magic Number,ProcessHacker,ProcessSystemProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ProcessSystemProvider.cs,Update,The following statement contains a magic number: if (!Dictionary.ContainsKey (pid)) {  	ProcessItem item = new ProcessItem ();  	// Set up basic process information.  	item.RunId = this.RunCount;  	item.Pid = pid;  	item.Process = processInfo;  	item.SessionId = processInfo.SessionId;  	item.ProcessingAttempts = 1;  	item.Name = procs [pid].Name;  	// Create the delta and history managers.  	item.CpuKernelDelta = new Int64Delta (processInfo.KernelTime);  	item.CpuUserDelta = new Int64Delta (processInfo.UserTime);  	item.IoReadDelta = new Int64Delta ((long)processInfo.IoCounters.ReadTransferCount);  	item.IoWriteDelta = new Int64Delta ((long)processInfo.IoCounters.WriteTransferCount);  	item.IoOtherDelta = new Int64Delta ((long)processInfo.IoCounters.OtherTransferCount);  	item.CpuKernelHistory = new CircularBuffer<float> (_historyMaxSize);  	item.CpuUserHistory = new CircularBuffer<float> (_historyMaxSize);  	item.IoReadHistory = new CircularBuffer<long> (_historyMaxSize);  	item.IoWriteHistory = new CircularBuffer<long> (_historyMaxSize);  	item.IoOtherHistory = new CircularBuffer<long> (_historyMaxSize);  	item.IoReadOtherHistory = new CircularBuffer<long> (_historyMaxSize);  	item.PrivateMemoryHistory = new CircularBuffer<long> (_historyMaxSize);  	item.WorkingSetHistory = new CircularBuffer<long> (_historyMaxSize);  	// HACK: Shouldn't happen' but it does - sometimes   	// the process name is null.  	if (item.Name == null) {  		try {  			using (var phandle = new ProcessHandle (pid' ProcessAccess.QueryInformation | ProcessAccess.VmRead))  				item.Name = phandle.GetMainModule ().BaseName;  		}  		catch {  			item.Name = "";  		}  	}  	// Get the process' creation time and check the   	// parent process ID.  	try {  		item.CreateTime = DateTime.FromFileTime (processInfo.CreateTime);  	}  	catch {  	}  	if (pid > 0) {  		item.ParentPid = processInfo.InheritedFromProcessId;  		item.HasParent = true;  		if (!procs.ContainsKey (item.ParentPid) || item.ParentPid == pid) {  			item.HasParent = false;  		}  		else if (procs.ContainsKey (item.ParentPid)) {  			// Check the parent's creation time to see if it's actually the parent.  			ulong parentStartTime = (ulong)procs [item.ParentPid].Process.CreateTime;  			ulong thisStartTime = (ulong)processInfo.CreateTime;  			if (parentStartTime > thisStartTime)  				item.HasParent = false;  		}  		// Get the process' token's username.  		try {  			using (var queryLimitedHandle = new ProcessHandle (pid' Program.MinProcessQueryRights)) {  				try {  					using (var thandle = queryLimitedHandle.GetToken (TokenAccess.Query)) {  						try {  							using (var sid = thandle.GetUser ())  								item.Username = sid.GetFullName (true);  						}  						catch {  						}  					}  				}  				catch {  				}  			}  		}  		catch {  		}  		// Get a process handle with QUERY_INFORMATION access' and   		// see if it's being debugged.  		try {  			item.ProcessQueryHandle = new ProcessHandle (pid' ProcessAccess.QueryInformation);  			try {  				item.IsBeingDebugged = item.ProcessQueryHandle.IsBeingDebugged ();  			}  			catch {  			}  		}  		catch {  		}  	}  	// Update the process name if it's a fake process.  	if (pid == 0) {  		item.Name = "System Idle Process";  	}  	else if (pid == -2) {  		item.ParentPid = 0;  		item.HasParent = true;  	}  	else if (pid == -3) {  		item.ParentPid = 0;  		item.HasParent = true;  	}  	// If this is not the first run' we process the item immediately.  	if (this.RunCount > 0) {  		this.FillPqResult (item' this.QueryProcessStage1 (pid' null' false' false));  	}  	else {  		if (pid > 0) {  			WorkQueue.GlobalQueueWorkItemTag (new QueryProcessDelegate (this.QueryProcessStage1)' "process-stage1"' pid' item.FileName' false);  		}  	}  	// Set the username for System Idle Process and System.  	if (pid == 0 || pid == 4) {  		// TODO: Potential localization problem. Need to create   		// a well-known SID and use that.  		item.Username = "NT AUTHORITY\\SYSTEM";  	}  	// If we didn't get a username' try to use Terminal Services   	// to get the SID of the process' token's user.  	if (pid > 4 && item.Username == null) {  		if (tsProcesses == null) {  			// Delay loading until this point.  			tsProcesses = new Dictionary<int' IntPtr> ();  			wtsEnumData = Win32.TSEnumProcessesFast ();  			for (int i = 0; i < wtsEnumData.PIDs.Length; i++)  				tsProcesses.Add (wtsEnumData.PIDs [i]' wtsEnumData.SIDs [i]);  		}  		try {  			item.Username = Sid.FromPointer (tsProcesses [pid]).GetFullName (true);  		}  		catch {  		}  	}  	newdictionary.Add (pid' item);  	this.OnDictionaryAdded (item);  }  // look for modified processes  else {  	ProcessItem item = this.Dictionary [pid];  	bool fullUpdate = false;  	// Update process performance information.  	item.CpuKernelDelta.Update (processInfo.KernelTime);  	item.CpuUserDelta.Update (processInfo.UserTime);  	item.IoReadDelta.Update ((long)processInfo.IoCounters.ReadTransferCount);  	item.IoWriteDelta.Update ((long)processInfo.IoCounters.WriteTransferCount);  	item.IoOtherDelta.Update ((long)processInfo.IoCounters.OtherTransferCount);  	UpdateCb (item.CpuKernelHistory' (float)item.CpuKernelDelta.Delta / (sysKernelTime + sysUserTime + otherTime));  	UpdateCb (item.CpuUserHistory' (float)item.CpuUserDelta.Delta / (sysKernelTime + sysUserTime + otherTime));  	UpdateCb (item.IoReadHistory' item.IoReadDelta.Delta);  	UpdateCb (item.IoWriteHistory' item.IoWriteDelta.Delta);  	UpdateCb (item.IoOtherHistory' item.IoOtherDelta.Delta);  	UpdateCb (item.IoReadOtherHistory' item.IoReadDelta.Delta + item.IoOtherDelta.Delta);  	UpdateCb (item.PrivateMemoryHistory' processInfo.VirtualMemoryCounters.PrivatePageCount.ToInt64 ());  	UpdateCb (item.WorkingSetHistory' processInfo.VirtualMemoryCounters.WorkingSetSize.ToInt64 ());  	// Update the struct.  	item.Process = processInfo;  	// Update CPU usage' and update PIDs with most activity.  	try {  		item.CpuUsage = (float)(item.CpuUserDelta.Delta + item.CpuKernelDelta.Delta) * 100 / (sysKernelTime + sysUserTime + otherTime);  		// HACK.  		if (item.CpuUsage > 400.0f)  			item.CpuUsage /= 8.0f;  		else if (item.CpuUsage > 200.0f)  			item.CpuUsage /= 4.0f;  		else if (item.CpuUsage > 100.0f)  			item.CpuUsage /= 2.0f;  		if (pid != 0 && item.CpuUsage > mostCPUUsage) {  			mostCPUUsage = item.CpuUsage;  			this.PidWithMostCpuUsage = pid;  		}  		if (pid != 0 && (item.IoReadDelta.Delta + item.IoWriteDelta.Delta) > mostIOActivity) {  			mostIOActivity = item.IoReadDelta.Delta + item.IoWriteDelta.Delta;  			this.PidWithMostIoActivity = pid;  		}  	}  	catch {  	}  	// Determine whether the process is being debugged.  	if (item.ProcessQueryHandle != null) {  		try {  			bool isBeingDebugged = item.ProcessQueryHandle.IsBeingDebugged ();  			if (isBeingDebugged != item.IsBeingDebugged) {  				item.IsBeingDebugged = isBeingDebugged;  				fullUpdate = true;  			}  		}  		catch {  		}  	}  	// Processes sometimes mistakenly get labeled as packed.   	// Try again if it is packed.  	if (pid > 0) {  		if (item.IsPacked && item.ProcessingAttempts < 3) {  			WorkQueue.GlobalQueueWorkItemTag (new QueryProcessDelegate (this.QueryProcessStage2)' "process-stage2"' pid' item.FileName' true);  			item.ProcessingAttempts++;  		}  	}  	if (item.JustProcessed)  		fullUpdate = true;  	// If we need a full update' call the dictionary modified   	// event so the process tree updates the process'   	// highlighting color.  	if (fullUpdate) {  		this.OnDictionaryModified (null' item);  	}  	item.JustProcessed = false;  }  
Magic Number,ProcessHacker,ProcessSystemProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ProcessSystemProvider.cs,Update,The following statement contains a magic number: if (!Dictionary.ContainsKey (pid)) {  	ProcessItem item = new ProcessItem ();  	// Set up basic process information.  	item.RunId = this.RunCount;  	item.Pid = pid;  	item.Process = processInfo;  	item.SessionId = processInfo.SessionId;  	item.ProcessingAttempts = 1;  	item.Name = procs [pid].Name;  	// Create the delta and history managers.  	item.CpuKernelDelta = new Int64Delta (processInfo.KernelTime);  	item.CpuUserDelta = new Int64Delta (processInfo.UserTime);  	item.IoReadDelta = new Int64Delta ((long)processInfo.IoCounters.ReadTransferCount);  	item.IoWriteDelta = new Int64Delta ((long)processInfo.IoCounters.WriteTransferCount);  	item.IoOtherDelta = new Int64Delta ((long)processInfo.IoCounters.OtherTransferCount);  	item.CpuKernelHistory = new CircularBuffer<float> (_historyMaxSize);  	item.CpuUserHistory = new CircularBuffer<float> (_historyMaxSize);  	item.IoReadHistory = new CircularBuffer<long> (_historyMaxSize);  	item.IoWriteHistory = new CircularBuffer<long> (_historyMaxSize);  	item.IoOtherHistory = new CircularBuffer<long> (_historyMaxSize);  	item.IoReadOtherHistory = new CircularBuffer<long> (_historyMaxSize);  	item.PrivateMemoryHistory = new CircularBuffer<long> (_historyMaxSize);  	item.WorkingSetHistory = new CircularBuffer<long> (_historyMaxSize);  	// HACK: Shouldn't happen' but it does - sometimes   	// the process name is null.  	if (item.Name == null) {  		try {  			using (var phandle = new ProcessHandle (pid' ProcessAccess.QueryInformation | ProcessAccess.VmRead))  				item.Name = phandle.GetMainModule ().BaseName;  		}  		catch {  			item.Name = "";  		}  	}  	// Get the process' creation time and check the   	// parent process ID.  	try {  		item.CreateTime = DateTime.FromFileTime (processInfo.CreateTime);  	}  	catch {  	}  	if (pid > 0) {  		item.ParentPid = processInfo.InheritedFromProcessId;  		item.HasParent = true;  		if (!procs.ContainsKey (item.ParentPid) || item.ParentPid == pid) {  			item.HasParent = false;  		}  		else if (procs.ContainsKey (item.ParentPid)) {  			// Check the parent's creation time to see if it's actually the parent.  			ulong parentStartTime = (ulong)procs [item.ParentPid].Process.CreateTime;  			ulong thisStartTime = (ulong)processInfo.CreateTime;  			if (parentStartTime > thisStartTime)  				item.HasParent = false;  		}  		// Get the process' token's username.  		try {  			using (var queryLimitedHandle = new ProcessHandle (pid' Program.MinProcessQueryRights)) {  				try {  					using (var thandle = queryLimitedHandle.GetToken (TokenAccess.Query)) {  						try {  							using (var sid = thandle.GetUser ())  								item.Username = sid.GetFullName (true);  						}  						catch {  						}  					}  				}  				catch {  				}  			}  		}  		catch {  		}  		// Get a process handle with QUERY_INFORMATION access' and   		// see if it's being debugged.  		try {  			item.ProcessQueryHandle = new ProcessHandle (pid' ProcessAccess.QueryInformation);  			try {  				item.IsBeingDebugged = item.ProcessQueryHandle.IsBeingDebugged ();  			}  			catch {  			}  		}  		catch {  		}  	}  	// Update the process name if it's a fake process.  	if (pid == 0) {  		item.Name = "System Idle Process";  	}  	else if (pid == -2) {  		item.ParentPid = 0;  		item.HasParent = true;  	}  	else if (pid == -3) {  		item.ParentPid = 0;  		item.HasParent = true;  	}  	// If this is not the first run' we process the item immediately.  	if (this.RunCount > 0) {  		this.FillPqResult (item' this.QueryProcessStage1 (pid' null' false' false));  	}  	else {  		if (pid > 0) {  			WorkQueue.GlobalQueueWorkItemTag (new QueryProcessDelegate (this.QueryProcessStage1)' "process-stage1"' pid' item.FileName' false);  		}  	}  	// Set the username for System Idle Process and System.  	if (pid == 0 || pid == 4) {  		// TODO: Potential localization problem. Need to create   		// a well-known SID and use that.  		item.Username = "NT AUTHORITY\\SYSTEM";  	}  	// If we didn't get a username' try to use Terminal Services   	// to get the SID of the process' token's user.  	if (pid > 4 && item.Username == null) {  		if (tsProcesses == null) {  			// Delay loading until this point.  			tsProcesses = new Dictionary<int' IntPtr> ();  			wtsEnumData = Win32.TSEnumProcessesFast ();  			for (int i = 0; i < wtsEnumData.PIDs.Length; i++)  				tsProcesses.Add (wtsEnumData.PIDs [i]' wtsEnumData.SIDs [i]);  		}  		try {  			item.Username = Sid.FromPointer (tsProcesses [pid]).GetFullName (true);  		}  		catch {  		}  	}  	newdictionary.Add (pid' item);  	this.OnDictionaryAdded (item);  }  // look for modified processes  else {  	ProcessItem item = this.Dictionary [pid];  	bool fullUpdate = false;  	// Update process performance information.  	item.CpuKernelDelta.Update (processInfo.KernelTime);  	item.CpuUserDelta.Update (processInfo.UserTime);  	item.IoReadDelta.Update ((long)processInfo.IoCounters.ReadTransferCount);  	item.IoWriteDelta.Update ((long)processInfo.IoCounters.WriteTransferCount);  	item.IoOtherDelta.Update ((long)processInfo.IoCounters.OtherTransferCount);  	UpdateCb (item.CpuKernelHistory' (float)item.CpuKernelDelta.Delta / (sysKernelTime + sysUserTime + otherTime));  	UpdateCb (item.CpuUserHistory' (float)item.CpuUserDelta.Delta / (sysKernelTime + sysUserTime + otherTime));  	UpdateCb (item.IoReadHistory' item.IoReadDelta.Delta);  	UpdateCb (item.IoWriteHistory' item.IoWriteDelta.Delta);  	UpdateCb (item.IoOtherHistory' item.IoOtherDelta.Delta);  	UpdateCb (item.IoReadOtherHistory' item.IoReadDelta.Delta + item.IoOtherDelta.Delta);  	UpdateCb (item.PrivateMemoryHistory' processInfo.VirtualMemoryCounters.PrivatePageCount.ToInt64 ());  	UpdateCb (item.WorkingSetHistory' processInfo.VirtualMemoryCounters.WorkingSetSize.ToInt64 ());  	// Update the struct.  	item.Process = processInfo;  	// Update CPU usage' and update PIDs with most activity.  	try {  		item.CpuUsage = (float)(item.CpuUserDelta.Delta + item.CpuKernelDelta.Delta) * 100 / (sysKernelTime + sysUserTime + otherTime);  		// HACK.  		if (item.CpuUsage > 400.0f)  			item.CpuUsage /= 8.0f;  		else if (item.CpuUsage > 200.0f)  			item.CpuUsage /= 4.0f;  		else if (item.CpuUsage > 100.0f)  			item.CpuUsage /= 2.0f;  		if (pid != 0 && item.CpuUsage > mostCPUUsage) {  			mostCPUUsage = item.CpuUsage;  			this.PidWithMostCpuUsage = pid;  		}  		if (pid != 0 && (item.IoReadDelta.Delta + item.IoWriteDelta.Delta) > mostIOActivity) {  			mostIOActivity = item.IoReadDelta.Delta + item.IoWriteDelta.Delta;  			this.PidWithMostIoActivity = pid;  		}  	}  	catch {  	}  	// Determine whether the process is being debugged.  	if (item.ProcessQueryHandle != null) {  		try {  			bool isBeingDebugged = item.ProcessQueryHandle.IsBeingDebugged ();  			if (isBeingDebugged != item.IsBeingDebugged) {  				item.IsBeingDebugged = isBeingDebugged;  				fullUpdate = true;  			}  		}  		catch {  		}  	}  	// Processes sometimes mistakenly get labeled as packed.   	// Try again if it is packed.  	if (pid > 0) {  		if (item.IsPacked && item.ProcessingAttempts < 3) {  			WorkQueue.GlobalQueueWorkItemTag (new QueryProcessDelegate (this.QueryProcessStage2)' "process-stage2"' pid' item.FileName' true);  			item.ProcessingAttempts++;  		}  	}  	if (item.JustProcessed)  		fullUpdate = true;  	// If we need a full update' call the dictionary modified   	// event so the process tree updates the process'   	// highlighting color.  	if (fullUpdate) {  		this.OnDictionaryModified (null' item);  	}  	item.JustProcessed = false;  }  
Magic Number,ProcessHacker,ProcessSystemProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ProcessSystemProvider.cs,Update,The following statement contains a magic number: if (!Dictionary.ContainsKey (pid)) {  	ProcessItem item = new ProcessItem ();  	// Set up basic process information.  	item.RunId = this.RunCount;  	item.Pid = pid;  	item.Process = processInfo;  	item.SessionId = processInfo.SessionId;  	item.ProcessingAttempts = 1;  	item.Name = procs [pid].Name;  	// Create the delta and history managers.  	item.CpuKernelDelta = new Int64Delta (processInfo.KernelTime);  	item.CpuUserDelta = new Int64Delta (processInfo.UserTime);  	item.IoReadDelta = new Int64Delta ((long)processInfo.IoCounters.ReadTransferCount);  	item.IoWriteDelta = new Int64Delta ((long)processInfo.IoCounters.WriteTransferCount);  	item.IoOtherDelta = new Int64Delta ((long)processInfo.IoCounters.OtherTransferCount);  	item.CpuKernelHistory = new CircularBuffer<float> (_historyMaxSize);  	item.CpuUserHistory = new CircularBuffer<float> (_historyMaxSize);  	item.IoReadHistory = new CircularBuffer<long> (_historyMaxSize);  	item.IoWriteHistory = new CircularBuffer<long> (_historyMaxSize);  	item.IoOtherHistory = new CircularBuffer<long> (_historyMaxSize);  	item.IoReadOtherHistory = new CircularBuffer<long> (_historyMaxSize);  	item.PrivateMemoryHistory = new CircularBuffer<long> (_historyMaxSize);  	item.WorkingSetHistory = new CircularBuffer<long> (_historyMaxSize);  	// HACK: Shouldn't happen' but it does - sometimes   	// the process name is null.  	if (item.Name == null) {  		try {  			using (var phandle = new ProcessHandle (pid' ProcessAccess.QueryInformation | ProcessAccess.VmRead))  				item.Name = phandle.GetMainModule ().BaseName;  		}  		catch {  			item.Name = "";  		}  	}  	// Get the process' creation time and check the   	// parent process ID.  	try {  		item.CreateTime = DateTime.FromFileTime (processInfo.CreateTime);  	}  	catch {  	}  	if (pid > 0) {  		item.ParentPid = processInfo.InheritedFromProcessId;  		item.HasParent = true;  		if (!procs.ContainsKey (item.ParentPid) || item.ParentPid == pid) {  			item.HasParent = false;  		}  		else if (procs.ContainsKey (item.ParentPid)) {  			// Check the parent's creation time to see if it's actually the parent.  			ulong parentStartTime = (ulong)procs [item.ParentPid].Process.CreateTime;  			ulong thisStartTime = (ulong)processInfo.CreateTime;  			if (parentStartTime > thisStartTime)  				item.HasParent = false;  		}  		// Get the process' token's username.  		try {  			using (var queryLimitedHandle = new ProcessHandle (pid' Program.MinProcessQueryRights)) {  				try {  					using (var thandle = queryLimitedHandle.GetToken (TokenAccess.Query)) {  						try {  							using (var sid = thandle.GetUser ())  								item.Username = sid.GetFullName (true);  						}  						catch {  						}  					}  				}  				catch {  				}  			}  		}  		catch {  		}  		// Get a process handle with QUERY_INFORMATION access' and   		// see if it's being debugged.  		try {  			item.ProcessQueryHandle = new ProcessHandle (pid' ProcessAccess.QueryInformation);  			try {  				item.IsBeingDebugged = item.ProcessQueryHandle.IsBeingDebugged ();  			}  			catch {  			}  		}  		catch {  		}  	}  	// Update the process name if it's a fake process.  	if (pid == 0) {  		item.Name = "System Idle Process";  	}  	else if (pid == -2) {  		item.ParentPid = 0;  		item.HasParent = true;  	}  	else if (pid == -3) {  		item.ParentPid = 0;  		item.HasParent = true;  	}  	// If this is not the first run' we process the item immediately.  	if (this.RunCount > 0) {  		this.FillPqResult (item' this.QueryProcessStage1 (pid' null' false' false));  	}  	else {  		if (pid > 0) {  			WorkQueue.GlobalQueueWorkItemTag (new QueryProcessDelegate (this.QueryProcessStage1)' "process-stage1"' pid' item.FileName' false);  		}  	}  	// Set the username for System Idle Process and System.  	if (pid == 0 || pid == 4) {  		// TODO: Potential localization problem. Need to create   		// a well-known SID and use that.  		item.Username = "NT AUTHORITY\\SYSTEM";  	}  	// If we didn't get a username' try to use Terminal Services   	// to get the SID of the process' token's user.  	if (pid > 4 && item.Username == null) {  		if (tsProcesses == null) {  			// Delay loading until this point.  			tsProcesses = new Dictionary<int' IntPtr> ();  			wtsEnumData = Win32.TSEnumProcessesFast ();  			for (int i = 0; i < wtsEnumData.PIDs.Length; i++)  				tsProcesses.Add (wtsEnumData.PIDs [i]' wtsEnumData.SIDs [i]);  		}  		try {  			item.Username = Sid.FromPointer (tsProcesses [pid]).GetFullName (true);  		}  		catch {  		}  	}  	newdictionary.Add (pid' item);  	this.OnDictionaryAdded (item);  }  // look for modified processes  else {  	ProcessItem item = this.Dictionary [pid];  	bool fullUpdate = false;  	// Update process performance information.  	item.CpuKernelDelta.Update (processInfo.KernelTime);  	item.CpuUserDelta.Update (processInfo.UserTime);  	item.IoReadDelta.Update ((long)processInfo.IoCounters.ReadTransferCount);  	item.IoWriteDelta.Update ((long)processInfo.IoCounters.WriteTransferCount);  	item.IoOtherDelta.Update ((long)processInfo.IoCounters.OtherTransferCount);  	UpdateCb (item.CpuKernelHistory' (float)item.CpuKernelDelta.Delta / (sysKernelTime + sysUserTime + otherTime));  	UpdateCb (item.CpuUserHistory' (float)item.CpuUserDelta.Delta / (sysKernelTime + sysUserTime + otherTime));  	UpdateCb (item.IoReadHistory' item.IoReadDelta.Delta);  	UpdateCb (item.IoWriteHistory' item.IoWriteDelta.Delta);  	UpdateCb (item.IoOtherHistory' item.IoOtherDelta.Delta);  	UpdateCb (item.IoReadOtherHistory' item.IoReadDelta.Delta + item.IoOtherDelta.Delta);  	UpdateCb (item.PrivateMemoryHistory' processInfo.VirtualMemoryCounters.PrivatePageCount.ToInt64 ());  	UpdateCb (item.WorkingSetHistory' processInfo.VirtualMemoryCounters.WorkingSetSize.ToInt64 ());  	// Update the struct.  	item.Process = processInfo;  	// Update CPU usage' and update PIDs with most activity.  	try {  		item.CpuUsage = (float)(item.CpuUserDelta.Delta + item.CpuKernelDelta.Delta) * 100 / (sysKernelTime + sysUserTime + otherTime);  		// HACK.  		if (item.CpuUsage > 400.0f)  			item.CpuUsage /= 8.0f;  		else if (item.CpuUsage > 200.0f)  			item.CpuUsage /= 4.0f;  		else if (item.CpuUsage > 100.0f)  			item.CpuUsage /= 2.0f;  		if (pid != 0 && item.CpuUsage > mostCPUUsage) {  			mostCPUUsage = item.CpuUsage;  			this.PidWithMostCpuUsage = pid;  		}  		if (pid != 0 && (item.IoReadDelta.Delta + item.IoWriteDelta.Delta) > mostIOActivity) {  			mostIOActivity = item.IoReadDelta.Delta + item.IoWriteDelta.Delta;  			this.PidWithMostIoActivity = pid;  		}  	}  	catch {  	}  	// Determine whether the process is being debugged.  	if (item.ProcessQueryHandle != null) {  		try {  			bool isBeingDebugged = item.ProcessQueryHandle.IsBeingDebugged ();  			if (isBeingDebugged != item.IsBeingDebugged) {  				item.IsBeingDebugged = isBeingDebugged;  				fullUpdate = true;  			}  		}  		catch {  		}  	}  	// Processes sometimes mistakenly get labeled as packed.   	// Try again if it is packed.  	if (pid > 0) {  		if (item.IsPacked && item.ProcessingAttempts < 3) {  			WorkQueue.GlobalQueueWorkItemTag (new QueryProcessDelegate (this.QueryProcessStage2)' "process-stage2"' pid' item.FileName' true);  			item.ProcessingAttempts++;  		}  	}  	if (item.JustProcessed)  		fullUpdate = true;  	// If we need a full update' call the dictionary modified   	// event so the process tree updates the process'   	// highlighting color.  	if (fullUpdate) {  		this.OnDictionaryModified (null' item);  	}  	item.JustProcessed = false;  }  
Magic Number,ProcessHacker,ProcessSystemProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ProcessSystemProvider.cs,Update,The following statement contains a magic number: if (!Dictionary.ContainsKey (pid)) {  	ProcessItem item = new ProcessItem ();  	// Set up basic process information.  	item.RunId = this.RunCount;  	item.Pid = pid;  	item.Process = processInfo;  	item.SessionId = processInfo.SessionId;  	item.ProcessingAttempts = 1;  	item.Name = procs [pid].Name;  	// Create the delta and history managers.  	item.CpuKernelDelta = new Int64Delta (processInfo.KernelTime);  	item.CpuUserDelta = new Int64Delta (processInfo.UserTime);  	item.IoReadDelta = new Int64Delta ((long)processInfo.IoCounters.ReadTransferCount);  	item.IoWriteDelta = new Int64Delta ((long)processInfo.IoCounters.WriteTransferCount);  	item.IoOtherDelta = new Int64Delta ((long)processInfo.IoCounters.OtherTransferCount);  	item.CpuKernelHistory = new CircularBuffer<float> (_historyMaxSize);  	item.CpuUserHistory = new CircularBuffer<float> (_historyMaxSize);  	item.IoReadHistory = new CircularBuffer<long> (_historyMaxSize);  	item.IoWriteHistory = new CircularBuffer<long> (_historyMaxSize);  	item.IoOtherHistory = new CircularBuffer<long> (_historyMaxSize);  	item.IoReadOtherHistory = new CircularBuffer<long> (_historyMaxSize);  	item.PrivateMemoryHistory = new CircularBuffer<long> (_historyMaxSize);  	item.WorkingSetHistory = new CircularBuffer<long> (_historyMaxSize);  	// HACK: Shouldn't happen' but it does - sometimes   	// the process name is null.  	if (item.Name == null) {  		try {  			using (var phandle = new ProcessHandle (pid' ProcessAccess.QueryInformation | ProcessAccess.VmRead))  				item.Name = phandle.GetMainModule ().BaseName;  		}  		catch {  			item.Name = "";  		}  	}  	// Get the process' creation time and check the   	// parent process ID.  	try {  		item.CreateTime = DateTime.FromFileTime (processInfo.CreateTime);  	}  	catch {  	}  	if (pid > 0) {  		item.ParentPid = processInfo.InheritedFromProcessId;  		item.HasParent = true;  		if (!procs.ContainsKey (item.ParentPid) || item.ParentPid == pid) {  			item.HasParent = false;  		}  		else if (procs.ContainsKey (item.ParentPid)) {  			// Check the parent's creation time to see if it's actually the parent.  			ulong parentStartTime = (ulong)procs [item.ParentPid].Process.CreateTime;  			ulong thisStartTime = (ulong)processInfo.CreateTime;  			if (parentStartTime > thisStartTime)  				item.HasParent = false;  		}  		// Get the process' token's username.  		try {  			using (var queryLimitedHandle = new ProcessHandle (pid' Program.MinProcessQueryRights)) {  				try {  					using (var thandle = queryLimitedHandle.GetToken (TokenAccess.Query)) {  						try {  							using (var sid = thandle.GetUser ())  								item.Username = sid.GetFullName (true);  						}  						catch {  						}  					}  				}  				catch {  				}  			}  		}  		catch {  		}  		// Get a process handle with QUERY_INFORMATION access' and   		// see if it's being debugged.  		try {  			item.ProcessQueryHandle = new ProcessHandle (pid' ProcessAccess.QueryInformation);  			try {  				item.IsBeingDebugged = item.ProcessQueryHandle.IsBeingDebugged ();  			}  			catch {  			}  		}  		catch {  		}  	}  	// Update the process name if it's a fake process.  	if (pid == 0) {  		item.Name = "System Idle Process";  	}  	else if (pid == -2) {  		item.ParentPid = 0;  		item.HasParent = true;  	}  	else if (pid == -3) {  		item.ParentPid = 0;  		item.HasParent = true;  	}  	// If this is not the first run' we process the item immediately.  	if (this.RunCount > 0) {  		this.FillPqResult (item' this.QueryProcessStage1 (pid' null' false' false));  	}  	else {  		if (pid > 0) {  			WorkQueue.GlobalQueueWorkItemTag (new QueryProcessDelegate (this.QueryProcessStage1)' "process-stage1"' pid' item.FileName' false);  		}  	}  	// Set the username for System Idle Process and System.  	if (pid == 0 || pid == 4) {  		// TODO: Potential localization problem. Need to create   		// a well-known SID and use that.  		item.Username = "NT AUTHORITY\\SYSTEM";  	}  	// If we didn't get a username' try to use Terminal Services   	// to get the SID of the process' token's user.  	if (pid > 4 && item.Username == null) {  		if (tsProcesses == null) {  			// Delay loading until this point.  			tsProcesses = new Dictionary<int' IntPtr> ();  			wtsEnumData = Win32.TSEnumProcessesFast ();  			for (int i = 0; i < wtsEnumData.PIDs.Length; i++)  				tsProcesses.Add (wtsEnumData.PIDs [i]' wtsEnumData.SIDs [i]);  		}  		try {  			item.Username = Sid.FromPointer (tsProcesses [pid]).GetFullName (true);  		}  		catch {  		}  	}  	newdictionary.Add (pid' item);  	this.OnDictionaryAdded (item);  }  // look for modified processes  else {  	ProcessItem item = this.Dictionary [pid];  	bool fullUpdate = false;  	// Update process performance information.  	item.CpuKernelDelta.Update (processInfo.KernelTime);  	item.CpuUserDelta.Update (processInfo.UserTime);  	item.IoReadDelta.Update ((long)processInfo.IoCounters.ReadTransferCount);  	item.IoWriteDelta.Update ((long)processInfo.IoCounters.WriteTransferCount);  	item.IoOtherDelta.Update ((long)processInfo.IoCounters.OtherTransferCount);  	UpdateCb (item.CpuKernelHistory' (float)item.CpuKernelDelta.Delta / (sysKernelTime + sysUserTime + otherTime));  	UpdateCb (item.CpuUserHistory' (float)item.CpuUserDelta.Delta / (sysKernelTime + sysUserTime + otherTime));  	UpdateCb (item.IoReadHistory' item.IoReadDelta.Delta);  	UpdateCb (item.IoWriteHistory' item.IoWriteDelta.Delta);  	UpdateCb (item.IoOtherHistory' item.IoOtherDelta.Delta);  	UpdateCb (item.IoReadOtherHistory' item.IoReadDelta.Delta + item.IoOtherDelta.Delta);  	UpdateCb (item.PrivateMemoryHistory' processInfo.VirtualMemoryCounters.PrivatePageCount.ToInt64 ());  	UpdateCb (item.WorkingSetHistory' processInfo.VirtualMemoryCounters.WorkingSetSize.ToInt64 ());  	// Update the struct.  	item.Process = processInfo;  	// Update CPU usage' and update PIDs with most activity.  	try {  		item.CpuUsage = (float)(item.CpuUserDelta.Delta + item.CpuKernelDelta.Delta) * 100 / (sysKernelTime + sysUserTime + otherTime);  		// HACK.  		if (item.CpuUsage > 400.0f)  			item.CpuUsage /= 8.0f;  		else if (item.CpuUsage > 200.0f)  			item.CpuUsage /= 4.0f;  		else if (item.CpuUsage > 100.0f)  			item.CpuUsage /= 2.0f;  		if (pid != 0 && item.CpuUsage > mostCPUUsage) {  			mostCPUUsage = item.CpuUsage;  			this.PidWithMostCpuUsage = pid;  		}  		if (pid != 0 && (item.IoReadDelta.Delta + item.IoWriteDelta.Delta) > mostIOActivity) {  			mostIOActivity = item.IoReadDelta.Delta + item.IoWriteDelta.Delta;  			this.PidWithMostIoActivity = pid;  		}  	}  	catch {  	}  	// Determine whether the process is being debugged.  	if (item.ProcessQueryHandle != null) {  		try {  			bool isBeingDebugged = item.ProcessQueryHandle.IsBeingDebugged ();  			if (isBeingDebugged != item.IsBeingDebugged) {  				item.IsBeingDebugged = isBeingDebugged;  				fullUpdate = true;  			}  		}  		catch {  		}  	}  	// Processes sometimes mistakenly get labeled as packed.   	// Try again if it is packed.  	if (pid > 0) {  		if (item.IsPacked && item.ProcessingAttempts < 3) {  			WorkQueue.GlobalQueueWorkItemTag (new QueryProcessDelegate (this.QueryProcessStage2)' "process-stage2"' pid' item.FileName' true);  			item.ProcessingAttempts++;  		}  	}  	if (item.JustProcessed)  		fullUpdate = true;  	// If we need a full update' call the dictionary modified   	// event so the process tree updates the process'   	// highlighting color.  	if (fullUpdate) {  		this.OnDictionaryModified (null' item);  	}  	item.JustProcessed = false;  }  
Magic Number,ProcessHacker,ProcessSystemProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ProcessSystemProvider.cs,Update,The following statement contains a magic number: if (!Dictionary.ContainsKey (pid)) {  	ProcessItem item = new ProcessItem ();  	// Set up basic process information.  	item.RunId = this.RunCount;  	item.Pid = pid;  	item.Process = processInfo;  	item.SessionId = processInfo.SessionId;  	item.ProcessingAttempts = 1;  	item.Name = procs [pid].Name;  	// Create the delta and history managers.  	item.CpuKernelDelta = new Int64Delta (processInfo.KernelTime);  	item.CpuUserDelta = new Int64Delta (processInfo.UserTime);  	item.IoReadDelta = new Int64Delta ((long)processInfo.IoCounters.ReadTransferCount);  	item.IoWriteDelta = new Int64Delta ((long)processInfo.IoCounters.WriteTransferCount);  	item.IoOtherDelta = new Int64Delta ((long)processInfo.IoCounters.OtherTransferCount);  	item.CpuKernelHistory = new CircularBuffer<float> (_historyMaxSize);  	item.CpuUserHistory = new CircularBuffer<float> (_historyMaxSize);  	item.IoReadHistory = new CircularBuffer<long> (_historyMaxSize);  	item.IoWriteHistory = new CircularBuffer<long> (_historyMaxSize);  	item.IoOtherHistory = new CircularBuffer<long> (_historyMaxSize);  	item.IoReadOtherHistory = new CircularBuffer<long> (_historyMaxSize);  	item.PrivateMemoryHistory = new CircularBuffer<long> (_historyMaxSize);  	item.WorkingSetHistory = new CircularBuffer<long> (_historyMaxSize);  	// HACK: Shouldn't happen' but it does - sometimes   	// the process name is null.  	if (item.Name == null) {  		try {  			using (var phandle = new ProcessHandle (pid' ProcessAccess.QueryInformation | ProcessAccess.VmRead))  				item.Name = phandle.GetMainModule ().BaseName;  		}  		catch {  			item.Name = "";  		}  	}  	// Get the process' creation time and check the   	// parent process ID.  	try {  		item.CreateTime = DateTime.FromFileTime (processInfo.CreateTime);  	}  	catch {  	}  	if (pid > 0) {  		item.ParentPid = processInfo.InheritedFromProcessId;  		item.HasParent = true;  		if (!procs.ContainsKey (item.ParentPid) || item.ParentPid == pid) {  			item.HasParent = false;  		}  		else if (procs.ContainsKey (item.ParentPid)) {  			// Check the parent's creation time to see if it's actually the parent.  			ulong parentStartTime = (ulong)procs [item.ParentPid].Process.CreateTime;  			ulong thisStartTime = (ulong)processInfo.CreateTime;  			if (parentStartTime > thisStartTime)  				item.HasParent = false;  		}  		// Get the process' token's username.  		try {  			using (var queryLimitedHandle = new ProcessHandle (pid' Program.MinProcessQueryRights)) {  				try {  					using (var thandle = queryLimitedHandle.GetToken (TokenAccess.Query)) {  						try {  							using (var sid = thandle.GetUser ())  								item.Username = sid.GetFullName (true);  						}  						catch {  						}  					}  				}  				catch {  				}  			}  		}  		catch {  		}  		// Get a process handle with QUERY_INFORMATION access' and   		// see if it's being debugged.  		try {  			item.ProcessQueryHandle = new ProcessHandle (pid' ProcessAccess.QueryInformation);  			try {  				item.IsBeingDebugged = item.ProcessQueryHandle.IsBeingDebugged ();  			}  			catch {  			}  		}  		catch {  		}  	}  	// Update the process name if it's a fake process.  	if (pid == 0) {  		item.Name = "System Idle Process";  	}  	else if (pid == -2) {  		item.ParentPid = 0;  		item.HasParent = true;  	}  	else if (pid == -3) {  		item.ParentPid = 0;  		item.HasParent = true;  	}  	// If this is not the first run' we process the item immediately.  	if (this.RunCount > 0) {  		this.FillPqResult (item' this.QueryProcessStage1 (pid' null' false' false));  	}  	else {  		if (pid > 0) {  			WorkQueue.GlobalQueueWorkItemTag (new QueryProcessDelegate (this.QueryProcessStage1)' "process-stage1"' pid' item.FileName' false);  		}  	}  	// Set the username for System Idle Process and System.  	if (pid == 0 || pid == 4) {  		// TODO: Potential localization problem. Need to create   		// a well-known SID and use that.  		item.Username = "NT AUTHORITY\\SYSTEM";  	}  	// If we didn't get a username' try to use Terminal Services   	// to get the SID of the process' token's user.  	if (pid > 4 && item.Username == null) {  		if (tsProcesses == null) {  			// Delay loading until this point.  			tsProcesses = new Dictionary<int' IntPtr> ();  			wtsEnumData = Win32.TSEnumProcessesFast ();  			for (int i = 0; i < wtsEnumData.PIDs.Length; i++)  				tsProcesses.Add (wtsEnumData.PIDs [i]' wtsEnumData.SIDs [i]);  		}  		try {  			item.Username = Sid.FromPointer (tsProcesses [pid]).GetFullName (true);  		}  		catch {  		}  	}  	newdictionary.Add (pid' item);  	this.OnDictionaryAdded (item);  }  // look for modified processes  else {  	ProcessItem item = this.Dictionary [pid];  	bool fullUpdate = false;  	// Update process performance information.  	item.CpuKernelDelta.Update (processInfo.KernelTime);  	item.CpuUserDelta.Update (processInfo.UserTime);  	item.IoReadDelta.Update ((long)processInfo.IoCounters.ReadTransferCount);  	item.IoWriteDelta.Update ((long)processInfo.IoCounters.WriteTransferCount);  	item.IoOtherDelta.Update ((long)processInfo.IoCounters.OtherTransferCount);  	UpdateCb (item.CpuKernelHistory' (float)item.CpuKernelDelta.Delta / (sysKernelTime + sysUserTime + otherTime));  	UpdateCb (item.CpuUserHistory' (float)item.CpuUserDelta.Delta / (sysKernelTime + sysUserTime + otherTime));  	UpdateCb (item.IoReadHistory' item.IoReadDelta.Delta);  	UpdateCb (item.IoWriteHistory' item.IoWriteDelta.Delta);  	UpdateCb (item.IoOtherHistory' item.IoOtherDelta.Delta);  	UpdateCb (item.IoReadOtherHistory' item.IoReadDelta.Delta + item.IoOtherDelta.Delta);  	UpdateCb (item.PrivateMemoryHistory' processInfo.VirtualMemoryCounters.PrivatePageCount.ToInt64 ());  	UpdateCb (item.WorkingSetHistory' processInfo.VirtualMemoryCounters.WorkingSetSize.ToInt64 ());  	// Update the struct.  	item.Process = processInfo;  	// Update CPU usage' and update PIDs with most activity.  	try {  		item.CpuUsage = (float)(item.CpuUserDelta.Delta + item.CpuKernelDelta.Delta) * 100 / (sysKernelTime + sysUserTime + otherTime);  		// HACK.  		if (item.CpuUsage > 400.0f)  			item.CpuUsage /= 8.0f;  		else if (item.CpuUsage > 200.0f)  			item.CpuUsage /= 4.0f;  		else if (item.CpuUsage > 100.0f)  			item.CpuUsage /= 2.0f;  		if (pid != 0 && item.CpuUsage > mostCPUUsage) {  			mostCPUUsage = item.CpuUsage;  			this.PidWithMostCpuUsage = pid;  		}  		if (pid != 0 && (item.IoReadDelta.Delta + item.IoWriteDelta.Delta) > mostIOActivity) {  			mostIOActivity = item.IoReadDelta.Delta + item.IoWriteDelta.Delta;  			this.PidWithMostIoActivity = pid;  		}  	}  	catch {  	}  	// Determine whether the process is being debugged.  	if (item.ProcessQueryHandle != null) {  		try {  			bool isBeingDebugged = item.ProcessQueryHandle.IsBeingDebugged ();  			if (isBeingDebugged != item.IsBeingDebugged) {  				item.IsBeingDebugged = isBeingDebugged;  				fullUpdate = true;  			}  		}  		catch {  		}  	}  	// Processes sometimes mistakenly get labeled as packed.   	// Try again if it is packed.  	if (pid > 0) {  		if (item.IsPacked && item.ProcessingAttempts < 3) {  			WorkQueue.GlobalQueueWorkItemTag (new QueryProcessDelegate (this.QueryProcessStage2)' "process-stage2"' pid' item.FileName' true);  			item.ProcessingAttempts++;  		}  	}  	if (item.JustProcessed)  		fullUpdate = true;  	// If we need a full update' call the dictionary modified   	// event so the process tree updates the process'   	// highlighting color.  	if (fullUpdate) {  		this.OnDictionaryModified (null' item);  	}  	item.JustProcessed = false;  }  
Magic Number,ProcessHacker,ProcessSystemProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ProcessSystemProvider.cs,Update,The following statement contains a magic number: if (!Dictionary.ContainsKey (pid)) {  	ProcessItem item = new ProcessItem ();  	// Set up basic process information.  	item.RunId = this.RunCount;  	item.Pid = pid;  	item.Process = processInfo;  	item.SessionId = processInfo.SessionId;  	item.ProcessingAttempts = 1;  	item.Name = procs [pid].Name;  	// Create the delta and history managers.  	item.CpuKernelDelta = new Int64Delta (processInfo.KernelTime);  	item.CpuUserDelta = new Int64Delta (processInfo.UserTime);  	item.IoReadDelta = new Int64Delta ((long)processInfo.IoCounters.ReadTransferCount);  	item.IoWriteDelta = new Int64Delta ((long)processInfo.IoCounters.WriteTransferCount);  	item.IoOtherDelta = new Int64Delta ((long)processInfo.IoCounters.OtherTransferCount);  	item.CpuKernelHistory = new CircularBuffer<float> (_historyMaxSize);  	item.CpuUserHistory = new CircularBuffer<float> (_historyMaxSize);  	item.IoReadHistory = new CircularBuffer<long> (_historyMaxSize);  	item.IoWriteHistory = new CircularBuffer<long> (_historyMaxSize);  	item.IoOtherHistory = new CircularBuffer<long> (_historyMaxSize);  	item.IoReadOtherHistory = new CircularBuffer<long> (_historyMaxSize);  	item.PrivateMemoryHistory = new CircularBuffer<long> (_historyMaxSize);  	item.WorkingSetHistory = new CircularBuffer<long> (_historyMaxSize);  	// HACK: Shouldn't happen' but it does - sometimes   	// the process name is null.  	if (item.Name == null) {  		try {  			using (var phandle = new ProcessHandle (pid' ProcessAccess.QueryInformation | ProcessAccess.VmRead))  				item.Name = phandle.GetMainModule ().BaseName;  		}  		catch {  			item.Name = "";  		}  	}  	// Get the process' creation time and check the   	// parent process ID.  	try {  		item.CreateTime = DateTime.FromFileTime (processInfo.CreateTime);  	}  	catch {  	}  	if (pid > 0) {  		item.ParentPid = processInfo.InheritedFromProcessId;  		item.HasParent = true;  		if (!procs.ContainsKey (item.ParentPid) || item.ParentPid == pid) {  			item.HasParent = false;  		}  		else if (procs.ContainsKey (item.ParentPid)) {  			// Check the parent's creation time to see if it's actually the parent.  			ulong parentStartTime = (ulong)procs [item.ParentPid].Process.CreateTime;  			ulong thisStartTime = (ulong)processInfo.CreateTime;  			if (parentStartTime > thisStartTime)  				item.HasParent = false;  		}  		// Get the process' token's username.  		try {  			using (var queryLimitedHandle = new ProcessHandle (pid' Program.MinProcessQueryRights)) {  				try {  					using (var thandle = queryLimitedHandle.GetToken (TokenAccess.Query)) {  						try {  							using (var sid = thandle.GetUser ())  								item.Username = sid.GetFullName (true);  						}  						catch {  						}  					}  				}  				catch {  				}  			}  		}  		catch {  		}  		// Get a process handle with QUERY_INFORMATION access' and   		// see if it's being debugged.  		try {  			item.ProcessQueryHandle = new ProcessHandle (pid' ProcessAccess.QueryInformation);  			try {  				item.IsBeingDebugged = item.ProcessQueryHandle.IsBeingDebugged ();  			}  			catch {  			}  		}  		catch {  		}  	}  	// Update the process name if it's a fake process.  	if (pid == 0) {  		item.Name = "System Idle Process";  	}  	else if (pid == -2) {  		item.ParentPid = 0;  		item.HasParent = true;  	}  	else if (pid == -3) {  		item.ParentPid = 0;  		item.HasParent = true;  	}  	// If this is not the first run' we process the item immediately.  	if (this.RunCount > 0) {  		this.FillPqResult (item' this.QueryProcessStage1 (pid' null' false' false));  	}  	else {  		if (pid > 0) {  			WorkQueue.GlobalQueueWorkItemTag (new QueryProcessDelegate (this.QueryProcessStage1)' "process-stage1"' pid' item.FileName' false);  		}  	}  	// Set the username for System Idle Process and System.  	if (pid == 0 || pid == 4) {  		// TODO: Potential localization problem. Need to create   		// a well-known SID and use that.  		item.Username = "NT AUTHORITY\\SYSTEM";  	}  	// If we didn't get a username' try to use Terminal Services   	// to get the SID of the process' token's user.  	if (pid > 4 && item.Username == null) {  		if (tsProcesses == null) {  			// Delay loading until this point.  			tsProcesses = new Dictionary<int' IntPtr> ();  			wtsEnumData = Win32.TSEnumProcessesFast ();  			for (int i = 0; i < wtsEnumData.PIDs.Length; i++)  				tsProcesses.Add (wtsEnumData.PIDs [i]' wtsEnumData.SIDs [i]);  		}  		try {  			item.Username = Sid.FromPointer (tsProcesses [pid]).GetFullName (true);  		}  		catch {  		}  	}  	newdictionary.Add (pid' item);  	this.OnDictionaryAdded (item);  }  // look for modified processes  else {  	ProcessItem item = this.Dictionary [pid];  	bool fullUpdate = false;  	// Update process performance information.  	item.CpuKernelDelta.Update (processInfo.KernelTime);  	item.CpuUserDelta.Update (processInfo.UserTime);  	item.IoReadDelta.Update ((long)processInfo.IoCounters.ReadTransferCount);  	item.IoWriteDelta.Update ((long)processInfo.IoCounters.WriteTransferCount);  	item.IoOtherDelta.Update ((long)processInfo.IoCounters.OtherTransferCount);  	UpdateCb (item.CpuKernelHistory' (float)item.CpuKernelDelta.Delta / (sysKernelTime + sysUserTime + otherTime));  	UpdateCb (item.CpuUserHistory' (float)item.CpuUserDelta.Delta / (sysKernelTime + sysUserTime + otherTime));  	UpdateCb (item.IoReadHistory' item.IoReadDelta.Delta);  	UpdateCb (item.IoWriteHistory' item.IoWriteDelta.Delta);  	UpdateCb (item.IoOtherHistory' item.IoOtherDelta.Delta);  	UpdateCb (item.IoReadOtherHistory' item.IoReadDelta.Delta + item.IoOtherDelta.Delta);  	UpdateCb (item.PrivateMemoryHistory' processInfo.VirtualMemoryCounters.PrivatePageCount.ToInt64 ());  	UpdateCb (item.WorkingSetHistory' processInfo.VirtualMemoryCounters.WorkingSetSize.ToInt64 ());  	// Update the struct.  	item.Process = processInfo;  	// Update CPU usage' and update PIDs with most activity.  	try {  		item.CpuUsage = (float)(item.CpuUserDelta.Delta + item.CpuKernelDelta.Delta) * 100 / (sysKernelTime + sysUserTime + otherTime);  		// HACK.  		if (item.CpuUsage > 400.0f)  			item.CpuUsage /= 8.0f;  		else if (item.CpuUsage > 200.0f)  			item.CpuUsage /= 4.0f;  		else if (item.CpuUsage > 100.0f)  			item.CpuUsage /= 2.0f;  		if (pid != 0 && item.CpuUsage > mostCPUUsage) {  			mostCPUUsage = item.CpuUsage;  			this.PidWithMostCpuUsage = pid;  		}  		if (pid != 0 && (item.IoReadDelta.Delta + item.IoWriteDelta.Delta) > mostIOActivity) {  			mostIOActivity = item.IoReadDelta.Delta + item.IoWriteDelta.Delta;  			this.PidWithMostIoActivity = pid;  		}  	}  	catch {  	}  	// Determine whether the process is being debugged.  	if (item.ProcessQueryHandle != null) {  		try {  			bool isBeingDebugged = item.ProcessQueryHandle.IsBeingDebugged ();  			if (isBeingDebugged != item.IsBeingDebugged) {  				item.IsBeingDebugged = isBeingDebugged;  				fullUpdate = true;  			}  		}  		catch {  		}  	}  	// Processes sometimes mistakenly get labeled as packed.   	// Try again if it is packed.  	if (pid > 0) {  		if (item.IsPacked && item.ProcessingAttempts < 3) {  			WorkQueue.GlobalQueueWorkItemTag (new QueryProcessDelegate (this.QueryProcessStage2)' "process-stage2"' pid' item.FileName' true);  			item.ProcessingAttempts++;  		}  	}  	if (item.JustProcessed)  		fullUpdate = true;  	// If we need a full update' call the dictionary modified   	// event so the process tree updates the process'   	// highlighting color.  	if (fullUpdate) {  		this.OnDictionaryModified (null' item);  	}  	item.JustProcessed = false;  }  
Magic Number,ProcessHacker,ProcessSystemProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ProcessSystemProvider.cs,Update,The following statement contains a magic number: if (pid == 0) {  	item.Name = "System Idle Process";  }  else if (pid == -2) {  	item.ParentPid = 0;  	item.HasParent = true;  }  else if (pid == -3) {  	item.ParentPid = 0;  	item.HasParent = true;  }  
Magic Number,ProcessHacker,ProcessSystemProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ProcessSystemProvider.cs,Update,The following statement contains a magic number: if (pid == 0) {  	item.Name = "System Idle Process";  }  else if (pid == -2) {  	item.ParentPid = 0;  	item.HasParent = true;  }  else if (pid == -3) {  	item.ParentPid = 0;  	item.HasParent = true;  }  
Magic Number,ProcessHacker,ProcessSystemProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ProcessSystemProvider.cs,Update,The following statement contains a magic number: if (pid == -2) {  	item.ParentPid = 0;  	item.HasParent = true;  }  else if (pid == -3) {  	item.ParentPid = 0;  	item.HasParent = true;  }  
Magic Number,ProcessHacker,ProcessSystemProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ProcessSystemProvider.cs,Update,The following statement contains a magic number: if (pid == -2) {  	item.ParentPid = 0;  	item.HasParent = true;  }  else if (pid == -3) {  	item.ParentPid = 0;  	item.HasParent = true;  }  
Magic Number,ProcessHacker,ProcessSystemProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ProcessSystemProvider.cs,Update,The following statement contains a magic number: if (pid == -3) {  	item.ParentPid = 0;  	item.HasParent = true;  }  
Magic Number,ProcessHacker,ProcessSystemProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ProcessSystemProvider.cs,Update,The following statement contains a magic number: if (pid == 0 || pid == 4) {  	// TODO: Potential localization problem. Need to create   	// a well-known SID and use that.  	item.Username = "NT AUTHORITY\\SYSTEM";  }  
Magic Number,ProcessHacker,ProcessSystemProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ProcessSystemProvider.cs,Update,The following statement contains a magic number: if (pid > 4 && item.Username == null) {  	if (tsProcesses == null) {  		// Delay loading until this point.  		tsProcesses = new Dictionary<int' IntPtr> ();  		wtsEnumData = Win32.TSEnumProcessesFast ();  		for (int i = 0; i < wtsEnumData.PIDs.Length; i++)  			tsProcesses.Add (wtsEnumData.PIDs [i]' wtsEnumData.SIDs [i]);  	}  	try {  		item.Username = Sid.FromPointer (tsProcesses [pid]).GetFullName (true);  	}  	catch {  	}  }  
Magic Number,ProcessHacker,ProcessSystemProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ProcessSystemProvider.cs,Update,The following statement contains a magic number: try {  	item.CpuUsage = (float)(item.CpuUserDelta.Delta + item.CpuKernelDelta.Delta) * 100 / (sysKernelTime + sysUserTime + otherTime);  	// HACK.  	if (item.CpuUsage > 400.0f)  		item.CpuUsage /= 8.0f;  	else if (item.CpuUsage > 200.0f)  		item.CpuUsage /= 4.0f;  	else if (item.CpuUsage > 100.0f)  		item.CpuUsage /= 2.0f;  	if (pid != 0 && item.CpuUsage > mostCPUUsage) {  		mostCPUUsage = item.CpuUsage;  		this.PidWithMostCpuUsage = pid;  	}  	if (pid != 0 && (item.IoReadDelta.Delta + item.IoWriteDelta.Delta) > mostIOActivity) {  		mostIOActivity = item.IoReadDelta.Delta + item.IoWriteDelta.Delta;  		this.PidWithMostIoActivity = pid;  	}  }  catch {  }  
Magic Number,ProcessHacker,ProcessSystemProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ProcessSystemProvider.cs,Update,The following statement contains a magic number: item.CpuUsage = (float)(item.CpuUserDelta.Delta + item.CpuKernelDelta.Delta) * 100 / (sysKernelTime + sysUserTime + otherTime);  
Magic Number,ProcessHacker,ProcessSystemProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ProcessSystemProvider.cs,Update,The following statement contains a magic number: if (pid > 0) {  	if (item.IsPacked && item.ProcessingAttempts < 3) {  		WorkQueue.GlobalQueueWorkItemTag (new QueryProcessDelegate (this.QueryProcessStage2)' "process-stage2"' pid' item.FileName' true);  		item.ProcessingAttempts++;  	}  }  
Magic Number,ProcessHacker,ProcessSystemProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ProcessSystemProvider.cs,Update,The following statement contains a magic number: if (item.IsPacked && item.ProcessingAttempts < 3) {  	WorkQueue.GlobalQueueWorkItemTag (new QueryProcessDelegate (this.QueryProcessStage2)' "process-stage2"' pid' item.FileName' true);  	item.ProcessingAttempts++;  }  
Magic Number,ProcessHacker,ModuleProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ModuleProvider.cs,Update,The following statement contains a magic number: if (_pid != 4 && _processHandle == null) {  	Logging.Log (Logging.Importance.Warning' "ModuleProvider: Process Handle is null' exiting...");  	return;  }  
Magic Number,ProcessHacker,ModuleProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ModuleProvider.cs,Update,The following statement contains a magic number: if (_pid != 4) {  	// Is this a WOW64 process? If it is' get the 32-bit modules.  	if (!_isWow64) {  		_processHandle.EnumModules (module =>  {  			if (!modules.ContainsKey (module.BaseAddress))  				modules.Add (module.BaseAddress' module);  			return true;  		});  	}  	else {  		using (DebugBuffer buffer = new DebugBuffer ()) {  			buffer.Query (_pid' RtlQueryProcessDebugFlags.Modules32 | RtlQueryProcessDebugFlags.NonInvasive);  			var processModules = buffer.GetModules ();  			foreach (var m in processModules) {  				// Most of the time we will get a duplicate entry -   				// the main executable image. Guard against that.  				if (!modules.ContainsKey (m.BaseAddress)) {  					modules.Add (m.BaseAddress' new ProcessModule (m.BaseAddress' m.Size' IntPtr.Zero' m.Flags' System.IO.Path.GetFileName (m.FileName)' m.FileName));  				}  			}  		}  	}  	// add mapped files  	_processHandle.EnumMemory (info =>  {  		if (info.Type == MemoryType.Mapped) {  			try {  				string fileName = _processHandle.GetMappedFileName (info.BaseAddress);  				if (fileName != null) {  					var fi = new System.IO.FileInfo (fileName);  					modules.Add (info.BaseAddress' new ProcessModule (info.BaseAddress' info.RegionSize.ToInt32 ()' IntPtr.Zero' 0' fi.Name' fi.FullName));  				}  			}  			catch {  			}  		}  		return true;  	});  }  else {  	// Add loaded kernel modules.  	Windows.EnumKernelModules (module =>  {  		if (!modules.ContainsKey (module.BaseAddress))  			modules.Add (module.BaseAddress' module);  		return true;  	});  }  
Magic Number,ProcessHacker,ThreadProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ThreadProvider.cs,LoadSymbols,The following statement contains a magic number: _symbolsWorkQueue.QueueWorkItemTag (new Action (() =>  {  	try {  		// Needed (maybe) to display the EULA  		Win32.SymbolServerSetOptions (SymbolServerOption.Unattended' 0);  	}  	catch (Exception ex) {  		Logging.Log (ex);  	}  	try {  		// Use the process handle if we have one' otherwise use the default ID generator.  		if (_processHandle != null)  			_symbols = new SymbolProvider (_processHandle);  		else  			_symbols = new SymbolProvider ();  		SymbolProvider.Options = SymbolOptions.DeferredLoads | (Settings.Instance.DbgHelpUndecorate ? SymbolOptions.UndName : 0);  		if (Settings.Instance.DbgHelpSearchPath != "")  			_symbols.SearchPath = Settings.Instance.DbgHelpSearchPath;  		try {  			if (_pid > 4) {  				using (var phandle = new ProcessHandle (_pid' Program.MinProcessQueryRights | Program.MinProcessReadMemoryRights)) {  					if (OSVersion.Architecture == OSArch.I386 || !phandle.IsWow64 ()) {  						// Load the process' modules.  						try {  							_symbols.LoadProcessModules (phandle);  						}  						catch {  						}  					}  					else {  						// Load the process' WOW64 modules.  						try {  							_symbols.LoadProcessWow64Modules (_pid);  						}  						catch {  						}  					}  					// If the process is CSRSS we should load kernel modules   					// due to the presence of kernel-mode threads.  					if (phandle.GetKnownProcessType () == KnownProcess.WindowsSubsystem)  						this.LoadKernelSymbols (true);  				}  			}  			else {  				this.LoadKernelSymbols (true);  			}  		}  		catch (WindowsException ex) {  			// Did we get Access Denied? At least load   			// kernel32.dll and ntdll.dll.  			try {  				ProcessHandle.Current.EnumModules (module =>  {  					if (module.BaseName.Equals ("kernel32.dll"' StringComparison.OrdinalIgnoreCase) || module.BaseName.Equals ("ntdll.dll"' StringComparison.OrdinalIgnoreCase)) {  						_symbols.LoadModule (module.FileName' module.BaseAddress' module.Size);  					}  					return true;  				});  			}  			catch (Exception ex2) {  				Logging.Log (ex2);  			}  			Logging.Log (ex);  		}  		catch (Exception ex) {  			Logging.Log (ex);  		}  	}  	finally {  		_moduleLoadCompletedEvent.Set ();  	}  })' "symbols-load");  
Magic Number,ProcessHacker,ThreadProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ThreadProvider.cs,LoadSymbols,The following statement contains a magic number: try {  	// Use the process handle if we have one' otherwise use the default ID generator.  	if (_processHandle != null)  		_symbols = new SymbolProvider (_processHandle);  	else  		_symbols = new SymbolProvider ();  	SymbolProvider.Options = SymbolOptions.DeferredLoads | (Settings.Instance.DbgHelpUndecorate ? SymbolOptions.UndName : 0);  	if (Settings.Instance.DbgHelpSearchPath != "")  		_symbols.SearchPath = Settings.Instance.DbgHelpSearchPath;  	try {  		if (_pid > 4) {  			using (var phandle = new ProcessHandle (_pid' Program.MinProcessQueryRights | Program.MinProcessReadMemoryRights)) {  				if (OSVersion.Architecture == OSArch.I386 || !phandle.IsWow64 ()) {  					// Load the process' modules.  					try {  						_symbols.LoadProcessModules (phandle);  					}  					catch {  					}  				}  				else {  					// Load the process' WOW64 modules.  					try {  						_symbols.LoadProcessWow64Modules (_pid);  					}  					catch {  					}  				}  				// If the process is CSRSS we should load kernel modules   				// due to the presence of kernel-mode threads.  				if (phandle.GetKnownProcessType () == KnownProcess.WindowsSubsystem)  					this.LoadKernelSymbols (true);  			}  		}  		else {  			this.LoadKernelSymbols (true);  		}  	}  	catch (WindowsException ex) {  		// Did we get Access Denied? At least load   		// kernel32.dll and ntdll.dll.  		try {  			ProcessHandle.Current.EnumModules (module =>  {  				if (module.BaseName.Equals ("kernel32.dll"' StringComparison.OrdinalIgnoreCase) || module.BaseName.Equals ("ntdll.dll"' StringComparison.OrdinalIgnoreCase)) {  					_symbols.LoadModule (module.FileName' module.BaseAddress' module.Size);  				}  				return true;  			});  		}  		catch (Exception ex2) {  			Logging.Log (ex2);  		}  		Logging.Log (ex);  	}  	catch (Exception ex) {  		Logging.Log (ex);  	}  }  finally {  	_moduleLoadCompletedEvent.Set ();  }  
Magic Number,ProcessHacker,ThreadProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ThreadProvider.cs,LoadSymbols,The following statement contains a magic number: try {  	if (_pid > 4) {  		using (var phandle = new ProcessHandle (_pid' Program.MinProcessQueryRights | Program.MinProcessReadMemoryRights)) {  			if (OSVersion.Architecture == OSArch.I386 || !phandle.IsWow64 ()) {  				// Load the process' modules.  				try {  					_symbols.LoadProcessModules (phandle);  				}  				catch {  				}  			}  			else {  				// Load the process' WOW64 modules.  				try {  					_symbols.LoadProcessWow64Modules (_pid);  				}  				catch {  				}  			}  			// If the process is CSRSS we should load kernel modules   			// due to the presence of kernel-mode threads.  			if (phandle.GetKnownProcessType () == KnownProcess.WindowsSubsystem)  				this.LoadKernelSymbols (true);  		}  	}  	else {  		this.LoadKernelSymbols (true);  	}  }  catch (WindowsException ex) {  	// Did we get Access Denied? At least load   	// kernel32.dll and ntdll.dll.  	try {  		ProcessHandle.Current.EnumModules (module =>  {  			if (module.BaseName.Equals ("kernel32.dll"' StringComparison.OrdinalIgnoreCase) || module.BaseName.Equals ("ntdll.dll"' StringComparison.OrdinalIgnoreCase)) {  				_symbols.LoadModule (module.FileName' module.BaseAddress' module.Size);  			}  			return true;  		});  	}  	catch (Exception ex2) {  		Logging.Log (ex2);  	}  	Logging.Log (ex);  }  catch (Exception ex) {  	Logging.Log (ex);  }  
Magic Number,ProcessHacker,ThreadProvider,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Providers\ThreadProvider.cs,LoadSymbols,The following statement contains a magic number: if (_pid > 4) {  	using (var phandle = new ProcessHandle (_pid' Program.MinProcessQueryRights | Program.MinProcessReadMemoryRights)) {  		if (OSVersion.Architecture == OSArch.I386 || !phandle.IsWow64 ()) {  			// Load the process' modules.  			try {  				_symbols.LoadProcessModules (phandle);  			}  			catch {  			}  		}  		else {  			// Load the process' WOW64 modules.  			try {  				_symbols.LoadProcessWow64Modules (_pid);  			}  			catch {  			}  		}  		// If the process is CSRSS we should load kernel modules   		// due to the presence of kernel-mode threads.  		if (phandle.GetKnownProcessType () == KnownProcess.WindowsSubsystem)  			this.LoadKernelSymbols (true);  	}  }  else {  	this.LoadKernelSymbols (true);  }  
Magic Number,ProcessHacker,MemoryEditor,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\MemoryEditor.cs,buttonValues_Click,The following statement contains a magic number: if (space >= 2) {  	ushort value = 0;  	value = (ushort)(hexBoxMemory.ByteProvider.ReadByte (addr + 1) << 8 | hexBoxMemory.ByteProvider.ReadByte (addr));  	values += "\r\n\r\n16-bit Integer' little-endian' unsigned: " + value.ToString ();  	values += "\r\n16-bit Integer' little-endian' signed: " + ((short)value).ToString ();  	value = (ushort)(hexBoxMemory.ByteProvider.ReadByte (addr) << 8 | hexBoxMemory.ByteProvider.ReadByte (addr + 1));  	values += "\r\n16-bit Integer' big-endian' unsigned: " + value.ToString ();  	values += "\r\n16-bit Integer' big-endian' signed: " + ((short)value).ToString ();  }  
Magic Number,ProcessHacker,MemoryEditor,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\MemoryEditor.cs,buttonValues_Click,The following statement contains a magic number: if (space >= 2) {  	ushort value = 0;  	value = (ushort)(hexBoxMemory.ByteProvider.ReadByte (addr + 1) << 8 | hexBoxMemory.ByteProvider.ReadByte (addr));  	values += "\r\n\r\n16-bit Integer' little-endian' unsigned: " + value.ToString ();  	values += "\r\n16-bit Integer' little-endian' signed: " + ((short)value).ToString ();  	value = (ushort)(hexBoxMemory.ByteProvider.ReadByte (addr) << 8 | hexBoxMemory.ByteProvider.ReadByte (addr + 1));  	values += "\r\n16-bit Integer' big-endian' unsigned: " + value.ToString ();  	values += "\r\n16-bit Integer' big-endian' signed: " + ((short)value).ToString ();  }  
Magic Number,ProcessHacker,MemoryEditor,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\MemoryEditor.cs,buttonValues_Click,The following statement contains a magic number: if (space >= 2) {  	ushort value = 0;  	value = (ushort)(hexBoxMemory.ByteProvider.ReadByte (addr + 1) << 8 | hexBoxMemory.ByteProvider.ReadByte (addr));  	values += "\r\n\r\n16-bit Integer' little-endian' unsigned: " + value.ToString ();  	values += "\r\n16-bit Integer' little-endian' signed: " + ((short)value).ToString ();  	value = (ushort)(hexBoxMemory.ByteProvider.ReadByte (addr) << 8 | hexBoxMemory.ByteProvider.ReadByte (addr + 1));  	values += "\r\n16-bit Integer' big-endian' unsigned: " + value.ToString ();  	values += "\r\n16-bit Integer' big-endian' signed: " + ((short)value).ToString ();  }  
Magic Number,ProcessHacker,MemoryEditor,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\MemoryEditor.cs,buttonValues_Click,The following statement contains a magic number: value = (ushort)(hexBoxMemory.ByteProvider.ReadByte (addr + 1) << 8 | hexBoxMemory.ByteProvider.ReadByte (addr));  
Magic Number,ProcessHacker,MemoryEditor,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\MemoryEditor.cs,buttonValues_Click,The following statement contains a magic number: value = (ushort)(hexBoxMemory.ByteProvider.ReadByte (addr) << 8 | hexBoxMemory.ByteProvider.ReadByte (addr + 1));  
Magic Number,ProcessHacker,MemoryEditor,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\MemoryEditor.cs,buttonValues_Click,The following statement contains a magic number: if (space >= 4) {  	uint value = 0;  	value = ((uint)hexBoxMemory.ByteProvider.ReadByte (addr + 3) << 24) + ((uint)hexBoxMemory.ByteProvider.ReadByte (addr + 2) << 16) + ((uint)hexBoxMemory.ByteProvider.ReadByte (addr + 1) << 8) + ((uint)hexBoxMemory.ByteProvider.ReadByte (addr));  	values += "\r\n\r\n32-bit Integer' little-endian' unsigned: " + value.ToString ();  	values += "\r\n32-bit Integer' little-endian' signed: " + ((int)value).ToString ();  	value = ((uint)hexBoxMemory.ByteProvider.ReadByte (addr) << 24) + ((uint)hexBoxMemory.ByteProvider.ReadByte (addr + 1) << 16) + ((uint)hexBoxMemory.ByteProvider.ReadByte (addr + 2) << 8) + ((uint)hexBoxMemory.ByteProvider.ReadByte (addr + 3));  	values += "\r\n32-bit Integer' big-endian' unsigned: " + value.ToString ();  	values += "\r\n32-bit Integer' big-endian' signed: " + ((int)value).ToString ();  }  
Magic Number,ProcessHacker,MemoryEditor,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\MemoryEditor.cs,buttonValues_Click,The following statement contains a magic number: if (space >= 4) {  	uint value = 0;  	value = ((uint)hexBoxMemory.ByteProvider.ReadByte (addr + 3) << 24) + ((uint)hexBoxMemory.ByteProvider.ReadByte (addr + 2) << 16) + ((uint)hexBoxMemory.ByteProvider.ReadByte (addr + 1) << 8) + ((uint)hexBoxMemory.ByteProvider.ReadByte (addr));  	values += "\r\n\r\n32-bit Integer' little-endian' unsigned: " + value.ToString ();  	values += "\r\n32-bit Integer' little-endian' signed: " + ((int)value).ToString ();  	value = ((uint)hexBoxMemory.ByteProvider.ReadByte (addr) << 24) + ((uint)hexBoxMemory.ByteProvider.ReadByte (addr + 1) << 16) + ((uint)hexBoxMemory.ByteProvider.ReadByte (addr + 2) << 8) + ((uint)hexBoxMemory.ByteProvider.ReadByte (addr + 3));  	values += "\r\n32-bit Integer' big-endian' unsigned: " + value.ToString ();  	values += "\r\n32-bit Integer' big-endian' signed: " + ((int)value).ToString ();  }  
Magic Number,ProcessHacker,MemoryEditor,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\MemoryEditor.cs,buttonValues_Click,The following statement contains a magic number: if (space >= 4) {  	uint value = 0;  	value = ((uint)hexBoxMemory.ByteProvider.ReadByte (addr + 3) << 24) + ((uint)hexBoxMemory.ByteProvider.ReadByte (addr + 2) << 16) + ((uint)hexBoxMemory.ByteProvider.ReadByte (addr + 1) << 8) + ((uint)hexBoxMemory.ByteProvider.ReadByte (addr));  	values += "\r\n\r\n32-bit Integer' little-endian' unsigned: " + value.ToString ();  	values += "\r\n32-bit Integer' little-endian' signed: " + ((int)value).ToString ();  	value = ((uint)hexBoxMemory.ByteProvider.ReadByte (addr) << 24) + ((uint)hexBoxMemory.ByteProvider.ReadByte (addr + 1) << 16) + ((uint)hexBoxMemory.ByteProvider.ReadByte (addr + 2) << 8) + ((uint)hexBoxMemory.ByteProvider.ReadByte (addr + 3));  	values += "\r\n32-bit Integer' big-endian' unsigned: " + value.ToString ();  	values += "\r\n32-bit Integer' big-endian' signed: " + ((int)value).ToString ();  }  
Magic Number,ProcessHacker,MemoryEditor,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\MemoryEditor.cs,buttonValues_Click,The following statement contains a magic number: if (space >= 4) {  	uint value = 0;  	value = ((uint)hexBoxMemory.ByteProvider.ReadByte (addr + 3) << 24) + ((uint)hexBoxMemory.ByteProvider.ReadByte (addr + 2) << 16) + ((uint)hexBoxMemory.ByteProvider.ReadByte (addr + 1) << 8) + ((uint)hexBoxMemory.ByteProvider.ReadByte (addr));  	values += "\r\n\r\n32-bit Integer' little-endian' unsigned: " + value.ToString ();  	values += "\r\n32-bit Integer' little-endian' signed: " + ((int)value).ToString ();  	value = ((uint)hexBoxMemory.ByteProvider.ReadByte (addr) << 24) + ((uint)hexBoxMemory.ByteProvider.ReadByte (addr + 1) << 16) + ((uint)hexBoxMemory.ByteProvider.ReadByte (addr + 2) << 8) + ((uint)hexBoxMemory.ByteProvider.ReadByte (addr + 3));  	values += "\r\n32-bit Integer' big-endian' unsigned: " + value.ToString ();  	values += "\r\n32-bit Integer' big-endian' signed: " + ((int)value).ToString ();  }  
Magic Number,ProcessHacker,MemoryEditor,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\MemoryEditor.cs,buttonValues_Click,The following statement contains a magic number: if (space >= 4) {  	uint value = 0;  	value = ((uint)hexBoxMemory.ByteProvider.ReadByte (addr + 3) << 24) + ((uint)hexBoxMemory.ByteProvider.ReadByte (addr + 2) << 16) + ((uint)hexBoxMemory.ByteProvider.ReadByte (addr + 1) << 8) + ((uint)hexBoxMemory.ByteProvider.ReadByte (addr));  	values += "\r\n\r\n32-bit Integer' little-endian' unsigned: " + value.ToString ();  	values += "\r\n32-bit Integer' little-endian' signed: " + ((int)value).ToString ();  	value = ((uint)hexBoxMemory.ByteProvider.ReadByte (addr) << 24) + ((uint)hexBoxMemory.ByteProvider.ReadByte (addr + 1) << 16) + ((uint)hexBoxMemory.ByteProvider.ReadByte (addr + 2) << 8) + ((uint)hexBoxMemory.ByteProvider.ReadByte (addr + 3));  	values += "\r\n32-bit Integer' big-endian' unsigned: " + value.ToString ();  	values += "\r\n32-bit Integer' big-endian' signed: " + ((int)value).ToString ();  }  
Magic Number,ProcessHacker,MemoryEditor,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\MemoryEditor.cs,buttonValues_Click,The following statement contains a magic number: if (space >= 4) {  	uint value = 0;  	value = ((uint)hexBoxMemory.ByteProvider.ReadByte (addr + 3) << 24) + ((uint)hexBoxMemory.ByteProvider.ReadByte (addr + 2) << 16) + ((uint)hexBoxMemory.ByteProvider.ReadByte (addr + 1) << 8) + ((uint)hexBoxMemory.ByteProvider.ReadByte (addr));  	values += "\r\n\r\n32-bit Integer' little-endian' unsigned: " + value.ToString ();  	values += "\r\n32-bit Integer' little-endian' signed: " + ((int)value).ToString ();  	value = ((uint)hexBoxMemory.ByteProvider.ReadByte (addr) << 24) + ((uint)hexBoxMemory.ByteProvider.ReadByte (addr + 1) << 16) + ((uint)hexBoxMemory.ByteProvider.ReadByte (addr + 2) << 8) + ((uint)hexBoxMemory.ByteProvider.ReadByte (addr + 3));  	values += "\r\n32-bit Integer' big-endian' unsigned: " + value.ToString ();  	values += "\r\n32-bit Integer' big-endian' signed: " + ((int)value).ToString ();  }  
Magic Number,ProcessHacker,MemoryEditor,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\MemoryEditor.cs,buttonValues_Click,The following statement contains a magic number: if (space >= 4) {  	uint value = 0;  	value = ((uint)hexBoxMemory.ByteProvider.ReadByte (addr + 3) << 24) + ((uint)hexBoxMemory.ByteProvider.ReadByte (addr + 2) << 16) + ((uint)hexBoxMemory.ByteProvider.ReadByte (addr + 1) << 8) + ((uint)hexBoxMemory.ByteProvider.ReadByte (addr));  	values += "\r\n\r\n32-bit Integer' little-endian' unsigned: " + value.ToString ();  	values += "\r\n32-bit Integer' little-endian' signed: " + ((int)value).ToString ();  	value = ((uint)hexBoxMemory.ByteProvider.ReadByte (addr) << 24) + ((uint)hexBoxMemory.ByteProvider.ReadByte (addr + 1) << 16) + ((uint)hexBoxMemory.ByteProvider.ReadByte (addr + 2) << 8) + ((uint)hexBoxMemory.ByteProvider.ReadByte (addr + 3));  	values += "\r\n32-bit Integer' big-endian' unsigned: " + value.ToString ();  	values += "\r\n32-bit Integer' big-endian' signed: " + ((int)value).ToString ();  }  
Magic Number,ProcessHacker,MemoryEditor,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\MemoryEditor.cs,buttonValues_Click,The following statement contains a magic number: if (space >= 4) {  	uint value = 0;  	value = ((uint)hexBoxMemory.ByteProvider.ReadByte (addr + 3) << 24) + ((uint)hexBoxMemory.ByteProvider.ReadByte (addr + 2) << 16) + ((uint)hexBoxMemory.ByteProvider.ReadByte (addr + 1) << 8) + ((uint)hexBoxMemory.ByteProvider.ReadByte (addr));  	values += "\r\n\r\n32-bit Integer' little-endian' unsigned: " + value.ToString ();  	values += "\r\n32-bit Integer' little-endian' signed: " + ((int)value).ToString ();  	value = ((uint)hexBoxMemory.ByteProvider.ReadByte (addr) << 24) + ((uint)hexBoxMemory.ByteProvider.ReadByte (addr + 1) << 16) + ((uint)hexBoxMemory.ByteProvider.ReadByte (addr + 2) << 8) + ((uint)hexBoxMemory.ByteProvider.ReadByte (addr + 3));  	values += "\r\n32-bit Integer' big-endian' unsigned: " + value.ToString ();  	values += "\r\n32-bit Integer' big-endian' signed: " + ((int)value).ToString ();  }  
Magic Number,ProcessHacker,MemoryEditor,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\MemoryEditor.cs,buttonValues_Click,The following statement contains a magic number: if (space >= 4) {  	uint value = 0;  	value = ((uint)hexBoxMemory.ByteProvider.ReadByte (addr + 3) << 24) + ((uint)hexBoxMemory.ByteProvider.ReadByte (addr + 2) << 16) + ((uint)hexBoxMemory.ByteProvider.ReadByte (addr + 1) << 8) + ((uint)hexBoxMemory.ByteProvider.ReadByte (addr));  	values += "\r\n\r\n32-bit Integer' little-endian' unsigned: " + value.ToString ();  	values += "\r\n32-bit Integer' little-endian' signed: " + ((int)value).ToString ();  	value = ((uint)hexBoxMemory.ByteProvider.ReadByte (addr) << 24) + ((uint)hexBoxMemory.ByteProvider.ReadByte (addr + 1) << 16) + ((uint)hexBoxMemory.ByteProvider.ReadByte (addr + 2) << 8) + ((uint)hexBoxMemory.ByteProvider.ReadByte (addr + 3));  	values += "\r\n32-bit Integer' big-endian' unsigned: " + value.ToString ();  	values += "\r\n32-bit Integer' big-endian' signed: " + ((int)value).ToString ();  }  
Magic Number,ProcessHacker,MemoryEditor,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\MemoryEditor.cs,buttonValues_Click,The following statement contains a magic number: if (space >= 4) {  	uint value = 0;  	value = ((uint)hexBoxMemory.ByteProvider.ReadByte (addr + 3) << 24) + ((uint)hexBoxMemory.ByteProvider.ReadByte (addr + 2) << 16) + ((uint)hexBoxMemory.ByteProvider.ReadByte (addr + 1) << 8) + ((uint)hexBoxMemory.ByteProvider.ReadByte (addr));  	values += "\r\n\r\n32-bit Integer' little-endian' unsigned: " + value.ToString ();  	values += "\r\n32-bit Integer' little-endian' signed: " + ((int)value).ToString ();  	value = ((uint)hexBoxMemory.ByteProvider.ReadByte (addr) << 24) + ((uint)hexBoxMemory.ByteProvider.ReadByte (addr + 1) << 16) + ((uint)hexBoxMemory.ByteProvider.ReadByte (addr + 2) << 8) + ((uint)hexBoxMemory.ByteProvider.ReadByte (addr + 3));  	values += "\r\n32-bit Integer' big-endian' unsigned: " + value.ToString ();  	values += "\r\n32-bit Integer' big-endian' signed: " + ((int)value).ToString ();  }  
Magic Number,ProcessHacker,MemoryEditor,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\MemoryEditor.cs,buttonValues_Click,The following statement contains a magic number: if (space >= 4) {  	uint value = 0;  	value = ((uint)hexBoxMemory.ByteProvider.ReadByte (addr + 3) << 24) + ((uint)hexBoxMemory.ByteProvider.ReadByte (addr + 2) << 16) + ((uint)hexBoxMemory.ByteProvider.ReadByte (addr + 1) << 8) + ((uint)hexBoxMemory.ByteProvider.ReadByte (addr));  	values += "\r\n\r\n32-bit Integer' little-endian' unsigned: " + value.ToString ();  	values += "\r\n32-bit Integer' little-endian' signed: " + ((int)value).ToString ();  	value = ((uint)hexBoxMemory.ByteProvider.ReadByte (addr) << 24) + ((uint)hexBoxMemory.ByteProvider.ReadByte (addr + 1) << 16) + ((uint)hexBoxMemory.ByteProvider.ReadByte (addr + 2) << 8) + ((uint)hexBoxMemory.ByteProvider.ReadByte (addr + 3));  	values += "\r\n32-bit Integer' big-endian' unsigned: " + value.ToString ();  	values += "\r\n32-bit Integer' big-endian' signed: " + ((int)value).ToString ();  }  
Magic Number,ProcessHacker,MemoryEditor,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\MemoryEditor.cs,buttonValues_Click,The following statement contains a magic number: value = ((uint)hexBoxMemory.ByteProvider.ReadByte (addr + 3) << 24) + ((uint)hexBoxMemory.ByteProvider.ReadByte (addr + 2) << 16) + ((uint)hexBoxMemory.ByteProvider.ReadByte (addr + 1) << 8) + ((uint)hexBoxMemory.ByteProvider.ReadByte (addr));  
Magic Number,ProcessHacker,MemoryEditor,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\MemoryEditor.cs,buttonValues_Click,The following statement contains a magic number: value = ((uint)hexBoxMemory.ByteProvider.ReadByte (addr + 3) << 24) + ((uint)hexBoxMemory.ByteProvider.ReadByte (addr + 2) << 16) + ((uint)hexBoxMemory.ByteProvider.ReadByte (addr + 1) << 8) + ((uint)hexBoxMemory.ByteProvider.ReadByte (addr));  
Magic Number,ProcessHacker,MemoryEditor,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\MemoryEditor.cs,buttonValues_Click,The following statement contains a magic number: value = ((uint)hexBoxMemory.ByteProvider.ReadByte (addr + 3) << 24) + ((uint)hexBoxMemory.ByteProvider.ReadByte (addr + 2) << 16) + ((uint)hexBoxMemory.ByteProvider.ReadByte (addr + 1) << 8) + ((uint)hexBoxMemory.ByteProvider.ReadByte (addr));  
Magic Number,ProcessHacker,MemoryEditor,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\MemoryEditor.cs,buttonValues_Click,The following statement contains a magic number: value = ((uint)hexBoxMemory.ByteProvider.ReadByte (addr + 3) << 24) + ((uint)hexBoxMemory.ByteProvider.ReadByte (addr + 2) << 16) + ((uint)hexBoxMemory.ByteProvider.ReadByte (addr + 1) << 8) + ((uint)hexBoxMemory.ByteProvider.ReadByte (addr));  
Magic Number,ProcessHacker,MemoryEditor,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\MemoryEditor.cs,buttonValues_Click,The following statement contains a magic number: value = ((uint)hexBoxMemory.ByteProvider.ReadByte (addr + 3) << 24) + ((uint)hexBoxMemory.ByteProvider.ReadByte (addr + 2) << 16) + ((uint)hexBoxMemory.ByteProvider.ReadByte (addr + 1) << 8) + ((uint)hexBoxMemory.ByteProvider.ReadByte (addr));  
Magic Number,ProcessHacker,MemoryEditor,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\MemoryEditor.cs,buttonValues_Click,The following statement contains a magic number: value = ((uint)hexBoxMemory.ByteProvider.ReadByte (addr) << 24) + ((uint)hexBoxMemory.ByteProvider.ReadByte (addr + 1) << 16) + ((uint)hexBoxMemory.ByteProvider.ReadByte (addr + 2) << 8) + ((uint)hexBoxMemory.ByteProvider.ReadByte (addr + 3));  
Magic Number,ProcessHacker,MemoryEditor,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\MemoryEditor.cs,buttonValues_Click,The following statement contains a magic number: value = ((uint)hexBoxMemory.ByteProvider.ReadByte (addr) << 24) + ((uint)hexBoxMemory.ByteProvider.ReadByte (addr + 1) << 16) + ((uint)hexBoxMemory.ByteProvider.ReadByte (addr + 2) << 8) + ((uint)hexBoxMemory.ByteProvider.ReadByte (addr + 3));  
Magic Number,ProcessHacker,MemoryEditor,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\MemoryEditor.cs,buttonValues_Click,The following statement contains a magic number: value = ((uint)hexBoxMemory.ByteProvider.ReadByte (addr) << 24) + ((uint)hexBoxMemory.ByteProvider.ReadByte (addr + 1) << 16) + ((uint)hexBoxMemory.ByteProvider.ReadByte (addr + 2) << 8) + ((uint)hexBoxMemory.ByteProvider.ReadByte (addr + 3));  
Magic Number,ProcessHacker,MemoryEditor,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\MemoryEditor.cs,buttonValues_Click,The following statement contains a magic number: value = ((uint)hexBoxMemory.ByteProvider.ReadByte (addr) << 24) + ((uint)hexBoxMemory.ByteProvider.ReadByte (addr + 1) << 16) + ((uint)hexBoxMemory.ByteProvider.ReadByte (addr + 2) << 8) + ((uint)hexBoxMemory.ByteProvider.ReadByte (addr + 3));  
Magic Number,ProcessHacker,MemoryEditor,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\MemoryEditor.cs,buttonValues_Click,The following statement contains a magic number: value = ((uint)hexBoxMemory.ByteProvider.ReadByte (addr) << 24) + ((uint)hexBoxMemory.ByteProvider.ReadByte (addr + 1) << 16) + ((uint)hexBoxMemory.ByteProvider.ReadByte (addr + 2) << 8) + ((uint)hexBoxMemory.ByteProvider.ReadByte (addr + 3));  
Magic Number,ProcessHacker,MemoryEditor,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\MemoryEditor.cs,buttonValues_Click,The following statement contains a magic number: if (space >= 8) {  	ulong value = 0;  	value = ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 7) << 56) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 6) << 48) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 5) << 40) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 4) << 32) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 3) << 24) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 2) << 16) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 1) << 8) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr));  	values += "\r\n\r\n64-bit Integer' little-endian' unsigned: " + value.ToString ();  	values += "\r\n64-bit Integer' little-endian' signed: " + ((long)value).ToString ();  	value = ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr) << 56) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 1) << 48) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 2) << 40) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 3) << 32) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 4) << 24) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 5) << 16) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 6) << 8) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 7));  	values += "\r\n64-bit Integer' big-endian' unsigned: " + value.ToString ();  	values += "\r\n64-bit Integer' big-endian' signed: " + ((long)value).ToString ();  }  
Magic Number,ProcessHacker,MemoryEditor,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\MemoryEditor.cs,buttonValues_Click,The following statement contains a magic number: if (space >= 8) {  	ulong value = 0;  	value = ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 7) << 56) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 6) << 48) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 5) << 40) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 4) << 32) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 3) << 24) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 2) << 16) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 1) << 8) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr));  	values += "\r\n\r\n64-bit Integer' little-endian' unsigned: " + value.ToString ();  	values += "\r\n64-bit Integer' little-endian' signed: " + ((long)value).ToString ();  	value = ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr) << 56) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 1) << 48) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 2) << 40) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 3) << 32) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 4) << 24) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 5) << 16) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 6) << 8) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 7));  	values += "\r\n64-bit Integer' big-endian' unsigned: " + value.ToString ();  	values += "\r\n64-bit Integer' big-endian' signed: " + ((long)value).ToString ();  }  
Magic Number,ProcessHacker,MemoryEditor,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\MemoryEditor.cs,buttonValues_Click,The following statement contains a magic number: if (space >= 8) {  	ulong value = 0;  	value = ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 7) << 56) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 6) << 48) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 5) << 40) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 4) << 32) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 3) << 24) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 2) << 16) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 1) << 8) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr));  	values += "\r\n\r\n64-bit Integer' little-endian' unsigned: " + value.ToString ();  	values += "\r\n64-bit Integer' little-endian' signed: " + ((long)value).ToString ();  	value = ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr) << 56) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 1) << 48) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 2) << 40) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 3) << 32) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 4) << 24) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 5) << 16) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 6) << 8) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 7));  	values += "\r\n64-bit Integer' big-endian' unsigned: " + value.ToString ();  	values += "\r\n64-bit Integer' big-endian' signed: " + ((long)value).ToString ();  }  
Magic Number,ProcessHacker,MemoryEditor,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\MemoryEditor.cs,buttonValues_Click,The following statement contains a magic number: if (space >= 8) {  	ulong value = 0;  	value = ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 7) << 56) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 6) << 48) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 5) << 40) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 4) << 32) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 3) << 24) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 2) << 16) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 1) << 8) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr));  	values += "\r\n\r\n64-bit Integer' little-endian' unsigned: " + value.ToString ();  	values += "\r\n64-bit Integer' little-endian' signed: " + ((long)value).ToString ();  	value = ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr) << 56) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 1) << 48) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 2) << 40) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 3) << 32) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 4) << 24) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 5) << 16) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 6) << 8) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 7));  	values += "\r\n64-bit Integer' big-endian' unsigned: " + value.ToString ();  	values += "\r\n64-bit Integer' big-endian' signed: " + ((long)value).ToString ();  }  
Magic Number,ProcessHacker,MemoryEditor,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\MemoryEditor.cs,buttonValues_Click,The following statement contains a magic number: if (space >= 8) {  	ulong value = 0;  	value = ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 7) << 56) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 6) << 48) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 5) << 40) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 4) << 32) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 3) << 24) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 2) << 16) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 1) << 8) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr));  	values += "\r\n\r\n64-bit Integer' little-endian' unsigned: " + value.ToString ();  	values += "\r\n64-bit Integer' little-endian' signed: " + ((long)value).ToString ();  	value = ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr) << 56) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 1) << 48) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 2) << 40) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 3) << 32) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 4) << 24) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 5) << 16) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 6) << 8) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 7));  	values += "\r\n64-bit Integer' big-endian' unsigned: " + value.ToString ();  	values += "\r\n64-bit Integer' big-endian' signed: " + ((long)value).ToString ();  }  
Magic Number,ProcessHacker,MemoryEditor,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\MemoryEditor.cs,buttonValues_Click,The following statement contains a magic number: if (space >= 8) {  	ulong value = 0;  	value = ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 7) << 56) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 6) << 48) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 5) << 40) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 4) << 32) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 3) << 24) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 2) << 16) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 1) << 8) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr));  	values += "\r\n\r\n64-bit Integer' little-endian' unsigned: " + value.ToString ();  	values += "\r\n64-bit Integer' little-endian' signed: " + ((long)value).ToString ();  	value = ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr) << 56) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 1) << 48) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 2) << 40) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 3) << 32) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 4) << 24) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 5) << 16) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 6) << 8) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 7));  	values += "\r\n64-bit Integer' big-endian' unsigned: " + value.ToString ();  	values += "\r\n64-bit Integer' big-endian' signed: " + ((long)value).ToString ();  }  
Magic Number,ProcessHacker,MemoryEditor,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\MemoryEditor.cs,buttonValues_Click,The following statement contains a magic number: if (space >= 8) {  	ulong value = 0;  	value = ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 7) << 56) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 6) << 48) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 5) << 40) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 4) << 32) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 3) << 24) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 2) << 16) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 1) << 8) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr));  	values += "\r\n\r\n64-bit Integer' little-endian' unsigned: " + value.ToString ();  	values += "\r\n64-bit Integer' little-endian' signed: " + ((long)value).ToString ();  	value = ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr) << 56) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 1) << 48) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 2) << 40) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 3) << 32) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 4) << 24) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 5) << 16) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 6) << 8) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 7));  	values += "\r\n64-bit Integer' big-endian' unsigned: " + value.ToString ();  	values += "\r\n64-bit Integer' big-endian' signed: " + ((long)value).ToString ();  }  
Magic Number,ProcessHacker,MemoryEditor,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\MemoryEditor.cs,buttonValues_Click,The following statement contains a magic number: if (space >= 8) {  	ulong value = 0;  	value = ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 7) << 56) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 6) << 48) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 5) << 40) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 4) << 32) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 3) << 24) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 2) << 16) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 1) << 8) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr));  	values += "\r\n\r\n64-bit Integer' little-endian' unsigned: " + value.ToString ();  	values += "\r\n64-bit Integer' little-endian' signed: " + ((long)value).ToString ();  	value = ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr) << 56) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 1) << 48) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 2) << 40) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 3) << 32) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 4) << 24) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 5) << 16) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 6) << 8) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 7));  	values += "\r\n64-bit Integer' big-endian' unsigned: " + value.ToString ();  	values += "\r\n64-bit Integer' big-endian' signed: " + ((long)value).ToString ();  }  
Magic Number,ProcessHacker,MemoryEditor,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\MemoryEditor.cs,buttonValues_Click,The following statement contains a magic number: if (space >= 8) {  	ulong value = 0;  	value = ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 7) << 56) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 6) << 48) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 5) << 40) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 4) << 32) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 3) << 24) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 2) << 16) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 1) << 8) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr));  	values += "\r\n\r\n64-bit Integer' little-endian' unsigned: " + value.ToString ();  	values += "\r\n64-bit Integer' little-endian' signed: " + ((long)value).ToString ();  	value = ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr) << 56) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 1) << 48) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 2) << 40) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 3) << 32) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 4) << 24) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 5) << 16) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 6) << 8) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 7));  	values += "\r\n64-bit Integer' big-endian' unsigned: " + value.ToString ();  	values += "\r\n64-bit Integer' big-endian' signed: " + ((long)value).ToString ();  }  
Magic Number,ProcessHacker,MemoryEditor,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\MemoryEditor.cs,buttonValues_Click,The following statement contains a magic number: if (space >= 8) {  	ulong value = 0;  	value = ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 7) << 56) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 6) << 48) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 5) << 40) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 4) << 32) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 3) << 24) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 2) << 16) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 1) << 8) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr));  	values += "\r\n\r\n64-bit Integer' little-endian' unsigned: " + value.ToString ();  	values += "\r\n64-bit Integer' little-endian' signed: " + ((long)value).ToString ();  	value = ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr) << 56) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 1) << 48) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 2) << 40) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 3) << 32) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 4) << 24) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 5) << 16) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 6) << 8) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 7));  	values += "\r\n64-bit Integer' big-endian' unsigned: " + value.ToString ();  	values += "\r\n64-bit Integer' big-endian' signed: " + ((long)value).ToString ();  }  
Magic Number,ProcessHacker,MemoryEditor,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\MemoryEditor.cs,buttonValues_Click,The following statement contains a magic number: if (space >= 8) {  	ulong value = 0;  	value = ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 7) << 56) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 6) << 48) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 5) << 40) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 4) << 32) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 3) << 24) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 2) << 16) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 1) << 8) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr));  	values += "\r\n\r\n64-bit Integer' little-endian' unsigned: " + value.ToString ();  	values += "\r\n64-bit Integer' little-endian' signed: " + ((long)value).ToString ();  	value = ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr) << 56) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 1) << 48) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 2) << 40) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 3) << 32) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 4) << 24) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 5) << 16) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 6) << 8) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 7));  	values += "\r\n64-bit Integer' big-endian' unsigned: " + value.ToString ();  	values += "\r\n64-bit Integer' big-endian' signed: " + ((long)value).ToString ();  }  
Magic Number,ProcessHacker,MemoryEditor,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\MemoryEditor.cs,buttonValues_Click,The following statement contains a magic number: if (space >= 8) {  	ulong value = 0;  	value = ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 7) << 56) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 6) << 48) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 5) << 40) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 4) << 32) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 3) << 24) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 2) << 16) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 1) << 8) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr));  	values += "\r\n\r\n64-bit Integer' little-endian' unsigned: " + value.ToString ();  	values += "\r\n64-bit Integer' little-endian' signed: " + ((long)value).ToString ();  	value = ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr) << 56) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 1) << 48) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 2) << 40) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 3) << 32) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 4) << 24) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 5) << 16) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 6) << 8) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 7));  	values += "\r\n64-bit Integer' big-endian' unsigned: " + value.ToString ();  	values += "\r\n64-bit Integer' big-endian' signed: " + ((long)value).ToString ();  }  
Magic Number,ProcessHacker,MemoryEditor,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\MemoryEditor.cs,buttonValues_Click,The following statement contains a magic number: if (space >= 8) {  	ulong value = 0;  	value = ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 7) << 56) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 6) << 48) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 5) << 40) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 4) << 32) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 3) << 24) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 2) << 16) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 1) << 8) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr));  	values += "\r\n\r\n64-bit Integer' little-endian' unsigned: " + value.ToString ();  	values += "\r\n64-bit Integer' little-endian' signed: " + ((long)value).ToString ();  	value = ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr) << 56) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 1) << 48) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 2) << 40) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 3) << 32) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 4) << 24) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 5) << 16) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 6) << 8) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 7));  	values += "\r\n64-bit Integer' big-endian' unsigned: " + value.ToString ();  	values += "\r\n64-bit Integer' big-endian' signed: " + ((long)value).ToString ();  }  
Magic Number,ProcessHacker,MemoryEditor,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\MemoryEditor.cs,buttonValues_Click,The following statement contains a magic number: if (space >= 8) {  	ulong value = 0;  	value = ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 7) << 56) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 6) << 48) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 5) << 40) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 4) << 32) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 3) << 24) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 2) << 16) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 1) << 8) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr));  	values += "\r\n\r\n64-bit Integer' little-endian' unsigned: " + value.ToString ();  	values += "\r\n64-bit Integer' little-endian' signed: " + ((long)value).ToString ();  	value = ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr) << 56) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 1) << 48) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 2) << 40) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 3) << 32) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 4) << 24) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 5) << 16) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 6) << 8) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 7));  	values += "\r\n64-bit Integer' big-endian' unsigned: " + value.ToString ();  	values += "\r\n64-bit Integer' big-endian' signed: " + ((long)value).ToString ();  }  
Magic Number,ProcessHacker,MemoryEditor,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\MemoryEditor.cs,buttonValues_Click,The following statement contains a magic number: if (space >= 8) {  	ulong value = 0;  	value = ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 7) << 56) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 6) << 48) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 5) << 40) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 4) << 32) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 3) << 24) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 2) << 16) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 1) << 8) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr));  	values += "\r\n\r\n64-bit Integer' little-endian' unsigned: " + value.ToString ();  	values += "\r\n64-bit Integer' little-endian' signed: " + ((long)value).ToString ();  	value = ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr) << 56) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 1) << 48) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 2) << 40) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 3) << 32) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 4) << 24) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 5) << 16) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 6) << 8) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 7));  	values += "\r\n64-bit Integer' big-endian' unsigned: " + value.ToString ();  	values += "\r\n64-bit Integer' big-endian' signed: " + ((long)value).ToString ();  }  
Magic Number,ProcessHacker,MemoryEditor,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\MemoryEditor.cs,buttonValues_Click,The following statement contains a magic number: if (space >= 8) {  	ulong value = 0;  	value = ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 7) << 56) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 6) << 48) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 5) << 40) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 4) << 32) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 3) << 24) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 2) << 16) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 1) << 8) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr));  	values += "\r\n\r\n64-bit Integer' little-endian' unsigned: " + value.ToString ();  	values += "\r\n64-bit Integer' little-endian' signed: " + ((long)value).ToString ();  	value = ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr) << 56) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 1) << 48) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 2) << 40) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 3) << 32) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 4) << 24) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 5) << 16) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 6) << 8) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 7));  	values += "\r\n64-bit Integer' big-endian' unsigned: " + value.ToString ();  	values += "\r\n64-bit Integer' big-endian' signed: " + ((long)value).ToString ();  }  
Magic Number,ProcessHacker,MemoryEditor,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\MemoryEditor.cs,buttonValues_Click,The following statement contains a magic number: if (space >= 8) {  	ulong value = 0;  	value = ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 7) << 56) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 6) << 48) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 5) << 40) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 4) << 32) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 3) << 24) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 2) << 16) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 1) << 8) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr));  	values += "\r\n\r\n64-bit Integer' little-endian' unsigned: " + value.ToString ();  	values += "\r\n64-bit Integer' little-endian' signed: " + ((long)value).ToString ();  	value = ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr) << 56) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 1) << 48) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 2) << 40) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 3) << 32) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 4) << 24) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 5) << 16) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 6) << 8) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 7));  	values += "\r\n64-bit Integer' big-endian' unsigned: " + value.ToString ();  	values += "\r\n64-bit Integer' big-endian' signed: " + ((long)value).ToString ();  }  
Magic Number,ProcessHacker,MemoryEditor,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\MemoryEditor.cs,buttonValues_Click,The following statement contains a magic number: if (space >= 8) {  	ulong value = 0;  	value = ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 7) << 56) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 6) << 48) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 5) << 40) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 4) << 32) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 3) << 24) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 2) << 16) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 1) << 8) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr));  	values += "\r\n\r\n64-bit Integer' little-endian' unsigned: " + value.ToString ();  	values += "\r\n64-bit Integer' little-endian' signed: " + ((long)value).ToString ();  	value = ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr) << 56) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 1) << 48) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 2) << 40) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 3) << 32) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 4) << 24) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 5) << 16) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 6) << 8) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 7));  	values += "\r\n64-bit Integer' big-endian' unsigned: " + value.ToString ();  	values += "\r\n64-bit Integer' big-endian' signed: " + ((long)value).ToString ();  }  
Magic Number,ProcessHacker,MemoryEditor,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\MemoryEditor.cs,buttonValues_Click,The following statement contains a magic number: if (space >= 8) {  	ulong value = 0;  	value = ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 7) << 56) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 6) << 48) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 5) << 40) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 4) << 32) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 3) << 24) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 2) << 16) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 1) << 8) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr));  	values += "\r\n\r\n64-bit Integer' little-endian' unsigned: " + value.ToString ();  	values += "\r\n64-bit Integer' little-endian' signed: " + ((long)value).ToString ();  	value = ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr) << 56) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 1) << 48) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 2) << 40) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 3) << 32) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 4) << 24) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 5) << 16) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 6) << 8) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 7));  	values += "\r\n64-bit Integer' big-endian' unsigned: " + value.ToString ();  	values += "\r\n64-bit Integer' big-endian' signed: " + ((long)value).ToString ();  }  
Magic Number,ProcessHacker,MemoryEditor,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\MemoryEditor.cs,buttonValues_Click,The following statement contains a magic number: if (space >= 8) {  	ulong value = 0;  	value = ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 7) << 56) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 6) << 48) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 5) << 40) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 4) << 32) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 3) << 24) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 2) << 16) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 1) << 8) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr));  	values += "\r\n\r\n64-bit Integer' little-endian' unsigned: " + value.ToString ();  	values += "\r\n64-bit Integer' little-endian' signed: " + ((long)value).ToString ();  	value = ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr) << 56) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 1) << 48) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 2) << 40) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 3) << 32) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 4) << 24) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 5) << 16) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 6) << 8) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 7));  	values += "\r\n64-bit Integer' big-endian' unsigned: " + value.ToString ();  	values += "\r\n64-bit Integer' big-endian' signed: " + ((long)value).ToString ();  }  
Magic Number,ProcessHacker,MemoryEditor,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\MemoryEditor.cs,buttonValues_Click,The following statement contains a magic number: if (space >= 8) {  	ulong value = 0;  	value = ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 7) << 56) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 6) << 48) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 5) << 40) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 4) << 32) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 3) << 24) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 2) << 16) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 1) << 8) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr));  	values += "\r\n\r\n64-bit Integer' little-endian' unsigned: " + value.ToString ();  	values += "\r\n64-bit Integer' little-endian' signed: " + ((long)value).ToString ();  	value = ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr) << 56) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 1) << 48) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 2) << 40) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 3) << 32) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 4) << 24) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 5) << 16) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 6) << 8) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 7));  	values += "\r\n64-bit Integer' big-endian' unsigned: " + value.ToString ();  	values += "\r\n64-bit Integer' big-endian' signed: " + ((long)value).ToString ();  }  
Magic Number,ProcessHacker,MemoryEditor,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\MemoryEditor.cs,buttonValues_Click,The following statement contains a magic number: if (space >= 8) {  	ulong value = 0;  	value = ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 7) << 56) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 6) << 48) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 5) << 40) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 4) << 32) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 3) << 24) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 2) << 16) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 1) << 8) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr));  	values += "\r\n\r\n64-bit Integer' little-endian' unsigned: " + value.ToString ();  	values += "\r\n64-bit Integer' little-endian' signed: " + ((long)value).ToString ();  	value = ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr) << 56) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 1) << 48) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 2) << 40) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 3) << 32) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 4) << 24) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 5) << 16) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 6) << 8) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 7));  	values += "\r\n64-bit Integer' big-endian' unsigned: " + value.ToString ();  	values += "\r\n64-bit Integer' big-endian' signed: " + ((long)value).ToString ();  }  
Magic Number,ProcessHacker,MemoryEditor,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\MemoryEditor.cs,buttonValues_Click,The following statement contains a magic number: if (space >= 8) {  	ulong value = 0;  	value = ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 7) << 56) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 6) << 48) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 5) << 40) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 4) << 32) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 3) << 24) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 2) << 16) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 1) << 8) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr));  	values += "\r\n\r\n64-bit Integer' little-endian' unsigned: " + value.ToString ();  	values += "\r\n64-bit Integer' little-endian' signed: " + ((long)value).ToString ();  	value = ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr) << 56) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 1) << 48) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 2) << 40) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 3) << 32) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 4) << 24) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 5) << 16) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 6) << 8) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 7));  	values += "\r\n64-bit Integer' big-endian' unsigned: " + value.ToString ();  	values += "\r\n64-bit Integer' big-endian' signed: " + ((long)value).ToString ();  }  
Magic Number,ProcessHacker,MemoryEditor,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\MemoryEditor.cs,buttonValues_Click,The following statement contains a magic number: if (space >= 8) {  	ulong value = 0;  	value = ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 7) << 56) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 6) << 48) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 5) << 40) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 4) << 32) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 3) << 24) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 2) << 16) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 1) << 8) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr));  	values += "\r\n\r\n64-bit Integer' little-endian' unsigned: " + value.ToString ();  	values += "\r\n64-bit Integer' little-endian' signed: " + ((long)value).ToString ();  	value = ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr) << 56) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 1) << 48) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 2) << 40) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 3) << 32) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 4) << 24) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 5) << 16) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 6) << 8) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 7));  	values += "\r\n64-bit Integer' big-endian' unsigned: " + value.ToString ();  	values += "\r\n64-bit Integer' big-endian' signed: " + ((long)value).ToString ();  }  
Magic Number,ProcessHacker,MemoryEditor,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\MemoryEditor.cs,buttonValues_Click,The following statement contains a magic number: if (space >= 8) {  	ulong value = 0;  	value = ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 7) << 56) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 6) << 48) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 5) << 40) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 4) << 32) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 3) << 24) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 2) << 16) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 1) << 8) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr));  	values += "\r\n\r\n64-bit Integer' little-endian' unsigned: " + value.ToString ();  	values += "\r\n64-bit Integer' little-endian' signed: " + ((long)value).ToString ();  	value = ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr) << 56) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 1) << 48) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 2) << 40) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 3) << 32) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 4) << 24) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 5) << 16) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 6) << 8) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 7));  	values += "\r\n64-bit Integer' big-endian' unsigned: " + value.ToString ();  	values += "\r\n64-bit Integer' big-endian' signed: " + ((long)value).ToString ();  }  
Magic Number,ProcessHacker,MemoryEditor,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\MemoryEditor.cs,buttonValues_Click,The following statement contains a magic number: if (space >= 8) {  	ulong value = 0;  	value = ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 7) << 56) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 6) << 48) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 5) << 40) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 4) << 32) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 3) << 24) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 2) << 16) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 1) << 8) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr));  	values += "\r\n\r\n64-bit Integer' little-endian' unsigned: " + value.ToString ();  	values += "\r\n64-bit Integer' little-endian' signed: " + ((long)value).ToString ();  	value = ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr) << 56) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 1) << 48) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 2) << 40) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 3) << 32) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 4) << 24) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 5) << 16) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 6) << 8) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 7));  	values += "\r\n64-bit Integer' big-endian' unsigned: " + value.ToString ();  	values += "\r\n64-bit Integer' big-endian' signed: " + ((long)value).ToString ();  }  
Magic Number,ProcessHacker,MemoryEditor,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\MemoryEditor.cs,buttonValues_Click,The following statement contains a magic number: if (space >= 8) {  	ulong value = 0;  	value = ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 7) << 56) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 6) << 48) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 5) << 40) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 4) << 32) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 3) << 24) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 2) << 16) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 1) << 8) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr));  	values += "\r\n\r\n64-bit Integer' little-endian' unsigned: " + value.ToString ();  	values += "\r\n64-bit Integer' little-endian' signed: " + ((long)value).ToString ();  	value = ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr) << 56) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 1) << 48) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 2) << 40) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 3) << 32) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 4) << 24) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 5) << 16) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 6) << 8) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 7));  	values += "\r\n64-bit Integer' big-endian' unsigned: " + value.ToString ();  	values += "\r\n64-bit Integer' big-endian' signed: " + ((long)value).ToString ();  }  
Magic Number,ProcessHacker,MemoryEditor,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\MemoryEditor.cs,buttonValues_Click,The following statement contains a magic number: value = ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 7) << 56) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 6) << 48) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 5) << 40) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 4) << 32) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 3) << 24) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 2) << 16) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 1) << 8) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr));  
Magic Number,ProcessHacker,MemoryEditor,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\MemoryEditor.cs,buttonValues_Click,The following statement contains a magic number: value = ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 7) << 56) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 6) << 48) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 5) << 40) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 4) << 32) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 3) << 24) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 2) << 16) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 1) << 8) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr));  
Magic Number,ProcessHacker,MemoryEditor,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\MemoryEditor.cs,buttonValues_Click,The following statement contains a magic number: value = ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 7) << 56) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 6) << 48) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 5) << 40) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 4) << 32) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 3) << 24) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 2) << 16) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 1) << 8) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr));  
Magic Number,ProcessHacker,MemoryEditor,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\MemoryEditor.cs,buttonValues_Click,The following statement contains a magic number: value = ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 7) << 56) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 6) << 48) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 5) << 40) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 4) << 32) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 3) << 24) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 2) << 16) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 1) << 8) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr));  
Magic Number,ProcessHacker,MemoryEditor,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\MemoryEditor.cs,buttonValues_Click,The following statement contains a magic number: value = ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 7) << 56) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 6) << 48) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 5) << 40) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 4) << 32) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 3) << 24) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 2) << 16) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 1) << 8) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr));  
Magic Number,ProcessHacker,MemoryEditor,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\MemoryEditor.cs,buttonValues_Click,The following statement contains a magic number: value = ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 7) << 56) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 6) << 48) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 5) << 40) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 4) << 32) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 3) << 24) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 2) << 16) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 1) << 8) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr));  
Magic Number,ProcessHacker,MemoryEditor,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\MemoryEditor.cs,buttonValues_Click,The following statement contains a magic number: value = ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 7) << 56) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 6) << 48) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 5) << 40) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 4) << 32) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 3) << 24) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 2) << 16) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 1) << 8) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr));  
Magic Number,ProcessHacker,MemoryEditor,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\MemoryEditor.cs,buttonValues_Click,The following statement contains a magic number: value = ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 7) << 56) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 6) << 48) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 5) << 40) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 4) << 32) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 3) << 24) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 2) << 16) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 1) << 8) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr));  
Magic Number,ProcessHacker,MemoryEditor,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\MemoryEditor.cs,buttonValues_Click,The following statement contains a magic number: value = ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 7) << 56) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 6) << 48) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 5) << 40) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 4) << 32) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 3) << 24) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 2) << 16) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 1) << 8) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr));  
Magic Number,ProcessHacker,MemoryEditor,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\MemoryEditor.cs,buttonValues_Click,The following statement contains a magic number: value = ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 7) << 56) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 6) << 48) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 5) << 40) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 4) << 32) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 3) << 24) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 2) << 16) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 1) << 8) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr));  
Magic Number,ProcessHacker,MemoryEditor,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\MemoryEditor.cs,buttonValues_Click,The following statement contains a magic number: value = ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 7) << 56) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 6) << 48) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 5) << 40) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 4) << 32) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 3) << 24) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 2) << 16) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 1) << 8) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr));  
Magic Number,ProcessHacker,MemoryEditor,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\MemoryEditor.cs,buttonValues_Click,The following statement contains a magic number: value = ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 7) << 56) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 6) << 48) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 5) << 40) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 4) << 32) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 3) << 24) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 2) << 16) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 1) << 8) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr));  
Magic Number,ProcessHacker,MemoryEditor,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\MemoryEditor.cs,buttonValues_Click,The following statement contains a magic number: value = ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 7) << 56) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 6) << 48) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 5) << 40) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 4) << 32) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 3) << 24) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 2) << 16) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 1) << 8) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr));  
Magic Number,ProcessHacker,MemoryEditor,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\MemoryEditor.cs,buttonValues_Click,The following statement contains a magic number: value = ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr) << 56) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 1) << 48) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 2) << 40) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 3) << 32) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 4) << 24) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 5) << 16) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 6) << 8) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 7));  
Magic Number,ProcessHacker,MemoryEditor,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\MemoryEditor.cs,buttonValues_Click,The following statement contains a magic number: value = ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr) << 56) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 1) << 48) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 2) << 40) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 3) << 32) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 4) << 24) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 5) << 16) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 6) << 8) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 7));  
Magic Number,ProcessHacker,MemoryEditor,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\MemoryEditor.cs,buttonValues_Click,The following statement contains a magic number: value = ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr) << 56) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 1) << 48) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 2) << 40) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 3) << 32) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 4) << 24) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 5) << 16) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 6) << 8) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 7));  
Magic Number,ProcessHacker,MemoryEditor,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\MemoryEditor.cs,buttonValues_Click,The following statement contains a magic number: value = ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr) << 56) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 1) << 48) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 2) << 40) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 3) << 32) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 4) << 24) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 5) << 16) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 6) << 8) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 7));  
Magic Number,ProcessHacker,MemoryEditor,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\MemoryEditor.cs,buttonValues_Click,The following statement contains a magic number: value = ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr) << 56) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 1) << 48) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 2) << 40) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 3) << 32) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 4) << 24) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 5) << 16) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 6) << 8) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 7));  
Magic Number,ProcessHacker,MemoryEditor,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\MemoryEditor.cs,buttonValues_Click,The following statement contains a magic number: value = ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr) << 56) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 1) << 48) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 2) << 40) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 3) << 32) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 4) << 24) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 5) << 16) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 6) << 8) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 7));  
Magic Number,ProcessHacker,MemoryEditor,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\MemoryEditor.cs,buttonValues_Click,The following statement contains a magic number: value = ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr) << 56) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 1) << 48) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 2) << 40) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 3) << 32) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 4) << 24) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 5) << 16) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 6) << 8) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 7));  
Magic Number,ProcessHacker,MemoryEditor,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\MemoryEditor.cs,buttonValues_Click,The following statement contains a magic number: value = ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr) << 56) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 1) << 48) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 2) << 40) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 3) << 32) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 4) << 24) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 5) << 16) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 6) << 8) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 7));  
Magic Number,ProcessHacker,MemoryEditor,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\MemoryEditor.cs,buttonValues_Click,The following statement contains a magic number: value = ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr) << 56) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 1) << 48) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 2) << 40) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 3) << 32) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 4) << 24) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 5) << 16) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 6) << 8) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 7));  
Magic Number,ProcessHacker,MemoryEditor,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\MemoryEditor.cs,buttonValues_Click,The following statement contains a magic number: value = ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr) << 56) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 1) << 48) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 2) << 40) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 3) << 32) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 4) << 24) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 5) << 16) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 6) << 8) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 7));  
Magic Number,ProcessHacker,MemoryEditor,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\MemoryEditor.cs,buttonValues_Click,The following statement contains a magic number: value = ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr) << 56) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 1) << 48) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 2) << 40) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 3) << 32) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 4) << 24) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 5) << 16) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 6) << 8) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 7));  
Magic Number,ProcessHacker,MemoryEditor,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\MemoryEditor.cs,buttonValues_Click,The following statement contains a magic number: value = ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr) << 56) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 1) << 48) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 2) << 40) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 3) << 32) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 4) << 24) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 5) << 16) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 6) << 8) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 7));  
Magic Number,ProcessHacker,MemoryEditor,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\MemoryEditor.cs,buttonValues_Click,The following statement contains a magic number: value = ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr) << 56) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 1) << 48) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 2) << 40) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 3) << 32) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 4) << 24) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 5) << 16) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 6) << 8) | ((ulong)hexBoxMemory.ByteProvider.ReadByte (addr + 7));  
Magic Number,ProcessHacker,ResultsWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\ResultsWindow.cs,EditSearch,The following statement contains a magic number: sw.Location = new System.Drawing.Point (location.X + (size.Width - sw.Width) / 2' location.Y + (size.Height - sw.Height) / 2);  
Magic Number,ProcessHacker,ResultsWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\ResultsWindow.cs,EditSearch,The following statement contains a magic number: sw.Location = new System.Drawing.Point (location.X + (size.Width - sw.Width) / 2' location.Y + (size.Height - sw.Height) / 2);  
Magic Number,ProcessHacker,ResultsWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\ResultsWindow.cs,listResults_RetrieveVirtualItem,The following statement contains a magic number: try {  	if (e.ItemIndex < _so.Searcher.Results.Count)  		e.Item = new ListViewItem (_so.Searcher.Results [e.ItemIndex]);  	else  		e.Item = new ListViewItem (new string[4]);  }  catch {  	e.Item = new ListViewItem (new string[4]);  }  
Magic Number,ProcessHacker,ResultsWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\ResultsWindow.cs,listResults_RetrieveVirtualItem,The following statement contains a magic number: try {  	if (e.ItemIndex < _so.Searcher.Results.Count)  		e.Item = new ListViewItem (_so.Searcher.Results [e.ItemIndex]);  	else  		e.Item = new ListViewItem (new string[4]);  }  catch {  	e.Item = new ListViewItem (new string[4]);  }  
Magic Number,ProcessHacker,ResultsWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\ResultsWindow.cs,listResults_RetrieveVirtualItem,The following statement contains a magic number: if (e.ItemIndex < _so.Searcher.Results.Count)  	e.Item = new ListViewItem (_so.Searcher.Results [e.ItemIndex]);  else  	e.Item = new ListViewItem (new string[4]);  
Magic Number,ProcessHacker,ResultsWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\ResultsWindow.cs,listResults_RetrieveVirtualItem,The following statement contains a magic number: e.Item = new ListViewItem (new string[4]);  
Magic Number,ProcessHacker,ResultsWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\ResultsWindow.cs,listResults_RetrieveVirtualItem,The following statement contains a magic number: e.Item = new ListViewItem (new string[4]);  
Magic Number,ProcessHacker,ResultsWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\ResultsWindow.cs,buttonSave_Click,The following statement contains a magic number: if (dr == DialogResult.OK) {  	System.IO.StreamWriter sw = new System.IO.StreamWriter (filename);  	foreach (string[] s in _so.Searcher.Results) {  		sw.Write ("0x{0:x} ({1}){2}\r\n"' Int32.Parse (s [0].Replace ("0x"' "")' System.Globalization.NumberStyles.HexNumber) + Int32.Parse (s [1].Replace ("0x"' "")' System.Globalization.NumberStyles.HexNumber)' Int32.Parse (s [2])' s [3] != "" ? (": " + s [3]) : "");  	}  	sw.Close ();  }  
Magic Number,ProcessHacker,ResultsWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\ResultsWindow.cs,buttonSave_Click,The following statement contains a magic number: if (dr == DialogResult.OK) {  	System.IO.StreamWriter sw = new System.IO.StreamWriter (filename);  	foreach (string[] s in _so.Searcher.Results) {  		sw.Write ("0x{0:x} ({1}){2}\r\n"' Int32.Parse (s [0].Replace ("0x"' "")' System.Globalization.NumberStyles.HexNumber) + Int32.Parse (s [1].Replace ("0x"' "")' System.Globalization.NumberStyles.HexNumber)' Int32.Parse (s [2])' s [3] != "" ? (": " + s [3]) : "");  	}  	sw.Close ();  }  
Magic Number,ProcessHacker,ResultsWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\ResultsWindow.cs,buttonSave_Click,The following statement contains a magic number: if (dr == DialogResult.OK) {  	System.IO.StreamWriter sw = new System.IO.StreamWriter (filename);  	foreach (string[] s in _so.Searcher.Results) {  		sw.Write ("0x{0:x} ({1}){2}\r\n"' Int32.Parse (s [0].Replace ("0x"' "")' System.Globalization.NumberStyles.HexNumber) + Int32.Parse (s [1].Replace ("0x"' "")' System.Globalization.NumberStyles.HexNumber)' Int32.Parse (s [2])' s [3] != "" ? (": " + s [3]) : "");  	}  	sw.Close ();  }  
Magic Number,ProcessHacker,ResultsWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\ResultsWindow.cs,buttonSave_Click,The following statement contains a magic number: foreach (string[] s in _so.Searcher.Results) {  	sw.Write ("0x{0:x} ({1}){2}\r\n"' Int32.Parse (s [0].Replace ("0x"' "")' System.Globalization.NumberStyles.HexNumber) + Int32.Parse (s [1].Replace ("0x"' "")' System.Globalization.NumberStyles.HexNumber)' Int32.Parse (s [2])' s [3] != "" ? (": " + s [3]) : "");  }  
Magic Number,ProcessHacker,ResultsWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\ResultsWindow.cs,buttonSave_Click,The following statement contains a magic number: foreach (string[] s in _so.Searcher.Results) {  	sw.Write ("0x{0:x} ({1}){2}\r\n"' Int32.Parse (s [0].Replace ("0x"' "")' System.Globalization.NumberStyles.HexNumber) + Int32.Parse (s [1].Replace ("0x"' "")' System.Globalization.NumberStyles.HexNumber)' Int32.Parse (s [2])' s [3] != "" ? (": " + s [3]) : "");  }  
Magic Number,ProcessHacker,ResultsWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\ResultsWindow.cs,buttonSave_Click,The following statement contains a magic number: foreach (string[] s in _so.Searcher.Results) {  	sw.Write ("0x{0:x} ({1}){2}\r\n"' Int32.Parse (s [0].Replace ("0x"' "")' System.Globalization.NumberStyles.HexNumber) + Int32.Parse (s [1].Replace ("0x"' "")' System.Globalization.NumberStyles.HexNumber)' Int32.Parse (s [2])' s [3] != "" ? (": " + s [3]) : "");  }  
Magic Number,ProcessHacker,ResultsWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\ResultsWindow.cs,buttonSave_Click,The following statement contains a magic number: sw.Write ("0x{0:x} ({1}){2}\r\n"' Int32.Parse (s [0].Replace ("0x"' "")' System.Globalization.NumberStyles.HexNumber) + Int32.Parse (s [1].Replace ("0x"' "")' System.Globalization.NumberStyles.HexNumber)' Int32.Parse (s [2])' s [3] != "" ? (": " + s [3]) : "");  
Magic Number,ProcessHacker,ResultsWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\ResultsWindow.cs,buttonSave_Click,The following statement contains a magic number: sw.Write ("0x{0:x} ({1}){2}\r\n"' Int32.Parse (s [0].Replace ("0x"' "")' System.Globalization.NumberStyles.HexNumber) + Int32.Parse (s [1].Replace ("0x"' "")' System.Globalization.NumberStyles.HexNumber)' Int32.Parse (s [2])' s [3] != "" ? (": " + s [3]) : "");  
Magic Number,ProcessHacker,ResultsWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\ResultsWindow.cs,buttonSave_Click,The following statement contains a magic number: sw.Write ("0x{0:x} ({1}){2}\r\n"' Int32.Parse (s [0].Replace ("0x"' "")' System.Globalization.NumberStyles.HexNumber) + Int32.Parse (s [1].Replace ("0x"' "")' System.Globalization.NumberStyles.HexNumber)' Int32.Parse (s [2])' s [3] != "" ? (": " + s [3]) : "");  
Magic Number,ProcessHacker,ResultsWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\ResultsWindow.cs,listResults_DoubleClick,The following statement contains a magic number: try {  	long s_a = (long)BaseConverter.ToNumberParse (_so.Searcher.Results [listResults.SelectedIndices [0]] [0]) + (long)BaseConverter.ToNumberParse (_so.Searcher.Results [listResults.SelectedIndices [0]] [1]);  	var lastInfo = new MemoryBasicInformation ();  	ProcessHandle phandle;  	try {  		phandle = new ProcessHandle (_pid' ProcessAccess.QueryInformation);  	}  	catch {  		this.Cursor = Cursors.Default;  		return;  	}  	phandle.EnumMemory (info =>  {  		if (info.BaseAddress.ToInt64 () > s_a) {  			long selectlength = (long)BaseConverter.ToNumberParse (_so.Searcher.Results [listResults.SelectedIndices [0]] [2]);  			MemoryEditor ed = Program.GetMemoryEditor (_pid' lastInfo.BaseAddress' lastInfo.RegionSize.ToInt64 ()' new Program.MemoryEditorInvokeAction (delegate (MemoryEditor f) {  				try {  					f.ReadOnly = false;  					f.Activate ();  					f.Select (s_a - lastInfo.BaseAddress.ToInt64 ()' selectlength);  				}  				catch {  				}  			}));  			return false;  		}  		lastInfo = info;  		return true;  	});  }  catch {  }  
Magic Number,ProcessHacker,ResultsWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\ResultsWindow.cs,listResults_DoubleClick,The following statement contains a magic number: phandle.EnumMemory (info =>  {  	if (info.BaseAddress.ToInt64 () > s_a) {  		long selectlength = (long)BaseConverter.ToNumberParse (_so.Searcher.Results [listResults.SelectedIndices [0]] [2]);  		MemoryEditor ed = Program.GetMemoryEditor (_pid' lastInfo.BaseAddress' lastInfo.RegionSize.ToInt64 ()' new Program.MemoryEditorInvokeAction (delegate (MemoryEditor f) {  			try {  				f.ReadOnly = false;  				f.Activate ();  				f.Select (s_a - lastInfo.BaseAddress.ToInt64 ()' selectlength);  			}  			catch {  			}  		}));  		return false;  	}  	lastInfo = info;  	return true;  });  
Magic Number,ProcessHacker,ResultsWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\ResultsWindow.cs,listResults_DoubleClick,The following statement contains a magic number: if (info.BaseAddress.ToInt64 () > s_a) {  	long selectlength = (long)BaseConverter.ToNumberParse (_so.Searcher.Results [listResults.SelectedIndices [0]] [2]);  	MemoryEditor ed = Program.GetMemoryEditor (_pid' lastInfo.BaseAddress' lastInfo.RegionSize.ToInt64 ()' new Program.MemoryEditorInvokeAction (delegate (MemoryEditor f) {  		try {  			f.ReadOnly = false;  			f.Activate ();  			f.Select (s_a - lastInfo.BaseAddress.ToInt64 ()' selectlength);  		}  		catch {  		}  	}));  	return false;  }  
Magic Number,ProcessHacker,ThreadWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\ThreadWindow.cs,WalkStackCallback,The following statement contains a magic number: if (_pid == 4) {  	if (OSVersion.WindowsVersion == WindowsVersion.XP && address == 0xffffffff)  		return true;  }  
Magic Number,ProcessHacker,ThreadWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\ThreadWindow.cs,WalkStackCallback,The following statement contains a magic number: try {  	ListViewItem newItem = listViewCallStack.Items.Add (new ListViewItem (new string[] {  		Utils.FormatAddress (address)'  		_symbols.GetSymbolFromAddress (address)  	}));  	newItem.Tag = address;  	try {  		if (stackFrame.Params.Length > 0)  			newItem.ToolTipText = "Parameters: ";  		foreach (IntPtr arg in stackFrame.Params)  			newItem.ToolTipText += Utils.FormatAddress (arg) + "' ";  		if (newItem.ToolTipText.EndsWith ("' "))  			newItem.ToolTipText = newItem.ToolTipText.Remove (newItem.ToolTipText.Length - 2);  		try {  			string fileAndLine = _symbols.GetLineFromAddress (address);  			if (fileAndLine != null)  				newItem.ToolTipText += "\nFile: " + fileAndLine;  		}  		catch {  		}  	}  	catch (Exception ex2) {  		Logging.Log (ex2);  	}  }  catch (Exception ex) {  	Logging.Log (ex);  	ListViewItem newItem = listViewCallStack.Items.Add (new ListViewItem (new string[] {  		Utils.FormatAddress (address)'  		"???"  	}));  	newItem.Tag = address;  }  
Magic Number,ProcessHacker,ThreadWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\ThreadWindow.cs,WalkStackCallback,The following statement contains a magic number: try {  	if (stackFrame.Params.Length > 0)  		newItem.ToolTipText = "Parameters: ";  	foreach (IntPtr arg in stackFrame.Params)  		newItem.ToolTipText += Utils.FormatAddress (arg) + "' ";  	if (newItem.ToolTipText.EndsWith ("' "))  		newItem.ToolTipText = newItem.ToolTipText.Remove (newItem.ToolTipText.Length - 2);  	try {  		string fileAndLine = _symbols.GetLineFromAddress (address);  		if (fileAndLine != null)  			newItem.ToolTipText += "\nFile: " + fileAndLine;  	}  	catch {  	}  }  catch (Exception ex2) {  	Logging.Log (ex2);  }  
Magic Number,ProcessHacker,ThreadWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\ThreadWindow.cs,WalkStackCallback,The following statement contains a magic number: if (newItem.ToolTipText.EndsWith ("' "))  	newItem.ToolTipText = newItem.ToolTipText.Remove (newItem.ToolTipText.Length - 2);  
Magic Number,ProcessHacker,ThreadWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\ThreadWindow.cs,WalkStackCallback,The following statement contains a magic number: newItem.ToolTipText = newItem.ToolTipText.Remove (newItem.ToolTipText.Length - 2);  
Magic Number,ProcessHacker,Save,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\Save.cs,GetProcessTreeText,The following statement contains a magic number: foreach (var node in Program.HackerWindow.ProcessTree.Tree.AllNodes) {  	// Go through each node control' find the column which corresponds to it'   	// find the column index for the column' and fill in the cell.  	foreach (var control in Program.HackerWindow.ProcessTree.Tree.NodeControls) {  		// Make sure the node control is visible' and make sure it's text.  		if (!control.ParentColumn.IsVisible || !(control is BaseTextControl))  			continue;  		// Get the text contained in the node control.  		string text = (control as BaseTextControl).GetLabel (node);  		// Get the column index corresponding with the node control's column.  		int columnIndex = columnIndexMap [control.ParentColumn];  		// Fill in the cell.  		str [i + 1] [columnIndex] = // If this is the first column in the row' add some indentation.  		(columnIndex == 0 ? (new string (' '' (node.Level - 1) * 2)) : "") + (text != null ? text : "");  	}  	i++;  }  
Magic Number,ProcessHacker,Save,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\Save.cs,GetProcessTreeText,The following statement contains a magic number: foreach (var control in Program.HackerWindow.ProcessTree.Tree.NodeControls) {  	// Make sure the node control is visible' and make sure it's text.  	if (!control.ParentColumn.IsVisible || !(control is BaseTextControl))  		continue;  	// Get the text contained in the node control.  	string text = (control as BaseTextControl).GetLabel (node);  	// Get the column index corresponding with the node control's column.  	int columnIndex = columnIndexMap [control.ParentColumn];  	// Fill in the cell.  	str [i + 1] [columnIndex] = // If this is the first column in the row' add some indentation.  	(columnIndex == 0 ? (new string (' '' (node.Level - 1) * 2)) : "") + (text != null ? text : "");  }  
Magic Number,ProcessHacker,Save,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Program\Save.cs,GetProcessTreeText,The following statement contains a magic number: str [i + 1] [columnIndex] = // If this is the first column in the row' add some indentation.  (columnIndex == 0 ? (new string (' '' (node.Level - 1) * 2)) : "") + (text != null ? text : "");  
Magic Number,ProcessHacker,StringSearcher,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Searchers\StringSearcher.cs,Search,The following statement contains a magic number: phandle.EnumMemory (info =>  {  	// skip unreadable areas  	if (info.Protect == MemoryProtection.AccessDenied)  		return true;  	if (info.State != MemoryState.Commit)  		return true;  	if ((!opt_priv) && (info.Type == MemoryType.Private))  		return true;  	if ((!opt_img) && (info.Type == MemoryType.Image))  		return true;  	if ((!opt_map) && (info.Type == MemoryType.Mapped))  		return true;  	byte[] data = new byte[info.RegionSize.ToInt32 ()];  	int bytesRead = 0;  	CallSearchProgressChanged (String.Format ("Searching 0x{0} ({1} found)..."' info.BaseAddress.ToString ("x")' count));  	try {  		bytesRead = phandle.ReadMemory (info.BaseAddress' data' data.Length);  		if (bytesRead == 0)  			return true;  	}  	catch {  		return true;  	}  	StringBuilder curstr = new StringBuilder ();  	bool isUnicode = false;  	byte byte2 = 0;  	byte byte1 = 0;  	for (int i = 0; i < bytesRead; i++) {  		bool isChar = IsChar (data [i]);  		if (unicode && isChar && isUnicode && byte1 != 0) {  			isUnicode = false;  			if (curstr.Length > 0)  				curstr.Remove (curstr.Length - 1' 1);  			curstr.Append ((char)data [i]);  		}  		else if (isChar) {  			curstr.Append ((char)data [i]);  		}  		else if (unicode && data [i] == 0 && IsChar (byte1) && !IsChar (byte2)) {  			// skip null byte  			isUnicode = true;  		}  		else if (unicode && data [i] == 0 && IsChar (byte1) && IsChar (byte2) && curstr.Length < minsize) {  			// ... [char] [char] *[null]* ([char] [null] [char] [null]) ...  			//                   ^ we are here  			isUnicode = true;  			curstr = new StringBuilder ();  			curstr.Append ((char)byte1);  		}  		else {  			if (curstr.Length >= minsize) {  				int length = curstr.Length;  				if (isUnicode)  					length *= 2;  				Results.Add (new string[] {  					Utils.FormatAddress (info.BaseAddress)'  					String.Format ("0x{0:x}"' i - length)'  					length.ToString ()'  					curstr.ToString ()  				});  				count++;  			}  			isUnicode = false;  			curstr = new StringBuilder ();  		}  		byte2 = byte1;  		byte1 = data [i];  	}  	data = null;  	return true;  });  
Magic Number,ProcessHacker,StringSearcher,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Searchers\StringSearcher.cs,Search,The following statement contains a magic number: for (int i = 0; i < bytesRead; i++) {  	bool isChar = IsChar (data [i]);  	if (unicode && isChar && isUnicode && byte1 != 0) {  		isUnicode = false;  		if (curstr.Length > 0)  			curstr.Remove (curstr.Length - 1' 1);  		curstr.Append ((char)data [i]);  	}  	else if (isChar) {  		curstr.Append ((char)data [i]);  	}  	else if (unicode && data [i] == 0 && IsChar (byte1) && !IsChar (byte2)) {  		// skip null byte  		isUnicode = true;  	}  	else if (unicode && data [i] == 0 && IsChar (byte1) && IsChar (byte2) && curstr.Length < minsize) {  		// ... [char] [char] *[null]* ([char] [null] [char] [null]) ...  		//                   ^ we are here  		isUnicode = true;  		curstr = new StringBuilder ();  		curstr.Append ((char)byte1);  	}  	else {  		if (curstr.Length >= minsize) {  			int length = curstr.Length;  			if (isUnicode)  				length *= 2;  			Results.Add (new string[] {  				Utils.FormatAddress (info.BaseAddress)'  				String.Format ("0x{0:x}"' i - length)'  				length.ToString ()'  				curstr.ToString ()  			});  			count++;  		}  		isUnicode = false;  		curstr = new StringBuilder ();  	}  	byte2 = byte1;  	byte1 = data [i];  }  
Magic Number,ProcessHacker,StringSearcher,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Searchers\StringSearcher.cs,Search,The following statement contains a magic number: if (unicode && isChar && isUnicode && byte1 != 0) {  	isUnicode = false;  	if (curstr.Length > 0)  		curstr.Remove (curstr.Length - 1' 1);  	curstr.Append ((char)data [i]);  }  else if (isChar) {  	curstr.Append ((char)data [i]);  }  else if (unicode && data [i] == 0 && IsChar (byte1) && !IsChar (byte2)) {  	// skip null byte  	isUnicode = true;  }  else if (unicode && data [i] == 0 && IsChar (byte1) && IsChar (byte2) && curstr.Length < minsize) {  	// ... [char] [char] *[null]* ([char] [null] [char] [null]) ...  	//                   ^ we are here  	isUnicode = true;  	curstr = new StringBuilder ();  	curstr.Append ((char)byte1);  }  else {  	if (curstr.Length >= minsize) {  		int length = curstr.Length;  		if (isUnicode)  			length *= 2;  		Results.Add (new string[] {  			Utils.FormatAddress (info.BaseAddress)'  			String.Format ("0x{0:x}"' i - length)'  			length.ToString ()'  			curstr.ToString ()  		});  		count++;  	}  	isUnicode = false;  	curstr = new StringBuilder ();  }  
Magic Number,ProcessHacker,StringSearcher,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Searchers\StringSearcher.cs,Search,The following statement contains a magic number: if (isChar) {  	curstr.Append ((char)data [i]);  }  else if (unicode && data [i] == 0 && IsChar (byte1) && !IsChar (byte2)) {  	// skip null byte  	isUnicode = true;  }  else if (unicode && data [i] == 0 && IsChar (byte1) && IsChar (byte2) && curstr.Length < minsize) {  	// ... [char] [char] *[null]* ([char] [null] [char] [null]) ...  	//                   ^ we are here  	isUnicode = true;  	curstr = new StringBuilder ();  	curstr.Append ((char)byte1);  }  else {  	if (curstr.Length >= minsize) {  		int length = curstr.Length;  		if (isUnicode)  			length *= 2;  		Results.Add (new string[] {  			Utils.FormatAddress (info.BaseAddress)'  			String.Format ("0x{0:x}"' i - length)'  			length.ToString ()'  			curstr.ToString ()  		});  		count++;  	}  	isUnicode = false;  	curstr = new StringBuilder ();  }  
Magic Number,ProcessHacker,StringSearcher,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Searchers\StringSearcher.cs,Search,The following statement contains a magic number: if (unicode && data [i] == 0 && IsChar (byte1) && !IsChar (byte2)) {  	// skip null byte  	isUnicode = true;  }  else if (unicode && data [i] == 0 && IsChar (byte1) && IsChar (byte2) && curstr.Length < minsize) {  	// ... [char] [char] *[null]* ([char] [null] [char] [null]) ...  	//                   ^ we are here  	isUnicode = true;  	curstr = new StringBuilder ();  	curstr.Append ((char)byte1);  }  else {  	if (curstr.Length >= minsize) {  		int length = curstr.Length;  		if (isUnicode)  			length *= 2;  		Results.Add (new string[] {  			Utils.FormatAddress (info.BaseAddress)'  			String.Format ("0x{0:x}"' i - length)'  			length.ToString ()'  			curstr.ToString ()  		});  		count++;  	}  	isUnicode = false;  	curstr = new StringBuilder ();  }  
Magic Number,ProcessHacker,StringSearcher,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Searchers\StringSearcher.cs,Search,The following statement contains a magic number: if (unicode && data [i] == 0 && IsChar (byte1) && IsChar (byte2) && curstr.Length < minsize) {  	// ... [char] [char] *[null]* ([char] [null] [char] [null]) ...  	//                   ^ we are here  	isUnicode = true;  	curstr = new StringBuilder ();  	curstr.Append ((char)byte1);  }  else {  	if (curstr.Length >= minsize) {  		int length = curstr.Length;  		if (isUnicode)  			length *= 2;  		Results.Add (new string[] {  			Utils.FormatAddress (info.BaseAddress)'  			String.Format ("0x{0:x}"' i - length)'  			length.ToString ()'  			curstr.ToString ()  		});  		count++;  	}  	isUnicode = false;  	curstr = new StringBuilder ();  }  
Magic Number,ProcessHacker,StringSearcher,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Searchers\StringSearcher.cs,Search,The following statement contains a magic number: if (curstr.Length >= minsize) {  	int length = curstr.Length;  	if (isUnicode)  		length *= 2;  	Results.Add (new string[] {  		Utils.FormatAddress (info.BaseAddress)'  		String.Format ("0x{0:x}"' i - length)'  		length.ToString ()'  		curstr.ToString ()  	});  	count++;  }  
Magic Number,ProcessHacker,StringSearcher,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Searchers\StringSearcher.cs,Search,The following statement contains a magic number: if (isUnicode)  	length *= 2;  
Magic Number,ProcessHacker,StringSearcher,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Searchers\StringSearcher.cs,Search,The following statement contains a magic number: length *= 2;  
Magic Number,ProcessHacker,OptionsWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\OptionsWindow.cs,LoadSettings,The following statement contains a magic number: switch (Settings.Instance.ToolStripDisplayStyle) {  case 0:  	comboToolbarStyle.SelectedIndex = 0;  	break;  case 1:  	comboToolbarStyle.SelectedIndex = 1;  	break;  case 2:  	comboToolbarStyle.SelectedIndex = 2;  	break;  default:  	comboToolbarStyle.SelectedIndex = 1;  	break;  }  
Magic Number,ProcessHacker,OptionsWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\OptionsWindow.cs,LoadSettings,The following statement contains a magic number: switch (Settings.Instance.ToolStripDisplayStyle) {  case 0:  	comboToolbarStyle.SelectedIndex = 0;  	break;  case 1:  	comboToolbarStyle.SelectedIndex = 1;  	break;  case 2:  	comboToolbarStyle.SelectedIndex = 2;  	break;  default:  	comboToolbarStyle.SelectedIndex = 1;  	break;  }  
Magic Number,ProcessHacker,OptionsWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\OptionsWindow.cs,LoadSettings,The following statement contains a magic number: comboToolbarStyle.SelectedIndex = 2;  
Magic Number,ProcessHacker,OptionsWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\OptionsWindow.cs,SaveSettings,The following statement contains a magic number: switch (comboToolbarStyle.SelectedIndex) {  case 0:  	Settings.Instance.ToolStripDisplayStyle = 0;  	break;  case 1:  	Settings.Instance.ToolStripDisplayStyle = 1;  	break;  case 2:  	Settings.Instance.ToolStripDisplayStyle = 2;  	break;  default:  	Settings.Instance.ToolStripDisplayStyle = 0;  	break;  }  
Magic Number,ProcessHacker,OptionsWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\OptionsWindow.cs,SaveSettings,The following statement contains a magic number: switch (comboToolbarStyle.SelectedIndex) {  case 0:  	Settings.Instance.ToolStripDisplayStyle = 0;  	break;  case 1:  	Settings.Instance.ToolStripDisplayStyle = 1;  	break;  case 2:  	Settings.Instance.ToolStripDisplayStyle = 2;  	break;  default:  	Settings.Instance.ToolStripDisplayStyle = 0;  	break;  }  
Magic Number,ProcessHacker,OptionsWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\OptionsWindow.cs,SaveSettings,The following statement contains a magic number: Settings.Instance.ToolStripDisplayStyle = 2;  
Magic Number,wyDay.Controls,VistaMenu,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\VistaMenu\OwnerDrawnMenu.cs,MenuItem_DrawItem,The following statement contains a magic number: if (((MenuItem)sender).Text == "-") {  	//draw the separator  	int yCenter = e.Bounds.Top + (e.Bounds.Height / 2) - 1;  	e.Graphics.DrawLine (SystemPens.ControlDark' e.Bounds.Left + 1' yCenter' (e.Bounds.Left + e.Bounds.Width - 2)' yCenter);  	e.Graphics.DrawLine (SystemPens.ControlLightLight' e.Bounds.Left + 1' yCenter + 1' (e.Bounds.Left + e.Bounds.Width - 2)' yCenter + 1);  }  else//regular menu items   {  	//draw the item text  	DrawText (sender' e' menuSelected);  	if (((MenuItem)sender).Checked) {  		if (((MenuItem)sender).RadioCheck) {  			//draw the bullet  			ControlPaint.DrawMenuGlyph (e.Graphics' e.Bounds.Left + (LEFT_MARGIN + ICON_SIZE + RIGHT_MARGIN - SystemInformation.MenuCheckSize.Width) / 2' e.Bounds.Top + (e.Bounds.Height - SystemInformation.MenuCheckSize.Height) / 2 + 1' SystemInformation.MenuCheckSize.Width' SystemInformation.MenuCheckSize.Height' MenuGlyph.Bullet' menuSelected ? SystemColors.HighlightText : SystemColors.MenuText' menuSelected ? SystemColors.Highlight : SystemColors.Menu);  		}  		else {  			//draw the check mark  			ControlPaint.DrawMenuGlyph (e.Graphics' e.Bounds.Left + (LEFT_MARGIN + ICON_SIZE + RIGHT_MARGIN - SystemInformation.MenuCheckSize.Width) / 2' e.Bounds.Top + (e.Bounds.Height - SystemInformation.MenuCheckSize.Height) / 2 + 1' SystemInformation.MenuCheckSize.Width' SystemInformation.MenuCheckSize.Height' MenuGlyph.Checkmark' menuSelected ? SystemColors.HighlightText : SystemColors.MenuText' menuSelected ? SystemColors.Highlight : SystemColors.Menu);  		}  	}  	else {  		Image drawImg = EnsurePropertiesExists ((MenuItem)sender).PreVistaBitmap;  		if (drawImg != null) {  			//draw the image  			if (((MenuItem)sender).Enabled)  				e.Graphics.DrawImage (drawImg' e.Bounds.Left + LEFT_MARGIN' e.Bounds.Top + ((e.Bounds.Height - ICON_SIZE) / 2)' ICON_SIZE' ICON_SIZE);  			else  				ControlPaint.DrawImageDisabled (e.Graphics' drawImg' e.Bounds.Left + LEFT_MARGIN' e.Bounds.Top + ((e.Bounds.Height - ICON_SIZE) / 2)' SystemColors.Menu);  		}  	}  }  
Magic Number,wyDay.Controls,VistaMenu,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\VistaMenu\OwnerDrawnMenu.cs,MenuItem_DrawItem,The following statement contains a magic number: if (((MenuItem)sender).Text == "-") {  	//draw the separator  	int yCenter = e.Bounds.Top + (e.Bounds.Height / 2) - 1;  	e.Graphics.DrawLine (SystemPens.ControlDark' e.Bounds.Left + 1' yCenter' (e.Bounds.Left + e.Bounds.Width - 2)' yCenter);  	e.Graphics.DrawLine (SystemPens.ControlLightLight' e.Bounds.Left + 1' yCenter + 1' (e.Bounds.Left + e.Bounds.Width - 2)' yCenter + 1);  }  else//regular menu items   {  	//draw the item text  	DrawText (sender' e' menuSelected);  	if (((MenuItem)sender).Checked) {  		if (((MenuItem)sender).RadioCheck) {  			//draw the bullet  			ControlPaint.DrawMenuGlyph (e.Graphics' e.Bounds.Left + (LEFT_MARGIN + ICON_SIZE + RIGHT_MARGIN - SystemInformation.MenuCheckSize.Width) / 2' e.Bounds.Top + (e.Bounds.Height - SystemInformation.MenuCheckSize.Height) / 2 + 1' SystemInformation.MenuCheckSize.Width' SystemInformation.MenuCheckSize.Height' MenuGlyph.Bullet' menuSelected ? SystemColors.HighlightText : SystemColors.MenuText' menuSelected ? SystemColors.Highlight : SystemColors.Menu);  		}  		else {  			//draw the check mark  			ControlPaint.DrawMenuGlyph (e.Graphics' e.Bounds.Left + (LEFT_MARGIN + ICON_SIZE + RIGHT_MARGIN - SystemInformation.MenuCheckSize.Width) / 2' e.Bounds.Top + (e.Bounds.Height - SystemInformation.MenuCheckSize.Height) / 2 + 1' SystemInformation.MenuCheckSize.Width' SystemInformation.MenuCheckSize.Height' MenuGlyph.Checkmark' menuSelected ? SystemColors.HighlightText : SystemColors.MenuText' menuSelected ? SystemColors.Highlight : SystemColors.Menu);  		}  	}  	else {  		Image drawImg = EnsurePropertiesExists ((MenuItem)sender).PreVistaBitmap;  		if (drawImg != null) {  			//draw the image  			if (((MenuItem)sender).Enabled)  				e.Graphics.DrawImage (drawImg' e.Bounds.Left + LEFT_MARGIN' e.Bounds.Top + ((e.Bounds.Height - ICON_SIZE) / 2)' ICON_SIZE' ICON_SIZE);  			else  				ControlPaint.DrawImageDisabled (e.Graphics' drawImg' e.Bounds.Left + LEFT_MARGIN' e.Bounds.Top + ((e.Bounds.Height - ICON_SIZE) / 2)' SystemColors.Menu);  		}  	}  }  
Magic Number,wyDay.Controls,VistaMenu,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\VistaMenu\OwnerDrawnMenu.cs,MenuItem_DrawItem,The following statement contains a magic number: if (((MenuItem)sender).Text == "-") {  	//draw the separator  	int yCenter = e.Bounds.Top + (e.Bounds.Height / 2) - 1;  	e.Graphics.DrawLine (SystemPens.ControlDark' e.Bounds.Left + 1' yCenter' (e.Bounds.Left + e.Bounds.Width - 2)' yCenter);  	e.Graphics.DrawLine (SystemPens.ControlLightLight' e.Bounds.Left + 1' yCenter + 1' (e.Bounds.Left + e.Bounds.Width - 2)' yCenter + 1);  }  else//regular menu items   {  	//draw the item text  	DrawText (sender' e' menuSelected);  	if (((MenuItem)sender).Checked) {  		if (((MenuItem)sender).RadioCheck) {  			//draw the bullet  			ControlPaint.DrawMenuGlyph (e.Graphics' e.Bounds.Left + (LEFT_MARGIN + ICON_SIZE + RIGHT_MARGIN - SystemInformation.MenuCheckSize.Width) / 2' e.Bounds.Top + (e.Bounds.Height - SystemInformation.MenuCheckSize.Height) / 2 + 1' SystemInformation.MenuCheckSize.Width' SystemInformation.MenuCheckSize.Height' MenuGlyph.Bullet' menuSelected ? SystemColors.HighlightText : SystemColors.MenuText' menuSelected ? SystemColors.Highlight : SystemColors.Menu);  		}  		else {  			//draw the check mark  			ControlPaint.DrawMenuGlyph (e.Graphics' e.Bounds.Left + (LEFT_MARGIN + ICON_SIZE + RIGHT_MARGIN - SystemInformation.MenuCheckSize.Width) / 2' e.Bounds.Top + (e.Bounds.Height - SystemInformation.MenuCheckSize.Height) / 2 + 1' SystemInformation.MenuCheckSize.Width' SystemInformation.MenuCheckSize.Height' MenuGlyph.Checkmark' menuSelected ? SystemColors.HighlightText : SystemColors.MenuText' menuSelected ? SystemColors.Highlight : SystemColors.Menu);  		}  	}  	else {  		Image drawImg = EnsurePropertiesExists ((MenuItem)sender).PreVistaBitmap;  		if (drawImg != null) {  			//draw the image  			if (((MenuItem)sender).Enabled)  				e.Graphics.DrawImage (drawImg' e.Bounds.Left + LEFT_MARGIN' e.Bounds.Top + ((e.Bounds.Height - ICON_SIZE) / 2)' ICON_SIZE' ICON_SIZE);  			else  				ControlPaint.DrawImageDisabled (e.Graphics' drawImg' e.Bounds.Left + LEFT_MARGIN' e.Bounds.Top + ((e.Bounds.Height - ICON_SIZE) / 2)' SystemColors.Menu);  		}  	}  }  
Magic Number,wyDay.Controls,VistaMenu,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\VistaMenu\OwnerDrawnMenu.cs,MenuItem_DrawItem,The following statement contains a magic number: if (((MenuItem)sender).Text == "-") {  	//draw the separator  	int yCenter = e.Bounds.Top + (e.Bounds.Height / 2) - 1;  	e.Graphics.DrawLine (SystemPens.ControlDark' e.Bounds.Left + 1' yCenter' (e.Bounds.Left + e.Bounds.Width - 2)' yCenter);  	e.Graphics.DrawLine (SystemPens.ControlLightLight' e.Bounds.Left + 1' yCenter + 1' (e.Bounds.Left + e.Bounds.Width - 2)' yCenter + 1);  }  else//regular menu items   {  	//draw the item text  	DrawText (sender' e' menuSelected);  	if (((MenuItem)sender).Checked) {  		if (((MenuItem)sender).RadioCheck) {  			//draw the bullet  			ControlPaint.DrawMenuGlyph (e.Graphics' e.Bounds.Left + (LEFT_MARGIN + ICON_SIZE + RIGHT_MARGIN - SystemInformation.MenuCheckSize.Width) / 2' e.Bounds.Top + (e.Bounds.Height - SystemInformation.MenuCheckSize.Height) / 2 + 1' SystemInformation.MenuCheckSize.Width' SystemInformation.MenuCheckSize.Height' MenuGlyph.Bullet' menuSelected ? SystemColors.HighlightText : SystemColors.MenuText' menuSelected ? SystemColors.Highlight : SystemColors.Menu);  		}  		else {  			//draw the check mark  			ControlPaint.DrawMenuGlyph (e.Graphics' e.Bounds.Left + (LEFT_MARGIN + ICON_SIZE + RIGHT_MARGIN - SystemInformation.MenuCheckSize.Width) / 2' e.Bounds.Top + (e.Bounds.Height - SystemInformation.MenuCheckSize.Height) / 2 + 1' SystemInformation.MenuCheckSize.Width' SystemInformation.MenuCheckSize.Height' MenuGlyph.Checkmark' menuSelected ? SystemColors.HighlightText : SystemColors.MenuText' menuSelected ? SystemColors.Highlight : SystemColors.Menu);  		}  	}  	else {  		Image drawImg = EnsurePropertiesExists ((MenuItem)sender).PreVistaBitmap;  		if (drawImg != null) {  			//draw the image  			if (((MenuItem)sender).Enabled)  				e.Graphics.DrawImage (drawImg' e.Bounds.Left + LEFT_MARGIN' e.Bounds.Top + ((e.Bounds.Height - ICON_SIZE) / 2)' ICON_SIZE' ICON_SIZE);  			else  				ControlPaint.DrawImageDisabled (e.Graphics' drawImg' e.Bounds.Left + LEFT_MARGIN' e.Bounds.Top + ((e.Bounds.Height - ICON_SIZE) / 2)' SystemColors.Menu);  		}  	}  }  
Magic Number,wyDay.Controls,VistaMenu,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\VistaMenu\OwnerDrawnMenu.cs,MenuItem_DrawItem,The following statement contains a magic number: if (((MenuItem)sender).Text == "-") {  	//draw the separator  	int yCenter = e.Bounds.Top + (e.Bounds.Height / 2) - 1;  	e.Graphics.DrawLine (SystemPens.ControlDark' e.Bounds.Left + 1' yCenter' (e.Bounds.Left + e.Bounds.Width - 2)' yCenter);  	e.Graphics.DrawLine (SystemPens.ControlLightLight' e.Bounds.Left + 1' yCenter + 1' (e.Bounds.Left + e.Bounds.Width - 2)' yCenter + 1);  }  else//regular menu items   {  	//draw the item text  	DrawText (sender' e' menuSelected);  	if (((MenuItem)sender).Checked) {  		if (((MenuItem)sender).RadioCheck) {  			//draw the bullet  			ControlPaint.DrawMenuGlyph (e.Graphics' e.Bounds.Left + (LEFT_MARGIN + ICON_SIZE + RIGHT_MARGIN - SystemInformation.MenuCheckSize.Width) / 2' e.Bounds.Top + (e.Bounds.Height - SystemInformation.MenuCheckSize.Height) / 2 + 1' SystemInformation.MenuCheckSize.Width' SystemInformation.MenuCheckSize.Height' MenuGlyph.Bullet' menuSelected ? SystemColors.HighlightText : SystemColors.MenuText' menuSelected ? SystemColors.Highlight : SystemColors.Menu);  		}  		else {  			//draw the check mark  			ControlPaint.DrawMenuGlyph (e.Graphics' e.Bounds.Left + (LEFT_MARGIN + ICON_SIZE + RIGHT_MARGIN - SystemInformation.MenuCheckSize.Width) / 2' e.Bounds.Top + (e.Bounds.Height - SystemInformation.MenuCheckSize.Height) / 2 + 1' SystemInformation.MenuCheckSize.Width' SystemInformation.MenuCheckSize.Height' MenuGlyph.Checkmark' menuSelected ? SystemColors.HighlightText : SystemColors.MenuText' menuSelected ? SystemColors.Highlight : SystemColors.Menu);  		}  	}  	else {  		Image drawImg = EnsurePropertiesExists ((MenuItem)sender).PreVistaBitmap;  		if (drawImg != null) {  			//draw the image  			if (((MenuItem)sender).Enabled)  				e.Graphics.DrawImage (drawImg' e.Bounds.Left + LEFT_MARGIN' e.Bounds.Top + ((e.Bounds.Height - ICON_SIZE) / 2)' ICON_SIZE' ICON_SIZE);  			else  				ControlPaint.DrawImageDisabled (e.Graphics' drawImg' e.Bounds.Left + LEFT_MARGIN' e.Bounds.Top + ((e.Bounds.Height - ICON_SIZE) / 2)' SystemColors.Menu);  		}  	}  }  
Magic Number,wyDay.Controls,VistaMenu,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\VistaMenu\OwnerDrawnMenu.cs,MenuItem_DrawItem,The following statement contains a magic number: if (((MenuItem)sender).Text == "-") {  	//draw the separator  	int yCenter = e.Bounds.Top + (e.Bounds.Height / 2) - 1;  	e.Graphics.DrawLine (SystemPens.ControlDark' e.Bounds.Left + 1' yCenter' (e.Bounds.Left + e.Bounds.Width - 2)' yCenter);  	e.Graphics.DrawLine (SystemPens.ControlLightLight' e.Bounds.Left + 1' yCenter + 1' (e.Bounds.Left + e.Bounds.Width - 2)' yCenter + 1);  }  else//regular menu items   {  	//draw the item text  	DrawText (sender' e' menuSelected);  	if (((MenuItem)sender).Checked) {  		if (((MenuItem)sender).RadioCheck) {  			//draw the bullet  			ControlPaint.DrawMenuGlyph (e.Graphics' e.Bounds.Left + (LEFT_MARGIN + ICON_SIZE + RIGHT_MARGIN - SystemInformation.MenuCheckSize.Width) / 2' e.Bounds.Top + (e.Bounds.Height - SystemInformation.MenuCheckSize.Height) / 2 + 1' SystemInformation.MenuCheckSize.Width' SystemInformation.MenuCheckSize.Height' MenuGlyph.Bullet' menuSelected ? SystemColors.HighlightText : SystemColors.MenuText' menuSelected ? SystemColors.Highlight : SystemColors.Menu);  		}  		else {  			//draw the check mark  			ControlPaint.DrawMenuGlyph (e.Graphics' e.Bounds.Left + (LEFT_MARGIN + ICON_SIZE + RIGHT_MARGIN - SystemInformation.MenuCheckSize.Width) / 2' e.Bounds.Top + (e.Bounds.Height - SystemInformation.MenuCheckSize.Height) / 2 + 1' SystemInformation.MenuCheckSize.Width' SystemInformation.MenuCheckSize.Height' MenuGlyph.Checkmark' menuSelected ? SystemColors.HighlightText : SystemColors.MenuText' menuSelected ? SystemColors.Highlight : SystemColors.Menu);  		}  	}  	else {  		Image drawImg = EnsurePropertiesExists ((MenuItem)sender).PreVistaBitmap;  		if (drawImg != null) {  			//draw the image  			if (((MenuItem)sender).Enabled)  				e.Graphics.DrawImage (drawImg' e.Bounds.Left + LEFT_MARGIN' e.Bounds.Top + ((e.Bounds.Height - ICON_SIZE) / 2)' ICON_SIZE' ICON_SIZE);  			else  				ControlPaint.DrawImageDisabled (e.Graphics' drawImg' e.Bounds.Left + LEFT_MARGIN' e.Bounds.Top + ((e.Bounds.Height - ICON_SIZE) / 2)' SystemColors.Menu);  		}  	}  }  
Magic Number,wyDay.Controls,VistaMenu,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\VistaMenu\OwnerDrawnMenu.cs,MenuItem_DrawItem,The following statement contains a magic number: if (((MenuItem)sender).Text == "-") {  	//draw the separator  	int yCenter = e.Bounds.Top + (e.Bounds.Height / 2) - 1;  	e.Graphics.DrawLine (SystemPens.ControlDark' e.Bounds.Left + 1' yCenter' (e.Bounds.Left + e.Bounds.Width - 2)' yCenter);  	e.Graphics.DrawLine (SystemPens.ControlLightLight' e.Bounds.Left + 1' yCenter + 1' (e.Bounds.Left + e.Bounds.Width - 2)' yCenter + 1);  }  else//regular menu items   {  	//draw the item text  	DrawText (sender' e' menuSelected);  	if (((MenuItem)sender).Checked) {  		if (((MenuItem)sender).RadioCheck) {  			//draw the bullet  			ControlPaint.DrawMenuGlyph (e.Graphics' e.Bounds.Left + (LEFT_MARGIN + ICON_SIZE + RIGHT_MARGIN - SystemInformation.MenuCheckSize.Width) / 2' e.Bounds.Top + (e.Bounds.Height - SystemInformation.MenuCheckSize.Height) / 2 + 1' SystemInformation.MenuCheckSize.Width' SystemInformation.MenuCheckSize.Height' MenuGlyph.Bullet' menuSelected ? SystemColors.HighlightText : SystemColors.MenuText' menuSelected ? SystemColors.Highlight : SystemColors.Menu);  		}  		else {  			//draw the check mark  			ControlPaint.DrawMenuGlyph (e.Graphics' e.Bounds.Left + (LEFT_MARGIN + ICON_SIZE + RIGHT_MARGIN - SystemInformation.MenuCheckSize.Width) / 2' e.Bounds.Top + (e.Bounds.Height - SystemInformation.MenuCheckSize.Height) / 2 + 1' SystemInformation.MenuCheckSize.Width' SystemInformation.MenuCheckSize.Height' MenuGlyph.Checkmark' menuSelected ? SystemColors.HighlightText : SystemColors.MenuText' menuSelected ? SystemColors.Highlight : SystemColors.Menu);  		}  	}  	else {  		Image drawImg = EnsurePropertiesExists ((MenuItem)sender).PreVistaBitmap;  		if (drawImg != null) {  			//draw the image  			if (((MenuItem)sender).Enabled)  				e.Graphics.DrawImage (drawImg' e.Bounds.Left + LEFT_MARGIN' e.Bounds.Top + ((e.Bounds.Height - ICON_SIZE) / 2)' ICON_SIZE' ICON_SIZE);  			else  				ControlPaint.DrawImageDisabled (e.Graphics' drawImg' e.Bounds.Left + LEFT_MARGIN' e.Bounds.Top + ((e.Bounds.Height - ICON_SIZE) / 2)' SystemColors.Menu);  		}  	}  }  
Magic Number,wyDay.Controls,VistaMenu,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\VistaMenu\OwnerDrawnMenu.cs,MenuItem_DrawItem,The following statement contains a magic number: if (((MenuItem)sender).Text == "-") {  	//draw the separator  	int yCenter = e.Bounds.Top + (e.Bounds.Height / 2) - 1;  	e.Graphics.DrawLine (SystemPens.ControlDark' e.Bounds.Left + 1' yCenter' (e.Bounds.Left + e.Bounds.Width - 2)' yCenter);  	e.Graphics.DrawLine (SystemPens.ControlLightLight' e.Bounds.Left + 1' yCenter + 1' (e.Bounds.Left + e.Bounds.Width - 2)' yCenter + 1);  }  else//regular menu items   {  	//draw the item text  	DrawText (sender' e' menuSelected);  	if (((MenuItem)sender).Checked) {  		if (((MenuItem)sender).RadioCheck) {  			//draw the bullet  			ControlPaint.DrawMenuGlyph (e.Graphics' e.Bounds.Left + (LEFT_MARGIN + ICON_SIZE + RIGHT_MARGIN - SystemInformation.MenuCheckSize.Width) / 2' e.Bounds.Top + (e.Bounds.Height - SystemInformation.MenuCheckSize.Height) / 2 + 1' SystemInformation.MenuCheckSize.Width' SystemInformation.MenuCheckSize.Height' MenuGlyph.Bullet' menuSelected ? SystemColors.HighlightText : SystemColors.MenuText' menuSelected ? SystemColors.Highlight : SystemColors.Menu);  		}  		else {  			//draw the check mark  			ControlPaint.DrawMenuGlyph (e.Graphics' e.Bounds.Left + (LEFT_MARGIN + ICON_SIZE + RIGHT_MARGIN - SystemInformation.MenuCheckSize.Width) / 2' e.Bounds.Top + (e.Bounds.Height - SystemInformation.MenuCheckSize.Height) / 2 + 1' SystemInformation.MenuCheckSize.Width' SystemInformation.MenuCheckSize.Height' MenuGlyph.Checkmark' menuSelected ? SystemColors.HighlightText : SystemColors.MenuText' menuSelected ? SystemColors.Highlight : SystemColors.Menu);  		}  	}  	else {  		Image drawImg = EnsurePropertiesExists ((MenuItem)sender).PreVistaBitmap;  		if (drawImg != null) {  			//draw the image  			if (((MenuItem)sender).Enabled)  				e.Graphics.DrawImage (drawImg' e.Bounds.Left + LEFT_MARGIN' e.Bounds.Top + ((e.Bounds.Height - ICON_SIZE) / 2)' ICON_SIZE' ICON_SIZE);  			else  				ControlPaint.DrawImageDisabled (e.Graphics' drawImg' e.Bounds.Left + LEFT_MARGIN' e.Bounds.Top + ((e.Bounds.Height - ICON_SIZE) / 2)' SystemColors.Menu);  		}  	}  }  
Magic Number,wyDay.Controls,VistaMenu,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\VistaMenu\OwnerDrawnMenu.cs,MenuItem_DrawItem,The following statement contains a magic number: if (((MenuItem)sender).Text == "-") {  	//draw the separator  	int yCenter = e.Bounds.Top + (e.Bounds.Height / 2) - 1;  	e.Graphics.DrawLine (SystemPens.ControlDark' e.Bounds.Left + 1' yCenter' (e.Bounds.Left + e.Bounds.Width - 2)' yCenter);  	e.Graphics.DrawLine (SystemPens.ControlLightLight' e.Bounds.Left + 1' yCenter + 1' (e.Bounds.Left + e.Bounds.Width - 2)' yCenter + 1);  }  else//regular menu items   {  	//draw the item text  	DrawText (sender' e' menuSelected);  	if (((MenuItem)sender).Checked) {  		if (((MenuItem)sender).RadioCheck) {  			//draw the bullet  			ControlPaint.DrawMenuGlyph (e.Graphics' e.Bounds.Left + (LEFT_MARGIN + ICON_SIZE + RIGHT_MARGIN - SystemInformation.MenuCheckSize.Width) / 2' e.Bounds.Top + (e.Bounds.Height - SystemInformation.MenuCheckSize.Height) / 2 + 1' SystemInformation.MenuCheckSize.Width' SystemInformation.MenuCheckSize.Height' MenuGlyph.Bullet' menuSelected ? SystemColors.HighlightText : SystemColors.MenuText' menuSelected ? SystemColors.Highlight : SystemColors.Menu);  		}  		else {  			//draw the check mark  			ControlPaint.DrawMenuGlyph (e.Graphics' e.Bounds.Left + (LEFT_MARGIN + ICON_SIZE + RIGHT_MARGIN - SystemInformation.MenuCheckSize.Width) / 2' e.Bounds.Top + (e.Bounds.Height - SystemInformation.MenuCheckSize.Height) / 2 + 1' SystemInformation.MenuCheckSize.Width' SystemInformation.MenuCheckSize.Height' MenuGlyph.Checkmark' menuSelected ? SystemColors.HighlightText : SystemColors.MenuText' menuSelected ? SystemColors.Highlight : SystemColors.Menu);  		}  	}  	else {  		Image drawImg = EnsurePropertiesExists ((MenuItem)sender).PreVistaBitmap;  		if (drawImg != null) {  			//draw the image  			if (((MenuItem)sender).Enabled)  				e.Graphics.DrawImage (drawImg' e.Bounds.Left + LEFT_MARGIN' e.Bounds.Top + ((e.Bounds.Height - ICON_SIZE) / 2)' ICON_SIZE' ICON_SIZE);  			else  				ControlPaint.DrawImageDisabled (e.Graphics' drawImg' e.Bounds.Left + LEFT_MARGIN' e.Bounds.Top + ((e.Bounds.Height - ICON_SIZE) / 2)' SystemColors.Menu);  		}  	}  }  
Magic Number,wyDay.Controls,VistaMenu,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\VistaMenu\OwnerDrawnMenu.cs,MenuItem_DrawItem,The following statement contains a magic number: e.Graphics.DrawLine (SystemPens.ControlDark' e.Bounds.Left + 1' yCenter' (e.Bounds.Left + e.Bounds.Width - 2)' yCenter);  
Magic Number,wyDay.Controls,VistaMenu,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\VistaMenu\OwnerDrawnMenu.cs,MenuItem_DrawItem,The following statement contains a magic number: e.Graphics.DrawLine (SystemPens.ControlLightLight' e.Bounds.Left + 1' yCenter + 1' (e.Bounds.Left + e.Bounds.Width - 2)' yCenter + 1);  
Magic Number,wyDay.Controls,VistaMenu,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\VistaMenu\OwnerDrawnMenu.cs,MenuItem_DrawItem,The following statement contains a magic number: if (((MenuItem)sender).Checked) {  	if (((MenuItem)sender).RadioCheck) {  		//draw the bullet  		ControlPaint.DrawMenuGlyph (e.Graphics' e.Bounds.Left + (LEFT_MARGIN + ICON_SIZE + RIGHT_MARGIN - SystemInformation.MenuCheckSize.Width) / 2' e.Bounds.Top + (e.Bounds.Height - SystemInformation.MenuCheckSize.Height) / 2 + 1' SystemInformation.MenuCheckSize.Width' SystemInformation.MenuCheckSize.Height' MenuGlyph.Bullet' menuSelected ? SystemColors.HighlightText : SystemColors.MenuText' menuSelected ? SystemColors.Highlight : SystemColors.Menu);  	}  	else {  		//draw the check mark  		ControlPaint.DrawMenuGlyph (e.Graphics' e.Bounds.Left + (LEFT_MARGIN + ICON_SIZE + RIGHT_MARGIN - SystemInformation.MenuCheckSize.Width) / 2' e.Bounds.Top + (e.Bounds.Height - SystemInformation.MenuCheckSize.Height) / 2 + 1' SystemInformation.MenuCheckSize.Width' SystemInformation.MenuCheckSize.Height' MenuGlyph.Checkmark' menuSelected ? SystemColors.HighlightText : SystemColors.MenuText' menuSelected ? SystemColors.Highlight : SystemColors.Menu);  	}  }  else {  	Image drawImg = EnsurePropertiesExists ((MenuItem)sender).PreVistaBitmap;  	if (drawImg != null) {  		//draw the image  		if (((MenuItem)sender).Enabled)  			e.Graphics.DrawImage (drawImg' e.Bounds.Left + LEFT_MARGIN' e.Bounds.Top + ((e.Bounds.Height - ICON_SIZE) / 2)' ICON_SIZE' ICON_SIZE);  		else  			ControlPaint.DrawImageDisabled (e.Graphics' drawImg' e.Bounds.Left + LEFT_MARGIN' e.Bounds.Top + ((e.Bounds.Height - ICON_SIZE) / 2)' SystemColors.Menu);  	}  }  
Magic Number,wyDay.Controls,VistaMenu,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\VistaMenu\OwnerDrawnMenu.cs,MenuItem_DrawItem,The following statement contains a magic number: if (((MenuItem)sender).Checked) {  	if (((MenuItem)sender).RadioCheck) {  		//draw the bullet  		ControlPaint.DrawMenuGlyph (e.Graphics' e.Bounds.Left + (LEFT_MARGIN + ICON_SIZE + RIGHT_MARGIN - SystemInformation.MenuCheckSize.Width) / 2' e.Bounds.Top + (e.Bounds.Height - SystemInformation.MenuCheckSize.Height) / 2 + 1' SystemInformation.MenuCheckSize.Width' SystemInformation.MenuCheckSize.Height' MenuGlyph.Bullet' menuSelected ? SystemColors.HighlightText : SystemColors.MenuText' menuSelected ? SystemColors.Highlight : SystemColors.Menu);  	}  	else {  		//draw the check mark  		ControlPaint.DrawMenuGlyph (e.Graphics' e.Bounds.Left + (LEFT_MARGIN + ICON_SIZE + RIGHT_MARGIN - SystemInformation.MenuCheckSize.Width) / 2' e.Bounds.Top + (e.Bounds.Height - SystemInformation.MenuCheckSize.Height) / 2 + 1' SystemInformation.MenuCheckSize.Width' SystemInformation.MenuCheckSize.Height' MenuGlyph.Checkmark' menuSelected ? SystemColors.HighlightText : SystemColors.MenuText' menuSelected ? SystemColors.Highlight : SystemColors.Menu);  	}  }  else {  	Image drawImg = EnsurePropertiesExists ((MenuItem)sender).PreVistaBitmap;  	if (drawImg != null) {  		//draw the image  		if (((MenuItem)sender).Enabled)  			e.Graphics.DrawImage (drawImg' e.Bounds.Left + LEFT_MARGIN' e.Bounds.Top + ((e.Bounds.Height - ICON_SIZE) / 2)' ICON_SIZE' ICON_SIZE);  		else  			ControlPaint.DrawImageDisabled (e.Graphics' drawImg' e.Bounds.Left + LEFT_MARGIN' e.Bounds.Top + ((e.Bounds.Height - ICON_SIZE) / 2)' SystemColors.Menu);  	}  }  
Magic Number,wyDay.Controls,VistaMenu,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\VistaMenu\OwnerDrawnMenu.cs,MenuItem_DrawItem,The following statement contains a magic number: if (((MenuItem)sender).Checked) {  	if (((MenuItem)sender).RadioCheck) {  		//draw the bullet  		ControlPaint.DrawMenuGlyph (e.Graphics' e.Bounds.Left + (LEFT_MARGIN + ICON_SIZE + RIGHT_MARGIN - SystemInformation.MenuCheckSize.Width) / 2' e.Bounds.Top + (e.Bounds.Height - SystemInformation.MenuCheckSize.Height) / 2 + 1' SystemInformation.MenuCheckSize.Width' SystemInformation.MenuCheckSize.Height' MenuGlyph.Bullet' menuSelected ? SystemColors.HighlightText : SystemColors.MenuText' menuSelected ? SystemColors.Highlight : SystemColors.Menu);  	}  	else {  		//draw the check mark  		ControlPaint.DrawMenuGlyph (e.Graphics' e.Bounds.Left + (LEFT_MARGIN + ICON_SIZE + RIGHT_MARGIN - SystemInformation.MenuCheckSize.Width) / 2' e.Bounds.Top + (e.Bounds.Height - SystemInformation.MenuCheckSize.Height) / 2 + 1' SystemInformation.MenuCheckSize.Width' SystemInformation.MenuCheckSize.Height' MenuGlyph.Checkmark' menuSelected ? SystemColors.HighlightText : SystemColors.MenuText' menuSelected ? SystemColors.Highlight : SystemColors.Menu);  	}  }  else {  	Image drawImg = EnsurePropertiesExists ((MenuItem)sender).PreVistaBitmap;  	if (drawImg != null) {  		//draw the image  		if (((MenuItem)sender).Enabled)  			e.Graphics.DrawImage (drawImg' e.Bounds.Left + LEFT_MARGIN' e.Bounds.Top + ((e.Bounds.Height - ICON_SIZE) / 2)' ICON_SIZE' ICON_SIZE);  		else  			ControlPaint.DrawImageDisabled (e.Graphics' drawImg' e.Bounds.Left + LEFT_MARGIN' e.Bounds.Top + ((e.Bounds.Height - ICON_SIZE) / 2)' SystemColors.Menu);  	}  }  
Magic Number,wyDay.Controls,VistaMenu,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\VistaMenu\OwnerDrawnMenu.cs,MenuItem_DrawItem,The following statement contains a magic number: if (((MenuItem)sender).Checked) {  	if (((MenuItem)sender).RadioCheck) {  		//draw the bullet  		ControlPaint.DrawMenuGlyph (e.Graphics' e.Bounds.Left + (LEFT_MARGIN + ICON_SIZE + RIGHT_MARGIN - SystemInformation.MenuCheckSize.Width) / 2' e.Bounds.Top + (e.Bounds.Height - SystemInformation.MenuCheckSize.Height) / 2 + 1' SystemInformation.MenuCheckSize.Width' SystemInformation.MenuCheckSize.Height' MenuGlyph.Bullet' menuSelected ? SystemColors.HighlightText : SystemColors.MenuText' menuSelected ? SystemColors.Highlight : SystemColors.Menu);  	}  	else {  		//draw the check mark  		ControlPaint.DrawMenuGlyph (e.Graphics' e.Bounds.Left + (LEFT_MARGIN + ICON_SIZE + RIGHT_MARGIN - SystemInformation.MenuCheckSize.Width) / 2' e.Bounds.Top + (e.Bounds.Height - SystemInformation.MenuCheckSize.Height) / 2 + 1' SystemInformation.MenuCheckSize.Width' SystemInformation.MenuCheckSize.Height' MenuGlyph.Checkmark' menuSelected ? SystemColors.HighlightText : SystemColors.MenuText' menuSelected ? SystemColors.Highlight : SystemColors.Menu);  	}  }  else {  	Image drawImg = EnsurePropertiesExists ((MenuItem)sender).PreVistaBitmap;  	if (drawImg != null) {  		//draw the image  		if (((MenuItem)sender).Enabled)  			e.Graphics.DrawImage (drawImg' e.Bounds.Left + LEFT_MARGIN' e.Bounds.Top + ((e.Bounds.Height - ICON_SIZE) / 2)' ICON_SIZE' ICON_SIZE);  		else  			ControlPaint.DrawImageDisabled (e.Graphics' drawImg' e.Bounds.Left + LEFT_MARGIN' e.Bounds.Top + ((e.Bounds.Height - ICON_SIZE) / 2)' SystemColors.Menu);  	}  }  
Magic Number,wyDay.Controls,VistaMenu,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\VistaMenu\OwnerDrawnMenu.cs,MenuItem_DrawItem,The following statement contains a magic number: if (((MenuItem)sender).Checked) {  	if (((MenuItem)sender).RadioCheck) {  		//draw the bullet  		ControlPaint.DrawMenuGlyph (e.Graphics' e.Bounds.Left + (LEFT_MARGIN + ICON_SIZE + RIGHT_MARGIN - SystemInformation.MenuCheckSize.Width) / 2' e.Bounds.Top + (e.Bounds.Height - SystemInformation.MenuCheckSize.Height) / 2 + 1' SystemInformation.MenuCheckSize.Width' SystemInformation.MenuCheckSize.Height' MenuGlyph.Bullet' menuSelected ? SystemColors.HighlightText : SystemColors.MenuText' menuSelected ? SystemColors.Highlight : SystemColors.Menu);  	}  	else {  		//draw the check mark  		ControlPaint.DrawMenuGlyph (e.Graphics' e.Bounds.Left + (LEFT_MARGIN + ICON_SIZE + RIGHT_MARGIN - SystemInformation.MenuCheckSize.Width) / 2' e.Bounds.Top + (e.Bounds.Height - SystemInformation.MenuCheckSize.Height) / 2 + 1' SystemInformation.MenuCheckSize.Width' SystemInformation.MenuCheckSize.Height' MenuGlyph.Checkmark' menuSelected ? SystemColors.HighlightText : SystemColors.MenuText' menuSelected ? SystemColors.Highlight : SystemColors.Menu);  	}  }  else {  	Image drawImg = EnsurePropertiesExists ((MenuItem)sender).PreVistaBitmap;  	if (drawImg != null) {  		//draw the image  		if (((MenuItem)sender).Enabled)  			e.Graphics.DrawImage (drawImg' e.Bounds.Left + LEFT_MARGIN' e.Bounds.Top + ((e.Bounds.Height - ICON_SIZE) / 2)' ICON_SIZE' ICON_SIZE);  		else  			ControlPaint.DrawImageDisabled (e.Graphics' drawImg' e.Bounds.Left + LEFT_MARGIN' e.Bounds.Top + ((e.Bounds.Height - ICON_SIZE) / 2)' SystemColors.Menu);  	}  }  
Magic Number,wyDay.Controls,VistaMenu,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\VistaMenu\OwnerDrawnMenu.cs,MenuItem_DrawItem,The following statement contains a magic number: if (((MenuItem)sender).Checked) {  	if (((MenuItem)sender).RadioCheck) {  		//draw the bullet  		ControlPaint.DrawMenuGlyph (e.Graphics' e.Bounds.Left + (LEFT_MARGIN + ICON_SIZE + RIGHT_MARGIN - SystemInformation.MenuCheckSize.Width) / 2' e.Bounds.Top + (e.Bounds.Height - SystemInformation.MenuCheckSize.Height) / 2 + 1' SystemInformation.MenuCheckSize.Width' SystemInformation.MenuCheckSize.Height' MenuGlyph.Bullet' menuSelected ? SystemColors.HighlightText : SystemColors.MenuText' menuSelected ? SystemColors.Highlight : SystemColors.Menu);  	}  	else {  		//draw the check mark  		ControlPaint.DrawMenuGlyph (e.Graphics' e.Bounds.Left + (LEFT_MARGIN + ICON_SIZE + RIGHT_MARGIN - SystemInformation.MenuCheckSize.Width) / 2' e.Bounds.Top + (e.Bounds.Height - SystemInformation.MenuCheckSize.Height) / 2 + 1' SystemInformation.MenuCheckSize.Width' SystemInformation.MenuCheckSize.Height' MenuGlyph.Checkmark' menuSelected ? SystemColors.HighlightText : SystemColors.MenuText' menuSelected ? SystemColors.Highlight : SystemColors.Menu);  	}  }  else {  	Image drawImg = EnsurePropertiesExists ((MenuItem)sender).PreVistaBitmap;  	if (drawImg != null) {  		//draw the image  		if (((MenuItem)sender).Enabled)  			e.Graphics.DrawImage (drawImg' e.Bounds.Left + LEFT_MARGIN' e.Bounds.Top + ((e.Bounds.Height - ICON_SIZE) / 2)' ICON_SIZE' ICON_SIZE);  		else  			ControlPaint.DrawImageDisabled (e.Graphics' drawImg' e.Bounds.Left + LEFT_MARGIN' e.Bounds.Top + ((e.Bounds.Height - ICON_SIZE) / 2)' SystemColors.Menu);  	}  }  
Magic Number,wyDay.Controls,VistaMenu,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\VistaMenu\OwnerDrawnMenu.cs,MenuItem_DrawItem,The following statement contains a magic number: if (((MenuItem)sender).RadioCheck) {  	//draw the bullet  	ControlPaint.DrawMenuGlyph (e.Graphics' e.Bounds.Left + (LEFT_MARGIN + ICON_SIZE + RIGHT_MARGIN - SystemInformation.MenuCheckSize.Width) / 2' e.Bounds.Top + (e.Bounds.Height - SystemInformation.MenuCheckSize.Height) / 2 + 1' SystemInformation.MenuCheckSize.Width' SystemInformation.MenuCheckSize.Height' MenuGlyph.Bullet' menuSelected ? SystemColors.HighlightText : SystemColors.MenuText' menuSelected ? SystemColors.Highlight : SystemColors.Menu);  }  else {  	//draw the check mark  	ControlPaint.DrawMenuGlyph (e.Graphics' e.Bounds.Left + (LEFT_MARGIN + ICON_SIZE + RIGHT_MARGIN - SystemInformation.MenuCheckSize.Width) / 2' e.Bounds.Top + (e.Bounds.Height - SystemInformation.MenuCheckSize.Height) / 2 + 1' SystemInformation.MenuCheckSize.Width' SystemInformation.MenuCheckSize.Height' MenuGlyph.Checkmark' menuSelected ? SystemColors.HighlightText : SystemColors.MenuText' menuSelected ? SystemColors.Highlight : SystemColors.Menu);  }  
Magic Number,wyDay.Controls,VistaMenu,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\VistaMenu\OwnerDrawnMenu.cs,MenuItem_DrawItem,The following statement contains a magic number: if (((MenuItem)sender).RadioCheck) {  	//draw the bullet  	ControlPaint.DrawMenuGlyph (e.Graphics' e.Bounds.Left + (LEFT_MARGIN + ICON_SIZE + RIGHT_MARGIN - SystemInformation.MenuCheckSize.Width) / 2' e.Bounds.Top + (e.Bounds.Height - SystemInformation.MenuCheckSize.Height) / 2 + 1' SystemInformation.MenuCheckSize.Width' SystemInformation.MenuCheckSize.Height' MenuGlyph.Bullet' menuSelected ? SystemColors.HighlightText : SystemColors.MenuText' menuSelected ? SystemColors.Highlight : SystemColors.Menu);  }  else {  	//draw the check mark  	ControlPaint.DrawMenuGlyph (e.Graphics' e.Bounds.Left + (LEFT_MARGIN + ICON_SIZE + RIGHT_MARGIN - SystemInformation.MenuCheckSize.Width) / 2' e.Bounds.Top + (e.Bounds.Height - SystemInformation.MenuCheckSize.Height) / 2 + 1' SystemInformation.MenuCheckSize.Width' SystemInformation.MenuCheckSize.Height' MenuGlyph.Checkmark' menuSelected ? SystemColors.HighlightText : SystemColors.MenuText' menuSelected ? SystemColors.Highlight : SystemColors.Menu);  }  
Magic Number,wyDay.Controls,VistaMenu,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\VistaMenu\OwnerDrawnMenu.cs,MenuItem_DrawItem,The following statement contains a magic number: if (((MenuItem)sender).RadioCheck) {  	//draw the bullet  	ControlPaint.DrawMenuGlyph (e.Graphics' e.Bounds.Left + (LEFT_MARGIN + ICON_SIZE + RIGHT_MARGIN - SystemInformation.MenuCheckSize.Width) / 2' e.Bounds.Top + (e.Bounds.Height - SystemInformation.MenuCheckSize.Height) / 2 + 1' SystemInformation.MenuCheckSize.Width' SystemInformation.MenuCheckSize.Height' MenuGlyph.Bullet' menuSelected ? SystemColors.HighlightText : SystemColors.MenuText' menuSelected ? SystemColors.Highlight : SystemColors.Menu);  }  else {  	//draw the check mark  	ControlPaint.DrawMenuGlyph (e.Graphics' e.Bounds.Left + (LEFT_MARGIN + ICON_SIZE + RIGHT_MARGIN - SystemInformation.MenuCheckSize.Width) / 2' e.Bounds.Top + (e.Bounds.Height - SystemInformation.MenuCheckSize.Height) / 2 + 1' SystemInformation.MenuCheckSize.Width' SystemInformation.MenuCheckSize.Height' MenuGlyph.Checkmark' menuSelected ? SystemColors.HighlightText : SystemColors.MenuText' menuSelected ? SystemColors.Highlight : SystemColors.Menu);  }  
Magic Number,wyDay.Controls,VistaMenu,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\VistaMenu\OwnerDrawnMenu.cs,MenuItem_DrawItem,The following statement contains a magic number: if (((MenuItem)sender).RadioCheck) {  	//draw the bullet  	ControlPaint.DrawMenuGlyph (e.Graphics' e.Bounds.Left + (LEFT_MARGIN + ICON_SIZE + RIGHT_MARGIN - SystemInformation.MenuCheckSize.Width) / 2' e.Bounds.Top + (e.Bounds.Height - SystemInformation.MenuCheckSize.Height) / 2 + 1' SystemInformation.MenuCheckSize.Width' SystemInformation.MenuCheckSize.Height' MenuGlyph.Bullet' menuSelected ? SystemColors.HighlightText : SystemColors.MenuText' menuSelected ? SystemColors.Highlight : SystemColors.Menu);  }  else {  	//draw the check mark  	ControlPaint.DrawMenuGlyph (e.Graphics' e.Bounds.Left + (LEFT_MARGIN + ICON_SIZE + RIGHT_MARGIN - SystemInformation.MenuCheckSize.Width) / 2' e.Bounds.Top + (e.Bounds.Height - SystemInformation.MenuCheckSize.Height) / 2 + 1' SystemInformation.MenuCheckSize.Width' SystemInformation.MenuCheckSize.Height' MenuGlyph.Checkmark' menuSelected ? SystemColors.HighlightText : SystemColors.MenuText' menuSelected ? SystemColors.Highlight : SystemColors.Menu);  }  
Magic Number,wyDay.Controls,VistaMenu,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\VistaMenu\OwnerDrawnMenu.cs,MenuItem_DrawItem,The following statement contains a magic number: ControlPaint.DrawMenuGlyph (e.Graphics' e.Bounds.Left + (LEFT_MARGIN + ICON_SIZE + RIGHT_MARGIN - SystemInformation.MenuCheckSize.Width) / 2' e.Bounds.Top + (e.Bounds.Height - SystemInformation.MenuCheckSize.Height) / 2 + 1' SystemInformation.MenuCheckSize.Width' SystemInformation.MenuCheckSize.Height' MenuGlyph.Bullet' menuSelected ? SystemColors.HighlightText : SystemColors.MenuText' menuSelected ? SystemColors.Highlight : SystemColors.Menu);  
Magic Number,wyDay.Controls,VistaMenu,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\VistaMenu\OwnerDrawnMenu.cs,MenuItem_DrawItem,The following statement contains a magic number: ControlPaint.DrawMenuGlyph (e.Graphics' e.Bounds.Left + (LEFT_MARGIN + ICON_SIZE + RIGHT_MARGIN - SystemInformation.MenuCheckSize.Width) / 2' e.Bounds.Top + (e.Bounds.Height - SystemInformation.MenuCheckSize.Height) / 2 + 1' SystemInformation.MenuCheckSize.Width' SystemInformation.MenuCheckSize.Height' MenuGlyph.Bullet' menuSelected ? SystemColors.HighlightText : SystemColors.MenuText' menuSelected ? SystemColors.Highlight : SystemColors.Menu);  
Magic Number,wyDay.Controls,VistaMenu,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\VistaMenu\OwnerDrawnMenu.cs,MenuItem_DrawItem,The following statement contains a magic number: ControlPaint.DrawMenuGlyph (e.Graphics' e.Bounds.Left + (LEFT_MARGIN + ICON_SIZE + RIGHT_MARGIN - SystemInformation.MenuCheckSize.Width) / 2' e.Bounds.Top + (e.Bounds.Height - SystemInformation.MenuCheckSize.Height) / 2 + 1' SystemInformation.MenuCheckSize.Width' SystemInformation.MenuCheckSize.Height' MenuGlyph.Checkmark' menuSelected ? SystemColors.HighlightText : SystemColors.MenuText' menuSelected ? SystemColors.Highlight : SystemColors.Menu);  
Magic Number,wyDay.Controls,VistaMenu,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\VistaMenu\OwnerDrawnMenu.cs,MenuItem_DrawItem,The following statement contains a magic number: ControlPaint.DrawMenuGlyph (e.Graphics' e.Bounds.Left + (LEFT_MARGIN + ICON_SIZE + RIGHT_MARGIN - SystemInformation.MenuCheckSize.Width) / 2' e.Bounds.Top + (e.Bounds.Height - SystemInformation.MenuCheckSize.Height) / 2 + 1' SystemInformation.MenuCheckSize.Width' SystemInformation.MenuCheckSize.Height' MenuGlyph.Checkmark' menuSelected ? SystemColors.HighlightText : SystemColors.MenuText' menuSelected ? SystemColors.Highlight : SystemColors.Menu);  
Magic Number,wyDay.Controls,VistaMenu,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\VistaMenu\OwnerDrawnMenu.cs,MenuItem_DrawItem,The following statement contains a magic number: if (drawImg != null) {  	//draw the image  	if (((MenuItem)sender).Enabled)  		e.Graphics.DrawImage (drawImg' e.Bounds.Left + LEFT_MARGIN' e.Bounds.Top + ((e.Bounds.Height - ICON_SIZE) / 2)' ICON_SIZE' ICON_SIZE);  	else  		ControlPaint.DrawImageDisabled (e.Graphics' drawImg' e.Bounds.Left + LEFT_MARGIN' e.Bounds.Top + ((e.Bounds.Height - ICON_SIZE) / 2)' SystemColors.Menu);  }  
Magic Number,wyDay.Controls,VistaMenu,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\VistaMenu\OwnerDrawnMenu.cs,MenuItem_DrawItem,The following statement contains a magic number: if (drawImg != null) {  	//draw the image  	if (((MenuItem)sender).Enabled)  		e.Graphics.DrawImage (drawImg' e.Bounds.Left + LEFT_MARGIN' e.Bounds.Top + ((e.Bounds.Height - ICON_SIZE) / 2)' ICON_SIZE' ICON_SIZE);  	else  		ControlPaint.DrawImageDisabled (e.Graphics' drawImg' e.Bounds.Left + LEFT_MARGIN' e.Bounds.Top + ((e.Bounds.Height - ICON_SIZE) / 2)' SystemColors.Menu);  }  
Magic Number,wyDay.Controls,VistaMenu,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\VistaMenu\OwnerDrawnMenu.cs,MenuItem_DrawItem,The following statement contains a magic number: if (((MenuItem)sender).Enabled)  	e.Graphics.DrawImage (drawImg' e.Bounds.Left + LEFT_MARGIN' e.Bounds.Top + ((e.Bounds.Height - ICON_SIZE) / 2)' ICON_SIZE' ICON_SIZE);  else  	ControlPaint.DrawImageDisabled (e.Graphics' drawImg' e.Bounds.Left + LEFT_MARGIN' e.Bounds.Top + ((e.Bounds.Height - ICON_SIZE) / 2)' SystemColors.Menu);  
Magic Number,wyDay.Controls,VistaMenu,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\VistaMenu\OwnerDrawnMenu.cs,MenuItem_DrawItem,The following statement contains a magic number: if (((MenuItem)sender).Enabled)  	e.Graphics.DrawImage (drawImg' e.Bounds.Left + LEFT_MARGIN' e.Bounds.Top + ((e.Bounds.Height - ICON_SIZE) / 2)' ICON_SIZE' ICON_SIZE);  else  	ControlPaint.DrawImageDisabled (e.Graphics' drawImg' e.Bounds.Left + LEFT_MARGIN' e.Bounds.Top + ((e.Bounds.Height - ICON_SIZE) / 2)' SystemColors.Menu);  
Magic Number,wyDay.Controls,VistaMenu,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\VistaMenu\OwnerDrawnMenu.cs,MenuItem_DrawItem,The following statement contains a magic number: e.Graphics.DrawImage (drawImg' e.Bounds.Left + LEFT_MARGIN' e.Bounds.Top + ((e.Bounds.Height - ICON_SIZE) / 2)' ICON_SIZE' ICON_SIZE);  
Magic Number,wyDay.Controls,VistaMenu,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\VistaMenu\OwnerDrawnMenu.cs,MenuItem_DrawItem,The following statement contains a magic number: ControlPaint.DrawImageDisabled (e.Graphics' drawImg' e.Bounds.Left + LEFT_MARGIN' e.Bounds.Top + ((e.Bounds.Height - ICON_SIZE) / 2)' SystemColors.Menu);  
Magic Number,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,PaintArrow,The following statement contains a magic number: middle.X += (dropDownRect.Width % 2);  
Magic Number,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,GetPreferredSize,The following statement contains a magic number: if (showSplit) {  	if (AutoSize)  		return CalculateButtonAutoSize ();  	else if (!string.IsNullOrEmpty (Text) && TextRenderer.MeasureText (Text' Font).Width + SplitSectionWidth > preferredSize.Width)  		return preferredSize + new Size (SplitSectionWidth + BorderSize * 2' 0);  }  
Magic Number,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,GetPreferredSize,The following statement contains a magic number: if (AutoSize)  	return CalculateButtonAutoSize ();  else if (!string.IsNullOrEmpty (Text) && TextRenderer.MeasureText (Text' Font).Width + SplitSectionWidth > preferredSize.Width)  	return preferredSize + new Size (SplitSectionWidth + BorderSize * 2' 0);  
Magic Number,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,GetPreferredSize,The following statement contains a magic number: if (!string.IsNullOrEmpty (Text) && TextRenderer.MeasureText (Text' Font).Width + SplitSectionWidth > preferredSize.Width)  	return preferredSize + new Size (SplitSectionWidth + BorderSize * 2' 0);  
Magic Number,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,GetPreferredSize,The following statement contains a magic number: return preferredSize + new Size (SplitSectionWidth + BorderSize * 2' 0);  
Magic Number,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,CalculateButtonAutoSize,The following statement contains a magic number: if (Text.Length != 0) {  	text_size.Height += 4;  	text_size.Width += 4;  }  
Magic Number,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,CalculateButtonAutoSize,The following statement contains a magic number: if (Text.Length != 0) {  	text_size.Height += 4;  	text_size.Width += 4;  }  
Magic Number,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,CalculateButtonAutoSize,The following statement contains a magic number: text_size.Height += 4;  
Magic Number,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,CalculateButtonAutoSize,The following statement contains a magic number: text_size.Width += 4;  
Magic Number,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,CalculateButtonAutoSize,The following statement contains a magic number: ret_size.Height += (Padding.Vertical + 6);  
Magic Number,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,CalculateButtonAutoSize,The following statement contains a magic number: ret_size.Width += (Padding.Horizontal + 6);  
Magic Number,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,CalculateButtonTextAndImageLayout,The following statement contains a magic number: switch (TextImageRelation) {  case TextImageRelation.Overlay:  	// Overlay is easy' text always goes here  	textRectangle = OverlayObjectRect (ref content_rect' ref text_size' TextAlign);  	// Rectangle.Inflate(content_rect' -4' -4);  	//Offset on Windows 98 style when button is pressed  	if (_state == PushButtonState.Pressed && !Application.RenderWithVisualStyles)  		textRectangle.Offset (1' 1);  	// Image is dependent on ImageAlign  	if (Image != null)  		imageRectangle = OverlayObjectRect (ref content_rect' ref image_size' ImageAlign);  	break;  case TextImageRelation.ImageAboveText:  	content_rect.Inflate (-4' -4);  	LayoutTextAboveOrBelowImage (content_rect' false' text_size' image_size' out textRectangle' out imageRectangle);  	break;  case TextImageRelation.TextAboveImage:  	content_rect.Inflate (-4' -4);  	LayoutTextAboveOrBelowImage (content_rect' true' text_size' image_size' out textRectangle' out imageRectangle);  	break;  case TextImageRelation.ImageBeforeText:  	content_rect.Inflate (-4' -4);  	LayoutTextBeforeOrAfterImage (content_rect' false' text_size' image_size' out textRectangle' out imageRectangle);  	break;  case TextImageRelation.TextBeforeImage:  	content_rect.Inflate (-4' -4);  	LayoutTextBeforeOrAfterImage (content_rect' true' text_size' image_size' out textRectangle' out imageRectangle);  	break;  }  
Magic Number,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,CalculateButtonTextAndImageLayout,The following statement contains a magic number: switch (TextImageRelation) {  case TextImageRelation.Overlay:  	// Overlay is easy' text always goes here  	textRectangle = OverlayObjectRect (ref content_rect' ref text_size' TextAlign);  	// Rectangle.Inflate(content_rect' -4' -4);  	//Offset on Windows 98 style when button is pressed  	if (_state == PushButtonState.Pressed && !Application.RenderWithVisualStyles)  		textRectangle.Offset (1' 1);  	// Image is dependent on ImageAlign  	if (Image != null)  		imageRectangle = OverlayObjectRect (ref content_rect' ref image_size' ImageAlign);  	break;  case TextImageRelation.ImageAboveText:  	content_rect.Inflate (-4' -4);  	LayoutTextAboveOrBelowImage (content_rect' false' text_size' image_size' out textRectangle' out imageRectangle);  	break;  case TextImageRelation.TextAboveImage:  	content_rect.Inflate (-4' -4);  	LayoutTextAboveOrBelowImage (content_rect' true' text_size' image_size' out textRectangle' out imageRectangle);  	break;  case TextImageRelation.ImageBeforeText:  	content_rect.Inflate (-4' -4);  	LayoutTextBeforeOrAfterImage (content_rect' false' text_size' image_size' out textRectangle' out imageRectangle);  	break;  case TextImageRelation.TextBeforeImage:  	content_rect.Inflate (-4' -4);  	LayoutTextBeforeOrAfterImage (content_rect' true' text_size' image_size' out textRectangle' out imageRectangle);  	break;  }  
Magic Number,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,CalculateButtonTextAndImageLayout,The following statement contains a magic number: switch (TextImageRelation) {  case TextImageRelation.Overlay:  	// Overlay is easy' text always goes here  	textRectangle = OverlayObjectRect (ref content_rect' ref text_size' TextAlign);  	// Rectangle.Inflate(content_rect' -4' -4);  	//Offset on Windows 98 style when button is pressed  	if (_state == PushButtonState.Pressed && !Application.RenderWithVisualStyles)  		textRectangle.Offset (1' 1);  	// Image is dependent on ImageAlign  	if (Image != null)  		imageRectangle = OverlayObjectRect (ref content_rect' ref image_size' ImageAlign);  	break;  case TextImageRelation.ImageAboveText:  	content_rect.Inflate (-4' -4);  	LayoutTextAboveOrBelowImage (content_rect' false' text_size' image_size' out textRectangle' out imageRectangle);  	break;  case TextImageRelation.TextAboveImage:  	content_rect.Inflate (-4' -4);  	LayoutTextAboveOrBelowImage (content_rect' true' text_size' image_size' out textRectangle' out imageRectangle);  	break;  case TextImageRelation.ImageBeforeText:  	content_rect.Inflate (-4' -4);  	LayoutTextBeforeOrAfterImage (content_rect' false' text_size' image_size' out textRectangle' out imageRectangle);  	break;  case TextImageRelation.TextBeforeImage:  	content_rect.Inflate (-4' -4);  	LayoutTextBeforeOrAfterImage (content_rect' true' text_size' image_size' out textRectangle' out imageRectangle);  	break;  }  
Magic Number,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,CalculateButtonTextAndImageLayout,The following statement contains a magic number: switch (TextImageRelation) {  case TextImageRelation.Overlay:  	// Overlay is easy' text always goes here  	textRectangle = OverlayObjectRect (ref content_rect' ref text_size' TextAlign);  	// Rectangle.Inflate(content_rect' -4' -4);  	//Offset on Windows 98 style when button is pressed  	if (_state == PushButtonState.Pressed && !Application.RenderWithVisualStyles)  		textRectangle.Offset (1' 1);  	// Image is dependent on ImageAlign  	if (Image != null)  		imageRectangle = OverlayObjectRect (ref content_rect' ref image_size' ImageAlign);  	break;  case TextImageRelation.ImageAboveText:  	content_rect.Inflate (-4' -4);  	LayoutTextAboveOrBelowImage (content_rect' false' text_size' image_size' out textRectangle' out imageRectangle);  	break;  case TextImageRelation.TextAboveImage:  	content_rect.Inflate (-4' -4);  	LayoutTextAboveOrBelowImage (content_rect' true' text_size' image_size' out textRectangle' out imageRectangle);  	break;  case TextImageRelation.ImageBeforeText:  	content_rect.Inflate (-4' -4);  	LayoutTextBeforeOrAfterImage (content_rect' false' text_size' image_size' out textRectangle' out imageRectangle);  	break;  case TextImageRelation.TextBeforeImage:  	content_rect.Inflate (-4' -4);  	LayoutTextBeforeOrAfterImage (content_rect' true' text_size' image_size' out textRectangle' out imageRectangle);  	break;  }  
Magic Number,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,CalculateButtonTextAndImageLayout,The following statement contains a magic number: switch (TextImageRelation) {  case TextImageRelation.Overlay:  	// Overlay is easy' text always goes here  	textRectangle = OverlayObjectRect (ref content_rect' ref text_size' TextAlign);  	// Rectangle.Inflate(content_rect' -4' -4);  	//Offset on Windows 98 style when button is pressed  	if (_state == PushButtonState.Pressed && !Application.RenderWithVisualStyles)  		textRectangle.Offset (1' 1);  	// Image is dependent on ImageAlign  	if (Image != null)  		imageRectangle = OverlayObjectRect (ref content_rect' ref image_size' ImageAlign);  	break;  case TextImageRelation.ImageAboveText:  	content_rect.Inflate (-4' -4);  	LayoutTextAboveOrBelowImage (content_rect' false' text_size' image_size' out textRectangle' out imageRectangle);  	break;  case TextImageRelation.TextAboveImage:  	content_rect.Inflate (-4' -4);  	LayoutTextAboveOrBelowImage (content_rect' true' text_size' image_size' out textRectangle' out imageRectangle);  	break;  case TextImageRelation.ImageBeforeText:  	content_rect.Inflate (-4' -4);  	LayoutTextBeforeOrAfterImage (content_rect' false' text_size' image_size' out textRectangle' out imageRectangle);  	break;  case TextImageRelation.TextBeforeImage:  	content_rect.Inflate (-4' -4);  	LayoutTextBeforeOrAfterImage (content_rect' true' text_size' image_size' out textRectangle' out imageRectangle);  	break;  }  
Magic Number,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,CalculateButtonTextAndImageLayout,The following statement contains a magic number: switch (TextImageRelation) {  case TextImageRelation.Overlay:  	// Overlay is easy' text always goes here  	textRectangle = OverlayObjectRect (ref content_rect' ref text_size' TextAlign);  	// Rectangle.Inflate(content_rect' -4' -4);  	//Offset on Windows 98 style when button is pressed  	if (_state == PushButtonState.Pressed && !Application.RenderWithVisualStyles)  		textRectangle.Offset (1' 1);  	// Image is dependent on ImageAlign  	if (Image != null)  		imageRectangle = OverlayObjectRect (ref content_rect' ref image_size' ImageAlign);  	break;  case TextImageRelation.ImageAboveText:  	content_rect.Inflate (-4' -4);  	LayoutTextAboveOrBelowImage (content_rect' false' text_size' image_size' out textRectangle' out imageRectangle);  	break;  case TextImageRelation.TextAboveImage:  	content_rect.Inflate (-4' -4);  	LayoutTextAboveOrBelowImage (content_rect' true' text_size' image_size' out textRectangle' out imageRectangle);  	break;  case TextImageRelation.ImageBeforeText:  	content_rect.Inflate (-4' -4);  	LayoutTextBeforeOrAfterImage (content_rect' false' text_size' image_size' out textRectangle' out imageRectangle);  	break;  case TextImageRelation.TextBeforeImage:  	content_rect.Inflate (-4' -4);  	LayoutTextBeforeOrAfterImage (content_rect' true' text_size' image_size' out textRectangle' out imageRectangle);  	break;  }  
Magic Number,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,CalculateButtonTextAndImageLayout,The following statement contains a magic number: switch (TextImageRelation) {  case TextImageRelation.Overlay:  	// Overlay is easy' text always goes here  	textRectangle = OverlayObjectRect (ref content_rect' ref text_size' TextAlign);  	// Rectangle.Inflate(content_rect' -4' -4);  	//Offset on Windows 98 style when button is pressed  	if (_state == PushButtonState.Pressed && !Application.RenderWithVisualStyles)  		textRectangle.Offset (1' 1);  	// Image is dependent on ImageAlign  	if (Image != null)  		imageRectangle = OverlayObjectRect (ref content_rect' ref image_size' ImageAlign);  	break;  case TextImageRelation.ImageAboveText:  	content_rect.Inflate (-4' -4);  	LayoutTextAboveOrBelowImage (content_rect' false' text_size' image_size' out textRectangle' out imageRectangle);  	break;  case TextImageRelation.TextAboveImage:  	content_rect.Inflate (-4' -4);  	LayoutTextAboveOrBelowImage (content_rect' true' text_size' image_size' out textRectangle' out imageRectangle);  	break;  case TextImageRelation.ImageBeforeText:  	content_rect.Inflate (-4' -4);  	LayoutTextBeforeOrAfterImage (content_rect' false' text_size' image_size' out textRectangle' out imageRectangle);  	break;  case TextImageRelation.TextBeforeImage:  	content_rect.Inflate (-4' -4);  	LayoutTextBeforeOrAfterImage (content_rect' true' text_size' image_size' out textRectangle' out imageRectangle);  	break;  }  
Magic Number,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,CalculateButtonTextAndImageLayout,The following statement contains a magic number: switch (TextImageRelation) {  case TextImageRelation.Overlay:  	// Overlay is easy' text always goes here  	textRectangle = OverlayObjectRect (ref content_rect' ref text_size' TextAlign);  	// Rectangle.Inflate(content_rect' -4' -4);  	//Offset on Windows 98 style when button is pressed  	if (_state == PushButtonState.Pressed && !Application.RenderWithVisualStyles)  		textRectangle.Offset (1' 1);  	// Image is dependent on ImageAlign  	if (Image != null)  		imageRectangle = OverlayObjectRect (ref content_rect' ref image_size' ImageAlign);  	break;  case TextImageRelation.ImageAboveText:  	content_rect.Inflate (-4' -4);  	LayoutTextAboveOrBelowImage (content_rect' false' text_size' image_size' out textRectangle' out imageRectangle);  	break;  case TextImageRelation.TextAboveImage:  	content_rect.Inflate (-4' -4);  	LayoutTextAboveOrBelowImage (content_rect' true' text_size' image_size' out textRectangle' out imageRectangle);  	break;  case TextImageRelation.ImageBeforeText:  	content_rect.Inflate (-4' -4);  	LayoutTextBeforeOrAfterImage (content_rect' false' text_size' image_size' out textRectangle' out imageRectangle);  	break;  case TextImageRelation.TextBeforeImage:  	content_rect.Inflate (-4' -4);  	LayoutTextBeforeOrAfterImage (content_rect' true' text_size' image_size' out textRectangle' out imageRectangle);  	break;  }  
Magic Number,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,CalculateButtonTextAndImageLayout,The following statement contains a magic number: content_rect.Inflate (-4' -4);  
Magic Number,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,CalculateButtonTextAndImageLayout,The following statement contains a magic number: content_rect.Inflate (-4' -4);  
Magic Number,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,CalculateButtonTextAndImageLayout,The following statement contains a magic number: content_rect.Inflate (-4' -4);  
Magic Number,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,CalculateButtonTextAndImageLayout,The following statement contains a magic number: content_rect.Inflate (-4' -4);  
Magic Number,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,CalculateButtonTextAndImageLayout,The following statement contains a magic number: content_rect.Inflate (-4' -4);  
Magic Number,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,CalculateButtonTextAndImageLayout,The following statement contains a magic number: content_rect.Inflate (-4' -4);  
Magic Number,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,CalculateButtonTextAndImageLayout,The following statement contains a magic number: content_rect.Inflate (-4' -4);  
Magic Number,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,CalculateButtonTextAndImageLayout,The following statement contains a magic number: content_rect.Inflate (-4' -4);  
Magic Number,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,OverlayObjectRect,The following statement contains a magic number: switch (alignment) {  case System.Drawing.ContentAlignment.TopLeft:  	x = 4;  	y = 4;  	break;  case System.Drawing.ContentAlignment.TopCenter:  	x = (container.Width - sizeOfObject.Width) / 2;  	y = 4;  	break;  case System.Drawing.ContentAlignment.TopRight:  	x = container.Width - sizeOfObject.Width - 4;  	y = 4;  	break;  case System.Drawing.ContentAlignment.MiddleLeft:  	x = 4;  	y = (container.Height - sizeOfObject.Height) / 2;  	break;  case System.Drawing.ContentAlignment.MiddleCenter:  	x = (container.Width - sizeOfObject.Width) / 2;  	y = (container.Height - sizeOfObject.Height) / 2;  	break;  case System.Drawing.ContentAlignment.MiddleRight:  	x = container.Width - sizeOfObject.Width - 4;  	y = (container.Height - sizeOfObject.Height) / 2;  	break;  case System.Drawing.ContentAlignment.BottomLeft:  	x = 4;  	y = container.Height - sizeOfObject.Height - 4;  	break;  case System.Drawing.ContentAlignment.BottomCenter:  	x = (container.Width - sizeOfObject.Width) / 2;  	y = container.Height - sizeOfObject.Height - 4;  	break;  case System.Drawing.ContentAlignment.BottomRight:  	x = container.Width - sizeOfObject.Width - 4;  	y = container.Height - sizeOfObject.Height - 4;  	break;  default:  	x = 4;  	y = 4;  	break;  }  
Magic Number,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,OverlayObjectRect,The following statement contains a magic number: switch (alignment) {  case System.Drawing.ContentAlignment.TopLeft:  	x = 4;  	y = 4;  	break;  case System.Drawing.ContentAlignment.TopCenter:  	x = (container.Width - sizeOfObject.Width) / 2;  	y = 4;  	break;  case System.Drawing.ContentAlignment.TopRight:  	x = container.Width - sizeOfObject.Width - 4;  	y = 4;  	break;  case System.Drawing.ContentAlignment.MiddleLeft:  	x = 4;  	y = (container.Height - sizeOfObject.Height) / 2;  	break;  case System.Drawing.ContentAlignment.MiddleCenter:  	x = (container.Width - sizeOfObject.Width) / 2;  	y = (container.Height - sizeOfObject.Height) / 2;  	break;  case System.Drawing.ContentAlignment.MiddleRight:  	x = container.Width - sizeOfObject.Width - 4;  	y = (container.Height - sizeOfObject.Height) / 2;  	break;  case System.Drawing.ContentAlignment.BottomLeft:  	x = 4;  	y = container.Height - sizeOfObject.Height - 4;  	break;  case System.Drawing.ContentAlignment.BottomCenter:  	x = (container.Width - sizeOfObject.Width) / 2;  	y = container.Height - sizeOfObject.Height - 4;  	break;  case System.Drawing.ContentAlignment.BottomRight:  	x = container.Width - sizeOfObject.Width - 4;  	y = container.Height - sizeOfObject.Height - 4;  	break;  default:  	x = 4;  	y = 4;  	break;  }  
Magic Number,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,OverlayObjectRect,The following statement contains a magic number: switch (alignment) {  case System.Drawing.ContentAlignment.TopLeft:  	x = 4;  	y = 4;  	break;  case System.Drawing.ContentAlignment.TopCenter:  	x = (container.Width - sizeOfObject.Width) / 2;  	y = 4;  	break;  case System.Drawing.ContentAlignment.TopRight:  	x = container.Width - sizeOfObject.Width - 4;  	y = 4;  	break;  case System.Drawing.ContentAlignment.MiddleLeft:  	x = 4;  	y = (container.Height - sizeOfObject.Height) / 2;  	break;  case System.Drawing.ContentAlignment.MiddleCenter:  	x = (container.Width - sizeOfObject.Width) / 2;  	y = (container.Height - sizeOfObject.Height) / 2;  	break;  case System.Drawing.ContentAlignment.MiddleRight:  	x = container.Width - sizeOfObject.Width - 4;  	y = (container.Height - sizeOfObject.Height) / 2;  	break;  case System.Drawing.ContentAlignment.BottomLeft:  	x = 4;  	y = container.Height - sizeOfObject.Height - 4;  	break;  case System.Drawing.ContentAlignment.BottomCenter:  	x = (container.Width - sizeOfObject.Width) / 2;  	y = container.Height - sizeOfObject.Height - 4;  	break;  case System.Drawing.ContentAlignment.BottomRight:  	x = container.Width - sizeOfObject.Width - 4;  	y = container.Height - sizeOfObject.Height - 4;  	break;  default:  	x = 4;  	y = 4;  	break;  }  
Magic Number,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,OverlayObjectRect,The following statement contains a magic number: switch (alignment) {  case System.Drawing.ContentAlignment.TopLeft:  	x = 4;  	y = 4;  	break;  case System.Drawing.ContentAlignment.TopCenter:  	x = (container.Width - sizeOfObject.Width) / 2;  	y = 4;  	break;  case System.Drawing.ContentAlignment.TopRight:  	x = container.Width - sizeOfObject.Width - 4;  	y = 4;  	break;  case System.Drawing.ContentAlignment.MiddleLeft:  	x = 4;  	y = (container.Height - sizeOfObject.Height) / 2;  	break;  case System.Drawing.ContentAlignment.MiddleCenter:  	x = (container.Width - sizeOfObject.Width) / 2;  	y = (container.Height - sizeOfObject.Height) / 2;  	break;  case System.Drawing.ContentAlignment.MiddleRight:  	x = container.Width - sizeOfObject.Width - 4;  	y = (container.Height - sizeOfObject.Height) / 2;  	break;  case System.Drawing.ContentAlignment.BottomLeft:  	x = 4;  	y = container.Height - sizeOfObject.Height - 4;  	break;  case System.Drawing.ContentAlignment.BottomCenter:  	x = (container.Width - sizeOfObject.Width) / 2;  	y = container.Height - sizeOfObject.Height - 4;  	break;  case System.Drawing.ContentAlignment.BottomRight:  	x = container.Width - sizeOfObject.Width - 4;  	y = container.Height - sizeOfObject.Height - 4;  	break;  default:  	x = 4;  	y = 4;  	break;  }  
Magic Number,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,OverlayObjectRect,The following statement contains a magic number: switch (alignment) {  case System.Drawing.ContentAlignment.TopLeft:  	x = 4;  	y = 4;  	break;  case System.Drawing.ContentAlignment.TopCenter:  	x = (container.Width - sizeOfObject.Width) / 2;  	y = 4;  	break;  case System.Drawing.ContentAlignment.TopRight:  	x = container.Width - sizeOfObject.Width - 4;  	y = 4;  	break;  case System.Drawing.ContentAlignment.MiddleLeft:  	x = 4;  	y = (container.Height - sizeOfObject.Height) / 2;  	break;  case System.Drawing.ContentAlignment.MiddleCenter:  	x = (container.Width - sizeOfObject.Width) / 2;  	y = (container.Height - sizeOfObject.Height) / 2;  	break;  case System.Drawing.ContentAlignment.MiddleRight:  	x = container.Width - sizeOfObject.Width - 4;  	y = (container.Height - sizeOfObject.Height) / 2;  	break;  case System.Drawing.ContentAlignment.BottomLeft:  	x = 4;  	y = container.Height - sizeOfObject.Height - 4;  	break;  case System.Drawing.ContentAlignment.BottomCenter:  	x = (container.Width - sizeOfObject.Width) / 2;  	y = container.Height - sizeOfObject.Height - 4;  	break;  case System.Drawing.ContentAlignment.BottomRight:  	x = container.Width - sizeOfObject.Width - 4;  	y = container.Height - sizeOfObject.Height - 4;  	break;  default:  	x = 4;  	y = 4;  	break;  }  
Magic Number,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,OverlayObjectRect,The following statement contains a magic number: switch (alignment) {  case System.Drawing.ContentAlignment.TopLeft:  	x = 4;  	y = 4;  	break;  case System.Drawing.ContentAlignment.TopCenter:  	x = (container.Width - sizeOfObject.Width) / 2;  	y = 4;  	break;  case System.Drawing.ContentAlignment.TopRight:  	x = container.Width - sizeOfObject.Width - 4;  	y = 4;  	break;  case System.Drawing.ContentAlignment.MiddleLeft:  	x = 4;  	y = (container.Height - sizeOfObject.Height) / 2;  	break;  case System.Drawing.ContentAlignment.MiddleCenter:  	x = (container.Width - sizeOfObject.Width) / 2;  	y = (container.Height - sizeOfObject.Height) / 2;  	break;  case System.Drawing.ContentAlignment.MiddleRight:  	x = container.Width - sizeOfObject.Width - 4;  	y = (container.Height - sizeOfObject.Height) / 2;  	break;  case System.Drawing.ContentAlignment.BottomLeft:  	x = 4;  	y = container.Height - sizeOfObject.Height - 4;  	break;  case System.Drawing.ContentAlignment.BottomCenter:  	x = (container.Width - sizeOfObject.Width) / 2;  	y = container.Height - sizeOfObject.Height - 4;  	break;  case System.Drawing.ContentAlignment.BottomRight:  	x = container.Width - sizeOfObject.Width - 4;  	y = container.Height - sizeOfObject.Height - 4;  	break;  default:  	x = 4;  	y = 4;  	break;  }  
Magic Number,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,OverlayObjectRect,The following statement contains a magic number: switch (alignment) {  case System.Drawing.ContentAlignment.TopLeft:  	x = 4;  	y = 4;  	break;  case System.Drawing.ContentAlignment.TopCenter:  	x = (container.Width - sizeOfObject.Width) / 2;  	y = 4;  	break;  case System.Drawing.ContentAlignment.TopRight:  	x = container.Width - sizeOfObject.Width - 4;  	y = 4;  	break;  case System.Drawing.ContentAlignment.MiddleLeft:  	x = 4;  	y = (container.Height - sizeOfObject.Height) / 2;  	break;  case System.Drawing.ContentAlignment.MiddleCenter:  	x = (container.Width - sizeOfObject.Width) / 2;  	y = (container.Height - sizeOfObject.Height) / 2;  	break;  case System.Drawing.ContentAlignment.MiddleRight:  	x = container.Width - sizeOfObject.Width - 4;  	y = (container.Height - sizeOfObject.Height) / 2;  	break;  case System.Drawing.ContentAlignment.BottomLeft:  	x = 4;  	y = container.Height - sizeOfObject.Height - 4;  	break;  case System.Drawing.ContentAlignment.BottomCenter:  	x = (container.Width - sizeOfObject.Width) / 2;  	y = container.Height - sizeOfObject.Height - 4;  	break;  case System.Drawing.ContentAlignment.BottomRight:  	x = container.Width - sizeOfObject.Width - 4;  	y = container.Height - sizeOfObject.Height - 4;  	break;  default:  	x = 4;  	y = 4;  	break;  }  
Magic Number,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,OverlayObjectRect,The following statement contains a magic number: switch (alignment) {  case System.Drawing.ContentAlignment.TopLeft:  	x = 4;  	y = 4;  	break;  case System.Drawing.ContentAlignment.TopCenter:  	x = (container.Width - sizeOfObject.Width) / 2;  	y = 4;  	break;  case System.Drawing.ContentAlignment.TopRight:  	x = container.Width - sizeOfObject.Width - 4;  	y = 4;  	break;  case System.Drawing.ContentAlignment.MiddleLeft:  	x = 4;  	y = (container.Height - sizeOfObject.Height) / 2;  	break;  case System.Drawing.ContentAlignment.MiddleCenter:  	x = (container.Width - sizeOfObject.Width) / 2;  	y = (container.Height - sizeOfObject.Height) / 2;  	break;  case System.Drawing.ContentAlignment.MiddleRight:  	x = container.Width - sizeOfObject.Width - 4;  	y = (container.Height - sizeOfObject.Height) / 2;  	break;  case System.Drawing.ContentAlignment.BottomLeft:  	x = 4;  	y = container.Height - sizeOfObject.Height - 4;  	break;  case System.Drawing.ContentAlignment.BottomCenter:  	x = (container.Width - sizeOfObject.Width) / 2;  	y = container.Height - sizeOfObject.Height - 4;  	break;  case System.Drawing.ContentAlignment.BottomRight:  	x = container.Width - sizeOfObject.Width - 4;  	y = container.Height - sizeOfObject.Height - 4;  	break;  default:  	x = 4;  	y = 4;  	break;  }  
Magic Number,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,OverlayObjectRect,The following statement contains a magic number: switch (alignment) {  case System.Drawing.ContentAlignment.TopLeft:  	x = 4;  	y = 4;  	break;  case System.Drawing.ContentAlignment.TopCenter:  	x = (container.Width - sizeOfObject.Width) / 2;  	y = 4;  	break;  case System.Drawing.ContentAlignment.TopRight:  	x = container.Width - sizeOfObject.Width - 4;  	y = 4;  	break;  case System.Drawing.ContentAlignment.MiddleLeft:  	x = 4;  	y = (container.Height - sizeOfObject.Height) / 2;  	break;  case System.Drawing.ContentAlignment.MiddleCenter:  	x = (container.Width - sizeOfObject.Width) / 2;  	y = (container.Height - sizeOfObject.Height) / 2;  	break;  case System.Drawing.ContentAlignment.MiddleRight:  	x = container.Width - sizeOfObject.Width - 4;  	y = (container.Height - sizeOfObject.Height) / 2;  	break;  case System.Drawing.ContentAlignment.BottomLeft:  	x = 4;  	y = container.Height - sizeOfObject.Height - 4;  	break;  case System.Drawing.ContentAlignment.BottomCenter:  	x = (container.Width - sizeOfObject.Width) / 2;  	y = container.Height - sizeOfObject.Height - 4;  	break;  case System.Drawing.ContentAlignment.BottomRight:  	x = container.Width - sizeOfObject.Width - 4;  	y = container.Height - sizeOfObject.Height - 4;  	break;  default:  	x = 4;  	y = 4;  	break;  }  
Magic Number,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,OverlayObjectRect,The following statement contains a magic number: switch (alignment) {  case System.Drawing.ContentAlignment.TopLeft:  	x = 4;  	y = 4;  	break;  case System.Drawing.ContentAlignment.TopCenter:  	x = (container.Width - sizeOfObject.Width) / 2;  	y = 4;  	break;  case System.Drawing.ContentAlignment.TopRight:  	x = container.Width - sizeOfObject.Width - 4;  	y = 4;  	break;  case System.Drawing.ContentAlignment.MiddleLeft:  	x = 4;  	y = (container.Height - sizeOfObject.Height) / 2;  	break;  case System.Drawing.ContentAlignment.MiddleCenter:  	x = (container.Width - sizeOfObject.Width) / 2;  	y = (container.Height - sizeOfObject.Height) / 2;  	break;  case System.Drawing.ContentAlignment.MiddleRight:  	x = container.Width - sizeOfObject.Width - 4;  	y = (container.Height - sizeOfObject.Height) / 2;  	break;  case System.Drawing.ContentAlignment.BottomLeft:  	x = 4;  	y = container.Height - sizeOfObject.Height - 4;  	break;  case System.Drawing.ContentAlignment.BottomCenter:  	x = (container.Width - sizeOfObject.Width) / 2;  	y = container.Height - sizeOfObject.Height - 4;  	break;  case System.Drawing.ContentAlignment.BottomRight:  	x = container.Width - sizeOfObject.Width - 4;  	y = container.Height - sizeOfObject.Height - 4;  	break;  default:  	x = 4;  	y = 4;  	break;  }  
Magic Number,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,OverlayObjectRect,The following statement contains a magic number: switch (alignment) {  case System.Drawing.ContentAlignment.TopLeft:  	x = 4;  	y = 4;  	break;  case System.Drawing.ContentAlignment.TopCenter:  	x = (container.Width - sizeOfObject.Width) / 2;  	y = 4;  	break;  case System.Drawing.ContentAlignment.TopRight:  	x = container.Width - sizeOfObject.Width - 4;  	y = 4;  	break;  case System.Drawing.ContentAlignment.MiddleLeft:  	x = 4;  	y = (container.Height - sizeOfObject.Height) / 2;  	break;  case System.Drawing.ContentAlignment.MiddleCenter:  	x = (container.Width - sizeOfObject.Width) / 2;  	y = (container.Height - sizeOfObject.Height) / 2;  	break;  case System.Drawing.ContentAlignment.MiddleRight:  	x = container.Width - sizeOfObject.Width - 4;  	y = (container.Height - sizeOfObject.Height) / 2;  	break;  case System.Drawing.ContentAlignment.BottomLeft:  	x = 4;  	y = container.Height - sizeOfObject.Height - 4;  	break;  case System.Drawing.ContentAlignment.BottomCenter:  	x = (container.Width - sizeOfObject.Width) / 2;  	y = container.Height - sizeOfObject.Height - 4;  	break;  case System.Drawing.ContentAlignment.BottomRight:  	x = container.Width - sizeOfObject.Width - 4;  	y = container.Height - sizeOfObject.Height - 4;  	break;  default:  	x = 4;  	y = 4;  	break;  }  
Magic Number,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,OverlayObjectRect,The following statement contains a magic number: switch (alignment) {  case System.Drawing.ContentAlignment.TopLeft:  	x = 4;  	y = 4;  	break;  case System.Drawing.ContentAlignment.TopCenter:  	x = (container.Width - sizeOfObject.Width) / 2;  	y = 4;  	break;  case System.Drawing.ContentAlignment.TopRight:  	x = container.Width - sizeOfObject.Width - 4;  	y = 4;  	break;  case System.Drawing.ContentAlignment.MiddleLeft:  	x = 4;  	y = (container.Height - sizeOfObject.Height) / 2;  	break;  case System.Drawing.ContentAlignment.MiddleCenter:  	x = (container.Width - sizeOfObject.Width) / 2;  	y = (container.Height - sizeOfObject.Height) / 2;  	break;  case System.Drawing.ContentAlignment.MiddleRight:  	x = container.Width - sizeOfObject.Width - 4;  	y = (container.Height - sizeOfObject.Height) / 2;  	break;  case System.Drawing.ContentAlignment.BottomLeft:  	x = 4;  	y = container.Height - sizeOfObject.Height - 4;  	break;  case System.Drawing.ContentAlignment.BottomCenter:  	x = (container.Width - sizeOfObject.Width) / 2;  	y = container.Height - sizeOfObject.Height - 4;  	break;  case System.Drawing.ContentAlignment.BottomRight:  	x = container.Width - sizeOfObject.Width - 4;  	y = container.Height - sizeOfObject.Height - 4;  	break;  default:  	x = 4;  	y = 4;  	break;  }  
Magic Number,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,OverlayObjectRect,The following statement contains a magic number: switch (alignment) {  case System.Drawing.ContentAlignment.TopLeft:  	x = 4;  	y = 4;  	break;  case System.Drawing.ContentAlignment.TopCenter:  	x = (container.Width - sizeOfObject.Width) / 2;  	y = 4;  	break;  case System.Drawing.ContentAlignment.TopRight:  	x = container.Width - sizeOfObject.Width - 4;  	y = 4;  	break;  case System.Drawing.ContentAlignment.MiddleLeft:  	x = 4;  	y = (container.Height - sizeOfObject.Height) / 2;  	break;  case System.Drawing.ContentAlignment.MiddleCenter:  	x = (container.Width - sizeOfObject.Width) / 2;  	y = (container.Height - sizeOfObject.Height) / 2;  	break;  case System.Drawing.ContentAlignment.MiddleRight:  	x = container.Width - sizeOfObject.Width - 4;  	y = (container.Height - sizeOfObject.Height) / 2;  	break;  case System.Drawing.ContentAlignment.BottomLeft:  	x = 4;  	y = container.Height - sizeOfObject.Height - 4;  	break;  case System.Drawing.ContentAlignment.BottomCenter:  	x = (container.Width - sizeOfObject.Width) / 2;  	y = container.Height - sizeOfObject.Height - 4;  	break;  case System.Drawing.ContentAlignment.BottomRight:  	x = container.Width - sizeOfObject.Width - 4;  	y = container.Height - sizeOfObject.Height - 4;  	break;  default:  	x = 4;  	y = 4;  	break;  }  
Magic Number,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,OverlayObjectRect,The following statement contains a magic number: switch (alignment) {  case System.Drawing.ContentAlignment.TopLeft:  	x = 4;  	y = 4;  	break;  case System.Drawing.ContentAlignment.TopCenter:  	x = (container.Width - sizeOfObject.Width) / 2;  	y = 4;  	break;  case System.Drawing.ContentAlignment.TopRight:  	x = container.Width - sizeOfObject.Width - 4;  	y = 4;  	break;  case System.Drawing.ContentAlignment.MiddleLeft:  	x = 4;  	y = (container.Height - sizeOfObject.Height) / 2;  	break;  case System.Drawing.ContentAlignment.MiddleCenter:  	x = (container.Width - sizeOfObject.Width) / 2;  	y = (container.Height - sizeOfObject.Height) / 2;  	break;  case System.Drawing.ContentAlignment.MiddleRight:  	x = container.Width - sizeOfObject.Width - 4;  	y = (container.Height - sizeOfObject.Height) / 2;  	break;  case System.Drawing.ContentAlignment.BottomLeft:  	x = 4;  	y = container.Height - sizeOfObject.Height - 4;  	break;  case System.Drawing.ContentAlignment.BottomCenter:  	x = (container.Width - sizeOfObject.Width) / 2;  	y = container.Height - sizeOfObject.Height - 4;  	break;  case System.Drawing.ContentAlignment.BottomRight:  	x = container.Width - sizeOfObject.Width - 4;  	y = container.Height - sizeOfObject.Height - 4;  	break;  default:  	x = 4;  	y = 4;  	break;  }  
Magic Number,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,OverlayObjectRect,The following statement contains a magic number: switch (alignment) {  case System.Drawing.ContentAlignment.TopLeft:  	x = 4;  	y = 4;  	break;  case System.Drawing.ContentAlignment.TopCenter:  	x = (container.Width - sizeOfObject.Width) / 2;  	y = 4;  	break;  case System.Drawing.ContentAlignment.TopRight:  	x = container.Width - sizeOfObject.Width - 4;  	y = 4;  	break;  case System.Drawing.ContentAlignment.MiddleLeft:  	x = 4;  	y = (container.Height - sizeOfObject.Height) / 2;  	break;  case System.Drawing.ContentAlignment.MiddleCenter:  	x = (container.Width - sizeOfObject.Width) / 2;  	y = (container.Height - sizeOfObject.Height) / 2;  	break;  case System.Drawing.ContentAlignment.MiddleRight:  	x = container.Width - sizeOfObject.Width - 4;  	y = (container.Height - sizeOfObject.Height) / 2;  	break;  case System.Drawing.ContentAlignment.BottomLeft:  	x = 4;  	y = container.Height - sizeOfObject.Height - 4;  	break;  case System.Drawing.ContentAlignment.BottomCenter:  	x = (container.Width - sizeOfObject.Width) / 2;  	y = container.Height - sizeOfObject.Height - 4;  	break;  case System.Drawing.ContentAlignment.BottomRight:  	x = container.Width - sizeOfObject.Width - 4;  	y = container.Height - sizeOfObject.Height - 4;  	break;  default:  	x = 4;  	y = 4;  	break;  }  
Magic Number,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,OverlayObjectRect,The following statement contains a magic number: switch (alignment) {  case System.Drawing.ContentAlignment.TopLeft:  	x = 4;  	y = 4;  	break;  case System.Drawing.ContentAlignment.TopCenter:  	x = (container.Width - sizeOfObject.Width) / 2;  	y = 4;  	break;  case System.Drawing.ContentAlignment.TopRight:  	x = container.Width - sizeOfObject.Width - 4;  	y = 4;  	break;  case System.Drawing.ContentAlignment.MiddleLeft:  	x = 4;  	y = (container.Height - sizeOfObject.Height) / 2;  	break;  case System.Drawing.ContentAlignment.MiddleCenter:  	x = (container.Width - sizeOfObject.Width) / 2;  	y = (container.Height - sizeOfObject.Height) / 2;  	break;  case System.Drawing.ContentAlignment.MiddleRight:  	x = container.Width - sizeOfObject.Width - 4;  	y = (container.Height - sizeOfObject.Height) / 2;  	break;  case System.Drawing.ContentAlignment.BottomLeft:  	x = 4;  	y = container.Height - sizeOfObject.Height - 4;  	break;  case System.Drawing.ContentAlignment.BottomCenter:  	x = (container.Width - sizeOfObject.Width) / 2;  	y = container.Height - sizeOfObject.Height - 4;  	break;  case System.Drawing.ContentAlignment.BottomRight:  	x = container.Width - sizeOfObject.Width - 4;  	y = container.Height - sizeOfObject.Height - 4;  	break;  default:  	x = 4;  	y = 4;  	break;  }  
Magic Number,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,OverlayObjectRect,The following statement contains a magic number: switch (alignment) {  case System.Drawing.ContentAlignment.TopLeft:  	x = 4;  	y = 4;  	break;  case System.Drawing.ContentAlignment.TopCenter:  	x = (container.Width - sizeOfObject.Width) / 2;  	y = 4;  	break;  case System.Drawing.ContentAlignment.TopRight:  	x = container.Width - sizeOfObject.Width - 4;  	y = 4;  	break;  case System.Drawing.ContentAlignment.MiddleLeft:  	x = 4;  	y = (container.Height - sizeOfObject.Height) / 2;  	break;  case System.Drawing.ContentAlignment.MiddleCenter:  	x = (container.Width - sizeOfObject.Width) / 2;  	y = (container.Height - sizeOfObject.Height) / 2;  	break;  case System.Drawing.ContentAlignment.MiddleRight:  	x = container.Width - sizeOfObject.Width - 4;  	y = (container.Height - sizeOfObject.Height) / 2;  	break;  case System.Drawing.ContentAlignment.BottomLeft:  	x = 4;  	y = container.Height - sizeOfObject.Height - 4;  	break;  case System.Drawing.ContentAlignment.BottomCenter:  	x = (container.Width - sizeOfObject.Width) / 2;  	y = container.Height - sizeOfObject.Height - 4;  	break;  case System.Drawing.ContentAlignment.BottomRight:  	x = container.Width - sizeOfObject.Width - 4;  	y = container.Height - sizeOfObject.Height - 4;  	break;  default:  	x = 4;  	y = 4;  	break;  }  
Magic Number,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,OverlayObjectRect,The following statement contains a magic number: switch (alignment) {  case System.Drawing.ContentAlignment.TopLeft:  	x = 4;  	y = 4;  	break;  case System.Drawing.ContentAlignment.TopCenter:  	x = (container.Width - sizeOfObject.Width) / 2;  	y = 4;  	break;  case System.Drawing.ContentAlignment.TopRight:  	x = container.Width - sizeOfObject.Width - 4;  	y = 4;  	break;  case System.Drawing.ContentAlignment.MiddleLeft:  	x = 4;  	y = (container.Height - sizeOfObject.Height) / 2;  	break;  case System.Drawing.ContentAlignment.MiddleCenter:  	x = (container.Width - sizeOfObject.Width) / 2;  	y = (container.Height - sizeOfObject.Height) / 2;  	break;  case System.Drawing.ContentAlignment.MiddleRight:  	x = container.Width - sizeOfObject.Width - 4;  	y = (container.Height - sizeOfObject.Height) / 2;  	break;  case System.Drawing.ContentAlignment.BottomLeft:  	x = 4;  	y = container.Height - sizeOfObject.Height - 4;  	break;  case System.Drawing.ContentAlignment.BottomCenter:  	x = (container.Width - sizeOfObject.Width) / 2;  	y = container.Height - sizeOfObject.Height - 4;  	break;  case System.Drawing.ContentAlignment.BottomRight:  	x = container.Width - sizeOfObject.Width - 4;  	y = container.Height - sizeOfObject.Height - 4;  	break;  default:  	x = 4;  	y = 4;  	break;  }  
Magic Number,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,OverlayObjectRect,The following statement contains a magic number: switch (alignment) {  case System.Drawing.ContentAlignment.TopLeft:  	x = 4;  	y = 4;  	break;  case System.Drawing.ContentAlignment.TopCenter:  	x = (container.Width - sizeOfObject.Width) / 2;  	y = 4;  	break;  case System.Drawing.ContentAlignment.TopRight:  	x = container.Width - sizeOfObject.Width - 4;  	y = 4;  	break;  case System.Drawing.ContentAlignment.MiddleLeft:  	x = 4;  	y = (container.Height - sizeOfObject.Height) / 2;  	break;  case System.Drawing.ContentAlignment.MiddleCenter:  	x = (container.Width - sizeOfObject.Width) / 2;  	y = (container.Height - sizeOfObject.Height) / 2;  	break;  case System.Drawing.ContentAlignment.MiddleRight:  	x = container.Width - sizeOfObject.Width - 4;  	y = (container.Height - sizeOfObject.Height) / 2;  	break;  case System.Drawing.ContentAlignment.BottomLeft:  	x = 4;  	y = container.Height - sizeOfObject.Height - 4;  	break;  case System.Drawing.ContentAlignment.BottomCenter:  	x = (container.Width - sizeOfObject.Width) / 2;  	y = container.Height - sizeOfObject.Height - 4;  	break;  case System.Drawing.ContentAlignment.BottomRight:  	x = container.Width - sizeOfObject.Width - 4;  	y = container.Height - sizeOfObject.Height - 4;  	break;  default:  	x = 4;  	y = 4;  	break;  }  
Magic Number,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,OverlayObjectRect,The following statement contains a magic number: switch (alignment) {  case System.Drawing.ContentAlignment.TopLeft:  	x = 4;  	y = 4;  	break;  case System.Drawing.ContentAlignment.TopCenter:  	x = (container.Width - sizeOfObject.Width) / 2;  	y = 4;  	break;  case System.Drawing.ContentAlignment.TopRight:  	x = container.Width - sizeOfObject.Width - 4;  	y = 4;  	break;  case System.Drawing.ContentAlignment.MiddleLeft:  	x = 4;  	y = (container.Height - sizeOfObject.Height) / 2;  	break;  case System.Drawing.ContentAlignment.MiddleCenter:  	x = (container.Width - sizeOfObject.Width) / 2;  	y = (container.Height - sizeOfObject.Height) / 2;  	break;  case System.Drawing.ContentAlignment.MiddleRight:  	x = container.Width - sizeOfObject.Width - 4;  	y = (container.Height - sizeOfObject.Height) / 2;  	break;  case System.Drawing.ContentAlignment.BottomLeft:  	x = 4;  	y = container.Height - sizeOfObject.Height - 4;  	break;  case System.Drawing.ContentAlignment.BottomCenter:  	x = (container.Width - sizeOfObject.Width) / 2;  	y = container.Height - sizeOfObject.Height - 4;  	break;  case System.Drawing.ContentAlignment.BottomRight:  	x = container.Width - sizeOfObject.Width - 4;  	y = container.Height - sizeOfObject.Height - 4;  	break;  default:  	x = 4;  	y = 4;  	break;  }  
Magic Number,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,OverlayObjectRect,The following statement contains a magic number: x = 4;  
Magic Number,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,OverlayObjectRect,The following statement contains a magic number: y = 4;  
Magic Number,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,OverlayObjectRect,The following statement contains a magic number: x = (container.Width - sizeOfObject.Width) / 2;  
Magic Number,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,OverlayObjectRect,The following statement contains a magic number: y = 4;  
Magic Number,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,OverlayObjectRect,The following statement contains a magic number: x = container.Width - sizeOfObject.Width - 4;  
Magic Number,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,OverlayObjectRect,The following statement contains a magic number: y = 4;  
Magic Number,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,OverlayObjectRect,The following statement contains a magic number: x = 4;  
Magic Number,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,OverlayObjectRect,The following statement contains a magic number: y = (container.Height - sizeOfObject.Height) / 2;  
Magic Number,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,OverlayObjectRect,The following statement contains a magic number: x = (container.Width - sizeOfObject.Width) / 2;  
Magic Number,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,OverlayObjectRect,The following statement contains a magic number: y = (container.Height - sizeOfObject.Height) / 2;  
Magic Number,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,OverlayObjectRect,The following statement contains a magic number: x = container.Width - sizeOfObject.Width - 4;  
Magic Number,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,OverlayObjectRect,The following statement contains a magic number: y = (container.Height - sizeOfObject.Height) / 2;  
Magic Number,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,OverlayObjectRect,The following statement contains a magic number: x = 4;  
Magic Number,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,OverlayObjectRect,The following statement contains a magic number: y = container.Height - sizeOfObject.Height - 4;  
Magic Number,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,OverlayObjectRect,The following statement contains a magic number: x = (container.Width - sizeOfObject.Width) / 2;  
Magic Number,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,OverlayObjectRect,The following statement contains a magic number: y = container.Height - sizeOfObject.Height - 4;  
Magic Number,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,OverlayObjectRect,The following statement contains a magic number: x = container.Width - sizeOfObject.Width - 4;  
Magic Number,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,OverlayObjectRect,The following statement contains a magic number: y = container.Height - sizeOfObject.Height - 4;  
Magic Number,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,OverlayObjectRect,The following statement contains a magic number: x = 4;  
Magic Number,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,OverlayObjectRect,The following statement contains a magic number: y = 4;  
Magic Number,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,LayoutTextBeforeOrAfterImage,The following statement contains a magic number: if (!textFirst)  	element_spacing += 2;  
Magic Number,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,LayoutTextBeforeOrAfterImage,The following statement contains a magic number: element_spacing += 2;  
Magic Number,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,LayoutTextBeforeOrAfterImage,The following statement contains a magic number: if (h_image == HorizontalAlignment.Left)  	offset = 0;  else if (h_image == HorizontalAlignment.Right && h_text == HorizontalAlignment.Right)  	offset = excess_width;  else if (h_image == HorizontalAlignment.Center && (h_text == HorizontalAlignment.Left || h_text == HorizontalAlignment.Center))  	offset += (int)(excess_width / 3);  else  	offset += (int)(2 * (excess_width / 3));  
Magic Number,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,LayoutTextBeforeOrAfterImage,The following statement contains a magic number: if (h_image == HorizontalAlignment.Left)  	offset = 0;  else if (h_image == HorizontalAlignment.Right && h_text == HorizontalAlignment.Right)  	offset = excess_width;  else if (h_image == HorizontalAlignment.Center && (h_text == HorizontalAlignment.Left || h_text == HorizontalAlignment.Center))  	offset += (int)(excess_width / 3);  else  	offset += (int)(2 * (excess_width / 3));  
Magic Number,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,LayoutTextBeforeOrAfterImage,The following statement contains a magic number: if (h_image == HorizontalAlignment.Left)  	offset = 0;  else if (h_image == HorizontalAlignment.Right && h_text == HorizontalAlignment.Right)  	offset = excess_width;  else if (h_image == HorizontalAlignment.Center && (h_text == HorizontalAlignment.Left || h_text == HorizontalAlignment.Center))  	offset += (int)(excess_width / 3);  else  	offset += (int)(2 * (excess_width / 3));  
Magic Number,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,LayoutTextBeforeOrAfterImage,The following statement contains a magic number: if (h_image == HorizontalAlignment.Right && h_text == HorizontalAlignment.Right)  	offset = excess_width;  else if (h_image == HorizontalAlignment.Center && (h_text == HorizontalAlignment.Left || h_text == HorizontalAlignment.Center))  	offset += (int)(excess_width / 3);  else  	offset += (int)(2 * (excess_width / 3));  
Magic Number,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,LayoutTextBeforeOrAfterImage,The following statement contains a magic number: if (h_image == HorizontalAlignment.Right && h_text == HorizontalAlignment.Right)  	offset = excess_width;  else if (h_image == HorizontalAlignment.Center && (h_text == HorizontalAlignment.Left || h_text == HorizontalAlignment.Center))  	offset += (int)(excess_width / 3);  else  	offset += (int)(2 * (excess_width / 3));  
Magic Number,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,LayoutTextBeforeOrAfterImage,The following statement contains a magic number: if (h_image == HorizontalAlignment.Right && h_text == HorizontalAlignment.Right)  	offset = excess_width;  else if (h_image == HorizontalAlignment.Center && (h_text == HorizontalAlignment.Left || h_text == HorizontalAlignment.Center))  	offset += (int)(excess_width / 3);  else  	offset += (int)(2 * (excess_width / 3));  
Magic Number,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,LayoutTextBeforeOrAfterImage,The following statement contains a magic number: if (h_image == HorizontalAlignment.Center && (h_text == HorizontalAlignment.Left || h_text == HorizontalAlignment.Center))  	offset += (int)(excess_width / 3);  else  	offset += (int)(2 * (excess_width / 3));  
Magic Number,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,LayoutTextBeforeOrAfterImage,The following statement contains a magic number: if (h_image == HorizontalAlignment.Center && (h_text == HorizontalAlignment.Left || h_text == HorizontalAlignment.Center))  	offset += (int)(excess_width / 3);  else  	offset += (int)(2 * (excess_width / 3));  
Magic Number,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,LayoutTextBeforeOrAfterImage,The following statement contains a magic number: if (h_image == HorizontalAlignment.Center && (h_text == HorizontalAlignment.Left || h_text == HorizontalAlignment.Center))  	offset += (int)(excess_width / 3);  else  	offset += (int)(2 * (excess_width / 3));  
Magic Number,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,LayoutTextBeforeOrAfterImage,The following statement contains a magic number: offset += (int)(excess_width / 3);  
Magic Number,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,LayoutTextBeforeOrAfterImage,The following statement contains a magic number: offset += (int)(2 * (excess_width / 3));  
Magic Number,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,LayoutTextBeforeOrAfterImage,The following statement contains a magic number: offset += (int)(2 * (excess_width / 3));  
Magic Number,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,LayoutTextAboveOrBelowImage,The following statement contains a magic number: if (textFirst)  	element_spacing += 2;  
Magic Number,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,LayoutTextAboveOrBelowImage,The following statement contains a magic number: element_spacing += 2;  
Magic Number,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,LayoutTextAboveOrBelowImage,The following statement contains a magic number: if (v_image == VerticalAlignment.Top)  	offset = 0;  else if (v_image == VerticalAlignment.Bottom && v_text == VerticalAlignment.Bottom)  	offset = excess_height;  else if (v_image == VerticalAlignment.Center && (v_text == VerticalAlignment.Top || v_text == VerticalAlignment.Center))  	offset += (int)(excess_height / 3);  else  	offset += (int)(2 * (excess_height / 3));  
Magic Number,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,LayoutTextAboveOrBelowImage,The following statement contains a magic number: if (v_image == VerticalAlignment.Top)  	offset = 0;  else if (v_image == VerticalAlignment.Bottom && v_text == VerticalAlignment.Bottom)  	offset = excess_height;  else if (v_image == VerticalAlignment.Center && (v_text == VerticalAlignment.Top || v_text == VerticalAlignment.Center))  	offset += (int)(excess_height / 3);  else  	offset += (int)(2 * (excess_height / 3));  
Magic Number,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,LayoutTextAboveOrBelowImage,The following statement contains a magic number: if (v_image == VerticalAlignment.Top)  	offset = 0;  else if (v_image == VerticalAlignment.Bottom && v_text == VerticalAlignment.Bottom)  	offset = excess_height;  else if (v_image == VerticalAlignment.Center && (v_text == VerticalAlignment.Top || v_text == VerticalAlignment.Center))  	offset += (int)(excess_height / 3);  else  	offset += (int)(2 * (excess_height / 3));  
Magic Number,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,LayoutTextAboveOrBelowImage,The following statement contains a magic number: if (v_image == VerticalAlignment.Bottom && v_text == VerticalAlignment.Bottom)  	offset = excess_height;  else if (v_image == VerticalAlignment.Center && (v_text == VerticalAlignment.Top || v_text == VerticalAlignment.Center))  	offset += (int)(excess_height / 3);  else  	offset += (int)(2 * (excess_height / 3));  
Magic Number,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,LayoutTextAboveOrBelowImage,The following statement contains a magic number: if (v_image == VerticalAlignment.Bottom && v_text == VerticalAlignment.Bottom)  	offset = excess_height;  else if (v_image == VerticalAlignment.Center && (v_text == VerticalAlignment.Top || v_text == VerticalAlignment.Center))  	offset += (int)(excess_height / 3);  else  	offset += (int)(2 * (excess_height / 3));  
Magic Number,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,LayoutTextAboveOrBelowImage,The following statement contains a magic number: if (v_image == VerticalAlignment.Bottom && v_text == VerticalAlignment.Bottom)  	offset = excess_height;  else if (v_image == VerticalAlignment.Center && (v_text == VerticalAlignment.Top || v_text == VerticalAlignment.Center))  	offset += (int)(excess_height / 3);  else  	offset += (int)(2 * (excess_height / 3));  
Magic Number,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,LayoutTextAboveOrBelowImage,The following statement contains a magic number: if (v_image == VerticalAlignment.Center && (v_text == VerticalAlignment.Top || v_text == VerticalAlignment.Center))  	offset += (int)(excess_height / 3);  else  	offset += (int)(2 * (excess_height / 3));  
Magic Number,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,LayoutTextAboveOrBelowImage,The following statement contains a magic number: if (v_image == VerticalAlignment.Center && (v_text == VerticalAlignment.Top || v_text == VerticalAlignment.Center))  	offset += (int)(excess_height / 3);  else  	offset += (int)(2 * (excess_height / 3));  
Magic Number,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,LayoutTextAboveOrBelowImage,The following statement contains a magic number: if (v_image == VerticalAlignment.Center && (v_text == VerticalAlignment.Top || v_text == VerticalAlignment.Center))  	offset += (int)(excess_height / 3);  else  	offset += (int)(2 * (excess_height / 3));  
Magic Number,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,LayoutTextAboveOrBelowImage,The following statement contains a magic number: offset += (int)(excess_height / 3);  
Magic Number,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,LayoutTextAboveOrBelowImage,The following statement contains a magic number: offset += (int)(2 * (excess_height / 3));  
Magic Number,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,LayoutTextAboveOrBelowImage,The following statement contains a magic number: offset += (int)(2 * (excess_height / 3));  
Magic Number,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,AlignInRectangle,The following statement contains a magic number: if (align == System.Drawing.ContentAlignment.BottomLeft || align == System.Drawing.ContentAlignment.MiddleLeft || align == System.Drawing.ContentAlignment.TopLeft)  	x = outer.X;  else if (align == System.Drawing.ContentAlignment.BottomCenter || align == System.Drawing.ContentAlignment.MiddleCenter || align == System.Drawing.ContentAlignment.TopCenter)  	x = Math.Max (outer.X + ((outer.Width - inner.Width) / 2)' outer.Left);  else if (align == System.Drawing.ContentAlignment.BottomRight || align == System.Drawing.ContentAlignment.MiddleRight || align == System.Drawing.ContentAlignment.TopRight)  	x = outer.Right - inner.Width;  
Magic Number,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,AlignInRectangle,The following statement contains a magic number: if (align == System.Drawing.ContentAlignment.BottomCenter || align == System.Drawing.ContentAlignment.MiddleCenter || align == System.Drawing.ContentAlignment.TopCenter)  	x = Math.Max (outer.X + ((outer.Width - inner.Width) / 2)' outer.Left);  else if (align == System.Drawing.ContentAlignment.BottomRight || align == System.Drawing.ContentAlignment.MiddleRight || align == System.Drawing.ContentAlignment.TopRight)  	x = outer.Right - inner.Width;  
Magic Number,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,AlignInRectangle,The following statement contains a magic number: x = Math.Max (outer.X + ((outer.Width - inner.Width) / 2)' outer.Left);  
Magic Number,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,AlignInRectangle,The following statement contains a magic number: if (align == System.Drawing.ContentAlignment.TopCenter || align == System.Drawing.ContentAlignment.TopLeft || align == System.Drawing.ContentAlignment.TopRight)  	y = outer.Y;  else if (align == System.Drawing.ContentAlignment.MiddleCenter || align == System.Drawing.ContentAlignment.MiddleLeft || align == System.Drawing.ContentAlignment.MiddleRight)  	y = outer.Y + (outer.Height - inner.Height) / 2;  else if (align == System.Drawing.ContentAlignment.BottomCenter || align == System.Drawing.ContentAlignment.BottomRight || align == System.Drawing.ContentAlignment.BottomLeft)  	y = outer.Bottom - inner.Height;  
Magic Number,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,AlignInRectangle,The following statement contains a magic number: if (align == System.Drawing.ContentAlignment.MiddleCenter || align == System.Drawing.ContentAlignment.MiddleLeft || align == System.Drawing.ContentAlignment.MiddleRight)  	y = outer.Y + (outer.Height - inner.Height) / 2;  else if (align == System.Drawing.ContentAlignment.BottomCenter || align == System.Drawing.ContentAlignment.BottomRight || align == System.Drawing.ContentAlignment.BottomLeft)  	y = outer.Bottom - inner.Height;  
Magic Number,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,AlignInRectangle,The following statement contains a magic number: y = outer.Y + (outer.Height - inner.Height) / 2;  
Magic Number,ProcessHacker.Common,PhUtils,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Common\PhUtils.cs,IsDangerousPid,The following statement contains a magic number: if (pid == 4)  	return true;  
Magic Number,ProcessHacker.Common,PhUtils,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Common\PhUtils.cs,GetForeColor,The following statement contains a magic number: if (backColor.GetBrightness () > 0.4)  	return Color.Black;  else  	return Color.White;  
Magic Number,ProcessHacker.Common,PhUtils,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Common\PhUtils.cs,GetIntegrity,The following statement contains a magic number: for (int i = 0; i < groups.Length; i++) {  	if ((groups [i].Attributes & SidAttributes.IntegrityEnabled) != 0) {  		integrity = groups [i].GetFullName (false).Replace (" Mandatory Level"' "");  		if (integrity == "Untrusted")  			integrityLevel = 0;  		else if (integrity == "Low")  			integrityLevel = 1;  		else if (integrity == "Medium")  			integrityLevel = 2;  		else if (integrity == "High")  			integrityLevel = 3;  		else if (integrity == "System")  			integrityLevel = 4;  		else if (integrity == "Installer")  			integrityLevel = 5;  	}  	groups [i].Dispose ();  }  
Magic Number,ProcessHacker.Common,PhUtils,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Common\PhUtils.cs,GetIntegrity,The following statement contains a magic number: for (int i = 0; i < groups.Length; i++) {  	if ((groups [i].Attributes & SidAttributes.IntegrityEnabled) != 0) {  		integrity = groups [i].GetFullName (false).Replace (" Mandatory Level"' "");  		if (integrity == "Untrusted")  			integrityLevel = 0;  		else if (integrity == "Low")  			integrityLevel = 1;  		else if (integrity == "Medium")  			integrityLevel = 2;  		else if (integrity == "High")  			integrityLevel = 3;  		else if (integrity == "System")  			integrityLevel = 4;  		else if (integrity == "Installer")  			integrityLevel = 5;  	}  	groups [i].Dispose ();  }  
Magic Number,ProcessHacker.Common,PhUtils,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Common\PhUtils.cs,GetIntegrity,The following statement contains a magic number: for (int i = 0; i < groups.Length; i++) {  	if ((groups [i].Attributes & SidAttributes.IntegrityEnabled) != 0) {  		integrity = groups [i].GetFullName (false).Replace (" Mandatory Level"' "");  		if (integrity == "Untrusted")  			integrityLevel = 0;  		else if (integrity == "Low")  			integrityLevel = 1;  		else if (integrity == "Medium")  			integrityLevel = 2;  		else if (integrity == "High")  			integrityLevel = 3;  		else if (integrity == "System")  			integrityLevel = 4;  		else if (integrity == "Installer")  			integrityLevel = 5;  	}  	groups [i].Dispose ();  }  
Magic Number,ProcessHacker.Common,PhUtils,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Common\PhUtils.cs,GetIntegrity,The following statement contains a magic number: for (int i = 0; i < groups.Length; i++) {  	if ((groups [i].Attributes & SidAttributes.IntegrityEnabled) != 0) {  		integrity = groups [i].GetFullName (false).Replace (" Mandatory Level"' "");  		if (integrity == "Untrusted")  			integrityLevel = 0;  		else if (integrity == "Low")  			integrityLevel = 1;  		else if (integrity == "Medium")  			integrityLevel = 2;  		else if (integrity == "High")  			integrityLevel = 3;  		else if (integrity == "System")  			integrityLevel = 4;  		else if (integrity == "Installer")  			integrityLevel = 5;  	}  	groups [i].Dispose ();  }  
Magic Number,ProcessHacker.Common,PhUtils,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Common\PhUtils.cs,GetIntegrity,The following statement contains a magic number: if ((groups [i].Attributes & SidAttributes.IntegrityEnabled) != 0) {  	integrity = groups [i].GetFullName (false).Replace (" Mandatory Level"' "");  	if (integrity == "Untrusted")  		integrityLevel = 0;  	else if (integrity == "Low")  		integrityLevel = 1;  	else if (integrity == "Medium")  		integrityLevel = 2;  	else if (integrity == "High")  		integrityLevel = 3;  	else if (integrity == "System")  		integrityLevel = 4;  	else if (integrity == "Installer")  		integrityLevel = 5;  }  
Magic Number,ProcessHacker.Common,PhUtils,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Common\PhUtils.cs,GetIntegrity,The following statement contains a magic number: if ((groups [i].Attributes & SidAttributes.IntegrityEnabled) != 0) {  	integrity = groups [i].GetFullName (false).Replace (" Mandatory Level"' "");  	if (integrity == "Untrusted")  		integrityLevel = 0;  	else if (integrity == "Low")  		integrityLevel = 1;  	else if (integrity == "Medium")  		integrityLevel = 2;  	else if (integrity == "High")  		integrityLevel = 3;  	else if (integrity == "System")  		integrityLevel = 4;  	else if (integrity == "Installer")  		integrityLevel = 5;  }  
Magic Number,ProcessHacker.Common,PhUtils,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Common\PhUtils.cs,GetIntegrity,The following statement contains a magic number: if ((groups [i].Attributes & SidAttributes.IntegrityEnabled) != 0) {  	integrity = groups [i].GetFullName (false).Replace (" Mandatory Level"' "");  	if (integrity == "Untrusted")  		integrityLevel = 0;  	else if (integrity == "Low")  		integrityLevel = 1;  	else if (integrity == "Medium")  		integrityLevel = 2;  	else if (integrity == "High")  		integrityLevel = 3;  	else if (integrity == "System")  		integrityLevel = 4;  	else if (integrity == "Installer")  		integrityLevel = 5;  }  
Magic Number,ProcessHacker.Common,PhUtils,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Common\PhUtils.cs,GetIntegrity,The following statement contains a magic number: if ((groups [i].Attributes & SidAttributes.IntegrityEnabled) != 0) {  	integrity = groups [i].GetFullName (false).Replace (" Mandatory Level"' "");  	if (integrity == "Untrusted")  		integrityLevel = 0;  	else if (integrity == "Low")  		integrityLevel = 1;  	else if (integrity == "Medium")  		integrityLevel = 2;  	else if (integrity == "High")  		integrityLevel = 3;  	else if (integrity == "System")  		integrityLevel = 4;  	else if (integrity == "Installer")  		integrityLevel = 5;  }  
Magic Number,ProcessHacker.Common,PhUtils,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Common\PhUtils.cs,GetIntegrity,The following statement contains a magic number: if (integrity == "Untrusted")  	integrityLevel = 0;  else if (integrity == "Low")  	integrityLevel = 1;  else if (integrity == "Medium")  	integrityLevel = 2;  else if (integrity == "High")  	integrityLevel = 3;  else if (integrity == "System")  	integrityLevel = 4;  else if (integrity == "Installer")  	integrityLevel = 5;  
Magic Number,ProcessHacker.Common,PhUtils,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Common\PhUtils.cs,GetIntegrity,The following statement contains a magic number: if (integrity == "Untrusted")  	integrityLevel = 0;  else if (integrity == "Low")  	integrityLevel = 1;  else if (integrity == "Medium")  	integrityLevel = 2;  else if (integrity == "High")  	integrityLevel = 3;  else if (integrity == "System")  	integrityLevel = 4;  else if (integrity == "Installer")  	integrityLevel = 5;  
Magic Number,ProcessHacker.Common,PhUtils,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Common\PhUtils.cs,GetIntegrity,The following statement contains a magic number: if (integrity == "Untrusted")  	integrityLevel = 0;  else if (integrity == "Low")  	integrityLevel = 1;  else if (integrity == "Medium")  	integrityLevel = 2;  else if (integrity == "High")  	integrityLevel = 3;  else if (integrity == "System")  	integrityLevel = 4;  else if (integrity == "Installer")  	integrityLevel = 5;  
Magic Number,ProcessHacker.Common,PhUtils,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Common\PhUtils.cs,GetIntegrity,The following statement contains a magic number: if (integrity == "Untrusted")  	integrityLevel = 0;  else if (integrity == "Low")  	integrityLevel = 1;  else if (integrity == "Medium")  	integrityLevel = 2;  else if (integrity == "High")  	integrityLevel = 3;  else if (integrity == "System")  	integrityLevel = 4;  else if (integrity == "Installer")  	integrityLevel = 5;  
Magic Number,ProcessHacker.Common,PhUtils,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Common\PhUtils.cs,GetIntegrity,The following statement contains a magic number: if (integrity == "Low")  	integrityLevel = 1;  else if (integrity == "Medium")  	integrityLevel = 2;  else if (integrity == "High")  	integrityLevel = 3;  else if (integrity == "System")  	integrityLevel = 4;  else if (integrity == "Installer")  	integrityLevel = 5;  
Magic Number,ProcessHacker.Common,PhUtils,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Common\PhUtils.cs,GetIntegrity,The following statement contains a magic number: if (integrity == "Low")  	integrityLevel = 1;  else if (integrity == "Medium")  	integrityLevel = 2;  else if (integrity == "High")  	integrityLevel = 3;  else if (integrity == "System")  	integrityLevel = 4;  else if (integrity == "Installer")  	integrityLevel = 5;  
Magic Number,ProcessHacker.Common,PhUtils,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Common\PhUtils.cs,GetIntegrity,The following statement contains a magic number: if (integrity == "Low")  	integrityLevel = 1;  else if (integrity == "Medium")  	integrityLevel = 2;  else if (integrity == "High")  	integrityLevel = 3;  else if (integrity == "System")  	integrityLevel = 4;  else if (integrity == "Installer")  	integrityLevel = 5;  
Magic Number,ProcessHacker.Common,PhUtils,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Common\PhUtils.cs,GetIntegrity,The following statement contains a magic number: if (integrity == "Low")  	integrityLevel = 1;  else if (integrity == "Medium")  	integrityLevel = 2;  else if (integrity == "High")  	integrityLevel = 3;  else if (integrity == "System")  	integrityLevel = 4;  else if (integrity == "Installer")  	integrityLevel = 5;  
Magic Number,ProcessHacker.Common,PhUtils,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Common\PhUtils.cs,GetIntegrity,The following statement contains a magic number: if (integrity == "Medium")  	integrityLevel = 2;  else if (integrity == "High")  	integrityLevel = 3;  else if (integrity == "System")  	integrityLevel = 4;  else if (integrity == "Installer")  	integrityLevel = 5;  
Magic Number,ProcessHacker.Common,PhUtils,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Common\PhUtils.cs,GetIntegrity,The following statement contains a magic number: if (integrity == "Medium")  	integrityLevel = 2;  else if (integrity == "High")  	integrityLevel = 3;  else if (integrity == "System")  	integrityLevel = 4;  else if (integrity == "Installer")  	integrityLevel = 5;  
Magic Number,ProcessHacker.Common,PhUtils,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Common\PhUtils.cs,GetIntegrity,The following statement contains a magic number: if (integrity == "Medium")  	integrityLevel = 2;  else if (integrity == "High")  	integrityLevel = 3;  else if (integrity == "System")  	integrityLevel = 4;  else if (integrity == "Installer")  	integrityLevel = 5;  
Magic Number,ProcessHacker.Common,PhUtils,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Common\PhUtils.cs,GetIntegrity,The following statement contains a magic number: if (integrity == "Medium")  	integrityLevel = 2;  else if (integrity == "High")  	integrityLevel = 3;  else if (integrity == "System")  	integrityLevel = 4;  else if (integrity == "Installer")  	integrityLevel = 5;  
Magic Number,ProcessHacker.Common,PhUtils,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Common\PhUtils.cs,GetIntegrity,The following statement contains a magic number: integrityLevel = 2;  
Magic Number,ProcessHacker.Common,PhUtils,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Common\PhUtils.cs,GetIntegrity,The following statement contains a magic number: if (integrity == "High")  	integrityLevel = 3;  else if (integrity == "System")  	integrityLevel = 4;  else if (integrity == "Installer")  	integrityLevel = 5;  
Magic Number,ProcessHacker.Common,PhUtils,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Common\PhUtils.cs,GetIntegrity,The following statement contains a magic number: if (integrity == "High")  	integrityLevel = 3;  else if (integrity == "System")  	integrityLevel = 4;  else if (integrity == "Installer")  	integrityLevel = 5;  
Magic Number,ProcessHacker.Common,PhUtils,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Common\PhUtils.cs,GetIntegrity,The following statement contains a magic number: if (integrity == "High")  	integrityLevel = 3;  else if (integrity == "System")  	integrityLevel = 4;  else if (integrity == "Installer")  	integrityLevel = 5;  
Magic Number,ProcessHacker.Common,PhUtils,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Common\PhUtils.cs,GetIntegrity,The following statement contains a magic number: integrityLevel = 3;  
Magic Number,ProcessHacker.Common,PhUtils,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Common\PhUtils.cs,GetIntegrity,The following statement contains a magic number: if (integrity == "System")  	integrityLevel = 4;  else if (integrity == "Installer")  	integrityLevel = 5;  
Magic Number,ProcessHacker.Common,PhUtils,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Common\PhUtils.cs,GetIntegrity,The following statement contains a magic number: if (integrity == "System")  	integrityLevel = 4;  else if (integrity == "Installer")  	integrityLevel = 5;  
Magic Number,ProcessHacker.Common,PhUtils,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Common\PhUtils.cs,GetIntegrity,The following statement contains a magic number: integrityLevel = 4;  
Magic Number,ProcessHacker.Common,PhUtils,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Common\PhUtils.cs,GetIntegrity,The following statement contains a magic number: if (integrity == "Installer")  	integrityLevel = 5;  
Magic Number,ProcessHacker.Common,PhUtils,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Common\PhUtils.cs,GetIntegrity,The following statement contains a magic number: integrityLevel = 5;  
Magic Number,ProcessHacker.Common,PhUtils,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Common\PhUtils.cs,OpenKeyInRegedit,The following statement contains a magic number: if (lastKey.ToLowerInvariant ().StartsWith ("hkcu"))  	lastKey = "HKEY_CURRENT_USER" + lastKey.Substring (4);  else if (lastKey.ToLowerInvariant ().StartsWith ("hku"))  	lastKey = "HKEY_USERS" + lastKey.Substring (3);  else if (lastKey.ToLowerInvariant ().StartsWith ("hkcr"))  	lastKey = "HKEY_CLASSES_ROOT" + lastKey.Substring (4);  else if (lastKey.ToLowerInvariant ().StartsWith ("hklm"))  	lastKey = "HKEY_LOCAL_MACHINE" + lastKey.Substring (4);  
Magic Number,ProcessHacker.Common,PhUtils,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Common\PhUtils.cs,OpenKeyInRegedit,The following statement contains a magic number: if (lastKey.ToLowerInvariant ().StartsWith ("hkcu"))  	lastKey = "HKEY_CURRENT_USER" + lastKey.Substring (4);  else if (lastKey.ToLowerInvariant ().StartsWith ("hku"))  	lastKey = "HKEY_USERS" + lastKey.Substring (3);  else if (lastKey.ToLowerInvariant ().StartsWith ("hkcr"))  	lastKey = "HKEY_CLASSES_ROOT" + lastKey.Substring (4);  else if (lastKey.ToLowerInvariant ().StartsWith ("hklm"))  	lastKey = "HKEY_LOCAL_MACHINE" + lastKey.Substring (4);  
Magic Number,ProcessHacker.Common,PhUtils,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Common\PhUtils.cs,OpenKeyInRegedit,The following statement contains a magic number: if (lastKey.ToLowerInvariant ().StartsWith ("hkcu"))  	lastKey = "HKEY_CURRENT_USER" + lastKey.Substring (4);  else if (lastKey.ToLowerInvariant ().StartsWith ("hku"))  	lastKey = "HKEY_USERS" + lastKey.Substring (3);  else if (lastKey.ToLowerInvariant ().StartsWith ("hkcr"))  	lastKey = "HKEY_CLASSES_ROOT" + lastKey.Substring (4);  else if (lastKey.ToLowerInvariant ().StartsWith ("hklm"))  	lastKey = "HKEY_LOCAL_MACHINE" + lastKey.Substring (4);  
Magic Number,ProcessHacker.Common,PhUtils,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Common\PhUtils.cs,OpenKeyInRegedit,The following statement contains a magic number: if (lastKey.ToLowerInvariant ().StartsWith ("hkcu"))  	lastKey = "HKEY_CURRENT_USER" + lastKey.Substring (4);  else if (lastKey.ToLowerInvariant ().StartsWith ("hku"))  	lastKey = "HKEY_USERS" + lastKey.Substring (3);  else if (lastKey.ToLowerInvariant ().StartsWith ("hkcr"))  	lastKey = "HKEY_CLASSES_ROOT" + lastKey.Substring (4);  else if (lastKey.ToLowerInvariant ().StartsWith ("hklm"))  	lastKey = "HKEY_LOCAL_MACHINE" + lastKey.Substring (4);  
Magic Number,ProcessHacker.Common,PhUtils,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Common\PhUtils.cs,OpenKeyInRegedit,The following statement contains a magic number: lastKey = "HKEY_CURRENT_USER" + lastKey.Substring (4);  
Magic Number,ProcessHacker.Common,PhUtils,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Common\PhUtils.cs,OpenKeyInRegedit,The following statement contains a magic number: if (lastKey.ToLowerInvariant ().StartsWith ("hku"))  	lastKey = "HKEY_USERS" + lastKey.Substring (3);  else if (lastKey.ToLowerInvariant ().StartsWith ("hkcr"))  	lastKey = "HKEY_CLASSES_ROOT" + lastKey.Substring (4);  else if (lastKey.ToLowerInvariant ().StartsWith ("hklm"))  	lastKey = "HKEY_LOCAL_MACHINE" + lastKey.Substring (4);  
Magic Number,ProcessHacker.Common,PhUtils,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Common\PhUtils.cs,OpenKeyInRegedit,The following statement contains a magic number: if (lastKey.ToLowerInvariant ().StartsWith ("hku"))  	lastKey = "HKEY_USERS" + lastKey.Substring (3);  else if (lastKey.ToLowerInvariant ().StartsWith ("hkcr"))  	lastKey = "HKEY_CLASSES_ROOT" + lastKey.Substring (4);  else if (lastKey.ToLowerInvariant ().StartsWith ("hklm"))  	lastKey = "HKEY_LOCAL_MACHINE" + lastKey.Substring (4);  
Magic Number,ProcessHacker.Common,PhUtils,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Common\PhUtils.cs,OpenKeyInRegedit,The following statement contains a magic number: if (lastKey.ToLowerInvariant ().StartsWith ("hku"))  	lastKey = "HKEY_USERS" + lastKey.Substring (3);  else if (lastKey.ToLowerInvariant ().StartsWith ("hkcr"))  	lastKey = "HKEY_CLASSES_ROOT" + lastKey.Substring (4);  else if (lastKey.ToLowerInvariant ().StartsWith ("hklm"))  	lastKey = "HKEY_LOCAL_MACHINE" + lastKey.Substring (4);  
Magic Number,ProcessHacker.Common,PhUtils,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Common\PhUtils.cs,OpenKeyInRegedit,The following statement contains a magic number: lastKey = "HKEY_USERS" + lastKey.Substring (3);  
Magic Number,ProcessHacker.Common,PhUtils,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Common\PhUtils.cs,OpenKeyInRegedit,The following statement contains a magic number: if (lastKey.ToLowerInvariant ().StartsWith ("hkcr"))  	lastKey = "HKEY_CLASSES_ROOT" + lastKey.Substring (4);  else if (lastKey.ToLowerInvariant ().StartsWith ("hklm"))  	lastKey = "HKEY_LOCAL_MACHINE" + lastKey.Substring (4);  
Magic Number,ProcessHacker.Common,PhUtils,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Common\PhUtils.cs,OpenKeyInRegedit,The following statement contains a magic number: if (lastKey.ToLowerInvariant ().StartsWith ("hkcr"))  	lastKey = "HKEY_CLASSES_ROOT" + lastKey.Substring (4);  else if (lastKey.ToLowerInvariant ().StartsWith ("hklm"))  	lastKey = "HKEY_LOCAL_MACHINE" + lastKey.Substring (4);  
Magic Number,ProcessHacker.Common,PhUtils,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Common\PhUtils.cs,OpenKeyInRegedit,The following statement contains a magic number: lastKey = "HKEY_CLASSES_ROOT" + lastKey.Substring (4);  
Magic Number,ProcessHacker.Common,PhUtils,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Common\PhUtils.cs,OpenKeyInRegedit,The following statement contains a magic number: if (lastKey.ToLowerInvariant ().StartsWith ("hklm"))  	lastKey = "HKEY_LOCAL_MACHINE" + lastKey.Substring (4);  
Magic Number,ProcessHacker.Common,PhUtils,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Common\PhUtils.cs,OpenKeyInRegedit,The following statement contains a magic number: lastKey = "HKEY_LOCAL_MACHINE" + lastKey.Substring (4);  
Magic Number,ProcessHacker.Components,DotNetCounters,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\DotNetCounters.cs,InitialColumnAutoSize,The following statement contains a magic number: columnName.Width = (listValues.Width - 30) * 6 / 10;  
Magic Number,ProcessHacker.Components,DotNetCounters,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\DotNetCounters.cs,InitialColumnAutoSize,The following statement contains a magic number: columnName.Width = (listValues.Width - 30) * 6 / 10;  
Magic Number,ProcessHacker.Components,DotNetCounters,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\DotNetCounters.cs,InitialColumnAutoSize,The following statement contains a magic number: columnName.Width = (listValues.Width - 30) * 6 / 10;  
Magic Number,ProcessHacker.Components,DotNetCounters,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\DotNetCounters.cs,InitialColumnAutoSize,The following statement contains a magic number: columnValue.Width = (listValues.Width - 30) * 4 / 10;  
Magic Number,ProcessHacker.Components,DotNetCounters,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\DotNetCounters.cs,InitialColumnAutoSize,The following statement contains a magic number: columnValue.Width = (listValues.Width - 30) * 4 / 10;  
Magic Number,ProcessHacker.Components,DotNetCounters,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\DotNetCounters.cs,InitialColumnAutoSize,The following statement contains a magic number: columnValue.Width = (listValues.Width - 30) * 4 / 10;  
Magic Number,ProcessHacker.Components,MessageLabel,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\MessageLabel.cs,GetBitmap,The following statement contains a magic number: try {  	return Utils.ToBitmap (iconHandle' 16' 16);  }  finally {  	Win32.DestroyIcon (iconHandle);  }  
Magic Number,ProcessHacker.Components,MessageLabel,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\MessageLabel.cs,GetBitmap,The following statement contains a magic number: try {  	return Utils.ToBitmap (iconHandle' 16' 16);  }  finally {  	Win32.DestroyIcon (iconHandle);  }  
Magic Number,ProcessHacker.Components,MessageLabel,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\MessageLabel.cs,GetBitmap,The following statement contains a magic number: return Utils.ToBitmap (iconHandle' 16' 16);  
Magic Number,ProcessHacker.Components,MessageLabel,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\MessageLabel.cs,GetBitmap,The following statement contains a magic number: return Utils.ToBitmap (iconHandle' 16' 16);  
Magic Number,ProcessHacker.Components,Indicator,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\Indicator.cs,OnPaint,The following statement contains a magic number: num1 -= this.Font.Height + 4;  
Magic Number,ProcessHacker.Components,Indicator,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\Indicator.cs,OnPaint,The following statement contains a magic number: for (int i = 0; i < num3; i++) {  	x = num4;  	y = (num5 - (i * 3)) - 1;  	num7 = x + num6;  	num8 = y;  	if (i < num9) {  		e.Graphics.FillRectangle (brush1' x' y' num6' 2);  		e.Graphics.FillRectangle (brush1' num7 + 1' y' num6' 2);  	}  	else if (i < num10) {  		e.Graphics.FillRectangle (brush2' x' y' num6' 2);  		e.Graphics.FillRectangle (brush2' num7 + 1' y' num6' 2);  	}  	else {  		e.Graphics.DrawLine (pen' x' y' num7' num8);  		e.Graphics.DrawLine (pen' x + 1' y + 1' num7' num8 + 1);  		x = num7 + 1;  		num7 = x + num6;  		e.Graphics.DrawLine (pen' x' y' num7' num8);  		e.Graphics.DrawLine (pen' x + 1' y + 1' num7' num8 + 1);  	}  }  
Magic Number,ProcessHacker.Components,Indicator,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\Indicator.cs,OnPaint,The following statement contains a magic number: for (int i = 0; i < num3; i++) {  	x = num4;  	y = (num5 - (i * 3)) - 1;  	num7 = x + num6;  	num8 = y;  	if (i < num9) {  		e.Graphics.FillRectangle (brush1' x' y' num6' 2);  		e.Graphics.FillRectangle (brush1' num7 + 1' y' num6' 2);  	}  	else if (i < num10) {  		e.Graphics.FillRectangle (brush2' x' y' num6' 2);  		e.Graphics.FillRectangle (brush2' num7 + 1' y' num6' 2);  	}  	else {  		e.Graphics.DrawLine (pen' x' y' num7' num8);  		e.Graphics.DrawLine (pen' x + 1' y + 1' num7' num8 + 1);  		x = num7 + 1;  		num7 = x + num6;  		e.Graphics.DrawLine (pen' x' y' num7' num8);  		e.Graphics.DrawLine (pen' x + 1' y + 1' num7' num8 + 1);  	}  }  
Magic Number,ProcessHacker.Components,Indicator,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\Indicator.cs,OnPaint,The following statement contains a magic number: for (int i = 0; i < num3; i++) {  	x = num4;  	y = (num5 - (i * 3)) - 1;  	num7 = x + num6;  	num8 = y;  	if (i < num9) {  		e.Graphics.FillRectangle (brush1' x' y' num6' 2);  		e.Graphics.FillRectangle (brush1' num7 + 1' y' num6' 2);  	}  	else if (i < num10) {  		e.Graphics.FillRectangle (brush2' x' y' num6' 2);  		e.Graphics.FillRectangle (brush2' num7 + 1' y' num6' 2);  	}  	else {  		e.Graphics.DrawLine (pen' x' y' num7' num8);  		e.Graphics.DrawLine (pen' x + 1' y + 1' num7' num8 + 1);  		x = num7 + 1;  		num7 = x + num6;  		e.Graphics.DrawLine (pen' x' y' num7' num8);  		e.Graphics.DrawLine (pen' x + 1' y + 1' num7' num8 + 1);  	}  }  
Magic Number,ProcessHacker.Components,Indicator,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\Indicator.cs,OnPaint,The following statement contains a magic number: for (int i = 0; i < num3; i++) {  	x = num4;  	y = (num5 - (i * 3)) - 1;  	num7 = x + num6;  	num8 = y;  	if (i < num9) {  		e.Graphics.FillRectangle (brush1' x' y' num6' 2);  		e.Graphics.FillRectangle (brush1' num7 + 1' y' num6' 2);  	}  	else if (i < num10) {  		e.Graphics.FillRectangle (brush2' x' y' num6' 2);  		e.Graphics.FillRectangle (brush2' num7 + 1' y' num6' 2);  	}  	else {  		e.Graphics.DrawLine (pen' x' y' num7' num8);  		e.Graphics.DrawLine (pen' x + 1' y + 1' num7' num8 + 1);  		x = num7 + 1;  		num7 = x + num6;  		e.Graphics.DrawLine (pen' x' y' num7' num8);  		e.Graphics.DrawLine (pen' x + 1' y + 1' num7' num8 + 1);  	}  }  
Magic Number,ProcessHacker.Components,Indicator,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\Indicator.cs,OnPaint,The following statement contains a magic number: for (int i = 0; i < num3; i++) {  	x = num4;  	y = (num5 - (i * 3)) - 1;  	num7 = x + num6;  	num8 = y;  	if (i < num9) {  		e.Graphics.FillRectangle (brush1' x' y' num6' 2);  		e.Graphics.FillRectangle (brush1' num7 + 1' y' num6' 2);  	}  	else if (i < num10) {  		e.Graphics.FillRectangle (brush2' x' y' num6' 2);  		e.Graphics.FillRectangle (brush2' num7 + 1' y' num6' 2);  	}  	else {  		e.Graphics.DrawLine (pen' x' y' num7' num8);  		e.Graphics.DrawLine (pen' x + 1' y + 1' num7' num8 + 1);  		x = num7 + 1;  		num7 = x + num6;  		e.Graphics.DrawLine (pen' x' y' num7' num8);  		e.Graphics.DrawLine (pen' x + 1' y + 1' num7' num8 + 1);  	}  }  
Magic Number,ProcessHacker.Components,Indicator,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\Indicator.cs,OnPaint,The following statement contains a magic number: y = (num5 - (i * 3)) - 1;  
Magic Number,ProcessHacker.Components,Indicator,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\Indicator.cs,OnPaint,The following statement contains a magic number: if (i < num9) {  	e.Graphics.FillRectangle (brush1' x' y' num6' 2);  	e.Graphics.FillRectangle (brush1' num7 + 1' y' num6' 2);  }  else if (i < num10) {  	e.Graphics.FillRectangle (brush2' x' y' num6' 2);  	e.Graphics.FillRectangle (brush2' num7 + 1' y' num6' 2);  }  else {  	e.Graphics.DrawLine (pen' x' y' num7' num8);  	e.Graphics.DrawLine (pen' x + 1' y + 1' num7' num8 + 1);  	x = num7 + 1;  	num7 = x + num6;  	e.Graphics.DrawLine (pen' x' y' num7' num8);  	e.Graphics.DrawLine (pen' x + 1' y + 1' num7' num8 + 1);  }  
Magic Number,ProcessHacker.Components,Indicator,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\Indicator.cs,OnPaint,The following statement contains a magic number: if (i < num9) {  	e.Graphics.FillRectangle (brush1' x' y' num6' 2);  	e.Graphics.FillRectangle (brush1' num7 + 1' y' num6' 2);  }  else if (i < num10) {  	e.Graphics.FillRectangle (brush2' x' y' num6' 2);  	e.Graphics.FillRectangle (brush2' num7 + 1' y' num6' 2);  }  else {  	e.Graphics.DrawLine (pen' x' y' num7' num8);  	e.Graphics.DrawLine (pen' x + 1' y + 1' num7' num8 + 1);  	x = num7 + 1;  	num7 = x + num6;  	e.Graphics.DrawLine (pen' x' y' num7' num8);  	e.Graphics.DrawLine (pen' x + 1' y + 1' num7' num8 + 1);  }  
Magic Number,ProcessHacker.Components,Indicator,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\Indicator.cs,OnPaint,The following statement contains a magic number: if (i < num9) {  	e.Graphics.FillRectangle (brush1' x' y' num6' 2);  	e.Graphics.FillRectangle (brush1' num7 + 1' y' num6' 2);  }  else if (i < num10) {  	e.Graphics.FillRectangle (brush2' x' y' num6' 2);  	e.Graphics.FillRectangle (brush2' num7 + 1' y' num6' 2);  }  else {  	e.Graphics.DrawLine (pen' x' y' num7' num8);  	e.Graphics.DrawLine (pen' x + 1' y + 1' num7' num8 + 1);  	x = num7 + 1;  	num7 = x + num6;  	e.Graphics.DrawLine (pen' x' y' num7' num8);  	e.Graphics.DrawLine (pen' x + 1' y + 1' num7' num8 + 1);  }  
Magic Number,ProcessHacker.Components,Indicator,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\Indicator.cs,OnPaint,The following statement contains a magic number: if (i < num9) {  	e.Graphics.FillRectangle (brush1' x' y' num6' 2);  	e.Graphics.FillRectangle (brush1' num7 + 1' y' num6' 2);  }  else if (i < num10) {  	e.Graphics.FillRectangle (brush2' x' y' num6' 2);  	e.Graphics.FillRectangle (brush2' num7 + 1' y' num6' 2);  }  else {  	e.Graphics.DrawLine (pen' x' y' num7' num8);  	e.Graphics.DrawLine (pen' x + 1' y + 1' num7' num8 + 1);  	x = num7 + 1;  	num7 = x + num6;  	e.Graphics.DrawLine (pen' x' y' num7' num8);  	e.Graphics.DrawLine (pen' x + 1' y + 1' num7' num8 + 1);  }  
Magic Number,ProcessHacker.Components,Indicator,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\Indicator.cs,OnPaint,The following statement contains a magic number: e.Graphics.FillRectangle (brush1' x' y' num6' 2);  
Magic Number,ProcessHacker.Components,Indicator,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\Indicator.cs,OnPaint,The following statement contains a magic number: e.Graphics.FillRectangle (brush1' num7 + 1' y' num6' 2);  
Magic Number,ProcessHacker.Components,Indicator,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\Indicator.cs,OnPaint,The following statement contains a magic number: if (i < num10) {  	e.Graphics.FillRectangle (brush2' x' y' num6' 2);  	e.Graphics.FillRectangle (brush2' num7 + 1' y' num6' 2);  }  else {  	e.Graphics.DrawLine (pen' x' y' num7' num8);  	e.Graphics.DrawLine (pen' x + 1' y + 1' num7' num8 + 1);  	x = num7 + 1;  	num7 = x + num6;  	e.Graphics.DrawLine (pen' x' y' num7' num8);  	e.Graphics.DrawLine (pen' x + 1' y + 1' num7' num8 + 1);  }  
Magic Number,ProcessHacker.Components,Indicator,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\Indicator.cs,OnPaint,The following statement contains a magic number: if (i < num10) {  	e.Graphics.FillRectangle (brush2' x' y' num6' 2);  	e.Graphics.FillRectangle (brush2' num7 + 1' y' num6' 2);  }  else {  	e.Graphics.DrawLine (pen' x' y' num7' num8);  	e.Graphics.DrawLine (pen' x + 1' y + 1' num7' num8 + 1);  	x = num7 + 1;  	num7 = x + num6;  	e.Graphics.DrawLine (pen' x' y' num7' num8);  	e.Graphics.DrawLine (pen' x + 1' y + 1' num7' num8 + 1);  }  
Magic Number,ProcessHacker.Components,Indicator,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\Indicator.cs,OnPaint,The following statement contains a magic number: e.Graphics.FillRectangle (brush2' x' y' num6' 2);  
Magic Number,ProcessHacker.Components,Indicator,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\Indicator.cs,OnPaint,The following statement contains a magic number: e.Graphics.FillRectangle (brush2' num7 + 1' y' num6' 2);  
Magic Number,ProcessHacker.Components,TargetWindowButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\TargetWindowButton.cs,DrawWindowRectangle,The following statement contains a magic number: if (windowDc != IntPtr.Zero) {  	// Pen width of system border width times 3.  	int penWidth = Win32.GetSystemMetrics (5) * 3;  	// Save the DC.  	int oldDc = Win32.SaveDC (windowDc);  	// Get an inversion effect.  	Win32.SetROP2 (windowDc' GdiBlendMode.Not);  	// Create a pen.  	IntPtr pen = Win32.CreatePen (GdiPenStyle.InsideFrame' penWidth' IntPtr.Zero);  	Win32.SelectObject (windowDc' pen);  	// Get the null brush.  	IntPtr brush = Win32.GetStockObject (GdiStockObject.NullBrush);  	Win32.SelectObject (windowDc' brush);  	// Draw the rectangle.  	Win32.Rectangle (windowDc' 0' 0' rect.Right - rect.Left' rect.Bottom - rect.Top);  	// Delete the pen.  	Win32.DeleteObject (pen);  	// Restore and release the old DC.  	Win32.RestoreDC (windowDc' oldDc);  	Win32.ReleaseDC (hWnd' windowDc);  }  
Magic Number,ProcessHacker.Components,TargetWindowButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\TargetWindowButton.cs,DrawWindowRectangle,The following statement contains a magic number: if (windowDc != IntPtr.Zero) {  	// Pen width of system border width times 3.  	int penWidth = Win32.GetSystemMetrics (5) * 3;  	// Save the DC.  	int oldDc = Win32.SaveDC (windowDc);  	// Get an inversion effect.  	Win32.SetROP2 (windowDc' GdiBlendMode.Not);  	// Create a pen.  	IntPtr pen = Win32.CreatePen (GdiPenStyle.InsideFrame' penWidth' IntPtr.Zero);  	Win32.SelectObject (windowDc' pen);  	// Get the null brush.  	IntPtr brush = Win32.GetStockObject (GdiStockObject.NullBrush);  	Win32.SelectObject (windowDc' brush);  	// Draw the rectangle.  	Win32.Rectangle (windowDc' 0' 0' rect.Right - rect.Left' rect.Bottom - rect.Top);  	// Delete the pen.  	Win32.DeleteObject (pen);  	// Restore and release the old DC.  	Win32.RestoreDC (windowDc' oldDc);  	Win32.ReleaseDC (hWnd' windowDc);  }  
Magic Number,ProcessHacker.Components,NetworkList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\NetworkList.cs,RefreshIcons,The following statement contains a magic number: lock (listNetwork) {  	foreach (ListViewItem item in listNetwork.Items) {  		int pid = ((NetworkItem)item.Tag).Connection.Pid;  		if (searchPid != 0)  			if (pid != searchPid)  				continue;  		// If the item already has an icon' continue searching.  		if (item.ImageKey != "generic_process")  			continue;  		// If the PID is System Idle Process' continue searching.  		if (pid < 4)  			continue;  		if (Program.ProcessProvider.Dictionary.ContainsKey (pid) && Program.ProcessProvider.Dictionary [pid].Icon != null) {  			if (!imageList.Images.ContainsKey (pid.ToString ()))  				imageList.Images.Add (pid.ToString ()' Program.ProcessProvider.Dictionary [pid].Icon);  			item.ImageKey = pid.ToString ();  		}  	}  }  
Magic Number,ProcessHacker.Components,NetworkList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\NetworkList.cs,RefreshIcons,The following statement contains a magic number: foreach (ListViewItem item in listNetwork.Items) {  	int pid = ((NetworkItem)item.Tag).Connection.Pid;  	if (searchPid != 0)  		if (pid != searchPid)  			continue;  	// If the item already has an icon' continue searching.  	if (item.ImageKey != "generic_process")  		continue;  	// If the PID is System Idle Process' continue searching.  	if (pid < 4)  		continue;  	if (Program.ProcessProvider.Dictionary.ContainsKey (pid) && Program.ProcessProvider.Dictionary [pid].Icon != null) {  		if (!imageList.Images.ContainsKey (pid.ToString ()))  			imageList.Images.Add (pid.ToString ()' Program.ProcessProvider.Dictionary [pid].Icon);  		item.ImageKey = pid.ToString ();  	}  }  
Magic Number,ProcessHacker.Components,NetworkList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\NetworkList.cs,RefreshIcons,The following statement contains a magic number: if (pid < 4)  	continue;  
Magic Number,ProcessHacker.Components,NetworkList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\NetworkList.cs,FillNetworkItemAddresses,The following statement contains a magic number: if (item.Connection.Remote != null && !item.Connection.Remote.IsEmpty ()) {  	string addressString = item.Connection.Remote.Address.ToString ();  	if (item.RemoteString != null && item.RemoteString != addressString)  		litem.SubItems [3].Text = item.RemoteString + " (" + addressString + ")";  	else  		litem.SubItems [3].Text = addressString;  }  
Magic Number,ProcessHacker.Components,NetworkList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\NetworkList.cs,FillNetworkItemAddresses,The following statement contains a magic number: if (item.Connection.Remote != null && !item.Connection.Remote.IsEmpty ()) {  	string addressString = item.Connection.Remote.Address.ToString ();  	if (item.RemoteString != null && item.RemoteString != addressString)  		litem.SubItems [3].Text = item.RemoteString + " (" + addressString + ")";  	else  		litem.SubItems [3].Text = addressString;  }  
Magic Number,ProcessHacker.Components,NetworkList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\NetworkList.cs,FillNetworkItemAddresses,The following statement contains a magic number: if (item.RemoteString != null && item.RemoteString != addressString)  	litem.SubItems [3].Text = item.RemoteString + " (" + addressString + ")";  else  	litem.SubItems [3].Text = addressString;  
Magic Number,ProcessHacker.Components,NetworkList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\NetworkList.cs,FillNetworkItemAddresses,The following statement contains a magic number: if (item.RemoteString != null && item.RemoteString != addressString)  	litem.SubItems [3].Text = item.RemoteString + " (" + addressString + ")";  else  	litem.SubItems [3].Text = addressString;  
Magic Number,ProcessHacker.Components,NetworkList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\NetworkList.cs,FillNetworkItemAddresses,The following statement contains a magic number: litem.SubItems [3].Text = item.RemoteString + " (" + addressString + ")";  
Magic Number,ProcessHacker.Components,NetworkList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\NetworkList.cs,FillNetworkItemAddresses,The following statement contains a magic number: litem.SubItems [3].Text = addressString;  
Magic Number,ProcessHacker.Components,NetworkList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\NetworkList.cs,provider_DictionaryModified,The following statement contains a magic number: this.BeginInvoke (new MethodInvoker (() =>  {  	lock (listNetwork) {  		ListViewItem litem = listNetwork.Items [newItem.Id];  		if (litem == null)  			return;  		this.FillNetworkItemAddresses (litem' newItem);  		litem.SubItems [6].Text = newItem.Connection.State != 0 ? newItem.Connection.State.ToString () : "";  		_needsSort = true;  	}  }));  
Magic Number,ProcessHacker.Components,NetworkList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\NetworkList.cs,provider_DictionaryModified,The following statement contains a magic number: lock (listNetwork) {  	ListViewItem litem = listNetwork.Items [newItem.Id];  	if (litem == null)  		return;  	this.FillNetworkItemAddresses (litem' newItem);  	litem.SubItems [6].Text = newItem.Connection.State != 0 ? newItem.Connection.State.ToString () : "";  	_needsSort = true;  }  
Magic Number,ProcessHacker.Components,NetworkList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\NetworkList.cs,provider_DictionaryModified,The following statement contains a magic number: litem.SubItems [6].Text = newItem.Connection.State != 0 ? newItem.Connection.State.ToString () : "";  
Magic Number,ProcessHacker.Components,MemoryList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\MemoryList.cs,MemoryList,The following statement contains a magic number: (listMemory.ListViewItemSorter as SortedListViewComparer).CustomSorters.Add (2' (x' y) =>  {  	MemoryItem ix = (MemoryItem)x.Tag;  	MemoryItem iy = (MemoryItem)y.Tag;  	return ix.Size.CompareTo (iy.Size);  });  
Magic Number,ProcessHacker.Components,MemoryList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\MemoryList.cs,FillMemoryListViewItem,The following statement contains a magic number: litem.SubItems [2].Text = Utils.FormatSize (item.Size);  
Magic Number,ProcessHacker.Components,MemoryList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\MemoryList.cs,FillMemoryListViewItem,The following statement contains a magic number: litem.SubItems [3].Text = GetProtectStr (item.Protection);  
Magic Number,ProcessHacker.Components,ModuleList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ModuleList.cs,SetMainModule,The following statement contains a magic number: comparer.ColumnSortOrder.Add (2);  
Magic Number,ProcessHacker.Components,ModuleList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ModuleList.cs,SetMainModule,The following statement contains a magic number: (listModules.ListViewItemSorter as SortedListViewComparer).CustomSorters.Add (2' (x' y) =>  {  	ModuleItem ix = (ModuleItem)x.Tag;  	ModuleItem iy = (ModuleItem)y.Tag;  	return ix.Size.CompareTo (iy.Size);  });  
Magic Number,ProcessHacker.Components,ModuleList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ModuleList.cs,menuModule_Popup,The following statement contains a magic number: if (listModules.SelectedItems.Count == 1) {  	if (_pid == 4) {  		menuModule.DisableAll ();  		if (KProcessHacker.Instance != null)  			unloadMenuItem.Enabled = true;  		inspectModuleMenuItem.Enabled = true;  		searchModuleMenuItem.Enabled = true;  		copyFileNameMenuItem.Enabled = true;  		copyModuleMenuItem.Enabled = true;  		openContainingFolderMenuItem.Enabled = true;  		propertiesMenuItem.Enabled = true;  	}  	else {  		menuModule.EnableAll ();  	}  }  else {  	menuModule.DisableAll ();  	if (listModules.SelectedItems.Count > 1) {  		copyFileNameMenuItem.Enabled = true;  		copyModuleMenuItem.Enabled = true;  	}  }  
Magic Number,ProcessHacker.Components,ModuleList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ModuleList.cs,menuModule_Popup,The following statement contains a magic number: if (_pid == 4) {  	menuModule.DisableAll ();  	if (KProcessHacker.Instance != null)  		unloadMenuItem.Enabled = true;  	inspectModuleMenuItem.Enabled = true;  	searchModuleMenuItem.Enabled = true;  	copyFileNameMenuItem.Enabled = true;  	copyModuleMenuItem.Enabled = true;  	openContainingFolderMenuItem.Enabled = true;  	propertiesMenuItem.Enabled = true;  }  else {  	menuModule.EnableAll ();  }  
Magic Number,ProcessHacker.Components,ModuleList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ModuleList.cs,unloadMenuItem_Click,The following statement contains a magic number: if (!PhUtils.ShowConfirmMessage ("Unload"' _pid != 4 ? "the selected module" : "the selected driver"' _pid != 4 ? "Unloading a module may cause the process to crash." : "Unloading a driver may cause system instability."' true))  	return;  
Magic Number,ProcessHacker.Components,ModuleList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ModuleList.cs,unloadMenuItem_Click,The following statement contains a magic number: if (!PhUtils.ShowConfirmMessage ("Unload"' _pid != 4 ? "the selected module" : "the selected driver"' _pid != 4 ? "Unloading a module may cause the process to crash." : "Unloading a driver may cause system instability."' true))  	return;  
Magic Number,ProcessHacker.Components,ModuleList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ModuleList.cs,unloadMenuItem_Click,The following statement contains a magic number: if (_pid == 4) {  	try {  		var moduleItem = (ModuleItem)listModules.SelectedItems [0].Tag;  		string serviceName = null;  		// Try to find the name of the service key for the driver by   		// looping through the objects in the Driver directory and   		// opening each one.  		using (var dhandle = new DirectoryHandle ("\\Driver"' DirectoryAccess.Query)) {  			foreach (var obj in dhandle.GetObjects ()) {  				try {  					using (var driverHandle = new DriverHandle ("\\Driver\\" + obj.Name)) {  						if (driverHandle.GetBasicInformation ().DriverStart == moduleItem.BaseAddress.ToIntPtr ()) {  							serviceName = driverHandle.GetServiceKeyName ();  							break;  						}  					}  				}  				catch {  				}  			}  		}  		// If we didn't find the service name' use the driver base name.  		if (serviceName == null) {  			if (moduleItem.Name.EndsWith (".sys"' StringComparison.OrdinalIgnoreCase))  				serviceName = moduleItem.Name.Remove (moduleItem.Name.Length - 4' 4);  			else  				serviceName = moduleItem.Name;  		}  		RegistryKey servicesKey = Registry.LocalMachine.OpenSubKey ("SYSTEM\\CurrentControlSet\\Services"' true);  		bool serviceKeyCreated;  		RegistryKey serviceKey;  		// Check if the service key exists so that we don't delete it   		// later if it does.  		if (Array.Exists<string> (servicesKey.GetSubKeyNames ()' keyName => (string.Compare (keyName' serviceName' true) == 0))) {  			serviceKeyCreated = false;  		}  		else {  			serviceKeyCreated = true;  			// Create the service key.  			serviceKey = servicesKey.CreateSubKey (serviceName);  			serviceKey.SetValue ("ErrorControl"' 1' RegistryValueKind.DWord);  			serviceKey.SetValue ("ImagePath"' "\\??\\" + moduleItem.FileName' RegistryValueKind.ExpandString);  			serviceKey.SetValue ("Start"' 1' RegistryValueKind.DWord);  			serviceKey.SetValue ("Type"' 1' RegistryValueKind.DWord);  			serviceKey.Close ();  			servicesKey.Flush ();  		}  		try {  			Windows.UnloadDriver (serviceName);  		}  		finally {  			if (serviceKeyCreated)  				servicesKey.DeleteSubKeyTree (serviceName);  			servicesKey.Close ();  		}  		listModules.SelectedItems.Clear ();  	}  	catch (Exception ex) {  		MessageBox.Show ("Unable to unload the driver. Make sure Process Hacker " + "is running with administrative privileges. Error:\n\n" + ex.Message' "Process Hacker"' MessageBoxButtons.OK' MessageBoxIcon.Error);  	}  }  else {  	try {  		using (ProcessHandle phandle = new ProcessHandle (_pid' Program.MinProcessQueryRights | ProcessAccess.VmOperation | ProcessAccess.VmRead | ProcessAccess.VmWrite | ProcessAccess.CreateThread)) {  			IntPtr baseAddress = ((ModuleItem)listModules.SelectedItems [0].Tag).BaseAddress.ToIntPtr ();  			phandle.SetModuleReferenceCount (baseAddress' 1);  			ThreadHandle thread;  			if (OSVersion.IsAboveOrEqual (WindowsVersion.Vista)) {  				// Use RtlCreateUserThread to bypass session boundaries. Since   				// LdrUnloadDll is a native function we don't need to notify CSR.  				thread = phandle.CreateThread (Loader.GetProcedure ("ntdll.dll"' "LdrUnloadDll")' baseAddress);  			}  			else {  				// On XP it seems we need to notify CSR...  				thread = phandle.CreateThreadWin32 (Loader.GetProcedure ("kernel32.dll"' "FreeLibrary")' baseAddress);  			}  			thread.Wait (1000 * Win32.TimeMsTo100Ns);  			NtStatus exitStatus = thread.GetExitStatus ();  			if (exitStatus == NtStatus.DllNotFound) {  				if (OSVersion.Architecture == OSArch.Amd64) {  					PhUtils.ShowError ("Unable to find the module to unload. This may be caused " + "by an attempt to unload a mapped file or a 32-bit module.");  				}  				else {  					PhUtils.ShowError ("Unable to find the module to unload. This may be caused " + "by an attempt to unload a mapped file.");  				}  			}  			else {  				exitStatus.ThrowIf ();  			}  			thread.Dispose ();  		}  		listModules.SelectedItems.Clear ();  	}  	catch (Exception ex) {  		PhUtils.ShowException ("Unable to unload the module"' ex);  	}  }  
Magic Number,ProcessHacker.Components,ModuleList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ModuleList.cs,unloadMenuItem_Click,The following statement contains a magic number: if (_pid == 4) {  	try {  		var moduleItem = (ModuleItem)listModules.SelectedItems [0].Tag;  		string serviceName = null;  		// Try to find the name of the service key for the driver by   		// looping through the objects in the Driver directory and   		// opening each one.  		using (var dhandle = new DirectoryHandle ("\\Driver"' DirectoryAccess.Query)) {  			foreach (var obj in dhandle.GetObjects ()) {  				try {  					using (var driverHandle = new DriverHandle ("\\Driver\\" + obj.Name)) {  						if (driverHandle.GetBasicInformation ().DriverStart == moduleItem.BaseAddress.ToIntPtr ()) {  							serviceName = driverHandle.GetServiceKeyName ();  							break;  						}  					}  				}  				catch {  				}  			}  		}  		// If we didn't find the service name' use the driver base name.  		if (serviceName == null) {  			if (moduleItem.Name.EndsWith (".sys"' StringComparison.OrdinalIgnoreCase))  				serviceName = moduleItem.Name.Remove (moduleItem.Name.Length - 4' 4);  			else  				serviceName = moduleItem.Name;  		}  		RegistryKey servicesKey = Registry.LocalMachine.OpenSubKey ("SYSTEM\\CurrentControlSet\\Services"' true);  		bool serviceKeyCreated;  		RegistryKey serviceKey;  		// Check if the service key exists so that we don't delete it   		// later if it does.  		if (Array.Exists<string> (servicesKey.GetSubKeyNames ()' keyName => (string.Compare (keyName' serviceName' true) == 0))) {  			serviceKeyCreated = false;  		}  		else {  			serviceKeyCreated = true;  			// Create the service key.  			serviceKey = servicesKey.CreateSubKey (serviceName);  			serviceKey.SetValue ("ErrorControl"' 1' RegistryValueKind.DWord);  			serviceKey.SetValue ("ImagePath"' "\\??\\" + moduleItem.FileName' RegistryValueKind.ExpandString);  			serviceKey.SetValue ("Start"' 1' RegistryValueKind.DWord);  			serviceKey.SetValue ("Type"' 1' RegistryValueKind.DWord);  			serviceKey.Close ();  			servicesKey.Flush ();  		}  		try {  			Windows.UnloadDriver (serviceName);  		}  		finally {  			if (serviceKeyCreated)  				servicesKey.DeleteSubKeyTree (serviceName);  			servicesKey.Close ();  		}  		listModules.SelectedItems.Clear ();  	}  	catch (Exception ex) {  		MessageBox.Show ("Unable to unload the driver. Make sure Process Hacker " + "is running with administrative privileges. Error:\n\n" + ex.Message' "Process Hacker"' MessageBoxButtons.OK' MessageBoxIcon.Error);  	}  }  else {  	try {  		using (ProcessHandle phandle = new ProcessHandle (_pid' Program.MinProcessQueryRights | ProcessAccess.VmOperation | ProcessAccess.VmRead | ProcessAccess.VmWrite | ProcessAccess.CreateThread)) {  			IntPtr baseAddress = ((ModuleItem)listModules.SelectedItems [0].Tag).BaseAddress.ToIntPtr ();  			phandle.SetModuleReferenceCount (baseAddress' 1);  			ThreadHandle thread;  			if (OSVersion.IsAboveOrEqual (WindowsVersion.Vista)) {  				// Use RtlCreateUserThread to bypass session boundaries. Since   				// LdrUnloadDll is a native function we don't need to notify CSR.  				thread = phandle.CreateThread (Loader.GetProcedure ("ntdll.dll"' "LdrUnloadDll")' baseAddress);  			}  			else {  				// On XP it seems we need to notify CSR...  				thread = phandle.CreateThreadWin32 (Loader.GetProcedure ("kernel32.dll"' "FreeLibrary")' baseAddress);  			}  			thread.Wait (1000 * Win32.TimeMsTo100Ns);  			NtStatus exitStatus = thread.GetExitStatus ();  			if (exitStatus == NtStatus.DllNotFound) {  				if (OSVersion.Architecture == OSArch.Amd64) {  					PhUtils.ShowError ("Unable to find the module to unload. This may be caused " + "by an attempt to unload a mapped file or a 32-bit module.");  				}  				else {  					PhUtils.ShowError ("Unable to find the module to unload. This may be caused " + "by an attempt to unload a mapped file.");  				}  			}  			else {  				exitStatus.ThrowIf ();  			}  			thread.Dispose ();  		}  		listModules.SelectedItems.Clear ();  	}  	catch (Exception ex) {  		PhUtils.ShowException ("Unable to unload the module"' ex);  	}  }  
Magic Number,ProcessHacker.Components,ModuleList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ModuleList.cs,unloadMenuItem_Click,The following statement contains a magic number: if (_pid == 4) {  	try {  		var moduleItem = (ModuleItem)listModules.SelectedItems [0].Tag;  		string serviceName = null;  		// Try to find the name of the service key for the driver by   		// looping through the objects in the Driver directory and   		// opening each one.  		using (var dhandle = new DirectoryHandle ("\\Driver"' DirectoryAccess.Query)) {  			foreach (var obj in dhandle.GetObjects ()) {  				try {  					using (var driverHandle = new DriverHandle ("\\Driver\\" + obj.Name)) {  						if (driverHandle.GetBasicInformation ().DriverStart == moduleItem.BaseAddress.ToIntPtr ()) {  							serviceName = driverHandle.GetServiceKeyName ();  							break;  						}  					}  				}  				catch {  				}  			}  		}  		// If we didn't find the service name' use the driver base name.  		if (serviceName == null) {  			if (moduleItem.Name.EndsWith (".sys"' StringComparison.OrdinalIgnoreCase))  				serviceName = moduleItem.Name.Remove (moduleItem.Name.Length - 4' 4);  			else  				serviceName = moduleItem.Name;  		}  		RegistryKey servicesKey = Registry.LocalMachine.OpenSubKey ("SYSTEM\\CurrentControlSet\\Services"' true);  		bool serviceKeyCreated;  		RegistryKey serviceKey;  		// Check if the service key exists so that we don't delete it   		// later if it does.  		if (Array.Exists<string> (servicesKey.GetSubKeyNames ()' keyName => (string.Compare (keyName' serviceName' true) == 0))) {  			serviceKeyCreated = false;  		}  		else {  			serviceKeyCreated = true;  			// Create the service key.  			serviceKey = servicesKey.CreateSubKey (serviceName);  			serviceKey.SetValue ("ErrorControl"' 1' RegistryValueKind.DWord);  			serviceKey.SetValue ("ImagePath"' "\\??\\" + moduleItem.FileName' RegistryValueKind.ExpandString);  			serviceKey.SetValue ("Start"' 1' RegistryValueKind.DWord);  			serviceKey.SetValue ("Type"' 1' RegistryValueKind.DWord);  			serviceKey.Close ();  			servicesKey.Flush ();  		}  		try {  			Windows.UnloadDriver (serviceName);  		}  		finally {  			if (serviceKeyCreated)  				servicesKey.DeleteSubKeyTree (serviceName);  			servicesKey.Close ();  		}  		listModules.SelectedItems.Clear ();  	}  	catch (Exception ex) {  		MessageBox.Show ("Unable to unload the driver. Make sure Process Hacker " + "is running with administrative privileges. Error:\n\n" + ex.Message' "Process Hacker"' MessageBoxButtons.OK' MessageBoxIcon.Error);  	}  }  else {  	try {  		using (ProcessHandle phandle = new ProcessHandle (_pid' Program.MinProcessQueryRights | ProcessAccess.VmOperation | ProcessAccess.VmRead | ProcessAccess.VmWrite | ProcessAccess.CreateThread)) {  			IntPtr baseAddress = ((ModuleItem)listModules.SelectedItems [0].Tag).BaseAddress.ToIntPtr ();  			phandle.SetModuleReferenceCount (baseAddress' 1);  			ThreadHandle thread;  			if (OSVersion.IsAboveOrEqual (WindowsVersion.Vista)) {  				// Use RtlCreateUserThread to bypass session boundaries. Since   				// LdrUnloadDll is a native function we don't need to notify CSR.  				thread = phandle.CreateThread (Loader.GetProcedure ("ntdll.dll"' "LdrUnloadDll")' baseAddress);  			}  			else {  				// On XP it seems we need to notify CSR...  				thread = phandle.CreateThreadWin32 (Loader.GetProcedure ("kernel32.dll"' "FreeLibrary")' baseAddress);  			}  			thread.Wait (1000 * Win32.TimeMsTo100Ns);  			NtStatus exitStatus = thread.GetExitStatus ();  			if (exitStatus == NtStatus.DllNotFound) {  				if (OSVersion.Architecture == OSArch.Amd64) {  					PhUtils.ShowError ("Unable to find the module to unload. This may be caused " + "by an attempt to unload a mapped file or a 32-bit module.");  				}  				else {  					PhUtils.ShowError ("Unable to find the module to unload. This may be caused " + "by an attempt to unload a mapped file.");  				}  			}  			else {  				exitStatus.ThrowIf ();  			}  			thread.Dispose ();  		}  		listModules.SelectedItems.Clear ();  	}  	catch (Exception ex) {  		PhUtils.ShowException ("Unable to unload the module"' ex);  	}  }  
Magic Number,ProcessHacker.Components,ModuleList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ModuleList.cs,unloadMenuItem_Click,The following statement contains a magic number: if (_pid == 4) {  	try {  		var moduleItem = (ModuleItem)listModules.SelectedItems [0].Tag;  		string serviceName = null;  		// Try to find the name of the service key for the driver by   		// looping through the objects in the Driver directory and   		// opening each one.  		using (var dhandle = new DirectoryHandle ("\\Driver"' DirectoryAccess.Query)) {  			foreach (var obj in dhandle.GetObjects ()) {  				try {  					using (var driverHandle = new DriverHandle ("\\Driver\\" + obj.Name)) {  						if (driverHandle.GetBasicInformation ().DriverStart == moduleItem.BaseAddress.ToIntPtr ()) {  							serviceName = driverHandle.GetServiceKeyName ();  							break;  						}  					}  				}  				catch {  				}  			}  		}  		// If we didn't find the service name' use the driver base name.  		if (serviceName == null) {  			if (moduleItem.Name.EndsWith (".sys"' StringComparison.OrdinalIgnoreCase))  				serviceName = moduleItem.Name.Remove (moduleItem.Name.Length - 4' 4);  			else  				serviceName = moduleItem.Name;  		}  		RegistryKey servicesKey = Registry.LocalMachine.OpenSubKey ("SYSTEM\\CurrentControlSet\\Services"' true);  		bool serviceKeyCreated;  		RegistryKey serviceKey;  		// Check if the service key exists so that we don't delete it   		// later if it does.  		if (Array.Exists<string> (servicesKey.GetSubKeyNames ()' keyName => (string.Compare (keyName' serviceName' true) == 0))) {  			serviceKeyCreated = false;  		}  		else {  			serviceKeyCreated = true;  			// Create the service key.  			serviceKey = servicesKey.CreateSubKey (serviceName);  			serviceKey.SetValue ("ErrorControl"' 1' RegistryValueKind.DWord);  			serviceKey.SetValue ("ImagePath"' "\\??\\" + moduleItem.FileName' RegistryValueKind.ExpandString);  			serviceKey.SetValue ("Start"' 1' RegistryValueKind.DWord);  			serviceKey.SetValue ("Type"' 1' RegistryValueKind.DWord);  			serviceKey.Close ();  			servicesKey.Flush ();  		}  		try {  			Windows.UnloadDriver (serviceName);  		}  		finally {  			if (serviceKeyCreated)  				servicesKey.DeleteSubKeyTree (serviceName);  			servicesKey.Close ();  		}  		listModules.SelectedItems.Clear ();  	}  	catch (Exception ex) {  		MessageBox.Show ("Unable to unload the driver. Make sure Process Hacker " + "is running with administrative privileges. Error:\n\n" + ex.Message' "Process Hacker"' MessageBoxButtons.OK' MessageBoxIcon.Error);  	}  }  else {  	try {  		using (ProcessHandle phandle = new ProcessHandle (_pid' Program.MinProcessQueryRights | ProcessAccess.VmOperation | ProcessAccess.VmRead | ProcessAccess.VmWrite | ProcessAccess.CreateThread)) {  			IntPtr baseAddress = ((ModuleItem)listModules.SelectedItems [0].Tag).BaseAddress.ToIntPtr ();  			phandle.SetModuleReferenceCount (baseAddress' 1);  			ThreadHandle thread;  			if (OSVersion.IsAboveOrEqual (WindowsVersion.Vista)) {  				// Use RtlCreateUserThread to bypass session boundaries. Since   				// LdrUnloadDll is a native function we don't need to notify CSR.  				thread = phandle.CreateThread (Loader.GetProcedure ("ntdll.dll"' "LdrUnloadDll")' baseAddress);  			}  			else {  				// On XP it seems we need to notify CSR...  				thread = phandle.CreateThreadWin32 (Loader.GetProcedure ("kernel32.dll"' "FreeLibrary")' baseAddress);  			}  			thread.Wait (1000 * Win32.TimeMsTo100Ns);  			NtStatus exitStatus = thread.GetExitStatus ();  			if (exitStatus == NtStatus.DllNotFound) {  				if (OSVersion.Architecture == OSArch.Amd64) {  					PhUtils.ShowError ("Unable to find the module to unload. This may be caused " + "by an attempt to unload a mapped file or a 32-bit module.");  				}  				else {  					PhUtils.ShowError ("Unable to find the module to unload. This may be caused " + "by an attempt to unload a mapped file.");  				}  			}  			else {  				exitStatus.ThrowIf ();  			}  			thread.Dispose ();  		}  		listModules.SelectedItems.Clear ();  	}  	catch (Exception ex) {  		PhUtils.ShowException ("Unable to unload the module"' ex);  	}  }  
Magic Number,ProcessHacker.Components,ModuleList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ModuleList.cs,unloadMenuItem_Click,The following statement contains a magic number: try {  	var moduleItem = (ModuleItem)listModules.SelectedItems [0].Tag;  	string serviceName = null;  	// Try to find the name of the service key for the driver by   	// looping through the objects in the Driver directory and   	// opening each one.  	using (var dhandle = new DirectoryHandle ("\\Driver"' DirectoryAccess.Query)) {  		foreach (var obj in dhandle.GetObjects ()) {  			try {  				using (var driverHandle = new DriverHandle ("\\Driver\\" + obj.Name)) {  					if (driverHandle.GetBasicInformation ().DriverStart == moduleItem.BaseAddress.ToIntPtr ()) {  						serviceName = driverHandle.GetServiceKeyName ();  						break;  					}  				}  			}  			catch {  			}  		}  	}  	// If we didn't find the service name' use the driver base name.  	if (serviceName == null) {  		if (moduleItem.Name.EndsWith (".sys"' StringComparison.OrdinalIgnoreCase))  			serviceName = moduleItem.Name.Remove (moduleItem.Name.Length - 4' 4);  		else  			serviceName = moduleItem.Name;  	}  	RegistryKey servicesKey = Registry.LocalMachine.OpenSubKey ("SYSTEM\\CurrentControlSet\\Services"' true);  	bool serviceKeyCreated;  	RegistryKey serviceKey;  	// Check if the service key exists so that we don't delete it   	// later if it does.  	if (Array.Exists<string> (servicesKey.GetSubKeyNames ()' keyName => (string.Compare (keyName' serviceName' true) == 0))) {  		serviceKeyCreated = false;  	}  	else {  		serviceKeyCreated = true;  		// Create the service key.  		serviceKey = servicesKey.CreateSubKey (serviceName);  		serviceKey.SetValue ("ErrorControl"' 1' RegistryValueKind.DWord);  		serviceKey.SetValue ("ImagePath"' "\\??\\" + moduleItem.FileName' RegistryValueKind.ExpandString);  		serviceKey.SetValue ("Start"' 1' RegistryValueKind.DWord);  		serviceKey.SetValue ("Type"' 1' RegistryValueKind.DWord);  		serviceKey.Close ();  		servicesKey.Flush ();  	}  	try {  		Windows.UnloadDriver (serviceName);  	}  	finally {  		if (serviceKeyCreated)  			servicesKey.DeleteSubKeyTree (serviceName);  		servicesKey.Close ();  	}  	listModules.SelectedItems.Clear ();  }  catch (Exception ex) {  	MessageBox.Show ("Unable to unload the driver. Make sure Process Hacker " + "is running with administrative privileges. Error:\n\n" + ex.Message' "Process Hacker"' MessageBoxButtons.OK' MessageBoxIcon.Error);  }  
Magic Number,ProcessHacker.Components,ModuleList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ModuleList.cs,unloadMenuItem_Click,The following statement contains a magic number: try {  	var moduleItem = (ModuleItem)listModules.SelectedItems [0].Tag;  	string serviceName = null;  	// Try to find the name of the service key for the driver by   	// looping through the objects in the Driver directory and   	// opening each one.  	using (var dhandle = new DirectoryHandle ("\\Driver"' DirectoryAccess.Query)) {  		foreach (var obj in dhandle.GetObjects ()) {  			try {  				using (var driverHandle = new DriverHandle ("\\Driver\\" + obj.Name)) {  					if (driverHandle.GetBasicInformation ().DriverStart == moduleItem.BaseAddress.ToIntPtr ()) {  						serviceName = driverHandle.GetServiceKeyName ();  						break;  					}  				}  			}  			catch {  			}  		}  	}  	// If we didn't find the service name' use the driver base name.  	if (serviceName == null) {  		if (moduleItem.Name.EndsWith (".sys"' StringComparison.OrdinalIgnoreCase))  			serviceName = moduleItem.Name.Remove (moduleItem.Name.Length - 4' 4);  		else  			serviceName = moduleItem.Name;  	}  	RegistryKey servicesKey = Registry.LocalMachine.OpenSubKey ("SYSTEM\\CurrentControlSet\\Services"' true);  	bool serviceKeyCreated;  	RegistryKey serviceKey;  	// Check if the service key exists so that we don't delete it   	// later if it does.  	if (Array.Exists<string> (servicesKey.GetSubKeyNames ()' keyName => (string.Compare (keyName' serviceName' true) == 0))) {  		serviceKeyCreated = false;  	}  	else {  		serviceKeyCreated = true;  		// Create the service key.  		serviceKey = servicesKey.CreateSubKey (serviceName);  		serviceKey.SetValue ("ErrorControl"' 1' RegistryValueKind.DWord);  		serviceKey.SetValue ("ImagePath"' "\\??\\" + moduleItem.FileName' RegistryValueKind.ExpandString);  		serviceKey.SetValue ("Start"' 1' RegistryValueKind.DWord);  		serviceKey.SetValue ("Type"' 1' RegistryValueKind.DWord);  		serviceKey.Close ();  		servicesKey.Flush ();  	}  	try {  		Windows.UnloadDriver (serviceName);  	}  	finally {  		if (serviceKeyCreated)  			servicesKey.DeleteSubKeyTree (serviceName);  		servicesKey.Close ();  	}  	listModules.SelectedItems.Clear ();  }  catch (Exception ex) {  	MessageBox.Show ("Unable to unload the driver. Make sure Process Hacker " + "is running with administrative privileges. Error:\n\n" + ex.Message' "Process Hacker"' MessageBoxButtons.OK' MessageBoxIcon.Error);  }  
Magic Number,ProcessHacker.Components,ModuleList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ModuleList.cs,unloadMenuItem_Click,The following statement contains a magic number: if (serviceName == null) {  	if (moduleItem.Name.EndsWith (".sys"' StringComparison.OrdinalIgnoreCase))  		serviceName = moduleItem.Name.Remove (moduleItem.Name.Length - 4' 4);  	else  		serviceName = moduleItem.Name;  }  
Magic Number,ProcessHacker.Components,ModuleList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ModuleList.cs,unloadMenuItem_Click,The following statement contains a magic number: if (serviceName == null) {  	if (moduleItem.Name.EndsWith (".sys"' StringComparison.OrdinalIgnoreCase))  		serviceName = moduleItem.Name.Remove (moduleItem.Name.Length - 4' 4);  	else  		serviceName = moduleItem.Name;  }  
Magic Number,ProcessHacker.Components,ModuleList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ModuleList.cs,unloadMenuItem_Click,The following statement contains a magic number: if (moduleItem.Name.EndsWith (".sys"' StringComparison.OrdinalIgnoreCase))  	serviceName = moduleItem.Name.Remove (moduleItem.Name.Length - 4' 4);  else  	serviceName = moduleItem.Name;  
Magic Number,ProcessHacker.Components,ModuleList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ModuleList.cs,unloadMenuItem_Click,The following statement contains a magic number: if (moduleItem.Name.EndsWith (".sys"' StringComparison.OrdinalIgnoreCase))  	serviceName = moduleItem.Name.Remove (moduleItem.Name.Length - 4' 4);  else  	serviceName = moduleItem.Name;  
Magic Number,ProcessHacker.Components,ModuleList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ModuleList.cs,unloadMenuItem_Click,The following statement contains a magic number: serviceName = moduleItem.Name.Remove (moduleItem.Name.Length - 4' 4);  
Magic Number,ProcessHacker.Components,ModuleList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ModuleList.cs,unloadMenuItem_Click,The following statement contains a magic number: serviceName = moduleItem.Name.Remove (moduleItem.Name.Length - 4' 4);  
Magic Number,ProcessHacker.Components,ModuleList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ModuleList.cs,unloadMenuItem_Click,The following statement contains a magic number: try {  	using (ProcessHandle phandle = new ProcessHandle (_pid' Program.MinProcessQueryRights | ProcessAccess.VmOperation | ProcessAccess.VmRead | ProcessAccess.VmWrite | ProcessAccess.CreateThread)) {  		IntPtr baseAddress = ((ModuleItem)listModules.SelectedItems [0].Tag).BaseAddress.ToIntPtr ();  		phandle.SetModuleReferenceCount (baseAddress' 1);  		ThreadHandle thread;  		if (OSVersion.IsAboveOrEqual (WindowsVersion.Vista)) {  			// Use RtlCreateUserThread to bypass session boundaries. Since   			// LdrUnloadDll is a native function we don't need to notify CSR.  			thread = phandle.CreateThread (Loader.GetProcedure ("ntdll.dll"' "LdrUnloadDll")' baseAddress);  		}  		else {  			// On XP it seems we need to notify CSR...  			thread = phandle.CreateThreadWin32 (Loader.GetProcedure ("kernel32.dll"' "FreeLibrary")' baseAddress);  		}  		thread.Wait (1000 * Win32.TimeMsTo100Ns);  		NtStatus exitStatus = thread.GetExitStatus ();  		if (exitStatus == NtStatus.DllNotFound) {  			if (OSVersion.Architecture == OSArch.Amd64) {  				PhUtils.ShowError ("Unable to find the module to unload. This may be caused " + "by an attempt to unload a mapped file or a 32-bit module.");  			}  			else {  				PhUtils.ShowError ("Unable to find the module to unload. This may be caused " + "by an attempt to unload a mapped file.");  			}  		}  		else {  			exitStatus.ThrowIf ();  		}  		thread.Dispose ();  	}  	listModules.SelectedItems.Clear ();  }  catch (Exception ex) {  	PhUtils.ShowException ("Unable to unload the module"' ex);  }  
Magic Number,ProcessHacker.Components,ModuleList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ModuleList.cs,unloadMenuItem_Click,The following statement contains a magic number: using (ProcessHandle phandle = new ProcessHandle (_pid' Program.MinProcessQueryRights | ProcessAccess.VmOperation | ProcessAccess.VmRead | ProcessAccess.VmWrite | ProcessAccess.CreateThread)) {  	IntPtr baseAddress = ((ModuleItem)listModules.SelectedItems [0].Tag).BaseAddress.ToIntPtr ();  	phandle.SetModuleReferenceCount (baseAddress' 1);  	ThreadHandle thread;  	if (OSVersion.IsAboveOrEqual (WindowsVersion.Vista)) {  		// Use RtlCreateUserThread to bypass session boundaries. Since   		// LdrUnloadDll is a native function we don't need to notify CSR.  		thread = phandle.CreateThread (Loader.GetProcedure ("ntdll.dll"' "LdrUnloadDll")' baseAddress);  	}  	else {  		// On XP it seems we need to notify CSR...  		thread = phandle.CreateThreadWin32 (Loader.GetProcedure ("kernel32.dll"' "FreeLibrary")' baseAddress);  	}  	thread.Wait (1000 * Win32.TimeMsTo100Ns);  	NtStatus exitStatus = thread.GetExitStatus ();  	if (exitStatus == NtStatus.DllNotFound) {  		if (OSVersion.Architecture == OSArch.Amd64) {  			PhUtils.ShowError ("Unable to find the module to unload. This may be caused " + "by an attempt to unload a mapped file or a 32-bit module.");  		}  		else {  			PhUtils.ShowError ("Unable to find the module to unload. This may be caused " + "by an attempt to unload a mapped file.");  		}  	}  	else {  		exitStatus.ThrowIf ();  	}  	thread.Dispose ();  }  
Magic Number,ProcessHacker.Components,ModuleList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ModuleList.cs,unloadMenuItem_Click,The following statement contains a magic number: thread.Wait (1000 * Win32.TimeMsTo100Ns);  
Magic Number,ProcessHacker.Components,HandleList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\HandleList.cs,HandleList,The following statement contains a magic number: comparer.ColumnSortOrder.Add (2);  
Magic Number,ProcessHacker.Components,HandleList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\HandleList.cs,closeHandleMenuItem_Click,The following statement contains a magic number: lock (_listLock) {  	bool allGood = true;  	foreach (ListViewItem item in listHandles.SelectedItems) {  		try {  			IntPtr handle = new IntPtr ((int)BaseConverter.ToNumberParse (item.SubItems [2].Text));  			using (ProcessHandle process = new ProcessHandle (_pid' Program.MinProcessGetHandleInformationRights)) {  				Win32.DuplicateObject (process.Handle' handle' 0' 0' DuplicateOptions.CloseSource);  			}  		}  		catch (Exception ex) {  			allGood = false;  			if (!PhUtils.ShowContinueMessage ("Unable to close the handle \"" + item.SubItems [1].Text + "\""' ex))  				return;  		}  	}  	if (allGood) {  		foreach (ListViewItem item in listHandles.SelectedItems)  			item.Selected = false;  	}  }  
Magic Number,ProcessHacker.Components,HandleList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\HandleList.cs,closeHandleMenuItem_Click,The following statement contains a magic number: foreach (ListViewItem item in listHandles.SelectedItems) {  	try {  		IntPtr handle = new IntPtr ((int)BaseConverter.ToNumberParse (item.SubItems [2].Text));  		using (ProcessHandle process = new ProcessHandle (_pid' Program.MinProcessGetHandleInformationRights)) {  			Win32.DuplicateObject (process.Handle' handle' 0' 0' DuplicateOptions.CloseSource);  		}  	}  	catch (Exception ex) {  		allGood = false;  		if (!PhUtils.ShowContinueMessage ("Unable to close the handle \"" + item.SubItems [1].Text + "\""' ex))  			return;  	}  }  
Magic Number,ProcessHacker.Components,HandleList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\HandleList.cs,closeHandleMenuItem_Click,The following statement contains a magic number: try {  	IntPtr handle = new IntPtr ((int)BaseConverter.ToNumberParse (item.SubItems [2].Text));  	using (ProcessHandle process = new ProcessHandle (_pid' Program.MinProcessGetHandleInformationRights)) {  		Win32.DuplicateObject (process.Handle' handle' 0' 0' DuplicateOptions.CloseSource);  	}  }  catch (Exception ex) {  	allGood = false;  	if (!PhUtils.ShowContinueMessage ("Unable to close the handle \"" + item.SubItems [1].Text + "\""' ex))  		return;  }  
Magic Number,ProcessHacker.Components,ServiceList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ServiceList.cs,provider_DictionaryModified,The following statement contains a magic number: lock (listServices) {  	ListViewItem litem = listServices.Items [newItem.Status.ServiceName];  	if (litem == null)  		return;  	litem.SubItems [1].Text = newItem.Status.DisplayName;  	litem.SubItems [2].Text = newItem.Status.ServiceStatusProcess.ServiceType.ToString ();  	litem.SubItems [3].Text = newItem.Status.ServiceStatusProcess.CurrentState.ToString ();  	litem.SubItems [4].Text = newItem.Config.StartType.ToString ();  	litem.SubItems [5].Text = newItem.Status.ServiceStatusProcess.ProcessID == 0 ? "" : newItem.Status.ServiceStatusProcess.ProcessID.ToString ();  	_needsSort = true;  }  
Magic Number,ProcessHacker.Components,ServiceList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ServiceList.cs,provider_DictionaryModified,The following statement contains a magic number: lock (listServices) {  	ListViewItem litem = listServices.Items [newItem.Status.ServiceName];  	if (litem == null)  		return;  	litem.SubItems [1].Text = newItem.Status.DisplayName;  	litem.SubItems [2].Text = newItem.Status.ServiceStatusProcess.ServiceType.ToString ();  	litem.SubItems [3].Text = newItem.Status.ServiceStatusProcess.CurrentState.ToString ();  	litem.SubItems [4].Text = newItem.Config.StartType.ToString ();  	litem.SubItems [5].Text = newItem.Status.ServiceStatusProcess.ProcessID == 0 ? "" : newItem.Status.ServiceStatusProcess.ProcessID.ToString ();  	_needsSort = true;  }  
Magic Number,ProcessHacker.Components,ServiceList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ServiceList.cs,provider_DictionaryModified,The following statement contains a magic number: lock (listServices) {  	ListViewItem litem = listServices.Items [newItem.Status.ServiceName];  	if (litem == null)  		return;  	litem.SubItems [1].Text = newItem.Status.DisplayName;  	litem.SubItems [2].Text = newItem.Status.ServiceStatusProcess.ServiceType.ToString ();  	litem.SubItems [3].Text = newItem.Status.ServiceStatusProcess.CurrentState.ToString ();  	litem.SubItems [4].Text = newItem.Config.StartType.ToString ();  	litem.SubItems [5].Text = newItem.Status.ServiceStatusProcess.ProcessID == 0 ? "" : newItem.Status.ServiceStatusProcess.ProcessID.ToString ();  	_needsSort = true;  }  
Magic Number,ProcessHacker.Components,ServiceList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ServiceList.cs,provider_DictionaryModified,The following statement contains a magic number: lock (listServices) {  	ListViewItem litem = listServices.Items [newItem.Status.ServiceName];  	if (litem == null)  		return;  	litem.SubItems [1].Text = newItem.Status.DisplayName;  	litem.SubItems [2].Text = newItem.Status.ServiceStatusProcess.ServiceType.ToString ();  	litem.SubItems [3].Text = newItem.Status.ServiceStatusProcess.CurrentState.ToString ();  	litem.SubItems [4].Text = newItem.Config.StartType.ToString ();  	litem.SubItems [5].Text = newItem.Status.ServiceStatusProcess.ProcessID == 0 ? "" : newItem.Status.ServiceStatusProcess.ProcessID.ToString ();  	_needsSort = true;  }  
Magic Number,ProcessHacker.Components,ServiceList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ServiceList.cs,provider_DictionaryModified,The following statement contains a magic number: litem.SubItems [2].Text = newItem.Status.ServiceStatusProcess.ServiceType.ToString ();  
Magic Number,ProcessHacker.Components,ServiceList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ServiceList.cs,provider_DictionaryModified,The following statement contains a magic number: litem.SubItems [3].Text = newItem.Status.ServiceStatusProcess.CurrentState.ToString ();  
Magic Number,ProcessHacker.Components,ServiceList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ServiceList.cs,provider_DictionaryModified,The following statement contains a magic number: litem.SubItems [4].Text = newItem.Config.StartType.ToString ();  
Magic Number,ProcessHacker.Components,ServiceList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ServiceList.cs,provider_DictionaryModified,The following statement contains a magic number: litem.SubItems [5].Text = newItem.Status.ServiceStatusProcess.ProcessID == 0 ? "" : newItem.Status.ServiceStatusProcess.ProcessID.ToString ();  
Magic Number,ProcessHacker.Components,Plotter,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\Plotter.cs,Draw,The following statement contains a magic number: while (start < _data1.Count - 1) {  	float f = _data1 [start + 1];  	float fPre = _data1 [start];  	int h = (int)(tHeight - (tHeight * f));  	int hPre = (int)(tHeight - (tHeight * fPre));  	// Fill in the area below the line.  	g.FillPolygon (new SolidBrush (Color.FromArgb (100' _lineColor1))' new Point[] {  		new Point (px' h)'  		new Point (px + moveStep' hPre)'  		new Point (px + moveStep' tHeight)'  		new Point (px' tHeight)  	});  	g.DrawLine (lGrid1' px' h' px + moveStep' hPre);  	if (this.UseSecondLine) {  		f = _data2 [start + 1];  		fPre = _data2 [start];  		if (!this.OverlaySecondLine) {  			f += _data1 [start + 1];  			fPre += _data1 [start];  			if (f > 1.0f)  				f = 1.0f;  			if (fPre > 1.0f)  				fPre = 1.0f;  		}  		h = (int)(tHeight - (tHeight * f));  		hPre = (int)(tHeight - (tHeight * fPre));  		// Draw the second line.  		if (this.OverlaySecondLine) {  			g.FillPolygon (new SolidBrush (Color.FromArgb (100' _lineColor2))' new Point[] {  				new Point (px' h)'  				new Point (px + moveStep' hPre)'  				new Point (px + moveStep' tHeight)'  				new Point (px' tHeight)  			});  			g.DrawLine (lGrid2' px' h' px + moveStep' hPre);  		}  		else {  			g.FillPolygon (new SolidBrush (Color.FromArgb (100' _lineColor2))' new Point[] {  				new Point (px' h)'  				new Point (px + moveStep' hPre)'  				new Point (px + moveStep' tHeight - (int)(tHeight * _data1 [start]))'  				new Point (px' tHeight - (int)(tHeight * _data1 [start + 1]))  			});  			g.DrawLine (lGrid2' px' h' px + moveStep' hPre);  		}  	}  	if (px < 0) {  		break;  	}  	px -= moveStep;  	start++;  }  
Magic Number,ProcessHacker.Components,Plotter,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\Plotter.cs,Draw,The following statement contains a magic number: while (start < _data1.Count - 1) {  	float f = _data1 [start + 1];  	float fPre = _data1 [start];  	int h = (int)(tHeight - (tHeight * f));  	int hPre = (int)(tHeight - (tHeight * fPre));  	// Fill in the area below the line.  	g.FillPolygon (new SolidBrush (Color.FromArgb (100' _lineColor1))' new Point[] {  		new Point (px' h)'  		new Point (px + moveStep' hPre)'  		new Point (px + moveStep' tHeight)'  		new Point (px' tHeight)  	});  	g.DrawLine (lGrid1' px' h' px + moveStep' hPre);  	if (this.UseSecondLine) {  		f = _data2 [start + 1];  		fPre = _data2 [start];  		if (!this.OverlaySecondLine) {  			f += _data1 [start + 1];  			fPre += _data1 [start];  			if (f > 1.0f)  				f = 1.0f;  			if (fPre > 1.0f)  				fPre = 1.0f;  		}  		h = (int)(tHeight - (tHeight * f));  		hPre = (int)(tHeight - (tHeight * fPre));  		// Draw the second line.  		if (this.OverlaySecondLine) {  			g.FillPolygon (new SolidBrush (Color.FromArgb (100' _lineColor2))' new Point[] {  				new Point (px' h)'  				new Point (px + moveStep' hPre)'  				new Point (px + moveStep' tHeight)'  				new Point (px' tHeight)  			});  			g.DrawLine (lGrid2' px' h' px + moveStep' hPre);  		}  		else {  			g.FillPolygon (new SolidBrush (Color.FromArgb (100' _lineColor2))' new Point[] {  				new Point (px' h)'  				new Point (px + moveStep' hPre)'  				new Point (px + moveStep' tHeight - (int)(tHeight * _data1 [start]))'  				new Point (px' tHeight - (int)(tHeight * _data1 [start + 1]))  			});  			g.DrawLine (lGrid2' px' h' px + moveStep' hPre);  		}  	}  	if (px < 0) {  		break;  	}  	px -= moveStep;  	start++;  }  
Magic Number,ProcessHacker.Components,Plotter,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\Plotter.cs,Draw,The following statement contains a magic number: while (start < _data1.Count - 1) {  	float f = _data1 [start + 1];  	float fPre = _data1 [start];  	int h = (int)(tHeight - (tHeight * f));  	int hPre = (int)(tHeight - (tHeight * fPre));  	// Fill in the area below the line.  	g.FillPolygon (new SolidBrush (Color.FromArgb (100' _lineColor1))' new Point[] {  		new Point (px' h)'  		new Point (px + moveStep' hPre)'  		new Point (px + moveStep' tHeight)'  		new Point (px' tHeight)  	});  	g.DrawLine (lGrid1' px' h' px + moveStep' hPre);  	if (this.UseSecondLine) {  		f = _data2 [start + 1];  		fPre = _data2 [start];  		if (!this.OverlaySecondLine) {  			f += _data1 [start + 1];  			fPre += _data1 [start];  			if (f > 1.0f)  				f = 1.0f;  			if (fPre > 1.0f)  				fPre = 1.0f;  		}  		h = (int)(tHeight - (tHeight * f));  		hPre = (int)(tHeight - (tHeight * fPre));  		// Draw the second line.  		if (this.OverlaySecondLine) {  			g.FillPolygon (new SolidBrush (Color.FromArgb (100' _lineColor2))' new Point[] {  				new Point (px' h)'  				new Point (px + moveStep' hPre)'  				new Point (px + moveStep' tHeight)'  				new Point (px' tHeight)  			});  			g.DrawLine (lGrid2' px' h' px + moveStep' hPre);  		}  		else {  			g.FillPolygon (new SolidBrush (Color.FromArgb (100' _lineColor2))' new Point[] {  				new Point (px' h)'  				new Point (px + moveStep' hPre)'  				new Point (px + moveStep' tHeight - (int)(tHeight * _data1 [start]))'  				new Point (px' tHeight - (int)(tHeight * _data1 [start + 1]))  			});  			g.DrawLine (lGrid2' px' h' px + moveStep' hPre);  		}  	}  	if (px < 0) {  		break;  	}  	px -= moveStep;  	start++;  }  
Magic Number,ProcessHacker.Components,Plotter,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\Plotter.cs,Draw,The following statement contains a magic number: g.FillPolygon (new SolidBrush (Color.FromArgb (100' _lineColor1))' new Point[] {  	new Point (px' h)'  	new Point (px + moveStep' hPre)'  	new Point (px + moveStep' tHeight)'  	new Point (px' tHeight)  });  
Magic Number,ProcessHacker.Components,Plotter,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\Plotter.cs,Draw,The following statement contains a magic number: if (this.UseSecondLine) {  	f = _data2 [start + 1];  	fPre = _data2 [start];  	if (!this.OverlaySecondLine) {  		f += _data1 [start + 1];  		fPre += _data1 [start];  		if (f > 1.0f)  			f = 1.0f;  		if (fPre > 1.0f)  			fPre = 1.0f;  	}  	h = (int)(tHeight - (tHeight * f));  	hPre = (int)(tHeight - (tHeight * fPre));  	// Draw the second line.  	if (this.OverlaySecondLine) {  		g.FillPolygon (new SolidBrush (Color.FromArgb (100' _lineColor2))' new Point[] {  			new Point (px' h)'  			new Point (px + moveStep' hPre)'  			new Point (px + moveStep' tHeight)'  			new Point (px' tHeight)  		});  		g.DrawLine (lGrid2' px' h' px + moveStep' hPre);  	}  	else {  		g.FillPolygon (new SolidBrush (Color.FromArgb (100' _lineColor2))' new Point[] {  			new Point (px' h)'  			new Point (px + moveStep' hPre)'  			new Point (px + moveStep' tHeight - (int)(tHeight * _data1 [start]))'  			new Point (px' tHeight - (int)(tHeight * _data1 [start + 1]))  		});  		g.DrawLine (lGrid2' px' h' px + moveStep' hPre);  	}  }  
Magic Number,ProcessHacker.Components,Plotter,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\Plotter.cs,Draw,The following statement contains a magic number: if (this.UseSecondLine) {  	f = _data2 [start + 1];  	fPre = _data2 [start];  	if (!this.OverlaySecondLine) {  		f += _data1 [start + 1];  		fPre += _data1 [start];  		if (f > 1.0f)  			f = 1.0f;  		if (fPre > 1.0f)  			fPre = 1.0f;  	}  	h = (int)(tHeight - (tHeight * f));  	hPre = (int)(tHeight - (tHeight * fPre));  	// Draw the second line.  	if (this.OverlaySecondLine) {  		g.FillPolygon (new SolidBrush (Color.FromArgb (100' _lineColor2))' new Point[] {  			new Point (px' h)'  			new Point (px + moveStep' hPre)'  			new Point (px + moveStep' tHeight)'  			new Point (px' tHeight)  		});  		g.DrawLine (lGrid2' px' h' px + moveStep' hPre);  	}  	else {  		g.FillPolygon (new SolidBrush (Color.FromArgb (100' _lineColor2))' new Point[] {  			new Point (px' h)'  			new Point (px + moveStep' hPre)'  			new Point (px + moveStep' tHeight - (int)(tHeight * _data1 [start]))'  			new Point (px' tHeight - (int)(tHeight * _data1 [start + 1]))  		});  		g.DrawLine (lGrid2' px' h' px + moveStep' hPre);  	}  }  
Magic Number,ProcessHacker.Components,Plotter,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\Plotter.cs,Draw,The following statement contains a magic number: if (this.OverlaySecondLine) {  	g.FillPolygon (new SolidBrush (Color.FromArgb (100' _lineColor2))' new Point[] {  		new Point (px' h)'  		new Point (px + moveStep' hPre)'  		new Point (px + moveStep' tHeight)'  		new Point (px' tHeight)  	});  	g.DrawLine (lGrid2' px' h' px + moveStep' hPre);  }  else {  	g.FillPolygon (new SolidBrush (Color.FromArgb (100' _lineColor2))' new Point[] {  		new Point (px' h)'  		new Point (px + moveStep' hPre)'  		new Point (px + moveStep' tHeight - (int)(tHeight * _data1 [start]))'  		new Point (px' tHeight - (int)(tHeight * _data1 [start + 1]))  	});  	g.DrawLine (lGrid2' px' h' px + moveStep' hPre);  }  
Magic Number,ProcessHacker.Components,Plotter,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\Plotter.cs,Draw,The following statement contains a magic number: if (this.OverlaySecondLine) {  	g.FillPolygon (new SolidBrush (Color.FromArgb (100' _lineColor2))' new Point[] {  		new Point (px' h)'  		new Point (px + moveStep' hPre)'  		new Point (px + moveStep' tHeight)'  		new Point (px' tHeight)  	});  	g.DrawLine (lGrid2' px' h' px + moveStep' hPre);  }  else {  	g.FillPolygon (new SolidBrush (Color.FromArgb (100' _lineColor2))' new Point[] {  		new Point (px' h)'  		new Point (px + moveStep' hPre)'  		new Point (px + moveStep' tHeight - (int)(tHeight * _data1 [start]))'  		new Point (px' tHeight - (int)(tHeight * _data1 [start + 1]))  	});  	g.DrawLine (lGrid2' px' h' px + moveStep' hPre);  }  
Magic Number,ProcessHacker.Components,Plotter,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\Plotter.cs,Draw,The following statement contains a magic number: g.FillPolygon (new SolidBrush (Color.FromArgb (100' _lineColor2))' new Point[] {  	new Point (px' h)'  	new Point (px + moveStep' hPre)'  	new Point (px + moveStep' tHeight)'  	new Point (px' tHeight)  });  
Magic Number,ProcessHacker.Components,Plotter,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\Plotter.cs,Draw,The following statement contains a magic number: g.FillPolygon (new SolidBrush (Color.FromArgb (100' _lineColor2))' new Point[] {  	new Point (px' h)'  	new Point (px + moveStep' hPre)'  	new Point (px + moveStep' tHeight - (int)(tHeight * _data1 [start]))'  	new Point (px' tHeight - (int)(tHeight * _data1 [start + 1]))  });  
Magic Number,ProcessHacker.Components,Plotter,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\Plotter.cs,ShowToolTip,The following statement contains a magic number: if (this.GetToolTip != null) {  	int itemIndex = (this.Width - _mouseLocation.X) / this.EffectiveMoveStep;  	if (itemIndex < this.Data1.Count) {  		try {  			string currentToolTip = this.GetToolTip (itemIndex);  			if (currentToolTip != _lastToolTip || force)  				toolTip.Show (currentToolTip' this' new Point (_mouseLocation.X + 10' _mouseLocation.Y + 10)' int.MaxValue);  			_lastToolTip = currentToolTip;  		}  		catch (Exception ex) {  			Logging.Log (ex);  		}  	}  	else {  		toolTip.Hide (this);  	}  }  
Magic Number,ProcessHacker.Components,Plotter,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\Plotter.cs,ShowToolTip,The following statement contains a magic number: if (this.GetToolTip != null) {  	int itemIndex = (this.Width - _mouseLocation.X) / this.EffectiveMoveStep;  	if (itemIndex < this.Data1.Count) {  		try {  			string currentToolTip = this.GetToolTip (itemIndex);  			if (currentToolTip != _lastToolTip || force)  				toolTip.Show (currentToolTip' this' new Point (_mouseLocation.X + 10' _mouseLocation.Y + 10)' int.MaxValue);  			_lastToolTip = currentToolTip;  		}  		catch (Exception ex) {  			Logging.Log (ex);  		}  	}  	else {  		toolTip.Hide (this);  	}  }  
Magic Number,ProcessHacker.Components,Plotter,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\Plotter.cs,ShowToolTip,The following statement contains a magic number: if (itemIndex < this.Data1.Count) {  	try {  		string currentToolTip = this.GetToolTip (itemIndex);  		if (currentToolTip != _lastToolTip || force)  			toolTip.Show (currentToolTip' this' new Point (_mouseLocation.X + 10' _mouseLocation.Y + 10)' int.MaxValue);  		_lastToolTip = currentToolTip;  	}  	catch (Exception ex) {  		Logging.Log (ex);  	}  }  else {  	toolTip.Hide (this);  }  
Magic Number,ProcessHacker.Components,Plotter,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\Plotter.cs,ShowToolTip,The following statement contains a magic number: if (itemIndex < this.Data1.Count) {  	try {  		string currentToolTip = this.GetToolTip (itemIndex);  		if (currentToolTip != _lastToolTip || force)  			toolTip.Show (currentToolTip' this' new Point (_mouseLocation.X + 10' _mouseLocation.Y + 10)' int.MaxValue);  		_lastToolTip = currentToolTip;  	}  	catch (Exception ex) {  		Logging.Log (ex);  	}  }  else {  	toolTip.Hide (this);  }  
Magic Number,ProcessHacker.Components,Plotter,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\Plotter.cs,ShowToolTip,The following statement contains a magic number: try {  	string currentToolTip = this.GetToolTip (itemIndex);  	if (currentToolTip != _lastToolTip || force)  		toolTip.Show (currentToolTip' this' new Point (_mouseLocation.X + 10' _mouseLocation.Y + 10)' int.MaxValue);  	_lastToolTip = currentToolTip;  }  catch (Exception ex) {  	Logging.Log (ex);  }  
Magic Number,ProcessHacker.Components,Plotter,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\Plotter.cs,ShowToolTip,The following statement contains a magic number: try {  	string currentToolTip = this.GetToolTip (itemIndex);  	if (currentToolTip != _lastToolTip || force)  		toolTip.Show (currentToolTip' this' new Point (_mouseLocation.X + 10' _mouseLocation.Y + 10)' int.MaxValue);  	_lastToolTip = currentToolTip;  }  catch (Exception ex) {  	Logging.Log (ex);  }  
Magic Number,ProcessHacker.Components,Plotter,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\Plotter.cs,ShowToolTip,The following statement contains a magic number: if (currentToolTip != _lastToolTip || force)  	toolTip.Show (currentToolTip' this' new Point (_mouseLocation.X + 10' _mouseLocation.Y + 10)' int.MaxValue);  
Magic Number,ProcessHacker.Components,Plotter,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\Plotter.cs,ShowToolTip,The following statement contains a magic number: if (currentToolTip != _lastToolTip || force)  	toolTip.Show (currentToolTip' this' new Point (_mouseLocation.X + 10' _mouseLocation.Y + 10)' int.MaxValue);  
Magic Number,ProcessHacker.Components,Plotter,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\Plotter.cs,ShowToolTip,The following statement contains a magic number: toolTip.Show (currentToolTip' this' new Point (_mouseLocation.X + 10' _mouseLocation.Y + 10)' int.MaxValue);  
Magic Number,ProcessHacker.Components,Plotter,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\Plotter.cs,ShowToolTip,The following statement contains a magic number: toolTip.Show (currentToolTip' this' new Point (_mouseLocation.X + 10' _mouseLocation.Y + 10)' int.MaxValue);  
Magic Number,ProcessHacker.Components,ServiceProperties,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ServiceProperties.cs,_provider_DictionaryModified,The following statement contains a magic number: this.BeginInvoke (new MethodInvoker (() =>  {  	// update the state of the service  	if (listServices.Items.ContainsKey (newItem.Status.ServiceName))  		listServices.Items [newItem.Status.ServiceName].SubItems [2].Text = newItem.Status.ServiceStatusProcess.CurrentState.ToString ();  	// update the start and stop buttons if we have a service selected  	if (listServices.SelectedItems.Count == 1) {  		if (listServices.SelectedItems [0].Name == newItem.Status.ServiceName) {  			buttonStart.Enabled = false;  			buttonStop.Enabled = false;  			if (newItem.Status.ServiceStatusProcess.CurrentState == ServiceState.Running)  				buttonStop.Enabled = true;  			else if (newItem.Status.ServiceStatusProcess.CurrentState == ServiceState.Stopped)  				buttonStart.Enabled = true;  		}  	}  	// if the service was just started in this process' add it to the list  	if (newItem.Status.ServiceStatusProcess.ProcessID == this.PID && oldItem.Status.ServiceStatusProcess.ProcessID == 0) {  		if (!listServices.Items.ContainsKey (newItem.Status.ServiceName)) {  			listServices.Items.Add (new ListViewItem (new string[] {  				newItem.Status.ServiceName'  				newItem.Status.DisplayName'  				newItem.Status.ServiceStatusProcess.CurrentState.ToString ()  			})).Name = newItem.Status.ServiceName;  		}  	}  }));  
Magic Number,ProcessHacker.Components,ServiceProperties,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ServiceProperties.cs,_provider_DictionaryModified,The following statement contains a magic number: if (listServices.Items.ContainsKey (newItem.Status.ServiceName))  	listServices.Items [newItem.Status.ServiceName].SubItems [2].Text = newItem.Status.ServiceStatusProcess.CurrentState.ToString ();  
Magic Number,ProcessHacker.Components,ServiceProperties,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ServiceProperties.cs,_provider_DictionaryModified,The following statement contains a magic number: listServices.Items [newItem.Status.ServiceName].SubItems [2].Text = newItem.Status.ServiceStatusProcess.CurrentState.ToString ();  
Magic Number,ProcessHacker.Components,ServiceProperties,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ServiceProperties.cs,buttonApply_Click,The following statement contains a magic number: try {  	string serviceName = listServices.SelectedItems [0].Name;  	ProcessHacker.Native.Api.ServiceType type;  	if (comboType.SelectedItem.ToString () == "Win32OwnProcess' InteractiveProcess")  		type = ProcessHacker.Native.Api.ServiceType.Win32OwnProcess | ProcessHacker.Native.Api.ServiceType.InteractiveProcess;  	else if (comboType.SelectedItem.ToString () == "Win32ShareProcess' InteractiveProcess")  		type = ProcessHacker.Native.Api.ServiceType.Win32ShareProcess | ProcessHacker.Native.Api.ServiceType.InteractiveProcess;  	else  		type = (ProcessHacker.Native.Api.ServiceType)Enum.Parse (typeof(ProcessHacker.Native.Api.ServiceType)' comboType.SelectedItem.ToString ());  	string binaryPath = textServiceBinaryPath.Text;  	string loadOrderGroup = textLoadOrderGroup.Text;  	string userAccount = textUserAccount.Text;  	string password = textPassword.Text;  	var startType = (ServiceStartType)Enum.Parse (typeof(ServiceStartType)' comboStartType.SelectedItem.ToString ());  	var errorControl = (ServiceErrorControl)Enum.Parse (typeof(ServiceErrorControl)' comboErrorControl.SelectedItem.ToString ());  	// Only change the items which the user modified.  	if (binaryPath == _oldConfig.BinaryPathName)  		binaryPath = null;  	if (loadOrderGroup == _oldConfig.LoadOrderGroup)  		loadOrderGroup = null;  	if (userAccount == _oldConfig.ServiceStartName)  		userAccount = null;  	if (!checkChangePassword.Checked)  		password = null;  	if (type == ProcessHacker.Native.Api.ServiceType.KernelDriver || type == ProcessHacker.Native.Api.ServiceType.FileSystemDriver)  		userAccount = null;  	if (Program.ElevationType == TokenElevationType.Full) {  		using (var shandle = new ServiceHandle (serviceName' ServiceAccess.ChangeConfig)) {  			if (!Win32.ChangeServiceConfig (shandle.Handle' type' startType' errorControl' binaryPath' loadOrderGroup' IntPtr.Zero' null' userAccount' password' null))  				Win32.Throw ();  		}  	}  	else {  		string args = "-e -type service -action config -obj \"" + serviceName + "\" -hwnd " + this.Handle.ToString ();  		args += " -servicetype \"" + comboType.SelectedItem.ToString () + "\"";  		args += " -servicestarttype \"" + comboStartType.SelectedItem.ToString () + "\"";  		args += " -serviceerrorcontrol \"" + comboErrorControl.SelectedItem.ToString () + "\"";  		if (binaryPath != null)  			args += " -servicebinarypath \"" + binaryPath.Replace ("\""' "\\\"") + "\"";  		if (loadOrderGroup != null)  			args += " -serviceloadordergroup \"" + loadOrderGroup.Replace ("\""' "\\\"") + "\"";  		if (userAccount != null)  			args += " -serviceuseraccount \"" + userAccount.Replace ("\""' "\\\"") + "\"";  		if (password != null)  			args += " -servicepassword \"" + password.Replace ("\""' "\\\"") + "\"";  		var result = Program.StartProcessHackerAdminWait (args' this.Handle' 2000);  		if (result == WaitResult.Timeout || result == WaitResult.Abandoned)  			return;  	}  	using (var shandle = new ServiceHandle (serviceName' ServiceAccess.QueryConfig))  		_provider.UpdateServiceConfig (serviceName' shandle.GetConfig ());  	if (listServices.Items.Count == 1)  		this.Close ();  }  catch (Exception ex) {  	PhUtils.ShowException ("Unable to change service configuration"' ex);  }  
Magic Number,ProcessHacker.Components,ServiceProperties,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ServiceProperties.cs,buttonApply_Click,The following statement contains a magic number: if (Program.ElevationType == TokenElevationType.Full) {  	using (var shandle = new ServiceHandle (serviceName' ServiceAccess.ChangeConfig)) {  		if (!Win32.ChangeServiceConfig (shandle.Handle' type' startType' errorControl' binaryPath' loadOrderGroup' IntPtr.Zero' null' userAccount' password' null))  			Win32.Throw ();  	}  }  else {  	string args = "-e -type service -action config -obj \"" + serviceName + "\" -hwnd " + this.Handle.ToString ();  	args += " -servicetype \"" + comboType.SelectedItem.ToString () + "\"";  	args += " -servicestarttype \"" + comboStartType.SelectedItem.ToString () + "\"";  	args += " -serviceerrorcontrol \"" + comboErrorControl.SelectedItem.ToString () + "\"";  	if (binaryPath != null)  		args += " -servicebinarypath \"" + binaryPath.Replace ("\""' "\\\"") + "\"";  	if (loadOrderGroup != null)  		args += " -serviceloadordergroup \"" + loadOrderGroup.Replace ("\""' "\\\"") + "\"";  	if (userAccount != null)  		args += " -serviceuseraccount \"" + userAccount.Replace ("\""' "\\\"") + "\"";  	if (password != null)  		args += " -servicepassword \"" + password.Replace ("\""' "\\\"") + "\"";  	var result = Program.StartProcessHackerAdminWait (args' this.Handle' 2000);  	if (result == WaitResult.Timeout || result == WaitResult.Abandoned)  		return;  }  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,ThreadList,The following statement contains a magic number: comparer.CustomSorters.Add (3' (x' y) =>  {  	return (x.Tag as ThreadItem).PriorityI.CompareTo ((y.Tag as ThreadItem).PriorityI);  });  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,ThreadList,The following statement contains a magic number: comparer.ColumnSortOrder.Add (2);  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,ThreadList,The following statement contains a magic number: comparer.ColumnSortOrder.Add (3);  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,EnableDisableMenuItems,The following statement contains a magic number: if (// If KProcessHacker isn't available' hide Force Terminate.  KProcessHacker.Instance != null && // Terminating a system thread is the same as Force Terminate'   // so hide it if we're viewing PID 4.  _pid != 4)  	forceTerminateThreadMenuItem.Visible = true;  else  	forceTerminateThreadMenuItem.Visible = false;  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,provider_DictionaryModified,The following statement contains a magic number: this.BeginInvoke (new MethodInvoker (() =>  {  	lock (listThreads) {  		ListViewItem litem = listThreads.Items [newItem.Tid.ToString ()];  		if (litem == null)  			return;  		if (!_useCycleTime) {  			if (newItem.ContextSwitchesDelta == 0)  				litem.SubItems [1].Text = "";  			else  				litem.SubItems [1].Text = newItem.ContextSwitchesDelta.ToString ("N0");  		}  		else {  			if (newItem.CyclesDelta == 0)  				litem.SubItems [1].Text = "";  			else  				litem.SubItems [1].Text = newItem.CyclesDelta.ToString ("N0");  		}  		litem.SubItems [2].Text = newItem.StartAddress;  		litem.SubItems [3].Text = newItem.Priority;  		litem.Tag = newItem;  		(litem as HighlightedListViewItem).NormalColor = GetThreadColor (newItem);  		_needsSort = true;  	}  }));  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,provider_DictionaryModified,The following statement contains a magic number: this.BeginInvoke (new MethodInvoker (() =>  {  	lock (listThreads) {  		ListViewItem litem = listThreads.Items [newItem.Tid.ToString ()];  		if (litem == null)  			return;  		if (!_useCycleTime) {  			if (newItem.ContextSwitchesDelta == 0)  				litem.SubItems [1].Text = "";  			else  				litem.SubItems [1].Text = newItem.ContextSwitchesDelta.ToString ("N0");  		}  		else {  			if (newItem.CyclesDelta == 0)  				litem.SubItems [1].Text = "";  			else  				litem.SubItems [1].Text = newItem.CyclesDelta.ToString ("N0");  		}  		litem.SubItems [2].Text = newItem.StartAddress;  		litem.SubItems [3].Text = newItem.Priority;  		litem.Tag = newItem;  		(litem as HighlightedListViewItem).NormalColor = GetThreadColor (newItem);  		_needsSort = true;  	}  }));  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,provider_DictionaryModified,The following statement contains a magic number: lock (listThreads) {  	ListViewItem litem = listThreads.Items [newItem.Tid.ToString ()];  	if (litem == null)  		return;  	if (!_useCycleTime) {  		if (newItem.ContextSwitchesDelta == 0)  			litem.SubItems [1].Text = "";  		else  			litem.SubItems [1].Text = newItem.ContextSwitchesDelta.ToString ("N0");  	}  	else {  		if (newItem.CyclesDelta == 0)  			litem.SubItems [1].Text = "";  		else  			litem.SubItems [1].Text = newItem.CyclesDelta.ToString ("N0");  	}  	litem.SubItems [2].Text = newItem.StartAddress;  	litem.SubItems [3].Text = newItem.Priority;  	litem.Tag = newItem;  	(litem as HighlightedListViewItem).NormalColor = GetThreadColor (newItem);  	_needsSort = true;  }  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,provider_DictionaryModified,The following statement contains a magic number: lock (listThreads) {  	ListViewItem litem = listThreads.Items [newItem.Tid.ToString ()];  	if (litem == null)  		return;  	if (!_useCycleTime) {  		if (newItem.ContextSwitchesDelta == 0)  			litem.SubItems [1].Text = "";  		else  			litem.SubItems [1].Text = newItem.ContextSwitchesDelta.ToString ("N0");  	}  	else {  		if (newItem.CyclesDelta == 0)  			litem.SubItems [1].Text = "";  		else  			litem.SubItems [1].Text = newItem.CyclesDelta.ToString ("N0");  	}  	litem.SubItems [2].Text = newItem.StartAddress;  	litem.SubItems [3].Text = newItem.Priority;  	litem.Tag = newItem;  	(litem as HighlightedListViewItem).NormalColor = GetThreadColor (newItem);  	_needsSort = true;  }  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,provider_DictionaryModified,The following statement contains a magic number: litem.SubItems [2].Text = newItem.StartAddress;  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,provider_DictionaryModified,The following statement contains a magic number: litem.SubItems [3].Text = newItem.Priority;  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,menuThread_Popup,The following statement contains a magic number: if (listThreads.SelectedItems.Count == 0) {  	menuThread.DisableAll ();  	return;  }  else if (listThreads.SelectedItems.Count == 1) {  	menuThread.EnableAll ();  	terminateThreadMenuItem.Text = "&Terminate Thread";  	forceTerminateThreadMenuItem.Text = "Force Terminate Thread";  	suspendThreadMenuItem.Text = "&Suspend Thread";  	resumeThreadMenuItem.Text = "&Resume Thread";  	priorityThreadMenuItem.Text = "&Priority";  	timeCriticalThreadMenuItem.Checked = false;  	highestThreadMenuItem.Checked = false;  	aboveNormalThreadMenuItem.Checked = false;  	normalThreadMenuItem.Checked = false;  	belowNormalThreadMenuItem.Checked = false;  	lowestThreadMenuItem.Checked = false;  	idleThreadMenuItem.Checked = false;  	ioPriority0ThreadMenuItem.Checked = false;  	ioPriority1ThreadMenuItem.Checked = false;  	ioPriority2ThreadMenuItem.Checked = false;  	ioPriority3ThreadMenuItem.Checked = false;  	try {  		using (var thandle = new ThreadHandle (int.Parse (listThreads.SelectedItems [0].SubItems [0].Text)' Program.MinThreadQueryRights)) {  			try {  				switch (thandle.GetBasePriorityWin32 ()) {  				case ThreadPriorityLevel.TimeCritical:  					timeCriticalThreadMenuItem.Checked = true;  					break;  				case ThreadPriorityLevel.Highest:  					highestThreadMenuItem.Checked = true;  					break;  				case ThreadPriorityLevel.AboveNormal:  					aboveNormalThreadMenuItem.Checked = true;  					break;  				case ThreadPriorityLevel.Normal:  					normalThreadMenuItem.Checked = true;  					break;  				case ThreadPriorityLevel.BelowNormal:  					belowNormalThreadMenuItem.Checked = true;  					break;  				case ThreadPriorityLevel.Lowest:  					lowestThreadMenuItem.Checked = true;  					break;  				case ThreadPriorityLevel.Idle:  					idleThreadMenuItem.Checked = true;  					break;  				}  			}  			catch {  				priorityThreadMenuItem.Enabled = false;  			}  			try {  				if (OSVersion.HasIoPriority) {  					switch (thandle.GetIoPriority ()) {  					case 0:  						ioPriority0ThreadMenuItem.Checked = true;  						break;  					case 1:  						ioPriority1ThreadMenuItem.Checked = true;  						break;  					case 2:  						ioPriority2ThreadMenuItem.Checked = true;  						break;  					case 3:  						ioPriority3ThreadMenuItem.Checked = true;  						break;  					}  				}  			}  			catch {  				ioPriorityThreadMenuItem.Enabled = false;  			}  		}  	}  	catch {  		priorityThreadMenuItem.Enabled = false;  		ioPriorityThreadMenuItem.Enabled = false;  	}  	try {  		using (ThreadHandle thandle = new ThreadHandle (int.Parse (listThreads.SelectedItems [0].Text)' Program.MinThreadQueryRights)) {  			using (TokenHandle tokenHandle = thandle.GetToken (TokenAccess.Query)) {  				tokenThreadMenuItem.Enabled = true;  			}  		}  	}  	catch (WindowsException) {  		tokenThreadMenuItem.Enabled = false;  	}  }  else {  	menuThread.DisableAll ();  	terminateThreadMenuItem.Enabled = true;  	forceTerminateThreadMenuItem.Enabled = true;  	suspendThreadMenuItem.Enabled = true;  	resumeThreadMenuItem.Enabled = true;  	terminateThreadMenuItem.Text = "&Terminate Threads";  	forceTerminateThreadMenuItem.Text = "Force Terminate Threads";  	suspendThreadMenuItem.Text = "&Suspend Threads";  	resumeThreadMenuItem.Text = "&Resume Threads";  	copyThreadMenuItem.Enabled = true;  }  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,menuThread_Popup,The following statement contains a magic number: if (listThreads.SelectedItems.Count == 0) {  	menuThread.DisableAll ();  	return;  }  else if (listThreads.SelectedItems.Count == 1) {  	menuThread.EnableAll ();  	terminateThreadMenuItem.Text = "&Terminate Thread";  	forceTerminateThreadMenuItem.Text = "Force Terminate Thread";  	suspendThreadMenuItem.Text = "&Suspend Thread";  	resumeThreadMenuItem.Text = "&Resume Thread";  	priorityThreadMenuItem.Text = "&Priority";  	timeCriticalThreadMenuItem.Checked = false;  	highestThreadMenuItem.Checked = false;  	aboveNormalThreadMenuItem.Checked = false;  	normalThreadMenuItem.Checked = false;  	belowNormalThreadMenuItem.Checked = false;  	lowestThreadMenuItem.Checked = false;  	idleThreadMenuItem.Checked = false;  	ioPriority0ThreadMenuItem.Checked = false;  	ioPriority1ThreadMenuItem.Checked = false;  	ioPriority2ThreadMenuItem.Checked = false;  	ioPriority3ThreadMenuItem.Checked = false;  	try {  		using (var thandle = new ThreadHandle (int.Parse (listThreads.SelectedItems [0].SubItems [0].Text)' Program.MinThreadQueryRights)) {  			try {  				switch (thandle.GetBasePriorityWin32 ()) {  				case ThreadPriorityLevel.TimeCritical:  					timeCriticalThreadMenuItem.Checked = true;  					break;  				case ThreadPriorityLevel.Highest:  					highestThreadMenuItem.Checked = true;  					break;  				case ThreadPriorityLevel.AboveNormal:  					aboveNormalThreadMenuItem.Checked = true;  					break;  				case ThreadPriorityLevel.Normal:  					normalThreadMenuItem.Checked = true;  					break;  				case ThreadPriorityLevel.BelowNormal:  					belowNormalThreadMenuItem.Checked = true;  					break;  				case ThreadPriorityLevel.Lowest:  					lowestThreadMenuItem.Checked = true;  					break;  				case ThreadPriorityLevel.Idle:  					idleThreadMenuItem.Checked = true;  					break;  				}  			}  			catch {  				priorityThreadMenuItem.Enabled = false;  			}  			try {  				if (OSVersion.HasIoPriority) {  					switch (thandle.GetIoPriority ()) {  					case 0:  						ioPriority0ThreadMenuItem.Checked = true;  						break;  					case 1:  						ioPriority1ThreadMenuItem.Checked = true;  						break;  					case 2:  						ioPriority2ThreadMenuItem.Checked = true;  						break;  					case 3:  						ioPriority3ThreadMenuItem.Checked = true;  						break;  					}  				}  			}  			catch {  				ioPriorityThreadMenuItem.Enabled = false;  			}  		}  	}  	catch {  		priorityThreadMenuItem.Enabled = false;  		ioPriorityThreadMenuItem.Enabled = false;  	}  	try {  		using (ThreadHandle thandle = new ThreadHandle (int.Parse (listThreads.SelectedItems [0].Text)' Program.MinThreadQueryRights)) {  			using (TokenHandle tokenHandle = thandle.GetToken (TokenAccess.Query)) {  				tokenThreadMenuItem.Enabled = true;  			}  		}  	}  	catch (WindowsException) {  		tokenThreadMenuItem.Enabled = false;  	}  }  else {  	menuThread.DisableAll ();  	terminateThreadMenuItem.Enabled = true;  	forceTerminateThreadMenuItem.Enabled = true;  	suspendThreadMenuItem.Enabled = true;  	resumeThreadMenuItem.Enabled = true;  	terminateThreadMenuItem.Text = "&Terminate Threads";  	forceTerminateThreadMenuItem.Text = "Force Terminate Threads";  	suspendThreadMenuItem.Text = "&Suspend Threads";  	resumeThreadMenuItem.Text = "&Resume Threads";  	copyThreadMenuItem.Enabled = true;  }  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,menuThread_Popup,The following statement contains a magic number: if (listThreads.SelectedItems.Count == 1) {  	menuThread.EnableAll ();  	terminateThreadMenuItem.Text = "&Terminate Thread";  	forceTerminateThreadMenuItem.Text = "Force Terminate Thread";  	suspendThreadMenuItem.Text = "&Suspend Thread";  	resumeThreadMenuItem.Text = "&Resume Thread";  	priorityThreadMenuItem.Text = "&Priority";  	timeCriticalThreadMenuItem.Checked = false;  	highestThreadMenuItem.Checked = false;  	aboveNormalThreadMenuItem.Checked = false;  	normalThreadMenuItem.Checked = false;  	belowNormalThreadMenuItem.Checked = false;  	lowestThreadMenuItem.Checked = false;  	idleThreadMenuItem.Checked = false;  	ioPriority0ThreadMenuItem.Checked = false;  	ioPriority1ThreadMenuItem.Checked = false;  	ioPriority2ThreadMenuItem.Checked = false;  	ioPriority3ThreadMenuItem.Checked = false;  	try {  		using (var thandle = new ThreadHandle (int.Parse (listThreads.SelectedItems [0].SubItems [0].Text)' Program.MinThreadQueryRights)) {  			try {  				switch (thandle.GetBasePriorityWin32 ()) {  				case ThreadPriorityLevel.TimeCritical:  					timeCriticalThreadMenuItem.Checked = true;  					break;  				case ThreadPriorityLevel.Highest:  					highestThreadMenuItem.Checked = true;  					break;  				case ThreadPriorityLevel.AboveNormal:  					aboveNormalThreadMenuItem.Checked = true;  					break;  				case ThreadPriorityLevel.Normal:  					normalThreadMenuItem.Checked = true;  					break;  				case ThreadPriorityLevel.BelowNormal:  					belowNormalThreadMenuItem.Checked = true;  					break;  				case ThreadPriorityLevel.Lowest:  					lowestThreadMenuItem.Checked = true;  					break;  				case ThreadPriorityLevel.Idle:  					idleThreadMenuItem.Checked = true;  					break;  				}  			}  			catch {  				priorityThreadMenuItem.Enabled = false;  			}  			try {  				if (OSVersion.HasIoPriority) {  					switch (thandle.GetIoPriority ()) {  					case 0:  						ioPriority0ThreadMenuItem.Checked = true;  						break;  					case 1:  						ioPriority1ThreadMenuItem.Checked = true;  						break;  					case 2:  						ioPriority2ThreadMenuItem.Checked = true;  						break;  					case 3:  						ioPriority3ThreadMenuItem.Checked = true;  						break;  					}  				}  			}  			catch {  				ioPriorityThreadMenuItem.Enabled = false;  			}  		}  	}  	catch {  		priorityThreadMenuItem.Enabled = false;  		ioPriorityThreadMenuItem.Enabled = false;  	}  	try {  		using (ThreadHandle thandle = new ThreadHandle (int.Parse (listThreads.SelectedItems [0].Text)' Program.MinThreadQueryRights)) {  			using (TokenHandle tokenHandle = thandle.GetToken (TokenAccess.Query)) {  				tokenThreadMenuItem.Enabled = true;  			}  		}  	}  	catch (WindowsException) {  		tokenThreadMenuItem.Enabled = false;  	}  }  else {  	menuThread.DisableAll ();  	terminateThreadMenuItem.Enabled = true;  	forceTerminateThreadMenuItem.Enabled = true;  	suspendThreadMenuItem.Enabled = true;  	resumeThreadMenuItem.Enabled = true;  	terminateThreadMenuItem.Text = "&Terminate Threads";  	forceTerminateThreadMenuItem.Text = "Force Terminate Threads";  	suspendThreadMenuItem.Text = "&Suspend Threads";  	resumeThreadMenuItem.Text = "&Resume Threads";  	copyThreadMenuItem.Enabled = true;  }  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,menuThread_Popup,The following statement contains a magic number: if (listThreads.SelectedItems.Count == 1) {  	menuThread.EnableAll ();  	terminateThreadMenuItem.Text = "&Terminate Thread";  	forceTerminateThreadMenuItem.Text = "Force Terminate Thread";  	suspendThreadMenuItem.Text = "&Suspend Thread";  	resumeThreadMenuItem.Text = "&Resume Thread";  	priorityThreadMenuItem.Text = "&Priority";  	timeCriticalThreadMenuItem.Checked = false;  	highestThreadMenuItem.Checked = false;  	aboveNormalThreadMenuItem.Checked = false;  	normalThreadMenuItem.Checked = false;  	belowNormalThreadMenuItem.Checked = false;  	lowestThreadMenuItem.Checked = false;  	idleThreadMenuItem.Checked = false;  	ioPriority0ThreadMenuItem.Checked = false;  	ioPriority1ThreadMenuItem.Checked = false;  	ioPriority2ThreadMenuItem.Checked = false;  	ioPriority3ThreadMenuItem.Checked = false;  	try {  		using (var thandle = new ThreadHandle (int.Parse (listThreads.SelectedItems [0].SubItems [0].Text)' Program.MinThreadQueryRights)) {  			try {  				switch (thandle.GetBasePriorityWin32 ()) {  				case ThreadPriorityLevel.TimeCritical:  					timeCriticalThreadMenuItem.Checked = true;  					break;  				case ThreadPriorityLevel.Highest:  					highestThreadMenuItem.Checked = true;  					break;  				case ThreadPriorityLevel.AboveNormal:  					aboveNormalThreadMenuItem.Checked = true;  					break;  				case ThreadPriorityLevel.Normal:  					normalThreadMenuItem.Checked = true;  					break;  				case ThreadPriorityLevel.BelowNormal:  					belowNormalThreadMenuItem.Checked = true;  					break;  				case ThreadPriorityLevel.Lowest:  					lowestThreadMenuItem.Checked = true;  					break;  				case ThreadPriorityLevel.Idle:  					idleThreadMenuItem.Checked = true;  					break;  				}  			}  			catch {  				priorityThreadMenuItem.Enabled = false;  			}  			try {  				if (OSVersion.HasIoPriority) {  					switch (thandle.GetIoPriority ()) {  					case 0:  						ioPriority0ThreadMenuItem.Checked = true;  						break;  					case 1:  						ioPriority1ThreadMenuItem.Checked = true;  						break;  					case 2:  						ioPriority2ThreadMenuItem.Checked = true;  						break;  					case 3:  						ioPriority3ThreadMenuItem.Checked = true;  						break;  					}  				}  			}  			catch {  				ioPriorityThreadMenuItem.Enabled = false;  			}  		}  	}  	catch {  		priorityThreadMenuItem.Enabled = false;  		ioPriorityThreadMenuItem.Enabled = false;  	}  	try {  		using (ThreadHandle thandle = new ThreadHandle (int.Parse (listThreads.SelectedItems [0].Text)' Program.MinThreadQueryRights)) {  			using (TokenHandle tokenHandle = thandle.GetToken (TokenAccess.Query)) {  				tokenThreadMenuItem.Enabled = true;  			}  		}  	}  	catch (WindowsException) {  		tokenThreadMenuItem.Enabled = false;  	}  }  else {  	menuThread.DisableAll ();  	terminateThreadMenuItem.Enabled = true;  	forceTerminateThreadMenuItem.Enabled = true;  	suspendThreadMenuItem.Enabled = true;  	resumeThreadMenuItem.Enabled = true;  	terminateThreadMenuItem.Text = "&Terminate Threads";  	forceTerminateThreadMenuItem.Text = "Force Terminate Threads";  	suspendThreadMenuItem.Text = "&Suspend Threads";  	resumeThreadMenuItem.Text = "&Resume Threads";  	copyThreadMenuItem.Enabled = true;  }  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,menuThread_Popup,The following statement contains a magic number: try {  	using (var thandle = new ThreadHandle (int.Parse (listThreads.SelectedItems [0].SubItems [0].Text)' Program.MinThreadQueryRights)) {  		try {  			switch (thandle.GetBasePriorityWin32 ()) {  			case ThreadPriorityLevel.TimeCritical:  				timeCriticalThreadMenuItem.Checked = true;  				break;  			case ThreadPriorityLevel.Highest:  				highestThreadMenuItem.Checked = true;  				break;  			case ThreadPriorityLevel.AboveNormal:  				aboveNormalThreadMenuItem.Checked = true;  				break;  			case ThreadPriorityLevel.Normal:  				normalThreadMenuItem.Checked = true;  				break;  			case ThreadPriorityLevel.BelowNormal:  				belowNormalThreadMenuItem.Checked = true;  				break;  			case ThreadPriorityLevel.Lowest:  				lowestThreadMenuItem.Checked = true;  				break;  			case ThreadPriorityLevel.Idle:  				idleThreadMenuItem.Checked = true;  				break;  			}  		}  		catch {  			priorityThreadMenuItem.Enabled = false;  		}  		try {  			if (OSVersion.HasIoPriority) {  				switch (thandle.GetIoPriority ()) {  				case 0:  					ioPriority0ThreadMenuItem.Checked = true;  					break;  				case 1:  					ioPriority1ThreadMenuItem.Checked = true;  					break;  				case 2:  					ioPriority2ThreadMenuItem.Checked = true;  					break;  				case 3:  					ioPriority3ThreadMenuItem.Checked = true;  					break;  				}  			}  		}  		catch {  			ioPriorityThreadMenuItem.Enabled = false;  		}  	}  }  catch {  	priorityThreadMenuItem.Enabled = false;  	ioPriorityThreadMenuItem.Enabled = false;  }  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,menuThread_Popup,The following statement contains a magic number: try {  	using (var thandle = new ThreadHandle (int.Parse (listThreads.SelectedItems [0].SubItems [0].Text)' Program.MinThreadQueryRights)) {  		try {  			switch (thandle.GetBasePriorityWin32 ()) {  			case ThreadPriorityLevel.TimeCritical:  				timeCriticalThreadMenuItem.Checked = true;  				break;  			case ThreadPriorityLevel.Highest:  				highestThreadMenuItem.Checked = true;  				break;  			case ThreadPriorityLevel.AboveNormal:  				aboveNormalThreadMenuItem.Checked = true;  				break;  			case ThreadPriorityLevel.Normal:  				normalThreadMenuItem.Checked = true;  				break;  			case ThreadPriorityLevel.BelowNormal:  				belowNormalThreadMenuItem.Checked = true;  				break;  			case ThreadPriorityLevel.Lowest:  				lowestThreadMenuItem.Checked = true;  				break;  			case ThreadPriorityLevel.Idle:  				idleThreadMenuItem.Checked = true;  				break;  			}  		}  		catch {  			priorityThreadMenuItem.Enabled = false;  		}  		try {  			if (OSVersion.HasIoPriority) {  				switch (thandle.GetIoPriority ()) {  				case 0:  					ioPriority0ThreadMenuItem.Checked = true;  					break;  				case 1:  					ioPriority1ThreadMenuItem.Checked = true;  					break;  				case 2:  					ioPriority2ThreadMenuItem.Checked = true;  					break;  				case 3:  					ioPriority3ThreadMenuItem.Checked = true;  					break;  				}  			}  		}  		catch {  			ioPriorityThreadMenuItem.Enabled = false;  		}  	}  }  catch {  	priorityThreadMenuItem.Enabled = false;  	ioPriorityThreadMenuItem.Enabled = false;  }  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,menuThread_Popup,The following statement contains a magic number: using (var thandle = new ThreadHandle (int.Parse (listThreads.SelectedItems [0].SubItems [0].Text)' Program.MinThreadQueryRights)) {  	try {  		switch (thandle.GetBasePriorityWin32 ()) {  		case ThreadPriorityLevel.TimeCritical:  			timeCriticalThreadMenuItem.Checked = true;  			break;  		case ThreadPriorityLevel.Highest:  			highestThreadMenuItem.Checked = true;  			break;  		case ThreadPriorityLevel.AboveNormal:  			aboveNormalThreadMenuItem.Checked = true;  			break;  		case ThreadPriorityLevel.Normal:  			normalThreadMenuItem.Checked = true;  			break;  		case ThreadPriorityLevel.BelowNormal:  			belowNormalThreadMenuItem.Checked = true;  			break;  		case ThreadPriorityLevel.Lowest:  			lowestThreadMenuItem.Checked = true;  			break;  		case ThreadPriorityLevel.Idle:  			idleThreadMenuItem.Checked = true;  			break;  		}  	}  	catch {  		priorityThreadMenuItem.Enabled = false;  	}  	try {  		if (OSVersion.HasIoPriority) {  			switch (thandle.GetIoPriority ()) {  			case 0:  				ioPriority0ThreadMenuItem.Checked = true;  				break;  			case 1:  				ioPriority1ThreadMenuItem.Checked = true;  				break;  			case 2:  				ioPriority2ThreadMenuItem.Checked = true;  				break;  			case 3:  				ioPriority3ThreadMenuItem.Checked = true;  				break;  			}  		}  	}  	catch {  		ioPriorityThreadMenuItem.Enabled = false;  	}  }  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,menuThread_Popup,The following statement contains a magic number: using (var thandle = new ThreadHandle (int.Parse (listThreads.SelectedItems [0].SubItems [0].Text)' Program.MinThreadQueryRights)) {  	try {  		switch (thandle.GetBasePriorityWin32 ()) {  		case ThreadPriorityLevel.TimeCritical:  			timeCriticalThreadMenuItem.Checked = true;  			break;  		case ThreadPriorityLevel.Highest:  			highestThreadMenuItem.Checked = true;  			break;  		case ThreadPriorityLevel.AboveNormal:  			aboveNormalThreadMenuItem.Checked = true;  			break;  		case ThreadPriorityLevel.Normal:  			normalThreadMenuItem.Checked = true;  			break;  		case ThreadPriorityLevel.BelowNormal:  			belowNormalThreadMenuItem.Checked = true;  			break;  		case ThreadPriorityLevel.Lowest:  			lowestThreadMenuItem.Checked = true;  			break;  		case ThreadPriorityLevel.Idle:  			idleThreadMenuItem.Checked = true;  			break;  		}  	}  	catch {  		priorityThreadMenuItem.Enabled = false;  	}  	try {  		if (OSVersion.HasIoPriority) {  			switch (thandle.GetIoPriority ()) {  			case 0:  				ioPriority0ThreadMenuItem.Checked = true;  				break;  			case 1:  				ioPriority1ThreadMenuItem.Checked = true;  				break;  			case 2:  				ioPriority2ThreadMenuItem.Checked = true;  				break;  			case 3:  				ioPriority3ThreadMenuItem.Checked = true;  				break;  			}  		}  	}  	catch {  		ioPriorityThreadMenuItem.Enabled = false;  	}  }  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,menuThread_Popup,The following statement contains a magic number: try {  	if (OSVersion.HasIoPriority) {  		switch (thandle.GetIoPriority ()) {  		case 0:  			ioPriority0ThreadMenuItem.Checked = true;  			break;  		case 1:  			ioPriority1ThreadMenuItem.Checked = true;  			break;  		case 2:  			ioPriority2ThreadMenuItem.Checked = true;  			break;  		case 3:  			ioPriority3ThreadMenuItem.Checked = true;  			break;  		}  	}  }  catch {  	ioPriorityThreadMenuItem.Enabled = false;  }  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,menuThread_Popup,The following statement contains a magic number: try {  	if (OSVersion.HasIoPriority) {  		switch (thandle.GetIoPriority ()) {  		case 0:  			ioPriority0ThreadMenuItem.Checked = true;  			break;  		case 1:  			ioPriority1ThreadMenuItem.Checked = true;  			break;  		case 2:  			ioPriority2ThreadMenuItem.Checked = true;  			break;  		case 3:  			ioPriority3ThreadMenuItem.Checked = true;  			break;  		}  	}  }  catch {  	ioPriorityThreadMenuItem.Enabled = false;  }  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,menuThread_Popup,The following statement contains a magic number: if (OSVersion.HasIoPriority) {  	switch (thandle.GetIoPriority ()) {  	case 0:  		ioPriority0ThreadMenuItem.Checked = true;  		break;  	case 1:  		ioPriority1ThreadMenuItem.Checked = true;  		break;  	case 2:  		ioPriority2ThreadMenuItem.Checked = true;  		break;  	case 3:  		ioPriority3ThreadMenuItem.Checked = true;  		break;  	}  }  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,menuThread_Popup,The following statement contains a magic number: if (OSVersion.HasIoPriority) {  	switch (thandle.GetIoPriority ()) {  	case 0:  		ioPriority0ThreadMenuItem.Checked = true;  		break;  	case 1:  		ioPriority1ThreadMenuItem.Checked = true;  		break;  	case 2:  		ioPriority2ThreadMenuItem.Checked = true;  		break;  	case 3:  		ioPriority3ThreadMenuItem.Checked = true;  		break;  	}  }  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,menuThread_Popup,The following statement contains a magic number: switch (thandle.GetIoPriority ()) {  case 0:  	ioPriority0ThreadMenuItem.Checked = true;  	break;  case 1:  	ioPriority1ThreadMenuItem.Checked = true;  	break;  case 2:  	ioPriority2ThreadMenuItem.Checked = true;  	break;  case 3:  	ioPriority3ThreadMenuItem.Checked = true;  	break;  }  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,menuThread_Popup,The following statement contains a magic number: switch (thandle.GetIoPriority ()) {  case 0:  	ioPriority0ThreadMenuItem.Checked = true;  	break;  case 1:  	ioPriority1ThreadMenuItem.Checked = true;  	break;  case 2:  	ioPriority2ThreadMenuItem.Checked = true;  	break;  case 3:  	ioPriority3ThreadMenuItem.Checked = true;  	break;  }  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,inspectThreadMenuItem_Click,The following statement contains a magic number: if (_pid == 4 && KProcessHacker.Instance == null) {  	PhUtils.ShowError ("Process Hacker cannot view system thread stacks without KProcessHacker. " + "Make sure Process Hacker has administrative privileges and KProcessHacker " + "supports your operating system.");  	return;  }  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,terminateThreadMenuItem_Click,The following statement contains a magic number: if (KProcessHacker.Instance != null && _pid == 4) {  	if (!PhUtils.ShowConfirmMessage ("terminate"' "the selected system thread(s)"' "Forcibly terminating system threads may cause the system to crash."' true))  		return;  	foreach (ListViewItem item in listThreads.SelectedItems) {  		int tid = Int32.Parse (item.SubItems [0].Text);  		try {  			using (var thandle = new ThreadHandle (tid' ThreadAccess.Terminate))  				thandle.DangerousTerminate (NtStatus.Success);  		}  		catch (Exception ex) {  			PhUtils.ShowException ("Unable to terminate the thread " + tid.ToString ()' ex);  		}  	}  	return;  }  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,analyzeWaitMenuItem_Click,The following statement contains a magic number: try {  	StringBuilder sb = new StringBuilder ();  	int tid = int.Parse (listThreads.SelectedItems [0].SubItems [0].Text);  	ProcessHandle phandle = null;  	if ((_provider.ProcessAccess & (ProcessAccess.QueryInformation | ProcessAccess.VmRead)) != 0)  		phandle = _provider.ProcessHandle;  	else  		phandle = new ProcessHandle (_pid' ProcessAccess.QueryInformation | ProcessAccess.VmRead);  	ProcessHandle processDupHandle = new ProcessHandle (_pid' ProcessAccess.DupHandle);  	bool found = false;  	using (var thandle = new ThreadHandle (tid' ThreadAccess.GetContext | ThreadAccess.SuspendResume)) {  		IntPtr[] lastParams = new IntPtr[4];  		thandle.WalkStack (phandle' stackFrame =>  {  			uint address = stackFrame.PcAddress.ToUInt32 ();  			string name = _provider.Symbols.GetSymbolFromAddress (address).ToLowerInvariant ();  			if (name == null) {  				// dummy  			}  			else if (name.StartsWith ("kernel32.dll!sleep")) {  				found = true;  				sb.Append ("Thread is sleeping. Timeout: " + stackFrame.Params [0].ToInt32 ().ToString () + " milliseconds");  			}  			else if (name.StartsWith ("ntdll.dll!zwdelayexecution") || name.StartsWith ("ntdll.dll!ntdelayexecution")) {  				found = true;  				bool alertable = stackFrame.Params [0].ToInt32 () != 0;  				IntPtr timeoutAddress = stackFrame.Params [1];  				long timeout;  				phandle.ReadMemory (timeoutAddress' &timeout' sizeof(long));  				if (timeout < 0) {  					sb.Append ("Thread is sleeping. Timeout: " + (new TimeSpan (-timeout)).TotalMilliseconds.ToString () + " milliseconds");  				}  				else {  					sb.AppendLine ("Thread is sleeping. Timeout: " + (new DateTime (timeout)).ToString ());  				}  			}  			else if (name.StartsWith ("ntdll.dll!zwdeviceiocontrolfile") || name.StartsWith ("ntdll.dll!ntdeviceiocontrolfile")) {  				found = true;  				IntPtr handle = stackFrame.Params [0];  				sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an I/O control request:");  				sb.AppendLine (this.GetHandleString (_pid' handle));  			}  			else if (name.StartsWith ("ntdll.dll!ntfscontrolfile") || name.StartsWith ("ntdll.dll!zwfscontrolfile")) {  				found = true;  				IntPtr handle = stackFrame.Params [0];  				sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an FS control request:");  				sb.AppendLine (this.GetHandleString (_pid' handle));  			}  			else if (name.StartsWith ("ntdll.dll!ntqueryobject") || name.StartsWith ("ntdll.dll!zwqueryobject")) {  				found = true;  				IntPtr handle = stackFrame.Params [0];  				// Use the KiFastSystemCallRet args if the handle we have is wrong.  				if (handle.ToInt32 () % 2 != 0 || handle == IntPtr.Zero)  					handle = lastParams [1];  				sb.AppendLine ("Thread " + tid.ToString () + " is querying an object (most likely a named pipe):");  				sb.AppendLine (this.GetHandleString (_pid' handle));  			}  			else if (name.StartsWith ("ntdll.dll!zwreadfile") || name.StartsWith ("ntdll.dll!ntreadfile") || name.StartsWith ("ntdll.dll!zwwritefile") || name.StartsWith ("ntdll.dll!ntwritefile")) {  				found = true;  				IntPtr handle = stackFrame.Params [0];  				sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a named pipe or a file:");  				sb.AppendLine (this.GetHandleString (_pid' handle));  			}  			else if (name.StartsWith ("ntdll.dll!zwremoveiocompletion") || name.StartsWith ("ntdll.dll!ntremoveiocompletion")) {  				found = true;  				IntPtr handle = stackFrame.Params [0];  				sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an I/O completion object:");  				sb.AppendLine (this.GetHandleString (_pid' handle));  			}  			else if (name.StartsWith ("ntdll.dll!zwreplywaitreceiveport") || name.StartsWith ("ntdll.dll!ntreplywaitreceiveport") || name.StartsWith ("ntdll.dll!zwrequestwaitreplyport") || name.StartsWith ("ntdll.dll!ntrequestwaitreplyport") || name.StartsWith ("ntdll.dll!zwalpcsendwaitreceiveport") || name.StartsWith ("ntdll.dll!ntalpcsendwaitreceiveport")) {  				found = true;  				IntPtr handle = stackFrame.Params [0];  				sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a LPC port:");  				sb.AppendLine (this.GetHandleString (_pid' handle));  			}  			else if (name.StartsWith ("ntdll.dll!zwsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!ntsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!zwsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!ntsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaithigheventpair") || name.StartsWith ("ntdll.dll!ntwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaitloweventpair") || name.StartsWith ("ntdll.dll!ntwaitloweventpair")) {  				found = true;  				IntPtr handle = stackFrame.Params [0];  				// Use the KiFastSystemCallRet args if the handle we have is wrong.  				if (handle.ToInt32 () % 2 != 0)  					handle = lastParams [1];  				sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for an event pair:");  				sb.AppendLine (this.GetHandleString (_pid' handle));  			}  			else if (name.StartsWith ("user32.dll!ntusergetmessage") || name.StartsWith ("user32.dll!ntuserwaitmessage")) {  				found = true;  				sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a USER message.");  			}  			else if (name.StartsWith ("ntdll.dll!zwwaitfordebugevent") || name.StartsWith ("ntdll.dll!ntwaitfordebugevent")) {  				found = true;  				IntPtr handle = stackFrame.Params [0];  				sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a debug event:");  				sb.AppendLine (this.GetHandleString (_pid' handle));  			}  			else if (name.StartsWith ("ntdll.dll!zwwaitforkeyedevent") || name.StartsWith ("ntdll.dll!ntwaitforkeyedevent") || name.StartsWith ("ntdll.dll!zwreleasekeyedevent") || name.StartsWith ("ntdll.dll!ntreleasekeyedevent")) {  				found = true;  				IntPtr handle = stackFrame.Params [0];  				IntPtr key = stackFrame.Params [1];  				sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for a keyed event (key 0x" + key.ToString ("x") + "):");  				sb.AppendLine (this.GetHandleString (_pid' handle));  			}  			else if (name.StartsWith ("ntdll.dll!zwwaitformultipleobjects") || name.StartsWith ("ntdll.dll!ntwaitformultipleobjects") || name.StartsWith ("kernel32.dll!waitformultipleobjects")) {  				found = true;  				int handleCount = stackFrame.Params [0].ToInt32 ();  				IntPtr handleAddress = stackFrame.Params [1];  				WaitType waitType = (WaitType)stackFrame.Params [2].ToInt32 ();  				bool alertable = stackFrame.Params [3].ToInt32 () != 0;  				// use the KiFastSystemCallRet args if we have the wrong args  				if (handleCount > 64) {  					handleCount = lastParams [1].ToInt32 ();  					handleAddress = lastParams [2];  					waitType = (WaitType)lastParams [3].ToInt32 ();  				}  				IntPtr* handles = stackalloc IntPtr[handleCount];  				phandle.ReadMemory (handleAddress' handles' handleCount * IntPtr.Size);  				sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + "' wait type: " + waitType.ToString () + ") for:");  				for (int i = 0; i < handleCount; i++) {  					sb.AppendLine (this.GetHandleString (_pid' handles [i]));  				}  			}  			else if (name.StartsWith ("ntdll.dll!zwwaitforsingleobject") || name.StartsWith ("ntdll.dll!ntwaitforsingleobject") || name.StartsWith ("kernel32.dll!waitforsingleobject")) {  				found = true;  				IntPtr handle = stackFrame.Params [0];  				bool alertable = stackFrame.Params [1].ToInt32 () != 0;  				sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + ") for:");  				sb.AppendLine (this.GetHandleString (_pid' handle));  			}  			else if (name.StartsWith ("ntdll.dll!zwwaitforworkviaworkerfactory") || name.StartsWith ("ntdll.dll!ntwaitforworkviaworkerfactory")) {  				found = true;  				IntPtr handle = stackFrame.Params [0];  				sb.AppendLine ("Thread " + tid.ToString () + " is waiting for work from a worker factory:");  				sb.AppendLine (this.GetHandleString (_pid' handle));  			}  			lastParams = stackFrame.Params;  			return !found;  		});  	}  	if (found) {  		ScratchpadWindow.Create (sb.ToString ());  	}  	else {  		PhUtils.ShowInformation ("The thread does not appear to be waiting.");  	}  }  catch (Exception ex) {  	PhUtils.ShowException ("Unable to analyze the thread"' ex);  }  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,analyzeWaitMenuItem_Click,The following statement contains a magic number: try {  	StringBuilder sb = new StringBuilder ();  	int tid = int.Parse (listThreads.SelectedItems [0].SubItems [0].Text);  	ProcessHandle phandle = null;  	if ((_provider.ProcessAccess & (ProcessAccess.QueryInformation | ProcessAccess.VmRead)) != 0)  		phandle = _provider.ProcessHandle;  	else  		phandle = new ProcessHandle (_pid' ProcessAccess.QueryInformation | ProcessAccess.VmRead);  	ProcessHandle processDupHandle = new ProcessHandle (_pid' ProcessAccess.DupHandle);  	bool found = false;  	using (var thandle = new ThreadHandle (tid' ThreadAccess.GetContext | ThreadAccess.SuspendResume)) {  		IntPtr[] lastParams = new IntPtr[4];  		thandle.WalkStack (phandle' stackFrame =>  {  			uint address = stackFrame.PcAddress.ToUInt32 ();  			string name = _provider.Symbols.GetSymbolFromAddress (address).ToLowerInvariant ();  			if (name == null) {  				// dummy  			}  			else if (name.StartsWith ("kernel32.dll!sleep")) {  				found = true;  				sb.Append ("Thread is sleeping. Timeout: " + stackFrame.Params [0].ToInt32 ().ToString () + " milliseconds");  			}  			else if (name.StartsWith ("ntdll.dll!zwdelayexecution") || name.StartsWith ("ntdll.dll!ntdelayexecution")) {  				found = true;  				bool alertable = stackFrame.Params [0].ToInt32 () != 0;  				IntPtr timeoutAddress = stackFrame.Params [1];  				long timeout;  				phandle.ReadMemory (timeoutAddress' &timeout' sizeof(long));  				if (timeout < 0) {  					sb.Append ("Thread is sleeping. Timeout: " + (new TimeSpan (-timeout)).TotalMilliseconds.ToString () + " milliseconds");  				}  				else {  					sb.AppendLine ("Thread is sleeping. Timeout: " + (new DateTime (timeout)).ToString ());  				}  			}  			else if (name.StartsWith ("ntdll.dll!zwdeviceiocontrolfile") || name.StartsWith ("ntdll.dll!ntdeviceiocontrolfile")) {  				found = true;  				IntPtr handle = stackFrame.Params [0];  				sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an I/O control request:");  				sb.AppendLine (this.GetHandleString (_pid' handle));  			}  			else if (name.StartsWith ("ntdll.dll!ntfscontrolfile") || name.StartsWith ("ntdll.dll!zwfscontrolfile")) {  				found = true;  				IntPtr handle = stackFrame.Params [0];  				sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an FS control request:");  				sb.AppendLine (this.GetHandleString (_pid' handle));  			}  			else if (name.StartsWith ("ntdll.dll!ntqueryobject") || name.StartsWith ("ntdll.dll!zwqueryobject")) {  				found = true;  				IntPtr handle = stackFrame.Params [0];  				// Use the KiFastSystemCallRet args if the handle we have is wrong.  				if (handle.ToInt32 () % 2 != 0 || handle == IntPtr.Zero)  					handle = lastParams [1];  				sb.AppendLine ("Thread " + tid.ToString () + " is querying an object (most likely a named pipe):");  				sb.AppendLine (this.GetHandleString (_pid' handle));  			}  			else if (name.StartsWith ("ntdll.dll!zwreadfile") || name.StartsWith ("ntdll.dll!ntreadfile") || name.StartsWith ("ntdll.dll!zwwritefile") || name.StartsWith ("ntdll.dll!ntwritefile")) {  				found = true;  				IntPtr handle = stackFrame.Params [0];  				sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a named pipe or a file:");  				sb.AppendLine (this.GetHandleString (_pid' handle));  			}  			else if (name.StartsWith ("ntdll.dll!zwremoveiocompletion") || name.StartsWith ("ntdll.dll!ntremoveiocompletion")) {  				found = true;  				IntPtr handle = stackFrame.Params [0];  				sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an I/O completion object:");  				sb.AppendLine (this.GetHandleString (_pid' handle));  			}  			else if (name.StartsWith ("ntdll.dll!zwreplywaitreceiveport") || name.StartsWith ("ntdll.dll!ntreplywaitreceiveport") || name.StartsWith ("ntdll.dll!zwrequestwaitreplyport") || name.StartsWith ("ntdll.dll!ntrequestwaitreplyport") || name.StartsWith ("ntdll.dll!zwalpcsendwaitreceiveport") || name.StartsWith ("ntdll.dll!ntalpcsendwaitreceiveport")) {  				found = true;  				IntPtr handle = stackFrame.Params [0];  				sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a LPC port:");  				sb.AppendLine (this.GetHandleString (_pid' handle));  			}  			else if (name.StartsWith ("ntdll.dll!zwsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!ntsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!zwsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!ntsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaithigheventpair") || name.StartsWith ("ntdll.dll!ntwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaitloweventpair") || name.StartsWith ("ntdll.dll!ntwaitloweventpair")) {  				found = true;  				IntPtr handle = stackFrame.Params [0];  				// Use the KiFastSystemCallRet args if the handle we have is wrong.  				if (handle.ToInt32 () % 2 != 0)  					handle = lastParams [1];  				sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for an event pair:");  				sb.AppendLine (this.GetHandleString (_pid' handle));  			}  			else if (name.StartsWith ("user32.dll!ntusergetmessage") || name.StartsWith ("user32.dll!ntuserwaitmessage")) {  				found = true;  				sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a USER message.");  			}  			else if (name.StartsWith ("ntdll.dll!zwwaitfordebugevent") || name.StartsWith ("ntdll.dll!ntwaitfordebugevent")) {  				found = true;  				IntPtr handle = stackFrame.Params [0];  				sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a debug event:");  				sb.AppendLine (this.GetHandleString (_pid' handle));  			}  			else if (name.StartsWith ("ntdll.dll!zwwaitforkeyedevent") || name.StartsWith ("ntdll.dll!ntwaitforkeyedevent") || name.StartsWith ("ntdll.dll!zwreleasekeyedevent") || name.StartsWith ("ntdll.dll!ntreleasekeyedevent")) {  				found = true;  				IntPtr handle = stackFrame.Params [0];  				IntPtr key = stackFrame.Params [1];  				sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for a keyed event (key 0x" + key.ToString ("x") + "):");  				sb.AppendLine (this.GetHandleString (_pid' handle));  			}  			else if (name.StartsWith ("ntdll.dll!zwwaitformultipleobjects") || name.StartsWith ("ntdll.dll!ntwaitformultipleobjects") || name.StartsWith ("kernel32.dll!waitformultipleobjects")) {  				found = true;  				int handleCount = stackFrame.Params [0].ToInt32 ();  				IntPtr handleAddress = stackFrame.Params [1];  				WaitType waitType = (WaitType)stackFrame.Params [2].ToInt32 ();  				bool alertable = stackFrame.Params [3].ToInt32 () != 0;  				// use the KiFastSystemCallRet args if we have the wrong args  				if (handleCount > 64) {  					handleCount = lastParams [1].ToInt32 ();  					handleAddress = lastParams [2];  					waitType = (WaitType)lastParams [3].ToInt32 ();  				}  				IntPtr* handles = stackalloc IntPtr[handleCount];  				phandle.ReadMemory (handleAddress' handles' handleCount * IntPtr.Size);  				sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + "' wait type: " + waitType.ToString () + ") for:");  				for (int i = 0; i < handleCount; i++) {  					sb.AppendLine (this.GetHandleString (_pid' handles [i]));  				}  			}  			else if (name.StartsWith ("ntdll.dll!zwwaitforsingleobject") || name.StartsWith ("ntdll.dll!ntwaitforsingleobject") || name.StartsWith ("kernel32.dll!waitforsingleobject")) {  				found = true;  				IntPtr handle = stackFrame.Params [0];  				bool alertable = stackFrame.Params [1].ToInt32 () != 0;  				sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + ") for:");  				sb.AppendLine (this.GetHandleString (_pid' handle));  			}  			else if (name.StartsWith ("ntdll.dll!zwwaitforworkviaworkerfactory") || name.StartsWith ("ntdll.dll!ntwaitforworkviaworkerfactory")) {  				found = true;  				IntPtr handle = stackFrame.Params [0];  				sb.AppendLine ("Thread " + tid.ToString () + " is waiting for work from a worker factory:");  				sb.AppendLine (this.GetHandleString (_pid' handle));  			}  			lastParams = stackFrame.Params;  			return !found;  		});  	}  	if (found) {  		ScratchpadWindow.Create (sb.ToString ());  	}  	else {  		PhUtils.ShowInformation ("The thread does not appear to be waiting.");  	}  }  catch (Exception ex) {  	PhUtils.ShowException ("Unable to analyze the thread"' ex);  }  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,analyzeWaitMenuItem_Click,The following statement contains a magic number: try {  	StringBuilder sb = new StringBuilder ();  	int tid = int.Parse (listThreads.SelectedItems [0].SubItems [0].Text);  	ProcessHandle phandle = null;  	if ((_provider.ProcessAccess & (ProcessAccess.QueryInformation | ProcessAccess.VmRead)) != 0)  		phandle = _provider.ProcessHandle;  	else  		phandle = new ProcessHandle (_pid' ProcessAccess.QueryInformation | ProcessAccess.VmRead);  	ProcessHandle processDupHandle = new ProcessHandle (_pid' ProcessAccess.DupHandle);  	bool found = false;  	using (var thandle = new ThreadHandle (tid' ThreadAccess.GetContext | ThreadAccess.SuspendResume)) {  		IntPtr[] lastParams = new IntPtr[4];  		thandle.WalkStack (phandle' stackFrame =>  {  			uint address = stackFrame.PcAddress.ToUInt32 ();  			string name = _provider.Symbols.GetSymbolFromAddress (address).ToLowerInvariant ();  			if (name == null) {  				// dummy  			}  			else if (name.StartsWith ("kernel32.dll!sleep")) {  				found = true;  				sb.Append ("Thread is sleeping. Timeout: " + stackFrame.Params [0].ToInt32 ().ToString () + " milliseconds");  			}  			else if (name.StartsWith ("ntdll.dll!zwdelayexecution") || name.StartsWith ("ntdll.dll!ntdelayexecution")) {  				found = true;  				bool alertable = stackFrame.Params [0].ToInt32 () != 0;  				IntPtr timeoutAddress = stackFrame.Params [1];  				long timeout;  				phandle.ReadMemory (timeoutAddress' &timeout' sizeof(long));  				if (timeout < 0) {  					sb.Append ("Thread is sleeping. Timeout: " + (new TimeSpan (-timeout)).TotalMilliseconds.ToString () + " milliseconds");  				}  				else {  					sb.AppendLine ("Thread is sleeping. Timeout: " + (new DateTime (timeout)).ToString ());  				}  			}  			else if (name.StartsWith ("ntdll.dll!zwdeviceiocontrolfile") || name.StartsWith ("ntdll.dll!ntdeviceiocontrolfile")) {  				found = true;  				IntPtr handle = stackFrame.Params [0];  				sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an I/O control request:");  				sb.AppendLine (this.GetHandleString (_pid' handle));  			}  			else if (name.StartsWith ("ntdll.dll!ntfscontrolfile") || name.StartsWith ("ntdll.dll!zwfscontrolfile")) {  				found = true;  				IntPtr handle = stackFrame.Params [0];  				sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an FS control request:");  				sb.AppendLine (this.GetHandleString (_pid' handle));  			}  			else if (name.StartsWith ("ntdll.dll!ntqueryobject") || name.StartsWith ("ntdll.dll!zwqueryobject")) {  				found = true;  				IntPtr handle = stackFrame.Params [0];  				// Use the KiFastSystemCallRet args if the handle we have is wrong.  				if (handle.ToInt32 () % 2 != 0 || handle == IntPtr.Zero)  					handle = lastParams [1];  				sb.AppendLine ("Thread " + tid.ToString () + " is querying an object (most likely a named pipe):");  				sb.AppendLine (this.GetHandleString (_pid' handle));  			}  			else if (name.StartsWith ("ntdll.dll!zwreadfile") || name.StartsWith ("ntdll.dll!ntreadfile") || name.StartsWith ("ntdll.dll!zwwritefile") || name.StartsWith ("ntdll.dll!ntwritefile")) {  				found = true;  				IntPtr handle = stackFrame.Params [0];  				sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a named pipe or a file:");  				sb.AppendLine (this.GetHandleString (_pid' handle));  			}  			else if (name.StartsWith ("ntdll.dll!zwremoveiocompletion") || name.StartsWith ("ntdll.dll!ntremoveiocompletion")) {  				found = true;  				IntPtr handle = stackFrame.Params [0];  				sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an I/O completion object:");  				sb.AppendLine (this.GetHandleString (_pid' handle));  			}  			else if (name.StartsWith ("ntdll.dll!zwreplywaitreceiveport") || name.StartsWith ("ntdll.dll!ntreplywaitreceiveport") || name.StartsWith ("ntdll.dll!zwrequestwaitreplyport") || name.StartsWith ("ntdll.dll!ntrequestwaitreplyport") || name.StartsWith ("ntdll.dll!zwalpcsendwaitreceiveport") || name.StartsWith ("ntdll.dll!ntalpcsendwaitreceiveport")) {  				found = true;  				IntPtr handle = stackFrame.Params [0];  				sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a LPC port:");  				sb.AppendLine (this.GetHandleString (_pid' handle));  			}  			else if (name.StartsWith ("ntdll.dll!zwsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!ntsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!zwsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!ntsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaithigheventpair") || name.StartsWith ("ntdll.dll!ntwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaitloweventpair") || name.StartsWith ("ntdll.dll!ntwaitloweventpair")) {  				found = true;  				IntPtr handle = stackFrame.Params [0];  				// Use the KiFastSystemCallRet args if the handle we have is wrong.  				if (handle.ToInt32 () % 2 != 0)  					handle = lastParams [1];  				sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for an event pair:");  				sb.AppendLine (this.GetHandleString (_pid' handle));  			}  			else if (name.StartsWith ("user32.dll!ntusergetmessage") || name.StartsWith ("user32.dll!ntuserwaitmessage")) {  				found = true;  				sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a USER message.");  			}  			else if (name.StartsWith ("ntdll.dll!zwwaitfordebugevent") || name.StartsWith ("ntdll.dll!ntwaitfordebugevent")) {  				found = true;  				IntPtr handle = stackFrame.Params [0];  				sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a debug event:");  				sb.AppendLine (this.GetHandleString (_pid' handle));  			}  			else if (name.StartsWith ("ntdll.dll!zwwaitforkeyedevent") || name.StartsWith ("ntdll.dll!ntwaitforkeyedevent") || name.StartsWith ("ntdll.dll!zwreleasekeyedevent") || name.StartsWith ("ntdll.dll!ntreleasekeyedevent")) {  				found = true;  				IntPtr handle = stackFrame.Params [0];  				IntPtr key = stackFrame.Params [1];  				sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for a keyed event (key 0x" + key.ToString ("x") + "):");  				sb.AppendLine (this.GetHandleString (_pid' handle));  			}  			else if (name.StartsWith ("ntdll.dll!zwwaitformultipleobjects") || name.StartsWith ("ntdll.dll!ntwaitformultipleobjects") || name.StartsWith ("kernel32.dll!waitformultipleobjects")) {  				found = true;  				int handleCount = stackFrame.Params [0].ToInt32 ();  				IntPtr handleAddress = stackFrame.Params [1];  				WaitType waitType = (WaitType)stackFrame.Params [2].ToInt32 ();  				bool alertable = stackFrame.Params [3].ToInt32 () != 0;  				// use the KiFastSystemCallRet args if we have the wrong args  				if (handleCount > 64) {  					handleCount = lastParams [1].ToInt32 ();  					handleAddress = lastParams [2];  					waitType = (WaitType)lastParams [3].ToInt32 ();  				}  				IntPtr* handles = stackalloc IntPtr[handleCount];  				phandle.ReadMemory (handleAddress' handles' handleCount * IntPtr.Size);  				sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + "' wait type: " + waitType.ToString () + ") for:");  				for (int i = 0; i < handleCount; i++) {  					sb.AppendLine (this.GetHandleString (_pid' handles [i]));  				}  			}  			else if (name.StartsWith ("ntdll.dll!zwwaitforsingleobject") || name.StartsWith ("ntdll.dll!ntwaitforsingleobject") || name.StartsWith ("kernel32.dll!waitforsingleobject")) {  				found = true;  				IntPtr handle = stackFrame.Params [0];  				bool alertable = stackFrame.Params [1].ToInt32 () != 0;  				sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + ") for:");  				sb.AppendLine (this.GetHandleString (_pid' handle));  			}  			else if (name.StartsWith ("ntdll.dll!zwwaitforworkviaworkerfactory") || name.StartsWith ("ntdll.dll!ntwaitforworkviaworkerfactory")) {  				found = true;  				IntPtr handle = stackFrame.Params [0];  				sb.AppendLine ("Thread " + tid.ToString () + " is waiting for work from a worker factory:");  				sb.AppendLine (this.GetHandleString (_pid' handle));  			}  			lastParams = stackFrame.Params;  			return !found;  		});  	}  	if (found) {  		ScratchpadWindow.Create (sb.ToString ());  	}  	else {  		PhUtils.ShowInformation ("The thread does not appear to be waiting.");  	}  }  catch (Exception ex) {  	PhUtils.ShowException ("Unable to analyze the thread"' ex);  }  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,analyzeWaitMenuItem_Click,The following statement contains a magic number: try {  	StringBuilder sb = new StringBuilder ();  	int tid = int.Parse (listThreads.SelectedItems [0].SubItems [0].Text);  	ProcessHandle phandle = null;  	if ((_provider.ProcessAccess & (ProcessAccess.QueryInformation | ProcessAccess.VmRead)) != 0)  		phandle = _provider.ProcessHandle;  	else  		phandle = new ProcessHandle (_pid' ProcessAccess.QueryInformation | ProcessAccess.VmRead);  	ProcessHandle processDupHandle = new ProcessHandle (_pid' ProcessAccess.DupHandle);  	bool found = false;  	using (var thandle = new ThreadHandle (tid' ThreadAccess.GetContext | ThreadAccess.SuspendResume)) {  		IntPtr[] lastParams = new IntPtr[4];  		thandle.WalkStack (phandle' stackFrame =>  {  			uint address = stackFrame.PcAddress.ToUInt32 ();  			string name = _provider.Symbols.GetSymbolFromAddress (address).ToLowerInvariant ();  			if (name == null) {  				// dummy  			}  			else if (name.StartsWith ("kernel32.dll!sleep")) {  				found = true;  				sb.Append ("Thread is sleeping. Timeout: " + stackFrame.Params [0].ToInt32 ().ToString () + " milliseconds");  			}  			else if (name.StartsWith ("ntdll.dll!zwdelayexecution") || name.StartsWith ("ntdll.dll!ntdelayexecution")) {  				found = true;  				bool alertable = stackFrame.Params [0].ToInt32 () != 0;  				IntPtr timeoutAddress = stackFrame.Params [1];  				long timeout;  				phandle.ReadMemory (timeoutAddress' &timeout' sizeof(long));  				if (timeout < 0) {  					sb.Append ("Thread is sleeping. Timeout: " + (new TimeSpan (-timeout)).TotalMilliseconds.ToString () + " milliseconds");  				}  				else {  					sb.AppendLine ("Thread is sleeping. Timeout: " + (new DateTime (timeout)).ToString ());  				}  			}  			else if (name.StartsWith ("ntdll.dll!zwdeviceiocontrolfile") || name.StartsWith ("ntdll.dll!ntdeviceiocontrolfile")) {  				found = true;  				IntPtr handle = stackFrame.Params [0];  				sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an I/O control request:");  				sb.AppendLine (this.GetHandleString (_pid' handle));  			}  			else if (name.StartsWith ("ntdll.dll!ntfscontrolfile") || name.StartsWith ("ntdll.dll!zwfscontrolfile")) {  				found = true;  				IntPtr handle = stackFrame.Params [0];  				sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an FS control request:");  				sb.AppendLine (this.GetHandleString (_pid' handle));  			}  			else if (name.StartsWith ("ntdll.dll!ntqueryobject") || name.StartsWith ("ntdll.dll!zwqueryobject")) {  				found = true;  				IntPtr handle = stackFrame.Params [0];  				// Use the KiFastSystemCallRet args if the handle we have is wrong.  				if (handle.ToInt32 () % 2 != 0 || handle == IntPtr.Zero)  					handle = lastParams [1];  				sb.AppendLine ("Thread " + tid.ToString () + " is querying an object (most likely a named pipe):");  				sb.AppendLine (this.GetHandleString (_pid' handle));  			}  			else if (name.StartsWith ("ntdll.dll!zwreadfile") || name.StartsWith ("ntdll.dll!ntreadfile") || name.StartsWith ("ntdll.dll!zwwritefile") || name.StartsWith ("ntdll.dll!ntwritefile")) {  				found = true;  				IntPtr handle = stackFrame.Params [0];  				sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a named pipe or a file:");  				sb.AppendLine (this.GetHandleString (_pid' handle));  			}  			else if (name.StartsWith ("ntdll.dll!zwremoveiocompletion") || name.StartsWith ("ntdll.dll!ntremoveiocompletion")) {  				found = true;  				IntPtr handle = stackFrame.Params [0];  				sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an I/O completion object:");  				sb.AppendLine (this.GetHandleString (_pid' handle));  			}  			else if (name.StartsWith ("ntdll.dll!zwreplywaitreceiveport") || name.StartsWith ("ntdll.dll!ntreplywaitreceiveport") || name.StartsWith ("ntdll.dll!zwrequestwaitreplyport") || name.StartsWith ("ntdll.dll!ntrequestwaitreplyport") || name.StartsWith ("ntdll.dll!zwalpcsendwaitreceiveport") || name.StartsWith ("ntdll.dll!ntalpcsendwaitreceiveport")) {  				found = true;  				IntPtr handle = stackFrame.Params [0];  				sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a LPC port:");  				sb.AppendLine (this.GetHandleString (_pid' handle));  			}  			else if (name.StartsWith ("ntdll.dll!zwsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!ntsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!zwsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!ntsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaithigheventpair") || name.StartsWith ("ntdll.dll!ntwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaitloweventpair") || name.StartsWith ("ntdll.dll!ntwaitloweventpair")) {  				found = true;  				IntPtr handle = stackFrame.Params [0];  				// Use the KiFastSystemCallRet args if the handle we have is wrong.  				if (handle.ToInt32 () % 2 != 0)  					handle = lastParams [1];  				sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for an event pair:");  				sb.AppendLine (this.GetHandleString (_pid' handle));  			}  			else if (name.StartsWith ("user32.dll!ntusergetmessage") || name.StartsWith ("user32.dll!ntuserwaitmessage")) {  				found = true;  				sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a USER message.");  			}  			else if (name.StartsWith ("ntdll.dll!zwwaitfordebugevent") || name.StartsWith ("ntdll.dll!ntwaitfordebugevent")) {  				found = true;  				IntPtr handle = stackFrame.Params [0];  				sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a debug event:");  				sb.AppendLine (this.GetHandleString (_pid' handle));  			}  			else if (name.StartsWith ("ntdll.dll!zwwaitforkeyedevent") || name.StartsWith ("ntdll.dll!ntwaitforkeyedevent") || name.StartsWith ("ntdll.dll!zwreleasekeyedevent") || name.StartsWith ("ntdll.dll!ntreleasekeyedevent")) {  				found = true;  				IntPtr handle = stackFrame.Params [0];  				IntPtr key = stackFrame.Params [1];  				sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for a keyed event (key 0x" + key.ToString ("x") + "):");  				sb.AppendLine (this.GetHandleString (_pid' handle));  			}  			else if (name.StartsWith ("ntdll.dll!zwwaitformultipleobjects") || name.StartsWith ("ntdll.dll!ntwaitformultipleobjects") || name.StartsWith ("kernel32.dll!waitformultipleobjects")) {  				found = true;  				int handleCount = stackFrame.Params [0].ToInt32 ();  				IntPtr handleAddress = stackFrame.Params [1];  				WaitType waitType = (WaitType)stackFrame.Params [2].ToInt32 ();  				bool alertable = stackFrame.Params [3].ToInt32 () != 0;  				// use the KiFastSystemCallRet args if we have the wrong args  				if (handleCount > 64) {  					handleCount = lastParams [1].ToInt32 ();  					handleAddress = lastParams [2];  					waitType = (WaitType)lastParams [3].ToInt32 ();  				}  				IntPtr* handles = stackalloc IntPtr[handleCount];  				phandle.ReadMemory (handleAddress' handles' handleCount * IntPtr.Size);  				sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + "' wait type: " + waitType.ToString () + ") for:");  				for (int i = 0; i < handleCount; i++) {  					sb.AppendLine (this.GetHandleString (_pid' handles [i]));  				}  			}  			else if (name.StartsWith ("ntdll.dll!zwwaitforsingleobject") || name.StartsWith ("ntdll.dll!ntwaitforsingleobject") || name.StartsWith ("kernel32.dll!waitforsingleobject")) {  				found = true;  				IntPtr handle = stackFrame.Params [0];  				bool alertable = stackFrame.Params [1].ToInt32 () != 0;  				sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + ") for:");  				sb.AppendLine (this.GetHandleString (_pid' handle));  			}  			else if (name.StartsWith ("ntdll.dll!zwwaitforworkviaworkerfactory") || name.StartsWith ("ntdll.dll!ntwaitforworkviaworkerfactory")) {  				found = true;  				IntPtr handle = stackFrame.Params [0];  				sb.AppendLine ("Thread " + tid.ToString () + " is waiting for work from a worker factory:");  				sb.AppendLine (this.GetHandleString (_pid' handle));  			}  			lastParams = stackFrame.Params;  			return !found;  		});  	}  	if (found) {  		ScratchpadWindow.Create (sb.ToString ());  	}  	else {  		PhUtils.ShowInformation ("The thread does not appear to be waiting.");  	}  }  catch (Exception ex) {  	PhUtils.ShowException ("Unable to analyze the thread"' ex);  }  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,analyzeWaitMenuItem_Click,The following statement contains a magic number: try {  	StringBuilder sb = new StringBuilder ();  	int tid = int.Parse (listThreads.SelectedItems [0].SubItems [0].Text);  	ProcessHandle phandle = null;  	if ((_provider.ProcessAccess & (ProcessAccess.QueryInformation | ProcessAccess.VmRead)) != 0)  		phandle = _provider.ProcessHandle;  	else  		phandle = new ProcessHandle (_pid' ProcessAccess.QueryInformation | ProcessAccess.VmRead);  	ProcessHandle processDupHandle = new ProcessHandle (_pid' ProcessAccess.DupHandle);  	bool found = false;  	using (var thandle = new ThreadHandle (tid' ThreadAccess.GetContext | ThreadAccess.SuspendResume)) {  		IntPtr[] lastParams = new IntPtr[4];  		thandle.WalkStack (phandle' stackFrame =>  {  			uint address = stackFrame.PcAddress.ToUInt32 ();  			string name = _provider.Symbols.GetSymbolFromAddress (address).ToLowerInvariant ();  			if (name == null) {  				// dummy  			}  			else if (name.StartsWith ("kernel32.dll!sleep")) {  				found = true;  				sb.Append ("Thread is sleeping. Timeout: " + stackFrame.Params [0].ToInt32 ().ToString () + " milliseconds");  			}  			else if (name.StartsWith ("ntdll.dll!zwdelayexecution") || name.StartsWith ("ntdll.dll!ntdelayexecution")) {  				found = true;  				bool alertable = stackFrame.Params [0].ToInt32 () != 0;  				IntPtr timeoutAddress = stackFrame.Params [1];  				long timeout;  				phandle.ReadMemory (timeoutAddress' &timeout' sizeof(long));  				if (timeout < 0) {  					sb.Append ("Thread is sleeping. Timeout: " + (new TimeSpan (-timeout)).TotalMilliseconds.ToString () + " milliseconds");  				}  				else {  					sb.AppendLine ("Thread is sleeping. Timeout: " + (new DateTime (timeout)).ToString ());  				}  			}  			else if (name.StartsWith ("ntdll.dll!zwdeviceiocontrolfile") || name.StartsWith ("ntdll.dll!ntdeviceiocontrolfile")) {  				found = true;  				IntPtr handle = stackFrame.Params [0];  				sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an I/O control request:");  				sb.AppendLine (this.GetHandleString (_pid' handle));  			}  			else if (name.StartsWith ("ntdll.dll!ntfscontrolfile") || name.StartsWith ("ntdll.dll!zwfscontrolfile")) {  				found = true;  				IntPtr handle = stackFrame.Params [0];  				sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an FS control request:");  				sb.AppendLine (this.GetHandleString (_pid' handle));  			}  			else if (name.StartsWith ("ntdll.dll!ntqueryobject") || name.StartsWith ("ntdll.dll!zwqueryobject")) {  				found = true;  				IntPtr handle = stackFrame.Params [0];  				// Use the KiFastSystemCallRet args if the handle we have is wrong.  				if (handle.ToInt32 () % 2 != 0 || handle == IntPtr.Zero)  					handle = lastParams [1];  				sb.AppendLine ("Thread " + tid.ToString () + " is querying an object (most likely a named pipe):");  				sb.AppendLine (this.GetHandleString (_pid' handle));  			}  			else if (name.StartsWith ("ntdll.dll!zwreadfile") || name.StartsWith ("ntdll.dll!ntreadfile") || name.StartsWith ("ntdll.dll!zwwritefile") || name.StartsWith ("ntdll.dll!ntwritefile")) {  				found = true;  				IntPtr handle = stackFrame.Params [0];  				sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a named pipe or a file:");  				sb.AppendLine (this.GetHandleString (_pid' handle));  			}  			else if (name.StartsWith ("ntdll.dll!zwremoveiocompletion") || name.StartsWith ("ntdll.dll!ntremoveiocompletion")) {  				found = true;  				IntPtr handle = stackFrame.Params [0];  				sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an I/O completion object:");  				sb.AppendLine (this.GetHandleString (_pid' handle));  			}  			else if (name.StartsWith ("ntdll.dll!zwreplywaitreceiveport") || name.StartsWith ("ntdll.dll!ntreplywaitreceiveport") || name.StartsWith ("ntdll.dll!zwrequestwaitreplyport") || name.StartsWith ("ntdll.dll!ntrequestwaitreplyport") || name.StartsWith ("ntdll.dll!zwalpcsendwaitreceiveport") || name.StartsWith ("ntdll.dll!ntalpcsendwaitreceiveport")) {  				found = true;  				IntPtr handle = stackFrame.Params [0];  				sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a LPC port:");  				sb.AppendLine (this.GetHandleString (_pid' handle));  			}  			else if (name.StartsWith ("ntdll.dll!zwsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!ntsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!zwsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!ntsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaithigheventpair") || name.StartsWith ("ntdll.dll!ntwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaitloweventpair") || name.StartsWith ("ntdll.dll!ntwaitloweventpair")) {  				found = true;  				IntPtr handle = stackFrame.Params [0];  				// Use the KiFastSystemCallRet args if the handle we have is wrong.  				if (handle.ToInt32 () % 2 != 0)  					handle = lastParams [1];  				sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for an event pair:");  				sb.AppendLine (this.GetHandleString (_pid' handle));  			}  			else if (name.StartsWith ("user32.dll!ntusergetmessage") || name.StartsWith ("user32.dll!ntuserwaitmessage")) {  				found = true;  				sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a USER message.");  			}  			else if (name.StartsWith ("ntdll.dll!zwwaitfordebugevent") || name.StartsWith ("ntdll.dll!ntwaitfordebugevent")) {  				found = true;  				IntPtr handle = stackFrame.Params [0];  				sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a debug event:");  				sb.AppendLine (this.GetHandleString (_pid' handle));  			}  			else if (name.StartsWith ("ntdll.dll!zwwaitforkeyedevent") || name.StartsWith ("ntdll.dll!ntwaitforkeyedevent") || name.StartsWith ("ntdll.dll!zwreleasekeyedevent") || name.StartsWith ("ntdll.dll!ntreleasekeyedevent")) {  				found = true;  				IntPtr handle = stackFrame.Params [0];  				IntPtr key = stackFrame.Params [1];  				sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for a keyed event (key 0x" + key.ToString ("x") + "):");  				sb.AppendLine (this.GetHandleString (_pid' handle));  			}  			else if (name.StartsWith ("ntdll.dll!zwwaitformultipleobjects") || name.StartsWith ("ntdll.dll!ntwaitformultipleobjects") || name.StartsWith ("kernel32.dll!waitformultipleobjects")) {  				found = true;  				int handleCount = stackFrame.Params [0].ToInt32 ();  				IntPtr handleAddress = stackFrame.Params [1];  				WaitType waitType = (WaitType)stackFrame.Params [2].ToInt32 ();  				bool alertable = stackFrame.Params [3].ToInt32 () != 0;  				// use the KiFastSystemCallRet args if we have the wrong args  				if (handleCount > 64) {  					handleCount = lastParams [1].ToInt32 ();  					handleAddress = lastParams [2];  					waitType = (WaitType)lastParams [3].ToInt32 ();  				}  				IntPtr* handles = stackalloc IntPtr[handleCount];  				phandle.ReadMemory (handleAddress' handles' handleCount * IntPtr.Size);  				sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + "' wait type: " + waitType.ToString () + ") for:");  				for (int i = 0; i < handleCount; i++) {  					sb.AppendLine (this.GetHandleString (_pid' handles [i]));  				}  			}  			else if (name.StartsWith ("ntdll.dll!zwwaitforsingleobject") || name.StartsWith ("ntdll.dll!ntwaitforsingleobject") || name.StartsWith ("kernel32.dll!waitforsingleobject")) {  				found = true;  				IntPtr handle = stackFrame.Params [0];  				bool alertable = stackFrame.Params [1].ToInt32 () != 0;  				sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + ") for:");  				sb.AppendLine (this.GetHandleString (_pid' handle));  			}  			else if (name.StartsWith ("ntdll.dll!zwwaitforworkviaworkerfactory") || name.StartsWith ("ntdll.dll!ntwaitforworkviaworkerfactory")) {  				found = true;  				IntPtr handle = stackFrame.Params [0];  				sb.AppendLine ("Thread " + tid.ToString () + " is waiting for work from a worker factory:");  				sb.AppendLine (this.GetHandleString (_pid' handle));  			}  			lastParams = stackFrame.Params;  			return !found;  		});  	}  	if (found) {  		ScratchpadWindow.Create (sb.ToString ());  	}  	else {  		PhUtils.ShowInformation ("The thread does not appear to be waiting.");  	}  }  catch (Exception ex) {  	PhUtils.ShowException ("Unable to analyze the thread"' ex);  }  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,analyzeWaitMenuItem_Click,The following statement contains a magic number: try {  	StringBuilder sb = new StringBuilder ();  	int tid = int.Parse (listThreads.SelectedItems [0].SubItems [0].Text);  	ProcessHandle phandle = null;  	if ((_provider.ProcessAccess & (ProcessAccess.QueryInformation | ProcessAccess.VmRead)) != 0)  		phandle = _provider.ProcessHandle;  	else  		phandle = new ProcessHandle (_pid' ProcessAccess.QueryInformation | ProcessAccess.VmRead);  	ProcessHandle processDupHandle = new ProcessHandle (_pid' ProcessAccess.DupHandle);  	bool found = false;  	using (var thandle = new ThreadHandle (tid' ThreadAccess.GetContext | ThreadAccess.SuspendResume)) {  		IntPtr[] lastParams = new IntPtr[4];  		thandle.WalkStack (phandle' stackFrame =>  {  			uint address = stackFrame.PcAddress.ToUInt32 ();  			string name = _provider.Symbols.GetSymbolFromAddress (address).ToLowerInvariant ();  			if (name == null) {  				// dummy  			}  			else if (name.StartsWith ("kernel32.dll!sleep")) {  				found = true;  				sb.Append ("Thread is sleeping. Timeout: " + stackFrame.Params [0].ToInt32 ().ToString () + " milliseconds");  			}  			else if (name.StartsWith ("ntdll.dll!zwdelayexecution") || name.StartsWith ("ntdll.dll!ntdelayexecution")) {  				found = true;  				bool alertable = stackFrame.Params [0].ToInt32 () != 0;  				IntPtr timeoutAddress = stackFrame.Params [1];  				long timeout;  				phandle.ReadMemory (timeoutAddress' &timeout' sizeof(long));  				if (timeout < 0) {  					sb.Append ("Thread is sleeping. Timeout: " + (new TimeSpan (-timeout)).TotalMilliseconds.ToString () + " milliseconds");  				}  				else {  					sb.AppendLine ("Thread is sleeping. Timeout: " + (new DateTime (timeout)).ToString ());  				}  			}  			else if (name.StartsWith ("ntdll.dll!zwdeviceiocontrolfile") || name.StartsWith ("ntdll.dll!ntdeviceiocontrolfile")) {  				found = true;  				IntPtr handle = stackFrame.Params [0];  				sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an I/O control request:");  				sb.AppendLine (this.GetHandleString (_pid' handle));  			}  			else if (name.StartsWith ("ntdll.dll!ntfscontrolfile") || name.StartsWith ("ntdll.dll!zwfscontrolfile")) {  				found = true;  				IntPtr handle = stackFrame.Params [0];  				sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an FS control request:");  				sb.AppendLine (this.GetHandleString (_pid' handle));  			}  			else if (name.StartsWith ("ntdll.dll!ntqueryobject") || name.StartsWith ("ntdll.dll!zwqueryobject")) {  				found = true;  				IntPtr handle = stackFrame.Params [0];  				// Use the KiFastSystemCallRet args if the handle we have is wrong.  				if (handle.ToInt32 () % 2 != 0 || handle == IntPtr.Zero)  					handle = lastParams [1];  				sb.AppendLine ("Thread " + tid.ToString () + " is querying an object (most likely a named pipe):");  				sb.AppendLine (this.GetHandleString (_pid' handle));  			}  			else if (name.StartsWith ("ntdll.dll!zwreadfile") || name.StartsWith ("ntdll.dll!ntreadfile") || name.StartsWith ("ntdll.dll!zwwritefile") || name.StartsWith ("ntdll.dll!ntwritefile")) {  				found = true;  				IntPtr handle = stackFrame.Params [0];  				sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a named pipe or a file:");  				sb.AppendLine (this.GetHandleString (_pid' handle));  			}  			else if (name.StartsWith ("ntdll.dll!zwremoveiocompletion") || name.StartsWith ("ntdll.dll!ntremoveiocompletion")) {  				found = true;  				IntPtr handle = stackFrame.Params [0];  				sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an I/O completion object:");  				sb.AppendLine (this.GetHandleString (_pid' handle));  			}  			else if (name.StartsWith ("ntdll.dll!zwreplywaitreceiveport") || name.StartsWith ("ntdll.dll!ntreplywaitreceiveport") || name.StartsWith ("ntdll.dll!zwrequestwaitreplyport") || name.StartsWith ("ntdll.dll!ntrequestwaitreplyport") || name.StartsWith ("ntdll.dll!zwalpcsendwaitreceiveport") || name.StartsWith ("ntdll.dll!ntalpcsendwaitreceiveport")) {  				found = true;  				IntPtr handle = stackFrame.Params [0];  				sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a LPC port:");  				sb.AppendLine (this.GetHandleString (_pid' handle));  			}  			else if (name.StartsWith ("ntdll.dll!zwsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!ntsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!zwsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!ntsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaithigheventpair") || name.StartsWith ("ntdll.dll!ntwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaitloweventpair") || name.StartsWith ("ntdll.dll!ntwaitloweventpair")) {  				found = true;  				IntPtr handle = stackFrame.Params [0];  				// Use the KiFastSystemCallRet args if the handle we have is wrong.  				if (handle.ToInt32 () % 2 != 0)  					handle = lastParams [1];  				sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for an event pair:");  				sb.AppendLine (this.GetHandleString (_pid' handle));  			}  			else if (name.StartsWith ("user32.dll!ntusergetmessage") || name.StartsWith ("user32.dll!ntuserwaitmessage")) {  				found = true;  				sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a USER message.");  			}  			else if (name.StartsWith ("ntdll.dll!zwwaitfordebugevent") || name.StartsWith ("ntdll.dll!ntwaitfordebugevent")) {  				found = true;  				IntPtr handle = stackFrame.Params [0];  				sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a debug event:");  				sb.AppendLine (this.GetHandleString (_pid' handle));  			}  			else if (name.StartsWith ("ntdll.dll!zwwaitforkeyedevent") || name.StartsWith ("ntdll.dll!ntwaitforkeyedevent") || name.StartsWith ("ntdll.dll!zwreleasekeyedevent") || name.StartsWith ("ntdll.dll!ntreleasekeyedevent")) {  				found = true;  				IntPtr handle = stackFrame.Params [0];  				IntPtr key = stackFrame.Params [1];  				sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for a keyed event (key 0x" + key.ToString ("x") + "):");  				sb.AppendLine (this.GetHandleString (_pid' handle));  			}  			else if (name.StartsWith ("ntdll.dll!zwwaitformultipleobjects") || name.StartsWith ("ntdll.dll!ntwaitformultipleobjects") || name.StartsWith ("kernel32.dll!waitformultipleobjects")) {  				found = true;  				int handleCount = stackFrame.Params [0].ToInt32 ();  				IntPtr handleAddress = stackFrame.Params [1];  				WaitType waitType = (WaitType)stackFrame.Params [2].ToInt32 ();  				bool alertable = stackFrame.Params [3].ToInt32 () != 0;  				// use the KiFastSystemCallRet args if we have the wrong args  				if (handleCount > 64) {  					handleCount = lastParams [1].ToInt32 ();  					handleAddress = lastParams [2];  					waitType = (WaitType)lastParams [3].ToInt32 ();  				}  				IntPtr* handles = stackalloc IntPtr[handleCount];  				phandle.ReadMemory (handleAddress' handles' handleCount * IntPtr.Size);  				sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + "' wait type: " + waitType.ToString () + ") for:");  				for (int i = 0; i < handleCount; i++) {  					sb.AppendLine (this.GetHandleString (_pid' handles [i]));  				}  			}  			else if (name.StartsWith ("ntdll.dll!zwwaitforsingleobject") || name.StartsWith ("ntdll.dll!ntwaitforsingleobject") || name.StartsWith ("kernel32.dll!waitforsingleobject")) {  				found = true;  				IntPtr handle = stackFrame.Params [0];  				bool alertable = stackFrame.Params [1].ToInt32 () != 0;  				sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + ") for:");  				sb.AppendLine (this.GetHandleString (_pid' handle));  			}  			else if (name.StartsWith ("ntdll.dll!zwwaitforworkviaworkerfactory") || name.StartsWith ("ntdll.dll!ntwaitforworkviaworkerfactory")) {  				found = true;  				IntPtr handle = stackFrame.Params [0];  				sb.AppendLine ("Thread " + tid.ToString () + " is waiting for work from a worker factory:");  				sb.AppendLine (this.GetHandleString (_pid' handle));  			}  			lastParams = stackFrame.Params;  			return !found;  		});  	}  	if (found) {  		ScratchpadWindow.Create (sb.ToString ());  	}  	else {  		PhUtils.ShowInformation ("The thread does not appear to be waiting.");  	}  }  catch (Exception ex) {  	PhUtils.ShowException ("Unable to analyze the thread"' ex);  }  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,analyzeWaitMenuItem_Click,The following statement contains a magic number: try {  	StringBuilder sb = new StringBuilder ();  	int tid = int.Parse (listThreads.SelectedItems [0].SubItems [0].Text);  	ProcessHandle phandle = null;  	if ((_provider.ProcessAccess & (ProcessAccess.QueryInformation | ProcessAccess.VmRead)) != 0)  		phandle = _provider.ProcessHandle;  	else  		phandle = new ProcessHandle (_pid' ProcessAccess.QueryInformation | ProcessAccess.VmRead);  	ProcessHandle processDupHandle = new ProcessHandle (_pid' ProcessAccess.DupHandle);  	bool found = false;  	using (var thandle = new ThreadHandle (tid' ThreadAccess.GetContext | ThreadAccess.SuspendResume)) {  		IntPtr[] lastParams = new IntPtr[4];  		thandle.WalkStack (phandle' stackFrame =>  {  			uint address = stackFrame.PcAddress.ToUInt32 ();  			string name = _provider.Symbols.GetSymbolFromAddress (address).ToLowerInvariant ();  			if (name == null) {  				// dummy  			}  			else if (name.StartsWith ("kernel32.dll!sleep")) {  				found = true;  				sb.Append ("Thread is sleeping. Timeout: " + stackFrame.Params [0].ToInt32 ().ToString () + " milliseconds");  			}  			else if (name.StartsWith ("ntdll.dll!zwdelayexecution") || name.StartsWith ("ntdll.dll!ntdelayexecution")) {  				found = true;  				bool alertable = stackFrame.Params [0].ToInt32 () != 0;  				IntPtr timeoutAddress = stackFrame.Params [1];  				long timeout;  				phandle.ReadMemory (timeoutAddress' &timeout' sizeof(long));  				if (timeout < 0) {  					sb.Append ("Thread is sleeping. Timeout: " + (new TimeSpan (-timeout)).TotalMilliseconds.ToString () + " milliseconds");  				}  				else {  					sb.AppendLine ("Thread is sleeping. Timeout: " + (new DateTime (timeout)).ToString ());  				}  			}  			else if (name.StartsWith ("ntdll.dll!zwdeviceiocontrolfile") || name.StartsWith ("ntdll.dll!ntdeviceiocontrolfile")) {  				found = true;  				IntPtr handle = stackFrame.Params [0];  				sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an I/O control request:");  				sb.AppendLine (this.GetHandleString (_pid' handle));  			}  			else if (name.StartsWith ("ntdll.dll!ntfscontrolfile") || name.StartsWith ("ntdll.dll!zwfscontrolfile")) {  				found = true;  				IntPtr handle = stackFrame.Params [0];  				sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an FS control request:");  				sb.AppendLine (this.GetHandleString (_pid' handle));  			}  			else if (name.StartsWith ("ntdll.dll!ntqueryobject") || name.StartsWith ("ntdll.dll!zwqueryobject")) {  				found = true;  				IntPtr handle = stackFrame.Params [0];  				// Use the KiFastSystemCallRet args if the handle we have is wrong.  				if (handle.ToInt32 () % 2 != 0 || handle == IntPtr.Zero)  					handle = lastParams [1];  				sb.AppendLine ("Thread " + tid.ToString () + " is querying an object (most likely a named pipe):");  				sb.AppendLine (this.GetHandleString (_pid' handle));  			}  			else if (name.StartsWith ("ntdll.dll!zwreadfile") || name.StartsWith ("ntdll.dll!ntreadfile") || name.StartsWith ("ntdll.dll!zwwritefile") || name.StartsWith ("ntdll.dll!ntwritefile")) {  				found = true;  				IntPtr handle = stackFrame.Params [0];  				sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a named pipe or a file:");  				sb.AppendLine (this.GetHandleString (_pid' handle));  			}  			else if (name.StartsWith ("ntdll.dll!zwremoveiocompletion") || name.StartsWith ("ntdll.dll!ntremoveiocompletion")) {  				found = true;  				IntPtr handle = stackFrame.Params [0];  				sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an I/O completion object:");  				sb.AppendLine (this.GetHandleString (_pid' handle));  			}  			else if (name.StartsWith ("ntdll.dll!zwreplywaitreceiveport") || name.StartsWith ("ntdll.dll!ntreplywaitreceiveport") || name.StartsWith ("ntdll.dll!zwrequestwaitreplyport") || name.StartsWith ("ntdll.dll!ntrequestwaitreplyport") || name.StartsWith ("ntdll.dll!zwalpcsendwaitreceiveport") || name.StartsWith ("ntdll.dll!ntalpcsendwaitreceiveport")) {  				found = true;  				IntPtr handle = stackFrame.Params [0];  				sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a LPC port:");  				sb.AppendLine (this.GetHandleString (_pid' handle));  			}  			else if (name.StartsWith ("ntdll.dll!zwsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!ntsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!zwsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!ntsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaithigheventpair") || name.StartsWith ("ntdll.dll!ntwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaitloweventpair") || name.StartsWith ("ntdll.dll!ntwaitloweventpair")) {  				found = true;  				IntPtr handle = stackFrame.Params [0];  				// Use the KiFastSystemCallRet args if the handle we have is wrong.  				if (handle.ToInt32 () % 2 != 0)  					handle = lastParams [1];  				sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for an event pair:");  				sb.AppendLine (this.GetHandleString (_pid' handle));  			}  			else if (name.StartsWith ("user32.dll!ntusergetmessage") || name.StartsWith ("user32.dll!ntuserwaitmessage")) {  				found = true;  				sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a USER message.");  			}  			else if (name.StartsWith ("ntdll.dll!zwwaitfordebugevent") || name.StartsWith ("ntdll.dll!ntwaitfordebugevent")) {  				found = true;  				IntPtr handle = stackFrame.Params [0];  				sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a debug event:");  				sb.AppendLine (this.GetHandleString (_pid' handle));  			}  			else if (name.StartsWith ("ntdll.dll!zwwaitforkeyedevent") || name.StartsWith ("ntdll.dll!ntwaitforkeyedevent") || name.StartsWith ("ntdll.dll!zwreleasekeyedevent") || name.StartsWith ("ntdll.dll!ntreleasekeyedevent")) {  				found = true;  				IntPtr handle = stackFrame.Params [0];  				IntPtr key = stackFrame.Params [1];  				sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for a keyed event (key 0x" + key.ToString ("x") + "):");  				sb.AppendLine (this.GetHandleString (_pid' handle));  			}  			else if (name.StartsWith ("ntdll.dll!zwwaitformultipleobjects") || name.StartsWith ("ntdll.dll!ntwaitformultipleobjects") || name.StartsWith ("kernel32.dll!waitformultipleobjects")) {  				found = true;  				int handleCount = stackFrame.Params [0].ToInt32 ();  				IntPtr handleAddress = stackFrame.Params [1];  				WaitType waitType = (WaitType)stackFrame.Params [2].ToInt32 ();  				bool alertable = stackFrame.Params [3].ToInt32 () != 0;  				// use the KiFastSystemCallRet args if we have the wrong args  				if (handleCount > 64) {  					handleCount = lastParams [1].ToInt32 ();  					handleAddress = lastParams [2];  					waitType = (WaitType)lastParams [3].ToInt32 ();  				}  				IntPtr* handles = stackalloc IntPtr[handleCount];  				phandle.ReadMemory (handleAddress' handles' handleCount * IntPtr.Size);  				sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + "' wait type: " + waitType.ToString () + ") for:");  				for (int i = 0; i < handleCount; i++) {  					sb.AppendLine (this.GetHandleString (_pid' handles [i]));  				}  			}  			else if (name.StartsWith ("ntdll.dll!zwwaitforsingleobject") || name.StartsWith ("ntdll.dll!ntwaitforsingleobject") || name.StartsWith ("kernel32.dll!waitforsingleobject")) {  				found = true;  				IntPtr handle = stackFrame.Params [0];  				bool alertable = stackFrame.Params [1].ToInt32 () != 0;  				sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + ") for:");  				sb.AppendLine (this.GetHandleString (_pid' handle));  			}  			else if (name.StartsWith ("ntdll.dll!zwwaitforworkviaworkerfactory") || name.StartsWith ("ntdll.dll!ntwaitforworkviaworkerfactory")) {  				found = true;  				IntPtr handle = stackFrame.Params [0];  				sb.AppendLine ("Thread " + tid.ToString () + " is waiting for work from a worker factory:");  				sb.AppendLine (this.GetHandleString (_pid' handle));  			}  			lastParams = stackFrame.Params;  			return !found;  		});  	}  	if (found) {  		ScratchpadWindow.Create (sb.ToString ());  	}  	else {  		PhUtils.ShowInformation ("The thread does not appear to be waiting.");  	}  }  catch (Exception ex) {  	PhUtils.ShowException ("Unable to analyze the thread"' ex);  }  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,analyzeWaitMenuItem_Click,The following statement contains a magic number: try {  	StringBuilder sb = new StringBuilder ();  	int tid = int.Parse (listThreads.SelectedItems [0].SubItems [0].Text);  	ProcessHandle phandle = null;  	if ((_provider.ProcessAccess & (ProcessAccess.QueryInformation | ProcessAccess.VmRead)) != 0)  		phandle = _provider.ProcessHandle;  	else  		phandle = new ProcessHandle (_pid' ProcessAccess.QueryInformation | ProcessAccess.VmRead);  	ProcessHandle processDupHandle = new ProcessHandle (_pid' ProcessAccess.DupHandle);  	bool found = false;  	using (var thandle = new ThreadHandle (tid' ThreadAccess.GetContext | ThreadAccess.SuspendResume)) {  		IntPtr[] lastParams = new IntPtr[4];  		thandle.WalkStack (phandle' stackFrame =>  {  			uint address = stackFrame.PcAddress.ToUInt32 ();  			string name = _provider.Symbols.GetSymbolFromAddress (address).ToLowerInvariant ();  			if (name == null) {  				// dummy  			}  			else if (name.StartsWith ("kernel32.dll!sleep")) {  				found = true;  				sb.Append ("Thread is sleeping. Timeout: " + stackFrame.Params [0].ToInt32 ().ToString () + " milliseconds");  			}  			else if (name.StartsWith ("ntdll.dll!zwdelayexecution") || name.StartsWith ("ntdll.dll!ntdelayexecution")) {  				found = true;  				bool alertable = stackFrame.Params [0].ToInt32 () != 0;  				IntPtr timeoutAddress = stackFrame.Params [1];  				long timeout;  				phandle.ReadMemory (timeoutAddress' &timeout' sizeof(long));  				if (timeout < 0) {  					sb.Append ("Thread is sleeping. Timeout: " + (new TimeSpan (-timeout)).TotalMilliseconds.ToString () + " milliseconds");  				}  				else {  					sb.AppendLine ("Thread is sleeping. Timeout: " + (new DateTime (timeout)).ToString ());  				}  			}  			else if (name.StartsWith ("ntdll.dll!zwdeviceiocontrolfile") || name.StartsWith ("ntdll.dll!ntdeviceiocontrolfile")) {  				found = true;  				IntPtr handle = stackFrame.Params [0];  				sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an I/O control request:");  				sb.AppendLine (this.GetHandleString (_pid' handle));  			}  			else if (name.StartsWith ("ntdll.dll!ntfscontrolfile") || name.StartsWith ("ntdll.dll!zwfscontrolfile")) {  				found = true;  				IntPtr handle = stackFrame.Params [0];  				sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an FS control request:");  				sb.AppendLine (this.GetHandleString (_pid' handle));  			}  			else if (name.StartsWith ("ntdll.dll!ntqueryobject") || name.StartsWith ("ntdll.dll!zwqueryobject")) {  				found = true;  				IntPtr handle = stackFrame.Params [0];  				// Use the KiFastSystemCallRet args if the handle we have is wrong.  				if (handle.ToInt32 () % 2 != 0 || handle == IntPtr.Zero)  					handle = lastParams [1];  				sb.AppendLine ("Thread " + tid.ToString () + " is querying an object (most likely a named pipe):");  				sb.AppendLine (this.GetHandleString (_pid' handle));  			}  			else if (name.StartsWith ("ntdll.dll!zwreadfile") || name.StartsWith ("ntdll.dll!ntreadfile") || name.StartsWith ("ntdll.dll!zwwritefile") || name.StartsWith ("ntdll.dll!ntwritefile")) {  				found = true;  				IntPtr handle = stackFrame.Params [0];  				sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a named pipe or a file:");  				sb.AppendLine (this.GetHandleString (_pid' handle));  			}  			else if (name.StartsWith ("ntdll.dll!zwremoveiocompletion") || name.StartsWith ("ntdll.dll!ntremoveiocompletion")) {  				found = true;  				IntPtr handle = stackFrame.Params [0];  				sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an I/O completion object:");  				sb.AppendLine (this.GetHandleString (_pid' handle));  			}  			else if (name.StartsWith ("ntdll.dll!zwreplywaitreceiveport") || name.StartsWith ("ntdll.dll!ntreplywaitreceiveport") || name.StartsWith ("ntdll.dll!zwrequestwaitreplyport") || name.StartsWith ("ntdll.dll!ntrequestwaitreplyport") || name.StartsWith ("ntdll.dll!zwalpcsendwaitreceiveport") || name.StartsWith ("ntdll.dll!ntalpcsendwaitreceiveport")) {  				found = true;  				IntPtr handle = stackFrame.Params [0];  				sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a LPC port:");  				sb.AppendLine (this.GetHandleString (_pid' handle));  			}  			else if (name.StartsWith ("ntdll.dll!zwsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!ntsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!zwsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!ntsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaithigheventpair") || name.StartsWith ("ntdll.dll!ntwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaitloweventpair") || name.StartsWith ("ntdll.dll!ntwaitloweventpair")) {  				found = true;  				IntPtr handle = stackFrame.Params [0];  				// Use the KiFastSystemCallRet args if the handle we have is wrong.  				if (handle.ToInt32 () % 2 != 0)  					handle = lastParams [1];  				sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for an event pair:");  				sb.AppendLine (this.GetHandleString (_pid' handle));  			}  			else if (name.StartsWith ("user32.dll!ntusergetmessage") || name.StartsWith ("user32.dll!ntuserwaitmessage")) {  				found = true;  				sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a USER message.");  			}  			else if (name.StartsWith ("ntdll.dll!zwwaitfordebugevent") || name.StartsWith ("ntdll.dll!ntwaitfordebugevent")) {  				found = true;  				IntPtr handle = stackFrame.Params [0];  				sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a debug event:");  				sb.AppendLine (this.GetHandleString (_pid' handle));  			}  			else if (name.StartsWith ("ntdll.dll!zwwaitforkeyedevent") || name.StartsWith ("ntdll.dll!ntwaitforkeyedevent") || name.StartsWith ("ntdll.dll!zwreleasekeyedevent") || name.StartsWith ("ntdll.dll!ntreleasekeyedevent")) {  				found = true;  				IntPtr handle = stackFrame.Params [0];  				IntPtr key = stackFrame.Params [1];  				sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for a keyed event (key 0x" + key.ToString ("x") + "):");  				sb.AppendLine (this.GetHandleString (_pid' handle));  			}  			else if (name.StartsWith ("ntdll.dll!zwwaitformultipleobjects") || name.StartsWith ("ntdll.dll!ntwaitformultipleobjects") || name.StartsWith ("kernel32.dll!waitformultipleobjects")) {  				found = true;  				int handleCount = stackFrame.Params [0].ToInt32 ();  				IntPtr handleAddress = stackFrame.Params [1];  				WaitType waitType = (WaitType)stackFrame.Params [2].ToInt32 ();  				bool alertable = stackFrame.Params [3].ToInt32 () != 0;  				// use the KiFastSystemCallRet args if we have the wrong args  				if (handleCount > 64) {  					handleCount = lastParams [1].ToInt32 ();  					handleAddress = lastParams [2];  					waitType = (WaitType)lastParams [3].ToInt32 ();  				}  				IntPtr* handles = stackalloc IntPtr[handleCount];  				phandle.ReadMemory (handleAddress' handles' handleCount * IntPtr.Size);  				sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + "' wait type: " + waitType.ToString () + ") for:");  				for (int i = 0; i < handleCount; i++) {  					sb.AppendLine (this.GetHandleString (_pid' handles [i]));  				}  			}  			else if (name.StartsWith ("ntdll.dll!zwwaitforsingleobject") || name.StartsWith ("ntdll.dll!ntwaitforsingleobject") || name.StartsWith ("kernel32.dll!waitforsingleobject")) {  				found = true;  				IntPtr handle = stackFrame.Params [0];  				bool alertable = stackFrame.Params [1].ToInt32 () != 0;  				sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + ") for:");  				sb.AppendLine (this.GetHandleString (_pid' handle));  			}  			else if (name.StartsWith ("ntdll.dll!zwwaitforworkviaworkerfactory") || name.StartsWith ("ntdll.dll!ntwaitforworkviaworkerfactory")) {  				found = true;  				IntPtr handle = stackFrame.Params [0];  				sb.AppendLine ("Thread " + tid.ToString () + " is waiting for work from a worker factory:");  				sb.AppendLine (this.GetHandleString (_pid' handle));  			}  			lastParams = stackFrame.Params;  			return !found;  		});  	}  	if (found) {  		ScratchpadWindow.Create (sb.ToString ());  	}  	else {  		PhUtils.ShowInformation ("The thread does not appear to be waiting.");  	}  }  catch (Exception ex) {  	PhUtils.ShowException ("Unable to analyze the thread"' ex);  }  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,analyzeWaitMenuItem_Click,The following statement contains a magic number: using (var thandle = new ThreadHandle (tid' ThreadAccess.GetContext | ThreadAccess.SuspendResume)) {  	IntPtr[] lastParams = new IntPtr[4];  	thandle.WalkStack (phandle' stackFrame =>  {  		uint address = stackFrame.PcAddress.ToUInt32 ();  		string name = _provider.Symbols.GetSymbolFromAddress (address).ToLowerInvariant ();  		if (name == null) {  			// dummy  		}  		else if (name.StartsWith ("kernel32.dll!sleep")) {  			found = true;  			sb.Append ("Thread is sleeping. Timeout: " + stackFrame.Params [0].ToInt32 ().ToString () + " milliseconds");  		}  		else if (name.StartsWith ("ntdll.dll!zwdelayexecution") || name.StartsWith ("ntdll.dll!ntdelayexecution")) {  			found = true;  			bool alertable = stackFrame.Params [0].ToInt32 () != 0;  			IntPtr timeoutAddress = stackFrame.Params [1];  			long timeout;  			phandle.ReadMemory (timeoutAddress' &timeout' sizeof(long));  			if (timeout < 0) {  				sb.Append ("Thread is sleeping. Timeout: " + (new TimeSpan (-timeout)).TotalMilliseconds.ToString () + " milliseconds");  			}  			else {  				sb.AppendLine ("Thread is sleeping. Timeout: " + (new DateTime (timeout)).ToString ());  			}  		}  		else if (name.StartsWith ("ntdll.dll!zwdeviceiocontrolfile") || name.StartsWith ("ntdll.dll!ntdeviceiocontrolfile")) {  			found = true;  			IntPtr handle = stackFrame.Params [0];  			sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an I/O control request:");  			sb.AppendLine (this.GetHandleString (_pid' handle));  		}  		else if (name.StartsWith ("ntdll.dll!ntfscontrolfile") || name.StartsWith ("ntdll.dll!zwfscontrolfile")) {  			found = true;  			IntPtr handle = stackFrame.Params [0];  			sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an FS control request:");  			sb.AppendLine (this.GetHandleString (_pid' handle));  		}  		else if (name.StartsWith ("ntdll.dll!ntqueryobject") || name.StartsWith ("ntdll.dll!zwqueryobject")) {  			found = true;  			IntPtr handle = stackFrame.Params [0];  			// Use the KiFastSystemCallRet args if the handle we have is wrong.  			if (handle.ToInt32 () % 2 != 0 || handle == IntPtr.Zero)  				handle = lastParams [1];  			sb.AppendLine ("Thread " + tid.ToString () + " is querying an object (most likely a named pipe):");  			sb.AppendLine (this.GetHandleString (_pid' handle));  		}  		else if (name.StartsWith ("ntdll.dll!zwreadfile") || name.StartsWith ("ntdll.dll!ntreadfile") || name.StartsWith ("ntdll.dll!zwwritefile") || name.StartsWith ("ntdll.dll!ntwritefile")) {  			found = true;  			IntPtr handle = stackFrame.Params [0];  			sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a named pipe or a file:");  			sb.AppendLine (this.GetHandleString (_pid' handle));  		}  		else if (name.StartsWith ("ntdll.dll!zwremoveiocompletion") || name.StartsWith ("ntdll.dll!ntremoveiocompletion")) {  			found = true;  			IntPtr handle = stackFrame.Params [0];  			sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an I/O completion object:");  			sb.AppendLine (this.GetHandleString (_pid' handle));  		}  		else if (name.StartsWith ("ntdll.dll!zwreplywaitreceiveport") || name.StartsWith ("ntdll.dll!ntreplywaitreceiveport") || name.StartsWith ("ntdll.dll!zwrequestwaitreplyport") || name.StartsWith ("ntdll.dll!ntrequestwaitreplyport") || name.StartsWith ("ntdll.dll!zwalpcsendwaitreceiveport") || name.StartsWith ("ntdll.dll!ntalpcsendwaitreceiveport")) {  			found = true;  			IntPtr handle = stackFrame.Params [0];  			sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a LPC port:");  			sb.AppendLine (this.GetHandleString (_pid' handle));  		}  		else if (name.StartsWith ("ntdll.dll!zwsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!ntsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!zwsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!ntsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaithigheventpair") || name.StartsWith ("ntdll.dll!ntwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaitloweventpair") || name.StartsWith ("ntdll.dll!ntwaitloweventpair")) {  			found = true;  			IntPtr handle = stackFrame.Params [0];  			// Use the KiFastSystemCallRet args if the handle we have is wrong.  			if (handle.ToInt32 () % 2 != 0)  				handle = lastParams [1];  			sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for an event pair:");  			sb.AppendLine (this.GetHandleString (_pid' handle));  		}  		else if (name.StartsWith ("user32.dll!ntusergetmessage") || name.StartsWith ("user32.dll!ntuserwaitmessage")) {  			found = true;  			sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a USER message.");  		}  		else if (name.StartsWith ("ntdll.dll!zwwaitfordebugevent") || name.StartsWith ("ntdll.dll!ntwaitfordebugevent")) {  			found = true;  			IntPtr handle = stackFrame.Params [0];  			sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a debug event:");  			sb.AppendLine (this.GetHandleString (_pid' handle));  		}  		else if (name.StartsWith ("ntdll.dll!zwwaitforkeyedevent") || name.StartsWith ("ntdll.dll!ntwaitforkeyedevent") || name.StartsWith ("ntdll.dll!zwreleasekeyedevent") || name.StartsWith ("ntdll.dll!ntreleasekeyedevent")) {  			found = true;  			IntPtr handle = stackFrame.Params [0];  			IntPtr key = stackFrame.Params [1];  			sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for a keyed event (key 0x" + key.ToString ("x") + "):");  			sb.AppendLine (this.GetHandleString (_pid' handle));  		}  		else if (name.StartsWith ("ntdll.dll!zwwaitformultipleobjects") || name.StartsWith ("ntdll.dll!ntwaitformultipleobjects") || name.StartsWith ("kernel32.dll!waitformultipleobjects")) {  			found = true;  			int handleCount = stackFrame.Params [0].ToInt32 ();  			IntPtr handleAddress = stackFrame.Params [1];  			WaitType waitType = (WaitType)stackFrame.Params [2].ToInt32 ();  			bool alertable = stackFrame.Params [3].ToInt32 () != 0;  			// use the KiFastSystemCallRet args if we have the wrong args  			if (handleCount > 64) {  				handleCount = lastParams [1].ToInt32 ();  				handleAddress = lastParams [2];  				waitType = (WaitType)lastParams [3].ToInt32 ();  			}  			IntPtr* handles = stackalloc IntPtr[handleCount];  			phandle.ReadMemory (handleAddress' handles' handleCount * IntPtr.Size);  			sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + "' wait type: " + waitType.ToString () + ") for:");  			for (int i = 0; i < handleCount; i++) {  				sb.AppendLine (this.GetHandleString (_pid' handles [i]));  			}  		}  		else if (name.StartsWith ("ntdll.dll!zwwaitforsingleobject") || name.StartsWith ("ntdll.dll!ntwaitforsingleobject") || name.StartsWith ("kernel32.dll!waitforsingleobject")) {  			found = true;  			IntPtr handle = stackFrame.Params [0];  			bool alertable = stackFrame.Params [1].ToInt32 () != 0;  			sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + ") for:");  			sb.AppendLine (this.GetHandleString (_pid' handle));  		}  		else if (name.StartsWith ("ntdll.dll!zwwaitforworkviaworkerfactory") || name.StartsWith ("ntdll.dll!ntwaitforworkviaworkerfactory")) {  			found = true;  			IntPtr handle = stackFrame.Params [0];  			sb.AppendLine ("Thread " + tid.ToString () + " is waiting for work from a worker factory:");  			sb.AppendLine (this.GetHandleString (_pid' handle));  		}  		lastParams = stackFrame.Params;  		return !found;  	});  }  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,analyzeWaitMenuItem_Click,The following statement contains a magic number: using (var thandle = new ThreadHandle (tid' ThreadAccess.GetContext | ThreadAccess.SuspendResume)) {  	IntPtr[] lastParams = new IntPtr[4];  	thandle.WalkStack (phandle' stackFrame =>  {  		uint address = stackFrame.PcAddress.ToUInt32 ();  		string name = _provider.Symbols.GetSymbolFromAddress (address).ToLowerInvariant ();  		if (name == null) {  			// dummy  		}  		else if (name.StartsWith ("kernel32.dll!sleep")) {  			found = true;  			sb.Append ("Thread is sleeping. Timeout: " + stackFrame.Params [0].ToInt32 ().ToString () + " milliseconds");  		}  		else if (name.StartsWith ("ntdll.dll!zwdelayexecution") || name.StartsWith ("ntdll.dll!ntdelayexecution")) {  			found = true;  			bool alertable = stackFrame.Params [0].ToInt32 () != 0;  			IntPtr timeoutAddress = stackFrame.Params [1];  			long timeout;  			phandle.ReadMemory (timeoutAddress' &timeout' sizeof(long));  			if (timeout < 0) {  				sb.Append ("Thread is sleeping. Timeout: " + (new TimeSpan (-timeout)).TotalMilliseconds.ToString () + " milliseconds");  			}  			else {  				sb.AppendLine ("Thread is sleeping. Timeout: " + (new DateTime (timeout)).ToString ());  			}  		}  		else if (name.StartsWith ("ntdll.dll!zwdeviceiocontrolfile") || name.StartsWith ("ntdll.dll!ntdeviceiocontrolfile")) {  			found = true;  			IntPtr handle = stackFrame.Params [0];  			sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an I/O control request:");  			sb.AppendLine (this.GetHandleString (_pid' handle));  		}  		else if (name.StartsWith ("ntdll.dll!ntfscontrolfile") || name.StartsWith ("ntdll.dll!zwfscontrolfile")) {  			found = true;  			IntPtr handle = stackFrame.Params [0];  			sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an FS control request:");  			sb.AppendLine (this.GetHandleString (_pid' handle));  		}  		else if (name.StartsWith ("ntdll.dll!ntqueryobject") || name.StartsWith ("ntdll.dll!zwqueryobject")) {  			found = true;  			IntPtr handle = stackFrame.Params [0];  			// Use the KiFastSystemCallRet args if the handle we have is wrong.  			if (handle.ToInt32 () % 2 != 0 || handle == IntPtr.Zero)  				handle = lastParams [1];  			sb.AppendLine ("Thread " + tid.ToString () + " is querying an object (most likely a named pipe):");  			sb.AppendLine (this.GetHandleString (_pid' handle));  		}  		else if (name.StartsWith ("ntdll.dll!zwreadfile") || name.StartsWith ("ntdll.dll!ntreadfile") || name.StartsWith ("ntdll.dll!zwwritefile") || name.StartsWith ("ntdll.dll!ntwritefile")) {  			found = true;  			IntPtr handle = stackFrame.Params [0];  			sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a named pipe or a file:");  			sb.AppendLine (this.GetHandleString (_pid' handle));  		}  		else if (name.StartsWith ("ntdll.dll!zwremoveiocompletion") || name.StartsWith ("ntdll.dll!ntremoveiocompletion")) {  			found = true;  			IntPtr handle = stackFrame.Params [0];  			sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an I/O completion object:");  			sb.AppendLine (this.GetHandleString (_pid' handle));  		}  		else if (name.StartsWith ("ntdll.dll!zwreplywaitreceiveport") || name.StartsWith ("ntdll.dll!ntreplywaitreceiveport") || name.StartsWith ("ntdll.dll!zwrequestwaitreplyport") || name.StartsWith ("ntdll.dll!ntrequestwaitreplyport") || name.StartsWith ("ntdll.dll!zwalpcsendwaitreceiveport") || name.StartsWith ("ntdll.dll!ntalpcsendwaitreceiveport")) {  			found = true;  			IntPtr handle = stackFrame.Params [0];  			sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a LPC port:");  			sb.AppendLine (this.GetHandleString (_pid' handle));  		}  		else if (name.StartsWith ("ntdll.dll!zwsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!ntsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!zwsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!ntsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaithigheventpair") || name.StartsWith ("ntdll.dll!ntwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaitloweventpair") || name.StartsWith ("ntdll.dll!ntwaitloweventpair")) {  			found = true;  			IntPtr handle = stackFrame.Params [0];  			// Use the KiFastSystemCallRet args if the handle we have is wrong.  			if (handle.ToInt32 () % 2 != 0)  				handle = lastParams [1];  			sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for an event pair:");  			sb.AppendLine (this.GetHandleString (_pid' handle));  		}  		else if (name.StartsWith ("user32.dll!ntusergetmessage") || name.StartsWith ("user32.dll!ntuserwaitmessage")) {  			found = true;  			sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a USER message.");  		}  		else if (name.StartsWith ("ntdll.dll!zwwaitfordebugevent") || name.StartsWith ("ntdll.dll!ntwaitfordebugevent")) {  			found = true;  			IntPtr handle = stackFrame.Params [0];  			sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a debug event:");  			sb.AppendLine (this.GetHandleString (_pid' handle));  		}  		else if (name.StartsWith ("ntdll.dll!zwwaitforkeyedevent") || name.StartsWith ("ntdll.dll!ntwaitforkeyedevent") || name.StartsWith ("ntdll.dll!zwreleasekeyedevent") || name.StartsWith ("ntdll.dll!ntreleasekeyedevent")) {  			found = true;  			IntPtr handle = stackFrame.Params [0];  			IntPtr key = stackFrame.Params [1];  			sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for a keyed event (key 0x" + key.ToString ("x") + "):");  			sb.AppendLine (this.GetHandleString (_pid' handle));  		}  		else if (name.StartsWith ("ntdll.dll!zwwaitformultipleobjects") || name.StartsWith ("ntdll.dll!ntwaitformultipleobjects") || name.StartsWith ("kernel32.dll!waitformultipleobjects")) {  			found = true;  			int handleCount = stackFrame.Params [0].ToInt32 ();  			IntPtr handleAddress = stackFrame.Params [1];  			WaitType waitType = (WaitType)stackFrame.Params [2].ToInt32 ();  			bool alertable = stackFrame.Params [3].ToInt32 () != 0;  			// use the KiFastSystemCallRet args if we have the wrong args  			if (handleCount > 64) {  				handleCount = lastParams [1].ToInt32 ();  				handleAddress = lastParams [2];  				waitType = (WaitType)lastParams [3].ToInt32 ();  			}  			IntPtr* handles = stackalloc IntPtr[handleCount];  			phandle.ReadMemory (handleAddress' handles' handleCount * IntPtr.Size);  			sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + "' wait type: " + waitType.ToString () + ") for:");  			for (int i = 0; i < handleCount; i++) {  				sb.AppendLine (this.GetHandleString (_pid' handles [i]));  			}  		}  		else if (name.StartsWith ("ntdll.dll!zwwaitforsingleobject") || name.StartsWith ("ntdll.dll!ntwaitforsingleobject") || name.StartsWith ("kernel32.dll!waitforsingleobject")) {  			found = true;  			IntPtr handle = stackFrame.Params [0];  			bool alertable = stackFrame.Params [1].ToInt32 () != 0;  			sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + ") for:");  			sb.AppendLine (this.GetHandleString (_pid' handle));  		}  		else if (name.StartsWith ("ntdll.dll!zwwaitforworkviaworkerfactory") || name.StartsWith ("ntdll.dll!ntwaitforworkviaworkerfactory")) {  			found = true;  			IntPtr handle = stackFrame.Params [0];  			sb.AppendLine ("Thread " + tid.ToString () + " is waiting for work from a worker factory:");  			sb.AppendLine (this.GetHandleString (_pid' handle));  		}  		lastParams = stackFrame.Params;  		return !found;  	});  }  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,analyzeWaitMenuItem_Click,The following statement contains a magic number: using (var thandle = new ThreadHandle (tid' ThreadAccess.GetContext | ThreadAccess.SuspendResume)) {  	IntPtr[] lastParams = new IntPtr[4];  	thandle.WalkStack (phandle' stackFrame =>  {  		uint address = stackFrame.PcAddress.ToUInt32 ();  		string name = _provider.Symbols.GetSymbolFromAddress (address).ToLowerInvariant ();  		if (name == null) {  			// dummy  		}  		else if (name.StartsWith ("kernel32.dll!sleep")) {  			found = true;  			sb.Append ("Thread is sleeping. Timeout: " + stackFrame.Params [0].ToInt32 ().ToString () + " milliseconds");  		}  		else if (name.StartsWith ("ntdll.dll!zwdelayexecution") || name.StartsWith ("ntdll.dll!ntdelayexecution")) {  			found = true;  			bool alertable = stackFrame.Params [0].ToInt32 () != 0;  			IntPtr timeoutAddress = stackFrame.Params [1];  			long timeout;  			phandle.ReadMemory (timeoutAddress' &timeout' sizeof(long));  			if (timeout < 0) {  				sb.Append ("Thread is sleeping. Timeout: " + (new TimeSpan (-timeout)).TotalMilliseconds.ToString () + " milliseconds");  			}  			else {  				sb.AppendLine ("Thread is sleeping. Timeout: " + (new DateTime (timeout)).ToString ());  			}  		}  		else if (name.StartsWith ("ntdll.dll!zwdeviceiocontrolfile") || name.StartsWith ("ntdll.dll!ntdeviceiocontrolfile")) {  			found = true;  			IntPtr handle = stackFrame.Params [0];  			sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an I/O control request:");  			sb.AppendLine (this.GetHandleString (_pid' handle));  		}  		else if (name.StartsWith ("ntdll.dll!ntfscontrolfile") || name.StartsWith ("ntdll.dll!zwfscontrolfile")) {  			found = true;  			IntPtr handle = stackFrame.Params [0];  			sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an FS control request:");  			sb.AppendLine (this.GetHandleString (_pid' handle));  		}  		else if (name.StartsWith ("ntdll.dll!ntqueryobject") || name.StartsWith ("ntdll.dll!zwqueryobject")) {  			found = true;  			IntPtr handle = stackFrame.Params [0];  			// Use the KiFastSystemCallRet args if the handle we have is wrong.  			if (handle.ToInt32 () % 2 != 0 || handle == IntPtr.Zero)  				handle = lastParams [1];  			sb.AppendLine ("Thread " + tid.ToString () + " is querying an object (most likely a named pipe):");  			sb.AppendLine (this.GetHandleString (_pid' handle));  		}  		else if (name.StartsWith ("ntdll.dll!zwreadfile") || name.StartsWith ("ntdll.dll!ntreadfile") || name.StartsWith ("ntdll.dll!zwwritefile") || name.StartsWith ("ntdll.dll!ntwritefile")) {  			found = true;  			IntPtr handle = stackFrame.Params [0];  			sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a named pipe or a file:");  			sb.AppendLine (this.GetHandleString (_pid' handle));  		}  		else if (name.StartsWith ("ntdll.dll!zwremoveiocompletion") || name.StartsWith ("ntdll.dll!ntremoveiocompletion")) {  			found = true;  			IntPtr handle = stackFrame.Params [0];  			sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an I/O completion object:");  			sb.AppendLine (this.GetHandleString (_pid' handle));  		}  		else if (name.StartsWith ("ntdll.dll!zwreplywaitreceiveport") || name.StartsWith ("ntdll.dll!ntreplywaitreceiveport") || name.StartsWith ("ntdll.dll!zwrequestwaitreplyport") || name.StartsWith ("ntdll.dll!ntrequestwaitreplyport") || name.StartsWith ("ntdll.dll!zwalpcsendwaitreceiveport") || name.StartsWith ("ntdll.dll!ntalpcsendwaitreceiveport")) {  			found = true;  			IntPtr handle = stackFrame.Params [0];  			sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a LPC port:");  			sb.AppendLine (this.GetHandleString (_pid' handle));  		}  		else if (name.StartsWith ("ntdll.dll!zwsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!ntsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!zwsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!ntsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaithigheventpair") || name.StartsWith ("ntdll.dll!ntwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaitloweventpair") || name.StartsWith ("ntdll.dll!ntwaitloweventpair")) {  			found = true;  			IntPtr handle = stackFrame.Params [0];  			// Use the KiFastSystemCallRet args if the handle we have is wrong.  			if (handle.ToInt32 () % 2 != 0)  				handle = lastParams [1];  			sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for an event pair:");  			sb.AppendLine (this.GetHandleString (_pid' handle));  		}  		else if (name.StartsWith ("user32.dll!ntusergetmessage") || name.StartsWith ("user32.dll!ntuserwaitmessage")) {  			found = true;  			sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a USER message.");  		}  		else if (name.StartsWith ("ntdll.dll!zwwaitfordebugevent") || name.StartsWith ("ntdll.dll!ntwaitfordebugevent")) {  			found = true;  			IntPtr handle = stackFrame.Params [0];  			sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a debug event:");  			sb.AppendLine (this.GetHandleString (_pid' handle));  		}  		else if (name.StartsWith ("ntdll.dll!zwwaitforkeyedevent") || name.StartsWith ("ntdll.dll!ntwaitforkeyedevent") || name.StartsWith ("ntdll.dll!zwreleasekeyedevent") || name.StartsWith ("ntdll.dll!ntreleasekeyedevent")) {  			found = true;  			IntPtr handle = stackFrame.Params [0];  			IntPtr key = stackFrame.Params [1];  			sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for a keyed event (key 0x" + key.ToString ("x") + "):");  			sb.AppendLine (this.GetHandleString (_pid' handle));  		}  		else if (name.StartsWith ("ntdll.dll!zwwaitformultipleobjects") || name.StartsWith ("ntdll.dll!ntwaitformultipleobjects") || name.StartsWith ("kernel32.dll!waitformultipleobjects")) {  			found = true;  			int handleCount = stackFrame.Params [0].ToInt32 ();  			IntPtr handleAddress = stackFrame.Params [1];  			WaitType waitType = (WaitType)stackFrame.Params [2].ToInt32 ();  			bool alertable = stackFrame.Params [3].ToInt32 () != 0;  			// use the KiFastSystemCallRet args if we have the wrong args  			if (handleCount > 64) {  				handleCount = lastParams [1].ToInt32 ();  				handleAddress = lastParams [2];  				waitType = (WaitType)lastParams [3].ToInt32 ();  			}  			IntPtr* handles = stackalloc IntPtr[handleCount];  			phandle.ReadMemory (handleAddress' handles' handleCount * IntPtr.Size);  			sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + "' wait type: " + waitType.ToString () + ") for:");  			for (int i = 0; i < handleCount; i++) {  				sb.AppendLine (this.GetHandleString (_pid' handles [i]));  			}  		}  		else if (name.StartsWith ("ntdll.dll!zwwaitforsingleobject") || name.StartsWith ("ntdll.dll!ntwaitforsingleobject") || name.StartsWith ("kernel32.dll!waitforsingleobject")) {  			found = true;  			IntPtr handle = stackFrame.Params [0];  			bool alertable = stackFrame.Params [1].ToInt32 () != 0;  			sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + ") for:");  			sb.AppendLine (this.GetHandleString (_pid' handle));  		}  		else if (name.StartsWith ("ntdll.dll!zwwaitforworkviaworkerfactory") || name.StartsWith ("ntdll.dll!ntwaitforworkviaworkerfactory")) {  			found = true;  			IntPtr handle = stackFrame.Params [0];  			sb.AppendLine ("Thread " + tid.ToString () + " is waiting for work from a worker factory:");  			sb.AppendLine (this.GetHandleString (_pid' handle));  		}  		lastParams = stackFrame.Params;  		return !found;  	});  }  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,analyzeWaitMenuItem_Click,The following statement contains a magic number: using (var thandle = new ThreadHandle (tid' ThreadAccess.GetContext | ThreadAccess.SuspendResume)) {  	IntPtr[] lastParams = new IntPtr[4];  	thandle.WalkStack (phandle' stackFrame =>  {  		uint address = stackFrame.PcAddress.ToUInt32 ();  		string name = _provider.Symbols.GetSymbolFromAddress (address).ToLowerInvariant ();  		if (name == null) {  			// dummy  		}  		else if (name.StartsWith ("kernel32.dll!sleep")) {  			found = true;  			sb.Append ("Thread is sleeping. Timeout: " + stackFrame.Params [0].ToInt32 ().ToString () + " milliseconds");  		}  		else if (name.StartsWith ("ntdll.dll!zwdelayexecution") || name.StartsWith ("ntdll.dll!ntdelayexecution")) {  			found = true;  			bool alertable = stackFrame.Params [0].ToInt32 () != 0;  			IntPtr timeoutAddress = stackFrame.Params [1];  			long timeout;  			phandle.ReadMemory (timeoutAddress' &timeout' sizeof(long));  			if (timeout < 0) {  				sb.Append ("Thread is sleeping. Timeout: " + (new TimeSpan (-timeout)).TotalMilliseconds.ToString () + " milliseconds");  			}  			else {  				sb.AppendLine ("Thread is sleeping. Timeout: " + (new DateTime (timeout)).ToString ());  			}  		}  		else if (name.StartsWith ("ntdll.dll!zwdeviceiocontrolfile") || name.StartsWith ("ntdll.dll!ntdeviceiocontrolfile")) {  			found = true;  			IntPtr handle = stackFrame.Params [0];  			sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an I/O control request:");  			sb.AppendLine (this.GetHandleString (_pid' handle));  		}  		else if (name.StartsWith ("ntdll.dll!ntfscontrolfile") || name.StartsWith ("ntdll.dll!zwfscontrolfile")) {  			found = true;  			IntPtr handle = stackFrame.Params [0];  			sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an FS control request:");  			sb.AppendLine (this.GetHandleString (_pid' handle));  		}  		else if (name.StartsWith ("ntdll.dll!ntqueryobject") || name.StartsWith ("ntdll.dll!zwqueryobject")) {  			found = true;  			IntPtr handle = stackFrame.Params [0];  			// Use the KiFastSystemCallRet args if the handle we have is wrong.  			if (handle.ToInt32 () % 2 != 0 || handle == IntPtr.Zero)  				handle = lastParams [1];  			sb.AppendLine ("Thread " + tid.ToString () + " is querying an object (most likely a named pipe):");  			sb.AppendLine (this.GetHandleString (_pid' handle));  		}  		else if (name.StartsWith ("ntdll.dll!zwreadfile") || name.StartsWith ("ntdll.dll!ntreadfile") || name.StartsWith ("ntdll.dll!zwwritefile") || name.StartsWith ("ntdll.dll!ntwritefile")) {  			found = true;  			IntPtr handle = stackFrame.Params [0];  			sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a named pipe or a file:");  			sb.AppendLine (this.GetHandleString (_pid' handle));  		}  		else if (name.StartsWith ("ntdll.dll!zwremoveiocompletion") || name.StartsWith ("ntdll.dll!ntremoveiocompletion")) {  			found = true;  			IntPtr handle = stackFrame.Params [0];  			sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an I/O completion object:");  			sb.AppendLine (this.GetHandleString (_pid' handle));  		}  		else if (name.StartsWith ("ntdll.dll!zwreplywaitreceiveport") || name.StartsWith ("ntdll.dll!ntreplywaitreceiveport") || name.StartsWith ("ntdll.dll!zwrequestwaitreplyport") || name.StartsWith ("ntdll.dll!ntrequestwaitreplyport") || name.StartsWith ("ntdll.dll!zwalpcsendwaitreceiveport") || name.StartsWith ("ntdll.dll!ntalpcsendwaitreceiveport")) {  			found = true;  			IntPtr handle = stackFrame.Params [0];  			sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a LPC port:");  			sb.AppendLine (this.GetHandleString (_pid' handle));  		}  		else if (name.StartsWith ("ntdll.dll!zwsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!ntsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!zwsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!ntsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaithigheventpair") || name.StartsWith ("ntdll.dll!ntwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaitloweventpair") || name.StartsWith ("ntdll.dll!ntwaitloweventpair")) {  			found = true;  			IntPtr handle = stackFrame.Params [0];  			// Use the KiFastSystemCallRet args if the handle we have is wrong.  			if (handle.ToInt32 () % 2 != 0)  				handle = lastParams [1];  			sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for an event pair:");  			sb.AppendLine (this.GetHandleString (_pid' handle));  		}  		else if (name.StartsWith ("user32.dll!ntusergetmessage") || name.StartsWith ("user32.dll!ntuserwaitmessage")) {  			found = true;  			sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a USER message.");  		}  		else if (name.StartsWith ("ntdll.dll!zwwaitfordebugevent") || name.StartsWith ("ntdll.dll!ntwaitfordebugevent")) {  			found = true;  			IntPtr handle = stackFrame.Params [0];  			sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a debug event:");  			sb.AppendLine (this.GetHandleString (_pid' handle));  		}  		else if (name.StartsWith ("ntdll.dll!zwwaitforkeyedevent") || name.StartsWith ("ntdll.dll!ntwaitforkeyedevent") || name.StartsWith ("ntdll.dll!zwreleasekeyedevent") || name.StartsWith ("ntdll.dll!ntreleasekeyedevent")) {  			found = true;  			IntPtr handle = stackFrame.Params [0];  			IntPtr key = stackFrame.Params [1];  			sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for a keyed event (key 0x" + key.ToString ("x") + "):");  			sb.AppendLine (this.GetHandleString (_pid' handle));  		}  		else if (name.StartsWith ("ntdll.dll!zwwaitformultipleobjects") || name.StartsWith ("ntdll.dll!ntwaitformultipleobjects") || name.StartsWith ("kernel32.dll!waitformultipleobjects")) {  			found = true;  			int handleCount = stackFrame.Params [0].ToInt32 ();  			IntPtr handleAddress = stackFrame.Params [1];  			WaitType waitType = (WaitType)stackFrame.Params [2].ToInt32 ();  			bool alertable = stackFrame.Params [3].ToInt32 () != 0;  			// use the KiFastSystemCallRet args if we have the wrong args  			if (handleCount > 64) {  				handleCount = lastParams [1].ToInt32 ();  				handleAddress = lastParams [2];  				waitType = (WaitType)lastParams [3].ToInt32 ();  			}  			IntPtr* handles = stackalloc IntPtr[handleCount];  			phandle.ReadMemory (handleAddress' handles' handleCount * IntPtr.Size);  			sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + "' wait type: " + waitType.ToString () + ") for:");  			for (int i = 0; i < handleCount; i++) {  				sb.AppendLine (this.GetHandleString (_pid' handles [i]));  			}  		}  		else if (name.StartsWith ("ntdll.dll!zwwaitforsingleobject") || name.StartsWith ("ntdll.dll!ntwaitforsingleobject") || name.StartsWith ("kernel32.dll!waitforsingleobject")) {  			found = true;  			IntPtr handle = stackFrame.Params [0];  			bool alertable = stackFrame.Params [1].ToInt32 () != 0;  			sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + ") for:");  			sb.AppendLine (this.GetHandleString (_pid' handle));  		}  		else if (name.StartsWith ("ntdll.dll!zwwaitforworkviaworkerfactory") || name.StartsWith ("ntdll.dll!ntwaitforworkviaworkerfactory")) {  			found = true;  			IntPtr handle = stackFrame.Params [0];  			sb.AppendLine ("Thread " + tid.ToString () + " is waiting for work from a worker factory:");  			sb.AppendLine (this.GetHandleString (_pid' handle));  		}  		lastParams = stackFrame.Params;  		return !found;  	});  }  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,analyzeWaitMenuItem_Click,The following statement contains a magic number: using (var thandle = new ThreadHandle (tid' ThreadAccess.GetContext | ThreadAccess.SuspendResume)) {  	IntPtr[] lastParams = new IntPtr[4];  	thandle.WalkStack (phandle' stackFrame =>  {  		uint address = stackFrame.PcAddress.ToUInt32 ();  		string name = _provider.Symbols.GetSymbolFromAddress (address).ToLowerInvariant ();  		if (name == null) {  			// dummy  		}  		else if (name.StartsWith ("kernel32.dll!sleep")) {  			found = true;  			sb.Append ("Thread is sleeping. Timeout: " + stackFrame.Params [0].ToInt32 ().ToString () + " milliseconds");  		}  		else if (name.StartsWith ("ntdll.dll!zwdelayexecution") || name.StartsWith ("ntdll.dll!ntdelayexecution")) {  			found = true;  			bool alertable = stackFrame.Params [0].ToInt32 () != 0;  			IntPtr timeoutAddress = stackFrame.Params [1];  			long timeout;  			phandle.ReadMemory (timeoutAddress' &timeout' sizeof(long));  			if (timeout < 0) {  				sb.Append ("Thread is sleeping. Timeout: " + (new TimeSpan (-timeout)).TotalMilliseconds.ToString () + " milliseconds");  			}  			else {  				sb.AppendLine ("Thread is sleeping. Timeout: " + (new DateTime (timeout)).ToString ());  			}  		}  		else if (name.StartsWith ("ntdll.dll!zwdeviceiocontrolfile") || name.StartsWith ("ntdll.dll!ntdeviceiocontrolfile")) {  			found = true;  			IntPtr handle = stackFrame.Params [0];  			sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an I/O control request:");  			sb.AppendLine (this.GetHandleString (_pid' handle));  		}  		else if (name.StartsWith ("ntdll.dll!ntfscontrolfile") || name.StartsWith ("ntdll.dll!zwfscontrolfile")) {  			found = true;  			IntPtr handle = stackFrame.Params [0];  			sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an FS control request:");  			sb.AppendLine (this.GetHandleString (_pid' handle));  		}  		else if (name.StartsWith ("ntdll.dll!ntqueryobject") || name.StartsWith ("ntdll.dll!zwqueryobject")) {  			found = true;  			IntPtr handle = stackFrame.Params [0];  			// Use the KiFastSystemCallRet args if the handle we have is wrong.  			if (handle.ToInt32 () % 2 != 0 || handle == IntPtr.Zero)  				handle = lastParams [1];  			sb.AppendLine ("Thread " + tid.ToString () + " is querying an object (most likely a named pipe):");  			sb.AppendLine (this.GetHandleString (_pid' handle));  		}  		else if (name.StartsWith ("ntdll.dll!zwreadfile") || name.StartsWith ("ntdll.dll!ntreadfile") || name.StartsWith ("ntdll.dll!zwwritefile") || name.StartsWith ("ntdll.dll!ntwritefile")) {  			found = true;  			IntPtr handle = stackFrame.Params [0];  			sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a named pipe or a file:");  			sb.AppendLine (this.GetHandleString (_pid' handle));  		}  		else if (name.StartsWith ("ntdll.dll!zwremoveiocompletion") || name.StartsWith ("ntdll.dll!ntremoveiocompletion")) {  			found = true;  			IntPtr handle = stackFrame.Params [0];  			sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an I/O completion object:");  			sb.AppendLine (this.GetHandleString (_pid' handle));  		}  		else if (name.StartsWith ("ntdll.dll!zwreplywaitreceiveport") || name.StartsWith ("ntdll.dll!ntreplywaitreceiveport") || name.StartsWith ("ntdll.dll!zwrequestwaitreplyport") || name.StartsWith ("ntdll.dll!ntrequestwaitreplyport") || name.StartsWith ("ntdll.dll!zwalpcsendwaitreceiveport") || name.StartsWith ("ntdll.dll!ntalpcsendwaitreceiveport")) {  			found = true;  			IntPtr handle = stackFrame.Params [0];  			sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a LPC port:");  			sb.AppendLine (this.GetHandleString (_pid' handle));  		}  		else if (name.StartsWith ("ntdll.dll!zwsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!ntsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!zwsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!ntsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaithigheventpair") || name.StartsWith ("ntdll.dll!ntwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaitloweventpair") || name.StartsWith ("ntdll.dll!ntwaitloweventpair")) {  			found = true;  			IntPtr handle = stackFrame.Params [0];  			// Use the KiFastSystemCallRet args if the handle we have is wrong.  			if (handle.ToInt32 () % 2 != 0)  				handle = lastParams [1];  			sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for an event pair:");  			sb.AppendLine (this.GetHandleString (_pid' handle));  		}  		else if (name.StartsWith ("user32.dll!ntusergetmessage") || name.StartsWith ("user32.dll!ntuserwaitmessage")) {  			found = true;  			sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a USER message.");  		}  		else if (name.StartsWith ("ntdll.dll!zwwaitfordebugevent") || name.StartsWith ("ntdll.dll!ntwaitfordebugevent")) {  			found = true;  			IntPtr handle = stackFrame.Params [0];  			sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a debug event:");  			sb.AppendLine (this.GetHandleString (_pid' handle));  		}  		else if (name.StartsWith ("ntdll.dll!zwwaitforkeyedevent") || name.StartsWith ("ntdll.dll!ntwaitforkeyedevent") || name.StartsWith ("ntdll.dll!zwreleasekeyedevent") || name.StartsWith ("ntdll.dll!ntreleasekeyedevent")) {  			found = true;  			IntPtr handle = stackFrame.Params [0];  			IntPtr key = stackFrame.Params [1];  			sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for a keyed event (key 0x" + key.ToString ("x") + "):");  			sb.AppendLine (this.GetHandleString (_pid' handle));  		}  		else if (name.StartsWith ("ntdll.dll!zwwaitformultipleobjects") || name.StartsWith ("ntdll.dll!ntwaitformultipleobjects") || name.StartsWith ("kernel32.dll!waitformultipleobjects")) {  			found = true;  			int handleCount = stackFrame.Params [0].ToInt32 ();  			IntPtr handleAddress = stackFrame.Params [1];  			WaitType waitType = (WaitType)stackFrame.Params [2].ToInt32 ();  			bool alertable = stackFrame.Params [3].ToInt32 () != 0;  			// use the KiFastSystemCallRet args if we have the wrong args  			if (handleCount > 64) {  				handleCount = lastParams [1].ToInt32 ();  				handleAddress = lastParams [2];  				waitType = (WaitType)lastParams [3].ToInt32 ();  			}  			IntPtr* handles = stackalloc IntPtr[handleCount];  			phandle.ReadMemory (handleAddress' handles' handleCount * IntPtr.Size);  			sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + "' wait type: " + waitType.ToString () + ") for:");  			for (int i = 0; i < handleCount; i++) {  				sb.AppendLine (this.GetHandleString (_pid' handles [i]));  			}  		}  		else if (name.StartsWith ("ntdll.dll!zwwaitforsingleobject") || name.StartsWith ("ntdll.dll!ntwaitforsingleobject") || name.StartsWith ("kernel32.dll!waitforsingleobject")) {  			found = true;  			IntPtr handle = stackFrame.Params [0];  			bool alertable = stackFrame.Params [1].ToInt32 () != 0;  			sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + ") for:");  			sb.AppendLine (this.GetHandleString (_pid' handle));  		}  		else if (name.StartsWith ("ntdll.dll!zwwaitforworkviaworkerfactory") || name.StartsWith ("ntdll.dll!ntwaitforworkviaworkerfactory")) {  			found = true;  			IntPtr handle = stackFrame.Params [0];  			sb.AppendLine ("Thread " + tid.ToString () + " is waiting for work from a worker factory:");  			sb.AppendLine (this.GetHandleString (_pid' handle));  		}  		lastParams = stackFrame.Params;  		return !found;  	});  }  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,analyzeWaitMenuItem_Click,The following statement contains a magic number: using (var thandle = new ThreadHandle (tid' ThreadAccess.GetContext | ThreadAccess.SuspendResume)) {  	IntPtr[] lastParams = new IntPtr[4];  	thandle.WalkStack (phandle' stackFrame =>  {  		uint address = stackFrame.PcAddress.ToUInt32 ();  		string name = _provider.Symbols.GetSymbolFromAddress (address).ToLowerInvariant ();  		if (name == null) {  			// dummy  		}  		else if (name.StartsWith ("kernel32.dll!sleep")) {  			found = true;  			sb.Append ("Thread is sleeping. Timeout: " + stackFrame.Params [0].ToInt32 ().ToString () + " milliseconds");  		}  		else if (name.StartsWith ("ntdll.dll!zwdelayexecution") || name.StartsWith ("ntdll.dll!ntdelayexecution")) {  			found = true;  			bool alertable = stackFrame.Params [0].ToInt32 () != 0;  			IntPtr timeoutAddress = stackFrame.Params [1];  			long timeout;  			phandle.ReadMemory (timeoutAddress' &timeout' sizeof(long));  			if (timeout < 0) {  				sb.Append ("Thread is sleeping. Timeout: " + (new TimeSpan (-timeout)).TotalMilliseconds.ToString () + " milliseconds");  			}  			else {  				sb.AppendLine ("Thread is sleeping. Timeout: " + (new DateTime (timeout)).ToString ());  			}  		}  		else if (name.StartsWith ("ntdll.dll!zwdeviceiocontrolfile") || name.StartsWith ("ntdll.dll!ntdeviceiocontrolfile")) {  			found = true;  			IntPtr handle = stackFrame.Params [0];  			sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an I/O control request:");  			sb.AppendLine (this.GetHandleString (_pid' handle));  		}  		else if (name.StartsWith ("ntdll.dll!ntfscontrolfile") || name.StartsWith ("ntdll.dll!zwfscontrolfile")) {  			found = true;  			IntPtr handle = stackFrame.Params [0];  			sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an FS control request:");  			sb.AppendLine (this.GetHandleString (_pid' handle));  		}  		else if (name.StartsWith ("ntdll.dll!ntqueryobject") || name.StartsWith ("ntdll.dll!zwqueryobject")) {  			found = true;  			IntPtr handle = stackFrame.Params [0];  			// Use the KiFastSystemCallRet args if the handle we have is wrong.  			if (handle.ToInt32 () % 2 != 0 || handle == IntPtr.Zero)  				handle = lastParams [1];  			sb.AppendLine ("Thread " + tid.ToString () + " is querying an object (most likely a named pipe):");  			sb.AppendLine (this.GetHandleString (_pid' handle));  		}  		else if (name.StartsWith ("ntdll.dll!zwreadfile") || name.StartsWith ("ntdll.dll!ntreadfile") || name.StartsWith ("ntdll.dll!zwwritefile") || name.StartsWith ("ntdll.dll!ntwritefile")) {  			found = true;  			IntPtr handle = stackFrame.Params [0];  			sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a named pipe or a file:");  			sb.AppendLine (this.GetHandleString (_pid' handle));  		}  		else if (name.StartsWith ("ntdll.dll!zwremoveiocompletion") || name.StartsWith ("ntdll.dll!ntremoveiocompletion")) {  			found = true;  			IntPtr handle = stackFrame.Params [0];  			sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an I/O completion object:");  			sb.AppendLine (this.GetHandleString (_pid' handle));  		}  		else if (name.StartsWith ("ntdll.dll!zwreplywaitreceiveport") || name.StartsWith ("ntdll.dll!ntreplywaitreceiveport") || name.StartsWith ("ntdll.dll!zwrequestwaitreplyport") || name.StartsWith ("ntdll.dll!ntrequestwaitreplyport") || name.StartsWith ("ntdll.dll!zwalpcsendwaitreceiveport") || name.StartsWith ("ntdll.dll!ntalpcsendwaitreceiveport")) {  			found = true;  			IntPtr handle = stackFrame.Params [0];  			sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a LPC port:");  			sb.AppendLine (this.GetHandleString (_pid' handle));  		}  		else if (name.StartsWith ("ntdll.dll!zwsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!ntsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!zwsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!ntsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaithigheventpair") || name.StartsWith ("ntdll.dll!ntwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaitloweventpair") || name.StartsWith ("ntdll.dll!ntwaitloweventpair")) {  			found = true;  			IntPtr handle = stackFrame.Params [0];  			// Use the KiFastSystemCallRet args if the handle we have is wrong.  			if (handle.ToInt32 () % 2 != 0)  				handle = lastParams [1];  			sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for an event pair:");  			sb.AppendLine (this.GetHandleString (_pid' handle));  		}  		else if (name.StartsWith ("user32.dll!ntusergetmessage") || name.StartsWith ("user32.dll!ntuserwaitmessage")) {  			found = true;  			sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a USER message.");  		}  		else if (name.StartsWith ("ntdll.dll!zwwaitfordebugevent") || name.StartsWith ("ntdll.dll!ntwaitfordebugevent")) {  			found = true;  			IntPtr handle = stackFrame.Params [0];  			sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a debug event:");  			sb.AppendLine (this.GetHandleString (_pid' handle));  		}  		else if (name.StartsWith ("ntdll.dll!zwwaitforkeyedevent") || name.StartsWith ("ntdll.dll!ntwaitforkeyedevent") || name.StartsWith ("ntdll.dll!zwreleasekeyedevent") || name.StartsWith ("ntdll.dll!ntreleasekeyedevent")) {  			found = true;  			IntPtr handle = stackFrame.Params [0];  			IntPtr key = stackFrame.Params [1];  			sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for a keyed event (key 0x" + key.ToString ("x") + "):");  			sb.AppendLine (this.GetHandleString (_pid' handle));  		}  		else if (name.StartsWith ("ntdll.dll!zwwaitformultipleobjects") || name.StartsWith ("ntdll.dll!ntwaitformultipleobjects") || name.StartsWith ("kernel32.dll!waitformultipleobjects")) {  			found = true;  			int handleCount = stackFrame.Params [0].ToInt32 ();  			IntPtr handleAddress = stackFrame.Params [1];  			WaitType waitType = (WaitType)stackFrame.Params [2].ToInt32 ();  			bool alertable = stackFrame.Params [3].ToInt32 () != 0;  			// use the KiFastSystemCallRet args if we have the wrong args  			if (handleCount > 64) {  				handleCount = lastParams [1].ToInt32 ();  				handleAddress = lastParams [2];  				waitType = (WaitType)lastParams [3].ToInt32 ();  			}  			IntPtr* handles = stackalloc IntPtr[handleCount];  			phandle.ReadMemory (handleAddress' handles' handleCount * IntPtr.Size);  			sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + "' wait type: " + waitType.ToString () + ") for:");  			for (int i = 0; i < handleCount; i++) {  				sb.AppendLine (this.GetHandleString (_pid' handles [i]));  			}  		}  		else if (name.StartsWith ("ntdll.dll!zwwaitforsingleobject") || name.StartsWith ("ntdll.dll!ntwaitforsingleobject") || name.StartsWith ("kernel32.dll!waitforsingleobject")) {  			found = true;  			IntPtr handle = stackFrame.Params [0];  			bool alertable = stackFrame.Params [1].ToInt32 () != 0;  			sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + ") for:");  			sb.AppendLine (this.GetHandleString (_pid' handle));  		}  		else if (name.StartsWith ("ntdll.dll!zwwaitforworkviaworkerfactory") || name.StartsWith ("ntdll.dll!ntwaitforworkviaworkerfactory")) {  			found = true;  			IntPtr handle = stackFrame.Params [0];  			sb.AppendLine ("Thread " + tid.ToString () + " is waiting for work from a worker factory:");  			sb.AppendLine (this.GetHandleString (_pid' handle));  		}  		lastParams = stackFrame.Params;  		return !found;  	});  }  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,analyzeWaitMenuItem_Click,The following statement contains a magic number: using (var thandle = new ThreadHandle (tid' ThreadAccess.GetContext | ThreadAccess.SuspendResume)) {  	IntPtr[] lastParams = new IntPtr[4];  	thandle.WalkStack (phandle' stackFrame =>  {  		uint address = stackFrame.PcAddress.ToUInt32 ();  		string name = _provider.Symbols.GetSymbolFromAddress (address).ToLowerInvariant ();  		if (name == null) {  			// dummy  		}  		else if (name.StartsWith ("kernel32.dll!sleep")) {  			found = true;  			sb.Append ("Thread is sleeping. Timeout: " + stackFrame.Params [0].ToInt32 ().ToString () + " milliseconds");  		}  		else if (name.StartsWith ("ntdll.dll!zwdelayexecution") || name.StartsWith ("ntdll.dll!ntdelayexecution")) {  			found = true;  			bool alertable = stackFrame.Params [0].ToInt32 () != 0;  			IntPtr timeoutAddress = stackFrame.Params [1];  			long timeout;  			phandle.ReadMemory (timeoutAddress' &timeout' sizeof(long));  			if (timeout < 0) {  				sb.Append ("Thread is sleeping. Timeout: " + (new TimeSpan (-timeout)).TotalMilliseconds.ToString () + " milliseconds");  			}  			else {  				sb.AppendLine ("Thread is sleeping. Timeout: " + (new DateTime (timeout)).ToString ());  			}  		}  		else if (name.StartsWith ("ntdll.dll!zwdeviceiocontrolfile") || name.StartsWith ("ntdll.dll!ntdeviceiocontrolfile")) {  			found = true;  			IntPtr handle = stackFrame.Params [0];  			sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an I/O control request:");  			sb.AppendLine (this.GetHandleString (_pid' handle));  		}  		else if (name.StartsWith ("ntdll.dll!ntfscontrolfile") || name.StartsWith ("ntdll.dll!zwfscontrolfile")) {  			found = true;  			IntPtr handle = stackFrame.Params [0];  			sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an FS control request:");  			sb.AppendLine (this.GetHandleString (_pid' handle));  		}  		else if (name.StartsWith ("ntdll.dll!ntqueryobject") || name.StartsWith ("ntdll.dll!zwqueryobject")) {  			found = true;  			IntPtr handle = stackFrame.Params [0];  			// Use the KiFastSystemCallRet args if the handle we have is wrong.  			if (handle.ToInt32 () % 2 != 0 || handle == IntPtr.Zero)  				handle = lastParams [1];  			sb.AppendLine ("Thread " + tid.ToString () + " is querying an object (most likely a named pipe):");  			sb.AppendLine (this.GetHandleString (_pid' handle));  		}  		else if (name.StartsWith ("ntdll.dll!zwreadfile") || name.StartsWith ("ntdll.dll!ntreadfile") || name.StartsWith ("ntdll.dll!zwwritefile") || name.StartsWith ("ntdll.dll!ntwritefile")) {  			found = true;  			IntPtr handle = stackFrame.Params [0];  			sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a named pipe or a file:");  			sb.AppendLine (this.GetHandleString (_pid' handle));  		}  		else if (name.StartsWith ("ntdll.dll!zwremoveiocompletion") || name.StartsWith ("ntdll.dll!ntremoveiocompletion")) {  			found = true;  			IntPtr handle = stackFrame.Params [0];  			sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an I/O completion object:");  			sb.AppendLine (this.GetHandleString (_pid' handle));  		}  		else if (name.StartsWith ("ntdll.dll!zwreplywaitreceiveport") || name.StartsWith ("ntdll.dll!ntreplywaitreceiveport") || name.StartsWith ("ntdll.dll!zwrequestwaitreplyport") || name.StartsWith ("ntdll.dll!ntrequestwaitreplyport") || name.StartsWith ("ntdll.dll!zwalpcsendwaitreceiveport") || name.StartsWith ("ntdll.dll!ntalpcsendwaitreceiveport")) {  			found = true;  			IntPtr handle = stackFrame.Params [0];  			sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a LPC port:");  			sb.AppendLine (this.GetHandleString (_pid' handle));  		}  		else if (name.StartsWith ("ntdll.dll!zwsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!ntsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!zwsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!ntsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaithigheventpair") || name.StartsWith ("ntdll.dll!ntwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaitloweventpair") || name.StartsWith ("ntdll.dll!ntwaitloweventpair")) {  			found = true;  			IntPtr handle = stackFrame.Params [0];  			// Use the KiFastSystemCallRet args if the handle we have is wrong.  			if (handle.ToInt32 () % 2 != 0)  				handle = lastParams [1];  			sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for an event pair:");  			sb.AppendLine (this.GetHandleString (_pid' handle));  		}  		else if (name.StartsWith ("user32.dll!ntusergetmessage") || name.StartsWith ("user32.dll!ntuserwaitmessage")) {  			found = true;  			sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a USER message.");  		}  		else if (name.StartsWith ("ntdll.dll!zwwaitfordebugevent") || name.StartsWith ("ntdll.dll!ntwaitfordebugevent")) {  			found = true;  			IntPtr handle = stackFrame.Params [0];  			sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a debug event:");  			sb.AppendLine (this.GetHandleString (_pid' handle));  		}  		else if (name.StartsWith ("ntdll.dll!zwwaitforkeyedevent") || name.StartsWith ("ntdll.dll!ntwaitforkeyedevent") || name.StartsWith ("ntdll.dll!zwreleasekeyedevent") || name.StartsWith ("ntdll.dll!ntreleasekeyedevent")) {  			found = true;  			IntPtr handle = stackFrame.Params [0];  			IntPtr key = stackFrame.Params [1];  			sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for a keyed event (key 0x" + key.ToString ("x") + "):");  			sb.AppendLine (this.GetHandleString (_pid' handle));  		}  		else if (name.StartsWith ("ntdll.dll!zwwaitformultipleobjects") || name.StartsWith ("ntdll.dll!ntwaitformultipleobjects") || name.StartsWith ("kernel32.dll!waitformultipleobjects")) {  			found = true;  			int handleCount = stackFrame.Params [0].ToInt32 ();  			IntPtr handleAddress = stackFrame.Params [1];  			WaitType waitType = (WaitType)stackFrame.Params [2].ToInt32 ();  			bool alertable = stackFrame.Params [3].ToInt32 () != 0;  			// use the KiFastSystemCallRet args if we have the wrong args  			if (handleCount > 64) {  				handleCount = lastParams [1].ToInt32 ();  				handleAddress = lastParams [2];  				waitType = (WaitType)lastParams [3].ToInt32 ();  			}  			IntPtr* handles = stackalloc IntPtr[handleCount];  			phandle.ReadMemory (handleAddress' handles' handleCount * IntPtr.Size);  			sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + "' wait type: " + waitType.ToString () + ") for:");  			for (int i = 0; i < handleCount; i++) {  				sb.AppendLine (this.GetHandleString (_pid' handles [i]));  			}  		}  		else if (name.StartsWith ("ntdll.dll!zwwaitforsingleobject") || name.StartsWith ("ntdll.dll!ntwaitforsingleobject") || name.StartsWith ("kernel32.dll!waitforsingleobject")) {  			found = true;  			IntPtr handle = stackFrame.Params [0];  			bool alertable = stackFrame.Params [1].ToInt32 () != 0;  			sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + ") for:");  			sb.AppendLine (this.GetHandleString (_pid' handle));  		}  		else if (name.StartsWith ("ntdll.dll!zwwaitforworkviaworkerfactory") || name.StartsWith ("ntdll.dll!ntwaitforworkviaworkerfactory")) {  			found = true;  			IntPtr handle = stackFrame.Params [0];  			sb.AppendLine ("Thread " + tid.ToString () + " is waiting for work from a worker factory:");  			sb.AppendLine (this.GetHandleString (_pid' handle));  		}  		lastParams = stackFrame.Params;  		return !found;  	});  }  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,analyzeWaitMenuItem_Click,The following statement contains a magic number: using (var thandle = new ThreadHandle (tid' ThreadAccess.GetContext | ThreadAccess.SuspendResume)) {  	IntPtr[] lastParams = new IntPtr[4];  	thandle.WalkStack (phandle' stackFrame =>  {  		uint address = stackFrame.PcAddress.ToUInt32 ();  		string name = _provider.Symbols.GetSymbolFromAddress (address).ToLowerInvariant ();  		if (name == null) {  			// dummy  		}  		else if (name.StartsWith ("kernel32.dll!sleep")) {  			found = true;  			sb.Append ("Thread is sleeping. Timeout: " + stackFrame.Params [0].ToInt32 ().ToString () + " milliseconds");  		}  		else if (name.StartsWith ("ntdll.dll!zwdelayexecution") || name.StartsWith ("ntdll.dll!ntdelayexecution")) {  			found = true;  			bool alertable = stackFrame.Params [0].ToInt32 () != 0;  			IntPtr timeoutAddress = stackFrame.Params [1];  			long timeout;  			phandle.ReadMemory (timeoutAddress' &timeout' sizeof(long));  			if (timeout < 0) {  				sb.Append ("Thread is sleeping. Timeout: " + (new TimeSpan (-timeout)).TotalMilliseconds.ToString () + " milliseconds");  			}  			else {  				sb.AppendLine ("Thread is sleeping. Timeout: " + (new DateTime (timeout)).ToString ());  			}  		}  		else if (name.StartsWith ("ntdll.dll!zwdeviceiocontrolfile") || name.StartsWith ("ntdll.dll!ntdeviceiocontrolfile")) {  			found = true;  			IntPtr handle = stackFrame.Params [0];  			sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an I/O control request:");  			sb.AppendLine (this.GetHandleString (_pid' handle));  		}  		else if (name.StartsWith ("ntdll.dll!ntfscontrolfile") || name.StartsWith ("ntdll.dll!zwfscontrolfile")) {  			found = true;  			IntPtr handle = stackFrame.Params [0];  			sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an FS control request:");  			sb.AppendLine (this.GetHandleString (_pid' handle));  		}  		else if (name.StartsWith ("ntdll.dll!ntqueryobject") || name.StartsWith ("ntdll.dll!zwqueryobject")) {  			found = true;  			IntPtr handle = stackFrame.Params [0];  			// Use the KiFastSystemCallRet args if the handle we have is wrong.  			if (handle.ToInt32 () % 2 != 0 || handle == IntPtr.Zero)  				handle = lastParams [1];  			sb.AppendLine ("Thread " + tid.ToString () + " is querying an object (most likely a named pipe):");  			sb.AppendLine (this.GetHandleString (_pid' handle));  		}  		else if (name.StartsWith ("ntdll.dll!zwreadfile") || name.StartsWith ("ntdll.dll!ntreadfile") || name.StartsWith ("ntdll.dll!zwwritefile") || name.StartsWith ("ntdll.dll!ntwritefile")) {  			found = true;  			IntPtr handle = stackFrame.Params [0];  			sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a named pipe or a file:");  			sb.AppendLine (this.GetHandleString (_pid' handle));  		}  		else if (name.StartsWith ("ntdll.dll!zwremoveiocompletion") || name.StartsWith ("ntdll.dll!ntremoveiocompletion")) {  			found = true;  			IntPtr handle = stackFrame.Params [0];  			sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an I/O completion object:");  			sb.AppendLine (this.GetHandleString (_pid' handle));  		}  		else if (name.StartsWith ("ntdll.dll!zwreplywaitreceiveport") || name.StartsWith ("ntdll.dll!ntreplywaitreceiveport") || name.StartsWith ("ntdll.dll!zwrequestwaitreplyport") || name.StartsWith ("ntdll.dll!ntrequestwaitreplyport") || name.StartsWith ("ntdll.dll!zwalpcsendwaitreceiveport") || name.StartsWith ("ntdll.dll!ntalpcsendwaitreceiveport")) {  			found = true;  			IntPtr handle = stackFrame.Params [0];  			sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a LPC port:");  			sb.AppendLine (this.GetHandleString (_pid' handle));  		}  		else if (name.StartsWith ("ntdll.dll!zwsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!ntsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!zwsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!ntsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaithigheventpair") || name.StartsWith ("ntdll.dll!ntwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaitloweventpair") || name.StartsWith ("ntdll.dll!ntwaitloweventpair")) {  			found = true;  			IntPtr handle = stackFrame.Params [0];  			// Use the KiFastSystemCallRet args if the handle we have is wrong.  			if (handle.ToInt32 () % 2 != 0)  				handle = lastParams [1];  			sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for an event pair:");  			sb.AppendLine (this.GetHandleString (_pid' handle));  		}  		else if (name.StartsWith ("user32.dll!ntusergetmessage") || name.StartsWith ("user32.dll!ntuserwaitmessage")) {  			found = true;  			sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a USER message.");  		}  		else if (name.StartsWith ("ntdll.dll!zwwaitfordebugevent") || name.StartsWith ("ntdll.dll!ntwaitfordebugevent")) {  			found = true;  			IntPtr handle = stackFrame.Params [0];  			sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a debug event:");  			sb.AppendLine (this.GetHandleString (_pid' handle));  		}  		else if (name.StartsWith ("ntdll.dll!zwwaitforkeyedevent") || name.StartsWith ("ntdll.dll!ntwaitforkeyedevent") || name.StartsWith ("ntdll.dll!zwreleasekeyedevent") || name.StartsWith ("ntdll.dll!ntreleasekeyedevent")) {  			found = true;  			IntPtr handle = stackFrame.Params [0];  			IntPtr key = stackFrame.Params [1];  			sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for a keyed event (key 0x" + key.ToString ("x") + "):");  			sb.AppendLine (this.GetHandleString (_pid' handle));  		}  		else if (name.StartsWith ("ntdll.dll!zwwaitformultipleobjects") || name.StartsWith ("ntdll.dll!ntwaitformultipleobjects") || name.StartsWith ("kernel32.dll!waitformultipleobjects")) {  			found = true;  			int handleCount = stackFrame.Params [0].ToInt32 ();  			IntPtr handleAddress = stackFrame.Params [1];  			WaitType waitType = (WaitType)stackFrame.Params [2].ToInt32 ();  			bool alertable = stackFrame.Params [3].ToInt32 () != 0;  			// use the KiFastSystemCallRet args if we have the wrong args  			if (handleCount > 64) {  				handleCount = lastParams [1].ToInt32 ();  				handleAddress = lastParams [2];  				waitType = (WaitType)lastParams [3].ToInt32 ();  			}  			IntPtr* handles = stackalloc IntPtr[handleCount];  			phandle.ReadMemory (handleAddress' handles' handleCount * IntPtr.Size);  			sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + "' wait type: " + waitType.ToString () + ") for:");  			for (int i = 0; i < handleCount; i++) {  				sb.AppendLine (this.GetHandleString (_pid' handles [i]));  			}  		}  		else if (name.StartsWith ("ntdll.dll!zwwaitforsingleobject") || name.StartsWith ("ntdll.dll!ntwaitforsingleobject") || name.StartsWith ("kernel32.dll!waitforsingleobject")) {  			found = true;  			IntPtr handle = stackFrame.Params [0];  			bool alertable = stackFrame.Params [1].ToInt32 () != 0;  			sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + ") for:");  			sb.AppendLine (this.GetHandleString (_pid' handle));  		}  		else if (name.StartsWith ("ntdll.dll!zwwaitforworkviaworkerfactory") || name.StartsWith ("ntdll.dll!ntwaitforworkviaworkerfactory")) {  			found = true;  			IntPtr handle = stackFrame.Params [0];  			sb.AppendLine ("Thread " + tid.ToString () + " is waiting for work from a worker factory:");  			sb.AppendLine (this.GetHandleString (_pid' handle));  		}  		lastParams = stackFrame.Params;  		return !found;  	});  }  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,analyzeWaitMenuItem_Click,The following statement contains a magic number: thandle.WalkStack (phandle' stackFrame =>  {  	uint address = stackFrame.PcAddress.ToUInt32 ();  	string name = _provider.Symbols.GetSymbolFromAddress (address).ToLowerInvariant ();  	if (name == null) {  		// dummy  	}  	else if (name.StartsWith ("kernel32.dll!sleep")) {  		found = true;  		sb.Append ("Thread is sleeping. Timeout: " + stackFrame.Params [0].ToInt32 ().ToString () + " milliseconds");  	}  	else if (name.StartsWith ("ntdll.dll!zwdelayexecution") || name.StartsWith ("ntdll.dll!ntdelayexecution")) {  		found = true;  		bool alertable = stackFrame.Params [0].ToInt32 () != 0;  		IntPtr timeoutAddress = stackFrame.Params [1];  		long timeout;  		phandle.ReadMemory (timeoutAddress' &timeout' sizeof(long));  		if (timeout < 0) {  			sb.Append ("Thread is sleeping. Timeout: " + (new TimeSpan (-timeout)).TotalMilliseconds.ToString () + " milliseconds");  		}  		else {  			sb.AppendLine ("Thread is sleeping. Timeout: " + (new DateTime (timeout)).ToString ());  		}  	}  	else if (name.StartsWith ("ntdll.dll!zwdeviceiocontrolfile") || name.StartsWith ("ntdll.dll!ntdeviceiocontrolfile")) {  		found = true;  		IntPtr handle = stackFrame.Params [0];  		sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an I/O control request:");  		sb.AppendLine (this.GetHandleString (_pid' handle));  	}  	else if (name.StartsWith ("ntdll.dll!ntfscontrolfile") || name.StartsWith ("ntdll.dll!zwfscontrolfile")) {  		found = true;  		IntPtr handle = stackFrame.Params [0];  		sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an FS control request:");  		sb.AppendLine (this.GetHandleString (_pid' handle));  	}  	else if (name.StartsWith ("ntdll.dll!ntqueryobject") || name.StartsWith ("ntdll.dll!zwqueryobject")) {  		found = true;  		IntPtr handle = stackFrame.Params [0];  		// Use the KiFastSystemCallRet args if the handle we have is wrong.  		if (handle.ToInt32 () % 2 != 0 || handle == IntPtr.Zero)  			handle = lastParams [1];  		sb.AppendLine ("Thread " + tid.ToString () + " is querying an object (most likely a named pipe):");  		sb.AppendLine (this.GetHandleString (_pid' handle));  	}  	else if (name.StartsWith ("ntdll.dll!zwreadfile") || name.StartsWith ("ntdll.dll!ntreadfile") || name.StartsWith ("ntdll.dll!zwwritefile") || name.StartsWith ("ntdll.dll!ntwritefile")) {  		found = true;  		IntPtr handle = stackFrame.Params [0];  		sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a named pipe or a file:");  		sb.AppendLine (this.GetHandleString (_pid' handle));  	}  	else if (name.StartsWith ("ntdll.dll!zwremoveiocompletion") || name.StartsWith ("ntdll.dll!ntremoveiocompletion")) {  		found = true;  		IntPtr handle = stackFrame.Params [0];  		sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an I/O completion object:");  		sb.AppendLine (this.GetHandleString (_pid' handle));  	}  	else if (name.StartsWith ("ntdll.dll!zwreplywaitreceiveport") || name.StartsWith ("ntdll.dll!ntreplywaitreceiveport") || name.StartsWith ("ntdll.dll!zwrequestwaitreplyport") || name.StartsWith ("ntdll.dll!ntrequestwaitreplyport") || name.StartsWith ("ntdll.dll!zwalpcsendwaitreceiveport") || name.StartsWith ("ntdll.dll!ntalpcsendwaitreceiveport")) {  		found = true;  		IntPtr handle = stackFrame.Params [0];  		sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a LPC port:");  		sb.AppendLine (this.GetHandleString (_pid' handle));  	}  	else if (name.StartsWith ("ntdll.dll!zwsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!ntsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!zwsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!ntsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaithigheventpair") || name.StartsWith ("ntdll.dll!ntwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaitloweventpair") || name.StartsWith ("ntdll.dll!ntwaitloweventpair")) {  		found = true;  		IntPtr handle = stackFrame.Params [0];  		// Use the KiFastSystemCallRet args if the handle we have is wrong.  		if (handle.ToInt32 () % 2 != 0)  			handle = lastParams [1];  		sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for an event pair:");  		sb.AppendLine (this.GetHandleString (_pid' handle));  	}  	else if (name.StartsWith ("user32.dll!ntusergetmessage") || name.StartsWith ("user32.dll!ntuserwaitmessage")) {  		found = true;  		sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a USER message.");  	}  	else if (name.StartsWith ("ntdll.dll!zwwaitfordebugevent") || name.StartsWith ("ntdll.dll!ntwaitfordebugevent")) {  		found = true;  		IntPtr handle = stackFrame.Params [0];  		sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a debug event:");  		sb.AppendLine (this.GetHandleString (_pid' handle));  	}  	else if (name.StartsWith ("ntdll.dll!zwwaitforkeyedevent") || name.StartsWith ("ntdll.dll!ntwaitforkeyedevent") || name.StartsWith ("ntdll.dll!zwreleasekeyedevent") || name.StartsWith ("ntdll.dll!ntreleasekeyedevent")) {  		found = true;  		IntPtr handle = stackFrame.Params [0];  		IntPtr key = stackFrame.Params [1];  		sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for a keyed event (key 0x" + key.ToString ("x") + "):");  		sb.AppendLine (this.GetHandleString (_pid' handle));  	}  	else if (name.StartsWith ("ntdll.dll!zwwaitformultipleobjects") || name.StartsWith ("ntdll.dll!ntwaitformultipleobjects") || name.StartsWith ("kernel32.dll!waitformultipleobjects")) {  		found = true;  		int handleCount = stackFrame.Params [0].ToInt32 ();  		IntPtr handleAddress = stackFrame.Params [1];  		WaitType waitType = (WaitType)stackFrame.Params [2].ToInt32 ();  		bool alertable = stackFrame.Params [3].ToInt32 () != 0;  		// use the KiFastSystemCallRet args if we have the wrong args  		if (handleCount > 64) {  			handleCount = lastParams [1].ToInt32 ();  			handleAddress = lastParams [2];  			waitType = (WaitType)lastParams [3].ToInt32 ();  		}  		IntPtr* handles = stackalloc IntPtr[handleCount];  		phandle.ReadMemory (handleAddress' handles' handleCount * IntPtr.Size);  		sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + "' wait type: " + waitType.ToString () + ") for:");  		for (int i = 0; i < handleCount; i++) {  			sb.AppendLine (this.GetHandleString (_pid' handles [i]));  		}  	}  	else if (name.StartsWith ("ntdll.dll!zwwaitforsingleobject") || name.StartsWith ("ntdll.dll!ntwaitforsingleobject") || name.StartsWith ("kernel32.dll!waitforsingleobject")) {  		found = true;  		IntPtr handle = stackFrame.Params [0];  		bool alertable = stackFrame.Params [1].ToInt32 () != 0;  		sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + ") for:");  		sb.AppendLine (this.GetHandleString (_pid' handle));  	}  	else if (name.StartsWith ("ntdll.dll!zwwaitforworkviaworkerfactory") || name.StartsWith ("ntdll.dll!ntwaitforworkviaworkerfactory")) {  		found = true;  		IntPtr handle = stackFrame.Params [0];  		sb.AppendLine ("Thread " + tid.ToString () + " is waiting for work from a worker factory:");  		sb.AppendLine (this.GetHandleString (_pid' handle));  	}  	lastParams = stackFrame.Params;  	return !found;  });  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,analyzeWaitMenuItem_Click,The following statement contains a magic number: thandle.WalkStack (phandle' stackFrame =>  {  	uint address = stackFrame.PcAddress.ToUInt32 ();  	string name = _provider.Symbols.GetSymbolFromAddress (address).ToLowerInvariant ();  	if (name == null) {  		// dummy  	}  	else if (name.StartsWith ("kernel32.dll!sleep")) {  		found = true;  		sb.Append ("Thread is sleeping. Timeout: " + stackFrame.Params [0].ToInt32 ().ToString () + " milliseconds");  	}  	else if (name.StartsWith ("ntdll.dll!zwdelayexecution") || name.StartsWith ("ntdll.dll!ntdelayexecution")) {  		found = true;  		bool alertable = stackFrame.Params [0].ToInt32 () != 0;  		IntPtr timeoutAddress = stackFrame.Params [1];  		long timeout;  		phandle.ReadMemory (timeoutAddress' &timeout' sizeof(long));  		if (timeout < 0) {  			sb.Append ("Thread is sleeping. Timeout: " + (new TimeSpan (-timeout)).TotalMilliseconds.ToString () + " milliseconds");  		}  		else {  			sb.AppendLine ("Thread is sleeping. Timeout: " + (new DateTime (timeout)).ToString ());  		}  	}  	else if (name.StartsWith ("ntdll.dll!zwdeviceiocontrolfile") || name.StartsWith ("ntdll.dll!ntdeviceiocontrolfile")) {  		found = true;  		IntPtr handle = stackFrame.Params [0];  		sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an I/O control request:");  		sb.AppendLine (this.GetHandleString (_pid' handle));  	}  	else if (name.StartsWith ("ntdll.dll!ntfscontrolfile") || name.StartsWith ("ntdll.dll!zwfscontrolfile")) {  		found = true;  		IntPtr handle = stackFrame.Params [0];  		sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an FS control request:");  		sb.AppendLine (this.GetHandleString (_pid' handle));  	}  	else if (name.StartsWith ("ntdll.dll!ntqueryobject") || name.StartsWith ("ntdll.dll!zwqueryobject")) {  		found = true;  		IntPtr handle = stackFrame.Params [0];  		// Use the KiFastSystemCallRet args if the handle we have is wrong.  		if (handle.ToInt32 () % 2 != 0 || handle == IntPtr.Zero)  			handle = lastParams [1];  		sb.AppendLine ("Thread " + tid.ToString () + " is querying an object (most likely a named pipe):");  		sb.AppendLine (this.GetHandleString (_pid' handle));  	}  	else if (name.StartsWith ("ntdll.dll!zwreadfile") || name.StartsWith ("ntdll.dll!ntreadfile") || name.StartsWith ("ntdll.dll!zwwritefile") || name.StartsWith ("ntdll.dll!ntwritefile")) {  		found = true;  		IntPtr handle = stackFrame.Params [0];  		sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a named pipe or a file:");  		sb.AppendLine (this.GetHandleString (_pid' handle));  	}  	else if (name.StartsWith ("ntdll.dll!zwremoveiocompletion") || name.StartsWith ("ntdll.dll!ntremoveiocompletion")) {  		found = true;  		IntPtr handle = stackFrame.Params [0];  		sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an I/O completion object:");  		sb.AppendLine (this.GetHandleString (_pid' handle));  	}  	else if (name.StartsWith ("ntdll.dll!zwreplywaitreceiveport") || name.StartsWith ("ntdll.dll!ntreplywaitreceiveport") || name.StartsWith ("ntdll.dll!zwrequestwaitreplyport") || name.StartsWith ("ntdll.dll!ntrequestwaitreplyport") || name.StartsWith ("ntdll.dll!zwalpcsendwaitreceiveport") || name.StartsWith ("ntdll.dll!ntalpcsendwaitreceiveport")) {  		found = true;  		IntPtr handle = stackFrame.Params [0];  		sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a LPC port:");  		sb.AppendLine (this.GetHandleString (_pid' handle));  	}  	else if (name.StartsWith ("ntdll.dll!zwsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!ntsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!zwsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!ntsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaithigheventpair") || name.StartsWith ("ntdll.dll!ntwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaitloweventpair") || name.StartsWith ("ntdll.dll!ntwaitloweventpair")) {  		found = true;  		IntPtr handle = stackFrame.Params [0];  		// Use the KiFastSystemCallRet args if the handle we have is wrong.  		if (handle.ToInt32 () % 2 != 0)  			handle = lastParams [1];  		sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for an event pair:");  		sb.AppendLine (this.GetHandleString (_pid' handle));  	}  	else if (name.StartsWith ("user32.dll!ntusergetmessage") || name.StartsWith ("user32.dll!ntuserwaitmessage")) {  		found = true;  		sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a USER message.");  	}  	else if (name.StartsWith ("ntdll.dll!zwwaitfordebugevent") || name.StartsWith ("ntdll.dll!ntwaitfordebugevent")) {  		found = true;  		IntPtr handle = stackFrame.Params [0];  		sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a debug event:");  		sb.AppendLine (this.GetHandleString (_pid' handle));  	}  	else if (name.StartsWith ("ntdll.dll!zwwaitforkeyedevent") || name.StartsWith ("ntdll.dll!ntwaitforkeyedevent") || name.StartsWith ("ntdll.dll!zwreleasekeyedevent") || name.StartsWith ("ntdll.dll!ntreleasekeyedevent")) {  		found = true;  		IntPtr handle = stackFrame.Params [0];  		IntPtr key = stackFrame.Params [1];  		sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for a keyed event (key 0x" + key.ToString ("x") + "):");  		sb.AppendLine (this.GetHandleString (_pid' handle));  	}  	else if (name.StartsWith ("ntdll.dll!zwwaitformultipleobjects") || name.StartsWith ("ntdll.dll!ntwaitformultipleobjects") || name.StartsWith ("kernel32.dll!waitformultipleobjects")) {  		found = true;  		int handleCount = stackFrame.Params [0].ToInt32 ();  		IntPtr handleAddress = stackFrame.Params [1];  		WaitType waitType = (WaitType)stackFrame.Params [2].ToInt32 ();  		bool alertable = stackFrame.Params [3].ToInt32 () != 0;  		// use the KiFastSystemCallRet args if we have the wrong args  		if (handleCount > 64) {  			handleCount = lastParams [1].ToInt32 ();  			handleAddress = lastParams [2];  			waitType = (WaitType)lastParams [3].ToInt32 ();  		}  		IntPtr* handles = stackalloc IntPtr[handleCount];  		phandle.ReadMemory (handleAddress' handles' handleCount * IntPtr.Size);  		sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + "' wait type: " + waitType.ToString () + ") for:");  		for (int i = 0; i < handleCount; i++) {  			sb.AppendLine (this.GetHandleString (_pid' handles [i]));  		}  	}  	else if (name.StartsWith ("ntdll.dll!zwwaitforsingleobject") || name.StartsWith ("ntdll.dll!ntwaitforsingleobject") || name.StartsWith ("kernel32.dll!waitforsingleobject")) {  		found = true;  		IntPtr handle = stackFrame.Params [0];  		bool alertable = stackFrame.Params [1].ToInt32 () != 0;  		sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + ") for:");  		sb.AppendLine (this.GetHandleString (_pid' handle));  	}  	else if (name.StartsWith ("ntdll.dll!zwwaitforworkviaworkerfactory") || name.StartsWith ("ntdll.dll!ntwaitforworkviaworkerfactory")) {  		found = true;  		IntPtr handle = stackFrame.Params [0];  		sb.AppendLine ("Thread " + tid.ToString () + " is waiting for work from a worker factory:");  		sb.AppendLine (this.GetHandleString (_pid' handle));  	}  	lastParams = stackFrame.Params;  	return !found;  });  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,analyzeWaitMenuItem_Click,The following statement contains a magic number: thandle.WalkStack (phandle' stackFrame =>  {  	uint address = stackFrame.PcAddress.ToUInt32 ();  	string name = _provider.Symbols.GetSymbolFromAddress (address).ToLowerInvariant ();  	if (name == null) {  		// dummy  	}  	else if (name.StartsWith ("kernel32.dll!sleep")) {  		found = true;  		sb.Append ("Thread is sleeping. Timeout: " + stackFrame.Params [0].ToInt32 ().ToString () + " milliseconds");  	}  	else if (name.StartsWith ("ntdll.dll!zwdelayexecution") || name.StartsWith ("ntdll.dll!ntdelayexecution")) {  		found = true;  		bool alertable = stackFrame.Params [0].ToInt32 () != 0;  		IntPtr timeoutAddress = stackFrame.Params [1];  		long timeout;  		phandle.ReadMemory (timeoutAddress' &timeout' sizeof(long));  		if (timeout < 0) {  			sb.Append ("Thread is sleeping. Timeout: " + (new TimeSpan (-timeout)).TotalMilliseconds.ToString () + " milliseconds");  		}  		else {  			sb.AppendLine ("Thread is sleeping. Timeout: " + (new DateTime (timeout)).ToString ());  		}  	}  	else if (name.StartsWith ("ntdll.dll!zwdeviceiocontrolfile") || name.StartsWith ("ntdll.dll!ntdeviceiocontrolfile")) {  		found = true;  		IntPtr handle = stackFrame.Params [0];  		sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an I/O control request:");  		sb.AppendLine (this.GetHandleString (_pid' handle));  	}  	else if (name.StartsWith ("ntdll.dll!ntfscontrolfile") || name.StartsWith ("ntdll.dll!zwfscontrolfile")) {  		found = true;  		IntPtr handle = stackFrame.Params [0];  		sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an FS control request:");  		sb.AppendLine (this.GetHandleString (_pid' handle));  	}  	else if (name.StartsWith ("ntdll.dll!ntqueryobject") || name.StartsWith ("ntdll.dll!zwqueryobject")) {  		found = true;  		IntPtr handle = stackFrame.Params [0];  		// Use the KiFastSystemCallRet args if the handle we have is wrong.  		if (handle.ToInt32 () % 2 != 0 || handle == IntPtr.Zero)  			handle = lastParams [1];  		sb.AppendLine ("Thread " + tid.ToString () + " is querying an object (most likely a named pipe):");  		sb.AppendLine (this.GetHandleString (_pid' handle));  	}  	else if (name.StartsWith ("ntdll.dll!zwreadfile") || name.StartsWith ("ntdll.dll!ntreadfile") || name.StartsWith ("ntdll.dll!zwwritefile") || name.StartsWith ("ntdll.dll!ntwritefile")) {  		found = true;  		IntPtr handle = stackFrame.Params [0];  		sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a named pipe or a file:");  		sb.AppendLine (this.GetHandleString (_pid' handle));  	}  	else if (name.StartsWith ("ntdll.dll!zwremoveiocompletion") || name.StartsWith ("ntdll.dll!ntremoveiocompletion")) {  		found = true;  		IntPtr handle = stackFrame.Params [0];  		sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an I/O completion object:");  		sb.AppendLine (this.GetHandleString (_pid' handle));  	}  	else if (name.StartsWith ("ntdll.dll!zwreplywaitreceiveport") || name.StartsWith ("ntdll.dll!ntreplywaitreceiveport") || name.StartsWith ("ntdll.dll!zwrequestwaitreplyport") || name.StartsWith ("ntdll.dll!ntrequestwaitreplyport") || name.StartsWith ("ntdll.dll!zwalpcsendwaitreceiveport") || name.StartsWith ("ntdll.dll!ntalpcsendwaitreceiveport")) {  		found = true;  		IntPtr handle = stackFrame.Params [0];  		sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a LPC port:");  		sb.AppendLine (this.GetHandleString (_pid' handle));  	}  	else if (name.StartsWith ("ntdll.dll!zwsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!ntsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!zwsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!ntsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaithigheventpair") || name.StartsWith ("ntdll.dll!ntwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaitloweventpair") || name.StartsWith ("ntdll.dll!ntwaitloweventpair")) {  		found = true;  		IntPtr handle = stackFrame.Params [0];  		// Use the KiFastSystemCallRet args if the handle we have is wrong.  		if (handle.ToInt32 () % 2 != 0)  			handle = lastParams [1];  		sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for an event pair:");  		sb.AppendLine (this.GetHandleString (_pid' handle));  	}  	else if (name.StartsWith ("user32.dll!ntusergetmessage") || name.StartsWith ("user32.dll!ntuserwaitmessage")) {  		found = true;  		sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a USER message.");  	}  	else if (name.StartsWith ("ntdll.dll!zwwaitfordebugevent") || name.StartsWith ("ntdll.dll!ntwaitfordebugevent")) {  		found = true;  		IntPtr handle = stackFrame.Params [0];  		sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a debug event:");  		sb.AppendLine (this.GetHandleString (_pid' handle));  	}  	else if (name.StartsWith ("ntdll.dll!zwwaitforkeyedevent") || name.StartsWith ("ntdll.dll!ntwaitforkeyedevent") || name.StartsWith ("ntdll.dll!zwreleasekeyedevent") || name.StartsWith ("ntdll.dll!ntreleasekeyedevent")) {  		found = true;  		IntPtr handle = stackFrame.Params [0];  		IntPtr key = stackFrame.Params [1];  		sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for a keyed event (key 0x" + key.ToString ("x") + "):");  		sb.AppendLine (this.GetHandleString (_pid' handle));  	}  	else if (name.StartsWith ("ntdll.dll!zwwaitformultipleobjects") || name.StartsWith ("ntdll.dll!ntwaitformultipleobjects") || name.StartsWith ("kernel32.dll!waitformultipleobjects")) {  		found = true;  		int handleCount = stackFrame.Params [0].ToInt32 ();  		IntPtr handleAddress = stackFrame.Params [1];  		WaitType waitType = (WaitType)stackFrame.Params [2].ToInt32 ();  		bool alertable = stackFrame.Params [3].ToInt32 () != 0;  		// use the KiFastSystemCallRet args if we have the wrong args  		if (handleCount > 64) {  			handleCount = lastParams [1].ToInt32 ();  			handleAddress = lastParams [2];  			waitType = (WaitType)lastParams [3].ToInt32 ();  		}  		IntPtr* handles = stackalloc IntPtr[handleCount];  		phandle.ReadMemory (handleAddress' handles' handleCount * IntPtr.Size);  		sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + "' wait type: " + waitType.ToString () + ") for:");  		for (int i = 0; i < handleCount; i++) {  			sb.AppendLine (this.GetHandleString (_pid' handles [i]));  		}  	}  	else if (name.StartsWith ("ntdll.dll!zwwaitforsingleobject") || name.StartsWith ("ntdll.dll!ntwaitforsingleobject") || name.StartsWith ("kernel32.dll!waitforsingleobject")) {  		found = true;  		IntPtr handle = stackFrame.Params [0];  		bool alertable = stackFrame.Params [1].ToInt32 () != 0;  		sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + ") for:");  		sb.AppendLine (this.GetHandleString (_pid' handle));  	}  	else if (name.StartsWith ("ntdll.dll!zwwaitforworkviaworkerfactory") || name.StartsWith ("ntdll.dll!ntwaitforworkviaworkerfactory")) {  		found = true;  		IntPtr handle = stackFrame.Params [0];  		sb.AppendLine ("Thread " + tid.ToString () + " is waiting for work from a worker factory:");  		sb.AppendLine (this.GetHandleString (_pid' handle));  	}  	lastParams = stackFrame.Params;  	return !found;  });  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,analyzeWaitMenuItem_Click,The following statement contains a magic number: thandle.WalkStack (phandle' stackFrame =>  {  	uint address = stackFrame.PcAddress.ToUInt32 ();  	string name = _provider.Symbols.GetSymbolFromAddress (address).ToLowerInvariant ();  	if (name == null) {  		// dummy  	}  	else if (name.StartsWith ("kernel32.dll!sleep")) {  		found = true;  		sb.Append ("Thread is sleeping. Timeout: " + stackFrame.Params [0].ToInt32 ().ToString () + " milliseconds");  	}  	else if (name.StartsWith ("ntdll.dll!zwdelayexecution") || name.StartsWith ("ntdll.dll!ntdelayexecution")) {  		found = true;  		bool alertable = stackFrame.Params [0].ToInt32 () != 0;  		IntPtr timeoutAddress = stackFrame.Params [1];  		long timeout;  		phandle.ReadMemory (timeoutAddress' &timeout' sizeof(long));  		if (timeout < 0) {  			sb.Append ("Thread is sleeping. Timeout: " + (new TimeSpan (-timeout)).TotalMilliseconds.ToString () + " milliseconds");  		}  		else {  			sb.AppendLine ("Thread is sleeping. Timeout: " + (new DateTime (timeout)).ToString ());  		}  	}  	else if (name.StartsWith ("ntdll.dll!zwdeviceiocontrolfile") || name.StartsWith ("ntdll.dll!ntdeviceiocontrolfile")) {  		found = true;  		IntPtr handle = stackFrame.Params [0];  		sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an I/O control request:");  		sb.AppendLine (this.GetHandleString (_pid' handle));  	}  	else if (name.StartsWith ("ntdll.dll!ntfscontrolfile") || name.StartsWith ("ntdll.dll!zwfscontrolfile")) {  		found = true;  		IntPtr handle = stackFrame.Params [0];  		sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an FS control request:");  		sb.AppendLine (this.GetHandleString (_pid' handle));  	}  	else if (name.StartsWith ("ntdll.dll!ntqueryobject") || name.StartsWith ("ntdll.dll!zwqueryobject")) {  		found = true;  		IntPtr handle = stackFrame.Params [0];  		// Use the KiFastSystemCallRet args if the handle we have is wrong.  		if (handle.ToInt32 () % 2 != 0 || handle == IntPtr.Zero)  			handle = lastParams [1];  		sb.AppendLine ("Thread " + tid.ToString () + " is querying an object (most likely a named pipe):");  		sb.AppendLine (this.GetHandleString (_pid' handle));  	}  	else if (name.StartsWith ("ntdll.dll!zwreadfile") || name.StartsWith ("ntdll.dll!ntreadfile") || name.StartsWith ("ntdll.dll!zwwritefile") || name.StartsWith ("ntdll.dll!ntwritefile")) {  		found = true;  		IntPtr handle = stackFrame.Params [0];  		sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a named pipe or a file:");  		sb.AppendLine (this.GetHandleString (_pid' handle));  	}  	else if (name.StartsWith ("ntdll.dll!zwremoveiocompletion") || name.StartsWith ("ntdll.dll!ntremoveiocompletion")) {  		found = true;  		IntPtr handle = stackFrame.Params [0];  		sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an I/O completion object:");  		sb.AppendLine (this.GetHandleString (_pid' handle));  	}  	else if (name.StartsWith ("ntdll.dll!zwreplywaitreceiveport") || name.StartsWith ("ntdll.dll!ntreplywaitreceiveport") || name.StartsWith ("ntdll.dll!zwrequestwaitreplyport") || name.StartsWith ("ntdll.dll!ntrequestwaitreplyport") || name.StartsWith ("ntdll.dll!zwalpcsendwaitreceiveport") || name.StartsWith ("ntdll.dll!ntalpcsendwaitreceiveport")) {  		found = true;  		IntPtr handle = stackFrame.Params [0];  		sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a LPC port:");  		sb.AppendLine (this.GetHandleString (_pid' handle));  	}  	else if (name.StartsWith ("ntdll.dll!zwsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!ntsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!zwsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!ntsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaithigheventpair") || name.StartsWith ("ntdll.dll!ntwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaitloweventpair") || name.StartsWith ("ntdll.dll!ntwaitloweventpair")) {  		found = true;  		IntPtr handle = stackFrame.Params [0];  		// Use the KiFastSystemCallRet args if the handle we have is wrong.  		if (handle.ToInt32 () % 2 != 0)  			handle = lastParams [1];  		sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for an event pair:");  		sb.AppendLine (this.GetHandleString (_pid' handle));  	}  	else if (name.StartsWith ("user32.dll!ntusergetmessage") || name.StartsWith ("user32.dll!ntuserwaitmessage")) {  		found = true;  		sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a USER message.");  	}  	else if (name.StartsWith ("ntdll.dll!zwwaitfordebugevent") || name.StartsWith ("ntdll.dll!ntwaitfordebugevent")) {  		found = true;  		IntPtr handle = stackFrame.Params [0];  		sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a debug event:");  		sb.AppendLine (this.GetHandleString (_pid' handle));  	}  	else if (name.StartsWith ("ntdll.dll!zwwaitforkeyedevent") || name.StartsWith ("ntdll.dll!ntwaitforkeyedevent") || name.StartsWith ("ntdll.dll!zwreleasekeyedevent") || name.StartsWith ("ntdll.dll!ntreleasekeyedevent")) {  		found = true;  		IntPtr handle = stackFrame.Params [0];  		IntPtr key = stackFrame.Params [1];  		sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for a keyed event (key 0x" + key.ToString ("x") + "):");  		sb.AppendLine (this.GetHandleString (_pid' handle));  	}  	else if (name.StartsWith ("ntdll.dll!zwwaitformultipleobjects") || name.StartsWith ("ntdll.dll!ntwaitformultipleobjects") || name.StartsWith ("kernel32.dll!waitformultipleobjects")) {  		found = true;  		int handleCount = stackFrame.Params [0].ToInt32 ();  		IntPtr handleAddress = stackFrame.Params [1];  		WaitType waitType = (WaitType)stackFrame.Params [2].ToInt32 ();  		bool alertable = stackFrame.Params [3].ToInt32 () != 0;  		// use the KiFastSystemCallRet args if we have the wrong args  		if (handleCount > 64) {  			handleCount = lastParams [1].ToInt32 ();  			handleAddress = lastParams [2];  			waitType = (WaitType)lastParams [3].ToInt32 ();  		}  		IntPtr* handles = stackalloc IntPtr[handleCount];  		phandle.ReadMemory (handleAddress' handles' handleCount * IntPtr.Size);  		sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + "' wait type: " + waitType.ToString () + ") for:");  		for (int i = 0; i < handleCount; i++) {  			sb.AppendLine (this.GetHandleString (_pid' handles [i]));  		}  	}  	else if (name.StartsWith ("ntdll.dll!zwwaitforsingleobject") || name.StartsWith ("ntdll.dll!ntwaitforsingleobject") || name.StartsWith ("kernel32.dll!waitforsingleobject")) {  		found = true;  		IntPtr handle = stackFrame.Params [0];  		bool alertable = stackFrame.Params [1].ToInt32 () != 0;  		sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + ") for:");  		sb.AppendLine (this.GetHandleString (_pid' handle));  	}  	else if (name.StartsWith ("ntdll.dll!zwwaitforworkviaworkerfactory") || name.StartsWith ("ntdll.dll!ntwaitforworkviaworkerfactory")) {  		found = true;  		IntPtr handle = stackFrame.Params [0];  		sb.AppendLine ("Thread " + tid.ToString () + " is waiting for work from a worker factory:");  		sb.AppendLine (this.GetHandleString (_pid' handle));  	}  	lastParams = stackFrame.Params;  	return !found;  });  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,analyzeWaitMenuItem_Click,The following statement contains a magic number: thandle.WalkStack (phandle' stackFrame =>  {  	uint address = stackFrame.PcAddress.ToUInt32 ();  	string name = _provider.Symbols.GetSymbolFromAddress (address).ToLowerInvariant ();  	if (name == null) {  		// dummy  	}  	else if (name.StartsWith ("kernel32.dll!sleep")) {  		found = true;  		sb.Append ("Thread is sleeping. Timeout: " + stackFrame.Params [0].ToInt32 ().ToString () + " milliseconds");  	}  	else if (name.StartsWith ("ntdll.dll!zwdelayexecution") || name.StartsWith ("ntdll.dll!ntdelayexecution")) {  		found = true;  		bool alertable = stackFrame.Params [0].ToInt32 () != 0;  		IntPtr timeoutAddress = stackFrame.Params [1];  		long timeout;  		phandle.ReadMemory (timeoutAddress' &timeout' sizeof(long));  		if (timeout < 0) {  			sb.Append ("Thread is sleeping. Timeout: " + (new TimeSpan (-timeout)).TotalMilliseconds.ToString () + " milliseconds");  		}  		else {  			sb.AppendLine ("Thread is sleeping. Timeout: " + (new DateTime (timeout)).ToString ());  		}  	}  	else if (name.StartsWith ("ntdll.dll!zwdeviceiocontrolfile") || name.StartsWith ("ntdll.dll!ntdeviceiocontrolfile")) {  		found = true;  		IntPtr handle = stackFrame.Params [0];  		sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an I/O control request:");  		sb.AppendLine (this.GetHandleString (_pid' handle));  	}  	else if (name.StartsWith ("ntdll.dll!ntfscontrolfile") || name.StartsWith ("ntdll.dll!zwfscontrolfile")) {  		found = true;  		IntPtr handle = stackFrame.Params [0];  		sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an FS control request:");  		sb.AppendLine (this.GetHandleString (_pid' handle));  	}  	else if (name.StartsWith ("ntdll.dll!ntqueryobject") || name.StartsWith ("ntdll.dll!zwqueryobject")) {  		found = true;  		IntPtr handle = stackFrame.Params [0];  		// Use the KiFastSystemCallRet args if the handle we have is wrong.  		if (handle.ToInt32 () % 2 != 0 || handle == IntPtr.Zero)  			handle = lastParams [1];  		sb.AppendLine ("Thread " + tid.ToString () + " is querying an object (most likely a named pipe):");  		sb.AppendLine (this.GetHandleString (_pid' handle));  	}  	else if (name.StartsWith ("ntdll.dll!zwreadfile") || name.StartsWith ("ntdll.dll!ntreadfile") || name.StartsWith ("ntdll.dll!zwwritefile") || name.StartsWith ("ntdll.dll!ntwritefile")) {  		found = true;  		IntPtr handle = stackFrame.Params [0];  		sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a named pipe or a file:");  		sb.AppendLine (this.GetHandleString (_pid' handle));  	}  	else if (name.StartsWith ("ntdll.dll!zwremoveiocompletion") || name.StartsWith ("ntdll.dll!ntremoveiocompletion")) {  		found = true;  		IntPtr handle = stackFrame.Params [0];  		sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an I/O completion object:");  		sb.AppendLine (this.GetHandleString (_pid' handle));  	}  	else if (name.StartsWith ("ntdll.dll!zwreplywaitreceiveport") || name.StartsWith ("ntdll.dll!ntreplywaitreceiveport") || name.StartsWith ("ntdll.dll!zwrequestwaitreplyport") || name.StartsWith ("ntdll.dll!ntrequestwaitreplyport") || name.StartsWith ("ntdll.dll!zwalpcsendwaitreceiveport") || name.StartsWith ("ntdll.dll!ntalpcsendwaitreceiveport")) {  		found = true;  		IntPtr handle = stackFrame.Params [0];  		sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a LPC port:");  		sb.AppendLine (this.GetHandleString (_pid' handle));  	}  	else if (name.StartsWith ("ntdll.dll!zwsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!ntsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!zwsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!ntsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaithigheventpair") || name.StartsWith ("ntdll.dll!ntwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaitloweventpair") || name.StartsWith ("ntdll.dll!ntwaitloweventpair")) {  		found = true;  		IntPtr handle = stackFrame.Params [0];  		// Use the KiFastSystemCallRet args if the handle we have is wrong.  		if (handle.ToInt32 () % 2 != 0)  			handle = lastParams [1];  		sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for an event pair:");  		sb.AppendLine (this.GetHandleString (_pid' handle));  	}  	else if (name.StartsWith ("user32.dll!ntusergetmessage") || name.StartsWith ("user32.dll!ntuserwaitmessage")) {  		found = true;  		sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a USER message.");  	}  	else if (name.StartsWith ("ntdll.dll!zwwaitfordebugevent") || name.StartsWith ("ntdll.dll!ntwaitfordebugevent")) {  		found = true;  		IntPtr handle = stackFrame.Params [0];  		sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a debug event:");  		sb.AppendLine (this.GetHandleString (_pid' handle));  	}  	else if (name.StartsWith ("ntdll.dll!zwwaitforkeyedevent") || name.StartsWith ("ntdll.dll!ntwaitforkeyedevent") || name.StartsWith ("ntdll.dll!zwreleasekeyedevent") || name.StartsWith ("ntdll.dll!ntreleasekeyedevent")) {  		found = true;  		IntPtr handle = stackFrame.Params [0];  		IntPtr key = stackFrame.Params [1];  		sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for a keyed event (key 0x" + key.ToString ("x") + "):");  		sb.AppendLine (this.GetHandleString (_pid' handle));  	}  	else if (name.StartsWith ("ntdll.dll!zwwaitformultipleobjects") || name.StartsWith ("ntdll.dll!ntwaitformultipleobjects") || name.StartsWith ("kernel32.dll!waitformultipleobjects")) {  		found = true;  		int handleCount = stackFrame.Params [0].ToInt32 ();  		IntPtr handleAddress = stackFrame.Params [1];  		WaitType waitType = (WaitType)stackFrame.Params [2].ToInt32 ();  		bool alertable = stackFrame.Params [3].ToInt32 () != 0;  		// use the KiFastSystemCallRet args if we have the wrong args  		if (handleCount > 64) {  			handleCount = lastParams [1].ToInt32 ();  			handleAddress = lastParams [2];  			waitType = (WaitType)lastParams [3].ToInt32 ();  		}  		IntPtr* handles = stackalloc IntPtr[handleCount];  		phandle.ReadMemory (handleAddress' handles' handleCount * IntPtr.Size);  		sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + "' wait type: " + waitType.ToString () + ") for:");  		for (int i = 0; i < handleCount; i++) {  			sb.AppendLine (this.GetHandleString (_pid' handles [i]));  		}  	}  	else if (name.StartsWith ("ntdll.dll!zwwaitforsingleobject") || name.StartsWith ("ntdll.dll!ntwaitforsingleobject") || name.StartsWith ("kernel32.dll!waitforsingleobject")) {  		found = true;  		IntPtr handle = stackFrame.Params [0];  		bool alertable = stackFrame.Params [1].ToInt32 () != 0;  		sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + ") for:");  		sb.AppendLine (this.GetHandleString (_pid' handle));  	}  	else if (name.StartsWith ("ntdll.dll!zwwaitforworkviaworkerfactory") || name.StartsWith ("ntdll.dll!ntwaitforworkviaworkerfactory")) {  		found = true;  		IntPtr handle = stackFrame.Params [0];  		sb.AppendLine ("Thread " + tid.ToString () + " is waiting for work from a worker factory:");  		sb.AppendLine (this.GetHandleString (_pid' handle));  	}  	lastParams = stackFrame.Params;  	return !found;  });  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,analyzeWaitMenuItem_Click,The following statement contains a magic number: thandle.WalkStack (phandle' stackFrame =>  {  	uint address = stackFrame.PcAddress.ToUInt32 ();  	string name = _provider.Symbols.GetSymbolFromAddress (address).ToLowerInvariant ();  	if (name == null) {  		// dummy  	}  	else if (name.StartsWith ("kernel32.dll!sleep")) {  		found = true;  		sb.Append ("Thread is sleeping. Timeout: " + stackFrame.Params [0].ToInt32 ().ToString () + " milliseconds");  	}  	else if (name.StartsWith ("ntdll.dll!zwdelayexecution") || name.StartsWith ("ntdll.dll!ntdelayexecution")) {  		found = true;  		bool alertable = stackFrame.Params [0].ToInt32 () != 0;  		IntPtr timeoutAddress = stackFrame.Params [1];  		long timeout;  		phandle.ReadMemory (timeoutAddress' &timeout' sizeof(long));  		if (timeout < 0) {  			sb.Append ("Thread is sleeping. Timeout: " + (new TimeSpan (-timeout)).TotalMilliseconds.ToString () + " milliseconds");  		}  		else {  			sb.AppendLine ("Thread is sleeping. Timeout: " + (new DateTime (timeout)).ToString ());  		}  	}  	else if (name.StartsWith ("ntdll.dll!zwdeviceiocontrolfile") || name.StartsWith ("ntdll.dll!ntdeviceiocontrolfile")) {  		found = true;  		IntPtr handle = stackFrame.Params [0];  		sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an I/O control request:");  		sb.AppendLine (this.GetHandleString (_pid' handle));  	}  	else if (name.StartsWith ("ntdll.dll!ntfscontrolfile") || name.StartsWith ("ntdll.dll!zwfscontrolfile")) {  		found = true;  		IntPtr handle = stackFrame.Params [0];  		sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an FS control request:");  		sb.AppendLine (this.GetHandleString (_pid' handle));  	}  	else if (name.StartsWith ("ntdll.dll!ntqueryobject") || name.StartsWith ("ntdll.dll!zwqueryobject")) {  		found = true;  		IntPtr handle = stackFrame.Params [0];  		// Use the KiFastSystemCallRet args if the handle we have is wrong.  		if (handle.ToInt32 () % 2 != 0 || handle == IntPtr.Zero)  			handle = lastParams [1];  		sb.AppendLine ("Thread " + tid.ToString () + " is querying an object (most likely a named pipe):");  		sb.AppendLine (this.GetHandleString (_pid' handle));  	}  	else if (name.StartsWith ("ntdll.dll!zwreadfile") || name.StartsWith ("ntdll.dll!ntreadfile") || name.StartsWith ("ntdll.dll!zwwritefile") || name.StartsWith ("ntdll.dll!ntwritefile")) {  		found = true;  		IntPtr handle = stackFrame.Params [0];  		sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a named pipe or a file:");  		sb.AppendLine (this.GetHandleString (_pid' handle));  	}  	else if (name.StartsWith ("ntdll.dll!zwremoveiocompletion") || name.StartsWith ("ntdll.dll!ntremoveiocompletion")) {  		found = true;  		IntPtr handle = stackFrame.Params [0];  		sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an I/O completion object:");  		sb.AppendLine (this.GetHandleString (_pid' handle));  	}  	else if (name.StartsWith ("ntdll.dll!zwreplywaitreceiveport") || name.StartsWith ("ntdll.dll!ntreplywaitreceiveport") || name.StartsWith ("ntdll.dll!zwrequestwaitreplyport") || name.StartsWith ("ntdll.dll!ntrequestwaitreplyport") || name.StartsWith ("ntdll.dll!zwalpcsendwaitreceiveport") || name.StartsWith ("ntdll.dll!ntalpcsendwaitreceiveport")) {  		found = true;  		IntPtr handle = stackFrame.Params [0];  		sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a LPC port:");  		sb.AppendLine (this.GetHandleString (_pid' handle));  	}  	else if (name.StartsWith ("ntdll.dll!zwsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!ntsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!zwsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!ntsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaithigheventpair") || name.StartsWith ("ntdll.dll!ntwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaitloweventpair") || name.StartsWith ("ntdll.dll!ntwaitloweventpair")) {  		found = true;  		IntPtr handle = stackFrame.Params [0];  		// Use the KiFastSystemCallRet args if the handle we have is wrong.  		if (handle.ToInt32 () % 2 != 0)  			handle = lastParams [1];  		sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for an event pair:");  		sb.AppendLine (this.GetHandleString (_pid' handle));  	}  	else if (name.StartsWith ("user32.dll!ntusergetmessage") || name.StartsWith ("user32.dll!ntuserwaitmessage")) {  		found = true;  		sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a USER message.");  	}  	else if (name.StartsWith ("ntdll.dll!zwwaitfordebugevent") || name.StartsWith ("ntdll.dll!ntwaitfordebugevent")) {  		found = true;  		IntPtr handle = stackFrame.Params [0];  		sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a debug event:");  		sb.AppendLine (this.GetHandleString (_pid' handle));  	}  	else if (name.StartsWith ("ntdll.dll!zwwaitforkeyedevent") || name.StartsWith ("ntdll.dll!ntwaitforkeyedevent") || name.StartsWith ("ntdll.dll!zwreleasekeyedevent") || name.StartsWith ("ntdll.dll!ntreleasekeyedevent")) {  		found = true;  		IntPtr handle = stackFrame.Params [0];  		IntPtr key = stackFrame.Params [1];  		sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for a keyed event (key 0x" + key.ToString ("x") + "):");  		sb.AppendLine (this.GetHandleString (_pid' handle));  	}  	else if (name.StartsWith ("ntdll.dll!zwwaitformultipleobjects") || name.StartsWith ("ntdll.dll!ntwaitformultipleobjects") || name.StartsWith ("kernel32.dll!waitformultipleobjects")) {  		found = true;  		int handleCount = stackFrame.Params [0].ToInt32 ();  		IntPtr handleAddress = stackFrame.Params [1];  		WaitType waitType = (WaitType)stackFrame.Params [2].ToInt32 ();  		bool alertable = stackFrame.Params [3].ToInt32 () != 0;  		// use the KiFastSystemCallRet args if we have the wrong args  		if (handleCount > 64) {  			handleCount = lastParams [1].ToInt32 ();  			handleAddress = lastParams [2];  			waitType = (WaitType)lastParams [3].ToInt32 ();  		}  		IntPtr* handles = stackalloc IntPtr[handleCount];  		phandle.ReadMemory (handleAddress' handles' handleCount * IntPtr.Size);  		sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + "' wait type: " + waitType.ToString () + ") for:");  		for (int i = 0; i < handleCount; i++) {  			sb.AppendLine (this.GetHandleString (_pid' handles [i]));  		}  	}  	else if (name.StartsWith ("ntdll.dll!zwwaitforsingleobject") || name.StartsWith ("ntdll.dll!ntwaitforsingleobject") || name.StartsWith ("kernel32.dll!waitforsingleobject")) {  		found = true;  		IntPtr handle = stackFrame.Params [0];  		bool alertable = stackFrame.Params [1].ToInt32 () != 0;  		sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + ") for:");  		sb.AppendLine (this.GetHandleString (_pid' handle));  	}  	else if (name.StartsWith ("ntdll.dll!zwwaitforworkviaworkerfactory") || name.StartsWith ("ntdll.dll!ntwaitforworkviaworkerfactory")) {  		found = true;  		IntPtr handle = stackFrame.Params [0];  		sb.AppendLine ("Thread " + tid.ToString () + " is waiting for work from a worker factory:");  		sb.AppendLine (this.GetHandleString (_pid' handle));  	}  	lastParams = stackFrame.Params;  	return !found;  });  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,analyzeWaitMenuItem_Click,The following statement contains a magic number: thandle.WalkStack (phandle' stackFrame =>  {  	uint address = stackFrame.PcAddress.ToUInt32 ();  	string name = _provider.Symbols.GetSymbolFromAddress (address).ToLowerInvariant ();  	if (name == null) {  		// dummy  	}  	else if (name.StartsWith ("kernel32.dll!sleep")) {  		found = true;  		sb.Append ("Thread is sleeping. Timeout: " + stackFrame.Params [0].ToInt32 ().ToString () + " milliseconds");  	}  	else if (name.StartsWith ("ntdll.dll!zwdelayexecution") || name.StartsWith ("ntdll.dll!ntdelayexecution")) {  		found = true;  		bool alertable = stackFrame.Params [0].ToInt32 () != 0;  		IntPtr timeoutAddress = stackFrame.Params [1];  		long timeout;  		phandle.ReadMemory (timeoutAddress' &timeout' sizeof(long));  		if (timeout < 0) {  			sb.Append ("Thread is sleeping. Timeout: " + (new TimeSpan (-timeout)).TotalMilliseconds.ToString () + " milliseconds");  		}  		else {  			sb.AppendLine ("Thread is sleeping. Timeout: " + (new DateTime (timeout)).ToString ());  		}  	}  	else if (name.StartsWith ("ntdll.dll!zwdeviceiocontrolfile") || name.StartsWith ("ntdll.dll!ntdeviceiocontrolfile")) {  		found = true;  		IntPtr handle = stackFrame.Params [0];  		sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an I/O control request:");  		sb.AppendLine (this.GetHandleString (_pid' handle));  	}  	else if (name.StartsWith ("ntdll.dll!ntfscontrolfile") || name.StartsWith ("ntdll.dll!zwfscontrolfile")) {  		found = true;  		IntPtr handle = stackFrame.Params [0];  		sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an FS control request:");  		sb.AppendLine (this.GetHandleString (_pid' handle));  	}  	else if (name.StartsWith ("ntdll.dll!ntqueryobject") || name.StartsWith ("ntdll.dll!zwqueryobject")) {  		found = true;  		IntPtr handle = stackFrame.Params [0];  		// Use the KiFastSystemCallRet args if the handle we have is wrong.  		if (handle.ToInt32 () % 2 != 0 || handle == IntPtr.Zero)  			handle = lastParams [1];  		sb.AppendLine ("Thread " + tid.ToString () + " is querying an object (most likely a named pipe):");  		sb.AppendLine (this.GetHandleString (_pid' handle));  	}  	else if (name.StartsWith ("ntdll.dll!zwreadfile") || name.StartsWith ("ntdll.dll!ntreadfile") || name.StartsWith ("ntdll.dll!zwwritefile") || name.StartsWith ("ntdll.dll!ntwritefile")) {  		found = true;  		IntPtr handle = stackFrame.Params [0];  		sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a named pipe or a file:");  		sb.AppendLine (this.GetHandleString (_pid' handle));  	}  	else if (name.StartsWith ("ntdll.dll!zwremoveiocompletion") || name.StartsWith ("ntdll.dll!ntremoveiocompletion")) {  		found = true;  		IntPtr handle = stackFrame.Params [0];  		sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an I/O completion object:");  		sb.AppendLine (this.GetHandleString (_pid' handle));  	}  	else if (name.StartsWith ("ntdll.dll!zwreplywaitreceiveport") || name.StartsWith ("ntdll.dll!ntreplywaitreceiveport") || name.StartsWith ("ntdll.dll!zwrequestwaitreplyport") || name.StartsWith ("ntdll.dll!ntrequestwaitreplyport") || name.StartsWith ("ntdll.dll!zwalpcsendwaitreceiveport") || name.StartsWith ("ntdll.dll!ntalpcsendwaitreceiveport")) {  		found = true;  		IntPtr handle = stackFrame.Params [0];  		sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a LPC port:");  		sb.AppendLine (this.GetHandleString (_pid' handle));  	}  	else if (name.StartsWith ("ntdll.dll!zwsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!ntsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!zwsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!ntsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaithigheventpair") || name.StartsWith ("ntdll.dll!ntwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaitloweventpair") || name.StartsWith ("ntdll.dll!ntwaitloweventpair")) {  		found = true;  		IntPtr handle = stackFrame.Params [0];  		// Use the KiFastSystemCallRet args if the handle we have is wrong.  		if (handle.ToInt32 () % 2 != 0)  			handle = lastParams [1];  		sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for an event pair:");  		sb.AppendLine (this.GetHandleString (_pid' handle));  	}  	else if (name.StartsWith ("user32.dll!ntusergetmessage") || name.StartsWith ("user32.dll!ntuserwaitmessage")) {  		found = true;  		sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a USER message.");  	}  	else if (name.StartsWith ("ntdll.dll!zwwaitfordebugevent") || name.StartsWith ("ntdll.dll!ntwaitfordebugevent")) {  		found = true;  		IntPtr handle = stackFrame.Params [0];  		sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a debug event:");  		sb.AppendLine (this.GetHandleString (_pid' handle));  	}  	else if (name.StartsWith ("ntdll.dll!zwwaitforkeyedevent") || name.StartsWith ("ntdll.dll!ntwaitforkeyedevent") || name.StartsWith ("ntdll.dll!zwreleasekeyedevent") || name.StartsWith ("ntdll.dll!ntreleasekeyedevent")) {  		found = true;  		IntPtr handle = stackFrame.Params [0];  		IntPtr key = stackFrame.Params [1];  		sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for a keyed event (key 0x" + key.ToString ("x") + "):");  		sb.AppendLine (this.GetHandleString (_pid' handle));  	}  	else if (name.StartsWith ("ntdll.dll!zwwaitformultipleobjects") || name.StartsWith ("ntdll.dll!ntwaitformultipleobjects") || name.StartsWith ("kernel32.dll!waitformultipleobjects")) {  		found = true;  		int handleCount = stackFrame.Params [0].ToInt32 ();  		IntPtr handleAddress = stackFrame.Params [1];  		WaitType waitType = (WaitType)stackFrame.Params [2].ToInt32 ();  		bool alertable = stackFrame.Params [3].ToInt32 () != 0;  		// use the KiFastSystemCallRet args if we have the wrong args  		if (handleCount > 64) {  			handleCount = lastParams [1].ToInt32 ();  			handleAddress = lastParams [2];  			waitType = (WaitType)lastParams [3].ToInt32 ();  		}  		IntPtr* handles = stackalloc IntPtr[handleCount];  		phandle.ReadMemory (handleAddress' handles' handleCount * IntPtr.Size);  		sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + "' wait type: " + waitType.ToString () + ") for:");  		for (int i = 0; i < handleCount; i++) {  			sb.AppendLine (this.GetHandleString (_pid' handles [i]));  		}  	}  	else if (name.StartsWith ("ntdll.dll!zwwaitforsingleobject") || name.StartsWith ("ntdll.dll!ntwaitforsingleobject") || name.StartsWith ("kernel32.dll!waitforsingleobject")) {  		found = true;  		IntPtr handle = stackFrame.Params [0];  		bool alertable = stackFrame.Params [1].ToInt32 () != 0;  		sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + ") for:");  		sb.AppendLine (this.GetHandleString (_pid' handle));  	}  	else if (name.StartsWith ("ntdll.dll!zwwaitforworkviaworkerfactory") || name.StartsWith ("ntdll.dll!ntwaitforworkviaworkerfactory")) {  		found = true;  		IntPtr handle = stackFrame.Params [0];  		sb.AppendLine ("Thread " + tid.ToString () + " is waiting for work from a worker factory:");  		sb.AppendLine (this.GetHandleString (_pid' handle));  	}  	lastParams = stackFrame.Params;  	return !found;  });  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,analyzeWaitMenuItem_Click,The following statement contains a magic number: if (name == null) {  	// dummy  }  else if (name.StartsWith ("kernel32.dll!sleep")) {  	found = true;  	sb.Append ("Thread is sleeping. Timeout: " + stackFrame.Params [0].ToInt32 ().ToString () + " milliseconds");  }  else if (name.StartsWith ("ntdll.dll!zwdelayexecution") || name.StartsWith ("ntdll.dll!ntdelayexecution")) {  	found = true;  	bool alertable = stackFrame.Params [0].ToInt32 () != 0;  	IntPtr timeoutAddress = stackFrame.Params [1];  	long timeout;  	phandle.ReadMemory (timeoutAddress' &timeout' sizeof(long));  	if (timeout < 0) {  		sb.Append ("Thread is sleeping. Timeout: " + (new TimeSpan (-timeout)).TotalMilliseconds.ToString () + " milliseconds");  	}  	else {  		sb.AppendLine ("Thread is sleeping. Timeout: " + (new DateTime (timeout)).ToString ());  	}  }  else if (name.StartsWith ("ntdll.dll!zwdeviceiocontrolfile") || name.StartsWith ("ntdll.dll!ntdeviceiocontrolfile")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an I/O control request:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!ntfscontrolfile") || name.StartsWith ("ntdll.dll!zwfscontrolfile")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an FS control request:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!ntqueryobject") || name.StartsWith ("ntdll.dll!zwqueryobject")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	// Use the KiFastSystemCallRet args if the handle we have is wrong.  	if (handle.ToInt32 () % 2 != 0 || handle == IntPtr.Zero)  		handle = lastParams [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is querying an object (most likely a named pipe):");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwreadfile") || name.StartsWith ("ntdll.dll!ntreadfile") || name.StartsWith ("ntdll.dll!zwwritefile") || name.StartsWith ("ntdll.dll!ntwritefile")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a named pipe or a file:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwremoveiocompletion") || name.StartsWith ("ntdll.dll!ntremoveiocompletion")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an I/O completion object:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwreplywaitreceiveport") || name.StartsWith ("ntdll.dll!ntreplywaitreceiveport") || name.StartsWith ("ntdll.dll!zwrequestwaitreplyport") || name.StartsWith ("ntdll.dll!ntrequestwaitreplyport") || name.StartsWith ("ntdll.dll!zwalpcsendwaitreceiveport") || name.StartsWith ("ntdll.dll!ntalpcsendwaitreceiveport")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a LPC port:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!ntsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!zwsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!ntsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaithigheventpair") || name.StartsWith ("ntdll.dll!ntwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaitloweventpair") || name.StartsWith ("ntdll.dll!ntwaitloweventpair")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	// Use the KiFastSystemCallRet args if the handle we have is wrong.  	if (handle.ToInt32 () % 2 != 0)  		handle = lastParams [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for an event pair:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("user32.dll!ntusergetmessage") || name.StartsWith ("user32.dll!ntuserwaitmessage")) {  	found = true;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a USER message.");  }  else if (name.StartsWith ("ntdll.dll!zwwaitfordebugevent") || name.StartsWith ("ntdll.dll!ntwaitfordebugevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a debug event:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforkeyedevent") || name.StartsWith ("ntdll.dll!ntwaitforkeyedevent") || name.StartsWith ("ntdll.dll!zwreleasekeyedevent") || name.StartsWith ("ntdll.dll!ntreleasekeyedevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	IntPtr key = stackFrame.Params [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for a keyed event (key 0x" + key.ToString ("x") + "):");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitformultipleobjects") || name.StartsWith ("ntdll.dll!ntwaitformultipleobjects") || name.StartsWith ("kernel32.dll!waitformultipleobjects")) {  	found = true;  	int handleCount = stackFrame.Params [0].ToInt32 ();  	IntPtr handleAddress = stackFrame.Params [1];  	WaitType waitType = (WaitType)stackFrame.Params [2].ToInt32 ();  	bool alertable = stackFrame.Params [3].ToInt32 () != 0;  	// use the KiFastSystemCallRet args if we have the wrong args  	if (handleCount > 64) {  		handleCount = lastParams [1].ToInt32 ();  		handleAddress = lastParams [2];  		waitType = (WaitType)lastParams [3].ToInt32 ();  	}  	IntPtr* handles = stackalloc IntPtr[handleCount];  	phandle.ReadMemory (handleAddress' handles' handleCount * IntPtr.Size);  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + "' wait type: " + waitType.ToString () + ") for:");  	for (int i = 0; i < handleCount; i++) {  		sb.AppendLine (this.GetHandleString (_pid' handles [i]));  	}  }  else if (name.StartsWith ("ntdll.dll!zwwaitforsingleobject") || name.StartsWith ("ntdll.dll!ntwaitforsingleobject") || name.StartsWith ("kernel32.dll!waitforsingleobject")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	bool alertable = stackFrame.Params [1].ToInt32 () != 0;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + ") for:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforworkviaworkerfactory") || name.StartsWith ("ntdll.dll!ntwaitforworkviaworkerfactory")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for work from a worker factory:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,analyzeWaitMenuItem_Click,The following statement contains a magic number: if (name == null) {  	// dummy  }  else if (name.StartsWith ("kernel32.dll!sleep")) {  	found = true;  	sb.Append ("Thread is sleeping. Timeout: " + stackFrame.Params [0].ToInt32 ().ToString () + " milliseconds");  }  else if (name.StartsWith ("ntdll.dll!zwdelayexecution") || name.StartsWith ("ntdll.dll!ntdelayexecution")) {  	found = true;  	bool alertable = stackFrame.Params [0].ToInt32 () != 0;  	IntPtr timeoutAddress = stackFrame.Params [1];  	long timeout;  	phandle.ReadMemory (timeoutAddress' &timeout' sizeof(long));  	if (timeout < 0) {  		sb.Append ("Thread is sleeping. Timeout: " + (new TimeSpan (-timeout)).TotalMilliseconds.ToString () + " milliseconds");  	}  	else {  		sb.AppendLine ("Thread is sleeping. Timeout: " + (new DateTime (timeout)).ToString ());  	}  }  else if (name.StartsWith ("ntdll.dll!zwdeviceiocontrolfile") || name.StartsWith ("ntdll.dll!ntdeviceiocontrolfile")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an I/O control request:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!ntfscontrolfile") || name.StartsWith ("ntdll.dll!zwfscontrolfile")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an FS control request:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!ntqueryobject") || name.StartsWith ("ntdll.dll!zwqueryobject")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	// Use the KiFastSystemCallRet args if the handle we have is wrong.  	if (handle.ToInt32 () % 2 != 0 || handle == IntPtr.Zero)  		handle = lastParams [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is querying an object (most likely a named pipe):");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwreadfile") || name.StartsWith ("ntdll.dll!ntreadfile") || name.StartsWith ("ntdll.dll!zwwritefile") || name.StartsWith ("ntdll.dll!ntwritefile")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a named pipe or a file:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwremoveiocompletion") || name.StartsWith ("ntdll.dll!ntremoveiocompletion")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an I/O completion object:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwreplywaitreceiveport") || name.StartsWith ("ntdll.dll!ntreplywaitreceiveport") || name.StartsWith ("ntdll.dll!zwrequestwaitreplyport") || name.StartsWith ("ntdll.dll!ntrequestwaitreplyport") || name.StartsWith ("ntdll.dll!zwalpcsendwaitreceiveport") || name.StartsWith ("ntdll.dll!ntalpcsendwaitreceiveport")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a LPC port:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!ntsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!zwsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!ntsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaithigheventpair") || name.StartsWith ("ntdll.dll!ntwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaitloweventpair") || name.StartsWith ("ntdll.dll!ntwaitloweventpair")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	// Use the KiFastSystemCallRet args if the handle we have is wrong.  	if (handle.ToInt32 () % 2 != 0)  		handle = lastParams [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for an event pair:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("user32.dll!ntusergetmessage") || name.StartsWith ("user32.dll!ntuserwaitmessage")) {  	found = true;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a USER message.");  }  else if (name.StartsWith ("ntdll.dll!zwwaitfordebugevent") || name.StartsWith ("ntdll.dll!ntwaitfordebugevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a debug event:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforkeyedevent") || name.StartsWith ("ntdll.dll!ntwaitforkeyedevent") || name.StartsWith ("ntdll.dll!zwreleasekeyedevent") || name.StartsWith ("ntdll.dll!ntreleasekeyedevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	IntPtr key = stackFrame.Params [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for a keyed event (key 0x" + key.ToString ("x") + "):");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitformultipleobjects") || name.StartsWith ("ntdll.dll!ntwaitformultipleobjects") || name.StartsWith ("kernel32.dll!waitformultipleobjects")) {  	found = true;  	int handleCount = stackFrame.Params [0].ToInt32 ();  	IntPtr handleAddress = stackFrame.Params [1];  	WaitType waitType = (WaitType)stackFrame.Params [2].ToInt32 ();  	bool alertable = stackFrame.Params [3].ToInt32 () != 0;  	// use the KiFastSystemCallRet args if we have the wrong args  	if (handleCount > 64) {  		handleCount = lastParams [1].ToInt32 ();  		handleAddress = lastParams [2];  		waitType = (WaitType)lastParams [3].ToInt32 ();  	}  	IntPtr* handles = stackalloc IntPtr[handleCount];  	phandle.ReadMemory (handleAddress' handles' handleCount * IntPtr.Size);  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + "' wait type: " + waitType.ToString () + ") for:");  	for (int i = 0; i < handleCount; i++) {  		sb.AppendLine (this.GetHandleString (_pid' handles [i]));  	}  }  else if (name.StartsWith ("ntdll.dll!zwwaitforsingleobject") || name.StartsWith ("ntdll.dll!ntwaitforsingleobject") || name.StartsWith ("kernel32.dll!waitforsingleobject")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	bool alertable = stackFrame.Params [1].ToInt32 () != 0;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + ") for:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforworkviaworkerfactory") || name.StartsWith ("ntdll.dll!ntwaitforworkviaworkerfactory")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for work from a worker factory:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,analyzeWaitMenuItem_Click,The following statement contains a magic number: if (name == null) {  	// dummy  }  else if (name.StartsWith ("kernel32.dll!sleep")) {  	found = true;  	sb.Append ("Thread is sleeping. Timeout: " + stackFrame.Params [0].ToInt32 ().ToString () + " milliseconds");  }  else if (name.StartsWith ("ntdll.dll!zwdelayexecution") || name.StartsWith ("ntdll.dll!ntdelayexecution")) {  	found = true;  	bool alertable = stackFrame.Params [0].ToInt32 () != 0;  	IntPtr timeoutAddress = stackFrame.Params [1];  	long timeout;  	phandle.ReadMemory (timeoutAddress' &timeout' sizeof(long));  	if (timeout < 0) {  		sb.Append ("Thread is sleeping. Timeout: " + (new TimeSpan (-timeout)).TotalMilliseconds.ToString () + " milliseconds");  	}  	else {  		sb.AppendLine ("Thread is sleeping. Timeout: " + (new DateTime (timeout)).ToString ());  	}  }  else if (name.StartsWith ("ntdll.dll!zwdeviceiocontrolfile") || name.StartsWith ("ntdll.dll!ntdeviceiocontrolfile")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an I/O control request:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!ntfscontrolfile") || name.StartsWith ("ntdll.dll!zwfscontrolfile")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an FS control request:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!ntqueryobject") || name.StartsWith ("ntdll.dll!zwqueryobject")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	// Use the KiFastSystemCallRet args if the handle we have is wrong.  	if (handle.ToInt32 () % 2 != 0 || handle == IntPtr.Zero)  		handle = lastParams [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is querying an object (most likely a named pipe):");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwreadfile") || name.StartsWith ("ntdll.dll!ntreadfile") || name.StartsWith ("ntdll.dll!zwwritefile") || name.StartsWith ("ntdll.dll!ntwritefile")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a named pipe or a file:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwremoveiocompletion") || name.StartsWith ("ntdll.dll!ntremoveiocompletion")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an I/O completion object:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwreplywaitreceiveport") || name.StartsWith ("ntdll.dll!ntreplywaitreceiveport") || name.StartsWith ("ntdll.dll!zwrequestwaitreplyport") || name.StartsWith ("ntdll.dll!ntrequestwaitreplyport") || name.StartsWith ("ntdll.dll!zwalpcsendwaitreceiveport") || name.StartsWith ("ntdll.dll!ntalpcsendwaitreceiveport")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a LPC port:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!ntsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!zwsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!ntsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaithigheventpair") || name.StartsWith ("ntdll.dll!ntwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaitloweventpair") || name.StartsWith ("ntdll.dll!ntwaitloweventpair")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	// Use the KiFastSystemCallRet args if the handle we have is wrong.  	if (handle.ToInt32 () % 2 != 0)  		handle = lastParams [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for an event pair:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("user32.dll!ntusergetmessage") || name.StartsWith ("user32.dll!ntuserwaitmessage")) {  	found = true;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a USER message.");  }  else if (name.StartsWith ("ntdll.dll!zwwaitfordebugevent") || name.StartsWith ("ntdll.dll!ntwaitfordebugevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a debug event:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforkeyedevent") || name.StartsWith ("ntdll.dll!ntwaitforkeyedevent") || name.StartsWith ("ntdll.dll!zwreleasekeyedevent") || name.StartsWith ("ntdll.dll!ntreleasekeyedevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	IntPtr key = stackFrame.Params [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for a keyed event (key 0x" + key.ToString ("x") + "):");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitformultipleobjects") || name.StartsWith ("ntdll.dll!ntwaitformultipleobjects") || name.StartsWith ("kernel32.dll!waitformultipleobjects")) {  	found = true;  	int handleCount = stackFrame.Params [0].ToInt32 ();  	IntPtr handleAddress = stackFrame.Params [1];  	WaitType waitType = (WaitType)stackFrame.Params [2].ToInt32 ();  	bool alertable = stackFrame.Params [3].ToInt32 () != 0;  	// use the KiFastSystemCallRet args if we have the wrong args  	if (handleCount > 64) {  		handleCount = lastParams [1].ToInt32 ();  		handleAddress = lastParams [2];  		waitType = (WaitType)lastParams [3].ToInt32 ();  	}  	IntPtr* handles = stackalloc IntPtr[handleCount];  	phandle.ReadMemory (handleAddress' handles' handleCount * IntPtr.Size);  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + "' wait type: " + waitType.ToString () + ") for:");  	for (int i = 0; i < handleCount; i++) {  		sb.AppendLine (this.GetHandleString (_pid' handles [i]));  	}  }  else if (name.StartsWith ("ntdll.dll!zwwaitforsingleobject") || name.StartsWith ("ntdll.dll!ntwaitforsingleobject") || name.StartsWith ("kernel32.dll!waitforsingleobject")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	bool alertable = stackFrame.Params [1].ToInt32 () != 0;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + ") for:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforworkviaworkerfactory") || name.StartsWith ("ntdll.dll!ntwaitforworkviaworkerfactory")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for work from a worker factory:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,analyzeWaitMenuItem_Click,The following statement contains a magic number: if (name == null) {  	// dummy  }  else if (name.StartsWith ("kernel32.dll!sleep")) {  	found = true;  	sb.Append ("Thread is sleeping. Timeout: " + stackFrame.Params [0].ToInt32 ().ToString () + " milliseconds");  }  else if (name.StartsWith ("ntdll.dll!zwdelayexecution") || name.StartsWith ("ntdll.dll!ntdelayexecution")) {  	found = true;  	bool alertable = stackFrame.Params [0].ToInt32 () != 0;  	IntPtr timeoutAddress = stackFrame.Params [1];  	long timeout;  	phandle.ReadMemory (timeoutAddress' &timeout' sizeof(long));  	if (timeout < 0) {  		sb.Append ("Thread is sleeping. Timeout: " + (new TimeSpan (-timeout)).TotalMilliseconds.ToString () + " milliseconds");  	}  	else {  		sb.AppendLine ("Thread is sleeping. Timeout: " + (new DateTime (timeout)).ToString ());  	}  }  else if (name.StartsWith ("ntdll.dll!zwdeviceiocontrolfile") || name.StartsWith ("ntdll.dll!ntdeviceiocontrolfile")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an I/O control request:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!ntfscontrolfile") || name.StartsWith ("ntdll.dll!zwfscontrolfile")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an FS control request:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!ntqueryobject") || name.StartsWith ("ntdll.dll!zwqueryobject")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	// Use the KiFastSystemCallRet args if the handle we have is wrong.  	if (handle.ToInt32 () % 2 != 0 || handle == IntPtr.Zero)  		handle = lastParams [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is querying an object (most likely a named pipe):");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwreadfile") || name.StartsWith ("ntdll.dll!ntreadfile") || name.StartsWith ("ntdll.dll!zwwritefile") || name.StartsWith ("ntdll.dll!ntwritefile")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a named pipe or a file:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwremoveiocompletion") || name.StartsWith ("ntdll.dll!ntremoveiocompletion")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an I/O completion object:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwreplywaitreceiveport") || name.StartsWith ("ntdll.dll!ntreplywaitreceiveport") || name.StartsWith ("ntdll.dll!zwrequestwaitreplyport") || name.StartsWith ("ntdll.dll!ntrequestwaitreplyport") || name.StartsWith ("ntdll.dll!zwalpcsendwaitreceiveport") || name.StartsWith ("ntdll.dll!ntalpcsendwaitreceiveport")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a LPC port:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!ntsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!zwsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!ntsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaithigheventpair") || name.StartsWith ("ntdll.dll!ntwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaitloweventpair") || name.StartsWith ("ntdll.dll!ntwaitloweventpair")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	// Use the KiFastSystemCallRet args if the handle we have is wrong.  	if (handle.ToInt32 () % 2 != 0)  		handle = lastParams [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for an event pair:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("user32.dll!ntusergetmessage") || name.StartsWith ("user32.dll!ntuserwaitmessage")) {  	found = true;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a USER message.");  }  else if (name.StartsWith ("ntdll.dll!zwwaitfordebugevent") || name.StartsWith ("ntdll.dll!ntwaitfordebugevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a debug event:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforkeyedevent") || name.StartsWith ("ntdll.dll!ntwaitforkeyedevent") || name.StartsWith ("ntdll.dll!zwreleasekeyedevent") || name.StartsWith ("ntdll.dll!ntreleasekeyedevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	IntPtr key = stackFrame.Params [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for a keyed event (key 0x" + key.ToString ("x") + "):");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitformultipleobjects") || name.StartsWith ("ntdll.dll!ntwaitformultipleobjects") || name.StartsWith ("kernel32.dll!waitformultipleobjects")) {  	found = true;  	int handleCount = stackFrame.Params [0].ToInt32 ();  	IntPtr handleAddress = stackFrame.Params [1];  	WaitType waitType = (WaitType)stackFrame.Params [2].ToInt32 ();  	bool alertable = stackFrame.Params [3].ToInt32 () != 0;  	// use the KiFastSystemCallRet args if we have the wrong args  	if (handleCount > 64) {  		handleCount = lastParams [1].ToInt32 ();  		handleAddress = lastParams [2];  		waitType = (WaitType)lastParams [3].ToInt32 ();  	}  	IntPtr* handles = stackalloc IntPtr[handleCount];  	phandle.ReadMemory (handleAddress' handles' handleCount * IntPtr.Size);  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + "' wait type: " + waitType.ToString () + ") for:");  	for (int i = 0; i < handleCount; i++) {  		sb.AppendLine (this.GetHandleString (_pid' handles [i]));  	}  }  else if (name.StartsWith ("ntdll.dll!zwwaitforsingleobject") || name.StartsWith ("ntdll.dll!ntwaitforsingleobject") || name.StartsWith ("kernel32.dll!waitforsingleobject")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	bool alertable = stackFrame.Params [1].ToInt32 () != 0;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + ") for:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforworkviaworkerfactory") || name.StartsWith ("ntdll.dll!ntwaitforworkviaworkerfactory")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for work from a worker factory:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,analyzeWaitMenuItem_Click,The following statement contains a magic number: if (name == null) {  	// dummy  }  else if (name.StartsWith ("kernel32.dll!sleep")) {  	found = true;  	sb.Append ("Thread is sleeping. Timeout: " + stackFrame.Params [0].ToInt32 ().ToString () + " milliseconds");  }  else if (name.StartsWith ("ntdll.dll!zwdelayexecution") || name.StartsWith ("ntdll.dll!ntdelayexecution")) {  	found = true;  	bool alertable = stackFrame.Params [0].ToInt32 () != 0;  	IntPtr timeoutAddress = stackFrame.Params [1];  	long timeout;  	phandle.ReadMemory (timeoutAddress' &timeout' sizeof(long));  	if (timeout < 0) {  		sb.Append ("Thread is sleeping. Timeout: " + (new TimeSpan (-timeout)).TotalMilliseconds.ToString () + " milliseconds");  	}  	else {  		sb.AppendLine ("Thread is sleeping. Timeout: " + (new DateTime (timeout)).ToString ());  	}  }  else if (name.StartsWith ("ntdll.dll!zwdeviceiocontrolfile") || name.StartsWith ("ntdll.dll!ntdeviceiocontrolfile")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an I/O control request:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!ntfscontrolfile") || name.StartsWith ("ntdll.dll!zwfscontrolfile")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an FS control request:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!ntqueryobject") || name.StartsWith ("ntdll.dll!zwqueryobject")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	// Use the KiFastSystemCallRet args if the handle we have is wrong.  	if (handle.ToInt32 () % 2 != 0 || handle == IntPtr.Zero)  		handle = lastParams [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is querying an object (most likely a named pipe):");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwreadfile") || name.StartsWith ("ntdll.dll!ntreadfile") || name.StartsWith ("ntdll.dll!zwwritefile") || name.StartsWith ("ntdll.dll!ntwritefile")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a named pipe or a file:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwremoveiocompletion") || name.StartsWith ("ntdll.dll!ntremoveiocompletion")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an I/O completion object:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwreplywaitreceiveport") || name.StartsWith ("ntdll.dll!ntreplywaitreceiveport") || name.StartsWith ("ntdll.dll!zwrequestwaitreplyport") || name.StartsWith ("ntdll.dll!ntrequestwaitreplyport") || name.StartsWith ("ntdll.dll!zwalpcsendwaitreceiveport") || name.StartsWith ("ntdll.dll!ntalpcsendwaitreceiveport")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a LPC port:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!ntsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!zwsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!ntsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaithigheventpair") || name.StartsWith ("ntdll.dll!ntwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaitloweventpair") || name.StartsWith ("ntdll.dll!ntwaitloweventpair")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	// Use the KiFastSystemCallRet args if the handle we have is wrong.  	if (handle.ToInt32 () % 2 != 0)  		handle = lastParams [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for an event pair:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("user32.dll!ntusergetmessage") || name.StartsWith ("user32.dll!ntuserwaitmessage")) {  	found = true;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a USER message.");  }  else if (name.StartsWith ("ntdll.dll!zwwaitfordebugevent") || name.StartsWith ("ntdll.dll!ntwaitfordebugevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a debug event:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforkeyedevent") || name.StartsWith ("ntdll.dll!ntwaitforkeyedevent") || name.StartsWith ("ntdll.dll!zwreleasekeyedevent") || name.StartsWith ("ntdll.dll!ntreleasekeyedevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	IntPtr key = stackFrame.Params [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for a keyed event (key 0x" + key.ToString ("x") + "):");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitformultipleobjects") || name.StartsWith ("ntdll.dll!ntwaitformultipleobjects") || name.StartsWith ("kernel32.dll!waitformultipleobjects")) {  	found = true;  	int handleCount = stackFrame.Params [0].ToInt32 ();  	IntPtr handleAddress = stackFrame.Params [1];  	WaitType waitType = (WaitType)stackFrame.Params [2].ToInt32 ();  	bool alertable = stackFrame.Params [3].ToInt32 () != 0;  	// use the KiFastSystemCallRet args if we have the wrong args  	if (handleCount > 64) {  		handleCount = lastParams [1].ToInt32 ();  		handleAddress = lastParams [2];  		waitType = (WaitType)lastParams [3].ToInt32 ();  	}  	IntPtr* handles = stackalloc IntPtr[handleCount];  	phandle.ReadMemory (handleAddress' handles' handleCount * IntPtr.Size);  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + "' wait type: " + waitType.ToString () + ") for:");  	for (int i = 0; i < handleCount; i++) {  		sb.AppendLine (this.GetHandleString (_pid' handles [i]));  	}  }  else if (name.StartsWith ("ntdll.dll!zwwaitforsingleobject") || name.StartsWith ("ntdll.dll!ntwaitforsingleobject") || name.StartsWith ("kernel32.dll!waitforsingleobject")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	bool alertable = stackFrame.Params [1].ToInt32 () != 0;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + ") for:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforworkviaworkerfactory") || name.StartsWith ("ntdll.dll!ntwaitforworkviaworkerfactory")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for work from a worker factory:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,analyzeWaitMenuItem_Click,The following statement contains a magic number: if (name == null) {  	// dummy  }  else if (name.StartsWith ("kernel32.dll!sleep")) {  	found = true;  	sb.Append ("Thread is sleeping. Timeout: " + stackFrame.Params [0].ToInt32 ().ToString () + " milliseconds");  }  else if (name.StartsWith ("ntdll.dll!zwdelayexecution") || name.StartsWith ("ntdll.dll!ntdelayexecution")) {  	found = true;  	bool alertable = stackFrame.Params [0].ToInt32 () != 0;  	IntPtr timeoutAddress = stackFrame.Params [1];  	long timeout;  	phandle.ReadMemory (timeoutAddress' &timeout' sizeof(long));  	if (timeout < 0) {  		sb.Append ("Thread is sleeping. Timeout: " + (new TimeSpan (-timeout)).TotalMilliseconds.ToString () + " milliseconds");  	}  	else {  		sb.AppendLine ("Thread is sleeping. Timeout: " + (new DateTime (timeout)).ToString ());  	}  }  else if (name.StartsWith ("ntdll.dll!zwdeviceiocontrolfile") || name.StartsWith ("ntdll.dll!ntdeviceiocontrolfile")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an I/O control request:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!ntfscontrolfile") || name.StartsWith ("ntdll.dll!zwfscontrolfile")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an FS control request:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!ntqueryobject") || name.StartsWith ("ntdll.dll!zwqueryobject")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	// Use the KiFastSystemCallRet args if the handle we have is wrong.  	if (handle.ToInt32 () % 2 != 0 || handle == IntPtr.Zero)  		handle = lastParams [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is querying an object (most likely a named pipe):");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwreadfile") || name.StartsWith ("ntdll.dll!ntreadfile") || name.StartsWith ("ntdll.dll!zwwritefile") || name.StartsWith ("ntdll.dll!ntwritefile")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a named pipe or a file:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwremoveiocompletion") || name.StartsWith ("ntdll.dll!ntremoveiocompletion")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an I/O completion object:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwreplywaitreceiveport") || name.StartsWith ("ntdll.dll!ntreplywaitreceiveport") || name.StartsWith ("ntdll.dll!zwrequestwaitreplyport") || name.StartsWith ("ntdll.dll!ntrequestwaitreplyport") || name.StartsWith ("ntdll.dll!zwalpcsendwaitreceiveport") || name.StartsWith ("ntdll.dll!ntalpcsendwaitreceiveport")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a LPC port:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!ntsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!zwsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!ntsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaithigheventpair") || name.StartsWith ("ntdll.dll!ntwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaitloweventpair") || name.StartsWith ("ntdll.dll!ntwaitloweventpair")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	// Use the KiFastSystemCallRet args if the handle we have is wrong.  	if (handle.ToInt32 () % 2 != 0)  		handle = lastParams [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for an event pair:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("user32.dll!ntusergetmessage") || name.StartsWith ("user32.dll!ntuserwaitmessage")) {  	found = true;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a USER message.");  }  else if (name.StartsWith ("ntdll.dll!zwwaitfordebugevent") || name.StartsWith ("ntdll.dll!ntwaitfordebugevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a debug event:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforkeyedevent") || name.StartsWith ("ntdll.dll!ntwaitforkeyedevent") || name.StartsWith ("ntdll.dll!zwreleasekeyedevent") || name.StartsWith ("ntdll.dll!ntreleasekeyedevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	IntPtr key = stackFrame.Params [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for a keyed event (key 0x" + key.ToString ("x") + "):");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitformultipleobjects") || name.StartsWith ("ntdll.dll!ntwaitformultipleobjects") || name.StartsWith ("kernel32.dll!waitformultipleobjects")) {  	found = true;  	int handleCount = stackFrame.Params [0].ToInt32 ();  	IntPtr handleAddress = stackFrame.Params [1];  	WaitType waitType = (WaitType)stackFrame.Params [2].ToInt32 ();  	bool alertable = stackFrame.Params [3].ToInt32 () != 0;  	// use the KiFastSystemCallRet args if we have the wrong args  	if (handleCount > 64) {  		handleCount = lastParams [1].ToInt32 ();  		handleAddress = lastParams [2];  		waitType = (WaitType)lastParams [3].ToInt32 ();  	}  	IntPtr* handles = stackalloc IntPtr[handleCount];  	phandle.ReadMemory (handleAddress' handles' handleCount * IntPtr.Size);  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + "' wait type: " + waitType.ToString () + ") for:");  	for (int i = 0; i < handleCount; i++) {  		sb.AppendLine (this.GetHandleString (_pid' handles [i]));  	}  }  else if (name.StartsWith ("ntdll.dll!zwwaitforsingleobject") || name.StartsWith ("ntdll.dll!ntwaitforsingleobject") || name.StartsWith ("kernel32.dll!waitforsingleobject")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	bool alertable = stackFrame.Params [1].ToInt32 () != 0;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + ") for:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforworkviaworkerfactory") || name.StartsWith ("ntdll.dll!ntwaitforworkviaworkerfactory")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for work from a worker factory:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,analyzeWaitMenuItem_Click,The following statement contains a magic number: if (name == null) {  	// dummy  }  else if (name.StartsWith ("kernel32.dll!sleep")) {  	found = true;  	sb.Append ("Thread is sleeping. Timeout: " + stackFrame.Params [0].ToInt32 ().ToString () + " milliseconds");  }  else if (name.StartsWith ("ntdll.dll!zwdelayexecution") || name.StartsWith ("ntdll.dll!ntdelayexecution")) {  	found = true;  	bool alertable = stackFrame.Params [0].ToInt32 () != 0;  	IntPtr timeoutAddress = stackFrame.Params [1];  	long timeout;  	phandle.ReadMemory (timeoutAddress' &timeout' sizeof(long));  	if (timeout < 0) {  		sb.Append ("Thread is sleeping. Timeout: " + (new TimeSpan (-timeout)).TotalMilliseconds.ToString () + " milliseconds");  	}  	else {  		sb.AppendLine ("Thread is sleeping. Timeout: " + (new DateTime (timeout)).ToString ());  	}  }  else if (name.StartsWith ("ntdll.dll!zwdeviceiocontrolfile") || name.StartsWith ("ntdll.dll!ntdeviceiocontrolfile")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an I/O control request:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!ntfscontrolfile") || name.StartsWith ("ntdll.dll!zwfscontrolfile")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an FS control request:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!ntqueryobject") || name.StartsWith ("ntdll.dll!zwqueryobject")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	// Use the KiFastSystemCallRet args if the handle we have is wrong.  	if (handle.ToInt32 () % 2 != 0 || handle == IntPtr.Zero)  		handle = lastParams [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is querying an object (most likely a named pipe):");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwreadfile") || name.StartsWith ("ntdll.dll!ntreadfile") || name.StartsWith ("ntdll.dll!zwwritefile") || name.StartsWith ("ntdll.dll!ntwritefile")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a named pipe or a file:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwremoveiocompletion") || name.StartsWith ("ntdll.dll!ntremoveiocompletion")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an I/O completion object:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwreplywaitreceiveport") || name.StartsWith ("ntdll.dll!ntreplywaitreceiveport") || name.StartsWith ("ntdll.dll!zwrequestwaitreplyport") || name.StartsWith ("ntdll.dll!ntrequestwaitreplyport") || name.StartsWith ("ntdll.dll!zwalpcsendwaitreceiveport") || name.StartsWith ("ntdll.dll!ntalpcsendwaitreceiveport")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a LPC port:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!ntsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!zwsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!ntsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaithigheventpair") || name.StartsWith ("ntdll.dll!ntwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaitloweventpair") || name.StartsWith ("ntdll.dll!ntwaitloweventpair")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	// Use the KiFastSystemCallRet args if the handle we have is wrong.  	if (handle.ToInt32 () % 2 != 0)  		handle = lastParams [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for an event pair:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("user32.dll!ntusergetmessage") || name.StartsWith ("user32.dll!ntuserwaitmessage")) {  	found = true;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a USER message.");  }  else if (name.StartsWith ("ntdll.dll!zwwaitfordebugevent") || name.StartsWith ("ntdll.dll!ntwaitfordebugevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a debug event:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforkeyedevent") || name.StartsWith ("ntdll.dll!ntwaitforkeyedevent") || name.StartsWith ("ntdll.dll!zwreleasekeyedevent") || name.StartsWith ("ntdll.dll!ntreleasekeyedevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	IntPtr key = stackFrame.Params [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for a keyed event (key 0x" + key.ToString ("x") + "):");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitformultipleobjects") || name.StartsWith ("ntdll.dll!ntwaitformultipleobjects") || name.StartsWith ("kernel32.dll!waitformultipleobjects")) {  	found = true;  	int handleCount = stackFrame.Params [0].ToInt32 ();  	IntPtr handleAddress = stackFrame.Params [1];  	WaitType waitType = (WaitType)stackFrame.Params [2].ToInt32 ();  	bool alertable = stackFrame.Params [3].ToInt32 () != 0;  	// use the KiFastSystemCallRet args if we have the wrong args  	if (handleCount > 64) {  		handleCount = lastParams [1].ToInt32 ();  		handleAddress = lastParams [2];  		waitType = (WaitType)lastParams [3].ToInt32 ();  	}  	IntPtr* handles = stackalloc IntPtr[handleCount];  	phandle.ReadMemory (handleAddress' handles' handleCount * IntPtr.Size);  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + "' wait type: " + waitType.ToString () + ") for:");  	for (int i = 0; i < handleCount; i++) {  		sb.AppendLine (this.GetHandleString (_pid' handles [i]));  	}  }  else if (name.StartsWith ("ntdll.dll!zwwaitforsingleobject") || name.StartsWith ("ntdll.dll!ntwaitforsingleobject") || name.StartsWith ("kernel32.dll!waitforsingleobject")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	bool alertable = stackFrame.Params [1].ToInt32 () != 0;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + ") for:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforworkviaworkerfactory") || name.StartsWith ("ntdll.dll!ntwaitforworkviaworkerfactory")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for work from a worker factory:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,analyzeWaitMenuItem_Click,The following statement contains a magic number: if (name.StartsWith ("kernel32.dll!sleep")) {  	found = true;  	sb.Append ("Thread is sleeping. Timeout: " + stackFrame.Params [0].ToInt32 ().ToString () + " milliseconds");  }  else if (name.StartsWith ("ntdll.dll!zwdelayexecution") || name.StartsWith ("ntdll.dll!ntdelayexecution")) {  	found = true;  	bool alertable = stackFrame.Params [0].ToInt32 () != 0;  	IntPtr timeoutAddress = stackFrame.Params [1];  	long timeout;  	phandle.ReadMemory (timeoutAddress' &timeout' sizeof(long));  	if (timeout < 0) {  		sb.Append ("Thread is sleeping. Timeout: " + (new TimeSpan (-timeout)).TotalMilliseconds.ToString () + " milliseconds");  	}  	else {  		sb.AppendLine ("Thread is sleeping. Timeout: " + (new DateTime (timeout)).ToString ());  	}  }  else if (name.StartsWith ("ntdll.dll!zwdeviceiocontrolfile") || name.StartsWith ("ntdll.dll!ntdeviceiocontrolfile")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an I/O control request:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!ntfscontrolfile") || name.StartsWith ("ntdll.dll!zwfscontrolfile")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an FS control request:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!ntqueryobject") || name.StartsWith ("ntdll.dll!zwqueryobject")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	// Use the KiFastSystemCallRet args if the handle we have is wrong.  	if (handle.ToInt32 () % 2 != 0 || handle == IntPtr.Zero)  		handle = lastParams [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is querying an object (most likely a named pipe):");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwreadfile") || name.StartsWith ("ntdll.dll!ntreadfile") || name.StartsWith ("ntdll.dll!zwwritefile") || name.StartsWith ("ntdll.dll!ntwritefile")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a named pipe or a file:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwremoveiocompletion") || name.StartsWith ("ntdll.dll!ntremoveiocompletion")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an I/O completion object:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwreplywaitreceiveport") || name.StartsWith ("ntdll.dll!ntreplywaitreceiveport") || name.StartsWith ("ntdll.dll!zwrequestwaitreplyport") || name.StartsWith ("ntdll.dll!ntrequestwaitreplyport") || name.StartsWith ("ntdll.dll!zwalpcsendwaitreceiveport") || name.StartsWith ("ntdll.dll!ntalpcsendwaitreceiveport")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a LPC port:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!ntsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!zwsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!ntsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaithigheventpair") || name.StartsWith ("ntdll.dll!ntwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaitloweventpair") || name.StartsWith ("ntdll.dll!ntwaitloweventpair")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	// Use the KiFastSystemCallRet args if the handle we have is wrong.  	if (handle.ToInt32 () % 2 != 0)  		handle = lastParams [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for an event pair:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("user32.dll!ntusergetmessage") || name.StartsWith ("user32.dll!ntuserwaitmessage")) {  	found = true;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a USER message.");  }  else if (name.StartsWith ("ntdll.dll!zwwaitfordebugevent") || name.StartsWith ("ntdll.dll!ntwaitfordebugevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a debug event:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforkeyedevent") || name.StartsWith ("ntdll.dll!ntwaitforkeyedevent") || name.StartsWith ("ntdll.dll!zwreleasekeyedevent") || name.StartsWith ("ntdll.dll!ntreleasekeyedevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	IntPtr key = stackFrame.Params [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for a keyed event (key 0x" + key.ToString ("x") + "):");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitformultipleobjects") || name.StartsWith ("ntdll.dll!ntwaitformultipleobjects") || name.StartsWith ("kernel32.dll!waitformultipleobjects")) {  	found = true;  	int handleCount = stackFrame.Params [0].ToInt32 ();  	IntPtr handleAddress = stackFrame.Params [1];  	WaitType waitType = (WaitType)stackFrame.Params [2].ToInt32 ();  	bool alertable = stackFrame.Params [3].ToInt32 () != 0;  	// use the KiFastSystemCallRet args if we have the wrong args  	if (handleCount > 64) {  		handleCount = lastParams [1].ToInt32 ();  		handleAddress = lastParams [2];  		waitType = (WaitType)lastParams [3].ToInt32 ();  	}  	IntPtr* handles = stackalloc IntPtr[handleCount];  	phandle.ReadMemory (handleAddress' handles' handleCount * IntPtr.Size);  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + "' wait type: " + waitType.ToString () + ") for:");  	for (int i = 0; i < handleCount; i++) {  		sb.AppendLine (this.GetHandleString (_pid' handles [i]));  	}  }  else if (name.StartsWith ("ntdll.dll!zwwaitforsingleobject") || name.StartsWith ("ntdll.dll!ntwaitforsingleobject") || name.StartsWith ("kernel32.dll!waitforsingleobject")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	bool alertable = stackFrame.Params [1].ToInt32 () != 0;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + ") for:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforworkviaworkerfactory") || name.StartsWith ("ntdll.dll!ntwaitforworkviaworkerfactory")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for work from a worker factory:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,analyzeWaitMenuItem_Click,The following statement contains a magic number: if (name.StartsWith ("kernel32.dll!sleep")) {  	found = true;  	sb.Append ("Thread is sleeping. Timeout: " + stackFrame.Params [0].ToInt32 ().ToString () + " milliseconds");  }  else if (name.StartsWith ("ntdll.dll!zwdelayexecution") || name.StartsWith ("ntdll.dll!ntdelayexecution")) {  	found = true;  	bool alertable = stackFrame.Params [0].ToInt32 () != 0;  	IntPtr timeoutAddress = stackFrame.Params [1];  	long timeout;  	phandle.ReadMemory (timeoutAddress' &timeout' sizeof(long));  	if (timeout < 0) {  		sb.Append ("Thread is sleeping. Timeout: " + (new TimeSpan (-timeout)).TotalMilliseconds.ToString () + " milliseconds");  	}  	else {  		sb.AppendLine ("Thread is sleeping. Timeout: " + (new DateTime (timeout)).ToString ());  	}  }  else if (name.StartsWith ("ntdll.dll!zwdeviceiocontrolfile") || name.StartsWith ("ntdll.dll!ntdeviceiocontrolfile")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an I/O control request:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!ntfscontrolfile") || name.StartsWith ("ntdll.dll!zwfscontrolfile")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an FS control request:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!ntqueryobject") || name.StartsWith ("ntdll.dll!zwqueryobject")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	// Use the KiFastSystemCallRet args if the handle we have is wrong.  	if (handle.ToInt32 () % 2 != 0 || handle == IntPtr.Zero)  		handle = lastParams [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is querying an object (most likely a named pipe):");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwreadfile") || name.StartsWith ("ntdll.dll!ntreadfile") || name.StartsWith ("ntdll.dll!zwwritefile") || name.StartsWith ("ntdll.dll!ntwritefile")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a named pipe or a file:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwremoveiocompletion") || name.StartsWith ("ntdll.dll!ntremoveiocompletion")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an I/O completion object:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwreplywaitreceiveport") || name.StartsWith ("ntdll.dll!ntreplywaitreceiveport") || name.StartsWith ("ntdll.dll!zwrequestwaitreplyport") || name.StartsWith ("ntdll.dll!ntrequestwaitreplyport") || name.StartsWith ("ntdll.dll!zwalpcsendwaitreceiveport") || name.StartsWith ("ntdll.dll!ntalpcsendwaitreceiveport")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a LPC port:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!ntsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!zwsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!ntsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaithigheventpair") || name.StartsWith ("ntdll.dll!ntwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaitloweventpair") || name.StartsWith ("ntdll.dll!ntwaitloweventpair")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	// Use the KiFastSystemCallRet args if the handle we have is wrong.  	if (handle.ToInt32 () % 2 != 0)  		handle = lastParams [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for an event pair:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("user32.dll!ntusergetmessage") || name.StartsWith ("user32.dll!ntuserwaitmessage")) {  	found = true;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a USER message.");  }  else if (name.StartsWith ("ntdll.dll!zwwaitfordebugevent") || name.StartsWith ("ntdll.dll!ntwaitfordebugevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a debug event:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforkeyedevent") || name.StartsWith ("ntdll.dll!ntwaitforkeyedevent") || name.StartsWith ("ntdll.dll!zwreleasekeyedevent") || name.StartsWith ("ntdll.dll!ntreleasekeyedevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	IntPtr key = stackFrame.Params [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for a keyed event (key 0x" + key.ToString ("x") + "):");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitformultipleobjects") || name.StartsWith ("ntdll.dll!ntwaitformultipleobjects") || name.StartsWith ("kernel32.dll!waitformultipleobjects")) {  	found = true;  	int handleCount = stackFrame.Params [0].ToInt32 ();  	IntPtr handleAddress = stackFrame.Params [1];  	WaitType waitType = (WaitType)stackFrame.Params [2].ToInt32 ();  	bool alertable = stackFrame.Params [3].ToInt32 () != 0;  	// use the KiFastSystemCallRet args if we have the wrong args  	if (handleCount > 64) {  		handleCount = lastParams [1].ToInt32 ();  		handleAddress = lastParams [2];  		waitType = (WaitType)lastParams [3].ToInt32 ();  	}  	IntPtr* handles = stackalloc IntPtr[handleCount];  	phandle.ReadMemory (handleAddress' handles' handleCount * IntPtr.Size);  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + "' wait type: " + waitType.ToString () + ") for:");  	for (int i = 0; i < handleCount; i++) {  		sb.AppendLine (this.GetHandleString (_pid' handles [i]));  	}  }  else if (name.StartsWith ("ntdll.dll!zwwaitforsingleobject") || name.StartsWith ("ntdll.dll!ntwaitforsingleobject") || name.StartsWith ("kernel32.dll!waitforsingleobject")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	bool alertable = stackFrame.Params [1].ToInt32 () != 0;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + ") for:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforworkviaworkerfactory") || name.StartsWith ("ntdll.dll!ntwaitforworkviaworkerfactory")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for work from a worker factory:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,analyzeWaitMenuItem_Click,The following statement contains a magic number: if (name.StartsWith ("kernel32.dll!sleep")) {  	found = true;  	sb.Append ("Thread is sleeping. Timeout: " + stackFrame.Params [0].ToInt32 ().ToString () + " milliseconds");  }  else if (name.StartsWith ("ntdll.dll!zwdelayexecution") || name.StartsWith ("ntdll.dll!ntdelayexecution")) {  	found = true;  	bool alertable = stackFrame.Params [0].ToInt32 () != 0;  	IntPtr timeoutAddress = stackFrame.Params [1];  	long timeout;  	phandle.ReadMemory (timeoutAddress' &timeout' sizeof(long));  	if (timeout < 0) {  		sb.Append ("Thread is sleeping. Timeout: " + (new TimeSpan (-timeout)).TotalMilliseconds.ToString () + " milliseconds");  	}  	else {  		sb.AppendLine ("Thread is sleeping. Timeout: " + (new DateTime (timeout)).ToString ());  	}  }  else if (name.StartsWith ("ntdll.dll!zwdeviceiocontrolfile") || name.StartsWith ("ntdll.dll!ntdeviceiocontrolfile")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an I/O control request:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!ntfscontrolfile") || name.StartsWith ("ntdll.dll!zwfscontrolfile")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an FS control request:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!ntqueryobject") || name.StartsWith ("ntdll.dll!zwqueryobject")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	// Use the KiFastSystemCallRet args if the handle we have is wrong.  	if (handle.ToInt32 () % 2 != 0 || handle == IntPtr.Zero)  		handle = lastParams [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is querying an object (most likely a named pipe):");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwreadfile") || name.StartsWith ("ntdll.dll!ntreadfile") || name.StartsWith ("ntdll.dll!zwwritefile") || name.StartsWith ("ntdll.dll!ntwritefile")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a named pipe or a file:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwremoveiocompletion") || name.StartsWith ("ntdll.dll!ntremoveiocompletion")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an I/O completion object:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwreplywaitreceiveport") || name.StartsWith ("ntdll.dll!ntreplywaitreceiveport") || name.StartsWith ("ntdll.dll!zwrequestwaitreplyport") || name.StartsWith ("ntdll.dll!ntrequestwaitreplyport") || name.StartsWith ("ntdll.dll!zwalpcsendwaitreceiveport") || name.StartsWith ("ntdll.dll!ntalpcsendwaitreceiveport")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a LPC port:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!ntsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!zwsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!ntsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaithigheventpair") || name.StartsWith ("ntdll.dll!ntwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaitloweventpair") || name.StartsWith ("ntdll.dll!ntwaitloweventpair")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	// Use the KiFastSystemCallRet args if the handle we have is wrong.  	if (handle.ToInt32 () % 2 != 0)  		handle = lastParams [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for an event pair:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("user32.dll!ntusergetmessage") || name.StartsWith ("user32.dll!ntuserwaitmessage")) {  	found = true;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a USER message.");  }  else if (name.StartsWith ("ntdll.dll!zwwaitfordebugevent") || name.StartsWith ("ntdll.dll!ntwaitfordebugevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a debug event:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforkeyedevent") || name.StartsWith ("ntdll.dll!ntwaitforkeyedevent") || name.StartsWith ("ntdll.dll!zwreleasekeyedevent") || name.StartsWith ("ntdll.dll!ntreleasekeyedevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	IntPtr key = stackFrame.Params [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for a keyed event (key 0x" + key.ToString ("x") + "):");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitformultipleobjects") || name.StartsWith ("ntdll.dll!ntwaitformultipleobjects") || name.StartsWith ("kernel32.dll!waitformultipleobjects")) {  	found = true;  	int handleCount = stackFrame.Params [0].ToInt32 ();  	IntPtr handleAddress = stackFrame.Params [1];  	WaitType waitType = (WaitType)stackFrame.Params [2].ToInt32 ();  	bool alertable = stackFrame.Params [3].ToInt32 () != 0;  	// use the KiFastSystemCallRet args if we have the wrong args  	if (handleCount > 64) {  		handleCount = lastParams [1].ToInt32 ();  		handleAddress = lastParams [2];  		waitType = (WaitType)lastParams [3].ToInt32 ();  	}  	IntPtr* handles = stackalloc IntPtr[handleCount];  	phandle.ReadMemory (handleAddress' handles' handleCount * IntPtr.Size);  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + "' wait type: " + waitType.ToString () + ") for:");  	for (int i = 0; i < handleCount; i++) {  		sb.AppendLine (this.GetHandleString (_pid' handles [i]));  	}  }  else if (name.StartsWith ("ntdll.dll!zwwaitforsingleobject") || name.StartsWith ("ntdll.dll!ntwaitforsingleobject") || name.StartsWith ("kernel32.dll!waitforsingleobject")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	bool alertable = stackFrame.Params [1].ToInt32 () != 0;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + ") for:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforworkviaworkerfactory") || name.StartsWith ("ntdll.dll!ntwaitforworkviaworkerfactory")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for work from a worker factory:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,analyzeWaitMenuItem_Click,The following statement contains a magic number: if (name.StartsWith ("kernel32.dll!sleep")) {  	found = true;  	sb.Append ("Thread is sleeping. Timeout: " + stackFrame.Params [0].ToInt32 ().ToString () + " milliseconds");  }  else if (name.StartsWith ("ntdll.dll!zwdelayexecution") || name.StartsWith ("ntdll.dll!ntdelayexecution")) {  	found = true;  	bool alertable = stackFrame.Params [0].ToInt32 () != 0;  	IntPtr timeoutAddress = stackFrame.Params [1];  	long timeout;  	phandle.ReadMemory (timeoutAddress' &timeout' sizeof(long));  	if (timeout < 0) {  		sb.Append ("Thread is sleeping. Timeout: " + (new TimeSpan (-timeout)).TotalMilliseconds.ToString () + " milliseconds");  	}  	else {  		sb.AppendLine ("Thread is sleeping. Timeout: " + (new DateTime (timeout)).ToString ());  	}  }  else if (name.StartsWith ("ntdll.dll!zwdeviceiocontrolfile") || name.StartsWith ("ntdll.dll!ntdeviceiocontrolfile")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an I/O control request:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!ntfscontrolfile") || name.StartsWith ("ntdll.dll!zwfscontrolfile")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an FS control request:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!ntqueryobject") || name.StartsWith ("ntdll.dll!zwqueryobject")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	// Use the KiFastSystemCallRet args if the handle we have is wrong.  	if (handle.ToInt32 () % 2 != 0 || handle == IntPtr.Zero)  		handle = lastParams [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is querying an object (most likely a named pipe):");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwreadfile") || name.StartsWith ("ntdll.dll!ntreadfile") || name.StartsWith ("ntdll.dll!zwwritefile") || name.StartsWith ("ntdll.dll!ntwritefile")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a named pipe or a file:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwremoveiocompletion") || name.StartsWith ("ntdll.dll!ntremoveiocompletion")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an I/O completion object:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwreplywaitreceiveport") || name.StartsWith ("ntdll.dll!ntreplywaitreceiveport") || name.StartsWith ("ntdll.dll!zwrequestwaitreplyport") || name.StartsWith ("ntdll.dll!ntrequestwaitreplyport") || name.StartsWith ("ntdll.dll!zwalpcsendwaitreceiveport") || name.StartsWith ("ntdll.dll!ntalpcsendwaitreceiveport")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a LPC port:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!ntsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!zwsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!ntsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaithigheventpair") || name.StartsWith ("ntdll.dll!ntwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaitloweventpair") || name.StartsWith ("ntdll.dll!ntwaitloweventpair")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	// Use the KiFastSystemCallRet args if the handle we have is wrong.  	if (handle.ToInt32 () % 2 != 0)  		handle = lastParams [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for an event pair:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("user32.dll!ntusergetmessage") || name.StartsWith ("user32.dll!ntuserwaitmessage")) {  	found = true;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a USER message.");  }  else if (name.StartsWith ("ntdll.dll!zwwaitfordebugevent") || name.StartsWith ("ntdll.dll!ntwaitfordebugevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a debug event:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforkeyedevent") || name.StartsWith ("ntdll.dll!ntwaitforkeyedevent") || name.StartsWith ("ntdll.dll!zwreleasekeyedevent") || name.StartsWith ("ntdll.dll!ntreleasekeyedevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	IntPtr key = stackFrame.Params [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for a keyed event (key 0x" + key.ToString ("x") + "):");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitformultipleobjects") || name.StartsWith ("ntdll.dll!ntwaitformultipleobjects") || name.StartsWith ("kernel32.dll!waitformultipleobjects")) {  	found = true;  	int handleCount = stackFrame.Params [0].ToInt32 ();  	IntPtr handleAddress = stackFrame.Params [1];  	WaitType waitType = (WaitType)stackFrame.Params [2].ToInt32 ();  	bool alertable = stackFrame.Params [3].ToInt32 () != 0;  	// use the KiFastSystemCallRet args if we have the wrong args  	if (handleCount > 64) {  		handleCount = lastParams [1].ToInt32 ();  		handleAddress = lastParams [2];  		waitType = (WaitType)lastParams [3].ToInt32 ();  	}  	IntPtr* handles = stackalloc IntPtr[handleCount];  	phandle.ReadMemory (handleAddress' handles' handleCount * IntPtr.Size);  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + "' wait type: " + waitType.ToString () + ") for:");  	for (int i = 0; i < handleCount; i++) {  		sb.AppendLine (this.GetHandleString (_pid' handles [i]));  	}  }  else if (name.StartsWith ("ntdll.dll!zwwaitforsingleobject") || name.StartsWith ("ntdll.dll!ntwaitforsingleobject") || name.StartsWith ("kernel32.dll!waitforsingleobject")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	bool alertable = stackFrame.Params [1].ToInt32 () != 0;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + ") for:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforworkviaworkerfactory") || name.StartsWith ("ntdll.dll!ntwaitforworkviaworkerfactory")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for work from a worker factory:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,analyzeWaitMenuItem_Click,The following statement contains a magic number: if (name.StartsWith ("kernel32.dll!sleep")) {  	found = true;  	sb.Append ("Thread is sleeping. Timeout: " + stackFrame.Params [0].ToInt32 ().ToString () + " milliseconds");  }  else if (name.StartsWith ("ntdll.dll!zwdelayexecution") || name.StartsWith ("ntdll.dll!ntdelayexecution")) {  	found = true;  	bool alertable = stackFrame.Params [0].ToInt32 () != 0;  	IntPtr timeoutAddress = stackFrame.Params [1];  	long timeout;  	phandle.ReadMemory (timeoutAddress' &timeout' sizeof(long));  	if (timeout < 0) {  		sb.Append ("Thread is sleeping. Timeout: " + (new TimeSpan (-timeout)).TotalMilliseconds.ToString () + " milliseconds");  	}  	else {  		sb.AppendLine ("Thread is sleeping. Timeout: " + (new DateTime (timeout)).ToString ());  	}  }  else if (name.StartsWith ("ntdll.dll!zwdeviceiocontrolfile") || name.StartsWith ("ntdll.dll!ntdeviceiocontrolfile")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an I/O control request:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!ntfscontrolfile") || name.StartsWith ("ntdll.dll!zwfscontrolfile")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an FS control request:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!ntqueryobject") || name.StartsWith ("ntdll.dll!zwqueryobject")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	// Use the KiFastSystemCallRet args if the handle we have is wrong.  	if (handle.ToInt32 () % 2 != 0 || handle == IntPtr.Zero)  		handle = lastParams [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is querying an object (most likely a named pipe):");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwreadfile") || name.StartsWith ("ntdll.dll!ntreadfile") || name.StartsWith ("ntdll.dll!zwwritefile") || name.StartsWith ("ntdll.dll!ntwritefile")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a named pipe or a file:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwremoveiocompletion") || name.StartsWith ("ntdll.dll!ntremoveiocompletion")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an I/O completion object:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwreplywaitreceiveport") || name.StartsWith ("ntdll.dll!ntreplywaitreceiveport") || name.StartsWith ("ntdll.dll!zwrequestwaitreplyport") || name.StartsWith ("ntdll.dll!ntrequestwaitreplyport") || name.StartsWith ("ntdll.dll!zwalpcsendwaitreceiveport") || name.StartsWith ("ntdll.dll!ntalpcsendwaitreceiveport")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a LPC port:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!ntsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!zwsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!ntsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaithigheventpair") || name.StartsWith ("ntdll.dll!ntwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaitloweventpair") || name.StartsWith ("ntdll.dll!ntwaitloweventpair")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	// Use the KiFastSystemCallRet args if the handle we have is wrong.  	if (handle.ToInt32 () % 2 != 0)  		handle = lastParams [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for an event pair:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("user32.dll!ntusergetmessage") || name.StartsWith ("user32.dll!ntuserwaitmessage")) {  	found = true;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a USER message.");  }  else if (name.StartsWith ("ntdll.dll!zwwaitfordebugevent") || name.StartsWith ("ntdll.dll!ntwaitfordebugevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a debug event:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforkeyedevent") || name.StartsWith ("ntdll.dll!ntwaitforkeyedevent") || name.StartsWith ("ntdll.dll!zwreleasekeyedevent") || name.StartsWith ("ntdll.dll!ntreleasekeyedevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	IntPtr key = stackFrame.Params [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for a keyed event (key 0x" + key.ToString ("x") + "):");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitformultipleobjects") || name.StartsWith ("ntdll.dll!ntwaitformultipleobjects") || name.StartsWith ("kernel32.dll!waitformultipleobjects")) {  	found = true;  	int handleCount = stackFrame.Params [0].ToInt32 ();  	IntPtr handleAddress = stackFrame.Params [1];  	WaitType waitType = (WaitType)stackFrame.Params [2].ToInt32 ();  	bool alertable = stackFrame.Params [3].ToInt32 () != 0;  	// use the KiFastSystemCallRet args if we have the wrong args  	if (handleCount > 64) {  		handleCount = lastParams [1].ToInt32 ();  		handleAddress = lastParams [2];  		waitType = (WaitType)lastParams [3].ToInt32 ();  	}  	IntPtr* handles = stackalloc IntPtr[handleCount];  	phandle.ReadMemory (handleAddress' handles' handleCount * IntPtr.Size);  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + "' wait type: " + waitType.ToString () + ") for:");  	for (int i = 0; i < handleCount; i++) {  		sb.AppendLine (this.GetHandleString (_pid' handles [i]));  	}  }  else if (name.StartsWith ("ntdll.dll!zwwaitforsingleobject") || name.StartsWith ("ntdll.dll!ntwaitforsingleobject") || name.StartsWith ("kernel32.dll!waitforsingleobject")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	bool alertable = stackFrame.Params [1].ToInt32 () != 0;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + ") for:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforworkviaworkerfactory") || name.StartsWith ("ntdll.dll!ntwaitforworkviaworkerfactory")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for work from a worker factory:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,analyzeWaitMenuItem_Click,The following statement contains a magic number: if (name.StartsWith ("kernel32.dll!sleep")) {  	found = true;  	sb.Append ("Thread is sleeping. Timeout: " + stackFrame.Params [0].ToInt32 ().ToString () + " milliseconds");  }  else if (name.StartsWith ("ntdll.dll!zwdelayexecution") || name.StartsWith ("ntdll.dll!ntdelayexecution")) {  	found = true;  	bool alertable = stackFrame.Params [0].ToInt32 () != 0;  	IntPtr timeoutAddress = stackFrame.Params [1];  	long timeout;  	phandle.ReadMemory (timeoutAddress' &timeout' sizeof(long));  	if (timeout < 0) {  		sb.Append ("Thread is sleeping. Timeout: " + (new TimeSpan (-timeout)).TotalMilliseconds.ToString () + " milliseconds");  	}  	else {  		sb.AppendLine ("Thread is sleeping. Timeout: " + (new DateTime (timeout)).ToString ());  	}  }  else if (name.StartsWith ("ntdll.dll!zwdeviceiocontrolfile") || name.StartsWith ("ntdll.dll!ntdeviceiocontrolfile")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an I/O control request:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!ntfscontrolfile") || name.StartsWith ("ntdll.dll!zwfscontrolfile")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an FS control request:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!ntqueryobject") || name.StartsWith ("ntdll.dll!zwqueryobject")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	// Use the KiFastSystemCallRet args if the handle we have is wrong.  	if (handle.ToInt32 () % 2 != 0 || handle == IntPtr.Zero)  		handle = lastParams [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is querying an object (most likely a named pipe):");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwreadfile") || name.StartsWith ("ntdll.dll!ntreadfile") || name.StartsWith ("ntdll.dll!zwwritefile") || name.StartsWith ("ntdll.dll!ntwritefile")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a named pipe or a file:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwremoveiocompletion") || name.StartsWith ("ntdll.dll!ntremoveiocompletion")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an I/O completion object:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwreplywaitreceiveport") || name.StartsWith ("ntdll.dll!ntreplywaitreceiveport") || name.StartsWith ("ntdll.dll!zwrequestwaitreplyport") || name.StartsWith ("ntdll.dll!ntrequestwaitreplyport") || name.StartsWith ("ntdll.dll!zwalpcsendwaitreceiveport") || name.StartsWith ("ntdll.dll!ntalpcsendwaitreceiveport")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a LPC port:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!ntsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!zwsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!ntsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaithigheventpair") || name.StartsWith ("ntdll.dll!ntwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaitloweventpair") || name.StartsWith ("ntdll.dll!ntwaitloweventpair")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	// Use the KiFastSystemCallRet args if the handle we have is wrong.  	if (handle.ToInt32 () % 2 != 0)  		handle = lastParams [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for an event pair:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("user32.dll!ntusergetmessage") || name.StartsWith ("user32.dll!ntuserwaitmessage")) {  	found = true;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a USER message.");  }  else if (name.StartsWith ("ntdll.dll!zwwaitfordebugevent") || name.StartsWith ("ntdll.dll!ntwaitfordebugevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a debug event:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforkeyedevent") || name.StartsWith ("ntdll.dll!ntwaitforkeyedevent") || name.StartsWith ("ntdll.dll!zwreleasekeyedevent") || name.StartsWith ("ntdll.dll!ntreleasekeyedevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	IntPtr key = stackFrame.Params [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for a keyed event (key 0x" + key.ToString ("x") + "):");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitformultipleobjects") || name.StartsWith ("ntdll.dll!ntwaitformultipleobjects") || name.StartsWith ("kernel32.dll!waitformultipleobjects")) {  	found = true;  	int handleCount = stackFrame.Params [0].ToInt32 ();  	IntPtr handleAddress = stackFrame.Params [1];  	WaitType waitType = (WaitType)stackFrame.Params [2].ToInt32 ();  	bool alertable = stackFrame.Params [3].ToInt32 () != 0;  	// use the KiFastSystemCallRet args if we have the wrong args  	if (handleCount > 64) {  		handleCount = lastParams [1].ToInt32 ();  		handleAddress = lastParams [2];  		waitType = (WaitType)lastParams [3].ToInt32 ();  	}  	IntPtr* handles = stackalloc IntPtr[handleCount];  	phandle.ReadMemory (handleAddress' handles' handleCount * IntPtr.Size);  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + "' wait type: " + waitType.ToString () + ") for:");  	for (int i = 0; i < handleCount; i++) {  		sb.AppendLine (this.GetHandleString (_pid' handles [i]));  	}  }  else if (name.StartsWith ("ntdll.dll!zwwaitforsingleobject") || name.StartsWith ("ntdll.dll!ntwaitforsingleobject") || name.StartsWith ("kernel32.dll!waitforsingleobject")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	bool alertable = stackFrame.Params [1].ToInt32 () != 0;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + ") for:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforworkviaworkerfactory") || name.StartsWith ("ntdll.dll!ntwaitforworkviaworkerfactory")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for work from a worker factory:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,analyzeWaitMenuItem_Click,The following statement contains a magic number: if (name.StartsWith ("kernel32.dll!sleep")) {  	found = true;  	sb.Append ("Thread is sleeping. Timeout: " + stackFrame.Params [0].ToInt32 ().ToString () + " milliseconds");  }  else if (name.StartsWith ("ntdll.dll!zwdelayexecution") || name.StartsWith ("ntdll.dll!ntdelayexecution")) {  	found = true;  	bool alertable = stackFrame.Params [0].ToInt32 () != 0;  	IntPtr timeoutAddress = stackFrame.Params [1];  	long timeout;  	phandle.ReadMemory (timeoutAddress' &timeout' sizeof(long));  	if (timeout < 0) {  		sb.Append ("Thread is sleeping. Timeout: " + (new TimeSpan (-timeout)).TotalMilliseconds.ToString () + " milliseconds");  	}  	else {  		sb.AppendLine ("Thread is sleeping. Timeout: " + (new DateTime (timeout)).ToString ());  	}  }  else if (name.StartsWith ("ntdll.dll!zwdeviceiocontrolfile") || name.StartsWith ("ntdll.dll!ntdeviceiocontrolfile")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an I/O control request:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!ntfscontrolfile") || name.StartsWith ("ntdll.dll!zwfscontrolfile")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an FS control request:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!ntqueryobject") || name.StartsWith ("ntdll.dll!zwqueryobject")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	// Use the KiFastSystemCallRet args if the handle we have is wrong.  	if (handle.ToInt32 () % 2 != 0 || handle == IntPtr.Zero)  		handle = lastParams [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is querying an object (most likely a named pipe):");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwreadfile") || name.StartsWith ("ntdll.dll!ntreadfile") || name.StartsWith ("ntdll.dll!zwwritefile") || name.StartsWith ("ntdll.dll!ntwritefile")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a named pipe or a file:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwremoveiocompletion") || name.StartsWith ("ntdll.dll!ntremoveiocompletion")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an I/O completion object:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwreplywaitreceiveport") || name.StartsWith ("ntdll.dll!ntreplywaitreceiveport") || name.StartsWith ("ntdll.dll!zwrequestwaitreplyport") || name.StartsWith ("ntdll.dll!ntrequestwaitreplyport") || name.StartsWith ("ntdll.dll!zwalpcsendwaitreceiveport") || name.StartsWith ("ntdll.dll!ntalpcsendwaitreceiveport")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a LPC port:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!ntsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!zwsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!ntsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaithigheventpair") || name.StartsWith ("ntdll.dll!ntwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaitloweventpair") || name.StartsWith ("ntdll.dll!ntwaitloweventpair")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	// Use the KiFastSystemCallRet args if the handle we have is wrong.  	if (handle.ToInt32 () % 2 != 0)  		handle = lastParams [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for an event pair:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("user32.dll!ntusergetmessage") || name.StartsWith ("user32.dll!ntuserwaitmessage")) {  	found = true;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a USER message.");  }  else if (name.StartsWith ("ntdll.dll!zwwaitfordebugevent") || name.StartsWith ("ntdll.dll!ntwaitfordebugevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a debug event:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforkeyedevent") || name.StartsWith ("ntdll.dll!ntwaitforkeyedevent") || name.StartsWith ("ntdll.dll!zwreleasekeyedevent") || name.StartsWith ("ntdll.dll!ntreleasekeyedevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	IntPtr key = stackFrame.Params [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for a keyed event (key 0x" + key.ToString ("x") + "):");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitformultipleobjects") || name.StartsWith ("ntdll.dll!ntwaitformultipleobjects") || name.StartsWith ("kernel32.dll!waitformultipleobjects")) {  	found = true;  	int handleCount = stackFrame.Params [0].ToInt32 ();  	IntPtr handleAddress = stackFrame.Params [1];  	WaitType waitType = (WaitType)stackFrame.Params [2].ToInt32 ();  	bool alertable = stackFrame.Params [3].ToInt32 () != 0;  	// use the KiFastSystemCallRet args if we have the wrong args  	if (handleCount > 64) {  		handleCount = lastParams [1].ToInt32 ();  		handleAddress = lastParams [2];  		waitType = (WaitType)lastParams [3].ToInt32 ();  	}  	IntPtr* handles = stackalloc IntPtr[handleCount];  	phandle.ReadMemory (handleAddress' handles' handleCount * IntPtr.Size);  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + "' wait type: " + waitType.ToString () + ") for:");  	for (int i = 0; i < handleCount; i++) {  		sb.AppendLine (this.GetHandleString (_pid' handles [i]));  	}  }  else if (name.StartsWith ("ntdll.dll!zwwaitforsingleobject") || name.StartsWith ("ntdll.dll!ntwaitforsingleobject") || name.StartsWith ("kernel32.dll!waitforsingleobject")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	bool alertable = stackFrame.Params [1].ToInt32 () != 0;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + ") for:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforworkviaworkerfactory") || name.StartsWith ("ntdll.dll!ntwaitforworkviaworkerfactory")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for work from a worker factory:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,analyzeWaitMenuItem_Click,The following statement contains a magic number: if (name.StartsWith ("ntdll.dll!zwdelayexecution") || name.StartsWith ("ntdll.dll!ntdelayexecution")) {  	found = true;  	bool alertable = stackFrame.Params [0].ToInt32 () != 0;  	IntPtr timeoutAddress = stackFrame.Params [1];  	long timeout;  	phandle.ReadMemory (timeoutAddress' &timeout' sizeof(long));  	if (timeout < 0) {  		sb.Append ("Thread is sleeping. Timeout: " + (new TimeSpan (-timeout)).TotalMilliseconds.ToString () + " milliseconds");  	}  	else {  		sb.AppendLine ("Thread is sleeping. Timeout: " + (new DateTime (timeout)).ToString ());  	}  }  else if (name.StartsWith ("ntdll.dll!zwdeviceiocontrolfile") || name.StartsWith ("ntdll.dll!ntdeviceiocontrolfile")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an I/O control request:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!ntfscontrolfile") || name.StartsWith ("ntdll.dll!zwfscontrolfile")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an FS control request:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!ntqueryobject") || name.StartsWith ("ntdll.dll!zwqueryobject")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	// Use the KiFastSystemCallRet args if the handle we have is wrong.  	if (handle.ToInt32 () % 2 != 0 || handle == IntPtr.Zero)  		handle = lastParams [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is querying an object (most likely a named pipe):");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwreadfile") || name.StartsWith ("ntdll.dll!ntreadfile") || name.StartsWith ("ntdll.dll!zwwritefile") || name.StartsWith ("ntdll.dll!ntwritefile")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a named pipe or a file:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwremoveiocompletion") || name.StartsWith ("ntdll.dll!ntremoveiocompletion")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an I/O completion object:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwreplywaitreceiveport") || name.StartsWith ("ntdll.dll!ntreplywaitreceiveport") || name.StartsWith ("ntdll.dll!zwrequestwaitreplyport") || name.StartsWith ("ntdll.dll!ntrequestwaitreplyport") || name.StartsWith ("ntdll.dll!zwalpcsendwaitreceiveport") || name.StartsWith ("ntdll.dll!ntalpcsendwaitreceiveport")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a LPC port:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!ntsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!zwsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!ntsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaithigheventpair") || name.StartsWith ("ntdll.dll!ntwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaitloweventpair") || name.StartsWith ("ntdll.dll!ntwaitloweventpair")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	// Use the KiFastSystemCallRet args if the handle we have is wrong.  	if (handle.ToInt32 () % 2 != 0)  		handle = lastParams [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for an event pair:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("user32.dll!ntusergetmessage") || name.StartsWith ("user32.dll!ntuserwaitmessage")) {  	found = true;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a USER message.");  }  else if (name.StartsWith ("ntdll.dll!zwwaitfordebugevent") || name.StartsWith ("ntdll.dll!ntwaitfordebugevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a debug event:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforkeyedevent") || name.StartsWith ("ntdll.dll!ntwaitforkeyedevent") || name.StartsWith ("ntdll.dll!zwreleasekeyedevent") || name.StartsWith ("ntdll.dll!ntreleasekeyedevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	IntPtr key = stackFrame.Params [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for a keyed event (key 0x" + key.ToString ("x") + "):");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitformultipleobjects") || name.StartsWith ("ntdll.dll!ntwaitformultipleobjects") || name.StartsWith ("kernel32.dll!waitformultipleobjects")) {  	found = true;  	int handleCount = stackFrame.Params [0].ToInt32 ();  	IntPtr handleAddress = stackFrame.Params [1];  	WaitType waitType = (WaitType)stackFrame.Params [2].ToInt32 ();  	bool alertable = stackFrame.Params [3].ToInt32 () != 0;  	// use the KiFastSystemCallRet args if we have the wrong args  	if (handleCount > 64) {  		handleCount = lastParams [1].ToInt32 ();  		handleAddress = lastParams [2];  		waitType = (WaitType)lastParams [3].ToInt32 ();  	}  	IntPtr* handles = stackalloc IntPtr[handleCount];  	phandle.ReadMemory (handleAddress' handles' handleCount * IntPtr.Size);  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + "' wait type: " + waitType.ToString () + ") for:");  	for (int i = 0; i < handleCount; i++) {  		sb.AppendLine (this.GetHandleString (_pid' handles [i]));  	}  }  else if (name.StartsWith ("ntdll.dll!zwwaitforsingleobject") || name.StartsWith ("ntdll.dll!ntwaitforsingleobject") || name.StartsWith ("kernel32.dll!waitforsingleobject")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	bool alertable = stackFrame.Params [1].ToInt32 () != 0;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + ") for:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforworkviaworkerfactory") || name.StartsWith ("ntdll.dll!ntwaitforworkviaworkerfactory")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for work from a worker factory:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,analyzeWaitMenuItem_Click,The following statement contains a magic number: if (name.StartsWith ("ntdll.dll!zwdelayexecution") || name.StartsWith ("ntdll.dll!ntdelayexecution")) {  	found = true;  	bool alertable = stackFrame.Params [0].ToInt32 () != 0;  	IntPtr timeoutAddress = stackFrame.Params [1];  	long timeout;  	phandle.ReadMemory (timeoutAddress' &timeout' sizeof(long));  	if (timeout < 0) {  		sb.Append ("Thread is sleeping. Timeout: " + (new TimeSpan (-timeout)).TotalMilliseconds.ToString () + " milliseconds");  	}  	else {  		sb.AppendLine ("Thread is sleeping. Timeout: " + (new DateTime (timeout)).ToString ());  	}  }  else if (name.StartsWith ("ntdll.dll!zwdeviceiocontrolfile") || name.StartsWith ("ntdll.dll!ntdeviceiocontrolfile")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an I/O control request:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!ntfscontrolfile") || name.StartsWith ("ntdll.dll!zwfscontrolfile")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an FS control request:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!ntqueryobject") || name.StartsWith ("ntdll.dll!zwqueryobject")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	// Use the KiFastSystemCallRet args if the handle we have is wrong.  	if (handle.ToInt32 () % 2 != 0 || handle == IntPtr.Zero)  		handle = lastParams [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is querying an object (most likely a named pipe):");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwreadfile") || name.StartsWith ("ntdll.dll!ntreadfile") || name.StartsWith ("ntdll.dll!zwwritefile") || name.StartsWith ("ntdll.dll!ntwritefile")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a named pipe or a file:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwremoveiocompletion") || name.StartsWith ("ntdll.dll!ntremoveiocompletion")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an I/O completion object:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwreplywaitreceiveport") || name.StartsWith ("ntdll.dll!ntreplywaitreceiveport") || name.StartsWith ("ntdll.dll!zwrequestwaitreplyport") || name.StartsWith ("ntdll.dll!ntrequestwaitreplyport") || name.StartsWith ("ntdll.dll!zwalpcsendwaitreceiveport") || name.StartsWith ("ntdll.dll!ntalpcsendwaitreceiveport")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a LPC port:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!ntsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!zwsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!ntsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaithigheventpair") || name.StartsWith ("ntdll.dll!ntwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaitloweventpair") || name.StartsWith ("ntdll.dll!ntwaitloweventpair")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	// Use the KiFastSystemCallRet args if the handle we have is wrong.  	if (handle.ToInt32 () % 2 != 0)  		handle = lastParams [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for an event pair:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("user32.dll!ntusergetmessage") || name.StartsWith ("user32.dll!ntuserwaitmessage")) {  	found = true;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a USER message.");  }  else if (name.StartsWith ("ntdll.dll!zwwaitfordebugevent") || name.StartsWith ("ntdll.dll!ntwaitfordebugevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a debug event:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforkeyedevent") || name.StartsWith ("ntdll.dll!ntwaitforkeyedevent") || name.StartsWith ("ntdll.dll!zwreleasekeyedevent") || name.StartsWith ("ntdll.dll!ntreleasekeyedevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	IntPtr key = stackFrame.Params [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for a keyed event (key 0x" + key.ToString ("x") + "):");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitformultipleobjects") || name.StartsWith ("ntdll.dll!ntwaitformultipleobjects") || name.StartsWith ("kernel32.dll!waitformultipleobjects")) {  	found = true;  	int handleCount = stackFrame.Params [0].ToInt32 ();  	IntPtr handleAddress = stackFrame.Params [1];  	WaitType waitType = (WaitType)stackFrame.Params [2].ToInt32 ();  	bool alertable = stackFrame.Params [3].ToInt32 () != 0;  	// use the KiFastSystemCallRet args if we have the wrong args  	if (handleCount > 64) {  		handleCount = lastParams [1].ToInt32 ();  		handleAddress = lastParams [2];  		waitType = (WaitType)lastParams [3].ToInt32 ();  	}  	IntPtr* handles = stackalloc IntPtr[handleCount];  	phandle.ReadMemory (handleAddress' handles' handleCount * IntPtr.Size);  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + "' wait type: " + waitType.ToString () + ") for:");  	for (int i = 0; i < handleCount; i++) {  		sb.AppendLine (this.GetHandleString (_pid' handles [i]));  	}  }  else if (name.StartsWith ("ntdll.dll!zwwaitforsingleobject") || name.StartsWith ("ntdll.dll!ntwaitforsingleobject") || name.StartsWith ("kernel32.dll!waitforsingleobject")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	bool alertable = stackFrame.Params [1].ToInt32 () != 0;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + ") for:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforworkviaworkerfactory") || name.StartsWith ("ntdll.dll!ntwaitforworkviaworkerfactory")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for work from a worker factory:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,analyzeWaitMenuItem_Click,The following statement contains a magic number: if (name.StartsWith ("ntdll.dll!zwdelayexecution") || name.StartsWith ("ntdll.dll!ntdelayexecution")) {  	found = true;  	bool alertable = stackFrame.Params [0].ToInt32 () != 0;  	IntPtr timeoutAddress = stackFrame.Params [1];  	long timeout;  	phandle.ReadMemory (timeoutAddress' &timeout' sizeof(long));  	if (timeout < 0) {  		sb.Append ("Thread is sleeping. Timeout: " + (new TimeSpan (-timeout)).TotalMilliseconds.ToString () + " milliseconds");  	}  	else {  		sb.AppendLine ("Thread is sleeping. Timeout: " + (new DateTime (timeout)).ToString ());  	}  }  else if (name.StartsWith ("ntdll.dll!zwdeviceiocontrolfile") || name.StartsWith ("ntdll.dll!ntdeviceiocontrolfile")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an I/O control request:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!ntfscontrolfile") || name.StartsWith ("ntdll.dll!zwfscontrolfile")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an FS control request:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!ntqueryobject") || name.StartsWith ("ntdll.dll!zwqueryobject")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	// Use the KiFastSystemCallRet args if the handle we have is wrong.  	if (handle.ToInt32 () % 2 != 0 || handle == IntPtr.Zero)  		handle = lastParams [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is querying an object (most likely a named pipe):");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwreadfile") || name.StartsWith ("ntdll.dll!ntreadfile") || name.StartsWith ("ntdll.dll!zwwritefile") || name.StartsWith ("ntdll.dll!ntwritefile")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a named pipe or a file:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwremoveiocompletion") || name.StartsWith ("ntdll.dll!ntremoveiocompletion")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an I/O completion object:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwreplywaitreceiveport") || name.StartsWith ("ntdll.dll!ntreplywaitreceiveport") || name.StartsWith ("ntdll.dll!zwrequestwaitreplyport") || name.StartsWith ("ntdll.dll!ntrequestwaitreplyport") || name.StartsWith ("ntdll.dll!zwalpcsendwaitreceiveport") || name.StartsWith ("ntdll.dll!ntalpcsendwaitreceiveport")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a LPC port:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!ntsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!zwsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!ntsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaithigheventpair") || name.StartsWith ("ntdll.dll!ntwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaitloweventpair") || name.StartsWith ("ntdll.dll!ntwaitloweventpair")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	// Use the KiFastSystemCallRet args if the handle we have is wrong.  	if (handle.ToInt32 () % 2 != 0)  		handle = lastParams [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for an event pair:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("user32.dll!ntusergetmessage") || name.StartsWith ("user32.dll!ntuserwaitmessage")) {  	found = true;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a USER message.");  }  else if (name.StartsWith ("ntdll.dll!zwwaitfordebugevent") || name.StartsWith ("ntdll.dll!ntwaitfordebugevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a debug event:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforkeyedevent") || name.StartsWith ("ntdll.dll!ntwaitforkeyedevent") || name.StartsWith ("ntdll.dll!zwreleasekeyedevent") || name.StartsWith ("ntdll.dll!ntreleasekeyedevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	IntPtr key = stackFrame.Params [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for a keyed event (key 0x" + key.ToString ("x") + "):");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitformultipleobjects") || name.StartsWith ("ntdll.dll!ntwaitformultipleobjects") || name.StartsWith ("kernel32.dll!waitformultipleobjects")) {  	found = true;  	int handleCount = stackFrame.Params [0].ToInt32 ();  	IntPtr handleAddress = stackFrame.Params [1];  	WaitType waitType = (WaitType)stackFrame.Params [2].ToInt32 ();  	bool alertable = stackFrame.Params [3].ToInt32 () != 0;  	// use the KiFastSystemCallRet args if we have the wrong args  	if (handleCount > 64) {  		handleCount = lastParams [1].ToInt32 ();  		handleAddress = lastParams [2];  		waitType = (WaitType)lastParams [3].ToInt32 ();  	}  	IntPtr* handles = stackalloc IntPtr[handleCount];  	phandle.ReadMemory (handleAddress' handles' handleCount * IntPtr.Size);  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + "' wait type: " + waitType.ToString () + ") for:");  	for (int i = 0; i < handleCount; i++) {  		sb.AppendLine (this.GetHandleString (_pid' handles [i]));  	}  }  else if (name.StartsWith ("ntdll.dll!zwwaitforsingleobject") || name.StartsWith ("ntdll.dll!ntwaitforsingleobject") || name.StartsWith ("kernel32.dll!waitforsingleobject")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	bool alertable = stackFrame.Params [1].ToInt32 () != 0;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + ") for:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforworkviaworkerfactory") || name.StartsWith ("ntdll.dll!ntwaitforworkviaworkerfactory")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for work from a worker factory:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,analyzeWaitMenuItem_Click,The following statement contains a magic number: if (name.StartsWith ("ntdll.dll!zwdelayexecution") || name.StartsWith ("ntdll.dll!ntdelayexecution")) {  	found = true;  	bool alertable = stackFrame.Params [0].ToInt32 () != 0;  	IntPtr timeoutAddress = stackFrame.Params [1];  	long timeout;  	phandle.ReadMemory (timeoutAddress' &timeout' sizeof(long));  	if (timeout < 0) {  		sb.Append ("Thread is sleeping. Timeout: " + (new TimeSpan (-timeout)).TotalMilliseconds.ToString () + " milliseconds");  	}  	else {  		sb.AppendLine ("Thread is sleeping. Timeout: " + (new DateTime (timeout)).ToString ());  	}  }  else if (name.StartsWith ("ntdll.dll!zwdeviceiocontrolfile") || name.StartsWith ("ntdll.dll!ntdeviceiocontrolfile")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an I/O control request:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!ntfscontrolfile") || name.StartsWith ("ntdll.dll!zwfscontrolfile")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an FS control request:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!ntqueryobject") || name.StartsWith ("ntdll.dll!zwqueryobject")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	// Use the KiFastSystemCallRet args if the handle we have is wrong.  	if (handle.ToInt32 () % 2 != 0 || handle == IntPtr.Zero)  		handle = lastParams [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is querying an object (most likely a named pipe):");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwreadfile") || name.StartsWith ("ntdll.dll!ntreadfile") || name.StartsWith ("ntdll.dll!zwwritefile") || name.StartsWith ("ntdll.dll!ntwritefile")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a named pipe or a file:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwremoveiocompletion") || name.StartsWith ("ntdll.dll!ntremoveiocompletion")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an I/O completion object:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwreplywaitreceiveport") || name.StartsWith ("ntdll.dll!ntreplywaitreceiveport") || name.StartsWith ("ntdll.dll!zwrequestwaitreplyport") || name.StartsWith ("ntdll.dll!ntrequestwaitreplyport") || name.StartsWith ("ntdll.dll!zwalpcsendwaitreceiveport") || name.StartsWith ("ntdll.dll!ntalpcsendwaitreceiveport")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a LPC port:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!ntsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!zwsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!ntsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaithigheventpair") || name.StartsWith ("ntdll.dll!ntwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaitloweventpair") || name.StartsWith ("ntdll.dll!ntwaitloweventpair")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	// Use the KiFastSystemCallRet args if the handle we have is wrong.  	if (handle.ToInt32 () % 2 != 0)  		handle = lastParams [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for an event pair:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("user32.dll!ntusergetmessage") || name.StartsWith ("user32.dll!ntuserwaitmessage")) {  	found = true;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a USER message.");  }  else if (name.StartsWith ("ntdll.dll!zwwaitfordebugevent") || name.StartsWith ("ntdll.dll!ntwaitfordebugevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a debug event:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforkeyedevent") || name.StartsWith ("ntdll.dll!ntwaitforkeyedevent") || name.StartsWith ("ntdll.dll!zwreleasekeyedevent") || name.StartsWith ("ntdll.dll!ntreleasekeyedevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	IntPtr key = stackFrame.Params [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for a keyed event (key 0x" + key.ToString ("x") + "):");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitformultipleobjects") || name.StartsWith ("ntdll.dll!ntwaitformultipleobjects") || name.StartsWith ("kernel32.dll!waitformultipleobjects")) {  	found = true;  	int handleCount = stackFrame.Params [0].ToInt32 ();  	IntPtr handleAddress = stackFrame.Params [1];  	WaitType waitType = (WaitType)stackFrame.Params [2].ToInt32 ();  	bool alertable = stackFrame.Params [3].ToInt32 () != 0;  	// use the KiFastSystemCallRet args if we have the wrong args  	if (handleCount > 64) {  		handleCount = lastParams [1].ToInt32 ();  		handleAddress = lastParams [2];  		waitType = (WaitType)lastParams [3].ToInt32 ();  	}  	IntPtr* handles = stackalloc IntPtr[handleCount];  	phandle.ReadMemory (handleAddress' handles' handleCount * IntPtr.Size);  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + "' wait type: " + waitType.ToString () + ") for:");  	for (int i = 0; i < handleCount; i++) {  		sb.AppendLine (this.GetHandleString (_pid' handles [i]));  	}  }  else if (name.StartsWith ("ntdll.dll!zwwaitforsingleobject") || name.StartsWith ("ntdll.dll!ntwaitforsingleobject") || name.StartsWith ("kernel32.dll!waitforsingleobject")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	bool alertable = stackFrame.Params [1].ToInt32 () != 0;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + ") for:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforworkviaworkerfactory") || name.StartsWith ("ntdll.dll!ntwaitforworkviaworkerfactory")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for work from a worker factory:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,analyzeWaitMenuItem_Click,The following statement contains a magic number: if (name.StartsWith ("ntdll.dll!zwdelayexecution") || name.StartsWith ("ntdll.dll!ntdelayexecution")) {  	found = true;  	bool alertable = stackFrame.Params [0].ToInt32 () != 0;  	IntPtr timeoutAddress = stackFrame.Params [1];  	long timeout;  	phandle.ReadMemory (timeoutAddress' &timeout' sizeof(long));  	if (timeout < 0) {  		sb.Append ("Thread is sleeping. Timeout: " + (new TimeSpan (-timeout)).TotalMilliseconds.ToString () + " milliseconds");  	}  	else {  		sb.AppendLine ("Thread is sleeping. Timeout: " + (new DateTime (timeout)).ToString ());  	}  }  else if (name.StartsWith ("ntdll.dll!zwdeviceiocontrolfile") || name.StartsWith ("ntdll.dll!ntdeviceiocontrolfile")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an I/O control request:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!ntfscontrolfile") || name.StartsWith ("ntdll.dll!zwfscontrolfile")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an FS control request:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!ntqueryobject") || name.StartsWith ("ntdll.dll!zwqueryobject")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	// Use the KiFastSystemCallRet args if the handle we have is wrong.  	if (handle.ToInt32 () % 2 != 0 || handle == IntPtr.Zero)  		handle = lastParams [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is querying an object (most likely a named pipe):");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwreadfile") || name.StartsWith ("ntdll.dll!ntreadfile") || name.StartsWith ("ntdll.dll!zwwritefile") || name.StartsWith ("ntdll.dll!ntwritefile")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a named pipe or a file:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwremoveiocompletion") || name.StartsWith ("ntdll.dll!ntremoveiocompletion")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an I/O completion object:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwreplywaitreceiveport") || name.StartsWith ("ntdll.dll!ntreplywaitreceiveport") || name.StartsWith ("ntdll.dll!zwrequestwaitreplyport") || name.StartsWith ("ntdll.dll!ntrequestwaitreplyport") || name.StartsWith ("ntdll.dll!zwalpcsendwaitreceiveport") || name.StartsWith ("ntdll.dll!ntalpcsendwaitreceiveport")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a LPC port:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!ntsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!zwsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!ntsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaithigheventpair") || name.StartsWith ("ntdll.dll!ntwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaitloweventpair") || name.StartsWith ("ntdll.dll!ntwaitloweventpair")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	// Use the KiFastSystemCallRet args if the handle we have is wrong.  	if (handle.ToInt32 () % 2 != 0)  		handle = lastParams [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for an event pair:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("user32.dll!ntusergetmessage") || name.StartsWith ("user32.dll!ntuserwaitmessage")) {  	found = true;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a USER message.");  }  else if (name.StartsWith ("ntdll.dll!zwwaitfordebugevent") || name.StartsWith ("ntdll.dll!ntwaitfordebugevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a debug event:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforkeyedevent") || name.StartsWith ("ntdll.dll!ntwaitforkeyedevent") || name.StartsWith ("ntdll.dll!zwreleasekeyedevent") || name.StartsWith ("ntdll.dll!ntreleasekeyedevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	IntPtr key = stackFrame.Params [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for a keyed event (key 0x" + key.ToString ("x") + "):");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitformultipleobjects") || name.StartsWith ("ntdll.dll!ntwaitformultipleobjects") || name.StartsWith ("kernel32.dll!waitformultipleobjects")) {  	found = true;  	int handleCount = stackFrame.Params [0].ToInt32 ();  	IntPtr handleAddress = stackFrame.Params [1];  	WaitType waitType = (WaitType)stackFrame.Params [2].ToInt32 ();  	bool alertable = stackFrame.Params [3].ToInt32 () != 0;  	// use the KiFastSystemCallRet args if we have the wrong args  	if (handleCount > 64) {  		handleCount = lastParams [1].ToInt32 ();  		handleAddress = lastParams [2];  		waitType = (WaitType)lastParams [3].ToInt32 ();  	}  	IntPtr* handles = stackalloc IntPtr[handleCount];  	phandle.ReadMemory (handleAddress' handles' handleCount * IntPtr.Size);  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + "' wait type: " + waitType.ToString () + ") for:");  	for (int i = 0; i < handleCount; i++) {  		sb.AppendLine (this.GetHandleString (_pid' handles [i]));  	}  }  else if (name.StartsWith ("ntdll.dll!zwwaitforsingleobject") || name.StartsWith ("ntdll.dll!ntwaitforsingleobject") || name.StartsWith ("kernel32.dll!waitforsingleobject")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	bool alertable = stackFrame.Params [1].ToInt32 () != 0;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + ") for:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforworkviaworkerfactory") || name.StartsWith ("ntdll.dll!ntwaitforworkviaworkerfactory")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for work from a worker factory:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,analyzeWaitMenuItem_Click,The following statement contains a magic number: if (name.StartsWith ("ntdll.dll!zwdelayexecution") || name.StartsWith ("ntdll.dll!ntdelayexecution")) {  	found = true;  	bool alertable = stackFrame.Params [0].ToInt32 () != 0;  	IntPtr timeoutAddress = stackFrame.Params [1];  	long timeout;  	phandle.ReadMemory (timeoutAddress' &timeout' sizeof(long));  	if (timeout < 0) {  		sb.Append ("Thread is sleeping. Timeout: " + (new TimeSpan (-timeout)).TotalMilliseconds.ToString () + " milliseconds");  	}  	else {  		sb.AppendLine ("Thread is sleeping. Timeout: " + (new DateTime (timeout)).ToString ());  	}  }  else if (name.StartsWith ("ntdll.dll!zwdeviceiocontrolfile") || name.StartsWith ("ntdll.dll!ntdeviceiocontrolfile")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an I/O control request:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!ntfscontrolfile") || name.StartsWith ("ntdll.dll!zwfscontrolfile")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an FS control request:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!ntqueryobject") || name.StartsWith ("ntdll.dll!zwqueryobject")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	// Use the KiFastSystemCallRet args if the handle we have is wrong.  	if (handle.ToInt32 () % 2 != 0 || handle == IntPtr.Zero)  		handle = lastParams [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is querying an object (most likely a named pipe):");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwreadfile") || name.StartsWith ("ntdll.dll!ntreadfile") || name.StartsWith ("ntdll.dll!zwwritefile") || name.StartsWith ("ntdll.dll!ntwritefile")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a named pipe or a file:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwremoveiocompletion") || name.StartsWith ("ntdll.dll!ntremoveiocompletion")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an I/O completion object:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwreplywaitreceiveport") || name.StartsWith ("ntdll.dll!ntreplywaitreceiveport") || name.StartsWith ("ntdll.dll!zwrequestwaitreplyport") || name.StartsWith ("ntdll.dll!ntrequestwaitreplyport") || name.StartsWith ("ntdll.dll!zwalpcsendwaitreceiveport") || name.StartsWith ("ntdll.dll!ntalpcsendwaitreceiveport")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a LPC port:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!ntsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!zwsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!ntsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaithigheventpair") || name.StartsWith ("ntdll.dll!ntwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaitloweventpair") || name.StartsWith ("ntdll.dll!ntwaitloweventpair")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	// Use the KiFastSystemCallRet args if the handle we have is wrong.  	if (handle.ToInt32 () % 2 != 0)  		handle = lastParams [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for an event pair:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("user32.dll!ntusergetmessage") || name.StartsWith ("user32.dll!ntuserwaitmessage")) {  	found = true;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a USER message.");  }  else if (name.StartsWith ("ntdll.dll!zwwaitfordebugevent") || name.StartsWith ("ntdll.dll!ntwaitfordebugevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a debug event:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforkeyedevent") || name.StartsWith ("ntdll.dll!ntwaitforkeyedevent") || name.StartsWith ("ntdll.dll!zwreleasekeyedevent") || name.StartsWith ("ntdll.dll!ntreleasekeyedevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	IntPtr key = stackFrame.Params [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for a keyed event (key 0x" + key.ToString ("x") + "):");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitformultipleobjects") || name.StartsWith ("ntdll.dll!ntwaitformultipleobjects") || name.StartsWith ("kernel32.dll!waitformultipleobjects")) {  	found = true;  	int handleCount = stackFrame.Params [0].ToInt32 ();  	IntPtr handleAddress = stackFrame.Params [1];  	WaitType waitType = (WaitType)stackFrame.Params [2].ToInt32 ();  	bool alertable = stackFrame.Params [3].ToInt32 () != 0;  	// use the KiFastSystemCallRet args if we have the wrong args  	if (handleCount > 64) {  		handleCount = lastParams [1].ToInt32 ();  		handleAddress = lastParams [2];  		waitType = (WaitType)lastParams [3].ToInt32 ();  	}  	IntPtr* handles = stackalloc IntPtr[handleCount];  	phandle.ReadMemory (handleAddress' handles' handleCount * IntPtr.Size);  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + "' wait type: " + waitType.ToString () + ") for:");  	for (int i = 0; i < handleCount; i++) {  		sb.AppendLine (this.GetHandleString (_pid' handles [i]));  	}  }  else if (name.StartsWith ("ntdll.dll!zwwaitforsingleobject") || name.StartsWith ("ntdll.dll!ntwaitforsingleobject") || name.StartsWith ("kernel32.dll!waitforsingleobject")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	bool alertable = stackFrame.Params [1].ToInt32 () != 0;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + ") for:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforworkviaworkerfactory") || name.StartsWith ("ntdll.dll!ntwaitforworkviaworkerfactory")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for work from a worker factory:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,analyzeWaitMenuItem_Click,The following statement contains a magic number: if (name.StartsWith ("ntdll.dll!zwdelayexecution") || name.StartsWith ("ntdll.dll!ntdelayexecution")) {  	found = true;  	bool alertable = stackFrame.Params [0].ToInt32 () != 0;  	IntPtr timeoutAddress = stackFrame.Params [1];  	long timeout;  	phandle.ReadMemory (timeoutAddress' &timeout' sizeof(long));  	if (timeout < 0) {  		sb.Append ("Thread is sleeping. Timeout: " + (new TimeSpan (-timeout)).TotalMilliseconds.ToString () + " milliseconds");  	}  	else {  		sb.AppendLine ("Thread is sleeping. Timeout: " + (new DateTime (timeout)).ToString ());  	}  }  else if (name.StartsWith ("ntdll.dll!zwdeviceiocontrolfile") || name.StartsWith ("ntdll.dll!ntdeviceiocontrolfile")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an I/O control request:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!ntfscontrolfile") || name.StartsWith ("ntdll.dll!zwfscontrolfile")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an FS control request:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!ntqueryobject") || name.StartsWith ("ntdll.dll!zwqueryobject")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	// Use the KiFastSystemCallRet args if the handle we have is wrong.  	if (handle.ToInt32 () % 2 != 0 || handle == IntPtr.Zero)  		handle = lastParams [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is querying an object (most likely a named pipe):");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwreadfile") || name.StartsWith ("ntdll.dll!ntreadfile") || name.StartsWith ("ntdll.dll!zwwritefile") || name.StartsWith ("ntdll.dll!ntwritefile")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a named pipe or a file:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwremoveiocompletion") || name.StartsWith ("ntdll.dll!ntremoveiocompletion")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an I/O completion object:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwreplywaitreceiveport") || name.StartsWith ("ntdll.dll!ntreplywaitreceiveport") || name.StartsWith ("ntdll.dll!zwrequestwaitreplyport") || name.StartsWith ("ntdll.dll!ntrequestwaitreplyport") || name.StartsWith ("ntdll.dll!zwalpcsendwaitreceiveport") || name.StartsWith ("ntdll.dll!ntalpcsendwaitreceiveport")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a LPC port:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!ntsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!zwsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!ntsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaithigheventpair") || name.StartsWith ("ntdll.dll!ntwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaitloweventpair") || name.StartsWith ("ntdll.dll!ntwaitloweventpair")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	// Use the KiFastSystemCallRet args if the handle we have is wrong.  	if (handle.ToInt32 () % 2 != 0)  		handle = lastParams [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for an event pair:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("user32.dll!ntusergetmessage") || name.StartsWith ("user32.dll!ntuserwaitmessage")) {  	found = true;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a USER message.");  }  else if (name.StartsWith ("ntdll.dll!zwwaitfordebugevent") || name.StartsWith ("ntdll.dll!ntwaitfordebugevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a debug event:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforkeyedevent") || name.StartsWith ("ntdll.dll!ntwaitforkeyedevent") || name.StartsWith ("ntdll.dll!zwreleasekeyedevent") || name.StartsWith ("ntdll.dll!ntreleasekeyedevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	IntPtr key = stackFrame.Params [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for a keyed event (key 0x" + key.ToString ("x") + "):");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitformultipleobjects") || name.StartsWith ("ntdll.dll!ntwaitformultipleobjects") || name.StartsWith ("kernel32.dll!waitformultipleobjects")) {  	found = true;  	int handleCount = stackFrame.Params [0].ToInt32 ();  	IntPtr handleAddress = stackFrame.Params [1];  	WaitType waitType = (WaitType)stackFrame.Params [2].ToInt32 ();  	bool alertable = stackFrame.Params [3].ToInt32 () != 0;  	// use the KiFastSystemCallRet args if we have the wrong args  	if (handleCount > 64) {  		handleCount = lastParams [1].ToInt32 ();  		handleAddress = lastParams [2];  		waitType = (WaitType)lastParams [3].ToInt32 ();  	}  	IntPtr* handles = stackalloc IntPtr[handleCount];  	phandle.ReadMemory (handleAddress' handles' handleCount * IntPtr.Size);  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + "' wait type: " + waitType.ToString () + ") for:");  	for (int i = 0; i < handleCount; i++) {  		sb.AppendLine (this.GetHandleString (_pid' handles [i]));  	}  }  else if (name.StartsWith ("ntdll.dll!zwwaitforsingleobject") || name.StartsWith ("ntdll.dll!ntwaitforsingleobject") || name.StartsWith ("kernel32.dll!waitforsingleobject")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	bool alertable = stackFrame.Params [1].ToInt32 () != 0;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + ") for:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforworkviaworkerfactory") || name.StartsWith ("ntdll.dll!ntwaitforworkviaworkerfactory")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for work from a worker factory:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,analyzeWaitMenuItem_Click,The following statement contains a magic number: if (name.StartsWith ("ntdll.dll!zwdeviceiocontrolfile") || name.StartsWith ("ntdll.dll!ntdeviceiocontrolfile")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an I/O control request:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!ntfscontrolfile") || name.StartsWith ("ntdll.dll!zwfscontrolfile")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an FS control request:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!ntqueryobject") || name.StartsWith ("ntdll.dll!zwqueryobject")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	// Use the KiFastSystemCallRet args if the handle we have is wrong.  	if (handle.ToInt32 () % 2 != 0 || handle == IntPtr.Zero)  		handle = lastParams [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is querying an object (most likely a named pipe):");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwreadfile") || name.StartsWith ("ntdll.dll!ntreadfile") || name.StartsWith ("ntdll.dll!zwwritefile") || name.StartsWith ("ntdll.dll!ntwritefile")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a named pipe or a file:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwremoveiocompletion") || name.StartsWith ("ntdll.dll!ntremoveiocompletion")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an I/O completion object:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwreplywaitreceiveport") || name.StartsWith ("ntdll.dll!ntreplywaitreceiveport") || name.StartsWith ("ntdll.dll!zwrequestwaitreplyport") || name.StartsWith ("ntdll.dll!ntrequestwaitreplyport") || name.StartsWith ("ntdll.dll!zwalpcsendwaitreceiveport") || name.StartsWith ("ntdll.dll!ntalpcsendwaitreceiveport")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a LPC port:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!ntsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!zwsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!ntsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaithigheventpair") || name.StartsWith ("ntdll.dll!ntwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaitloweventpair") || name.StartsWith ("ntdll.dll!ntwaitloweventpair")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	// Use the KiFastSystemCallRet args if the handle we have is wrong.  	if (handle.ToInt32 () % 2 != 0)  		handle = lastParams [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for an event pair:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("user32.dll!ntusergetmessage") || name.StartsWith ("user32.dll!ntuserwaitmessage")) {  	found = true;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a USER message.");  }  else if (name.StartsWith ("ntdll.dll!zwwaitfordebugevent") || name.StartsWith ("ntdll.dll!ntwaitfordebugevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a debug event:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforkeyedevent") || name.StartsWith ("ntdll.dll!ntwaitforkeyedevent") || name.StartsWith ("ntdll.dll!zwreleasekeyedevent") || name.StartsWith ("ntdll.dll!ntreleasekeyedevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	IntPtr key = stackFrame.Params [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for a keyed event (key 0x" + key.ToString ("x") + "):");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitformultipleobjects") || name.StartsWith ("ntdll.dll!ntwaitformultipleobjects") || name.StartsWith ("kernel32.dll!waitformultipleobjects")) {  	found = true;  	int handleCount = stackFrame.Params [0].ToInt32 ();  	IntPtr handleAddress = stackFrame.Params [1];  	WaitType waitType = (WaitType)stackFrame.Params [2].ToInt32 ();  	bool alertable = stackFrame.Params [3].ToInt32 () != 0;  	// use the KiFastSystemCallRet args if we have the wrong args  	if (handleCount > 64) {  		handleCount = lastParams [1].ToInt32 ();  		handleAddress = lastParams [2];  		waitType = (WaitType)lastParams [3].ToInt32 ();  	}  	IntPtr* handles = stackalloc IntPtr[handleCount];  	phandle.ReadMemory (handleAddress' handles' handleCount * IntPtr.Size);  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + "' wait type: " + waitType.ToString () + ") for:");  	for (int i = 0; i < handleCount; i++) {  		sb.AppendLine (this.GetHandleString (_pid' handles [i]));  	}  }  else if (name.StartsWith ("ntdll.dll!zwwaitforsingleobject") || name.StartsWith ("ntdll.dll!ntwaitforsingleobject") || name.StartsWith ("kernel32.dll!waitforsingleobject")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	bool alertable = stackFrame.Params [1].ToInt32 () != 0;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + ") for:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforworkviaworkerfactory") || name.StartsWith ("ntdll.dll!ntwaitforworkviaworkerfactory")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for work from a worker factory:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,analyzeWaitMenuItem_Click,The following statement contains a magic number: if (name.StartsWith ("ntdll.dll!zwdeviceiocontrolfile") || name.StartsWith ("ntdll.dll!ntdeviceiocontrolfile")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an I/O control request:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!ntfscontrolfile") || name.StartsWith ("ntdll.dll!zwfscontrolfile")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an FS control request:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!ntqueryobject") || name.StartsWith ("ntdll.dll!zwqueryobject")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	// Use the KiFastSystemCallRet args if the handle we have is wrong.  	if (handle.ToInt32 () % 2 != 0 || handle == IntPtr.Zero)  		handle = lastParams [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is querying an object (most likely a named pipe):");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwreadfile") || name.StartsWith ("ntdll.dll!ntreadfile") || name.StartsWith ("ntdll.dll!zwwritefile") || name.StartsWith ("ntdll.dll!ntwritefile")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a named pipe or a file:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwremoveiocompletion") || name.StartsWith ("ntdll.dll!ntremoveiocompletion")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an I/O completion object:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwreplywaitreceiveport") || name.StartsWith ("ntdll.dll!ntreplywaitreceiveport") || name.StartsWith ("ntdll.dll!zwrequestwaitreplyport") || name.StartsWith ("ntdll.dll!ntrequestwaitreplyport") || name.StartsWith ("ntdll.dll!zwalpcsendwaitreceiveport") || name.StartsWith ("ntdll.dll!ntalpcsendwaitreceiveport")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a LPC port:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!ntsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!zwsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!ntsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaithigheventpair") || name.StartsWith ("ntdll.dll!ntwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaitloweventpair") || name.StartsWith ("ntdll.dll!ntwaitloweventpair")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	// Use the KiFastSystemCallRet args if the handle we have is wrong.  	if (handle.ToInt32 () % 2 != 0)  		handle = lastParams [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for an event pair:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("user32.dll!ntusergetmessage") || name.StartsWith ("user32.dll!ntuserwaitmessage")) {  	found = true;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a USER message.");  }  else if (name.StartsWith ("ntdll.dll!zwwaitfordebugevent") || name.StartsWith ("ntdll.dll!ntwaitfordebugevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a debug event:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforkeyedevent") || name.StartsWith ("ntdll.dll!ntwaitforkeyedevent") || name.StartsWith ("ntdll.dll!zwreleasekeyedevent") || name.StartsWith ("ntdll.dll!ntreleasekeyedevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	IntPtr key = stackFrame.Params [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for a keyed event (key 0x" + key.ToString ("x") + "):");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitformultipleobjects") || name.StartsWith ("ntdll.dll!ntwaitformultipleobjects") || name.StartsWith ("kernel32.dll!waitformultipleobjects")) {  	found = true;  	int handleCount = stackFrame.Params [0].ToInt32 ();  	IntPtr handleAddress = stackFrame.Params [1];  	WaitType waitType = (WaitType)stackFrame.Params [2].ToInt32 ();  	bool alertable = stackFrame.Params [3].ToInt32 () != 0;  	// use the KiFastSystemCallRet args if we have the wrong args  	if (handleCount > 64) {  		handleCount = lastParams [1].ToInt32 ();  		handleAddress = lastParams [2];  		waitType = (WaitType)lastParams [3].ToInt32 ();  	}  	IntPtr* handles = stackalloc IntPtr[handleCount];  	phandle.ReadMemory (handleAddress' handles' handleCount * IntPtr.Size);  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + "' wait type: " + waitType.ToString () + ") for:");  	for (int i = 0; i < handleCount; i++) {  		sb.AppendLine (this.GetHandleString (_pid' handles [i]));  	}  }  else if (name.StartsWith ("ntdll.dll!zwwaitforsingleobject") || name.StartsWith ("ntdll.dll!ntwaitforsingleobject") || name.StartsWith ("kernel32.dll!waitforsingleobject")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	bool alertable = stackFrame.Params [1].ToInt32 () != 0;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + ") for:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforworkviaworkerfactory") || name.StartsWith ("ntdll.dll!ntwaitforworkviaworkerfactory")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for work from a worker factory:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,analyzeWaitMenuItem_Click,The following statement contains a magic number: if (name.StartsWith ("ntdll.dll!zwdeviceiocontrolfile") || name.StartsWith ("ntdll.dll!ntdeviceiocontrolfile")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an I/O control request:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!ntfscontrolfile") || name.StartsWith ("ntdll.dll!zwfscontrolfile")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an FS control request:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!ntqueryobject") || name.StartsWith ("ntdll.dll!zwqueryobject")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	// Use the KiFastSystemCallRet args if the handle we have is wrong.  	if (handle.ToInt32 () % 2 != 0 || handle == IntPtr.Zero)  		handle = lastParams [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is querying an object (most likely a named pipe):");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwreadfile") || name.StartsWith ("ntdll.dll!ntreadfile") || name.StartsWith ("ntdll.dll!zwwritefile") || name.StartsWith ("ntdll.dll!ntwritefile")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a named pipe or a file:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwremoveiocompletion") || name.StartsWith ("ntdll.dll!ntremoveiocompletion")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an I/O completion object:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwreplywaitreceiveport") || name.StartsWith ("ntdll.dll!ntreplywaitreceiveport") || name.StartsWith ("ntdll.dll!zwrequestwaitreplyport") || name.StartsWith ("ntdll.dll!ntrequestwaitreplyport") || name.StartsWith ("ntdll.dll!zwalpcsendwaitreceiveport") || name.StartsWith ("ntdll.dll!ntalpcsendwaitreceiveport")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a LPC port:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!ntsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!zwsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!ntsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaithigheventpair") || name.StartsWith ("ntdll.dll!ntwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaitloweventpair") || name.StartsWith ("ntdll.dll!ntwaitloweventpair")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	// Use the KiFastSystemCallRet args if the handle we have is wrong.  	if (handle.ToInt32 () % 2 != 0)  		handle = lastParams [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for an event pair:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("user32.dll!ntusergetmessage") || name.StartsWith ("user32.dll!ntuserwaitmessage")) {  	found = true;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a USER message.");  }  else if (name.StartsWith ("ntdll.dll!zwwaitfordebugevent") || name.StartsWith ("ntdll.dll!ntwaitfordebugevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a debug event:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforkeyedevent") || name.StartsWith ("ntdll.dll!ntwaitforkeyedevent") || name.StartsWith ("ntdll.dll!zwreleasekeyedevent") || name.StartsWith ("ntdll.dll!ntreleasekeyedevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	IntPtr key = stackFrame.Params [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for a keyed event (key 0x" + key.ToString ("x") + "):");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitformultipleobjects") || name.StartsWith ("ntdll.dll!ntwaitformultipleobjects") || name.StartsWith ("kernel32.dll!waitformultipleobjects")) {  	found = true;  	int handleCount = stackFrame.Params [0].ToInt32 ();  	IntPtr handleAddress = stackFrame.Params [1];  	WaitType waitType = (WaitType)stackFrame.Params [2].ToInt32 ();  	bool alertable = stackFrame.Params [3].ToInt32 () != 0;  	// use the KiFastSystemCallRet args if we have the wrong args  	if (handleCount > 64) {  		handleCount = lastParams [1].ToInt32 ();  		handleAddress = lastParams [2];  		waitType = (WaitType)lastParams [3].ToInt32 ();  	}  	IntPtr* handles = stackalloc IntPtr[handleCount];  	phandle.ReadMemory (handleAddress' handles' handleCount * IntPtr.Size);  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + "' wait type: " + waitType.ToString () + ") for:");  	for (int i = 0; i < handleCount; i++) {  		sb.AppendLine (this.GetHandleString (_pid' handles [i]));  	}  }  else if (name.StartsWith ("ntdll.dll!zwwaitforsingleobject") || name.StartsWith ("ntdll.dll!ntwaitforsingleobject") || name.StartsWith ("kernel32.dll!waitforsingleobject")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	bool alertable = stackFrame.Params [1].ToInt32 () != 0;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + ") for:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforworkviaworkerfactory") || name.StartsWith ("ntdll.dll!ntwaitforworkviaworkerfactory")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for work from a worker factory:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,analyzeWaitMenuItem_Click,The following statement contains a magic number: if (name.StartsWith ("ntdll.dll!zwdeviceiocontrolfile") || name.StartsWith ("ntdll.dll!ntdeviceiocontrolfile")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an I/O control request:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!ntfscontrolfile") || name.StartsWith ("ntdll.dll!zwfscontrolfile")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an FS control request:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!ntqueryobject") || name.StartsWith ("ntdll.dll!zwqueryobject")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	// Use the KiFastSystemCallRet args if the handle we have is wrong.  	if (handle.ToInt32 () % 2 != 0 || handle == IntPtr.Zero)  		handle = lastParams [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is querying an object (most likely a named pipe):");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwreadfile") || name.StartsWith ("ntdll.dll!ntreadfile") || name.StartsWith ("ntdll.dll!zwwritefile") || name.StartsWith ("ntdll.dll!ntwritefile")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a named pipe or a file:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwremoveiocompletion") || name.StartsWith ("ntdll.dll!ntremoveiocompletion")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an I/O completion object:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwreplywaitreceiveport") || name.StartsWith ("ntdll.dll!ntreplywaitreceiveport") || name.StartsWith ("ntdll.dll!zwrequestwaitreplyport") || name.StartsWith ("ntdll.dll!ntrequestwaitreplyport") || name.StartsWith ("ntdll.dll!zwalpcsendwaitreceiveport") || name.StartsWith ("ntdll.dll!ntalpcsendwaitreceiveport")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a LPC port:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!ntsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!zwsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!ntsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaithigheventpair") || name.StartsWith ("ntdll.dll!ntwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaitloweventpair") || name.StartsWith ("ntdll.dll!ntwaitloweventpair")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	// Use the KiFastSystemCallRet args if the handle we have is wrong.  	if (handle.ToInt32 () % 2 != 0)  		handle = lastParams [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for an event pair:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("user32.dll!ntusergetmessage") || name.StartsWith ("user32.dll!ntuserwaitmessage")) {  	found = true;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a USER message.");  }  else if (name.StartsWith ("ntdll.dll!zwwaitfordebugevent") || name.StartsWith ("ntdll.dll!ntwaitfordebugevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a debug event:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforkeyedevent") || name.StartsWith ("ntdll.dll!ntwaitforkeyedevent") || name.StartsWith ("ntdll.dll!zwreleasekeyedevent") || name.StartsWith ("ntdll.dll!ntreleasekeyedevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	IntPtr key = stackFrame.Params [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for a keyed event (key 0x" + key.ToString ("x") + "):");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitformultipleobjects") || name.StartsWith ("ntdll.dll!ntwaitformultipleobjects") || name.StartsWith ("kernel32.dll!waitformultipleobjects")) {  	found = true;  	int handleCount = stackFrame.Params [0].ToInt32 ();  	IntPtr handleAddress = stackFrame.Params [1];  	WaitType waitType = (WaitType)stackFrame.Params [2].ToInt32 ();  	bool alertable = stackFrame.Params [3].ToInt32 () != 0;  	// use the KiFastSystemCallRet args if we have the wrong args  	if (handleCount > 64) {  		handleCount = lastParams [1].ToInt32 ();  		handleAddress = lastParams [2];  		waitType = (WaitType)lastParams [3].ToInt32 ();  	}  	IntPtr* handles = stackalloc IntPtr[handleCount];  	phandle.ReadMemory (handleAddress' handles' handleCount * IntPtr.Size);  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + "' wait type: " + waitType.ToString () + ") for:");  	for (int i = 0; i < handleCount; i++) {  		sb.AppendLine (this.GetHandleString (_pid' handles [i]));  	}  }  else if (name.StartsWith ("ntdll.dll!zwwaitforsingleobject") || name.StartsWith ("ntdll.dll!ntwaitforsingleobject") || name.StartsWith ("kernel32.dll!waitforsingleobject")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	bool alertable = stackFrame.Params [1].ToInt32 () != 0;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + ") for:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforworkviaworkerfactory") || name.StartsWith ("ntdll.dll!ntwaitforworkviaworkerfactory")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for work from a worker factory:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,analyzeWaitMenuItem_Click,The following statement contains a magic number: if (name.StartsWith ("ntdll.dll!zwdeviceiocontrolfile") || name.StartsWith ("ntdll.dll!ntdeviceiocontrolfile")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an I/O control request:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!ntfscontrolfile") || name.StartsWith ("ntdll.dll!zwfscontrolfile")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an FS control request:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!ntqueryobject") || name.StartsWith ("ntdll.dll!zwqueryobject")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	// Use the KiFastSystemCallRet args if the handle we have is wrong.  	if (handle.ToInt32 () % 2 != 0 || handle == IntPtr.Zero)  		handle = lastParams [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is querying an object (most likely a named pipe):");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwreadfile") || name.StartsWith ("ntdll.dll!ntreadfile") || name.StartsWith ("ntdll.dll!zwwritefile") || name.StartsWith ("ntdll.dll!ntwritefile")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a named pipe or a file:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwremoveiocompletion") || name.StartsWith ("ntdll.dll!ntremoveiocompletion")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an I/O completion object:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwreplywaitreceiveport") || name.StartsWith ("ntdll.dll!ntreplywaitreceiveport") || name.StartsWith ("ntdll.dll!zwrequestwaitreplyport") || name.StartsWith ("ntdll.dll!ntrequestwaitreplyport") || name.StartsWith ("ntdll.dll!zwalpcsendwaitreceiveport") || name.StartsWith ("ntdll.dll!ntalpcsendwaitreceiveport")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a LPC port:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!ntsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!zwsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!ntsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaithigheventpair") || name.StartsWith ("ntdll.dll!ntwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaitloweventpair") || name.StartsWith ("ntdll.dll!ntwaitloweventpair")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	// Use the KiFastSystemCallRet args if the handle we have is wrong.  	if (handle.ToInt32 () % 2 != 0)  		handle = lastParams [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for an event pair:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("user32.dll!ntusergetmessage") || name.StartsWith ("user32.dll!ntuserwaitmessage")) {  	found = true;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a USER message.");  }  else if (name.StartsWith ("ntdll.dll!zwwaitfordebugevent") || name.StartsWith ("ntdll.dll!ntwaitfordebugevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a debug event:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforkeyedevent") || name.StartsWith ("ntdll.dll!ntwaitforkeyedevent") || name.StartsWith ("ntdll.dll!zwreleasekeyedevent") || name.StartsWith ("ntdll.dll!ntreleasekeyedevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	IntPtr key = stackFrame.Params [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for a keyed event (key 0x" + key.ToString ("x") + "):");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitformultipleobjects") || name.StartsWith ("ntdll.dll!ntwaitformultipleobjects") || name.StartsWith ("kernel32.dll!waitformultipleobjects")) {  	found = true;  	int handleCount = stackFrame.Params [0].ToInt32 ();  	IntPtr handleAddress = stackFrame.Params [1];  	WaitType waitType = (WaitType)stackFrame.Params [2].ToInt32 ();  	bool alertable = stackFrame.Params [3].ToInt32 () != 0;  	// use the KiFastSystemCallRet args if we have the wrong args  	if (handleCount > 64) {  		handleCount = lastParams [1].ToInt32 ();  		handleAddress = lastParams [2];  		waitType = (WaitType)lastParams [3].ToInt32 ();  	}  	IntPtr* handles = stackalloc IntPtr[handleCount];  	phandle.ReadMemory (handleAddress' handles' handleCount * IntPtr.Size);  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + "' wait type: " + waitType.ToString () + ") for:");  	for (int i = 0; i < handleCount; i++) {  		sb.AppendLine (this.GetHandleString (_pid' handles [i]));  	}  }  else if (name.StartsWith ("ntdll.dll!zwwaitforsingleobject") || name.StartsWith ("ntdll.dll!ntwaitforsingleobject") || name.StartsWith ("kernel32.dll!waitforsingleobject")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	bool alertable = stackFrame.Params [1].ToInt32 () != 0;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + ") for:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforworkviaworkerfactory") || name.StartsWith ("ntdll.dll!ntwaitforworkviaworkerfactory")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for work from a worker factory:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,analyzeWaitMenuItem_Click,The following statement contains a magic number: if (name.StartsWith ("ntdll.dll!zwdeviceiocontrolfile") || name.StartsWith ("ntdll.dll!ntdeviceiocontrolfile")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an I/O control request:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!ntfscontrolfile") || name.StartsWith ("ntdll.dll!zwfscontrolfile")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an FS control request:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!ntqueryobject") || name.StartsWith ("ntdll.dll!zwqueryobject")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	// Use the KiFastSystemCallRet args if the handle we have is wrong.  	if (handle.ToInt32 () % 2 != 0 || handle == IntPtr.Zero)  		handle = lastParams [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is querying an object (most likely a named pipe):");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwreadfile") || name.StartsWith ("ntdll.dll!ntreadfile") || name.StartsWith ("ntdll.dll!zwwritefile") || name.StartsWith ("ntdll.dll!ntwritefile")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a named pipe or a file:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwremoveiocompletion") || name.StartsWith ("ntdll.dll!ntremoveiocompletion")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an I/O completion object:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwreplywaitreceiveport") || name.StartsWith ("ntdll.dll!ntreplywaitreceiveport") || name.StartsWith ("ntdll.dll!zwrequestwaitreplyport") || name.StartsWith ("ntdll.dll!ntrequestwaitreplyport") || name.StartsWith ("ntdll.dll!zwalpcsendwaitreceiveport") || name.StartsWith ("ntdll.dll!ntalpcsendwaitreceiveport")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a LPC port:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!ntsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!zwsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!ntsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaithigheventpair") || name.StartsWith ("ntdll.dll!ntwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaitloweventpair") || name.StartsWith ("ntdll.dll!ntwaitloweventpair")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	// Use the KiFastSystemCallRet args if the handle we have is wrong.  	if (handle.ToInt32 () % 2 != 0)  		handle = lastParams [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for an event pair:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("user32.dll!ntusergetmessage") || name.StartsWith ("user32.dll!ntuserwaitmessage")) {  	found = true;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a USER message.");  }  else if (name.StartsWith ("ntdll.dll!zwwaitfordebugevent") || name.StartsWith ("ntdll.dll!ntwaitfordebugevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a debug event:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforkeyedevent") || name.StartsWith ("ntdll.dll!ntwaitforkeyedevent") || name.StartsWith ("ntdll.dll!zwreleasekeyedevent") || name.StartsWith ("ntdll.dll!ntreleasekeyedevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	IntPtr key = stackFrame.Params [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for a keyed event (key 0x" + key.ToString ("x") + "):");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitformultipleobjects") || name.StartsWith ("ntdll.dll!ntwaitformultipleobjects") || name.StartsWith ("kernel32.dll!waitformultipleobjects")) {  	found = true;  	int handleCount = stackFrame.Params [0].ToInt32 ();  	IntPtr handleAddress = stackFrame.Params [1];  	WaitType waitType = (WaitType)stackFrame.Params [2].ToInt32 ();  	bool alertable = stackFrame.Params [3].ToInt32 () != 0;  	// use the KiFastSystemCallRet args if we have the wrong args  	if (handleCount > 64) {  		handleCount = lastParams [1].ToInt32 ();  		handleAddress = lastParams [2];  		waitType = (WaitType)lastParams [3].ToInt32 ();  	}  	IntPtr* handles = stackalloc IntPtr[handleCount];  	phandle.ReadMemory (handleAddress' handles' handleCount * IntPtr.Size);  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + "' wait type: " + waitType.ToString () + ") for:");  	for (int i = 0; i < handleCount; i++) {  		sb.AppendLine (this.GetHandleString (_pid' handles [i]));  	}  }  else if (name.StartsWith ("ntdll.dll!zwwaitforsingleobject") || name.StartsWith ("ntdll.dll!ntwaitforsingleobject") || name.StartsWith ("kernel32.dll!waitforsingleobject")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	bool alertable = stackFrame.Params [1].ToInt32 () != 0;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + ") for:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforworkviaworkerfactory") || name.StartsWith ("ntdll.dll!ntwaitforworkviaworkerfactory")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for work from a worker factory:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,analyzeWaitMenuItem_Click,The following statement contains a magic number: if (name.StartsWith ("ntdll.dll!zwdeviceiocontrolfile") || name.StartsWith ("ntdll.dll!ntdeviceiocontrolfile")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an I/O control request:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!ntfscontrolfile") || name.StartsWith ("ntdll.dll!zwfscontrolfile")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an FS control request:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!ntqueryobject") || name.StartsWith ("ntdll.dll!zwqueryobject")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	// Use the KiFastSystemCallRet args if the handle we have is wrong.  	if (handle.ToInt32 () % 2 != 0 || handle == IntPtr.Zero)  		handle = lastParams [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is querying an object (most likely a named pipe):");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwreadfile") || name.StartsWith ("ntdll.dll!ntreadfile") || name.StartsWith ("ntdll.dll!zwwritefile") || name.StartsWith ("ntdll.dll!ntwritefile")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a named pipe or a file:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwremoveiocompletion") || name.StartsWith ("ntdll.dll!ntremoveiocompletion")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an I/O completion object:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwreplywaitreceiveport") || name.StartsWith ("ntdll.dll!ntreplywaitreceiveport") || name.StartsWith ("ntdll.dll!zwrequestwaitreplyport") || name.StartsWith ("ntdll.dll!ntrequestwaitreplyport") || name.StartsWith ("ntdll.dll!zwalpcsendwaitreceiveport") || name.StartsWith ("ntdll.dll!ntalpcsendwaitreceiveport")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a LPC port:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!ntsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!zwsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!ntsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaithigheventpair") || name.StartsWith ("ntdll.dll!ntwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaitloweventpair") || name.StartsWith ("ntdll.dll!ntwaitloweventpair")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	// Use the KiFastSystemCallRet args if the handle we have is wrong.  	if (handle.ToInt32 () % 2 != 0)  		handle = lastParams [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for an event pair:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("user32.dll!ntusergetmessage") || name.StartsWith ("user32.dll!ntuserwaitmessage")) {  	found = true;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a USER message.");  }  else if (name.StartsWith ("ntdll.dll!zwwaitfordebugevent") || name.StartsWith ("ntdll.dll!ntwaitfordebugevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a debug event:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforkeyedevent") || name.StartsWith ("ntdll.dll!ntwaitforkeyedevent") || name.StartsWith ("ntdll.dll!zwreleasekeyedevent") || name.StartsWith ("ntdll.dll!ntreleasekeyedevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	IntPtr key = stackFrame.Params [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for a keyed event (key 0x" + key.ToString ("x") + "):");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitformultipleobjects") || name.StartsWith ("ntdll.dll!ntwaitformultipleobjects") || name.StartsWith ("kernel32.dll!waitformultipleobjects")) {  	found = true;  	int handleCount = stackFrame.Params [0].ToInt32 ();  	IntPtr handleAddress = stackFrame.Params [1];  	WaitType waitType = (WaitType)stackFrame.Params [2].ToInt32 ();  	bool alertable = stackFrame.Params [3].ToInt32 () != 0;  	// use the KiFastSystemCallRet args if we have the wrong args  	if (handleCount > 64) {  		handleCount = lastParams [1].ToInt32 ();  		handleAddress = lastParams [2];  		waitType = (WaitType)lastParams [3].ToInt32 ();  	}  	IntPtr* handles = stackalloc IntPtr[handleCount];  	phandle.ReadMemory (handleAddress' handles' handleCount * IntPtr.Size);  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + "' wait type: " + waitType.ToString () + ") for:");  	for (int i = 0; i < handleCount; i++) {  		sb.AppendLine (this.GetHandleString (_pid' handles [i]));  	}  }  else if (name.StartsWith ("ntdll.dll!zwwaitforsingleobject") || name.StartsWith ("ntdll.dll!ntwaitforsingleobject") || name.StartsWith ("kernel32.dll!waitforsingleobject")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	bool alertable = stackFrame.Params [1].ToInt32 () != 0;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + ") for:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforworkviaworkerfactory") || name.StartsWith ("ntdll.dll!ntwaitforworkviaworkerfactory")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for work from a worker factory:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,analyzeWaitMenuItem_Click,The following statement contains a magic number: if (name.StartsWith ("ntdll.dll!ntfscontrolfile") || name.StartsWith ("ntdll.dll!zwfscontrolfile")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an FS control request:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!ntqueryobject") || name.StartsWith ("ntdll.dll!zwqueryobject")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	// Use the KiFastSystemCallRet args if the handle we have is wrong.  	if (handle.ToInt32 () % 2 != 0 || handle == IntPtr.Zero)  		handle = lastParams [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is querying an object (most likely a named pipe):");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwreadfile") || name.StartsWith ("ntdll.dll!ntreadfile") || name.StartsWith ("ntdll.dll!zwwritefile") || name.StartsWith ("ntdll.dll!ntwritefile")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a named pipe or a file:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwremoveiocompletion") || name.StartsWith ("ntdll.dll!ntremoveiocompletion")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an I/O completion object:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwreplywaitreceiveport") || name.StartsWith ("ntdll.dll!ntreplywaitreceiveport") || name.StartsWith ("ntdll.dll!zwrequestwaitreplyport") || name.StartsWith ("ntdll.dll!ntrequestwaitreplyport") || name.StartsWith ("ntdll.dll!zwalpcsendwaitreceiveport") || name.StartsWith ("ntdll.dll!ntalpcsendwaitreceiveport")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a LPC port:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!ntsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!zwsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!ntsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaithigheventpair") || name.StartsWith ("ntdll.dll!ntwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaitloweventpair") || name.StartsWith ("ntdll.dll!ntwaitloweventpair")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	// Use the KiFastSystemCallRet args if the handle we have is wrong.  	if (handle.ToInt32 () % 2 != 0)  		handle = lastParams [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for an event pair:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("user32.dll!ntusergetmessage") || name.StartsWith ("user32.dll!ntuserwaitmessage")) {  	found = true;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a USER message.");  }  else if (name.StartsWith ("ntdll.dll!zwwaitfordebugevent") || name.StartsWith ("ntdll.dll!ntwaitfordebugevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a debug event:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforkeyedevent") || name.StartsWith ("ntdll.dll!ntwaitforkeyedevent") || name.StartsWith ("ntdll.dll!zwreleasekeyedevent") || name.StartsWith ("ntdll.dll!ntreleasekeyedevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	IntPtr key = stackFrame.Params [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for a keyed event (key 0x" + key.ToString ("x") + "):");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitformultipleobjects") || name.StartsWith ("ntdll.dll!ntwaitformultipleobjects") || name.StartsWith ("kernel32.dll!waitformultipleobjects")) {  	found = true;  	int handleCount = stackFrame.Params [0].ToInt32 ();  	IntPtr handleAddress = stackFrame.Params [1];  	WaitType waitType = (WaitType)stackFrame.Params [2].ToInt32 ();  	bool alertable = stackFrame.Params [3].ToInt32 () != 0;  	// use the KiFastSystemCallRet args if we have the wrong args  	if (handleCount > 64) {  		handleCount = lastParams [1].ToInt32 ();  		handleAddress = lastParams [2];  		waitType = (WaitType)lastParams [3].ToInt32 ();  	}  	IntPtr* handles = stackalloc IntPtr[handleCount];  	phandle.ReadMemory (handleAddress' handles' handleCount * IntPtr.Size);  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + "' wait type: " + waitType.ToString () + ") for:");  	for (int i = 0; i < handleCount; i++) {  		sb.AppendLine (this.GetHandleString (_pid' handles [i]));  	}  }  else if (name.StartsWith ("ntdll.dll!zwwaitforsingleobject") || name.StartsWith ("ntdll.dll!ntwaitforsingleobject") || name.StartsWith ("kernel32.dll!waitforsingleobject")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	bool alertable = stackFrame.Params [1].ToInt32 () != 0;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + ") for:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforworkviaworkerfactory") || name.StartsWith ("ntdll.dll!ntwaitforworkviaworkerfactory")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for work from a worker factory:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,analyzeWaitMenuItem_Click,The following statement contains a magic number: if (name.StartsWith ("ntdll.dll!ntfscontrolfile") || name.StartsWith ("ntdll.dll!zwfscontrolfile")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an FS control request:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!ntqueryobject") || name.StartsWith ("ntdll.dll!zwqueryobject")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	// Use the KiFastSystemCallRet args if the handle we have is wrong.  	if (handle.ToInt32 () % 2 != 0 || handle == IntPtr.Zero)  		handle = lastParams [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is querying an object (most likely a named pipe):");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwreadfile") || name.StartsWith ("ntdll.dll!ntreadfile") || name.StartsWith ("ntdll.dll!zwwritefile") || name.StartsWith ("ntdll.dll!ntwritefile")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a named pipe or a file:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwremoveiocompletion") || name.StartsWith ("ntdll.dll!ntremoveiocompletion")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an I/O completion object:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwreplywaitreceiveport") || name.StartsWith ("ntdll.dll!ntreplywaitreceiveport") || name.StartsWith ("ntdll.dll!zwrequestwaitreplyport") || name.StartsWith ("ntdll.dll!ntrequestwaitreplyport") || name.StartsWith ("ntdll.dll!zwalpcsendwaitreceiveport") || name.StartsWith ("ntdll.dll!ntalpcsendwaitreceiveport")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a LPC port:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!ntsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!zwsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!ntsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaithigheventpair") || name.StartsWith ("ntdll.dll!ntwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaitloweventpair") || name.StartsWith ("ntdll.dll!ntwaitloweventpair")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	// Use the KiFastSystemCallRet args if the handle we have is wrong.  	if (handle.ToInt32 () % 2 != 0)  		handle = lastParams [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for an event pair:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("user32.dll!ntusergetmessage") || name.StartsWith ("user32.dll!ntuserwaitmessage")) {  	found = true;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a USER message.");  }  else if (name.StartsWith ("ntdll.dll!zwwaitfordebugevent") || name.StartsWith ("ntdll.dll!ntwaitfordebugevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a debug event:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforkeyedevent") || name.StartsWith ("ntdll.dll!ntwaitforkeyedevent") || name.StartsWith ("ntdll.dll!zwreleasekeyedevent") || name.StartsWith ("ntdll.dll!ntreleasekeyedevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	IntPtr key = stackFrame.Params [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for a keyed event (key 0x" + key.ToString ("x") + "):");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitformultipleobjects") || name.StartsWith ("ntdll.dll!ntwaitformultipleobjects") || name.StartsWith ("kernel32.dll!waitformultipleobjects")) {  	found = true;  	int handleCount = stackFrame.Params [0].ToInt32 ();  	IntPtr handleAddress = stackFrame.Params [1];  	WaitType waitType = (WaitType)stackFrame.Params [2].ToInt32 ();  	bool alertable = stackFrame.Params [3].ToInt32 () != 0;  	// use the KiFastSystemCallRet args if we have the wrong args  	if (handleCount > 64) {  		handleCount = lastParams [1].ToInt32 ();  		handleAddress = lastParams [2];  		waitType = (WaitType)lastParams [3].ToInt32 ();  	}  	IntPtr* handles = stackalloc IntPtr[handleCount];  	phandle.ReadMemory (handleAddress' handles' handleCount * IntPtr.Size);  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + "' wait type: " + waitType.ToString () + ") for:");  	for (int i = 0; i < handleCount; i++) {  		sb.AppendLine (this.GetHandleString (_pid' handles [i]));  	}  }  else if (name.StartsWith ("ntdll.dll!zwwaitforsingleobject") || name.StartsWith ("ntdll.dll!ntwaitforsingleobject") || name.StartsWith ("kernel32.dll!waitforsingleobject")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	bool alertable = stackFrame.Params [1].ToInt32 () != 0;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + ") for:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforworkviaworkerfactory") || name.StartsWith ("ntdll.dll!ntwaitforworkviaworkerfactory")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for work from a worker factory:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,analyzeWaitMenuItem_Click,The following statement contains a magic number: if (name.StartsWith ("ntdll.dll!ntfscontrolfile") || name.StartsWith ("ntdll.dll!zwfscontrolfile")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an FS control request:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!ntqueryobject") || name.StartsWith ("ntdll.dll!zwqueryobject")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	// Use the KiFastSystemCallRet args if the handle we have is wrong.  	if (handle.ToInt32 () % 2 != 0 || handle == IntPtr.Zero)  		handle = lastParams [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is querying an object (most likely a named pipe):");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwreadfile") || name.StartsWith ("ntdll.dll!ntreadfile") || name.StartsWith ("ntdll.dll!zwwritefile") || name.StartsWith ("ntdll.dll!ntwritefile")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a named pipe or a file:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwremoveiocompletion") || name.StartsWith ("ntdll.dll!ntremoveiocompletion")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an I/O completion object:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwreplywaitreceiveport") || name.StartsWith ("ntdll.dll!ntreplywaitreceiveport") || name.StartsWith ("ntdll.dll!zwrequestwaitreplyport") || name.StartsWith ("ntdll.dll!ntrequestwaitreplyport") || name.StartsWith ("ntdll.dll!zwalpcsendwaitreceiveport") || name.StartsWith ("ntdll.dll!ntalpcsendwaitreceiveport")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a LPC port:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!ntsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!zwsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!ntsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaithigheventpair") || name.StartsWith ("ntdll.dll!ntwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaitloweventpair") || name.StartsWith ("ntdll.dll!ntwaitloweventpair")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	// Use the KiFastSystemCallRet args if the handle we have is wrong.  	if (handle.ToInt32 () % 2 != 0)  		handle = lastParams [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for an event pair:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("user32.dll!ntusergetmessage") || name.StartsWith ("user32.dll!ntuserwaitmessage")) {  	found = true;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a USER message.");  }  else if (name.StartsWith ("ntdll.dll!zwwaitfordebugevent") || name.StartsWith ("ntdll.dll!ntwaitfordebugevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a debug event:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforkeyedevent") || name.StartsWith ("ntdll.dll!ntwaitforkeyedevent") || name.StartsWith ("ntdll.dll!zwreleasekeyedevent") || name.StartsWith ("ntdll.dll!ntreleasekeyedevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	IntPtr key = stackFrame.Params [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for a keyed event (key 0x" + key.ToString ("x") + "):");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitformultipleobjects") || name.StartsWith ("ntdll.dll!ntwaitformultipleobjects") || name.StartsWith ("kernel32.dll!waitformultipleobjects")) {  	found = true;  	int handleCount = stackFrame.Params [0].ToInt32 ();  	IntPtr handleAddress = stackFrame.Params [1];  	WaitType waitType = (WaitType)stackFrame.Params [2].ToInt32 ();  	bool alertable = stackFrame.Params [3].ToInt32 () != 0;  	// use the KiFastSystemCallRet args if we have the wrong args  	if (handleCount > 64) {  		handleCount = lastParams [1].ToInt32 ();  		handleAddress = lastParams [2];  		waitType = (WaitType)lastParams [3].ToInt32 ();  	}  	IntPtr* handles = stackalloc IntPtr[handleCount];  	phandle.ReadMemory (handleAddress' handles' handleCount * IntPtr.Size);  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + "' wait type: " + waitType.ToString () + ") for:");  	for (int i = 0; i < handleCount; i++) {  		sb.AppendLine (this.GetHandleString (_pid' handles [i]));  	}  }  else if (name.StartsWith ("ntdll.dll!zwwaitforsingleobject") || name.StartsWith ("ntdll.dll!ntwaitforsingleobject") || name.StartsWith ("kernel32.dll!waitforsingleobject")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	bool alertable = stackFrame.Params [1].ToInt32 () != 0;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + ") for:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforworkviaworkerfactory") || name.StartsWith ("ntdll.dll!ntwaitforworkviaworkerfactory")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for work from a worker factory:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,analyzeWaitMenuItem_Click,The following statement contains a magic number: if (name.StartsWith ("ntdll.dll!ntfscontrolfile") || name.StartsWith ("ntdll.dll!zwfscontrolfile")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an FS control request:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!ntqueryobject") || name.StartsWith ("ntdll.dll!zwqueryobject")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	// Use the KiFastSystemCallRet args if the handle we have is wrong.  	if (handle.ToInt32 () % 2 != 0 || handle == IntPtr.Zero)  		handle = lastParams [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is querying an object (most likely a named pipe):");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwreadfile") || name.StartsWith ("ntdll.dll!ntreadfile") || name.StartsWith ("ntdll.dll!zwwritefile") || name.StartsWith ("ntdll.dll!ntwritefile")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a named pipe or a file:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwremoveiocompletion") || name.StartsWith ("ntdll.dll!ntremoveiocompletion")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an I/O completion object:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwreplywaitreceiveport") || name.StartsWith ("ntdll.dll!ntreplywaitreceiveport") || name.StartsWith ("ntdll.dll!zwrequestwaitreplyport") || name.StartsWith ("ntdll.dll!ntrequestwaitreplyport") || name.StartsWith ("ntdll.dll!zwalpcsendwaitreceiveport") || name.StartsWith ("ntdll.dll!ntalpcsendwaitreceiveport")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a LPC port:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!ntsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!zwsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!ntsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaithigheventpair") || name.StartsWith ("ntdll.dll!ntwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaitloweventpair") || name.StartsWith ("ntdll.dll!ntwaitloweventpair")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	// Use the KiFastSystemCallRet args if the handle we have is wrong.  	if (handle.ToInt32 () % 2 != 0)  		handle = lastParams [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for an event pair:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("user32.dll!ntusergetmessage") || name.StartsWith ("user32.dll!ntuserwaitmessage")) {  	found = true;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a USER message.");  }  else if (name.StartsWith ("ntdll.dll!zwwaitfordebugevent") || name.StartsWith ("ntdll.dll!ntwaitfordebugevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a debug event:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforkeyedevent") || name.StartsWith ("ntdll.dll!ntwaitforkeyedevent") || name.StartsWith ("ntdll.dll!zwreleasekeyedevent") || name.StartsWith ("ntdll.dll!ntreleasekeyedevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	IntPtr key = stackFrame.Params [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for a keyed event (key 0x" + key.ToString ("x") + "):");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitformultipleobjects") || name.StartsWith ("ntdll.dll!ntwaitformultipleobjects") || name.StartsWith ("kernel32.dll!waitformultipleobjects")) {  	found = true;  	int handleCount = stackFrame.Params [0].ToInt32 ();  	IntPtr handleAddress = stackFrame.Params [1];  	WaitType waitType = (WaitType)stackFrame.Params [2].ToInt32 ();  	bool alertable = stackFrame.Params [3].ToInt32 () != 0;  	// use the KiFastSystemCallRet args if we have the wrong args  	if (handleCount > 64) {  		handleCount = lastParams [1].ToInt32 ();  		handleAddress = lastParams [2];  		waitType = (WaitType)lastParams [3].ToInt32 ();  	}  	IntPtr* handles = stackalloc IntPtr[handleCount];  	phandle.ReadMemory (handleAddress' handles' handleCount * IntPtr.Size);  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + "' wait type: " + waitType.ToString () + ") for:");  	for (int i = 0; i < handleCount; i++) {  		sb.AppendLine (this.GetHandleString (_pid' handles [i]));  	}  }  else if (name.StartsWith ("ntdll.dll!zwwaitforsingleobject") || name.StartsWith ("ntdll.dll!ntwaitforsingleobject") || name.StartsWith ("kernel32.dll!waitforsingleobject")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	bool alertable = stackFrame.Params [1].ToInt32 () != 0;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + ") for:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforworkviaworkerfactory") || name.StartsWith ("ntdll.dll!ntwaitforworkviaworkerfactory")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for work from a worker factory:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,analyzeWaitMenuItem_Click,The following statement contains a magic number: if (name.StartsWith ("ntdll.dll!ntfscontrolfile") || name.StartsWith ("ntdll.dll!zwfscontrolfile")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an FS control request:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!ntqueryobject") || name.StartsWith ("ntdll.dll!zwqueryobject")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	// Use the KiFastSystemCallRet args if the handle we have is wrong.  	if (handle.ToInt32 () % 2 != 0 || handle == IntPtr.Zero)  		handle = lastParams [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is querying an object (most likely a named pipe):");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwreadfile") || name.StartsWith ("ntdll.dll!ntreadfile") || name.StartsWith ("ntdll.dll!zwwritefile") || name.StartsWith ("ntdll.dll!ntwritefile")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a named pipe or a file:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwremoveiocompletion") || name.StartsWith ("ntdll.dll!ntremoveiocompletion")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an I/O completion object:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwreplywaitreceiveport") || name.StartsWith ("ntdll.dll!ntreplywaitreceiveport") || name.StartsWith ("ntdll.dll!zwrequestwaitreplyport") || name.StartsWith ("ntdll.dll!ntrequestwaitreplyport") || name.StartsWith ("ntdll.dll!zwalpcsendwaitreceiveport") || name.StartsWith ("ntdll.dll!ntalpcsendwaitreceiveport")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a LPC port:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!ntsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!zwsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!ntsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaithigheventpair") || name.StartsWith ("ntdll.dll!ntwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaitloweventpair") || name.StartsWith ("ntdll.dll!ntwaitloweventpair")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	// Use the KiFastSystemCallRet args if the handle we have is wrong.  	if (handle.ToInt32 () % 2 != 0)  		handle = lastParams [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for an event pair:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("user32.dll!ntusergetmessage") || name.StartsWith ("user32.dll!ntuserwaitmessage")) {  	found = true;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a USER message.");  }  else if (name.StartsWith ("ntdll.dll!zwwaitfordebugevent") || name.StartsWith ("ntdll.dll!ntwaitfordebugevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a debug event:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforkeyedevent") || name.StartsWith ("ntdll.dll!ntwaitforkeyedevent") || name.StartsWith ("ntdll.dll!zwreleasekeyedevent") || name.StartsWith ("ntdll.dll!ntreleasekeyedevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	IntPtr key = stackFrame.Params [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for a keyed event (key 0x" + key.ToString ("x") + "):");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitformultipleobjects") || name.StartsWith ("ntdll.dll!ntwaitformultipleobjects") || name.StartsWith ("kernel32.dll!waitformultipleobjects")) {  	found = true;  	int handleCount = stackFrame.Params [0].ToInt32 ();  	IntPtr handleAddress = stackFrame.Params [1];  	WaitType waitType = (WaitType)stackFrame.Params [2].ToInt32 ();  	bool alertable = stackFrame.Params [3].ToInt32 () != 0;  	// use the KiFastSystemCallRet args if we have the wrong args  	if (handleCount > 64) {  		handleCount = lastParams [1].ToInt32 ();  		handleAddress = lastParams [2];  		waitType = (WaitType)lastParams [3].ToInt32 ();  	}  	IntPtr* handles = stackalloc IntPtr[handleCount];  	phandle.ReadMemory (handleAddress' handles' handleCount * IntPtr.Size);  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + "' wait type: " + waitType.ToString () + ") for:");  	for (int i = 0; i < handleCount; i++) {  		sb.AppendLine (this.GetHandleString (_pid' handles [i]));  	}  }  else if (name.StartsWith ("ntdll.dll!zwwaitforsingleobject") || name.StartsWith ("ntdll.dll!ntwaitforsingleobject") || name.StartsWith ("kernel32.dll!waitforsingleobject")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	bool alertable = stackFrame.Params [1].ToInt32 () != 0;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + ") for:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforworkviaworkerfactory") || name.StartsWith ("ntdll.dll!ntwaitforworkviaworkerfactory")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for work from a worker factory:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,analyzeWaitMenuItem_Click,The following statement contains a magic number: if (name.StartsWith ("ntdll.dll!ntfscontrolfile") || name.StartsWith ("ntdll.dll!zwfscontrolfile")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an FS control request:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!ntqueryobject") || name.StartsWith ("ntdll.dll!zwqueryobject")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	// Use the KiFastSystemCallRet args if the handle we have is wrong.  	if (handle.ToInt32 () % 2 != 0 || handle == IntPtr.Zero)  		handle = lastParams [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is querying an object (most likely a named pipe):");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwreadfile") || name.StartsWith ("ntdll.dll!ntreadfile") || name.StartsWith ("ntdll.dll!zwwritefile") || name.StartsWith ("ntdll.dll!ntwritefile")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a named pipe or a file:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwremoveiocompletion") || name.StartsWith ("ntdll.dll!ntremoveiocompletion")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an I/O completion object:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwreplywaitreceiveport") || name.StartsWith ("ntdll.dll!ntreplywaitreceiveport") || name.StartsWith ("ntdll.dll!zwrequestwaitreplyport") || name.StartsWith ("ntdll.dll!ntrequestwaitreplyport") || name.StartsWith ("ntdll.dll!zwalpcsendwaitreceiveport") || name.StartsWith ("ntdll.dll!ntalpcsendwaitreceiveport")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a LPC port:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!ntsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!zwsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!ntsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaithigheventpair") || name.StartsWith ("ntdll.dll!ntwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaitloweventpair") || name.StartsWith ("ntdll.dll!ntwaitloweventpair")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	// Use the KiFastSystemCallRet args if the handle we have is wrong.  	if (handle.ToInt32 () % 2 != 0)  		handle = lastParams [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for an event pair:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("user32.dll!ntusergetmessage") || name.StartsWith ("user32.dll!ntuserwaitmessage")) {  	found = true;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a USER message.");  }  else if (name.StartsWith ("ntdll.dll!zwwaitfordebugevent") || name.StartsWith ("ntdll.dll!ntwaitfordebugevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a debug event:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforkeyedevent") || name.StartsWith ("ntdll.dll!ntwaitforkeyedevent") || name.StartsWith ("ntdll.dll!zwreleasekeyedevent") || name.StartsWith ("ntdll.dll!ntreleasekeyedevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	IntPtr key = stackFrame.Params [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for a keyed event (key 0x" + key.ToString ("x") + "):");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitformultipleobjects") || name.StartsWith ("ntdll.dll!ntwaitformultipleobjects") || name.StartsWith ("kernel32.dll!waitformultipleobjects")) {  	found = true;  	int handleCount = stackFrame.Params [0].ToInt32 ();  	IntPtr handleAddress = stackFrame.Params [1];  	WaitType waitType = (WaitType)stackFrame.Params [2].ToInt32 ();  	bool alertable = stackFrame.Params [3].ToInt32 () != 0;  	// use the KiFastSystemCallRet args if we have the wrong args  	if (handleCount > 64) {  		handleCount = lastParams [1].ToInt32 ();  		handleAddress = lastParams [2];  		waitType = (WaitType)lastParams [3].ToInt32 ();  	}  	IntPtr* handles = stackalloc IntPtr[handleCount];  	phandle.ReadMemory (handleAddress' handles' handleCount * IntPtr.Size);  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + "' wait type: " + waitType.ToString () + ") for:");  	for (int i = 0; i < handleCount; i++) {  		sb.AppendLine (this.GetHandleString (_pid' handles [i]));  	}  }  else if (name.StartsWith ("ntdll.dll!zwwaitforsingleobject") || name.StartsWith ("ntdll.dll!ntwaitforsingleobject") || name.StartsWith ("kernel32.dll!waitforsingleobject")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	bool alertable = stackFrame.Params [1].ToInt32 () != 0;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + ") for:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforworkviaworkerfactory") || name.StartsWith ("ntdll.dll!ntwaitforworkviaworkerfactory")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for work from a worker factory:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,analyzeWaitMenuItem_Click,The following statement contains a magic number: if (name.StartsWith ("ntdll.dll!ntfscontrolfile") || name.StartsWith ("ntdll.dll!zwfscontrolfile")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an FS control request:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!ntqueryobject") || name.StartsWith ("ntdll.dll!zwqueryobject")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	// Use the KiFastSystemCallRet args if the handle we have is wrong.  	if (handle.ToInt32 () % 2 != 0 || handle == IntPtr.Zero)  		handle = lastParams [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is querying an object (most likely a named pipe):");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwreadfile") || name.StartsWith ("ntdll.dll!ntreadfile") || name.StartsWith ("ntdll.dll!zwwritefile") || name.StartsWith ("ntdll.dll!ntwritefile")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a named pipe or a file:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwremoveiocompletion") || name.StartsWith ("ntdll.dll!ntremoveiocompletion")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an I/O completion object:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwreplywaitreceiveport") || name.StartsWith ("ntdll.dll!ntreplywaitreceiveport") || name.StartsWith ("ntdll.dll!zwrequestwaitreplyport") || name.StartsWith ("ntdll.dll!ntrequestwaitreplyport") || name.StartsWith ("ntdll.dll!zwalpcsendwaitreceiveport") || name.StartsWith ("ntdll.dll!ntalpcsendwaitreceiveport")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a LPC port:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!ntsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!zwsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!ntsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaithigheventpair") || name.StartsWith ("ntdll.dll!ntwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaitloweventpair") || name.StartsWith ("ntdll.dll!ntwaitloweventpair")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	// Use the KiFastSystemCallRet args if the handle we have is wrong.  	if (handle.ToInt32 () % 2 != 0)  		handle = lastParams [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for an event pair:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("user32.dll!ntusergetmessage") || name.StartsWith ("user32.dll!ntuserwaitmessage")) {  	found = true;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a USER message.");  }  else if (name.StartsWith ("ntdll.dll!zwwaitfordebugevent") || name.StartsWith ("ntdll.dll!ntwaitfordebugevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a debug event:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforkeyedevent") || name.StartsWith ("ntdll.dll!ntwaitforkeyedevent") || name.StartsWith ("ntdll.dll!zwreleasekeyedevent") || name.StartsWith ("ntdll.dll!ntreleasekeyedevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	IntPtr key = stackFrame.Params [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for a keyed event (key 0x" + key.ToString ("x") + "):");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitformultipleobjects") || name.StartsWith ("ntdll.dll!ntwaitformultipleobjects") || name.StartsWith ("kernel32.dll!waitformultipleobjects")) {  	found = true;  	int handleCount = stackFrame.Params [0].ToInt32 ();  	IntPtr handleAddress = stackFrame.Params [1];  	WaitType waitType = (WaitType)stackFrame.Params [2].ToInt32 ();  	bool alertable = stackFrame.Params [3].ToInt32 () != 0;  	// use the KiFastSystemCallRet args if we have the wrong args  	if (handleCount > 64) {  		handleCount = lastParams [1].ToInt32 ();  		handleAddress = lastParams [2];  		waitType = (WaitType)lastParams [3].ToInt32 ();  	}  	IntPtr* handles = stackalloc IntPtr[handleCount];  	phandle.ReadMemory (handleAddress' handles' handleCount * IntPtr.Size);  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + "' wait type: " + waitType.ToString () + ") for:");  	for (int i = 0; i < handleCount; i++) {  		sb.AppendLine (this.GetHandleString (_pid' handles [i]));  	}  }  else if (name.StartsWith ("ntdll.dll!zwwaitforsingleobject") || name.StartsWith ("ntdll.dll!ntwaitforsingleobject") || name.StartsWith ("kernel32.dll!waitforsingleobject")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	bool alertable = stackFrame.Params [1].ToInt32 () != 0;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + ") for:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforworkviaworkerfactory") || name.StartsWith ("ntdll.dll!ntwaitforworkviaworkerfactory")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for work from a worker factory:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,analyzeWaitMenuItem_Click,The following statement contains a magic number: if (name.StartsWith ("ntdll.dll!ntqueryobject") || name.StartsWith ("ntdll.dll!zwqueryobject")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	// Use the KiFastSystemCallRet args if the handle we have is wrong.  	if (handle.ToInt32 () % 2 != 0 || handle == IntPtr.Zero)  		handle = lastParams [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is querying an object (most likely a named pipe):");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwreadfile") || name.StartsWith ("ntdll.dll!ntreadfile") || name.StartsWith ("ntdll.dll!zwwritefile") || name.StartsWith ("ntdll.dll!ntwritefile")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a named pipe or a file:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwremoveiocompletion") || name.StartsWith ("ntdll.dll!ntremoveiocompletion")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an I/O completion object:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwreplywaitreceiveport") || name.StartsWith ("ntdll.dll!ntreplywaitreceiveport") || name.StartsWith ("ntdll.dll!zwrequestwaitreplyport") || name.StartsWith ("ntdll.dll!ntrequestwaitreplyport") || name.StartsWith ("ntdll.dll!zwalpcsendwaitreceiveport") || name.StartsWith ("ntdll.dll!ntalpcsendwaitreceiveport")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a LPC port:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!ntsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!zwsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!ntsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaithigheventpair") || name.StartsWith ("ntdll.dll!ntwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaitloweventpair") || name.StartsWith ("ntdll.dll!ntwaitloweventpair")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	// Use the KiFastSystemCallRet args if the handle we have is wrong.  	if (handle.ToInt32 () % 2 != 0)  		handle = lastParams [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for an event pair:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("user32.dll!ntusergetmessage") || name.StartsWith ("user32.dll!ntuserwaitmessage")) {  	found = true;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a USER message.");  }  else if (name.StartsWith ("ntdll.dll!zwwaitfordebugevent") || name.StartsWith ("ntdll.dll!ntwaitfordebugevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a debug event:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforkeyedevent") || name.StartsWith ("ntdll.dll!ntwaitforkeyedevent") || name.StartsWith ("ntdll.dll!zwreleasekeyedevent") || name.StartsWith ("ntdll.dll!ntreleasekeyedevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	IntPtr key = stackFrame.Params [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for a keyed event (key 0x" + key.ToString ("x") + "):");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitformultipleobjects") || name.StartsWith ("ntdll.dll!ntwaitformultipleobjects") || name.StartsWith ("kernel32.dll!waitformultipleobjects")) {  	found = true;  	int handleCount = stackFrame.Params [0].ToInt32 ();  	IntPtr handleAddress = stackFrame.Params [1];  	WaitType waitType = (WaitType)stackFrame.Params [2].ToInt32 ();  	bool alertable = stackFrame.Params [3].ToInt32 () != 0;  	// use the KiFastSystemCallRet args if we have the wrong args  	if (handleCount > 64) {  		handleCount = lastParams [1].ToInt32 ();  		handleAddress = lastParams [2];  		waitType = (WaitType)lastParams [3].ToInt32 ();  	}  	IntPtr* handles = stackalloc IntPtr[handleCount];  	phandle.ReadMemory (handleAddress' handles' handleCount * IntPtr.Size);  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + "' wait type: " + waitType.ToString () + ") for:");  	for (int i = 0; i < handleCount; i++) {  		sb.AppendLine (this.GetHandleString (_pid' handles [i]));  	}  }  else if (name.StartsWith ("ntdll.dll!zwwaitforsingleobject") || name.StartsWith ("ntdll.dll!ntwaitforsingleobject") || name.StartsWith ("kernel32.dll!waitforsingleobject")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	bool alertable = stackFrame.Params [1].ToInt32 () != 0;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + ") for:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforworkviaworkerfactory") || name.StartsWith ("ntdll.dll!ntwaitforworkviaworkerfactory")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for work from a worker factory:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,analyzeWaitMenuItem_Click,The following statement contains a magic number: if (name.StartsWith ("ntdll.dll!ntqueryobject") || name.StartsWith ("ntdll.dll!zwqueryobject")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	// Use the KiFastSystemCallRet args if the handle we have is wrong.  	if (handle.ToInt32 () % 2 != 0 || handle == IntPtr.Zero)  		handle = lastParams [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is querying an object (most likely a named pipe):");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwreadfile") || name.StartsWith ("ntdll.dll!ntreadfile") || name.StartsWith ("ntdll.dll!zwwritefile") || name.StartsWith ("ntdll.dll!ntwritefile")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a named pipe or a file:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwremoveiocompletion") || name.StartsWith ("ntdll.dll!ntremoveiocompletion")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an I/O completion object:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwreplywaitreceiveport") || name.StartsWith ("ntdll.dll!ntreplywaitreceiveport") || name.StartsWith ("ntdll.dll!zwrequestwaitreplyport") || name.StartsWith ("ntdll.dll!ntrequestwaitreplyport") || name.StartsWith ("ntdll.dll!zwalpcsendwaitreceiveport") || name.StartsWith ("ntdll.dll!ntalpcsendwaitreceiveport")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a LPC port:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!ntsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!zwsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!ntsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaithigheventpair") || name.StartsWith ("ntdll.dll!ntwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaitloweventpair") || name.StartsWith ("ntdll.dll!ntwaitloweventpair")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	// Use the KiFastSystemCallRet args if the handle we have is wrong.  	if (handle.ToInt32 () % 2 != 0)  		handle = lastParams [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for an event pair:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("user32.dll!ntusergetmessage") || name.StartsWith ("user32.dll!ntuserwaitmessage")) {  	found = true;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a USER message.");  }  else if (name.StartsWith ("ntdll.dll!zwwaitfordebugevent") || name.StartsWith ("ntdll.dll!ntwaitfordebugevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a debug event:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforkeyedevent") || name.StartsWith ("ntdll.dll!ntwaitforkeyedevent") || name.StartsWith ("ntdll.dll!zwreleasekeyedevent") || name.StartsWith ("ntdll.dll!ntreleasekeyedevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	IntPtr key = stackFrame.Params [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for a keyed event (key 0x" + key.ToString ("x") + "):");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitformultipleobjects") || name.StartsWith ("ntdll.dll!ntwaitformultipleobjects") || name.StartsWith ("kernel32.dll!waitformultipleobjects")) {  	found = true;  	int handleCount = stackFrame.Params [0].ToInt32 ();  	IntPtr handleAddress = stackFrame.Params [1];  	WaitType waitType = (WaitType)stackFrame.Params [2].ToInt32 ();  	bool alertable = stackFrame.Params [3].ToInt32 () != 0;  	// use the KiFastSystemCallRet args if we have the wrong args  	if (handleCount > 64) {  		handleCount = lastParams [1].ToInt32 ();  		handleAddress = lastParams [2];  		waitType = (WaitType)lastParams [3].ToInt32 ();  	}  	IntPtr* handles = stackalloc IntPtr[handleCount];  	phandle.ReadMemory (handleAddress' handles' handleCount * IntPtr.Size);  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + "' wait type: " + waitType.ToString () + ") for:");  	for (int i = 0; i < handleCount; i++) {  		sb.AppendLine (this.GetHandleString (_pid' handles [i]));  	}  }  else if (name.StartsWith ("ntdll.dll!zwwaitforsingleobject") || name.StartsWith ("ntdll.dll!ntwaitforsingleobject") || name.StartsWith ("kernel32.dll!waitforsingleobject")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	bool alertable = stackFrame.Params [1].ToInt32 () != 0;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + ") for:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforworkviaworkerfactory") || name.StartsWith ("ntdll.dll!ntwaitforworkviaworkerfactory")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for work from a worker factory:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,analyzeWaitMenuItem_Click,The following statement contains a magic number: if (name.StartsWith ("ntdll.dll!ntqueryobject") || name.StartsWith ("ntdll.dll!zwqueryobject")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	// Use the KiFastSystemCallRet args if the handle we have is wrong.  	if (handle.ToInt32 () % 2 != 0 || handle == IntPtr.Zero)  		handle = lastParams [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is querying an object (most likely a named pipe):");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwreadfile") || name.StartsWith ("ntdll.dll!ntreadfile") || name.StartsWith ("ntdll.dll!zwwritefile") || name.StartsWith ("ntdll.dll!ntwritefile")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a named pipe or a file:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwremoveiocompletion") || name.StartsWith ("ntdll.dll!ntremoveiocompletion")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an I/O completion object:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwreplywaitreceiveport") || name.StartsWith ("ntdll.dll!ntreplywaitreceiveport") || name.StartsWith ("ntdll.dll!zwrequestwaitreplyport") || name.StartsWith ("ntdll.dll!ntrequestwaitreplyport") || name.StartsWith ("ntdll.dll!zwalpcsendwaitreceiveport") || name.StartsWith ("ntdll.dll!ntalpcsendwaitreceiveport")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a LPC port:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!ntsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!zwsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!ntsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaithigheventpair") || name.StartsWith ("ntdll.dll!ntwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaitloweventpair") || name.StartsWith ("ntdll.dll!ntwaitloweventpair")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	// Use the KiFastSystemCallRet args if the handle we have is wrong.  	if (handle.ToInt32 () % 2 != 0)  		handle = lastParams [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for an event pair:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("user32.dll!ntusergetmessage") || name.StartsWith ("user32.dll!ntuserwaitmessage")) {  	found = true;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a USER message.");  }  else if (name.StartsWith ("ntdll.dll!zwwaitfordebugevent") || name.StartsWith ("ntdll.dll!ntwaitfordebugevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a debug event:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforkeyedevent") || name.StartsWith ("ntdll.dll!ntwaitforkeyedevent") || name.StartsWith ("ntdll.dll!zwreleasekeyedevent") || name.StartsWith ("ntdll.dll!ntreleasekeyedevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	IntPtr key = stackFrame.Params [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for a keyed event (key 0x" + key.ToString ("x") + "):");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitformultipleobjects") || name.StartsWith ("ntdll.dll!ntwaitformultipleobjects") || name.StartsWith ("kernel32.dll!waitformultipleobjects")) {  	found = true;  	int handleCount = stackFrame.Params [0].ToInt32 ();  	IntPtr handleAddress = stackFrame.Params [1];  	WaitType waitType = (WaitType)stackFrame.Params [2].ToInt32 ();  	bool alertable = stackFrame.Params [3].ToInt32 () != 0;  	// use the KiFastSystemCallRet args if we have the wrong args  	if (handleCount > 64) {  		handleCount = lastParams [1].ToInt32 ();  		handleAddress = lastParams [2];  		waitType = (WaitType)lastParams [3].ToInt32 ();  	}  	IntPtr* handles = stackalloc IntPtr[handleCount];  	phandle.ReadMemory (handleAddress' handles' handleCount * IntPtr.Size);  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + "' wait type: " + waitType.ToString () + ") for:");  	for (int i = 0; i < handleCount; i++) {  		sb.AppendLine (this.GetHandleString (_pid' handles [i]));  	}  }  else if (name.StartsWith ("ntdll.dll!zwwaitforsingleobject") || name.StartsWith ("ntdll.dll!ntwaitforsingleobject") || name.StartsWith ("kernel32.dll!waitforsingleobject")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	bool alertable = stackFrame.Params [1].ToInt32 () != 0;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + ") for:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforworkviaworkerfactory") || name.StartsWith ("ntdll.dll!ntwaitforworkviaworkerfactory")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for work from a worker factory:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,analyzeWaitMenuItem_Click,The following statement contains a magic number: if (name.StartsWith ("ntdll.dll!ntqueryobject") || name.StartsWith ("ntdll.dll!zwqueryobject")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	// Use the KiFastSystemCallRet args if the handle we have is wrong.  	if (handle.ToInt32 () % 2 != 0 || handle == IntPtr.Zero)  		handle = lastParams [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is querying an object (most likely a named pipe):");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwreadfile") || name.StartsWith ("ntdll.dll!ntreadfile") || name.StartsWith ("ntdll.dll!zwwritefile") || name.StartsWith ("ntdll.dll!ntwritefile")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a named pipe or a file:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwremoveiocompletion") || name.StartsWith ("ntdll.dll!ntremoveiocompletion")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an I/O completion object:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwreplywaitreceiveport") || name.StartsWith ("ntdll.dll!ntreplywaitreceiveport") || name.StartsWith ("ntdll.dll!zwrequestwaitreplyport") || name.StartsWith ("ntdll.dll!ntrequestwaitreplyport") || name.StartsWith ("ntdll.dll!zwalpcsendwaitreceiveport") || name.StartsWith ("ntdll.dll!ntalpcsendwaitreceiveport")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a LPC port:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!ntsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!zwsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!ntsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaithigheventpair") || name.StartsWith ("ntdll.dll!ntwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaitloweventpair") || name.StartsWith ("ntdll.dll!ntwaitloweventpair")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	// Use the KiFastSystemCallRet args if the handle we have is wrong.  	if (handle.ToInt32 () % 2 != 0)  		handle = lastParams [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for an event pair:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("user32.dll!ntusergetmessage") || name.StartsWith ("user32.dll!ntuserwaitmessage")) {  	found = true;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a USER message.");  }  else if (name.StartsWith ("ntdll.dll!zwwaitfordebugevent") || name.StartsWith ("ntdll.dll!ntwaitfordebugevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a debug event:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforkeyedevent") || name.StartsWith ("ntdll.dll!ntwaitforkeyedevent") || name.StartsWith ("ntdll.dll!zwreleasekeyedevent") || name.StartsWith ("ntdll.dll!ntreleasekeyedevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	IntPtr key = stackFrame.Params [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for a keyed event (key 0x" + key.ToString ("x") + "):");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitformultipleobjects") || name.StartsWith ("ntdll.dll!ntwaitformultipleobjects") || name.StartsWith ("kernel32.dll!waitformultipleobjects")) {  	found = true;  	int handleCount = stackFrame.Params [0].ToInt32 ();  	IntPtr handleAddress = stackFrame.Params [1];  	WaitType waitType = (WaitType)stackFrame.Params [2].ToInt32 ();  	bool alertable = stackFrame.Params [3].ToInt32 () != 0;  	// use the KiFastSystemCallRet args if we have the wrong args  	if (handleCount > 64) {  		handleCount = lastParams [1].ToInt32 ();  		handleAddress = lastParams [2];  		waitType = (WaitType)lastParams [3].ToInt32 ();  	}  	IntPtr* handles = stackalloc IntPtr[handleCount];  	phandle.ReadMemory (handleAddress' handles' handleCount * IntPtr.Size);  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + "' wait type: " + waitType.ToString () + ") for:");  	for (int i = 0; i < handleCount; i++) {  		sb.AppendLine (this.GetHandleString (_pid' handles [i]));  	}  }  else if (name.StartsWith ("ntdll.dll!zwwaitforsingleobject") || name.StartsWith ("ntdll.dll!ntwaitforsingleobject") || name.StartsWith ("kernel32.dll!waitforsingleobject")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	bool alertable = stackFrame.Params [1].ToInt32 () != 0;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + ") for:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforworkviaworkerfactory") || name.StartsWith ("ntdll.dll!ntwaitforworkviaworkerfactory")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for work from a worker factory:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,analyzeWaitMenuItem_Click,The following statement contains a magic number: if (name.StartsWith ("ntdll.dll!ntqueryobject") || name.StartsWith ("ntdll.dll!zwqueryobject")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	// Use the KiFastSystemCallRet args if the handle we have is wrong.  	if (handle.ToInt32 () % 2 != 0 || handle == IntPtr.Zero)  		handle = lastParams [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is querying an object (most likely a named pipe):");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwreadfile") || name.StartsWith ("ntdll.dll!ntreadfile") || name.StartsWith ("ntdll.dll!zwwritefile") || name.StartsWith ("ntdll.dll!ntwritefile")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a named pipe or a file:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwremoveiocompletion") || name.StartsWith ("ntdll.dll!ntremoveiocompletion")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an I/O completion object:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwreplywaitreceiveport") || name.StartsWith ("ntdll.dll!ntreplywaitreceiveport") || name.StartsWith ("ntdll.dll!zwrequestwaitreplyport") || name.StartsWith ("ntdll.dll!ntrequestwaitreplyport") || name.StartsWith ("ntdll.dll!zwalpcsendwaitreceiveport") || name.StartsWith ("ntdll.dll!ntalpcsendwaitreceiveport")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a LPC port:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!ntsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!zwsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!ntsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaithigheventpair") || name.StartsWith ("ntdll.dll!ntwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaitloweventpair") || name.StartsWith ("ntdll.dll!ntwaitloweventpair")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	// Use the KiFastSystemCallRet args if the handle we have is wrong.  	if (handle.ToInt32 () % 2 != 0)  		handle = lastParams [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for an event pair:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("user32.dll!ntusergetmessage") || name.StartsWith ("user32.dll!ntuserwaitmessage")) {  	found = true;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a USER message.");  }  else if (name.StartsWith ("ntdll.dll!zwwaitfordebugevent") || name.StartsWith ("ntdll.dll!ntwaitfordebugevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a debug event:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforkeyedevent") || name.StartsWith ("ntdll.dll!ntwaitforkeyedevent") || name.StartsWith ("ntdll.dll!zwreleasekeyedevent") || name.StartsWith ("ntdll.dll!ntreleasekeyedevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	IntPtr key = stackFrame.Params [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for a keyed event (key 0x" + key.ToString ("x") + "):");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitformultipleobjects") || name.StartsWith ("ntdll.dll!ntwaitformultipleobjects") || name.StartsWith ("kernel32.dll!waitformultipleobjects")) {  	found = true;  	int handleCount = stackFrame.Params [0].ToInt32 ();  	IntPtr handleAddress = stackFrame.Params [1];  	WaitType waitType = (WaitType)stackFrame.Params [2].ToInt32 ();  	bool alertable = stackFrame.Params [3].ToInt32 () != 0;  	// use the KiFastSystemCallRet args if we have the wrong args  	if (handleCount > 64) {  		handleCount = lastParams [1].ToInt32 ();  		handleAddress = lastParams [2];  		waitType = (WaitType)lastParams [3].ToInt32 ();  	}  	IntPtr* handles = stackalloc IntPtr[handleCount];  	phandle.ReadMemory (handleAddress' handles' handleCount * IntPtr.Size);  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + "' wait type: " + waitType.ToString () + ") for:");  	for (int i = 0; i < handleCount; i++) {  		sb.AppendLine (this.GetHandleString (_pid' handles [i]));  	}  }  else if (name.StartsWith ("ntdll.dll!zwwaitforsingleobject") || name.StartsWith ("ntdll.dll!ntwaitforsingleobject") || name.StartsWith ("kernel32.dll!waitforsingleobject")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	bool alertable = stackFrame.Params [1].ToInt32 () != 0;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + ") for:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforworkviaworkerfactory") || name.StartsWith ("ntdll.dll!ntwaitforworkviaworkerfactory")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for work from a worker factory:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,analyzeWaitMenuItem_Click,The following statement contains a magic number: if (name.StartsWith ("ntdll.dll!ntqueryobject") || name.StartsWith ("ntdll.dll!zwqueryobject")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	// Use the KiFastSystemCallRet args if the handle we have is wrong.  	if (handle.ToInt32 () % 2 != 0 || handle == IntPtr.Zero)  		handle = lastParams [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is querying an object (most likely a named pipe):");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwreadfile") || name.StartsWith ("ntdll.dll!ntreadfile") || name.StartsWith ("ntdll.dll!zwwritefile") || name.StartsWith ("ntdll.dll!ntwritefile")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a named pipe or a file:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwremoveiocompletion") || name.StartsWith ("ntdll.dll!ntremoveiocompletion")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an I/O completion object:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwreplywaitreceiveport") || name.StartsWith ("ntdll.dll!ntreplywaitreceiveport") || name.StartsWith ("ntdll.dll!zwrequestwaitreplyport") || name.StartsWith ("ntdll.dll!ntrequestwaitreplyport") || name.StartsWith ("ntdll.dll!zwalpcsendwaitreceiveport") || name.StartsWith ("ntdll.dll!ntalpcsendwaitreceiveport")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a LPC port:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!ntsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!zwsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!ntsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaithigheventpair") || name.StartsWith ("ntdll.dll!ntwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaitloweventpair") || name.StartsWith ("ntdll.dll!ntwaitloweventpair")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	// Use the KiFastSystemCallRet args if the handle we have is wrong.  	if (handle.ToInt32 () % 2 != 0)  		handle = lastParams [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for an event pair:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("user32.dll!ntusergetmessage") || name.StartsWith ("user32.dll!ntuserwaitmessage")) {  	found = true;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a USER message.");  }  else if (name.StartsWith ("ntdll.dll!zwwaitfordebugevent") || name.StartsWith ("ntdll.dll!ntwaitfordebugevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a debug event:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforkeyedevent") || name.StartsWith ("ntdll.dll!ntwaitforkeyedevent") || name.StartsWith ("ntdll.dll!zwreleasekeyedevent") || name.StartsWith ("ntdll.dll!ntreleasekeyedevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	IntPtr key = stackFrame.Params [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for a keyed event (key 0x" + key.ToString ("x") + "):");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitformultipleobjects") || name.StartsWith ("ntdll.dll!ntwaitformultipleobjects") || name.StartsWith ("kernel32.dll!waitformultipleobjects")) {  	found = true;  	int handleCount = stackFrame.Params [0].ToInt32 ();  	IntPtr handleAddress = stackFrame.Params [1];  	WaitType waitType = (WaitType)stackFrame.Params [2].ToInt32 ();  	bool alertable = stackFrame.Params [3].ToInt32 () != 0;  	// use the KiFastSystemCallRet args if we have the wrong args  	if (handleCount > 64) {  		handleCount = lastParams [1].ToInt32 ();  		handleAddress = lastParams [2];  		waitType = (WaitType)lastParams [3].ToInt32 ();  	}  	IntPtr* handles = stackalloc IntPtr[handleCount];  	phandle.ReadMemory (handleAddress' handles' handleCount * IntPtr.Size);  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + "' wait type: " + waitType.ToString () + ") for:");  	for (int i = 0; i < handleCount; i++) {  		sb.AppendLine (this.GetHandleString (_pid' handles [i]));  	}  }  else if (name.StartsWith ("ntdll.dll!zwwaitforsingleobject") || name.StartsWith ("ntdll.dll!ntwaitforsingleobject") || name.StartsWith ("kernel32.dll!waitforsingleobject")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	bool alertable = stackFrame.Params [1].ToInt32 () != 0;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + ") for:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforworkviaworkerfactory") || name.StartsWith ("ntdll.dll!ntwaitforworkviaworkerfactory")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for work from a worker factory:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,analyzeWaitMenuItem_Click,The following statement contains a magic number: if (name.StartsWith ("ntdll.dll!ntqueryobject") || name.StartsWith ("ntdll.dll!zwqueryobject")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	// Use the KiFastSystemCallRet args if the handle we have is wrong.  	if (handle.ToInt32 () % 2 != 0 || handle == IntPtr.Zero)  		handle = lastParams [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is querying an object (most likely a named pipe):");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwreadfile") || name.StartsWith ("ntdll.dll!ntreadfile") || name.StartsWith ("ntdll.dll!zwwritefile") || name.StartsWith ("ntdll.dll!ntwritefile")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a named pipe or a file:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwremoveiocompletion") || name.StartsWith ("ntdll.dll!ntremoveiocompletion")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an I/O completion object:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwreplywaitreceiveport") || name.StartsWith ("ntdll.dll!ntreplywaitreceiveport") || name.StartsWith ("ntdll.dll!zwrequestwaitreplyport") || name.StartsWith ("ntdll.dll!ntrequestwaitreplyport") || name.StartsWith ("ntdll.dll!zwalpcsendwaitreceiveport") || name.StartsWith ("ntdll.dll!ntalpcsendwaitreceiveport")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a LPC port:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!ntsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!zwsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!ntsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaithigheventpair") || name.StartsWith ("ntdll.dll!ntwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaitloweventpair") || name.StartsWith ("ntdll.dll!ntwaitloweventpair")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	// Use the KiFastSystemCallRet args if the handle we have is wrong.  	if (handle.ToInt32 () % 2 != 0)  		handle = lastParams [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for an event pair:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("user32.dll!ntusergetmessage") || name.StartsWith ("user32.dll!ntuserwaitmessage")) {  	found = true;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a USER message.");  }  else if (name.StartsWith ("ntdll.dll!zwwaitfordebugevent") || name.StartsWith ("ntdll.dll!ntwaitfordebugevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a debug event:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforkeyedevent") || name.StartsWith ("ntdll.dll!ntwaitforkeyedevent") || name.StartsWith ("ntdll.dll!zwreleasekeyedevent") || name.StartsWith ("ntdll.dll!ntreleasekeyedevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	IntPtr key = stackFrame.Params [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for a keyed event (key 0x" + key.ToString ("x") + "):");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitformultipleobjects") || name.StartsWith ("ntdll.dll!ntwaitformultipleobjects") || name.StartsWith ("kernel32.dll!waitformultipleobjects")) {  	found = true;  	int handleCount = stackFrame.Params [0].ToInt32 ();  	IntPtr handleAddress = stackFrame.Params [1];  	WaitType waitType = (WaitType)stackFrame.Params [2].ToInt32 ();  	bool alertable = stackFrame.Params [3].ToInt32 () != 0;  	// use the KiFastSystemCallRet args if we have the wrong args  	if (handleCount > 64) {  		handleCount = lastParams [1].ToInt32 ();  		handleAddress = lastParams [2];  		waitType = (WaitType)lastParams [3].ToInt32 ();  	}  	IntPtr* handles = stackalloc IntPtr[handleCount];  	phandle.ReadMemory (handleAddress' handles' handleCount * IntPtr.Size);  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + "' wait type: " + waitType.ToString () + ") for:");  	for (int i = 0; i < handleCount; i++) {  		sb.AppendLine (this.GetHandleString (_pid' handles [i]));  	}  }  else if (name.StartsWith ("ntdll.dll!zwwaitforsingleobject") || name.StartsWith ("ntdll.dll!ntwaitforsingleobject") || name.StartsWith ("kernel32.dll!waitforsingleobject")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	bool alertable = stackFrame.Params [1].ToInt32 () != 0;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + ") for:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforworkviaworkerfactory") || name.StartsWith ("ntdll.dll!ntwaitforworkviaworkerfactory")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for work from a worker factory:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,analyzeWaitMenuItem_Click,The following statement contains a magic number: if (handle.ToInt32 () % 2 != 0 || handle == IntPtr.Zero)  	handle = lastParams [1];  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,analyzeWaitMenuItem_Click,The following statement contains a magic number: if (name.StartsWith ("ntdll.dll!zwreadfile") || name.StartsWith ("ntdll.dll!ntreadfile") || name.StartsWith ("ntdll.dll!zwwritefile") || name.StartsWith ("ntdll.dll!ntwritefile")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a named pipe or a file:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwremoveiocompletion") || name.StartsWith ("ntdll.dll!ntremoveiocompletion")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an I/O completion object:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwreplywaitreceiveport") || name.StartsWith ("ntdll.dll!ntreplywaitreceiveport") || name.StartsWith ("ntdll.dll!zwrequestwaitreplyport") || name.StartsWith ("ntdll.dll!ntrequestwaitreplyport") || name.StartsWith ("ntdll.dll!zwalpcsendwaitreceiveport") || name.StartsWith ("ntdll.dll!ntalpcsendwaitreceiveport")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a LPC port:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!ntsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!zwsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!ntsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaithigheventpair") || name.StartsWith ("ntdll.dll!ntwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaitloweventpair") || name.StartsWith ("ntdll.dll!ntwaitloweventpair")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	// Use the KiFastSystemCallRet args if the handle we have is wrong.  	if (handle.ToInt32 () % 2 != 0)  		handle = lastParams [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for an event pair:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("user32.dll!ntusergetmessage") || name.StartsWith ("user32.dll!ntuserwaitmessage")) {  	found = true;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a USER message.");  }  else if (name.StartsWith ("ntdll.dll!zwwaitfordebugevent") || name.StartsWith ("ntdll.dll!ntwaitfordebugevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a debug event:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforkeyedevent") || name.StartsWith ("ntdll.dll!ntwaitforkeyedevent") || name.StartsWith ("ntdll.dll!zwreleasekeyedevent") || name.StartsWith ("ntdll.dll!ntreleasekeyedevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	IntPtr key = stackFrame.Params [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for a keyed event (key 0x" + key.ToString ("x") + "):");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitformultipleobjects") || name.StartsWith ("ntdll.dll!ntwaitformultipleobjects") || name.StartsWith ("kernel32.dll!waitformultipleobjects")) {  	found = true;  	int handleCount = stackFrame.Params [0].ToInt32 ();  	IntPtr handleAddress = stackFrame.Params [1];  	WaitType waitType = (WaitType)stackFrame.Params [2].ToInt32 ();  	bool alertable = stackFrame.Params [3].ToInt32 () != 0;  	// use the KiFastSystemCallRet args if we have the wrong args  	if (handleCount > 64) {  		handleCount = lastParams [1].ToInt32 ();  		handleAddress = lastParams [2];  		waitType = (WaitType)lastParams [3].ToInt32 ();  	}  	IntPtr* handles = stackalloc IntPtr[handleCount];  	phandle.ReadMemory (handleAddress' handles' handleCount * IntPtr.Size);  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + "' wait type: " + waitType.ToString () + ") for:");  	for (int i = 0; i < handleCount; i++) {  		sb.AppendLine (this.GetHandleString (_pid' handles [i]));  	}  }  else if (name.StartsWith ("ntdll.dll!zwwaitforsingleobject") || name.StartsWith ("ntdll.dll!ntwaitforsingleobject") || name.StartsWith ("kernel32.dll!waitforsingleobject")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	bool alertable = stackFrame.Params [1].ToInt32 () != 0;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + ") for:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforworkviaworkerfactory") || name.StartsWith ("ntdll.dll!ntwaitforworkviaworkerfactory")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for work from a worker factory:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,analyzeWaitMenuItem_Click,The following statement contains a magic number: if (name.StartsWith ("ntdll.dll!zwreadfile") || name.StartsWith ("ntdll.dll!ntreadfile") || name.StartsWith ("ntdll.dll!zwwritefile") || name.StartsWith ("ntdll.dll!ntwritefile")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a named pipe or a file:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwremoveiocompletion") || name.StartsWith ("ntdll.dll!ntremoveiocompletion")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an I/O completion object:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwreplywaitreceiveport") || name.StartsWith ("ntdll.dll!ntreplywaitreceiveport") || name.StartsWith ("ntdll.dll!zwrequestwaitreplyport") || name.StartsWith ("ntdll.dll!ntrequestwaitreplyport") || name.StartsWith ("ntdll.dll!zwalpcsendwaitreceiveport") || name.StartsWith ("ntdll.dll!ntalpcsendwaitreceiveport")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a LPC port:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!ntsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!zwsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!ntsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaithigheventpair") || name.StartsWith ("ntdll.dll!ntwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaitloweventpair") || name.StartsWith ("ntdll.dll!ntwaitloweventpair")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	// Use the KiFastSystemCallRet args if the handle we have is wrong.  	if (handle.ToInt32 () % 2 != 0)  		handle = lastParams [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for an event pair:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("user32.dll!ntusergetmessage") || name.StartsWith ("user32.dll!ntuserwaitmessage")) {  	found = true;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a USER message.");  }  else if (name.StartsWith ("ntdll.dll!zwwaitfordebugevent") || name.StartsWith ("ntdll.dll!ntwaitfordebugevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a debug event:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforkeyedevent") || name.StartsWith ("ntdll.dll!ntwaitforkeyedevent") || name.StartsWith ("ntdll.dll!zwreleasekeyedevent") || name.StartsWith ("ntdll.dll!ntreleasekeyedevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	IntPtr key = stackFrame.Params [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for a keyed event (key 0x" + key.ToString ("x") + "):");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitformultipleobjects") || name.StartsWith ("ntdll.dll!ntwaitformultipleobjects") || name.StartsWith ("kernel32.dll!waitformultipleobjects")) {  	found = true;  	int handleCount = stackFrame.Params [0].ToInt32 ();  	IntPtr handleAddress = stackFrame.Params [1];  	WaitType waitType = (WaitType)stackFrame.Params [2].ToInt32 ();  	bool alertable = stackFrame.Params [3].ToInt32 () != 0;  	// use the KiFastSystemCallRet args if we have the wrong args  	if (handleCount > 64) {  		handleCount = lastParams [1].ToInt32 ();  		handleAddress = lastParams [2];  		waitType = (WaitType)lastParams [3].ToInt32 ();  	}  	IntPtr* handles = stackalloc IntPtr[handleCount];  	phandle.ReadMemory (handleAddress' handles' handleCount * IntPtr.Size);  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + "' wait type: " + waitType.ToString () + ") for:");  	for (int i = 0; i < handleCount; i++) {  		sb.AppendLine (this.GetHandleString (_pid' handles [i]));  	}  }  else if (name.StartsWith ("ntdll.dll!zwwaitforsingleobject") || name.StartsWith ("ntdll.dll!ntwaitforsingleobject") || name.StartsWith ("kernel32.dll!waitforsingleobject")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	bool alertable = stackFrame.Params [1].ToInt32 () != 0;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + ") for:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforworkviaworkerfactory") || name.StartsWith ("ntdll.dll!ntwaitforworkviaworkerfactory")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for work from a worker factory:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,analyzeWaitMenuItem_Click,The following statement contains a magic number: if (name.StartsWith ("ntdll.dll!zwreadfile") || name.StartsWith ("ntdll.dll!ntreadfile") || name.StartsWith ("ntdll.dll!zwwritefile") || name.StartsWith ("ntdll.dll!ntwritefile")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a named pipe or a file:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwremoveiocompletion") || name.StartsWith ("ntdll.dll!ntremoveiocompletion")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an I/O completion object:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwreplywaitreceiveport") || name.StartsWith ("ntdll.dll!ntreplywaitreceiveport") || name.StartsWith ("ntdll.dll!zwrequestwaitreplyport") || name.StartsWith ("ntdll.dll!ntrequestwaitreplyport") || name.StartsWith ("ntdll.dll!zwalpcsendwaitreceiveport") || name.StartsWith ("ntdll.dll!ntalpcsendwaitreceiveport")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a LPC port:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!ntsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!zwsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!ntsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaithigheventpair") || name.StartsWith ("ntdll.dll!ntwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaitloweventpair") || name.StartsWith ("ntdll.dll!ntwaitloweventpair")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	// Use the KiFastSystemCallRet args if the handle we have is wrong.  	if (handle.ToInt32 () % 2 != 0)  		handle = lastParams [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for an event pair:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("user32.dll!ntusergetmessage") || name.StartsWith ("user32.dll!ntuserwaitmessage")) {  	found = true;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a USER message.");  }  else if (name.StartsWith ("ntdll.dll!zwwaitfordebugevent") || name.StartsWith ("ntdll.dll!ntwaitfordebugevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a debug event:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforkeyedevent") || name.StartsWith ("ntdll.dll!ntwaitforkeyedevent") || name.StartsWith ("ntdll.dll!zwreleasekeyedevent") || name.StartsWith ("ntdll.dll!ntreleasekeyedevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	IntPtr key = stackFrame.Params [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for a keyed event (key 0x" + key.ToString ("x") + "):");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitformultipleobjects") || name.StartsWith ("ntdll.dll!ntwaitformultipleobjects") || name.StartsWith ("kernel32.dll!waitformultipleobjects")) {  	found = true;  	int handleCount = stackFrame.Params [0].ToInt32 ();  	IntPtr handleAddress = stackFrame.Params [1];  	WaitType waitType = (WaitType)stackFrame.Params [2].ToInt32 ();  	bool alertable = stackFrame.Params [3].ToInt32 () != 0;  	// use the KiFastSystemCallRet args if we have the wrong args  	if (handleCount > 64) {  		handleCount = lastParams [1].ToInt32 ();  		handleAddress = lastParams [2];  		waitType = (WaitType)lastParams [3].ToInt32 ();  	}  	IntPtr* handles = stackalloc IntPtr[handleCount];  	phandle.ReadMemory (handleAddress' handles' handleCount * IntPtr.Size);  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + "' wait type: " + waitType.ToString () + ") for:");  	for (int i = 0; i < handleCount; i++) {  		sb.AppendLine (this.GetHandleString (_pid' handles [i]));  	}  }  else if (name.StartsWith ("ntdll.dll!zwwaitforsingleobject") || name.StartsWith ("ntdll.dll!ntwaitforsingleobject") || name.StartsWith ("kernel32.dll!waitforsingleobject")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	bool alertable = stackFrame.Params [1].ToInt32 () != 0;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + ") for:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforworkviaworkerfactory") || name.StartsWith ("ntdll.dll!ntwaitforworkviaworkerfactory")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for work from a worker factory:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,analyzeWaitMenuItem_Click,The following statement contains a magic number: if (name.StartsWith ("ntdll.dll!zwreadfile") || name.StartsWith ("ntdll.dll!ntreadfile") || name.StartsWith ("ntdll.dll!zwwritefile") || name.StartsWith ("ntdll.dll!ntwritefile")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a named pipe or a file:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwremoveiocompletion") || name.StartsWith ("ntdll.dll!ntremoveiocompletion")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an I/O completion object:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwreplywaitreceiveport") || name.StartsWith ("ntdll.dll!ntreplywaitreceiveport") || name.StartsWith ("ntdll.dll!zwrequestwaitreplyport") || name.StartsWith ("ntdll.dll!ntrequestwaitreplyport") || name.StartsWith ("ntdll.dll!zwalpcsendwaitreceiveport") || name.StartsWith ("ntdll.dll!ntalpcsendwaitreceiveport")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a LPC port:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!ntsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!zwsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!ntsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaithigheventpair") || name.StartsWith ("ntdll.dll!ntwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaitloweventpair") || name.StartsWith ("ntdll.dll!ntwaitloweventpair")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	// Use the KiFastSystemCallRet args if the handle we have is wrong.  	if (handle.ToInt32 () % 2 != 0)  		handle = lastParams [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for an event pair:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("user32.dll!ntusergetmessage") || name.StartsWith ("user32.dll!ntuserwaitmessage")) {  	found = true;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a USER message.");  }  else if (name.StartsWith ("ntdll.dll!zwwaitfordebugevent") || name.StartsWith ("ntdll.dll!ntwaitfordebugevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a debug event:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforkeyedevent") || name.StartsWith ("ntdll.dll!ntwaitforkeyedevent") || name.StartsWith ("ntdll.dll!zwreleasekeyedevent") || name.StartsWith ("ntdll.dll!ntreleasekeyedevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	IntPtr key = stackFrame.Params [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for a keyed event (key 0x" + key.ToString ("x") + "):");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitformultipleobjects") || name.StartsWith ("ntdll.dll!ntwaitformultipleobjects") || name.StartsWith ("kernel32.dll!waitformultipleobjects")) {  	found = true;  	int handleCount = stackFrame.Params [0].ToInt32 ();  	IntPtr handleAddress = stackFrame.Params [1];  	WaitType waitType = (WaitType)stackFrame.Params [2].ToInt32 ();  	bool alertable = stackFrame.Params [3].ToInt32 () != 0;  	// use the KiFastSystemCallRet args if we have the wrong args  	if (handleCount > 64) {  		handleCount = lastParams [1].ToInt32 ();  		handleAddress = lastParams [2];  		waitType = (WaitType)lastParams [3].ToInt32 ();  	}  	IntPtr* handles = stackalloc IntPtr[handleCount];  	phandle.ReadMemory (handleAddress' handles' handleCount * IntPtr.Size);  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + "' wait type: " + waitType.ToString () + ") for:");  	for (int i = 0; i < handleCount; i++) {  		sb.AppendLine (this.GetHandleString (_pid' handles [i]));  	}  }  else if (name.StartsWith ("ntdll.dll!zwwaitforsingleobject") || name.StartsWith ("ntdll.dll!ntwaitforsingleobject") || name.StartsWith ("kernel32.dll!waitforsingleobject")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	bool alertable = stackFrame.Params [1].ToInt32 () != 0;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + ") for:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforworkviaworkerfactory") || name.StartsWith ("ntdll.dll!ntwaitforworkviaworkerfactory")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for work from a worker factory:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,analyzeWaitMenuItem_Click,The following statement contains a magic number: if (name.StartsWith ("ntdll.dll!zwreadfile") || name.StartsWith ("ntdll.dll!ntreadfile") || name.StartsWith ("ntdll.dll!zwwritefile") || name.StartsWith ("ntdll.dll!ntwritefile")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a named pipe or a file:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwremoveiocompletion") || name.StartsWith ("ntdll.dll!ntremoveiocompletion")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an I/O completion object:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwreplywaitreceiveport") || name.StartsWith ("ntdll.dll!ntreplywaitreceiveport") || name.StartsWith ("ntdll.dll!zwrequestwaitreplyport") || name.StartsWith ("ntdll.dll!ntrequestwaitreplyport") || name.StartsWith ("ntdll.dll!zwalpcsendwaitreceiveport") || name.StartsWith ("ntdll.dll!ntalpcsendwaitreceiveport")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a LPC port:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!ntsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!zwsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!ntsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaithigheventpair") || name.StartsWith ("ntdll.dll!ntwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaitloweventpair") || name.StartsWith ("ntdll.dll!ntwaitloweventpair")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	// Use the KiFastSystemCallRet args if the handle we have is wrong.  	if (handle.ToInt32 () % 2 != 0)  		handle = lastParams [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for an event pair:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("user32.dll!ntusergetmessage") || name.StartsWith ("user32.dll!ntuserwaitmessage")) {  	found = true;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a USER message.");  }  else if (name.StartsWith ("ntdll.dll!zwwaitfordebugevent") || name.StartsWith ("ntdll.dll!ntwaitfordebugevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a debug event:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforkeyedevent") || name.StartsWith ("ntdll.dll!ntwaitforkeyedevent") || name.StartsWith ("ntdll.dll!zwreleasekeyedevent") || name.StartsWith ("ntdll.dll!ntreleasekeyedevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	IntPtr key = stackFrame.Params [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for a keyed event (key 0x" + key.ToString ("x") + "):");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitformultipleobjects") || name.StartsWith ("ntdll.dll!ntwaitformultipleobjects") || name.StartsWith ("kernel32.dll!waitformultipleobjects")) {  	found = true;  	int handleCount = stackFrame.Params [0].ToInt32 ();  	IntPtr handleAddress = stackFrame.Params [1];  	WaitType waitType = (WaitType)stackFrame.Params [2].ToInt32 ();  	bool alertable = stackFrame.Params [3].ToInt32 () != 0;  	// use the KiFastSystemCallRet args if we have the wrong args  	if (handleCount > 64) {  		handleCount = lastParams [1].ToInt32 ();  		handleAddress = lastParams [2];  		waitType = (WaitType)lastParams [3].ToInt32 ();  	}  	IntPtr* handles = stackalloc IntPtr[handleCount];  	phandle.ReadMemory (handleAddress' handles' handleCount * IntPtr.Size);  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + "' wait type: " + waitType.ToString () + ") for:");  	for (int i = 0; i < handleCount; i++) {  		sb.AppendLine (this.GetHandleString (_pid' handles [i]));  	}  }  else if (name.StartsWith ("ntdll.dll!zwwaitforsingleobject") || name.StartsWith ("ntdll.dll!ntwaitforsingleobject") || name.StartsWith ("kernel32.dll!waitforsingleobject")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	bool alertable = stackFrame.Params [1].ToInt32 () != 0;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + ") for:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforworkviaworkerfactory") || name.StartsWith ("ntdll.dll!ntwaitforworkviaworkerfactory")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for work from a worker factory:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,analyzeWaitMenuItem_Click,The following statement contains a magic number: if (name.StartsWith ("ntdll.dll!zwreadfile") || name.StartsWith ("ntdll.dll!ntreadfile") || name.StartsWith ("ntdll.dll!zwwritefile") || name.StartsWith ("ntdll.dll!ntwritefile")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a named pipe or a file:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwremoveiocompletion") || name.StartsWith ("ntdll.dll!ntremoveiocompletion")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an I/O completion object:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwreplywaitreceiveport") || name.StartsWith ("ntdll.dll!ntreplywaitreceiveport") || name.StartsWith ("ntdll.dll!zwrequestwaitreplyport") || name.StartsWith ("ntdll.dll!ntrequestwaitreplyport") || name.StartsWith ("ntdll.dll!zwalpcsendwaitreceiveport") || name.StartsWith ("ntdll.dll!ntalpcsendwaitreceiveport")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a LPC port:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!ntsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!zwsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!ntsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaithigheventpair") || name.StartsWith ("ntdll.dll!ntwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaitloweventpair") || name.StartsWith ("ntdll.dll!ntwaitloweventpair")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	// Use the KiFastSystemCallRet args if the handle we have is wrong.  	if (handle.ToInt32 () % 2 != 0)  		handle = lastParams [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for an event pair:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("user32.dll!ntusergetmessage") || name.StartsWith ("user32.dll!ntuserwaitmessage")) {  	found = true;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a USER message.");  }  else if (name.StartsWith ("ntdll.dll!zwwaitfordebugevent") || name.StartsWith ("ntdll.dll!ntwaitfordebugevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a debug event:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforkeyedevent") || name.StartsWith ("ntdll.dll!ntwaitforkeyedevent") || name.StartsWith ("ntdll.dll!zwreleasekeyedevent") || name.StartsWith ("ntdll.dll!ntreleasekeyedevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	IntPtr key = stackFrame.Params [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for a keyed event (key 0x" + key.ToString ("x") + "):");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitformultipleobjects") || name.StartsWith ("ntdll.dll!ntwaitformultipleobjects") || name.StartsWith ("kernel32.dll!waitformultipleobjects")) {  	found = true;  	int handleCount = stackFrame.Params [0].ToInt32 ();  	IntPtr handleAddress = stackFrame.Params [1];  	WaitType waitType = (WaitType)stackFrame.Params [2].ToInt32 ();  	bool alertable = stackFrame.Params [3].ToInt32 () != 0;  	// use the KiFastSystemCallRet args if we have the wrong args  	if (handleCount > 64) {  		handleCount = lastParams [1].ToInt32 ();  		handleAddress = lastParams [2];  		waitType = (WaitType)lastParams [3].ToInt32 ();  	}  	IntPtr* handles = stackalloc IntPtr[handleCount];  	phandle.ReadMemory (handleAddress' handles' handleCount * IntPtr.Size);  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + "' wait type: " + waitType.ToString () + ") for:");  	for (int i = 0; i < handleCount; i++) {  		sb.AppendLine (this.GetHandleString (_pid' handles [i]));  	}  }  else if (name.StartsWith ("ntdll.dll!zwwaitforsingleobject") || name.StartsWith ("ntdll.dll!ntwaitforsingleobject") || name.StartsWith ("kernel32.dll!waitforsingleobject")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	bool alertable = stackFrame.Params [1].ToInt32 () != 0;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + ") for:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforworkviaworkerfactory") || name.StartsWith ("ntdll.dll!ntwaitforworkviaworkerfactory")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for work from a worker factory:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,analyzeWaitMenuItem_Click,The following statement contains a magic number: if (name.StartsWith ("ntdll.dll!zwremoveiocompletion") || name.StartsWith ("ntdll.dll!ntremoveiocompletion")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an I/O completion object:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwreplywaitreceiveport") || name.StartsWith ("ntdll.dll!ntreplywaitreceiveport") || name.StartsWith ("ntdll.dll!zwrequestwaitreplyport") || name.StartsWith ("ntdll.dll!ntrequestwaitreplyport") || name.StartsWith ("ntdll.dll!zwalpcsendwaitreceiveport") || name.StartsWith ("ntdll.dll!ntalpcsendwaitreceiveport")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a LPC port:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!ntsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!zwsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!ntsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaithigheventpair") || name.StartsWith ("ntdll.dll!ntwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaitloweventpair") || name.StartsWith ("ntdll.dll!ntwaitloweventpair")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	// Use the KiFastSystemCallRet args if the handle we have is wrong.  	if (handle.ToInt32 () % 2 != 0)  		handle = lastParams [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for an event pair:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("user32.dll!ntusergetmessage") || name.StartsWith ("user32.dll!ntuserwaitmessage")) {  	found = true;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a USER message.");  }  else if (name.StartsWith ("ntdll.dll!zwwaitfordebugevent") || name.StartsWith ("ntdll.dll!ntwaitfordebugevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a debug event:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforkeyedevent") || name.StartsWith ("ntdll.dll!ntwaitforkeyedevent") || name.StartsWith ("ntdll.dll!zwreleasekeyedevent") || name.StartsWith ("ntdll.dll!ntreleasekeyedevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	IntPtr key = stackFrame.Params [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for a keyed event (key 0x" + key.ToString ("x") + "):");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitformultipleobjects") || name.StartsWith ("ntdll.dll!ntwaitformultipleobjects") || name.StartsWith ("kernel32.dll!waitformultipleobjects")) {  	found = true;  	int handleCount = stackFrame.Params [0].ToInt32 ();  	IntPtr handleAddress = stackFrame.Params [1];  	WaitType waitType = (WaitType)stackFrame.Params [2].ToInt32 ();  	bool alertable = stackFrame.Params [3].ToInt32 () != 0;  	// use the KiFastSystemCallRet args if we have the wrong args  	if (handleCount > 64) {  		handleCount = lastParams [1].ToInt32 ();  		handleAddress = lastParams [2];  		waitType = (WaitType)lastParams [3].ToInt32 ();  	}  	IntPtr* handles = stackalloc IntPtr[handleCount];  	phandle.ReadMemory (handleAddress' handles' handleCount * IntPtr.Size);  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + "' wait type: " + waitType.ToString () + ") for:");  	for (int i = 0; i < handleCount; i++) {  		sb.AppendLine (this.GetHandleString (_pid' handles [i]));  	}  }  else if (name.StartsWith ("ntdll.dll!zwwaitforsingleobject") || name.StartsWith ("ntdll.dll!ntwaitforsingleobject") || name.StartsWith ("kernel32.dll!waitforsingleobject")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	bool alertable = stackFrame.Params [1].ToInt32 () != 0;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + ") for:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforworkviaworkerfactory") || name.StartsWith ("ntdll.dll!ntwaitforworkviaworkerfactory")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for work from a worker factory:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,analyzeWaitMenuItem_Click,The following statement contains a magic number: if (name.StartsWith ("ntdll.dll!zwremoveiocompletion") || name.StartsWith ("ntdll.dll!ntremoveiocompletion")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an I/O completion object:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwreplywaitreceiveport") || name.StartsWith ("ntdll.dll!ntreplywaitreceiveport") || name.StartsWith ("ntdll.dll!zwrequestwaitreplyport") || name.StartsWith ("ntdll.dll!ntrequestwaitreplyport") || name.StartsWith ("ntdll.dll!zwalpcsendwaitreceiveport") || name.StartsWith ("ntdll.dll!ntalpcsendwaitreceiveport")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a LPC port:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!ntsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!zwsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!ntsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaithigheventpair") || name.StartsWith ("ntdll.dll!ntwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaitloweventpair") || name.StartsWith ("ntdll.dll!ntwaitloweventpair")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	// Use the KiFastSystemCallRet args if the handle we have is wrong.  	if (handle.ToInt32 () % 2 != 0)  		handle = lastParams [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for an event pair:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("user32.dll!ntusergetmessage") || name.StartsWith ("user32.dll!ntuserwaitmessage")) {  	found = true;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a USER message.");  }  else if (name.StartsWith ("ntdll.dll!zwwaitfordebugevent") || name.StartsWith ("ntdll.dll!ntwaitfordebugevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a debug event:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforkeyedevent") || name.StartsWith ("ntdll.dll!ntwaitforkeyedevent") || name.StartsWith ("ntdll.dll!zwreleasekeyedevent") || name.StartsWith ("ntdll.dll!ntreleasekeyedevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	IntPtr key = stackFrame.Params [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for a keyed event (key 0x" + key.ToString ("x") + "):");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitformultipleobjects") || name.StartsWith ("ntdll.dll!ntwaitformultipleobjects") || name.StartsWith ("kernel32.dll!waitformultipleobjects")) {  	found = true;  	int handleCount = stackFrame.Params [0].ToInt32 ();  	IntPtr handleAddress = stackFrame.Params [1];  	WaitType waitType = (WaitType)stackFrame.Params [2].ToInt32 ();  	bool alertable = stackFrame.Params [3].ToInt32 () != 0;  	// use the KiFastSystemCallRet args if we have the wrong args  	if (handleCount > 64) {  		handleCount = lastParams [1].ToInt32 ();  		handleAddress = lastParams [2];  		waitType = (WaitType)lastParams [3].ToInt32 ();  	}  	IntPtr* handles = stackalloc IntPtr[handleCount];  	phandle.ReadMemory (handleAddress' handles' handleCount * IntPtr.Size);  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + "' wait type: " + waitType.ToString () + ") for:");  	for (int i = 0; i < handleCount; i++) {  		sb.AppendLine (this.GetHandleString (_pid' handles [i]));  	}  }  else if (name.StartsWith ("ntdll.dll!zwwaitforsingleobject") || name.StartsWith ("ntdll.dll!ntwaitforsingleobject") || name.StartsWith ("kernel32.dll!waitforsingleobject")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	bool alertable = stackFrame.Params [1].ToInt32 () != 0;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + ") for:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforworkviaworkerfactory") || name.StartsWith ("ntdll.dll!ntwaitforworkviaworkerfactory")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for work from a worker factory:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,analyzeWaitMenuItem_Click,The following statement contains a magic number: if (name.StartsWith ("ntdll.dll!zwremoveiocompletion") || name.StartsWith ("ntdll.dll!ntremoveiocompletion")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an I/O completion object:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwreplywaitreceiveport") || name.StartsWith ("ntdll.dll!ntreplywaitreceiveport") || name.StartsWith ("ntdll.dll!zwrequestwaitreplyport") || name.StartsWith ("ntdll.dll!ntrequestwaitreplyport") || name.StartsWith ("ntdll.dll!zwalpcsendwaitreceiveport") || name.StartsWith ("ntdll.dll!ntalpcsendwaitreceiveport")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a LPC port:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!ntsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!zwsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!ntsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaithigheventpair") || name.StartsWith ("ntdll.dll!ntwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaitloweventpair") || name.StartsWith ("ntdll.dll!ntwaitloweventpair")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	// Use the KiFastSystemCallRet args if the handle we have is wrong.  	if (handle.ToInt32 () % 2 != 0)  		handle = lastParams [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for an event pair:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("user32.dll!ntusergetmessage") || name.StartsWith ("user32.dll!ntuserwaitmessage")) {  	found = true;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a USER message.");  }  else if (name.StartsWith ("ntdll.dll!zwwaitfordebugevent") || name.StartsWith ("ntdll.dll!ntwaitfordebugevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a debug event:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforkeyedevent") || name.StartsWith ("ntdll.dll!ntwaitforkeyedevent") || name.StartsWith ("ntdll.dll!zwreleasekeyedevent") || name.StartsWith ("ntdll.dll!ntreleasekeyedevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	IntPtr key = stackFrame.Params [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for a keyed event (key 0x" + key.ToString ("x") + "):");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitformultipleobjects") || name.StartsWith ("ntdll.dll!ntwaitformultipleobjects") || name.StartsWith ("kernel32.dll!waitformultipleobjects")) {  	found = true;  	int handleCount = stackFrame.Params [0].ToInt32 ();  	IntPtr handleAddress = stackFrame.Params [1];  	WaitType waitType = (WaitType)stackFrame.Params [2].ToInt32 ();  	bool alertable = stackFrame.Params [3].ToInt32 () != 0;  	// use the KiFastSystemCallRet args if we have the wrong args  	if (handleCount > 64) {  		handleCount = lastParams [1].ToInt32 ();  		handleAddress = lastParams [2];  		waitType = (WaitType)lastParams [3].ToInt32 ();  	}  	IntPtr* handles = stackalloc IntPtr[handleCount];  	phandle.ReadMemory (handleAddress' handles' handleCount * IntPtr.Size);  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + "' wait type: " + waitType.ToString () + ") for:");  	for (int i = 0; i < handleCount; i++) {  		sb.AppendLine (this.GetHandleString (_pid' handles [i]));  	}  }  else if (name.StartsWith ("ntdll.dll!zwwaitforsingleobject") || name.StartsWith ("ntdll.dll!ntwaitforsingleobject") || name.StartsWith ("kernel32.dll!waitforsingleobject")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	bool alertable = stackFrame.Params [1].ToInt32 () != 0;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + ") for:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforworkviaworkerfactory") || name.StartsWith ("ntdll.dll!ntwaitforworkviaworkerfactory")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for work from a worker factory:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,analyzeWaitMenuItem_Click,The following statement contains a magic number: if (name.StartsWith ("ntdll.dll!zwremoveiocompletion") || name.StartsWith ("ntdll.dll!ntremoveiocompletion")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an I/O completion object:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwreplywaitreceiveport") || name.StartsWith ("ntdll.dll!ntreplywaitreceiveport") || name.StartsWith ("ntdll.dll!zwrequestwaitreplyport") || name.StartsWith ("ntdll.dll!ntrequestwaitreplyport") || name.StartsWith ("ntdll.dll!zwalpcsendwaitreceiveport") || name.StartsWith ("ntdll.dll!ntalpcsendwaitreceiveport")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a LPC port:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!ntsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!zwsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!ntsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaithigheventpair") || name.StartsWith ("ntdll.dll!ntwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaitloweventpair") || name.StartsWith ("ntdll.dll!ntwaitloweventpair")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	// Use the KiFastSystemCallRet args if the handle we have is wrong.  	if (handle.ToInt32 () % 2 != 0)  		handle = lastParams [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for an event pair:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("user32.dll!ntusergetmessage") || name.StartsWith ("user32.dll!ntuserwaitmessage")) {  	found = true;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a USER message.");  }  else if (name.StartsWith ("ntdll.dll!zwwaitfordebugevent") || name.StartsWith ("ntdll.dll!ntwaitfordebugevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a debug event:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforkeyedevent") || name.StartsWith ("ntdll.dll!ntwaitforkeyedevent") || name.StartsWith ("ntdll.dll!zwreleasekeyedevent") || name.StartsWith ("ntdll.dll!ntreleasekeyedevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	IntPtr key = stackFrame.Params [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for a keyed event (key 0x" + key.ToString ("x") + "):");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitformultipleobjects") || name.StartsWith ("ntdll.dll!ntwaitformultipleobjects") || name.StartsWith ("kernel32.dll!waitformultipleobjects")) {  	found = true;  	int handleCount = stackFrame.Params [0].ToInt32 ();  	IntPtr handleAddress = stackFrame.Params [1];  	WaitType waitType = (WaitType)stackFrame.Params [2].ToInt32 ();  	bool alertable = stackFrame.Params [3].ToInt32 () != 0;  	// use the KiFastSystemCallRet args if we have the wrong args  	if (handleCount > 64) {  		handleCount = lastParams [1].ToInt32 ();  		handleAddress = lastParams [2];  		waitType = (WaitType)lastParams [3].ToInt32 ();  	}  	IntPtr* handles = stackalloc IntPtr[handleCount];  	phandle.ReadMemory (handleAddress' handles' handleCount * IntPtr.Size);  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + "' wait type: " + waitType.ToString () + ") for:");  	for (int i = 0; i < handleCount; i++) {  		sb.AppendLine (this.GetHandleString (_pid' handles [i]));  	}  }  else if (name.StartsWith ("ntdll.dll!zwwaitforsingleobject") || name.StartsWith ("ntdll.dll!ntwaitforsingleobject") || name.StartsWith ("kernel32.dll!waitforsingleobject")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	bool alertable = stackFrame.Params [1].ToInt32 () != 0;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + ") for:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforworkviaworkerfactory") || name.StartsWith ("ntdll.dll!ntwaitforworkviaworkerfactory")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for work from a worker factory:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,analyzeWaitMenuItem_Click,The following statement contains a magic number: if (name.StartsWith ("ntdll.dll!zwremoveiocompletion") || name.StartsWith ("ntdll.dll!ntremoveiocompletion")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an I/O completion object:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwreplywaitreceiveport") || name.StartsWith ("ntdll.dll!ntreplywaitreceiveport") || name.StartsWith ("ntdll.dll!zwrequestwaitreplyport") || name.StartsWith ("ntdll.dll!ntrequestwaitreplyport") || name.StartsWith ("ntdll.dll!zwalpcsendwaitreceiveport") || name.StartsWith ("ntdll.dll!ntalpcsendwaitreceiveport")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a LPC port:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!ntsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!zwsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!ntsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaithigheventpair") || name.StartsWith ("ntdll.dll!ntwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaitloweventpair") || name.StartsWith ("ntdll.dll!ntwaitloweventpair")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	// Use the KiFastSystemCallRet args if the handle we have is wrong.  	if (handle.ToInt32 () % 2 != 0)  		handle = lastParams [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for an event pair:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("user32.dll!ntusergetmessage") || name.StartsWith ("user32.dll!ntuserwaitmessage")) {  	found = true;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a USER message.");  }  else if (name.StartsWith ("ntdll.dll!zwwaitfordebugevent") || name.StartsWith ("ntdll.dll!ntwaitfordebugevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a debug event:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforkeyedevent") || name.StartsWith ("ntdll.dll!ntwaitforkeyedevent") || name.StartsWith ("ntdll.dll!zwreleasekeyedevent") || name.StartsWith ("ntdll.dll!ntreleasekeyedevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	IntPtr key = stackFrame.Params [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for a keyed event (key 0x" + key.ToString ("x") + "):");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitformultipleobjects") || name.StartsWith ("ntdll.dll!ntwaitformultipleobjects") || name.StartsWith ("kernel32.dll!waitformultipleobjects")) {  	found = true;  	int handleCount = stackFrame.Params [0].ToInt32 ();  	IntPtr handleAddress = stackFrame.Params [1];  	WaitType waitType = (WaitType)stackFrame.Params [2].ToInt32 ();  	bool alertable = stackFrame.Params [3].ToInt32 () != 0;  	// use the KiFastSystemCallRet args if we have the wrong args  	if (handleCount > 64) {  		handleCount = lastParams [1].ToInt32 ();  		handleAddress = lastParams [2];  		waitType = (WaitType)lastParams [3].ToInt32 ();  	}  	IntPtr* handles = stackalloc IntPtr[handleCount];  	phandle.ReadMemory (handleAddress' handles' handleCount * IntPtr.Size);  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + "' wait type: " + waitType.ToString () + ") for:");  	for (int i = 0; i < handleCount; i++) {  		sb.AppendLine (this.GetHandleString (_pid' handles [i]));  	}  }  else if (name.StartsWith ("ntdll.dll!zwwaitforsingleobject") || name.StartsWith ("ntdll.dll!ntwaitforsingleobject") || name.StartsWith ("kernel32.dll!waitforsingleobject")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	bool alertable = stackFrame.Params [1].ToInt32 () != 0;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + ") for:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforworkviaworkerfactory") || name.StartsWith ("ntdll.dll!ntwaitforworkviaworkerfactory")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for work from a worker factory:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,analyzeWaitMenuItem_Click,The following statement contains a magic number: if (name.StartsWith ("ntdll.dll!zwremoveiocompletion") || name.StartsWith ("ntdll.dll!ntremoveiocompletion")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for an I/O completion object:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwreplywaitreceiveport") || name.StartsWith ("ntdll.dll!ntreplywaitreceiveport") || name.StartsWith ("ntdll.dll!zwrequestwaitreplyport") || name.StartsWith ("ntdll.dll!ntrequestwaitreplyport") || name.StartsWith ("ntdll.dll!zwalpcsendwaitreceiveport") || name.StartsWith ("ntdll.dll!ntalpcsendwaitreceiveport")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a LPC port:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!ntsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!zwsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!ntsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaithigheventpair") || name.StartsWith ("ntdll.dll!ntwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaitloweventpair") || name.StartsWith ("ntdll.dll!ntwaitloweventpair")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	// Use the KiFastSystemCallRet args if the handle we have is wrong.  	if (handle.ToInt32 () % 2 != 0)  		handle = lastParams [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for an event pair:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("user32.dll!ntusergetmessage") || name.StartsWith ("user32.dll!ntuserwaitmessage")) {  	found = true;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a USER message.");  }  else if (name.StartsWith ("ntdll.dll!zwwaitfordebugevent") || name.StartsWith ("ntdll.dll!ntwaitfordebugevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a debug event:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforkeyedevent") || name.StartsWith ("ntdll.dll!ntwaitforkeyedevent") || name.StartsWith ("ntdll.dll!zwreleasekeyedevent") || name.StartsWith ("ntdll.dll!ntreleasekeyedevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	IntPtr key = stackFrame.Params [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for a keyed event (key 0x" + key.ToString ("x") + "):");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitformultipleobjects") || name.StartsWith ("ntdll.dll!ntwaitformultipleobjects") || name.StartsWith ("kernel32.dll!waitformultipleobjects")) {  	found = true;  	int handleCount = stackFrame.Params [0].ToInt32 ();  	IntPtr handleAddress = stackFrame.Params [1];  	WaitType waitType = (WaitType)stackFrame.Params [2].ToInt32 ();  	bool alertable = stackFrame.Params [3].ToInt32 () != 0;  	// use the KiFastSystemCallRet args if we have the wrong args  	if (handleCount > 64) {  		handleCount = lastParams [1].ToInt32 ();  		handleAddress = lastParams [2];  		waitType = (WaitType)lastParams [3].ToInt32 ();  	}  	IntPtr* handles = stackalloc IntPtr[handleCount];  	phandle.ReadMemory (handleAddress' handles' handleCount * IntPtr.Size);  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + "' wait type: " + waitType.ToString () + ") for:");  	for (int i = 0; i < handleCount; i++) {  		sb.AppendLine (this.GetHandleString (_pid' handles [i]));  	}  }  else if (name.StartsWith ("ntdll.dll!zwwaitforsingleobject") || name.StartsWith ("ntdll.dll!ntwaitforsingleobject") || name.StartsWith ("kernel32.dll!waitforsingleobject")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	bool alertable = stackFrame.Params [1].ToInt32 () != 0;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + ") for:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforworkviaworkerfactory") || name.StartsWith ("ntdll.dll!ntwaitforworkviaworkerfactory")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for work from a worker factory:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,analyzeWaitMenuItem_Click,The following statement contains a magic number: if (name.StartsWith ("ntdll.dll!zwreplywaitreceiveport") || name.StartsWith ("ntdll.dll!ntreplywaitreceiveport") || name.StartsWith ("ntdll.dll!zwrequestwaitreplyport") || name.StartsWith ("ntdll.dll!ntrequestwaitreplyport") || name.StartsWith ("ntdll.dll!zwalpcsendwaitreceiveport") || name.StartsWith ("ntdll.dll!ntalpcsendwaitreceiveport")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a LPC port:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!ntsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!zwsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!ntsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaithigheventpair") || name.StartsWith ("ntdll.dll!ntwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaitloweventpair") || name.StartsWith ("ntdll.dll!ntwaitloweventpair")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	// Use the KiFastSystemCallRet args if the handle we have is wrong.  	if (handle.ToInt32 () % 2 != 0)  		handle = lastParams [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for an event pair:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("user32.dll!ntusergetmessage") || name.StartsWith ("user32.dll!ntuserwaitmessage")) {  	found = true;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a USER message.");  }  else if (name.StartsWith ("ntdll.dll!zwwaitfordebugevent") || name.StartsWith ("ntdll.dll!ntwaitfordebugevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a debug event:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforkeyedevent") || name.StartsWith ("ntdll.dll!ntwaitforkeyedevent") || name.StartsWith ("ntdll.dll!zwreleasekeyedevent") || name.StartsWith ("ntdll.dll!ntreleasekeyedevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	IntPtr key = stackFrame.Params [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for a keyed event (key 0x" + key.ToString ("x") + "):");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitformultipleobjects") || name.StartsWith ("ntdll.dll!ntwaitformultipleobjects") || name.StartsWith ("kernel32.dll!waitformultipleobjects")) {  	found = true;  	int handleCount = stackFrame.Params [0].ToInt32 ();  	IntPtr handleAddress = stackFrame.Params [1];  	WaitType waitType = (WaitType)stackFrame.Params [2].ToInt32 ();  	bool alertable = stackFrame.Params [3].ToInt32 () != 0;  	// use the KiFastSystemCallRet args if we have the wrong args  	if (handleCount > 64) {  		handleCount = lastParams [1].ToInt32 ();  		handleAddress = lastParams [2];  		waitType = (WaitType)lastParams [3].ToInt32 ();  	}  	IntPtr* handles = stackalloc IntPtr[handleCount];  	phandle.ReadMemory (handleAddress' handles' handleCount * IntPtr.Size);  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + "' wait type: " + waitType.ToString () + ") for:");  	for (int i = 0; i < handleCount; i++) {  		sb.AppendLine (this.GetHandleString (_pid' handles [i]));  	}  }  else if (name.StartsWith ("ntdll.dll!zwwaitforsingleobject") || name.StartsWith ("ntdll.dll!ntwaitforsingleobject") || name.StartsWith ("kernel32.dll!waitforsingleobject")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	bool alertable = stackFrame.Params [1].ToInt32 () != 0;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + ") for:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforworkviaworkerfactory") || name.StartsWith ("ntdll.dll!ntwaitforworkviaworkerfactory")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for work from a worker factory:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,analyzeWaitMenuItem_Click,The following statement contains a magic number: if (name.StartsWith ("ntdll.dll!zwreplywaitreceiveport") || name.StartsWith ("ntdll.dll!ntreplywaitreceiveport") || name.StartsWith ("ntdll.dll!zwrequestwaitreplyport") || name.StartsWith ("ntdll.dll!ntrequestwaitreplyport") || name.StartsWith ("ntdll.dll!zwalpcsendwaitreceiveport") || name.StartsWith ("ntdll.dll!ntalpcsendwaitreceiveport")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a LPC port:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!ntsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!zwsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!ntsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaithigheventpair") || name.StartsWith ("ntdll.dll!ntwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaitloweventpair") || name.StartsWith ("ntdll.dll!ntwaitloweventpair")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	// Use the KiFastSystemCallRet args if the handle we have is wrong.  	if (handle.ToInt32 () % 2 != 0)  		handle = lastParams [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for an event pair:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("user32.dll!ntusergetmessage") || name.StartsWith ("user32.dll!ntuserwaitmessage")) {  	found = true;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a USER message.");  }  else if (name.StartsWith ("ntdll.dll!zwwaitfordebugevent") || name.StartsWith ("ntdll.dll!ntwaitfordebugevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a debug event:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforkeyedevent") || name.StartsWith ("ntdll.dll!ntwaitforkeyedevent") || name.StartsWith ("ntdll.dll!zwreleasekeyedevent") || name.StartsWith ("ntdll.dll!ntreleasekeyedevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	IntPtr key = stackFrame.Params [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for a keyed event (key 0x" + key.ToString ("x") + "):");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitformultipleobjects") || name.StartsWith ("ntdll.dll!ntwaitformultipleobjects") || name.StartsWith ("kernel32.dll!waitformultipleobjects")) {  	found = true;  	int handleCount = stackFrame.Params [0].ToInt32 ();  	IntPtr handleAddress = stackFrame.Params [1];  	WaitType waitType = (WaitType)stackFrame.Params [2].ToInt32 ();  	bool alertable = stackFrame.Params [3].ToInt32 () != 0;  	// use the KiFastSystemCallRet args if we have the wrong args  	if (handleCount > 64) {  		handleCount = lastParams [1].ToInt32 ();  		handleAddress = lastParams [2];  		waitType = (WaitType)lastParams [3].ToInt32 ();  	}  	IntPtr* handles = stackalloc IntPtr[handleCount];  	phandle.ReadMemory (handleAddress' handles' handleCount * IntPtr.Size);  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + "' wait type: " + waitType.ToString () + ") for:");  	for (int i = 0; i < handleCount; i++) {  		sb.AppendLine (this.GetHandleString (_pid' handles [i]));  	}  }  else if (name.StartsWith ("ntdll.dll!zwwaitforsingleobject") || name.StartsWith ("ntdll.dll!ntwaitforsingleobject") || name.StartsWith ("kernel32.dll!waitforsingleobject")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	bool alertable = stackFrame.Params [1].ToInt32 () != 0;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + ") for:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforworkviaworkerfactory") || name.StartsWith ("ntdll.dll!ntwaitforworkviaworkerfactory")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for work from a worker factory:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,analyzeWaitMenuItem_Click,The following statement contains a magic number: if (name.StartsWith ("ntdll.dll!zwreplywaitreceiveport") || name.StartsWith ("ntdll.dll!ntreplywaitreceiveport") || name.StartsWith ("ntdll.dll!zwrequestwaitreplyport") || name.StartsWith ("ntdll.dll!ntrequestwaitreplyport") || name.StartsWith ("ntdll.dll!zwalpcsendwaitreceiveport") || name.StartsWith ("ntdll.dll!ntalpcsendwaitreceiveport")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a LPC port:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!ntsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!zwsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!ntsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaithigheventpair") || name.StartsWith ("ntdll.dll!ntwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaitloweventpair") || name.StartsWith ("ntdll.dll!ntwaitloweventpair")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	// Use the KiFastSystemCallRet args if the handle we have is wrong.  	if (handle.ToInt32 () % 2 != 0)  		handle = lastParams [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for an event pair:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("user32.dll!ntusergetmessage") || name.StartsWith ("user32.dll!ntuserwaitmessage")) {  	found = true;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a USER message.");  }  else if (name.StartsWith ("ntdll.dll!zwwaitfordebugevent") || name.StartsWith ("ntdll.dll!ntwaitfordebugevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a debug event:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforkeyedevent") || name.StartsWith ("ntdll.dll!ntwaitforkeyedevent") || name.StartsWith ("ntdll.dll!zwreleasekeyedevent") || name.StartsWith ("ntdll.dll!ntreleasekeyedevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	IntPtr key = stackFrame.Params [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for a keyed event (key 0x" + key.ToString ("x") + "):");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitformultipleobjects") || name.StartsWith ("ntdll.dll!ntwaitformultipleobjects") || name.StartsWith ("kernel32.dll!waitformultipleobjects")) {  	found = true;  	int handleCount = stackFrame.Params [0].ToInt32 ();  	IntPtr handleAddress = stackFrame.Params [1];  	WaitType waitType = (WaitType)stackFrame.Params [2].ToInt32 ();  	bool alertable = stackFrame.Params [3].ToInt32 () != 0;  	// use the KiFastSystemCallRet args if we have the wrong args  	if (handleCount > 64) {  		handleCount = lastParams [1].ToInt32 ();  		handleAddress = lastParams [2];  		waitType = (WaitType)lastParams [3].ToInt32 ();  	}  	IntPtr* handles = stackalloc IntPtr[handleCount];  	phandle.ReadMemory (handleAddress' handles' handleCount * IntPtr.Size);  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + "' wait type: " + waitType.ToString () + ") for:");  	for (int i = 0; i < handleCount; i++) {  		sb.AppendLine (this.GetHandleString (_pid' handles [i]));  	}  }  else if (name.StartsWith ("ntdll.dll!zwwaitforsingleobject") || name.StartsWith ("ntdll.dll!ntwaitforsingleobject") || name.StartsWith ("kernel32.dll!waitforsingleobject")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	bool alertable = stackFrame.Params [1].ToInt32 () != 0;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + ") for:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforworkviaworkerfactory") || name.StartsWith ("ntdll.dll!ntwaitforworkviaworkerfactory")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for work from a worker factory:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,analyzeWaitMenuItem_Click,The following statement contains a magic number: if (name.StartsWith ("ntdll.dll!zwreplywaitreceiveport") || name.StartsWith ("ntdll.dll!ntreplywaitreceiveport") || name.StartsWith ("ntdll.dll!zwrequestwaitreplyport") || name.StartsWith ("ntdll.dll!ntrequestwaitreplyport") || name.StartsWith ("ntdll.dll!zwalpcsendwaitreceiveport") || name.StartsWith ("ntdll.dll!ntalpcsendwaitreceiveport")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a LPC port:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!ntsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!zwsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!ntsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaithigheventpair") || name.StartsWith ("ntdll.dll!ntwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaitloweventpair") || name.StartsWith ("ntdll.dll!ntwaitloweventpair")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	// Use the KiFastSystemCallRet args if the handle we have is wrong.  	if (handle.ToInt32 () % 2 != 0)  		handle = lastParams [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for an event pair:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("user32.dll!ntusergetmessage") || name.StartsWith ("user32.dll!ntuserwaitmessage")) {  	found = true;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a USER message.");  }  else if (name.StartsWith ("ntdll.dll!zwwaitfordebugevent") || name.StartsWith ("ntdll.dll!ntwaitfordebugevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a debug event:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforkeyedevent") || name.StartsWith ("ntdll.dll!ntwaitforkeyedevent") || name.StartsWith ("ntdll.dll!zwreleasekeyedevent") || name.StartsWith ("ntdll.dll!ntreleasekeyedevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	IntPtr key = stackFrame.Params [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for a keyed event (key 0x" + key.ToString ("x") + "):");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitformultipleobjects") || name.StartsWith ("ntdll.dll!ntwaitformultipleobjects") || name.StartsWith ("kernel32.dll!waitformultipleobjects")) {  	found = true;  	int handleCount = stackFrame.Params [0].ToInt32 ();  	IntPtr handleAddress = stackFrame.Params [1];  	WaitType waitType = (WaitType)stackFrame.Params [2].ToInt32 ();  	bool alertable = stackFrame.Params [3].ToInt32 () != 0;  	// use the KiFastSystemCallRet args if we have the wrong args  	if (handleCount > 64) {  		handleCount = lastParams [1].ToInt32 ();  		handleAddress = lastParams [2];  		waitType = (WaitType)lastParams [3].ToInt32 ();  	}  	IntPtr* handles = stackalloc IntPtr[handleCount];  	phandle.ReadMemory (handleAddress' handles' handleCount * IntPtr.Size);  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + "' wait type: " + waitType.ToString () + ") for:");  	for (int i = 0; i < handleCount; i++) {  		sb.AppendLine (this.GetHandleString (_pid' handles [i]));  	}  }  else if (name.StartsWith ("ntdll.dll!zwwaitforsingleobject") || name.StartsWith ("ntdll.dll!ntwaitforsingleobject") || name.StartsWith ("kernel32.dll!waitforsingleobject")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	bool alertable = stackFrame.Params [1].ToInt32 () != 0;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + ") for:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforworkviaworkerfactory") || name.StartsWith ("ntdll.dll!ntwaitforworkviaworkerfactory")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for work from a worker factory:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,analyzeWaitMenuItem_Click,The following statement contains a magic number: if (name.StartsWith ("ntdll.dll!zwreplywaitreceiveport") || name.StartsWith ("ntdll.dll!ntreplywaitreceiveport") || name.StartsWith ("ntdll.dll!zwrequestwaitreplyport") || name.StartsWith ("ntdll.dll!ntrequestwaitreplyport") || name.StartsWith ("ntdll.dll!zwalpcsendwaitreceiveport") || name.StartsWith ("ntdll.dll!ntalpcsendwaitreceiveport")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a LPC port:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!ntsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!zwsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!ntsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaithigheventpair") || name.StartsWith ("ntdll.dll!ntwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaitloweventpair") || name.StartsWith ("ntdll.dll!ntwaitloweventpair")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	// Use the KiFastSystemCallRet args if the handle we have is wrong.  	if (handle.ToInt32 () % 2 != 0)  		handle = lastParams [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for an event pair:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("user32.dll!ntusergetmessage") || name.StartsWith ("user32.dll!ntuserwaitmessage")) {  	found = true;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a USER message.");  }  else if (name.StartsWith ("ntdll.dll!zwwaitfordebugevent") || name.StartsWith ("ntdll.dll!ntwaitfordebugevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a debug event:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforkeyedevent") || name.StartsWith ("ntdll.dll!ntwaitforkeyedevent") || name.StartsWith ("ntdll.dll!zwreleasekeyedevent") || name.StartsWith ("ntdll.dll!ntreleasekeyedevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	IntPtr key = stackFrame.Params [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for a keyed event (key 0x" + key.ToString ("x") + "):");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitformultipleobjects") || name.StartsWith ("ntdll.dll!ntwaitformultipleobjects") || name.StartsWith ("kernel32.dll!waitformultipleobjects")) {  	found = true;  	int handleCount = stackFrame.Params [0].ToInt32 ();  	IntPtr handleAddress = stackFrame.Params [1];  	WaitType waitType = (WaitType)stackFrame.Params [2].ToInt32 ();  	bool alertable = stackFrame.Params [3].ToInt32 () != 0;  	// use the KiFastSystemCallRet args if we have the wrong args  	if (handleCount > 64) {  		handleCount = lastParams [1].ToInt32 ();  		handleAddress = lastParams [2];  		waitType = (WaitType)lastParams [3].ToInt32 ();  	}  	IntPtr* handles = stackalloc IntPtr[handleCount];  	phandle.ReadMemory (handleAddress' handles' handleCount * IntPtr.Size);  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + "' wait type: " + waitType.ToString () + ") for:");  	for (int i = 0; i < handleCount; i++) {  		sb.AppendLine (this.GetHandleString (_pid' handles [i]));  	}  }  else if (name.StartsWith ("ntdll.dll!zwwaitforsingleobject") || name.StartsWith ("ntdll.dll!ntwaitforsingleobject") || name.StartsWith ("kernel32.dll!waitforsingleobject")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	bool alertable = stackFrame.Params [1].ToInt32 () != 0;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + ") for:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforworkviaworkerfactory") || name.StartsWith ("ntdll.dll!ntwaitforworkviaworkerfactory")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for work from a worker factory:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,analyzeWaitMenuItem_Click,The following statement contains a magic number: if (name.StartsWith ("ntdll.dll!zwreplywaitreceiveport") || name.StartsWith ("ntdll.dll!ntreplywaitreceiveport") || name.StartsWith ("ntdll.dll!zwrequestwaitreplyport") || name.StartsWith ("ntdll.dll!ntrequestwaitreplyport") || name.StartsWith ("ntdll.dll!zwalpcsendwaitreceiveport") || name.StartsWith ("ntdll.dll!ntalpcsendwaitreceiveport")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a LPC port:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!ntsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!zwsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!ntsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaithigheventpair") || name.StartsWith ("ntdll.dll!ntwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaitloweventpair") || name.StartsWith ("ntdll.dll!ntwaitloweventpair")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	// Use the KiFastSystemCallRet args if the handle we have is wrong.  	if (handle.ToInt32 () % 2 != 0)  		handle = lastParams [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for an event pair:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("user32.dll!ntusergetmessage") || name.StartsWith ("user32.dll!ntuserwaitmessage")) {  	found = true;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a USER message.");  }  else if (name.StartsWith ("ntdll.dll!zwwaitfordebugevent") || name.StartsWith ("ntdll.dll!ntwaitfordebugevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a debug event:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforkeyedevent") || name.StartsWith ("ntdll.dll!ntwaitforkeyedevent") || name.StartsWith ("ntdll.dll!zwreleasekeyedevent") || name.StartsWith ("ntdll.dll!ntreleasekeyedevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	IntPtr key = stackFrame.Params [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for a keyed event (key 0x" + key.ToString ("x") + "):");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitformultipleobjects") || name.StartsWith ("ntdll.dll!ntwaitformultipleobjects") || name.StartsWith ("kernel32.dll!waitformultipleobjects")) {  	found = true;  	int handleCount = stackFrame.Params [0].ToInt32 ();  	IntPtr handleAddress = stackFrame.Params [1];  	WaitType waitType = (WaitType)stackFrame.Params [2].ToInt32 ();  	bool alertable = stackFrame.Params [3].ToInt32 () != 0;  	// use the KiFastSystemCallRet args if we have the wrong args  	if (handleCount > 64) {  		handleCount = lastParams [1].ToInt32 ();  		handleAddress = lastParams [2];  		waitType = (WaitType)lastParams [3].ToInt32 ();  	}  	IntPtr* handles = stackalloc IntPtr[handleCount];  	phandle.ReadMemory (handleAddress' handles' handleCount * IntPtr.Size);  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + "' wait type: " + waitType.ToString () + ") for:");  	for (int i = 0; i < handleCount; i++) {  		sb.AppendLine (this.GetHandleString (_pid' handles [i]));  	}  }  else if (name.StartsWith ("ntdll.dll!zwwaitforsingleobject") || name.StartsWith ("ntdll.dll!ntwaitforsingleobject") || name.StartsWith ("kernel32.dll!waitforsingleobject")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	bool alertable = stackFrame.Params [1].ToInt32 () != 0;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + ") for:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforworkviaworkerfactory") || name.StartsWith ("ntdll.dll!ntwaitforworkviaworkerfactory")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for work from a worker factory:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,analyzeWaitMenuItem_Click,The following statement contains a magic number: if (name.StartsWith ("ntdll.dll!zwsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!ntsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!zwsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!ntsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaithigheventpair") || name.StartsWith ("ntdll.dll!ntwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaitloweventpair") || name.StartsWith ("ntdll.dll!ntwaitloweventpair")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	// Use the KiFastSystemCallRet args if the handle we have is wrong.  	if (handle.ToInt32 () % 2 != 0)  		handle = lastParams [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for an event pair:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("user32.dll!ntusergetmessage") || name.StartsWith ("user32.dll!ntuserwaitmessage")) {  	found = true;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a USER message.");  }  else if (name.StartsWith ("ntdll.dll!zwwaitfordebugevent") || name.StartsWith ("ntdll.dll!ntwaitfordebugevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a debug event:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforkeyedevent") || name.StartsWith ("ntdll.dll!ntwaitforkeyedevent") || name.StartsWith ("ntdll.dll!zwreleasekeyedevent") || name.StartsWith ("ntdll.dll!ntreleasekeyedevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	IntPtr key = stackFrame.Params [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for a keyed event (key 0x" + key.ToString ("x") + "):");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitformultipleobjects") || name.StartsWith ("ntdll.dll!ntwaitformultipleobjects") || name.StartsWith ("kernel32.dll!waitformultipleobjects")) {  	found = true;  	int handleCount = stackFrame.Params [0].ToInt32 ();  	IntPtr handleAddress = stackFrame.Params [1];  	WaitType waitType = (WaitType)stackFrame.Params [2].ToInt32 ();  	bool alertable = stackFrame.Params [3].ToInt32 () != 0;  	// use the KiFastSystemCallRet args if we have the wrong args  	if (handleCount > 64) {  		handleCount = lastParams [1].ToInt32 ();  		handleAddress = lastParams [2];  		waitType = (WaitType)lastParams [3].ToInt32 ();  	}  	IntPtr* handles = stackalloc IntPtr[handleCount];  	phandle.ReadMemory (handleAddress' handles' handleCount * IntPtr.Size);  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + "' wait type: " + waitType.ToString () + ") for:");  	for (int i = 0; i < handleCount; i++) {  		sb.AppendLine (this.GetHandleString (_pid' handles [i]));  	}  }  else if (name.StartsWith ("ntdll.dll!zwwaitforsingleobject") || name.StartsWith ("ntdll.dll!ntwaitforsingleobject") || name.StartsWith ("kernel32.dll!waitforsingleobject")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	bool alertable = stackFrame.Params [1].ToInt32 () != 0;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + ") for:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforworkviaworkerfactory") || name.StartsWith ("ntdll.dll!ntwaitforworkviaworkerfactory")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for work from a worker factory:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,analyzeWaitMenuItem_Click,The following statement contains a magic number: if (name.StartsWith ("ntdll.dll!zwsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!ntsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!zwsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!ntsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaithigheventpair") || name.StartsWith ("ntdll.dll!ntwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaitloweventpair") || name.StartsWith ("ntdll.dll!ntwaitloweventpair")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	// Use the KiFastSystemCallRet args if the handle we have is wrong.  	if (handle.ToInt32 () % 2 != 0)  		handle = lastParams [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for an event pair:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("user32.dll!ntusergetmessage") || name.StartsWith ("user32.dll!ntuserwaitmessage")) {  	found = true;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a USER message.");  }  else if (name.StartsWith ("ntdll.dll!zwwaitfordebugevent") || name.StartsWith ("ntdll.dll!ntwaitfordebugevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a debug event:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforkeyedevent") || name.StartsWith ("ntdll.dll!ntwaitforkeyedevent") || name.StartsWith ("ntdll.dll!zwreleasekeyedevent") || name.StartsWith ("ntdll.dll!ntreleasekeyedevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	IntPtr key = stackFrame.Params [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for a keyed event (key 0x" + key.ToString ("x") + "):");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitformultipleobjects") || name.StartsWith ("ntdll.dll!ntwaitformultipleobjects") || name.StartsWith ("kernel32.dll!waitformultipleobjects")) {  	found = true;  	int handleCount = stackFrame.Params [0].ToInt32 ();  	IntPtr handleAddress = stackFrame.Params [1];  	WaitType waitType = (WaitType)stackFrame.Params [2].ToInt32 ();  	bool alertable = stackFrame.Params [3].ToInt32 () != 0;  	// use the KiFastSystemCallRet args if we have the wrong args  	if (handleCount > 64) {  		handleCount = lastParams [1].ToInt32 ();  		handleAddress = lastParams [2];  		waitType = (WaitType)lastParams [3].ToInt32 ();  	}  	IntPtr* handles = stackalloc IntPtr[handleCount];  	phandle.ReadMemory (handleAddress' handles' handleCount * IntPtr.Size);  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + "' wait type: " + waitType.ToString () + ") for:");  	for (int i = 0; i < handleCount; i++) {  		sb.AppendLine (this.GetHandleString (_pid' handles [i]));  	}  }  else if (name.StartsWith ("ntdll.dll!zwwaitforsingleobject") || name.StartsWith ("ntdll.dll!ntwaitforsingleobject") || name.StartsWith ("kernel32.dll!waitforsingleobject")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	bool alertable = stackFrame.Params [1].ToInt32 () != 0;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + ") for:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforworkviaworkerfactory") || name.StartsWith ("ntdll.dll!ntwaitforworkviaworkerfactory")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for work from a worker factory:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,analyzeWaitMenuItem_Click,The following statement contains a magic number: if (name.StartsWith ("ntdll.dll!zwsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!ntsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!zwsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!ntsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaithigheventpair") || name.StartsWith ("ntdll.dll!ntwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaitloweventpair") || name.StartsWith ("ntdll.dll!ntwaitloweventpair")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	// Use the KiFastSystemCallRet args if the handle we have is wrong.  	if (handle.ToInt32 () % 2 != 0)  		handle = lastParams [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for an event pair:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("user32.dll!ntusergetmessage") || name.StartsWith ("user32.dll!ntuserwaitmessage")) {  	found = true;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a USER message.");  }  else if (name.StartsWith ("ntdll.dll!zwwaitfordebugevent") || name.StartsWith ("ntdll.dll!ntwaitfordebugevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a debug event:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforkeyedevent") || name.StartsWith ("ntdll.dll!ntwaitforkeyedevent") || name.StartsWith ("ntdll.dll!zwreleasekeyedevent") || name.StartsWith ("ntdll.dll!ntreleasekeyedevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	IntPtr key = stackFrame.Params [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for a keyed event (key 0x" + key.ToString ("x") + "):");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitformultipleobjects") || name.StartsWith ("ntdll.dll!ntwaitformultipleobjects") || name.StartsWith ("kernel32.dll!waitformultipleobjects")) {  	found = true;  	int handleCount = stackFrame.Params [0].ToInt32 ();  	IntPtr handleAddress = stackFrame.Params [1];  	WaitType waitType = (WaitType)stackFrame.Params [2].ToInt32 ();  	bool alertable = stackFrame.Params [3].ToInt32 () != 0;  	// use the KiFastSystemCallRet args if we have the wrong args  	if (handleCount > 64) {  		handleCount = lastParams [1].ToInt32 ();  		handleAddress = lastParams [2];  		waitType = (WaitType)lastParams [3].ToInt32 ();  	}  	IntPtr* handles = stackalloc IntPtr[handleCount];  	phandle.ReadMemory (handleAddress' handles' handleCount * IntPtr.Size);  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + "' wait type: " + waitType.ToString () + ") for:");  	for (int i = 0; i < handleCount; i++) {  		sb.AppendLine (this.GetHandleString (_pid' handles [i]));  	}  }  else if (name.StartsWith ("ntdll.dll!zwwaitforsingleobject") || name.StartsWith ("ntdll.dll!ntwaitforsingleobject") || name.StartsWith ("kernel32.dll!waitforsingleobject")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	bool alertable = stackFrame.Params [1].ToInt32 () != 0;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + ") for:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforworkviaworkerfactory") || name.StartsWith ("ntdll.dll!ntwaitforworkviaworkerfactory")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for work from a worker factory:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,analyzeWaitMenuItem_Click,The following statement contains a magic number: if (name.StartsWith ("ntdll.dll!zwsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!ntsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!zwsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!ntsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaithigheventpair") || name.StartsWith ("ntdll.dll!ntwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaitloweventpair") || name.StartsWith ("ntdll.dll!ntwaitloweventpair")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	// Use the KiFastSystemCallRet args if the handle we have is wrong.  	if (handle.ToInt32 () % 2 != 0)  		handle = lastParams [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for an event pair:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("user32.dll!ntusergetmessage") || name.StartsWith ("user32.dll!ntuserwaitmessage")) {  	found = true;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a USER message.");  }  else if (name.StartsWith ("ntdll.dll!zwwaitfordebugevent") || name.StartsWith ("ntdll.dll!ntwaitfordebugevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a debug event:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforkeyedevent") || name.StartsWith ("ntdll.dll!ntwaitforkeyedevent") || name.StartsWith ("ntdll.dll!zwreleasekeyedevent") || name.StartsWith ("ntdll.dll!ntreleasekeyedevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	IntPtr key = stackFrame.Params [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for a keyed event (key 0x" + key.ToString ("x") + "):");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitformultipleobjects") || name.StartsWith ("ntdll.dll!ntwaitformultipleobjects") || name.StartsWith ("kernel32.dll!waitformultipleobjects")) {  	found = true;  	int handleCount = stackFrame.Params [0].ToInt32 ();  	IntPtr handleAddress = stackFrame.Params [1];  	WaitType waitType = (WaitType)stackFrame.Params [2].ToInt32 ();  	bool alertable = stackFrame.Params [3].ToInt32 () != 0;  	// use the KiFastSystemCallRet args if we have the wrong args  	if (handleCount > 64) {  		handleCount = lastParams [1].ToInt32 ();  		handleAddress = lastParams [2];  		waitType = (WaitType)lastParams [3].ToInt32 ();  	}  	IntPtr* handles = stackalloc IntPtr[handleCount];  	phandle.ReadMemory (handleAddress' handles' handleCount * IntPtr.Size);  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + "' wait type: " + waitType.ToString () + ") for:");  	for (int i = 0; i < handleCount; i++) {  		sb.AppendLine (this.GetHandleString (_pid' handles [i]));  	}  }  else if (name.StartsWith ("ntdll.dll!zwwaitforsingleobject") || name.StartsWith ("ntdll.dll!ntwaitforsingleobject") || name.StartsWith ("kernel32.dll!waitforsingleobject")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	bool alertable = stackFrame.Params [1].ToInt32 () != 0;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + ") for:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforworkviaworkerfactory") || name.StartsWith ("ntdll.dll!ntwaitforworkviaworkerfactory")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for work from a worker factory:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,analyzeWaitMenuItem_Click,The following statement contains a magic number: if (name.StartsWith ("ntdll.dll!zwsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!ntsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!zwsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!ntsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaithigheventpair") || name.StartsWith ("ntdll.dll!ntwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaitloweventpair") || name.StartsWith ("ntdll.dll!ntwaitloweventpair")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	// Use the KiFastSystemCallRet args if the handle we have is wrong.  	if (handle.ToInt32 () % 2 != 0)  		handle = lastParams [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for an event pair:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("user32.dll!ntusergetmessage") || name.StartsWith ("user32.dll!ntuserwaitmessage")) {  	found = true;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a USER message.");  }  else if (name.StartsWith ("ntdll.dll!zwwaitfordebugevent") || name.StartsWith ("ntdll.dll!ntwaitfordebugevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a debug event:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforkeyedevent") || name.StartsWith ("ntdll.dll!ntwaitforkeyedevent") || name.StartsWith ("ntdll.dll!zwreleasekeyedevent") || name.StartsWith ("ntdll.dll!ntreleasekeyedevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	IntPtr key = stackFrame.Params [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for a keyed event (key 0x" + key.ToString ("x") + "):");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitformultipleobjects") || name.StartsWith ("ntdll.dll!ntwaitformultipleobjects") || name.StartsWith ("kernel32.dll!waitformultipleobjects")) {  	found = true;  	int handleCount = stackFrame.Params [0].ToInt32 ();  	IntPtr handleAddress = stackFrame.Params [1];  	WaitType waitType = (WaitType)stackFrame.Params [2].ToInt32 ();  	bool alertable = stackFrame.Params [3].ToInt32 () != 0;  	// use the KiFastSystemCallRet args if we have the wrong args  	if (handleCount > 64) {  		handleCount = lastParams [1].ToInt32 ();  		handleAddress = lastParams [2];  		waitType = (WaitType)lastParams [3].ToInt32 ();  	}  	IntPtr* handles = stackalloc IntPtr[handleCount];  	phandle.ReadMemory (handleAddress' handles' handleCount * IntPtr.Size);  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + "' wait type: " + waitType.ToString () + ") for:");  	for (int i = 0; i < handleCount; i++) {  		sb.AppendLine (this.GetHandleString (_pid' handles [i]));  	}  }  else if (name.StartsWith ("ntdll.dll!zwwaitforsingleobject") || name.StartsWith ("ntdll.dll!ntwaitforsingleobject") || name.StartsWith ("kernel32.dll!waitforsingleobject")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	bool alertable = stackFrame.Params [1].ToInt32 () != 0;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + ") for:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforworkviaworkerfactory") || name.StartsWith ("ntdll.dll!ntwaitforworkviaworkerfactory")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for work from a worker factory:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,analyzeWaitMenuItem_Click,The following statement contains a magic number: if (name.StartsWith ("ntdll.dll!zwsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!ntsethighwaitloweventpair") || name.StartsWith ("ntdll.dll!zwsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!ntsetlowwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaithigheventpair") || name.StartsWith ("ntdll.dll!ntwaithigheventpair") || name.StartsWith ("ntdll.dll!zwwaitloweventpair") || name.StartsWith ("ntdll.dll!ntwaitloweventpair")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	// Use the KiFastSystemCallRet args if the handle we have is wrong.  	if (handle.ToInt32 () % 2 != 0)  		handle = lastParams [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for an event pair:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("user32.dll!ntusergetmessage") || name.StartsWith ("user32.dll!ntuserwaitmessage")) {  	found = true;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a USER message.");  }  else if (name.StartsWith ("ntdll.dll!zwwaitfordebugevent") || name.StartsWith ("ntdll.dll!ntwaitfordebugevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a debug event:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforkeyedevent") || name.StartsWith ("ntdll.dll!ntwaitforkeyedevent") || name.StartsWith ("ntdll.dll!zwreleasekeyedevent") || name.StartsWith ("ntdll.dll!ntreleasekeyedevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	IntPtr key = stackFrame.Params [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for a keyed event (key 0x" + key.ToString ("x") + "):");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitformultipleobjects") || name.StartsWith ("ntdll.dll!ntwaitformultipleobjects") || name.StartsWith ("kernel32.dll!waitformultipleobjects")) {  	found = true;  	int handleCount = stackFrame.Params [0].ToInt32 ();  	IntPtr handleAddress = stackFrame.Params [1];  	WaitType waitType = (WaitType)stackFrame.Params [2].ToInt32 ();  	bool alertable = stackFrame.Params [3].ToInt32 () != 0;  	// use the KiFastSystemCallRet args if we have the wrong args  	if (handleCount > 64) {  		handleCount = lastParams [1].ToInt32 ();  		handleAddress = lastParams [2];  		waitType = (WaitType)lastParams [3].ToInt32 ();  	}  	IntPtr* handles = stackalloc IntPtr[handleCount];  	phandle.ReadMemory (handleAddress' handles' handleCount * IntPtr.Size);  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + "' wait type: " + waitType.ToString () + ") for:");  	for (int i = 0; i < handleCount; i++) {  		sb.AppendLine (this.GetHandleString (_pid' handles [i]));  	}  }  else if (name.StartsWith ("ntdll.dll!zwwaitforsingleobject") || name.StartsWith ("ntdll.dll!ntwaitforsingleobject") || name.StartsWith ("kernel32.dll!waitforsingleobject")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	bool alertable = stackFrame.Params [1].ToInt32 () != 0;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + ") for:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforworkviaworkerfactory") || name.StartsWith ("ntdll.dll!ntwaitforworkviaworkerfactory")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for work from a worker factory:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,analyzeWaitMenuItem_Click,The following statement contains a magic number: if (handle.ToInt32 () % 2 != 0)  	handle = lastParams [1];  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,analyzeWaitMenuItem_Click,The following statement contains a magic number: if (name.StartsWith ("user32.dll!ntusergetmessage") || name.StartsWith ("user32.dll!ntuserwaitmessage")) {  	found = true;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a USER message.");  }  else if (name.StartsWith ("ntdll.dll!zwwaitfordebugevent") || name.StartsWith ("ntdll.dll!ntwaitfordebugevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a debug event:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforkeyedevent") || name.StartsWith ("ntdll.dll!ntwaitforkeyedevent") || name.StartsWith ("ntdll.dll!zwreleasekeyedevent") || name.StartsWith ("ntdll.dll!ntreleasekeyedevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	IntPtr key = stackFrame.Params [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for a keyed event (key 0x" + key.ToString ("x") + "):");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitformultipleobjects") || name.StartsWith ("ntdll.dll!ntwaitformultipleobjects") || name.StartsWith ("kernel32.dll!waitformultipleobjects")) {  	found = true;  	int handleCount = stackFrame.Params [0].ToInt32 ();  	IntPtr handleAddress = stackFrame.Params [1];  	WaitType waitType = (WaitType)stackFrame.Params [2].ToInt32 ();  	bool alertable = stackFrame.Params [3].ToInt32 () != 0;  	// use the KiFastSystemCallRet args if we have the wrong args  	if (handleCount > 64) {  		handleCount = lastParams [1].ToInt32 ();  		handleAddress = lastParams [2];  		waitType = (WaitType)lastParams [3].ToInt32 ();  	}  	IntPtr* handles = stackalloc IntPtr[handleCount];  	phandle.ReadMemory (handleAddress' handles' handleCount * IntPtr.Size);  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + "' wait type: " + waitType.ToString () + ") for:");  	for (int i = 0; i < handleCount; i++) {  		sb.AppendLine (this.GetHandleString (_pid' handles [i]));  	}  }  else if (name.StartsWith ("ntdll.dll!zwwaitforsingleobject") || name.StartsWith ("ntdll.dll!ntwaitforsingleobject") || name.StartsWith ("kernel32.dll!waitforsingleobject")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	bool alertable = stackFrame.Params [1].ToInt32 () != 0;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + ") for:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforworkviaworkerfactory") || name.StartsWith ("ntdll.dll!ntwaitforworkviaworkerfactory")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for work from a worker factory:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,analyzeWaitMenuItem_Click,The following statement contains a magic number: if (name.StartsWith ("user32.dll!ntusergetmessage") || name.StartsWith ("user32.dll!ntuserwaitmessage")) {  	found = true;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a USER message.");  }  else if (name.StartsWith ("ntdll.dll!zwwaitfordebugevent") || name.StartsWith ("ntdll.dll!ntwaitfordebugevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a debug event:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforkeyedevent") || name.StartsWith ("ntdll.dll!ntwaitforkeyedevent") || name.StartsWith ("ntdll.dll!zwreleasekeyedevent") || name.StartsWith ("ntdll.dll!ntreleasekeyedevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	IntPtr key = stackFrame.Params [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for a keyed event (key 0x" + key.ToString ("x") + "):");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitformultipleobjects") || name.StartsWith ("ntdll.dll!ntwaitformultipleobjects") || name.StartsWith ("kernel32.dll!waitformultipleobjects")) {  	found = true;  	int handleCount = stackFrame.Params [0].ToInt32 ();  	IntPtr handleAddress = stackFrame.Params [1];  	WaitType waitType = (WaitType)stackFrame.Params [2].ToInt32 ();  	bool alertable = stackFrame.Params [3].ToInt32 () != 0;  	// use the KiFastSystemCallRet args if we have the wrong args  	if (handleCount > 64) {  		handleCount = lastParams [1].ToInt32 ();  		handleAddress = lastParams [2];  		waitType = (WaitType)lastParams [3].ToInt32 ();  	}  	IntPtr* handles = stackalloc IntPtr[handleCount];  	phandle.ReadMemory (handleAddress' handles' handleCount * IntPtr.Size);  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + "' wait type: " + waitType.ToString () + ") for:");  	for (int i = 0; i < handleCount; i++) {  		sb.AppendLine (this.GetHandleString (_pid' handles [i]));  	}  }  else if (name.StartsWith ("ntdll.dll!zwwaitforsingleobject") || name.StartsWith ("ntdll.dll!ntwaitforsingleobject") || name.StartsWith ("kernel32.dll!waitforsingleobject")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	bool alertable = stackFrame.Params [1].ToInt32 () != 0;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + ") for:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforworkviaworkerfactory") || name.StartsWith ("ntdll.dll!ntwaitforworkviaworkerfactory")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for work from a worker factory:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,analyzeWaitMenuItem_Click,The following statement contains a magic number: if (name.StartsWith ("user32.dll!ntusergetmessage") || name.StartsWith ("user32.dll!ntuserwaitmessage")) {  	found = true;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a USER message.");  }  else if (name.StartsWith ("ntdll.dll!zwwaitfordebugevent") || name.StartsWith ("ntdll.dll!ntwaitfordebugevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a debug event:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforkeyedevent") || name.StartsWith ("ntdll.dll!ntwaitforkeyedevent") || name.StartsWith ("ntdll.dll!zwreleasekeyedevent") || name.StartsWith ("ntdll.dll!ntreleasekeyedevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	IntPtr key = stackFrame.Params [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for a keyed event (key 0x" + key.ToString ("x") + "):");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitformultipleobjects") || name.StartsWith ("ntdll.dll!ntwaitformultipleobjects") || name.StartsWith ("kernel32.dll!waitformultipleobjects")) {  	found = true;  	int handleCount = stackFrame.Params [0].ToInt32 ();  	IntPtr handleAddress = stackFrame.Params [1];  	WaitType waitType = (WaitType)stackFrame.Params [2].ToInt32 ();  	bool alertable = stackFrame.Params [3].ToInt32 () != 0;  	// use the KiFastSystemCallRet args if we have the wrong args  	if (handleCount > 64) {  		handleCount = lastParams [1].ToInt32 ();  		handleAddress = lastParams [2];  		waitType = (WaitType)lastParams [3].ToInt32 ();  	}  	IntPtr* handles = stackalloc IntPtr[handleCount];  	phandle.ReadMemory (handleAddress' handles' handleCount * IntPtr.Size);  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + "' wait type: " + waitType.ToString () + ") for:");  	for (int i = 0; i < handleCount; i++) {  		sb.AppendLine (this.GetHandleString (_pid' handles [i]));  	}  }  else if (name.StartsWith ("ntdll.dll!zwwaitforsingleobject") || name.StartsWith ("ntdll.dll!ntwaitforsingleobject") || name.StartsWith ("kernel32.dll!waitforsingleobject")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	bool alertable = stackFrame.Params [1].ToInt32 () != 0;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + ") for:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforworkviaworkerfactory") || name.StartsWith ("ntdll.dll!ntwaitforworkviaworkerfactory")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for work from a worker factory:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,analyzeWaitMenuItem_Click,The following statement contains a magic number: if (name.StartsWith ("user32.dll!ntusergetmessage") || name.StartsWith ("user32.dll!ntuserwaitmessage")) {  	found = true;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a USER message.");  }  else if (name.StartsWith ("ntdll.dll!zwwaitfordebugevent") || name.StartsWith ("ntdll.dll!ntwaitfordebugevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a debug event:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforkeyedevent") || name.StartsWith ("ntdll.dll!ntwaitforkeyedevent") || name.StartsWith ("ntdll.dll!zwreleasekeyedevent") || name.StartsWith ("ntdll.dll!ntreleasekeyedevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	IntPtr key = stackFrame.Params [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for a keyed event (key 0x" + key.ToString ("x") + "):");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitformultipleobjects") || name.StartsWith ("ntdll.dll!ntwaitformultipleobjects") || name.StartsWith ("kernel32.dll!waitformultipleobjects")) {  	found = true;  	int handleCount = stackFrame.Params [0].ToInt32 ();  	IntPtr handleAddress = stackFrame.Params [1];  	WaitType waitType = (WaitType)stackFrame.Params [2].ToInt32 ();  	bool alertable = stackFrame.Params [3].ToInt32 () != 0;  	// use the KiFastSystemCallRet args if we have the wrong args  	if (handleCount > 64) {  		handleCount = lastParams [1].ToInt32 ();  		handleAddress = lastParams [2];  		waitType = (WaitType)lastParams [3].ToInt32 ();  	}  	IntPtr* handles = stackalloc IntPtr[handleCount];  	phandle.ReadMemory (handleAddress' handles' handleCount * IntPtr.Size);  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + "' wait type: " + waitType.ToString () + ") for:");  	for (int i = 0; i < handleCount; i++) {  		sb.AppendLine (this.GetHandleString (_pid' handles [i]));  	}  }  else if (name.StartsWith ("ntdll.dll!zwwaitforsingleobject") || name.StartsWith ("ntdll.dll!ntwaitforsingleobject") || name.StartsWith ("kernel32.dll!waitforsingleobject")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	bool alertable = stackFrame.Params [1].ToInt32 () != 0;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + ") for:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforworkviaworkerfactory") || name.StartsWith ("ntdll.dll!ntwaitforworkviaworkerfactory")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for work from a worker factory:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,analyzeWaitMenuItem_Click,The following statement contains a magic number: if (name.StartsWith ("user32.dll!ntusergetmessage") || name.StartsWith ("user32.dll!ntuserwaitmessage")) {  	found = true;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a USER message.");  }  else if (name.StartsWith ("ntdll.dll!zwwaitfordebugevent") || name.StartsWith ("ntdll.dll!ntwaitfordebugevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a debug event:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforkeyedevent") || name.StartsWith ("ntdll.dll!ntwaitforkeyedevent") || name.StartsWith ("ntdll.dll!zwreleasekeyedevent") || name.StartsWith ("ntdll.dll!ntreleasekeyedevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	IntPtr key = stackFrame.Params [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for a keyed event (key 0x" + key.ToString ("x") + "):");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitformultipleobjects") || name.StartsWith ("ntdll.dll!ntwaitformultipleobjects") || name.StartsWith ("kernel32.dll!waitformultipleobjects")) {  	found = true;  	int handleCount = stackFrame.Params [0].ToInt32 ();  	IntPtr handleAddress = stackFrame.Params [1];  	WaitType waitType = (WaitType)stackFrame.Params [2].ToInt32 ();  	bool alertable = stackFrame.Params [3].ToInt32 () != 0;  	// use the KiFastSystemCallRet args if we have the wrong args  	if (handleCount > 64) {  		handleCount = lastParams [1].ToInt32 ();  		handleAddress = lastParams [2];  		waitType = (WaitType)lastParams [3].ToInt32 ();  	}  	IntPtr* handles = stackalloc IntPtr[handleCount];  	phandle.ReadMemory (handleAddress' handles' handleCount * IntPtr.Size);  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + "' wait type: " + waitType.ToString () + ") for:");  	for (int i = 0; i < handleCount; i++) {  		sb.AppendLine (this.GetHandleString (_pid' handles [i]));  	}  }  else if (name.StartsWith ("ntdll.dll!zwwaitforsingleobject") || name.StartsWith ("ntdll.dll!ntwaitforsingleobject") || name.StartsWith ("kernel32.dll!waitforsingleobject")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	bool alertable = stackFrame.Params [1].ToInt32 () != 0;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + ") for:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforworkviaworkerfactory") || name.StartsWith ("ntdll.dll!ntwaitforworkviaworkerfactory")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for work from a worker factory:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,analyzeWaitMenuItem_Click,The following statement contains a magic number: if (name.StartsWith ("ntdll.dll!zwwaitfordebugevent") || name.StartsWith ("ntdll.dll!ntwaitfordebugevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a debug event:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforkeyedevent") || name.StartsWith ("ntdll.dll!ntwaitforkeyedevent") || name.StartsWith ("ntdll.dll!zwreleasekeyedevent") || name.StartsWith ("ntdll.dll!ntreleasekeyedevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	IntPtr key = stackFrame.Params [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for a keyed event (key 0x" + key.ToString ("x") + "):");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitformultipleobjects") || name.StartsWith ("ntdll.dll!ntwaitformultipleobjects") || name.StartsWith ("kernel32.dll!waitformultipleobjects")) {  	found = true;  	int handleCount = stackFrame.Params [0].ToInt32 ();  	IntPtr handleAddress = stackFrame.Params [1];  	WaitType waitType = (WaitType)stackFrame.Params [2].ToInt32 ();  	bool alertable = stackFrame.Params [3].ToInt32 () != 0;  	// use the KiFastSystemCallRet args if we have the wrong args  	if (handleCount > 64) {  		handleCount = lastParams [1].ToInt32 ();  		handleAddress = lastParams [2];  		waitType = (WaitType)lastParams [3].ToInt32 ();  	}  	IntPtr* handles = stackalloc IntPtr[handleCount];  	phandle.ReadMemory (handleAddress' handles' handleCount * IntPtr.Size);  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + "' wait type: " + waitType.ToString () + ") for:");  	for (int i = 0; i < handleCount; i++) {  		sb.AppendLine (this.GetHandleString (_pid' handles [i]));  	}  }  else if (name.StartsWith ("ntdll.dll!zwwaitforsingleobject") || name.StartsWith ("ntdll.dll!ntwaitforsingleobject") || name.StartsWith ("kernel32.dll!waitforsingleobject")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	bool alertable = stackFrame.Params [1].ToInt32 () != 0;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + ") for:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforworkviaworkerfactory") || name.StartsWith ("ntdll.dll!ntwaitforworkviaworkerfactory")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for work from a worker factory:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,analyzeWaitMenuItem_Click,The following statement contains a magic number: if (name.StartsWith ("ntdll.dll!zwwaitfordebugevent") || name.StartsWith ("ntdll.dll!ntwaitfordebugevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a debug event:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforkeyedevent") || name.StartsWith ("ntdll.dll!ntwaitforkeyedevent") || name.StartsWith ("ntdll.dll!zwreleasekeyedevent") || name.StartsWith ("ntdll.dll!ntreleasekeyedevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	IntPtr key = stackFrame.Params [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for a keyed event (key 0x" + key.ToString ("x") + "):");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitformultipleobjects") || name.StartsWith ("ntdll.dll!ntwaitformultipleobjects") || name.StartsWith ("kernel32.dll!waitformultipleobjects")) {  	found = true;  	int handleCount = stackFrame.Params [0].ToInt32 ();  	IntPtr handleAddress = stackFrame.Params [1];  	WaitType waitType = (WaitType)stackFrame.Params [2].ToInt32 ();  	bool alertable = stackFrame.Params [3].ToInt32 () != 0;  	// use the KiFastSystemCallRet args if we have the wrong args  	if (handleCount > 64) {  		handleCount = lastParams [1].ToInt32 ();  		handleAddress = lastParams [2];  		waitType = (WaitType)lastParams [3].ToInt32 ();  	}  	IntPtr* handles = stackalloc IntPtr[handleCount];  	phandle.ReadMemory (handleAddress' handles' handleCount * IntPtr.Size);  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + "' wait type: " + waitType.ToString () + ") for:");  	for (int i = 0; i < handleCount; i++) {  		sb.AppendLine (this.GetHandleString (_pid' handles [i]));  	}  }  else if (name.StartsWith ("ntdll.dll!zwwaitforsingleobject") || name.StartsWith ("ntdll.dll!ntwaitforsingleobject") || name.StartsWith ("kernel32.dll!waitforsingleobject")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	bool alertable = stackFrame.Params [1].ToInt32 () != 0;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + ") for:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforworkviaworkerfactory") || name.StartsWith ("ntdll.dll!ntwaitforworkviaworkerfactory")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for work from a worker factory:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,analyzeWaitMenuItem_Click,The following statement contains a magic number: if (name.StartsWith ("ntdll.dll!zwwaitfordebugevent") || name.StartsWith ("ntdll.dll!ntwaitfordebugevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a debug event:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforkeyedevent") || name.StartsWith ("ntdll.dll!ntwaitforkeyedevent") || name.StartsWith ("ntdll.dll!zwreleasekeyedevent") || name.StartsWith ("ntdll.dll!ntreleasekeyedevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	IntPtr key = stackFrame.Params [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for a keyed event (key 0x" + key.ToString ("x") + "):");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitformultipleobjects") || name.StartsWith ("ntdll.dll!ntwaitformultipleobjects") || name.StartsWith ("kernel32.dll!waitformultipleobjects")) {  	found = true;  	int handleCount = stackFrame.Params [0].ToInt32 ();  	IntPtr handleAddress = stackFrame.Params [1];  	WaitType waitType = (WaitType)stackFrame.Params [2].ToInt32 ();  	bool alertable = stackFrame.Params [3].ToInt32 () != 0;  	// use the KiFastSystemCallRet args if we have the wrong args  	if (handleCount > 64) {  		handleCount = lastParams [1].ToInt32 ();  		handleAddress = lastParams [2];  		waitType = (WaitType)lastParams [3].ToInt32 ();  	}  	IntPtr* handles = stackalloc IntPtr[handleCount];  	phandle.ReadMemory (handleAddress' handles' handleCount * IntPtr.Size);  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + "' wait type: " + waitType.ToString () + ") for:");  	for (int i = 0; i < handleCount; i++) {  		sb.AppendLine (this.GetHandleString (_pid' handles [i]));  	}  }  else if (name.StartsWith ("ntdll.dll!zwwaitforsingleobject") || name.StartsWith ("ntdll.dll!ntwaitforsingleobject") || name.StartsWith ("kernel32.dll!waitforsingleobject")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	bool alertable = stackFrame.Params [1].ToInt32 () != 0;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + ") for:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforworkviaworkerfactory") || name.StartsWith ("ntdll.dll!ntwaitforworkviaworkerfactory")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for work from a worker factory:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,analyzeWaitMenuItem_Click,The following statement contains a magic number: if (name.StartsWith ("ntdll.dll!zwwaitfordebugevent") || name.StartsWith ("ntdll.dll!ntwaitfordebugevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a debug event:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforkeyedevent") || name.StartsWith ("ntdll.dll!ntwaitforkeyedevent") || name.StartsWith ("ntdll.dll!zwreleasekeyedevent") || name.StartsWith ("ntdll.dll!ntreleasekeyedevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	IntPtr key = stackFrame.Params [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for a keyed event (key 0x" + key.ToString ("x") + "):");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitformultipleobjects") || name.StartsWith ("ntdll.dll!ntwaitformultipleobjects") || name.StartsWith ("kernel32.dll!waitformultipleobjects")) {  	found = true;  	int handleCount = stackFrame.Params [0].ToInt32 ();  	IntPtr handleAddress = stackFrame.Params [1];  	WaitType waitType = (WaitType)stackFrame.Params [2].ToInt32 ();  	bool alertable = stackFrame.Params [3].ToInt32 () != 0;  	// use the KiFastSystemCallRet args if we have the wrong args  	if (handleCount > 64) {  		handleCount = lastParams [1].ToInt32 ();  		handleAddress = lastParams [2];  		waitType = (WaitType)lastParams [3].ToInt32 ();  	}  	IntPtr* handles = stackalloc IntPtr[handleCount];  	phandle.ReadMemory (handleAddress' handles' handleCount * IntPtr.Size);  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + "' wait type: " + waitType.ToString () + ") for:");  	for (int i = 0; i < handleCount; i++) {  		sb.AppendLine (this.GetHandleString (_pid' handles [i]));  	}  }  else if (name.StartsWith ("ntdll.dll!zwwaitforsingleobject") || name.StartsWith ("ntdll.dll!ntwaitforsingleobject") || name.StartsWith ("kernel32.dll!waitforsingleobject")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	bool alertable = stackFrame.Params [1].ToInt32 () != 0;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + ") for:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforworkviaworkerfactory") || name.StartsWith ("ntdll.dll!ntwaitforworkviaworkerfactory")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for work from a worker factory:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,analyzeWaitMenuItem_Click,The following statement contains a magic number: if (name.StartsWith ("ntdll.dll!zwwaitfordebugevent") || name.StartsWith ("ntdll.dll!ntwaitfordebugevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for a debug event:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforkeyedevent") || name.StartsWith ("ntdll.dll!ntwaitforkeyedevent") || name.StartsWith ("ntdll.dll!zwreleasekeyedevent") || name.StartsWith ("ntdll.dll!ntreleasekeyedevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	IntPtr key = stackFrame.Params [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for a keyed event (key 0x" + key.ToString ("x") + "):");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitformultipleobjects") || name.StartsWith ("ntdll.dll!ntwaitformultipleobjects") || name.StartsWith ("kernel32.dll!waitformultipleobjects")) {  	found = true;  	int handleCount = stackFrame.Params [0].ToInt32 ();  	IntPtr handleAddress = stackFrame.Params [1];  	WaitType waitType = (WaitType)stackFrame.Params [2].ToInt32 ();  	bool alertable = stackFrame.Params [3].ToInt32 () != 0;  	// use the KiFastSystemCallRet args if we have the wrong args  	if (handleCount > 64) {  		handleCount = lastParams [1].ToInt32 ();  		handleAddress = lastParams [2];  		waitType = (WaitType)lastParams [3].ToInt32 ();  	}  	IntPtr* handles = stackalloc IntPtr[handleCount];  	phandle.ReadMemory (handleAddress' handles' handleCount * IntPtr.Size);  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + "' wait type: " + waitType.ToString () + ") for:");  	for (int i = 0; i < handleCount; i++) {  		sb.AppendLine (this.GetHandleString (_pid' handles [i]));  	}  }  else if (name.StartsWith ("ntdll.dll!zwwaitforsingleobject") || name.StartsWith ("ntdll.dll!ntwaitforsingleobject") || name.StartsWith ("kernel32.dll!waitforsingleobject")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	bool alertable = stackFrame.Params [1].ToInt32 () != 0;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + ") for:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforworkviaworkerfactory") || name.StartsWith ("ntdll.dll!ntwaitforworkviaworkerfactory")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for work from a worker factory:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,analyzeWaitMenuItem_Click,The following statement contains a magic number: if (name.StartsWith ("ntdll.dll!zwwaitforkeyedevent") || name.StartsWith ("ntdll.dll!ntwaitforkeyedevent") || name.StartsWith ("ntdll.dll!zwreleasekeyedevent") || name.StartsWith ("ntdll.dll!ntreleasekeyedevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	IntPtr key = stackFrame.Params [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for a keyed event (key 0x" + key.ToString ("x") + "):");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitformultipleobjects") || name.StartsWith ("ntdll.dll!ntwaitformultipleobjects") || name.StartsWith ("kernel32.dll!waitformultipleobjects")) {  	found = true;  	int handleCount = stackFrame.Params [0].ToInt32 ();  	IntPtr handleAddress = stackFrame.Params [1];  	WaitType waitType = (WaitType)stackFrame.Params [2].ToInt32 ();  	bool alertable = stackFrame.Params [3].ToInt32 () != 0;  	// use the KiFastSystemCallRet args if we have the wrong args  	if (handleCount > 64) {  		handleCount = lastParams [1].ToInt32 ();  		handleAddress = lastParams [2];  		waitType = (WaitType)lastParams [3].ToInt32 ();  	}  	IntPtr* handles = stackalloc IntPtr[handleCount];  	phandle.ReadMemory (handleAddress' handles' handleCount * IntPtr.Size);  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + "' wait type: " + waitType.ToString () + ") for:");  	for (int i = 0; i < handleCount; i++) {  		sb.AppendLine (this.GetHandleString (_pid' handles [i]));  	}  }  else if (name.StartsWith ("ntdll.dll!zwwaitforsingleobject") || name.StartsWith ("ntdll.dll!ntwaitforsingleobject") || name.StartsWith ("kernel32.dll!waitforsingleobject")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	bool alertable = stackFrame.Params [1].ToInt32 () != 0;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + ") for:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforworkviaworkerfactory") || name.StartsWith ("ntdll.dll!ntwaitforworkviaworkerfactory")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for work from a worker factory:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,analyzeWaitMenuItem_Click,The following statement contains a magic number: if (name.StartsWith ("ntdll.dll!zwwaitforkeyedevent") || name.StartsWith ("ntdll.dll!ntwaitforkeyedevent") || name.StartsWith ("ntdll.dll!zwreleasekeyedevent") || name.StartsWith ("ntdll.dll!ntreleasekeyedevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	IntPtr key = stackFrame.Params [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for a keyed event (key 0x" + key.ToString ("x") + "):");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitformultipleobjects") || name.StartsWith ("ntdll.dll!ntwaitformultipleobjects") || name.StartsWith ("kernel32.dll!waitformultipleobjects")) {  	found = true;  	int handleCount = stackFrame.Params [0].ToInt32 ();  	IntPtr handleAddress = stackFrame.Params [1];  	WaitType waitType = (WaitType)stackFrame.Params [2].ToInt32 ();  	bool alertable = stackFrame.Params [3].ToInt32 () != 0;  	// use the KiFastSystemCallRet args if we have the wrong args  	if (handleCount > 64) {  		handleCount = lastParams [1].ToInt32 ();  		handleAddress = lastParams [2];  		waitType = (WaitType)lastParams [3].ToInt32 ();  	}  	IntPtr* handles = stackalloc IntPtr[handleCount];  	phandle.ReadMemory (handleAddress' handles' handleCount * IntPtr.Size);  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + "' wait type: " + waitType.ToString () + ") for:");  	for (int i = 0; i < handleCount; i++) {  		sb.AppendLine (this.GetHandleString (_pid' handles [i]));  	}  }  else if (name.StartsWith ("ntdll.dll!zwwaitforsingleobject") || name.StartsWith ("ntdll.dll!ntwaitforsingleobject") || name.StartsWith ("kernel32.dll!waitforsingleobject")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	bool alertable = stackFrame.Params [1].ToInt32 () != 0;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + ") for:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforworkviaworkerfactory") || name.StartsWith ("ntdll.dll!ntwaitforworkviaworkerfactory")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for work from a worker factory:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,analyzeWaitMenuItem_Click,The following statement contains a magic number: if (name.StartsWith ("ntdll.dll!zwwaitforkeyedevent") || name.StartsWith ("ntdll.dll!ntwaitforkeyedevent") || name.StartsWith ("ntdll.dll!zwreleasekeyedevent") || name.StartsWith ("ntdll.dll!ntreleasekeyedevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	IntPtr key = stackFrame.Params [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for a keyed event (key 0x" + key.ToString ("x") + "):");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitformultipleobjects") || name.StartsWith ("ntdll.dll!ntwaitformultipleobjects") || name.StartsWith ("kernel32.dll!waitformultipleobjects")) {  	found = true;  	int handleCount = stackFrame.Params [0].ToInt32 ();  	IntPtr handleAddress = stackFrame.Params [1];  	WaitType waitType = (WaitType)stackFrame.Params [2].ToInt32 ();  	bool alertable = stackFrame.Params [3].ToInt32 () != 0;  	// use the KiFastSystemCallRet args if we have the wrong args  	if (handleCount > 64) {  		handleCount = lastParams [1].ToInt32 ();  		handleAddress = lastParams [2];  		waitType = (WaitType)lastParams [3].ToInt32 ();  	}  	IntPtr* handles = stackalloc IntPtr[handleCount];  	phandle.ReadMemory (handleAddress' handles' handleCount * IntPtr.Size);  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + "' wait type: " + waitType.ToString () + ") for:");  	for (int i = 0; i < handleCount; i++) {  		sb.AppendLine (this.GetHandleString (_pid' handles [i]));  	}  }  else if (name.StartsWith ("ntdll.dll!zwwaitforsingleobject") || name.StartsWith ("ntdll.dll!ntwaitforsingleobject") || name.StartsWith ("kernel32.dll!waitforsingleobject")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	bool alertable = stackFrame.Params [1].ToInt32 () != 0;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + ") for:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforworkviaworkerfactory") || name.StartsWith ("ntdll.dll!ntwaitforworkviaworkerfactory")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for work from a worker factory:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,analyzeWaitMenuItem_Click,The following statement contains a magic number: if (name.StartsWith ("ntdll.dll!zwwaitforkeyedevent") || name.StartsWith ("ntdll.dll!ntwaitforkeyedevent") || name.StartsWith ("ntdll.dll!zwreleasekeyedevent") || name.StartsWith ("ntdll.dll!ntreleasekeyedevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	IntPtr key = stackFrame.Params [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for a keyed event (key 0x" + key.ToString ("x") + "):");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitformultipleobjects") || name.StartsWith ("ntdll.dll!ntwaitformultipleobjects") || name.StartsWith ("kernel32.dll!waitformultipleobjects")) {  	found = true;  	int handleCount = stackFrame.Params [0].ToInt32 ();  	IntPtr handleAddress = stackFrame.Params [1];  	WaitType waitType = (WaitType)stackFrame.Params [2].ToInt32 ();  	bool alertable = stackFrame.Params [3].ToInt32 () != 0;  	// use the KiFastSystemCallRet args if we have the wrong args  	if (handleCount > 64) {  		handleCount = lastParams [1].ToInt32 ();  		handleAddress = lastParams [2];  		waitType = (WaitType)lastParams [3].ToInt32 ();  	}  	IntPtr* handles = stackalloc IntPtr[handleCount];  	phandle.ReadMemory (handleAddress' handles' handleCount * IntPtr.Size);  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + "' wait type: " + waitType.ToString () + ") for:");  	for (int i = 0; i < handleCount; i++) {  		sb.AppendLine (this.GetHandleString (_pid' handles [i]));  	}  }  else if (name.StartsWith ("ntdll.dll!zwwaitforsingleobject") || name.StartsWith ("ntdll.dll!ntwaitforsingleobject") || name.StartsWith ("kernel32.dll!waitforsingleobject")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	bool alertable = stackFrame.Params [1].ToInt32 () != 0;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + ") for:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforworkviaworkerfactory") || name.StartsWith ("ntdll.dll!ntwaitforworkviaworkerfactory")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for work from a worker factory:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,analyzeWaitMenuItem_Click,The following statement contains a magic number: if (name.StartsWith ("ntdll.dll!zwwaitforkeyedevent") || name.StartsWith ("ntdll.dll!ntwaitforkeyedevent") || name.StartsWith ("ntdll.dll!zwreleasekeyedevent") || name.StartsWith ("ntdll.dll!ntreleasekeyedevent")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	IntPtr key = stackFrame.Params [1];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (" + name + ") for a keyed event (key 0x" + key.ToString ("x") + "):");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitformultipleobjects") || name.StartsWith ("ntdll.dll!ntwaitformultipleobjects") || name.StartsWith ("kernel32.dll!waitformultipleobjects")) {  	found = true;  	int handleCount = stackFrame.Params [0].ToInt32 ();  	IntPtr handleAddress = stackFrame.Params [1];  	WaitType waitType = (WaitType)stackFrame.Params [2].ToInt32 ();  	bool alertable = stackFrame.Params [3].ToInt32 () != 0;  	// use the KiFastSystemCallRet args if we have the wrong args  	if (handleCount > 64) {  		handleCount = lastParams [1].ToInt32 ();  		handleAddress = lastParams [2];  		waitType = (WaitType)lastParams [3].ToInt32 ();  	}  	IntPtr* handles = stackalloc IntPtr[handleCount];  	phandle.ReadMemory (handleAddress' handles' handleCount * IntPtr.Size);  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + "' wait type: " + waitType.ToString () + ") for:");  	for (int i = 0; i < handleCount; i++) {  		sb.AppendLine (this.GetHandleString (_pid' handles [i]));  	}  }  else if (name.StartsWith ("ntdll.dll!zwwaitforsingleobject") || name.StartsWith ("ntdll.dll!ntwaitforsingleobject") || name.StartsWith ("kernel32.dll!waitforsingleobject")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	bool alertable = stackFrame.Params [1].ToInt32 () != 0;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + ") for:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforworkviaworkerfactory") || name.StartsWith ("ntdll.dll!ntwaitforworkviaworkerfactory")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for work from a worker factory:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,analyzeWaitMenuItem_Click,The following statement contains a magic number: if (name.StartsWith ("ntdll.dll!zwwaitformultipleobjects") || name.StartsWith ("ntdll.dll!ntwaitformultipleobjects") || name.StartsWith ("kernel32.dll!waitformultipleobjects")) {  	found = true;  	int handleCount = stackFrame.Params [0].ToInt32 ();  	IntPtr handleAddress = stackFrame.Params [1];  	WaitType waitType = (WaitType)stackFrame.Params [2].ToInt32 ();  	bool alertable = stackFrame.Params [3].ToInt32 () != 0;  	// use the KiFastSystemCallRet args if we have the wrong args  	if (handleCount > 64) {  		handleCount = lastParams [1].ToInt32 ();  		handleAddress = lastParams [2];  		waitType = (WaitType)lastParams [3].ToInt32 ();  	}  	IntPtr* handles = stackalloc IntPtr[handleCount];  	phandle.ReadMemory (handleAddress' handles' handleCount * IntPtr.Size);  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + "' wait type: " + waitType.ToString () + ") for:");  	for (int i = 0; i < handleCount; i++) {  		sb.AppendLine (this.GetHandleString (_pid' handles [i]));  	}  }  else if (name.StartsWith ("ntdll.dll!zwwaitforsingleobject") || name.StartsWith ("ntdll.dll!ntwaitforsingleobject") || name.StartsWith ("kernel32.dll!waitforsingleobject")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	bool alertable = stackFrame.Params [1].ToInt32 () != 0;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + ") for:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforworkviaworkerfactory") || name.StartsWith ("ntdll.dll!ntwaitforworkviaworkerfactory")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for work from a worker factory:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,analyzeWaitMenuItem_Click,The following statement contains a magic number: if (name.StartsWith ("ntdll.dll!zwwaitformultipleobjects") || name.StartsWith ("ntdll.dll!ntwaitformultipleobjects") || name.StartsWith ("kernel32.dll!waitformultipleobjects")) {  	found = true;  	int handleCount = stackFrame.Params [0].ToInt32 ();  	IntPtr handleAddress = stackFrame.Params [1];  	WaitType waitType = (WaitType)stackFrame.Params [2].ToInt32 ();  	bool alertable = stackFrame.Params [3].ToInt32 () != 0;  	// use the KiFastSystemCallRet args if we have the wrong args  	if (handleCount > 64) {  		handleCount = lastParams [1].ToInt32 ();  		handleAddress = lastParams [2];  		waitType = (WaitType)lastParams [3].ToInt32 ();  	}  	IntPtr* handles = stackalloc IntPtr[handleCount];  	phandle.ReadMemory (handleAddress' handles' handleCount * IntPtr.Size);  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + "' wait type: " + waitType.ToString () + ") for:");  	for (int i = 0; i < handleCount; i++) {  		sb.AppendLine (this.GetHandleString (_pid' handles [i]));  	}  }  else if (name.StartsWith ("ntdll.dll!zwwaitforsingleobject") || name.StartsWith ("ntdll.dll!ntwaitforsingleobject") || name.StartsWith ("kernel32.dll!waitforsingleobject")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	bool alertable = stackFrame.Params [1].ToInt32 () != 0;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + ") for:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforworkviaworkerfactory") || name.StartsWith ("ntdll.dll!ntwaitforworkviaworkerfactory")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for work from a worker factory:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,analyzeWaitMenuItem_Click,The following statement contains a magic number: if (name.StartsWith ("ntdll.dll!zwwaitformultipleobjects") || name.StartsWith ("ntdll.dll!ntwaitformultipleobjects") || name.StartsWith ("kernel32.dll!waitformultipleobjects")) {  	found = true;  	int handleCount = stackFrame.Params [0].ToInt32 ();  	IntPtr handleAddress = stackFrame.Params [1];  	WaitType waitType = (WaitType)stackFrame.Params [2].ToInt32 ();  	bool alertable = stackFrame.Params [3].ToInt32 () != 0;  	// use the KiFastSystemCallRet args if we have the wrong args  	if (handleCount > 64) {  		handleCount = lastParams [1].ToInt32 ();  		handleAddress = lastParams [2];  		waitType = (WaitType)lastParams [3].ToInt32 ();  	}  	IntPtr* handles = stackalloc IntPtr[handleCount];  	phandle.ReadMemory (handleAddress' handles' handleCount * IntPtr.Size);  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + "' wait type: " + waitType.ToString () + ") for:");  	for (int i = 0; i < handleCount; i++) {  		sb.AppendLine (this.GetHandleString (_pid' handles [i]));  	}  }  else if (name.StartsWith ("ntdll.dll!zwwaitforsingleobject") || name.StartsWith ("ntdll.dll!ntwaitforsingleobject") || name.StartsWith ("kernel32.dll!waitforsingleobject")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	bool alertable = stackFrame.Params [1].ToInt32 () != 0;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + ") for:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforworkviaworkerfactory") || name.StartsWith ("ntdll.dll!ntwaitforworkviaworkerfactory")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for work from a worker factory:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,analyzeWaitMenuItem_Click,The following statement contains a magic number: if (name.StartsWith ("ntdll.dll!zwwaitformultipleobjects") || name.StartsWith ("ntdll.dll!ntwaitformultipleobjects") || name.StartsWith ("kernel32.dll!waitformultipleobjects")) {  	found = true;  	int handleCount = stackFrame.Params [0].ToInt32 ();  	IntPtr handleAddress = stackFrame.Params [1];  	WaitType waitType = (WaitType)stackFrame.Params [2].ToInt32 ();  	bool alertable = stackFrame.Params [3].ToInt32 () != 0;  	// use the KiFastSystemCallRet args if we have the wrong args  	if (handleCount > 64) {  		handleCount = lastParams [1].ToInt32 ();  		handleAddress = lastParams [2];  		waitType = (WaitType)lastParams [3].ToInt32 ();  	}  	IntPtr* handles = stackalloc IntPtr[handleCount];  	phandle.ReadMemory (handleAddress' handles' handleCount * IntPtr.Size);  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + "' wait type: " + waitType.ToString () + ") for:");  	for (int i = 0; i < handleCount; i++) {  		sb.AppendLine (this.GetHandleString (_pid' handles [i]));  	}  }  else if (name.StartsWith ("ntdll.dll!zwwaitforsingleobject") || name.StartsWith ("ntdll.dll!ntwaitforsingleobject") || name.StartsWith ("kernel32.dll!waitforsingleobject")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	bool alertable = stackFrame.Params [1].ToInt32 () != 0;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + ") for:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforworkviaworkerfactory") || name.StartsWith ("ntdll.dll!ntwaitforworkviaworkerfactory")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for work from a worker factory:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,analyzeWaitMenuItem_Click,The following statement contains a magic number: if (name.StartsWith ("ntdll.dll!zwwaitformultipleobjects") || name.StartsWith ("ntdll.dll!ntwaitformultipleobjects") || name.StartsWith ("kernel32.dll!waitformultipleobjects")) {  	found = true;  	int handleCount = stackFrame.Params [0].ToInt32 ();  	IntPtr handleAddress = stackFrame.Params [1];  	WaitType waitType = (WaitType)stackFrame.Params [2].ToInt32 ();  	bool alertable = stackFrame.Params [3].ToInt32 () != 0;  	// use the KiFastSystemCallRet args if we have the wrong args  	if (handleCount > 64) {  		handleCount = lastParams [1].ToInt32 ();  		handleAddress = lastParams [2];  		waitType = (WaitType)lastParams [3].ToInt32 ();  	}  	IntPtr* handles = stackalloc IntPtr[handleCount];  	phandle.ReadMemory (handleAddress' handles' handleCount * IntPtr.Size);  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + "' wait type: " + waitType.ToString () + ") for:");  	for (int i = 0; i < handleCount; i++) {  		sb.AppendLine (this.GetHandleString (_pid' handles [i]));  	}  }  else if (name.StartsWith ("ntdll.dll!zwwaitforsingleobject") || name.StartsWith ("ntdll.dll!ntwaitforsingleobject") || name.StartsWith ("kernel32.dll!waitforsingleobject")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	bool alertable = stackFrame.Params [1].ToInt32 () != 0;  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting (alertable: " + alertable.ToString () + ") for:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  else if (name.StartsWith ("ntdll.dll!zwwaitforworkviaworkerfactory") || name.StartsWith ("ntdll.dll!ntwaitforworkviaworkerfactory")) {  	found = true;  	IntPtr handle = stackFrame.Params [0];  	sb.AppendLine ("Thread " + tid.ToString () + " is waiting for work from a worker factory:");  	sb.AppendLine (this.GetHandleString (_pid' handle));  }  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,analyzeWaitMenuItem_Click,The following statement contains a magic number: if (handleCount > 64) {  	handleCount = lastParams [1].ToInt32 ();  	handleAddress = lastParams [2];  	waitType = (WaitType)lastParams [3].ToInt32 ();  }  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,analyzeWaitMenuItem_Click,The following statement contains a magic number: if (handleCount > 64) {  	handleCount = lastParams [1].ToInt32 ();  	handleAddress = lastParams [2];  	waitType = (WaitType)lastParams [3].ToInt32 ();  }  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,analyzeWaitMenuItem_Click,The following statement contains a magic number: if (handleCount > 64) {  	handleCount = lastParams [1].ToInt32 ();  	handleAddress = lastParams [2];  	waitType = (WaitType)lastParams [3].ToInt32 ();  }  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,analyzeWaitMenuItem_Click,The following statement contains a magic number: handleAddress = lastParams [2];  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,analyzeWaitMenuItem_Click,The following statement contains a magic number: waitType = (WaitType)lastParams [3].ToInt32 ();  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,ioPriority2ThreadMenuItem_Click,The following statement contains a magic number: SetThreadIoPriority (2);  
Magic Number,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,ioPriority3ThreadMenuItem_Click,The following statement contains a magic number: SetThreadIoPriority (3);  
Magic Number,ProcessHacker.Components,TokenProperties,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\TokenProperties.cs,TokenProperties,The following statement contains a magic number: try {  	using (TokenHandle thandle = _object.GetToken (TokenAccess.Query)) {  		// "General"  		try {  			textUser.Text = thandle.GetUser ().GetFullName (true);  			textUserSID.Text = thandle.GetUser ().StringSid;  			textOwner.Text = thandle.GetOwner ().GetFullName (true);  			textPrimaryGroup.Text = thandle.GetPrimaryGroup ().GetFullName (true);  		}  		catch (Exception ex) {  			textUser.Text = "(" + ex.Message + ")";  		}  		try {  			textSessionID.Text = thandle.GetSessionId ().ToString ();  		}  		catch (Exception ex) {  			textSessionID.Text = "(" + ex.Message + ")";  		}  		try {  			var type = thandle.GetElevationType ();  			if (type == TokenElevationType.Default)  				textElevated.Text = "N/A";  			else if (type == TokenElevationType.Full)  				textElevated.Text = "True";  			else if (type == TokenElevationType.Limited)  				textElevated.Text = "False";  		}  		catch (Exception ex) {  			textElevated.Text = "(" + ex.Message + ")";  		}  		// Determine if the token has a linked token.  		if (OSVersion.HasUac) {  			try {  				TokenHandle linkedToken = thandle.GetLinkedToken ();  				if (linkedToken != null)  					linkedToken.Dispose ();  				else  					buttonLinkedToken.Visible = false;  			}  			catch {  				buttonLinkedToken.Visible = false;  			}  		}  		else {  			buttonLinkedToken.Visible = false;  		}  		try {  			bool virtAllowed = thandle.IsVirtualizationAllowed ();  			bool virtEnabled = thandle.IsVirtualizationEnabled ();  			if (virtEnabled)  				textVirtualized.Text = "Enabled";  			else if (virtAllowed)  				textVirtualized.Text = "Disabled";  			else  				textVirtualized.Text = "Not Allowed";  		}  		catch (Exception ex) {  			textVirtualized.Text = "(" + ex.Message + ")";  		}  		try {  			using (TokenHandle tokenSource = _object.GetToken (TokenAccess.QuerySource)) {  				var source = tokenSource.GetSource ();  				textSourceName.Text = source.SourceName.TrimEnd ('\0'' '\r'' '\n'' ' ');  				long luid = source.SourceIdentifier.QuadPart;  				textSourceLUID.Text = "0x" + luid.ToString ("x");  			}  		}  		catch (Exception ex) {  			textSourceName.Text = "(" + ex.Message + ")";  		}  		// "Advanced"  		try {  			var statistics = thandle.GetStatistics ();  			textTokenType.Text = statistics.TokenType.ToString ();  			textImpersonationLevel.Text = statistics.ImpersonationLevel.ToString ();  			textTokenId.Text = "0x" + statistics.TokenId.ToString ();  			textAuthenticationId.Text = "0x" + statistics.AuthenticationId.ToString ();  			textMemoryUsed.Text = Utils.FormatSize (statistics.DynamicCharged);  			textMemoryAvailable.Text = Utils.FormatSize (statistics.DynamicAvailable);  		}  		catch (Exception ex) {  			textTokenType.Text = "(" + ex.Message + ")";  		}  		try {  			var groups = thandle.GetGroups ();  			_groups = new TokenGroupsList (groups);  			foreach (var group in groups)  				group.Dispose ();  			_groups.Dock = DockStyle.Fill;  			tabGroups.Controls.Add (_groups);  		}  		catch (Exception ex) {  			tabGroups.Text = "(" + ex.Message + ")";  		}  		try {  			var privileges = thandle.GetPrivileges ();  			for (int i = 0; i < privileges.Length; i++) {  				this.AddPrivilege (privileges [i]);  			}  		}  		catch (Exception ex) {  			tabPrivileges.Text = "(" + ex.Message + ")";  		}  	}  }  catch (Exception ex) {  	tabControl.Visible = false;  	Label errorMessage = new Label ();  	errorMessage.Text = ex.Message;  	this.Padding = new Padding (15' 10' 0' 0);  	this.Controls.Add (errorMessage);  }  
Magic Number,ProcessHacker.Components,TokenProperties,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\TokenProperties.cs,TokenProperties,The following statement contains a magic number: try {  	using (TokenHandle thandle = _object.GetToken (TokenAccess.Query)) {  		// "General"  		try {  			textUser.Text = thandle.GetUser ().GetFullName (true);  			textUserSID.Text = thandle.GetUser ().StringSid;  			textOwner.Text = thandle.GetOwner ().GetFullName (true);  			textPrimaryGroup.Text = thandle.GetPrimaryGroup ().GetFullName (true);  		}  		catch (Exception ex) {  			textUser.Text = "(" + ex.Message + ")";  		}  		try {  			textSessionID.Text = thandle.GetSessionId ().ToString ();  		}  		catch (Exception ex) {  			textSessionID.Text = "(" + ex.Message + ")";  		}  		try {  			var type = thandle.GetElevationType ();  			if (type == TokenElevationType.Default)  				textElevated.Text = "N/A";  			else if (type == TokenElevationType.Full)  				textElevated.Text = "True";  			else if (type == TokenElevationType.Limited)  				textElevated.Text = "False";  		}  		catch (Exception ex) {  			textElevated.Text = "(" + ex.Message + ")";  		}  		// Determine if the token has a linked token.  		if (OSVersion.HasUac) {  			try {  				TokenHandle linkedToken = thandle.GetLinkedToken ();  				if (linkedToken != null)  					linkedToken.Dispose ();  				else  					buttonLinkedToken.Visible = false;  			}  			catch {  				buttonLinkedToken.Visible = false;  			}  		}  		else {  			buttonLinkedToken.Visible = false;  		}  		try {  			bool virtAllowed = thandle.IsVirtualizationAllowed ();  			bool virtEnabled = thandle.IsVirtualizationEnabled ();  			if (virtEnabled)  				textVirtualized.Text = "Enabled";  			else if (virtAllowed)  				textVirtualized.Text = "Disabled";  			else  				textVirtualized.Text = "Not Allowed";  		}  		catch (Exception ex) {  			textVirtualized.Text = "(" + ex.Message + ")";  		}  		try {  			using (TokenHandle tokenSource = _object.GetToken (TokenAccess.QuerySource)) {  				var source = tokenSource.GetSource ();  				textSourceName.Text = source.SourceName.TrimEnd ('\0'' '\r'' '\n'' ' ');  				long luid = source.SourceIdentifier.QuadPart;  				textSourceLUID.Text = "0x" + luid.ToString ("x");  			}  		}  		catch (Exception ex) {  			textSourceName.Text = "(" + ex.Message + ")";  		}  		// "Advanced"  		try {  			var statistics = thandle.GetStatistics ();  			textTokenType.Text = statistics.TokenType.ToString ();  			textImpersonationLevel.Text = statistics.ImpersonationLevel.ToString ();  			textTokenId.Text = "0x" + statistics.TokenId.ToString ();  			textAuthenticationId.Text = "0x" + statistics.AuthenticationId.ToString ();  			textMemoryUsed.Text = Utils.FormatSize (statistics.DynamicCharged);  			textMemoryAvailable.Text = Utils.FormatSize (statistics.DynamicAvailable);  		}  		catch (Exception ex) {  			textTokenType.Text = "(" + ex.Message + ")";  		}  		try {  			var groups = thandle.GetGroups ();  			_groups = new TokenGroupsList (groups);  			foreach (var group in groups)  				group.Dispose ();  			_groups.Dock = DockStyle.Fill;  			tabGroups.Controls.Add (_groups);  		}  		catch (Exception ex) {  			tabGroups.Text = "(" + ex.Message + ")";  		}  		try {  			var privileges = thandle.GetPrivileges ();  			for (int i = 0; i < privileges.Length; i++) {  				this.AddPrivilege (privileges [i]);  			}  		}  		catch (Exception ex) {  			tabPrivileges.Text = "(" + ex.Message + ")";  		}  	}  }  catch (Exception ex) {  	tabControl.Visible = false;  	Label errorMessage = new Label ();  	errorMessage.Text = ex.Message;  	this.Padding = new Padding (15' 10' 0' 0);  	this.Controls.Add (errorMessage);  }  
Magic Number,ProcessHacker.Components,TokenProperties,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\TokenProperties.cs,TokenProperties,The following statement contains a magic number: this.Padding = new Padding (15' 10' 0' 0);  
Magic Number,ProcessHacker.Components,TokenProperties,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\TokenProperties.cs,TokenProperties,The following statement contains a magic number: this.Padding = new Padding (15' 10' 0' 0);  
Magic Number,ProcessHacker.Components,VerticleProgressBar,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\VerticleProgressBar.cs,VerticleProgressBar_Paint,The following statement contains a magic number: rChunk.DrawBackground (e.Graphics' new Rectangle (new Point (e.ClipRectangle.Left + 1' e.ClipRectangle.Top + 1 + (int)(this.Size.Height * (1 - _value)))' new Size (this.Size.Width - 2' (int)(this.Size.Height * _value) - 2)));  
Magic Number,ProcessHacker.Components,VerticleProgressBar,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\VerticleProgressBar.cs,VerticleProgressBar_Paint,The following statement contains a magic number: rChunk.DrawBackground (e.Graphics' new Rectangle (new Point (e.ClipRectangle.Left + 1' e.ClipRectangle.Top + 1 + (int)(this.Size.Height * (1 - _value)))' new Size (this.Size.Width - 2' (int)(this.Size.Height * _value) - 2)));  
Magic Number,ProcessHacker.Components,UtilitiesButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\UtilitiesButton.cs,UtilitiesButton,The following statement contains a magic number: this.Size = new Size (24' 24);  
Magic Number,ProcessHacker.Components,UtilitiesButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\UtilitiesButton.cs,UtilitiesButton,The following statement contains a magic number: this.Size = new Size (24' 24);  
Magic Number,ProcessHacker.Components,UtilitiesButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\UtilitiesButton.cs,InsertNumber,The following statement contains a magic number: if (prompt.ShowDialog () == DialogResult.OK) {  	byte[] bytes = new byte[byteCount];  	long number = (long)BaseConverter.ToNumberParse (prompt.Value);  	for (int i = 0; i < bytes.Length; i++) {  		bytes [BigEndian ? (bytes.Length - i - 1) : i] = (byte)((number >> (i * 8)) & 0xff);  	}  	_hexbox.ByteProvider.DeleteBytes (_hexbox.SelectionStart' _hexbox.SelectionLength);  	_hexbox.ByteProvider.InsertBytes (_hexbox.SelectionStart' bytes);  	_hexbox.Select (_hexbox.SelectionStart' bytes.Length);  }  
Magic Number,ProcessHacker.Components,UtilitiesButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\UtilitiesButton.cs,InsertNumber,The following statement contains a magic number: for (int i = 0; i < bytes.Length; i++) {  	bytes [BigEndian ? (bytes.Length - i - 1) : i] = (byte)((number >> (i * 8)) & 0xff);  }  
Magic Number,ProcessHacker.Components,UtilitiesButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\UtilitiesButton.cs,InsertNumber,The following statement contains a magic number: bytes [BigEndian ? (bytes.Length - i - 1) : i] = (byte)((number >> (i * 8)) & 0xff);  
Magic Number,ProcessHacker.Components,UtilitiesButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\UtilitiesButton.cs,bitLittleEndianMenuItem_Click,The following statement contains a magic number: InsertNumber (_hexbox' 2' false);  
Magic Number,ProcessHacker.Components,UtilitiesButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\UtilitiesButton.cs,bitBigEndianMenuItem_Click,The following statement contains a magic number: InsertNumber (_hexbox' 2' true);  
Magic Number,ProcessHacker.Components,UtilitiesButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\UtilitiesButton.cs,bitLittleEndianMenuItem1_Click,The following statement contains a magic number: InsertNumber (_hexbox' 4' false);  
Magic Number,ProcessHacker.Components,UtilitiesButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\UtilitiesButton.cs,bitBigEndianMenuItem1_Click,The following statement contains a magic number: InsertNumber (_hexbox' 4' true);  
Magic Number,ProcessHacker.Components,UtilitiesButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\UtilitiesButton.cs,bitLittleEndianMenuItem2_Click,The following statement contains a magic number: InsertNumber (_hexbox' 8' false);  
Magic Number,ProcessHacker.Components,UtilitiesButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\UtilitiesButton.cs,bitBigEndianMenuItem2_Click,The following statement contains a magic number: InsertNumber (_hexbox' 8' true);  
Magic Number,TaskbarLib,JumpListManager,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\TaskbarLib\JumpLists\JumpListManager.cs,GetApplicationDestinations,The following statement contains a magic number: for (uint i = 0; i < count; ++i) {  	try {  		array.GetAt (i' ref iidShellItem' out obj);  	}  	catch (Exception)//Wrong type  	 {  	}  	if (obj == null) {  		HResult getAtResult = array.GetAt (i' ref iidShellLink' out obj);  		getAtResult.ThrowIf ();  		//This shouldn't fail since if it's not IShellItem  		//then it must be IShellLink.  		IShellLinkW link = (IShellLinkW)obj;  		ShellLink wrapper = new ShellLink ();  		StringBuilder sb = new StringBuilder (256);  		HResult getPathResult = link.GetPath (sb' sb.Capacity' IntPtr.Zero' 2);  		getPathResult.ThrowIf ();  		wrapper.Path = sb.ToString ();  		HResult getArgumentsResult = link.GetArguments (sb' sb.Capacity);  		getArgumentsResult.ThrowIf ();  		wrapper.Arguments = sb.ToString ();  		int iconId;  		HResult getIconLocationResult = link.GetIconLocation (sb' sb.Capacity' out iconId);  		getIconLocationResult.ThrowIf ();  		wrapper.IconIndex = iconId;  		wrapper.IconLocation = sb.ToString ();  		uint showCmd;  		HResult getShowCmdResult = link.GetShowCmd (out showCmd);  		getShowCmdResult.ThrowIf ();  		wrapper.ShowCommand = (WindowShowCommand)showCmd;  		HResult getWorkingDirectoryResult = link.GetWorkingDirectory (sb' sb.Capacity);  		getWorkingDirectoryResult.ThrowIf ();  		wrapper.WorkingDirectory = sb.ToString ();  		returnValue.Add (wrapper);  	}  	else//It's an IShellItem.  	 {  		IShellItem item = (IShellItem)obj;  		ShellItem wrapper = new ShellItem ();  		string path;  		HResult getDisplayNameResult = item.GetDisplayName (SIGDN.SIGDN_FILESYSPATH' out path);  		getDisplayNameResult.ThrowIf ();  		wrapper.Path = path;  		//Title and Category are irrelevant here' because it's  		//an IShellItem.  The user might want to see them' but he's  		//free to go to the IShellItem and look at its property store.  		returnValue.Add (wrapper);  	}  }  
Magic Number,TaskbarLib,JumpListManager,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\TaskbarLib\JumpLists\JumpListManager.cs,GetApplicationDestinations,The following statement contains a magic number: for (uint i = 0; i < count; ++i) {  	try {  		array.GetAt (i' ref iidShellItem' out obj);  	}  	catch (Exception)//Wrong type  	 {  	}  	if (obj == null) {  		HResult getAtResult = array.GetAt (i' ref iidShellLink' out obj);  		getAtResult.ThrowIf ();  		//This shouldn't fail since if it's not IShellItem  		//then it must be IShellLink.  		IShellLinkW link = (IShellLinkW)obj;  		ShellLink wrapper = new ShellLink ();  		StringBuilder sb = new StringBuilder (256);  		HResult getPathResult = link.GetPath (sb' sb.Capacity' IntPtr.Zero' 2);  		getPathResult.ThrowIf ();  		wrapper.Path = sb.ToString ();  		HResult getArgumentsResult = link.GetArguments (sb' sb.Capacity);  		getArgumentsResult.ThrowIf ();  		wrapper.Arguments = sb.ToString ();  		int iconId;  		HResult getIconLocationResult = link.GetIconLocation (sb' sb.Capacity' out iconId);  		getIconLocationResult.ThrowIf ();  		wrapper.IconIndex = iconId;  		wrapper.IconLocation = sb.ToString ();  		uint showCmd;  		HResult getShowCmdResult = link.GetShowCmd (out showCmd);  		getShowCmdResult.ThrowIf ();  		wrapper.ShowCommand = (WindowShowCommand)showCmd;  		HResult getWorkingDirectoryResult = link.GetWorkingDirectory (sb' sb.Capacity);  		getWorkingDirectoryResult.ThrowIf ();  		wrapper.WorkingDirectory = sb.ToString ();  		returnValue.Add (wrapper);  	}  	else//It's an IShellItem.  	 {  		IShellItem item = (IShellItem)obj;  		ShellItem wrapper = new ShellItem ();  		string path;  		HResult getDisplayNameResult = item.GetDisplayName (SIGDN.SIGDN_FILESYSPATH' out path);  		getDisplayNameResult.ThrowIf ();  		wrapper.Path = path;  		//Title and Category are irrelevant here' because it's  		//an IShellItem.  The user might want to see them' but he's  		//free to go to the IShellItem and look at its property store.  		returnValue.Add (wrapper);  	}  }  
Magic Number,TaskbarLib,JumpListManager,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\TaskbarLib\JumpLists\JumpListManager.cs,GetApplicationDestinations,The following statement contains a magic number: if (obj == null) {  	HResult getAtResult = array.GetAt (i' ref iidShellLink' out obj);  	getAtResult.ThrowIf ();  	//This shouldn't fail since if it's not IShellItem  	//then it must be IShellLink.  	IShellLinkW link = (IShellLinkW)obj;  	ShellLink wrapper = new ShellLink ();  	StringBuilder sb = new StringBuilder (256);  	HResult getPathResult = link.GetPath (sb' sb.Capacity' IntPtr.Zero' 2);  	getPathResult.ThrowIf ();  	wrapper.Path = sb.ToString ();  	HResult getArgumentsResult = link.GetArguments (sb' sb.Capacity);  	getArgumentsResult.ThrowIf ();  	wrapper.Arguments = sb.ToString ();  	int iconId;  	HResult getIconLocationResult = link.GetIconLocation (sb' sb.Capacity' out iconId);  	getIconLocationResult.ThrowIf ();  	wrapper.IconIndex = iconId;  	wrapper.IconLocation = sb.ToString ();  	uint showCmd;  	HResult getShowCmdResult = link.GetShowCmd (out showCmd);  	getShowCmdResult.ThrowIf ();  	wrapper.ShowCommand = (WindowShowCommand)showCmd;  	HResult getWorkingDirectoryResult = link.GetWorkingDirectory (sb' sb.Capacity);  	getWorkingDirectoryResult.ThrowIf ();  	wrapper.WorkingDirectory = sb.ToString ();  	returnValue.Add (wrapper);  }  else//It's an IShellItem.   {  	IShellItem item = (IShellItem)obj;  	ShellItem wrapper = new ShellItem ();  	string path;  	HResult getDisplayNameResult = item.GetDisplayName (SIGDN.SIGDN_FILESYSPATH' out path);  	getDisplayNameResult.ThrowIf ();  	wrapper.Path = path;  	//Title and Category are irrelevant here' because it's  	//an IShellItem.  The user might want to see them' but he's  	//free to go to the IShellItem and look at its property store.  	returnValue.Add (wrapper);  }  
Magic Number,TaskbarLib,JumpListManager,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\TaskbarLib\JumpLists\JumpListManager.cs,GetApplicationDestinations,The following statement contains a magic number: if (obj == null) {  	HResult getAtResult = array.GetAt (i' ref iidShellLink' out obj);  	getAtResult.ThrowIf ();  	//This shouldn't fail since if it's not IShellItem  	//then it must be IShellLink.  	IShellLinkW link = (IShellLinkW)obj;  	ShellLink wrapper = new ShellLink ();  	StringBuilder sb = new StringBuilder (256);  	HResult getPathResult = link.GetPath (sb' sb.Capacity' IntPtr.Zero' 2);  	getPathResult.ThrowIf ();  	wrapper.Path = sb.ToString ();  	HResult getArgumentsResult = link.GetArguments (sb' sb.Capacity);  	getArgumentsResult.ThrowIf ();  	wrapper.Arguments = sb.ToString ();  	int iconId;  	HResult getIconLocationResult = link.GetIconLocation (sb' sb.Capacity' out iconId);  	getIconLocationResult.ThrowIf ();  	wrapper.IconIndex = iconId;  	wrapper.IconLocation = sb.ToString ();  	uint showCmd;  	HResult getShowCmdResult = link.GetShowCmd (out showCmd);  	getShowCmdResult.ThrowIf ();  	wrapper.ShowCommand = (WindowShowCommand)showCmd;  	HResult getWorkingDirectoryResult = link.GetWorkingDirectory (sb' sb.Capacity);  	getWorkingDirectoryResult.ThrowIf ();  	wrapper.WorkingDirectory = sb.ToString ();  	returnValue.Add (wrapper);  }  else//It's an IShellItem.   {  	IShellItem item = (IShellItem)obj;  	ShellItem wrapper = new ShellItem ();  	string path;  	HResult getDisplayNameResult = item.GetDisplayName (SIGDN.SIGDN_FILESYSPATH' out path);  	getDisplayNameResult.ThrowIf ();  	wrapper.Path = path;  	//Title and Category are irrelevant here' because it's  	//an IShellItem.  The user might want to see them' but he's  	//free to go to the IShellItem and look at its property store.  	returnValue.Add (wrapper);  }  
Magic Number,TaskbarLib,JumpListManager,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\TaskbarLib\JumpLists\JumpListManager.cs,BeginList,The following statement contains a magic number: for (uint i = 0; i < count; ++i) {  	object item;  	removedItems.GetAt (i' ref SafeNativeMethods.IID_IUnknown' out item);  	try {  		IShellLinkW shellLink = (IShellLinkW)item;  		if (shellLink != null) {  			StringBuilder sb = new StringBuilder (256);  			shellLink.GetPath (sb' sb.Capacity' IntPtr.Zero' 2);  			removedItemsArr [i] = sb.ToString ();  		}  		continue;  	}  	catch (InvalidCastException)//It's not a ShellLink  	 {  	}  	try {  		IShellItem shellItem = (IShellItem)item;  		if (shellItem != null) {  			string path;  			shellItem.GetDisplayName (SIGDN.SIGDN_FILESYSPATH' out path);  			removedItemsArr [i] = path;  		}  	}  	catch (InvalidCastException) {  		//It's neither a shell link nor a shell item.  		//This is impossible.  		Debug.Assert (false' "List of removed items contains something that is neither a shell item nor a shell link");  	}  }  
Magic Number,TaskbarLib,JumpListManager,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\TaskbarLib\JumpLists\JumpListManager.cs,BeginList,The following statement contains a magic number: for (uint i = 0; i < count; ++i) {  	object item;  	removedItems.GetAt (i' ref SafeNativeMethods.IID_IUnknown' out item);  	try {  		IShellLinkW shellLink = (IShellLinkW)item;  		if (shellLink != null) {  			StringBuilder sb = new StringBuilder (256);  			shellLink.GetPath (sb' sb.Capacity' IntPtr.Zero' 2);  			removedItemsArr [i] = sb.ToString ();  		}  		continue;  	}  	catch (InvalidCastException)//It's not a ShellLink  	 {  	}  	try {  		IShellItem shellItem = (IShellItem)item;  		if (shellItem != null) {  			string path;  			shellItem.GetDisplayName (SIGDN.SIGDN_FILESYSPATH' out path);  			removedItemsArr [i] = path;  		}  	}  	catch (InvalidCastException) {  		//It's neither a shell link nor a shell item.  		//This is impossible.  		Debug.Assert (false' "List of removed items contains something that is neither a shell item nor a shell link");  	}  }  
Magic Number,TaskbarLib,JumpListManager,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\TaskbarLib\JumpLists\JumpListManager.cs,BeginList,The following statement contains a magic number: try {  	IShellLinkW shellLink = (IShellLinkW)item;  	if (shellLink != null) {  		StringBuilder sb = new StringBuilder (256);  		shellLink.GetPath (sb' sb.Capacity' IntPtr.Zero' 2);  		removedItemsArr [i] = sb.ToString ();  	}  	continue;  }  catch (InvalidCastException)//It's not a ShellLink   {  }  
Magic Number,TaskbarLib,JumpListManager,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\TaskbarLib\JumpLists\JumpListManager.cs,BeginList,The following statement contains a magic number: try {  	IShellLinkW shellLink = (IShellLinkW)item;  	if (shellLink != null) {  		StringBuilder sb = new StringBuilder (256);  		shellLink.GetPath (sb' sb.Capacity' IntPtr.Zero' 2);  		removedItemsArr [i] = sb.ToString ();  	}  	continue;  }  catch (InvalidCastException)//It's not a ShellLink   {  }  
Magic Number,TaskbarLib,JumpListManager,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\TaskbarLib\JumpLists\JumpListManager.cs,BeginList,The following statement contains a magic number: if (shellLink != null) {  	StringBuilder sb = new StringBuilder (256);  	shellLink.GetPath (sb' sb.Capacity' IntPtr.Zero' 2);  	removedItemsArr [i] = sb.ToString ();  }  
Magic Number,TaskbarLib,JumpListManager,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\TaskbarLib\JumpLists\JumpListManager.cs,BeginList,The following statement contains a magic number: if (shellLink != null) {  	StringBuilder sb = new StringBuilder (256);  	shellLink.GetPath (sb' sb.Capacity' IntPtr.Zero' 2);  	removedItemsArr [i] = sb.ToString ();  }  
Magic Number,TaskbarLib,JumpListManager,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\TaskbarLib\JumpLists\JumpListManager.cs,BeginList,The following statement contains a magic number: shellLink.GetPath (sb' sb.Capacity' IntPtr.Zero' 2);  
Magic Number,TaskbarLib,ThumbButtonManager,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\TaskbarLib\ThumbnailButtons\ThumbButtonManager.cs,OnCommand,The following statement contains a magic number: if (((wParam.ToInt32 () >> 16) & 0xffff) == SafeNativeMethods.THBN_CLICKED) {  	_thumbButtons [wParam.ToInt32 () & 0xffff].OnClick ();  }  
Magic Number,ProcessHacker.UI.Actions,ProcessActions,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\UI\Actions\ProcessActions.cs,ShowProperties,The following statement contains a magic number: if (pid != 4) {  	result = PromptForElevation (window' new int[] {  		pid  	}' new string[] {  		name  	}' Program.MinProcessQueryRights' "restart Process Hacker elevated"' "show properties for");  }  else {  	result = ElevationAction.NotRequired;  }  
Magic Number,ProcessHacker.UI.Actions,ProcessActions,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\UI\Actions\ProcessActions.cs,TerminateTree,The following statement contains a magic number: foreach (var process in processes) {  	if (process.Value.Process.ProcessId < 4)  		continue;  	if (process.Value.Process.InheritedFromProcessId.Equals (pid))  		if (!TerminateTree (window' processes' process.Value.Process.ProcessId))  			good = false;  }  
Magic Number,ProcessHacker.UI.Actions,ProcessActions,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\UI\Actions\ProcessActions.cs,TerminateTree,The following statement contains a magic number: if (process.Value.Process.ProcessId < 4)  	continue;  
Magic Number,ProcessHacker.UI,GenericViewMenu,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\UI\GenericViewMenu.cs,ListViewMenuItem_Click,The following statement contains a magic number: ListViewCopy ((ListView)((object[])mitem.Tag) [1]' (int)((object[])mitem.Tag) [0]' (RetrieveVirtualItemEventHandler)((object[])mitem.Tag) [2]);  
Magic Number,ProcessHacker.UI,ColumnSettings,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\UI\ColumnSettings.cs,LoadSettings,The following statement contains a magic number: for (int i = 0; i < list.Length; i++) {  	string[] s = list [i].Split (''');  	if (s.Length != 2)  		break;  	lv.Columns [i].DisplayIndex = Int32.Parse (s [0]);  	lv.Columns [i].Width = Int32.Parse (s [1]);  }  
Magic Number,ProcessHacker.UI,ColumnSettings,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\UI\ColumnSettings.cs,LoadSettings,The following statement contains a magic number: if (s.Length != 2)  	break;  
Magic Number,ProcessHacker.UI,ColumnSettings,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\UI\ColumnSettings.cs,LoadSettings,The following statement contains a magic number: try {  	Dictionary<NodeControl' string> oldAssoc = new Dictionary<NodeControl' string> ();  	foreach (NodeControl control in tv.NodeControls) {  		oldAssoc.Add (control' control.ParentColumn.Header);  	}  	TreeColumn[] newColumns = new TreeColumn[tv.Columns.Count];  	Dictionary<string' TreeColumn> newColumnsD = new Dictionary<string' TreeColumn> ();  	for (int i = 0; i < tv.Columns.Count; i++) {  		string[] s = list [i].Split (''');  		newColumns [i] = new TreeColumn (s [0]' Int32.Parse (s [1]));  		newColumns [i].SortOrder = (SortOrder)Enum.Parse (typeof(SortOrder)' s [2]);  		newColumns [i].IsVisible = bool.Parse (s [3]);  		newColumns [i].MinColumnWidth = 3;  		newColumnsD.Add (s [0]' newColumns [i]);  	}  	tv.Columns.Clear ();  	foreach (TreeColumn column in newColumns)  		tv.Columns.Add (column);  	foreach (NodeControl c in oldAssoc.Keys)  		c.ParentColumn = newColumnsD [oldAssoc [c]];  }  catch {  }  
Magic Number,ProcessHacker.UI,ColumnSettings,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\UI\ColumnSettings.cs,LoadSettings,The following statement contains a magic number: try {  	Dictionary<NodeControl' string> oldAssoc = new Dictionary<NodeControl' string> ();  	foreach (NodeControl control in tv.NodeControls) {  		oldAssoc.Add (control' control.ParentColumn.Header);  	}  	TreeColumn[] newColumns = new TreeColumn[tv.Columns.Count];  	Dictionary<string' TreeColumn> newColumnsD = new Dictionary<string' TreeColumn> ();  	for (int i = 0; i < tv.Columns.Count; i++) {  		string[] s = list [i].Split (''');  		newColumns [i] = new TreeColumn (s [0]' Int32.Parse (s [1]));  		newColumns [i].SortOrder = (SortOrder)Enum.Parse (typeof(SortOrder)' s [2]);  		newColumns [i].IsVisible = bool.Parse (s [3]);  		newColumns [i].MinColumnWidth = 3;  		newColumnsD.Add (s [0]' newColumns [i]);  	}  	tv.Columns.Clear ();  	foreach (TreeColumn column in newColumns)  		tv.Columns.Add (column);  	foreach (NodeControl c in oldAssoc.Keys)  		c.ParentColumn = newColumnsD [oldAssoc [c]];  }  catch {  }  
Magic Number,ProcessHacker.UI,ColumnSettings,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\UI\ColumnSettings.cs,LoadSettings,The following statement contains a magic number: try {  	Dictionary<NodeControl' string> oldAssoc = new Dictionary<NodeControl' string> ();  	foreach (NodeControl control in tv.NodeControls) {  		oldAssoc.Add (control' control.ParentColumn.Header);  	}  	TreeColumn[] newColumns = new TreeColumn[tv.Columns.Count];  	Dictionary<string' TreeColumn> newColumnsD = new Dictionary<string' TreeColumn> ();  	for (int i = 0; i < tv.Columns.Count; i++) {  		string[] s = list [i].Split (''');  		newColumns [i] = new TreeColumn (s [0]' Int32.Parse (s [1]));  		newColumns [i].SortOrder = (SortOrder)Enum.Parse (typeof(SortOrder)' s [2]);  		newColumns [i].IsVisible = bool.Parse (s [3]);  		newColumns [i].MinColumnWidth = 3;  		newColumnsD.Add (s [0]' newColumns [i]);  	}  	tv.Columns.Clear ();  	foreach (TreeColumn column in newColumns)  		tv.Columns.Add (column);  	foreach (NodeControl c in oldAssoc.Keys)  		c.ParentColumn = newColumnsD [oldAssoc [c]];  }  catch {  }  
Magic Number,ProcessHacker.UI,ColumnSettings,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\UI\ColumnSettings.cs,LoadSettings,The following statement contains a magic number: for (int i = 0; i < tv.Columns.Count; i++) {  	string[] s = list [i].Split (''');  	newColumns [i] = new TreeColumn (s [0]' Int32.Parse (s [1]));  	newColumns [i].SortOrder = (SortOrder)Enum.Parse (typeof(SortOrder)' s [2]);  	newColumns [i].IsVisible = bool.Parse (s [3]);  	newColumns [i].MinColumnWidth = 3;  	newColumnsD.Add (s [0]' newColumns [i]);  }  
Magic Number,ProcessHacker.UI,ColumnSettings,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\UI\ColumnSettings.cs,LoadSettings,The following statement contains a magic number: for (int i = 0; i < tv.Columns.Count; i++) {  	string[] s = list [i].Split (''');  	newColumns [i] = new TreeColumn (s [0]' Int32.Parse (s [1]));  	newColumns [i].SortOrder = (SortOrder)Enum.Parse (typeof(SortOrder)' s [2]);  	newColumns [i].IsVisible = bool.Parse (s [3]);  	newColumns [i].MinColumnWidth = 3;  	newColumnsD.Add (s [0]' newColumns [i]);  }  
Magic Number,ProcessHacker.UI,ColumnSettings,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\UI\ColumnSettings.cs,LoadSettings,The following statement contains a magic number: for (int i = 0; i < tv.Columns.Count; i++) {  	string[] s = list [i].Split (''');  	newColumns [i] = new TreeColumn (s [0]' Int32.Parse (s [1]));  	newColumns [i].SortOrder = (SortOrder)Enum.Parse (typeof(SortOrder)' s [2]);  	newColumns [i].IsVisible = bool.Parse (s [3]);  	newColumns [i].MinColumnWidth = 3;  	newColumnsD.Add (s [0]' newColumns [i]);  }  
Magic Number,ProcessHacker.UI,ColumnSettings,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\UI\ColumnSettings.cs,LoadSettings,The following statement contains a magic number: newColumns [i].SortOrder = (SortOrder)Enum.Parse (typeof(SortOrder)' s [2]);  
Magic Number,ProcessHacker.UI,ColumnSettings,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\UI\ColumnSettings.cs,LoadSettings,The following statement contains a magic number: newColumns [i].IsVisible = bool.Parse (s [3]);  
Magic Number,ProcessHacker.UI,ColumnSettings,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\UI\ColumnSettings.cs,LoadSettings,The following statement contains a magic number: newColumns [i].MinColumnWidth = 3;  
Magic Number,ProcessHacker.FormHelper,AsyncOperation,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\UI\Async\AsyncUtils.cs,CancelAndWait,The following statement contains a magic number: lock (_asyncLock) {  	cancelledFlag = true;  	while (!IsDone) {  		Monitor.Wait (_asyncLock' 1000);  	}  }  
Magic Number,ProcessHacker.FormHelper,AsyncOperation,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\UI\Async\AsyncUtils.cs,CancelAndWait,The following statement contains a magic number: while (!IsDone) {  	Monitor.Wait (_asyncLock' 1000);  }  
Magic Number,ProcessHacker.FormHelper,AsyncOperation,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\UI\Async\AsyncUtils.cs,CancelAndWait,The following statement contains a magic number: Monitor.Wait (_asyncLock' 1000);  
Magic Number,ProcessHacker.FormHelper,AsyncOperation,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\UI\Async\AsyncUtils.cs,WaitUntilDone,The following statement contains a magic number: lock (_asyncLock) {  	// Wait for either completion or cancellation.  As with  	// CancelAndWait' we don't sleep forever - to reduce the  	// chances of deadlock in obscure race conditions' we wake  	// up every second to check we didn't miss a Pulse.  	while (!IsDone) {  		Monitor.Wait (_asyncLock' 1000);  	}  }  
Magic Number,ProcessHacker.FormHelper,AsyncOperation,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\UI\Async\AsyncUtils.cs,WaitUntilDone,The following statement contains a magic number: while (!IsDone) {  	Monitor.Wait (_asyncLock' 1000);  }  
Magic Number,ProcessHacker.FormHelper,AsyncOperation,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\UI\Async\AsyncUtils.cs,WaitUntilDone,The following statement contains a magic number: Monitor.Wait (_asyncLock' 1000);  
Magic Number,ProcessHacker.FormHelper,HandleFilter,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\UI\Async\HandleFilter.cs,DoFilter,The following statement contains a magic number: if (!CancelRequested) {  	var handles = Windows.GetHandles ();  	Dictionary<int' ProcessHandle> processHandles = new Dictionary<int' ProcessHandle> ();  	// Find handles  	for (int i = 0; i < handles.Length; i++) {  		// Check for cancellation here too'  		// otherwise the user might have to wait for much time                      		if (CancelRequested)  			return;  		if (i % 20 == 0)  			OnMatchProgress (i' handles.Length);  		var handle = handles [i];  		CompareHandleBestNameWithFilter (processHandles' handle);  		// test Exception   		//if (i > 2000) throw new Exception("test");  	}  	foreach (ProcessHandle phandle in processHandles.Values)  		phandle.Dispose ();  	// Find DLLs and mapped files  	var processes = Windows.GetProcesses ();  	foreach (var process in processes) {  		try {  			// Modules  			using (var phandle = new ProcessHandle (process.Key' Program.MinProcessQueryRights | Program.MinProcessReadMemoryRights)) {  				phandle.EnumModules (module =>  {  					if (module.FileName.ToLowerInvariant ().Contains (strFilterLower))  						this.CallDllMatchListView (process.Key' module);  					return true;  				});  			}  			// Memory  			using (var phandle = new ProcessHandle (process.Key' ProcessAccess.QueryInformation | Program.MinProcessReadMemoryRights)) {  				phandle.EnumMemory (region =>  {  					if (region.Type != MemoryType.Mapped)  						return true;  					string name = phandle.GetMappedFileName (region.BaseAddress);  					if (name != null && name.ToLowerInvariant ().Contains (strFilterLower))  						this.CallMappedFileMatchListView (process.Key' region.BaseAddress' name);  					return true;  				});  			}  			// WOW64 Modules  			if (OSVersion.Architecture == OSArch.Amd64) {  				using (DebugBuffer buffer = new DebugBuffer ()) {  					buffer.Query (process.Key' RtlQueryProcessDebugFlags.Modules32 | RtlQueryProcessDebugFlags.NonInvasive);  					buffer.EnumModules (module =>  {  						if (module.FileName.ToLowerInvariant ().Contains (strFilterLower))  							this.CallDllMatchListView (process.Key' module);  						return true;  					});  				}  			}  		}  		catch (Exception ex) {  			Logging.Log (ex);  		}  	}  	OnMatchListView (null);  }  
Magic Number,ProcessHacker.FormHelper,HandleFilter,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\UI\Async\HandleFilter.cs,DoFilter,The following statement contains a magic number: for (int i = 0; i < handles.Length; i++) {  	// Check for cancellation here too'  	// otherwise the user might have to wait for much time                      	if (CancelRequested)  		return;  	if (i % 20 == 0)  		OnMatchProgress (i' handles.Length);  	var handle = handles [i];  	CompareHandleBestNameWithFilter (processHandles' handle);  	// test Exception   	//if (i > 2000) throw new Exception("test");  }  
Magic Number,ProcessHacker.FormHelper,HandleFilter,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\UI\Async\HandleFilter.cs,DoFilter,The following statement contains a magic number: if (i % 20 == 0)  	OnMatchProgress (i' handles.Length);  
Magic Number,Debugger.Interop,MTA2STA,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\SharpDevelop\MTA2STA.cs,Call,The following statement contains a magic number: if (!hasReturnValue && callMethod == CallMethod.HiddenFormWithTimeout) {  	// Give it 5 seconds to run  	if (!callDone.WaitOne (5000' true)) {  		System.Console.WriteLine ("Call time out! (continuing)");  		System.Console.WriteLine (new System.Diagnostics.StackTrace (true).ToString ());  	}  }  else {  	callDone.WaitOne ();  }  
Magic Number,Debugger.Interop,MTA2STA,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\SharpDevelop\MTA2STA.cs,Call,The following statement contains a magic number: if (!callDone.WaitOne (5000' true)) {  	System.Console.WriteLine ("Call time out! (continuing)");  	System.Console.WriteLine (new System.Diagnostics.StackTrace (true).ToString ());  }  
Magic Number,Debugger.Wrappers,Util,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\SharpDevelop\Wrappers\Util.cs,GetString,The following statement contains a magic number: return GetString (getter' 64' true);  
Magic Number,Debugger.Wrappers,Util,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\SharpDevelop\Wrappers\Util.cs,GetString,The following statement contains a magic number: unmanagedString = Marshal.AllocHGlobal ((int)defaultLenght * 2 + 2);  
Magic Number,Debugger.Wrappers,Util,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\SharpDevelop\Wrappers\Util.cs,GetString,The following statement contains a magic number: unmanagedString = Marshal.AllocHGlobal ((int)defaultLenght * 2 + 2);  
Magic Number,Debugger.Wrappers,Util,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\SharpDevelop\Wrappers\Util.cs,GetString,The following statement contains a magic number: if (exactLenght > defaultLenght) {  	// Second attempt  	Marshal.FreeHGlobal (unmanagedString);  	unmanagedString = Marshal.AllocHGlobal ((int)exactLenght * 2 + 2);  	// + 2 for terminating zero  	getter (exactLenght' out exactLenght' unmanagedString);  }  
Magic Number,Debugger.Wrappers,Util,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\SharpDevelop\Wrappers\Util.cs,GetString,The following statement contains a magic number: if (exactLenght > defaultLenght) {  	// Second attempt  	Marshal.FreeHGlobal (unmanagedString);  	unmanagedString = Marshal.AllocHGlobal ((int)exactLenght * 2 + 2);  	// + 2 for terminating zero  	getter (exactLenght' out exactLenght' unmanagedString);  }  
Magic Number,Debugger.Wrappers,Util,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\SharpDevelop\Wrappers\Util.cs,GetString,The following statement contains a magic number: unmanagedString = Marshal.AllocHGlobal ((int)exactLenght * 2 + 2);  
Magic Number,Debugger.Wrappers,Util,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\SharpDevelop\Wrappers\Util.cs,GetString,The following statement contains a magic number: unmanagedString = Marshal.AllocHGlobal ((int)exactLenght * 2 + 2);  
Magic Number,ProcessHacker.Structs,StructDef,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Structs\StructDef.cs,ReadOnce,The following statement contains a magic number: switch (field.Type) {  case FieldType.Bool32:  	value.Value = Utils.ToInt32 (IOProvider.ReadBytes (offset' 4)' Utils.Endianness.Little) != 0;  	readSize = 4;  	break;  case FieldType.Bool8:  	value.Value = IOProvider.ReadBytes (offset' 1) [0] != 0;  	readSize = 1;  	break;  case FieldType.CharASCII:  	value.Value = (char)IOProvider.ReadBytes (offset' 1) [0];  	readSize = 1;  	break;  case FieldType.CharUTF16:  	value.Value = Encoding.Unicode.GetString (IOProvider.ReadBytes (offset' 2)) [0];  	readSize = 2;  	break;  case FieldType.Double:  	{  		long data = Utils.ToInt64 (IOProvider.ReadBytes (offset' 8)' Utils.Endianness.Little);  		value.Value = *(double*)&data;  		readSize = 8;  	}  	break;  case FieldType.Int16:  	value.Value = (short)Utils.ToUInt16 (IOProvider.ReadBytes (offset' 2)' Utils.Endianness.Little);  	readSize = 2;  	break;  case FieldType.Int32:  	value.Value = Utils.ToInt32 (IOProvider.ReadBytes (offset' 4)' Utils.Endianness.Little);  	readSize = 4;  	break;  case FieldType.Int64:  	value.Value = Utils.ToInt64 (IOProvider.ReadBytes (offset' 8)' Utils.Endianness.Little);  	readSize = 8;  	break;  case FieldType.Int8:  	value.Value = (sbyte)IOProvider.ReadBytes (offset' 1) [0];  	readSize = 1;  	break;  case FieldType.PVoid:  	value.Value = IOProvider.ReadBytes (offset' IntPtr.Size).ToIntPtr ();  	readSize = IntPtr.Size;  	break;  case FieldType.Single:  	{  		int data = Utils.ToInt32 (IOProvider.ReadBytes (offset' 4)' Utils.Endianness.Little);  		value.Value = *(float*)&data;  		readSize = 4;  	}  	break;  case FieldType.StringASCII:  	{  		StringBuilder str = new StringBuilder ();  		if (field.VarLength == -1) {  			int i;  			for (i = 0; ; i++) {  				byte b = IOProvider.ReadBytes (offset.Increment (i)' 1) [0];  				if (b == 0)  					break;  				str.Append ((char)b);  			}  			readSize = i;  		}  		else {  			str.Append (Encoding.ASCII.GetString (IOProvider.ReadBytes (offset' field.VarLength)));  			readSize = field.VarLength;  		}  		value.Value = str.ToString ();  	}  	break;  case FieldType.StringUTF16:  	{  		StringBuilder str = new StringBuilder ();  		if (field.VarLength == -1) {  			int i;  			for (i = 0; ; i += 2) {  				byte[] b = IOProvider.ReadBytes (offset.Increment (i)' 2);  				if (Utils.IsEmpty (b))  					break;  				str.Append (Encoding.Unicode.GetString (b));  			}  			readSize = i;  		}  		else {  			str.Append (Encoding.Unicode.GetString (IOProvider.ReadBytes (offset' field.VarLength * 2)));  			// each char is 2 bytes  			readSize = field.VarLength;  		}  		value.Value = str.ToString ();  	}  	break;  case FieldType.Struct:  	{  		FieldValue[] valuesOut;  		StructDef struc = Structs [field.StructName];  		struc.IOProvider = this.IOProvider;  		struc.Offset = offset;  		struc.Structs = this.Structs;  		readSize = struc.Read (out valuesOut);  		value.Value = valuesOut;  		value.StructName = field.StructName;  	}  	break;  case FieldType.UInt16:  	value.Value = Utils.ToUInt16 (IOProvider.ReadBytes (offset' 2)' Utils.Endianness.Little);  	readSize = 2;  	break;  case FieldType.UInt32:  	value.Value = Utils.ToUInt32 (IOProvider.ReadBytes (offset' 4)' Utils.Endianness.Little);  	readSize = 4;  	break;  case FieldType.UInt64:  	value.Value = (ulong)Utils.ToInt64 (IOProvider.ReadBytes (offset' 8)' Utils.Endianness.Little);  	readSize = 8;  	break;  case FieldType.UInt8:  	value.Value = IOProvider.ReadBytes (offset' 1) [0];  	readSize = 1;  	break;  default:  	readSize = 0;  	break;  }  
Magic Number,ProcessHacker.Structs,StructDef,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Structs\StructDef.cs,ReadOnce,The following statement contains a magic number: switch (field.Type) {  case FieldType.Bool32:  	value.Value = Utils.ToInt32 (IOProvider.ReadBytes (offset' 4)' Utils.Endianness.Little) != 0;  	readSize = 4;  	break;  case FieldType.Bool8:  	value.Value = IOProvider.ReadBytes (offset' 1) [0] != 0;  	readSize = 1;  	break;  case FieldType.CharASCII:  	value.Value = (char)IOProvider.ReadBytes (offset' 1) [0];  	readSize = 1;  	break;  case FieldType.CharUTF16:  	value.Value = Encoding.Unicode.GetString (IOProvider.ReadBytes (offset' 2)) [0];  	readSize = 2;  	break;  case FieldType.Double:  	{  		long data = Utils.ToInt64 (IOProvider.ReadBytes (offset' 8)' Utils.Endianness.Little);  		value.Value = *(double*)&data;  		readSize = 8;  	}  	break;  case FieldType.Int16:  	value.Value = (short)Utils.ToUInt16 (IOProvider.ReadBytes (offset' 2)' Utils.Endianness.Little);  	readSize = 2;  	break;  case FieldType.Int32:  	value.Value = Utils.ToInt32 (IOProvider.ReadBytes (offset' 4)' Utils.Endianness.Little);  	readSize = 4;  	break;  case FieldType.Int64:  	value.Value = Utils.ToInt64 (IOProvider.ReadBytes (offset' 8)' Utils.Endianness.Little);  	readSize = 8;  	break;  case FieldType.Int8:  	value.Value = (sbyte)IOProvider.ReadBytes (offset' 1) [0];  	readSize = 1;  	break;  case FieldType.PVoid:  	value.Value = IOProvider.ReadBytes (offset' IntPtr.Size).ToIntPtr ();  	readSize = IntPtr.Size;  	break;  case FieldType.Single:  	{  		int data = Utils.ToInt32 (IOProvider.ReadBytes (offset' 4)' Utils.Endianness.Little);  		value.Value = *(float*)&data;  		readSize = 4;  	}  	break;  case FieldType.StringASCII:  	{  		StringBuilder str = new StringBuilder ();  		if (field.VarLength == -1) {  			int i;  			for (i = 0; ; i++) {  				byte b = IOProvider.ReadBytes (offset.Increment (i)' 1) [0];  				if (b == 0)  					break;  				str.Append ((char)b);  			}  			readSize = i;  		}  		else {  			str.Append (Encoding.ASCII.GetString (IOProvider.ReadBytes (offset' field.VarLength)));  			readSize = field.VarLength;  		}  		value.Value = str.ToString ();  	}  	break;  case FieldType.StringUTF16:  	{  		StringBuilder str = new StringBuilder ();  		if (field.VarLength == -1) {  			int i;  			for (i = 0; ; i += 2) {  				byte[] b = IOProvider.ReadBytes (offset.Increment (i)' 2);  				if (Utils.IsEmpty (b))  					break;  				str.Append (Encoding.Unicode.GetString (b));  			}  			readSize = i;  		}  		else {  			str.Append (Encoding.Unicode.GetString (IOProvider.ReadBytes (offset' field.VarLength * 2)));  			// each char is 2 bytes  			readSize = field.VarLength;  		}  		value.Value = str.ToString ();  	}  	break;  case FieldType.Struct:  	{  		FieldValue[] valuesOut;  		StructDef struc = Structs [field.StructName];  		struc.IOProvider = this.IOProvider;  		struc.Offset = offset;  		struc.Structs = this.Structs;  		readSize = struc.Read (out valuesOut);  		value.Value = valuesOut;  		value.StructName = field.StructName;  	}  	break;  case FieldType.UInt16:  	value.Value = Utils.ToUInt16 (IOProvider.ReadBytes (offset' 2)' Utils.Endianness.Little);  	readSize = 2;  	break;  case FieldType.UInt32:  	value.Value = Utils.ToUInt32 (IOProvider.ReadBytes (offset' 4)' Utils.Endianness.Little);  	readSize = 4;  	break;  case FieldType.UInt64:  	value.Value = (ulong)Utils.ToInt64 (IOProvider.ReadBytes (offset' 8)' Utils.Endianness.Little);  	readSize = 8;  	break;  case FieldType.UInt8:  	value.Value = IOProvider.ReadBytes (offset' 1) [0];  	readSize = 1;  	break;  default:  	readSize = 0;  	break;  }  
Magic Number,ProcessHacker.Structs,StructDef,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Structs\StructDef.cs,ReadOnce,The following statement contains a magic number: switch (field.Type) {  case FieldType.Bool32:  	value.Value = Utils.ToInt32 (IOProvider.ReadBytes (offset' 4)' Utils.Endianness.Little) != 0;  	readSize = 4;  	break;  case FieldType.Bool8:  	value.Value = IOProvider.ReadBytes (offset' 1) [0] != 0;  	readSize = 1;  	break;  case FieldType.CharASCII:  	value.Value = (char)IOProvider.ReadBytes (offset' 1) [0];  	readSize = 1;  	break;  case FieldType.CharUTF16:  	value.Value = Encoding.Unicode.GetString (IOProvider.ReadBytes (offset' 2)) [0];  	readSize = 2;  	break;  case FieldType.Double:  	{  		long data = Utils.ToInt64 (IOProvider.ReadBytes (offset' 8)' Utils.Endianness.Little);  		value.Value = *(double*)&data;  		readSize = 8;  	}  	break;  case FieldType.Int16:  	value.Value = (short)Utils.ToUInt16 (IOProvider.ReadBytes (offset' 2)' Utils.Endianness.Little);  	readSize = 2;  	break;  case FieldType.Int32:  	value.Value = Utils.ToInt32 (IOProvider.ReadBytes (offset' 4)' Utils.Endianness.Little);  	readSize = 4;  	break;  case FieldType.Int64:  	value.Value = Utils.ToInt64 (IOProvider.ReadBytes (offset' 8)' Utils.Endianness.Little);  	readSize = 8;  	break;  case FieldType.Int8:  	value.Value = (sbyte)IOProvider.ReadBytes (offset' 1) [0];  	readSize = 1;  	break;  case FieldType.PVoid:  	value.Value = IOProvider.ReadBytes (offset' IntPtr.Size).ToIntPtr ();  	readSize = IntPtr.Size;  	break;  case FieldType.Single:  	{  		int data = Utils.ToInt32 (IOProvider.ReadBytes (offset' 4)' Utils.Endianness.Little);  		value.Value = *(float*)&data;  		readSize = 4;  	}  	break;  case FieldType.StringASCII:  	{  		StringBuilder str = new StringBuilder ();  		if (field.VarLength == -1) {  			int i;  			for (i = 0; ; i++) {  				byte b = IOProvider.ReadBytes (offset.Increment (i)' 1) [0];  				if (b == 0)  					break;  				str.Append ((char)b);  			}  			readSize = i;  		}  		else {  			str.Append (Encoding.ASCII.GetString (IOProvider.ReadBytes (offset' field.VarLength)));  			readSize = field.VarLength;  		}  		value.Value = str.ToString ();  	}  	break;  case FieldType.StringUTF16:  	{  		StringBuilder str = new StringBuilder ();  		if (field.VarLength == -1) {  			int i;  			for (i = 0; ; i += 2) {  				byte[] b = IOProvider.ReadBytes (offset.Increment (i)' 2);  				if (Utils.IsEmpty (b))  					break;  				str.Append (Encoding.Unicode.GetString (b));  			}  			readSize = i;  		}  		else {  			str.Append (Encoding.Unicode.GetString (IOProvider.ReadBytes (offset' field.VarLength * 2)));  			// each char is 2 bytes  			readSize = field.VarLength;  		}  		value.Value = str.ToString ();  	}  	break;  case FieldType.Struct:  	{  		FieldValue[] valuesOut;  		StructDef struc = Structs [field.StructName];  		struc.IOProvider = this.IOProvider;  		struc.Offset = offset;  		struc.Structs = this.Structs;  		readSize = struc.Read (out valuesOut);  		value.Value = valuesOut;  		value.StructName = field.StructName;  	}  	break;  case FieldType.UInt16:  	value.Value = Utils.ToUInt16 (IOProvider.ReadBytes (offset' 2)' Utils.Endianness.Little);  	readSize = 2;  	break;  case FieldType.UInt32:  	value.Value = Utils.ToUInt32 (IOProvider.ReadBytes (offset' 4)' Utils.Endianness.Little);  	readSize = 4;  	break;  case FieldType.UInt64:  	value.Value = (ulong)Utils.ToInt64 (IOProvider.ReadBytes (offset' 8)' Utils.Endianness.Little);  	readSize = 8;  	break;  case FieldType.UInt8:  	value.Value = IOProvider.ReadBytes (offset' 1) [0];  	readSize = 1;  	break;  default:  	readSize = 0;  	break;  }  
Magic Number,ProcessHacker.Structs,StructDef,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Structs\StructDef.cs,ReadOnce,The following statement contains a magic number: switch (field.Type) {  case FieldType.Bool32:  	value.Value = Utils.ToInt32 (IOProvider.ReadBytes (offset' 4)' Utils.Endianness.Little) != 0;  	readSize = 4;  	break;  case FieldType.Bool8:  	value.Value = IOProvider.ReadBytes (offset' 1) [0] != 0;  	readSize = 1;  	break;  case FieldType.CharASCII:  	value.Value = (char)IOProvider.ReadBytes (offset' 1) [0];  	readSize = 1;  	break;  case FieldType.CharUTF16:  	value.Value = Encoding.Unicode.GetString (IOProvider.ReadBytes (offset' 2)) [0];  	readSize = 2;  	break;  case FieldType.Double:  	{  		long data = Utils.ToInt64 (IOProvider.ReadBytes (offset' 8)' Utils.Endianness.Little);  		value.Value = *(double*)&data;  		readSize = 8;  	}  	break;  case FieldType.Int16:  	value.Value = (short)Utils.ToUInt16 (IOProvider.ReadBytes (offset' 2)' Utils.Endianness.Little);  	readSize = 2;  	break;  case FieldType.Int32:  	value.Value = Utils.ToInt32 (IOProvider.ReadBytes (offset' 4)' Utils.Endianness.Little);  	readSize = 4;  	break;  case FieldType.Int64:  	value.Value = Utils.ToInt64 (IOProvider.ReadBytes (offset' 8)' Utils.Endianness.Little);  	readSize = 8;  	break;  case FieldType.Int8:  	value.Value = (sbyte)IOProvider.ReadBytes (offset' 1) [0];  	readSize = 1;  	break;  case FieldType.PVoid:  	value.Value = IOProvider.ReadBytes (offset' IntPtr.Size).ToIntPtr ();  	readSize = IntPtr.Size;  	break;  case FieldType.Single:  	{  		int data = Utils.ToInt32 (IOProvider.ReadBytes (offset' 4)' Utils.Endianness.Little);  		value.Value = *(float*)&data;  		readSize = 4;  	}  	break;  case FieldType.StringASCII:  	{  		StringBuilder str = new StringBuilder ();  		if (field.VarLength == -1) {  			int i;  			for (i = 0; ; i++) {  				byte b = IOProvider.ReadBytes (offset.Increment (i)' 1) [0];  				if (b == 0)  					break;  				str.Append ((char)b);  			}  			readSize = i;  		}  		else {  			str.Append (Encoding.ASCII.GetString (IOProvider.ReadBytes (offset' field.VarLength)));  			readSize = field.VarLength;  		}  		value.Value = str.ToString ();  	}  	break;  case FieldType.StringUTF16:  	{  		StringBuilder str = new StringBuilder ();  		if (field.VarLength == -1) {  			int i;  			for (i = 0; ; i += 2) {  				byte[] b = IOProvider.ReadBytes (offset.Increment (i)' 2);  				if (Utils.IsEmpty (b))  					break;  				str.Append (Encoding.Unicode.GetString (b));  			}  			readSize = i;  		}  		else {  			str.Append (Encoding.Unicode.GetString (IOProvider.ReadBytes (offset' field.VarLength * 2)));  			// each char is 2 bytes  			readSize = field.VarLength;  		}  		value.Value = str.ToString ();  	}  	break;  case FieldType.Struct:  	{  		FieldValue[] valuesOut;  		StructDef struc = Structs [field.StructName];  		struc.IOProvider = this.IOProvider;  		struc.Offset = offset;  		struc.Structs = this.Structs;  		readSize = struc.Read (out valuesOut);  		value.Value = valuesOut;  		value.StructName = field.StructName;  	}  	break;  case FieldType.UInt16:  	value.Value = Utils.ToUInt16 (IOProvider.ReadBytes (offset' 2)' Utils.Endianness.Little);  	readSize = 2;  	break;  case FieldType.UInt32:  	value.Value = Utils.ToUInt32 (IOProvider.ReadBytes (offset' 4)' Utils.Endianness.Little);  	readSize = 4;  	break;  case FieldType.UInt64:  	value.Value = (ulong)Utils.ToInt64 (IOProvider.ReadBytes (offset' 8)' Utils.Endianness.Little);  	readSize = 8;  	break;  case FieldType.UInt8:  	value.Value = IOProvider.ReadBytes (offset' 1) [0];  	readSize = 1;  	break;  default:  	readSize = 0;  	break;  }  
Magic Number,ProcessHacker.Structs,StructDef,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Structs\StructDef.cs,ReadOnce,The following statement contains a magic number: switch (field.Type) {  case FieldType.Bool32:  	value.Value = Utils.ToInt32 (IOProvider.ReadBytes (offset' 4)' Utils.Endianness.Little) != 0;  	readSize = 4;  	break;  case FieldType.Bool8:  	value.Value = IOProvider.ReadBytes (offset' 1) [0] != 0;  	readSize = 1;  	break;  case FieldType.CharASCII:  	value.Value = (char)IOProvider.ReadBytes (offset' 1) [0];  	readSize = 1;  	break;  case FieldType.CharUTF16:  	value.Value = Encoding.Unicode.GetString (IOProvider.ReadBytes (offset' 2)) [0];  	readSize = 2;  	break;  case FieldType.Double:  	{  		long data = Utils.ToInt64 (IOProvider.ReadBytes (offset' 8)' Utils.Endianness.Little);  		value.Value = *(double*)&data;  		readSize = 8;  	}  	break;  case FieldType.Int16:  	value.Value = (short)Utils.ToUInt16 (IOProvider.ReadBytes (offset' 2)' Utils.Endianness.Little);  	readSize = 2;  	break;  case FieldType.Int32:  	value.Value = Utils.ToInt32 (IOProvider.ReadBytes (offset' 4)' Utils.Endianness.Little);  	readSize = 4;  	break;  case FieldType.Int64:  	value.Value = Utils.ToInt64 (IOProvider.ReadBytes (offset' 8)' Utils.Endianness.Little);  	readSize = 8;  	break;  case FieldType.Int8:  	value.Value = (sbyte)IOProvider.ReadBytes (offset' 1) [0];  	readSize = 1;  	break;  case FieldType.PVoid:  	value.Value = IOProvider.ReadBytes (offset' IntPtr.Size).ToIntPtr ();  	readSize = IntPtr.Size;  	break;  case FieldType.Single:  	{  		int data = Utils.ToInt32 (IOProvider.ReadBytes (offset' 4)' Utils.Endianness.Little);  		value.Value = *(float*)&data;  		readSize = 4;  	}  	break;  case FieldType.StringASCII:  	{  		StringBuilder str = new StringBuilder ();  		if (field.VarLength == -1) {  			int i;  			for (i = 0; ; i++) {  				byte b = IOProvider.ReadBytes (offset.Increment (i)' 1) [0];  				if (b == 0)  					break;  				str.Append ((char)b);  			}  			readSize = i;  		}  		else {  			str.Append (Encoding.ASCII.GetString (IOProvider.ReadBytes (offset' field.VarLength)));  			readSize = field.VarLength;  		}  		value.Value = str.ToString ();  	}  	break;  case FieldType.StringUTF16:  	{  		StringBuilder str = new StringBuilder ();  		if (field.VarLength == -1) {  			int i;  			for (i = 0; ; i += 2) {  				byte[] b = IOProvider.ReadBytes (offset.Increment (i)' 2);  				if (Utils.IsEmpty (b))  					break;  				str.Append (Encoding.Unicode.GetString (b));  			}  			readSize = i;  		}  		else {  			str.Append (Encoding.Unicode.GetString (IOProvider.ReadBytes (offset' field.VarLength * 2)));  			// each char is 2 bytes  			readSize = field.VarLength;  		}  		value.Value = str.ToString ();  	}  	break;  case FieldType.Struct:  	{  		FieldValue[] valuesOut;  		StructDef struc = Structs [field.StructName];  		struc.IOProvider = this.IOProvider;  		struc.Offset = offset;  		struc.Structs = this.Structs;  		readSize = struc.Read (out valuesOut);  		value.Value = valuesOut;  		value.StructName = field.StructName;  	}  	break;  case FieldType.UInt16:  	value.Value = Utils.ToUInt16 (IOProvider.ReadBytes (offset' 2)' Utils.Endianness.Little);  	readSize = 2;  	break;  case FieldType.UInt32:  	value.Value = Utils.ToUInt32 (IOProvider.ReadBytes (offset' 4)' Utils.Endianness.Little);  	readSize = 4;  	break;  case FieldType.UInt64:  	value.Value = (ulong)Utils.ToInt64 (IOProvider.ReadBytes (offset' 8)' Utils.Endianness.Little);  	readSize = 8;  	break;  case FieldType.UInt8:  	value.Value = IOProvider.ReadBytes (offset' 1) [0];  	readSize = 1;  	break;  default:  	readSize = 0;  	break;  }  
Magic Number,ProcessHacker.Structs,StructDef,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Structs\StructDef.cs,ReadOnce,The following statement contains a magic number: switch (field.Type) {  case FieldType.Bool32:  	value.Value = Utils.ToInt32 (IOProvider.ReadBytes (offset' 4)' Utils.Endianness.Little) != 0;  	readSize = 4;  	break;  case FieldType.Bool8:  	value.Value = IOProvider.ReadBytes (offset' 1) [0] != 0;  	readSize = 1;  	break;  case FieldType.CharASCII:  	value.Value = (char)IOProvider.ReadBytes (offset' 1) [0];  	readSize = 1;  	break;  case FieldType.CharUTF16:  	value.Value = Encoding.Unicode.GetString (IOProvider.ReadBytes (offset' 2)) [0];  	readSize = 2;  	break;  case FieldType.Double:  	{  		long data = Utils.ToInt64 (IOProvider.ReadBytes (offset' 8)' Utils.Endianness.Little);  		value.Value = *(double*)&data;  		readSize = 8;  	}  	break;  case FieldType.Int16:  	value.Value = (short)Utils.ToUInt16 (IOProvider.ReadBytes (offset' 2)' Utils.Endianness.Little);  	readSize = 2;  	break;  case FieldType.Int32:  	value.Value = Utils.ToInt32 (IOProvider.ReadBytes (offset' 4)' Utils.Endianness.Little);  	readSize = 4;  	break;  case FieldType.Int64:  	value.Value = Utils.ToInt64 (IOProvider.ReadBytes (offset' 8)' Utils.Endianness.Little);  	readSize = 8;  	break;  case FieldType.Int8:  	value.Value = (sbyte)IOProvider.ReadBytes (offset' 1) [0];  	readSize = 1;  	break;  case FieldType.PVoid:  	value.Value = IOProvider.ReadBytes (offset' IntPtr.Size).ToIntPtr ();  	readSize = IntPtr.Size;  	break;  case FieldType.Single:  	{  		int data = Utils.ToInt32 (IOProvider.ReadBytes (offset' 4)' Utils.Endianness.Little);  		value.Value = *(float*)&data;  		readSize = 4;  	}  	break;  case FieldType.StringASCII:  	{  		StringBuilder str = new StringBuilder ();  		if (field.VarLength == -1) {  			int i;  			for (i = 0; ; i++) {  				byte b = IOProvider.ReadBytes (offset.Increment (i)' 1) [0];  				if (b == 0)  					break;  				str.Append ((char)b);  			}  			readSize = i;  		}  		else {  			str.Append (Encoding.ASCII.GetString (IOProvider.ReadBytes (offset' field.VarLength)));  			readSize = field.VarLength;  		}  		value.Value = str.ToString ();  	}  	break;  case FieldType.StringUTF16:  	{  		StringBuilder str = new StringBuilder ();  		if (field.VarLength == -1) {  			int i;  			for (i = 0; ; i += 2) {  				byte[] b = IOProvider.ReadBytes (offset.Increment (i)' 2);  				if (Utils.IsEmpty (b))  					break;  				str.Append (Encoding.Unicode.GetString (b));  			}  			readSize = i;  		}  		else {  			str.Append (Encoding.Unicode.GetString (IOProvider.ReadBytes (offset' field.VarLength * 2)));  			// each char is 2 bytes  			readSize = field.VarLength;  		}  		value.Value = str.ToString ();  	}  	break;  case FieldType.Struct:  	{  		FieldValue[] valuesOut;  		StructDef struc = Structs [field.StructName];  		struc.IOProvider = this.IOProvider;  		struc.Offset = offset;  		struc.Structs = this.Structs;  		readSize = struc.Read (out valuesOut);  		value.Value = valuesOut;  		value.StructName = field.StructName;  	}  	break;  case FieldType.UInt16:  	value.Value = Utils.ToUInt16 (IOProvider.ReadBytes (offset' 2)' Utils.Endianness.Little);  	readSize = 2;  	break;  case FieldType.UInt32:  	value.Value = Utils.ToUInt32 (IOProvider.ReadBytes (offset' 4)' Utils.Endianness.Little);  	readSize = 4;  	break;  case FieldType.UInt64:  	value.Value = (ulong)Utils.ToInt64 (IOProvider.ReadBytes (offset' 8)' Utils.Endianness.Little);  	readSize = 8;  	break;  case FieldType.UInt8:  	value.Value = IOProvider.ReadBytes (offset' 1) [0];  	readSize = 1;  	break;  default:  	readSize = 0;  	break;  }  
Magic Number,ProcessHacker.Structs,StructDef,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Structs\StructDef.cs,ReadOnce,The following statement contains a magic number: switch (field.Type) {  case FieldType.Bool32:  	value.Value = Utils.ToInt32 (IOProvider.ReadBytes (offset' 4)' Utils.Endianness.Little) != 0;  	readSize = 4;  	break;  case FieldType.Bool8:  	value.Value = IOProvider.ReadBytes (offset' 1) [0] != 0;  	readSize = 1;  	break;  case FieldType.CharASCII:  	value.Value = (char)IOProvider.ReadBytes (offset' 1) [0];  	readSize = 1;  	break;  case FieldType.CharUTF16:  	value.Value = Encoding.Unicode.GetString (IOProvider.ReadBytes (offset' 2)) [0];  	readSize = 2;  	break;  case FieldType.Double:  	{  		long data = Utils.ToInt64 (IOProvider.ReadBytes (offset' 8)' Utils.Endianness.Little);  		value.Value = *(double*)&data;  		readSize = 8;  	}  	break;  case FieldType.Int16:  	value.Value = (short)Utils.ToUInt16 (IOProvider.ReadBytes (offset' 2)' Utils.Endianness.Little);  	readSize = 2;  	break;  case FieldType.Int32:  	value.Value = Utils.ToInt32 (IOProvider.ReadBytes (offset' 4)' Utils.Endianness.Little);  	readSize = 4;  	break;  case FieldType.Int64:  	value.Value = Utils.ToInt64 (IOProvider.ReadBytes (offset' 8)' Utils.Endianness.Little);  	readSize = 8;  	break;  case FieldType.Int8:  	value.Value = (sbyte)IOProvider.ReadBytes (offset' 1) [0];  	readSize = 1;  	break;  case FieldType.PVoid:  	value.Value = IOProvider.ReadBytes (offset' IntPtr.Size).ToIntPtr ();  	readSize = IntPtr.Size;  	break;  case FieldType.Single:  	{  		int data = Utils.ToInt32 (IOProvider.ReadBytes (offset' 4)' Utils.Endianness.Little);  		value.Value = *(float*)&data;  		readSize = 4;  	}  	break;  case FieldType.StringASCII:  	{  		StringBuilder str = new StringBuilder ();  		if (field.VarLength == -1) {  			int i;  			for (i = 0; ; i++) {  				byte b = IOProvider.ReadBytes (offset.Increment (i)' 1) [0];  				if (b == 0)  					break;  				str.Append ((char)b);  			}  			readSize = i;  		}  		else {  			str.Append (Encoding.ASCII.GetString (IOProvider.ReadBytes (offset' field.VarLength)));  			readSize = field.VarLength;  		}  		value.Value = str.ToString ();  	}  	break;  case FieldType.StringUTF16:  	{  		StringBuilder str = new StringBuilder ();  		if (field.VarLength == -1) {  			int i;  			for (i = 0; ; i += 2) {  				byte[] b = IOProvider.ReadBytes (offset.Increment (i)' 2);  				if (Utils.IsEmpty (b))  					break;  				str.Append (Encoding.Unicode.GetString (b));  			}  			readSize = i;  		}  		else {  			str.Append (Encoding.Unicode.GetString (IOProvider.ReadBytes (offset' field.VarLength * 2)));  			// each char is 2 bytes  			readSize = field.VarLength;  		}  		value.Value = str.ToString ();  	}  	break;  case FieldType.Struct:  	{  		FieldValue[] valuesOut;  		StructDef struc = Structs [field.StructName];  		struc.IOProvider = this.IOProvider;  		struc.Offset = offset;  		struc.Structs = this.Structs;  		readSize = struc.Read (out valuesOut);  		value.Value = valuesOut;  		value.StructName = field.StructName;  	}  	break;  case FieldType.UInt16:  	value.Value = Utils.ToUInt16 (IOProvider.ReadBytes (offset' 2)' Utils.Endianness.Little);  	readSize = 2;  	break;  case FieldType.UInt32:  	value.Value = Utils.ToUInt32 (IOProvider.ReadBytes (offset' 4)' Utils.Endianness.Little);  	readSize = 4;  	break;  case FieldType.UInt64:  	value.Value = (ulong)Utils.ToInt64 (IOProvider.ReadBytes (offset' 8)' Utils.Endianness.Little);  	readSize = 8;  	break;  case FieldType.UInt8:  	value.Value = IOProvider.ReadBytes (offset' 1) [0];  	readSize = 1;  	break;  default:  	readSize = 0;  	break;  }  
Magic Number,ProcessHacker.Structs,StructDef,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Structs\StructDef.cs,ReadOnce,The following statement contains a magic number: switch (field.Type) {  case FieldType.Bool32:  	value.Value = Utils.ToInt32 (IOProvider.ReadBytes (offset' 4)' Utils.Endianness.Little) != 0;  	readSize = 4;  	break;  case FieldType.Bool8:  	value.Value = IOProvider.ReadBytes (offset' 1) [0] != 0;  	readSize = 1;  	break;  case FieldType.CharASCII:  	value.Value = (char)IOProvider.ReadBytes (offset' 1) [0];  	readSize = 1;  	break;  case FieldType.CharUTF16:  	value.Value = Encoding.Unicode.GetString (IOProvider.ReadBytes (offset' 2)) [0];  	readSize = 2;  	break;  case FieldType.Double:  	{  		long data = Utils.ToInt64 (IOProvider.ReadBytes (offset' 8)' Utils.Endianness.Little);  		value.Value = *(double*)&data;  		readSize = 8;  	}  	break;  case FieldType.Int16:  	value.Value = (short)Utils.ToUInt16 (IOProvider.ReadBytes (offset' 2)' Utils.Endianness.Little);  	readSize = 2;  	break;  case FieldType.Int32:  	value.Value = Utils.ToInt32 (IOProvider.ReadBytes (offset' 4)' Utils.Endianness.Little);  	readSize = 4;  	break;  case FieldType.Int64:  	value.Value = Utils.ToInt64 (IOProvider.ReadBytes (offset' 8)' Utils.Endianness.Little);  	readSize = 8;  	break;  case FieldType.Int8:  	value.Value = (sbyte)IOProvider.ReadBytes (offset' 1) [0];  	readSize = 1;  	break;  case FieldType.PVoid:  	value.Value = IOProvider.ReadBytes (offset' IntPtr.Size).ToIntPtr ();  	readSize = IntPtr.Size;  	break;  case FieldType.Single:  	{  		int data = Utils.ToInt32 (IOProvider.ReadBytes (offset' 4)' Utils.Endianness.Little);  		value.Value = *(float*)&data;  		readSize = 4;  	}  	break;  case FieldType.StringASCII:  	{  		StringBuilder str = new StringBuilder ();  		if (field.VarLength == -1) {  			int i;  			for (i = 0; ; i++) {  				byte b = IOProvider.ReadBytes (offset.Increment (i)' 1) [0];  				if (b == 0)  					break;  				str.Append ((char)b);  			}  			readSize = i;  		}  		else {  			str.Append (Encoding.ASCII.GetString (IOProvider.ReadBytes (offset' field.VarLength)));  			readSize = field.VarLength;  		}  		value.Value = str.ToString ();  	}  	break;  case FieldType.StringUTF16:  	{  		StringBuilder str = new StringBuilder ();  		if (field.VarLength == -1) {  			int i;  			for (i = 0; ; i += 2) {  				byte[] b = IOProvider.ReadBytes (offset.Increment (i)' 2);  				if (Utils.IsEmpty (b))  					break;  				str.Append (Encoding.Unicode.GetString (b));  			}  			readSize = i;  		}  		else {  			str.Append (Encoding.Unicode.GetString (IOProvider.ReadBytes (offset' field.VarLength * 2)));  			// each char is 2 bytes  			readSize = field.VarLength;  		}  		value.Value = str.ToString ();  	}  	break;  case FieldType.Struct:  	{  		FieldValue[] valuesOut;  		StructDef struc = Structs [field.StructName];  		struc.IOProvider = this.IOProvider;  		struc.Offset = offset;  		struc.Structs = this.Structs;  		readSize = struc.Read (out valuesOut);  		value.Value = valuesOut;  		value.StructName = field.StructName;  	}  	break;  case FieldType.UInt16:  	value.Value = Utils.ToUInt16 (IOProvider.ReadBytes (offset' 2)' Utils.Endianness.Little);  	readSize = 2;  	break;  case FieldType.UInt32:  	value.Value = Utils.ToUInt32 (IOProvider.ReadBytes (offset' 4)' Utils.Endianness.Little);  	readSize = 4;  	break;  case FieldType.UInt64:  	value.Value = (ulong)Utils.ToInt64 (IOProvider.ReadBytes (offset' 8)' Utils.Endianness.Little);  	readSize = 8;  	break;  case FieldType.UInt8:  	value.Value = IOProvider.ReadBytes (offset' 1) [0];  	readSize = 1;  	break;  default:  	readSize = 0;  	break;  }  
Magic Number,ProcessHacker.Structs,StructDef,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Structs\StructDef.cs,ReadOnce,The following statement contains a magic number: switch (field.Type) {  case FieldType.Bool32:  	value.Value = Utils.ToInt32 (IOProvider.ReadBytes (offset' 4)' Utils.Endianness.Little) != 0;  	readSize = 4;  	break;  case FieldType.Bool8:  	value.Value = IOProvider.ReadBytes (offset' 1) [0] != 0;  	readSize = 1;  	break;  case FieldType.CharASCII:  	value.Value = (char)IOProvider.ReadBytes (offset' 1) [0];  	readSize = 1;  	break;  case FieldType.CharUTF16:  	value.Value = Encoding.Unicode.GetString (IOProvider.ReadBytes (offset' 2)) [0];  	readSize = 2;  	break;  case FieldType.Double:  	{  		long data = Utils.ToInt64 (IOProvider.ReadBytes (offset' 8)' Utils.Endianness.Little);  		value.Value = *(double*)&data;  		readSize = 8;  	}  	break;  case FieldType.Int16:  	value.Value = (short)Utils.ToUInt16 (IOProvider.ReadBytes (offset' 2)' Utils.Endianness.Little);  	readSize = 2;  	break;  case FieldType.Int32:  	value.Value = Utils.ToInt32 (IOProvider.ReadBytes (offset' 4)' Utils.Endianness.Little);  	readSize = 4;  	break;  case FieldType.Int64:  	value.Value = Utils.ToInt64 (IOProvider.ReadBytes (offset' 8)' Utils.Endianness.Little);  	readSize = 8;  	break;  case FieldType.Int8:  	value.Value = (sbyte)IOProvider.ReadBytes (offset' 1) [0];  	readSize = 1;  	break;  case FieldType.PVoid:  	value.Value = IOProvider.ReadBytes (offset' IntPtr.Size).ToIntPtr ();  	readSize = IntPtr.Size;  	break;  case FieldType.Single:  	{  		int data = Utils.ToInt32 (IOProvider.ReadBytes (offset' 4)' Utils.Endianness.Little);  		value.Value = *(float*)&data;  		readSize = 4;  	}  	break;  case FieldType.StringASCII:  	{  		StringBuilder str = new StringBuilder ();  		if (field.VarLength == -1) {  			int i;  			for (i = 0; ; i++) {  				byte b = IOProvider.ReadBytes (offset.Increment (i)' 1) [0];  				if (b == 0)  					break;  				str.Append ((char)b);  			}  			readSize = i;  		}  		else {  			str.Append (Encoding.ASCII.GetString (IOProvider.ReadBytes (offset' field.VarLength)));  			readSize = field.VarLength;  		}  		value.Value = str.ToString ();  	}  	break;  case FieldType.StringUTF16:  	{  		StringBuilder str = new StringBuilder ();  		if (field.VarLength == -1) {  			int i;  			for (i = 0; ; i += 2) {  				byte[] b = IOProvider.ReadBytes (offset.Increment (i)' 2);  				if (Utils.IsEmpty (b))  					break;  				str.Append (Encoding.Unicode.GetString (b));  			}  			readSize = i;  		}  		else {  			str.Append (Encoding.Unicode.GetString (IOProvider.ReadBytes (offset' field.VarLength * 2)));  			// each char is 2 bytes  			readSize = field.VarLength;  		}  		value.Value = str.ToString ();  	}  	break;  case FieldType.Struct:  	{  		FieldValue[] valuesOut;  		StructDef struc = Structs [field.StructName];  		struc.IOProvider = this.IOProvider;  		struc.Offset = offset;  		struc.Structs = this.Structs;  		readSize = struc.Read (out valuesOut);  		value.Value = valuesOut;  		value.StructName = field.StructName;  	}  	break;  case FieldType.UInt16:  	value.Value = Utils.ToUInt16 (IOProvider.ReadBytes (offset' 2)' Utils.Endianness.Little);  	readSize = 2;  	break;  case FieldType.UInt32:  	value.Value = Utils.ToUInt32 (IOProvider.ReadBytes (offset' 4)' Utils.Endianness.Little);  	readSize = 4;  	break;  case FieldType.UInt64:  	value.Value = (ulong)Utils.ToInt64 (IOProvider.ReadBytes (offset' 8)' Utils.Endianness.Little);  	readSize = 8;  	break;  case FieldType.UInt8:  	value.Value = IOProvider.ReadBytes (offset' 1) [0];  	readSize = 1;  	break;  default:  	readSize = 0;  	break;  }  
Magic Number,ProcessHacker.Structs,StructDef,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Structs\StructDef.cs,ReadOnce,The following statement contains a magic number: switch (field.Type) {  case FieldType.Bool32:  	value.Value = Utils.ToInt32 (IOProvider.ReadBytes (offset' 4)' Utils.Endianness.Little) != 0;  	readSize = 4;  	break;  case FieldType.Bool8:  	value.Value = IOProvider.ReadBytes (offset' 1) [0] != 0;  	readSize = 1;  	break;  case FieldType.CharASCII:  	value.Value = (char)IOProvider.ReadBytes (offset' 1) [0];  	readSize = 1;  	break;  case FieldType.CharUTF16:  	value.Value = Encoding.Unicode.GetString (IOProvider.ReadBytes (offset' 2)) [0];  	readSize = 2;  	break;  case FieldType.Double:  	{  		long data = Utils.ToInt64 (IOProvider.ReadBytes (offset' 8)' Utils.Endianness.Little);  		value.Value = *(double*)&data;  		readSize = 8;  	}  	break;  case FieldType.Int16:  	value.Value = (short)Utils.ToUInt16 (IOProvider.ReadBytes (offset' 2)' Utils.Endianness.Little);  	readSize = 2;  	break;  case FieldType.Int32:  	value.Value = Utils.ToInt32 (IOProvider.ReadBytes (offset' 4)' Utils.Endianness.Little);  	readSize = 4;  	break;  case FieldType.Int64:  	value.Value = Utils.ToInt64 (IOProvider.ReadBytes (offset' 8)' Utils.Endianness.Little);  	readSize = 8;  	break;  case FieldType.Int8:  	value.Value = (sbyte)IOProvider.ReadBytes (offset' 1) [0];  	readSize = 1;  	break;  case FieldType.PVoid:  	value.Value = IOProvider.ReadBytes (offset' IntPtr.Size).ToIntPtr ();  	readSize = IntPtr.Size;  	break;  case FieldType.Single:  	{  		int data = Utils.ToInt32 (IOProvider.ReadBytes (offset' 4)' Utils.Endianness.Little);  		value.Value = *(float*)&data;  		readSize = 4;  	}  	break;  case FieldType.StringASCII:  	{  		StringBuilder str = new StringBuilder ();  		if (field.VarLength == -1) {  			int i;  			for (i = 0; ; i++) {  				byte b = IOProvider.ReadBytes (offset.Increment (i)' 1) [0];  				if (b == 0)  					break;  				str.Append ((char)b);  			}  			readSize = i;  		}  		else {  			str.Append (Encoding.ASCII.GetString (IOProvider.ReadBytes (offset' field.VarLength)));  			readSize = field.VarLength;  		}  		value.Value = str.ToString ();  	}  	break;  case FieldType.StringUTF16:  	{  		StringBuilder str = new StringBuilder ();  		if (field.VarLength == -1) {  			int i;  			for (i = 0; ; i += 2) {  				byte[] b = IOProvider.ReadBytes (offset.Increment (i)' 2);  				if (Utils.IsEmpty (b))  					break;  				str.Append (Encoding.Unicode.GetString (b));  			}  			readSize = i;  		}  		else {  			str.Append (Encoding.Unicode.GetString (IOProvider.ReadBytes (offset' field.VarLength * 2)));  			// each char is 2 bytes  			readSize = field.VarLength;  		}  		value.Value = str.ToString ();  	}  	break;  case FieldType.Struct:  	{  		FieldValue[] valuesOut;  		StructDef struc = Structs [field.StructName];  		struc.IOProvider = this.IOProvider;  		struc.Offset = offset;  		struc.Structs = this.Structs;  		readSize = struc.Read (out valuesOut);  		value.Value = valuesOut;  		value.StructName = field.StructName;  	}  	break;  case FieldType.UInt16:  	value.Value = Utils.ToUInt16 (IOProvider.ReadBytes (offset' 2)' Utils.Endianness.Little);  	readSize = 2;  	break;  case FieldType.UInt32:  	value.Value = Utils.ToUInt32 (IOProvider.ReadBytes (offset' 4)' Utils.Endianness.Little);  	readSize = 4;  	break;  case FieldType.UInt64:  	value.Value = (ulong)Utils.ToInt64 (IOProvider.ReadBytes (offset' 8)' Utils.Endianness.Little);  	readSize = 8;  	break;  case FieldType.UInt8:  	value.Value = IOProvider.ReadBytes (offset' 1) [0];  	readSize = 1;  	break;  default:  	readSize = 0;  	break;  }  
Magic Number,ProcessHacker.Structs,StructDef,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Structs\StructDef.cs,ReadOnce,The following statement contains a magic number: switch (field.Type) {  case FieldType.Bool32:  	value.Value = Utils.ToInt32 (IOProvider.ReadBytes (offset' 4)' Utils.Endianness.Little) != 0;  	readSize = 4;  	break;  case FieldType.Bool8:  	value.Value = IOProvider.ReadBytes (offset' 1) [0] != 0;  	readSize = 1;  	break;  case FieldType.CharASCII:  	value.Value = (char)IOProvider.ReadBytes (offset' 1) [0];  	readSize = 1;  	break;  case FieldType.CharUTF16:  	value.Value = Encoding.Unicode.GetString (IOProvider.ReadBytes (offset' 2)) [0];  	readSize = 2;  	break;  case FieldType.Double:  	{  		long data = Utils.ToInt64 (IOProvider.ReadBytes (offset' 8)' Utils.Endianness.Little);  		value.Value = *(double*)&data;  		readSize = 8;  	}  	break;  case FieldType.Int16:  	value.Value = (short)Utils.ToUInt16 (IOProvider.ReadBytes (offset' 2)' Utils.Endianness.Little);  	readSize = 2;  	break;  case FieldType.Int32:  	value.Value = Utils.ToInt32 (IOProvider.ReadBytes (offset' 4)' Utils.Endianness.Little);  	readSize = 4;  	break;  case FieldType.Int64:  	value.Value = Utils.ToInt64 (IOProvider.ReadBytes (offset' 8)' Utils.Endianness.Little);  	readSize = 8;  	break;  case FieldType.Int8:  	value.Value = (sbyte)IOProvider.ReadBytes (offset' 1) [0];  	readSize = 1;  	break;  case FieldType.PVoid:  	value.Value = IOProvider.ReadBytes (offset' IntPtr.Size).ToIntPtr ();  	readSize = IntPtr.Size;  	break;  case FieldType.Single:  	{  		int data = Utils.ToInt32 (IOProvider.ReadBytes (offset' 4)' Utils.Endianness.Little);  		value.Value = *(float*)&data;  		readSize = 4;  	}  	break;  case FieldType.StringASCII:  	{  		StringBuilder str = new StringBuilder ();  		if (field.VarLength == -1) {  			int i;  			for (i = 0; ; i++) {  				byte b = IOProvider.ReadBytes (offset.Increment (i)' 1) [0];  				if (b == 0)  					break;  				str.Append ((char)b);  			}  			readSize = i;  		}  		else {  			str.Append (Encoding.ASCII.GetString (IOProvider.ReadBytes (offset' field.VarLength)));  			readSize = field.VarLength;  		}  		value.Value = str.ToString ();  	}  	break;  case FieldType.StringUTF16:  	{  		StringBuilder str = new StringBuilder ();  		if (field.VarLength == -1) {  			int i;  			for (i = 0; ; i += 2) {  				byte[] b = IOProvider.ReadBytes (offset.Increment (i)' 2);  				if (Utils.IsEmpty (b))  					break;  				str.Append (Encoding.Unicode.GetString (b));  			}  			readSize = i;  		}  		else {  			str.Append (Encoding.Unicode.GetString (IOProvider.ReadBytes (offset' field.VarLength * 2)));  			// each char is 2 bytes  			readSize = field.VarLength;  		}  		value.Value = str.ToString ();  	}  	break;  case FieldType.Struct:  	{  		FieldValue[] valuesOut;  		StructDef struc = Structs [field.StructName];  		struc.IOProvider = this.IOProvider;  		struc.Offset = offset;  		struc.Structs = this.Structs;  		readSize = struc.Read (out valuesOut);  		value.Value = valuesOut;  		value.StructName = field.StructName;  	}  	break;  case FieldType.UInt16:  	value.Value = Utils.ToUInt16 (IOProvider.ReadBytes (offset' 2)' Utils.Endianness.Little);  	readSize = 2;  	break;  case FieldType.UInt32:  	value.Value = Utils.ToUInt32 (IOProvider.ReadBytes (offset' 4)' Utils.Endianness.Little);  	readSize = 4;  	break;  case FieldType.UInt64:  	value.Value = (ulong)Utils.ToInt64 (IOProvider.ReadBytes (offset' 8)' Utils.Endianness.Little);  	readSize = 8;  	break;  case FieldType.UInt8:  	value.Value = IOProvider.ReadBytes (offset' 1) [0];  	readSize = 1;  	break;  default:  	readSize = 0;  	break;  }  
Magic Number,ProcessHacker.Structs,StructDef,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Structs\StructDef.cs,ReadOnce,The following statement contains a magic number: switch (field.Type) {  case FieldType.Bool32:  	value.Value = Utils.ToInt32 (IOProvider.ReadBytes (offset' 4)' Utils.Endianness.Little) != 0;  	readSize = 4;  	break;  case FieldType.Bool8:  	value.Value = IOProvider.ReadBytes (offset' 1) [0] != 0;  	readSize = 1;  	break;  case FieldType.CharASCII:  	value.Value = (char)IOProvider.ReadBytes (offset' 1) [0];  	readSize = 1;  	break;  case FieldType.CharUTF16:  	value.Value = Encoding.Unicode.GetString (IOProvider.ReadBytes (offset' 2)) [0];  	readSize = 2;  	break;  case FieldType.Double:  	{  		long data = Utils.ToInt64 (IOProvider.ReadBytes (offset' 8)' Utils.Endianness.Little);  		value.Value = *(double*)&data;  		readSize = 8;  	}  	break;  case FieldType.Int16:  	value.Value = (short)Utils.ToUInt16 (IOProvider.ReadBytes (offset' 2)' Utils.Endianness.Little);  	readSize = 2;  	break;  case FieldType.Int32:  	value.Value = Utils.ToInt32 (IOProvider.ReadBytes (offset' 4)' Utils.Endianness.Little);  	readSize = 4;  	break;  case FieldType.Int64:  	value.Value = Utils.ToInt64 (IOProvider.ReadBytes (offset' 8)' Utils.Endianness.Little);  	readSize = 8;  	break;  case FieldType.Int8:  	value.Value = (sbyte)IOProvider.ReadBytes (offset' 1) [0];  	readSize = 1;  	break;  case FieldType.PVoid:  	value.Value = IOProvider.ReadBytes (offset' IntPtr.Size).ToIntPtr ();  	readSize = IntPtr.Size;  	break;  case FieldType.Single:  	{  		int data = Utils.ToInt32 (IOProvider.ReadBytes (offset' 4)' Utils.Endianness.Little);  		value.Value = *(float*)&data;  		readSize = 4;  	}  	break;  case FieldType.StringASCII:  	{  		StringBuilder str = new StringBuilder ();  		if (field.VarLength == -1) {  			int i;  			for (i = 0; ; i++) {  				byte b = IOProvider.ReadBytes (offset.Increment (i)' 1) [0];  				if (b == 0)  					break;  				str.Append ((char)b);  			}  			readSize = i;  		}  		else {  			str.Append (Encoding.ASCII.GetString (IOProvider.ReadBytes (offset' field.VarLength)));  			readSize = field.VarLength;  		}  		value.Value = str.ToString ();  	}  	break;  case FieldType.StringUTF16:  	{  		StringBuilder str = new StringBuilder ();  		if (field.VarLength == -1) {  			int i;  			for (i = 0; ; i += 2) {  				byte[] b = IOProvider.ReadBytes (offset.Increment (i)' 2);  				if (Utils.IsEmpty (b))  					break;  				str.Append (Encoding.Unicode.GetString (b));  			}  			readSize = i;  		}  		else {  			str.Append (Encoding.Unicode.GetString (IOProvider.ReadBytes (offset' field.VarLength * 2)));  			// each char is 2 bytes  			readSize = field.VarLength;  		}  		value.Value = str.ToString ();  	}  	break;  case FieldType.Struct:  	{  		FieldValue[] valuesOut;  		StructDef struc = Structs [field.StructName];  		struc.IOProvider = this.IOProvider;  		struc.Offset = offset;  		struc.Structs = this.Structs;  		readSize = struc.Read (out valuesOut);  		value.Value = valuesOut;  		value.StructName = field.StructName;  	}  	break;  case FieldType.UInt16:  	value.Value = Utils.ToUInt16 (IOProvider.ReadBytes (offset' 2)' Utils.Endianness.Little);  	readSize = 2;  	break;  case FieldType.UInt32:  	value.Value = Utils.ToUInt32 (IOProvider.ReadBytes (offset' 4)' Utils.Endianness.Little);  	readSize = 4;  	break;  case FieldType.UInt64:  	value.Value = (ulong)Utils.ToInt64 (IOProvider.ReadBytes (offset' 8)' Utils.Endianness.Little);  	readSize = 8;  	break;  case FieldType.UInt8:  	value.Value = IOProvider.ReadBytes (offset' 1) [0];  	readSize = 1;  	break;  default:  	readSize = 0;  	break;  }  
Magic Number,ProcessHacker.Structs,StructDef,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Structs\StructDef.cs,ReadOnce,The following statement contains a magic number: switch (field.Type) {  case FieldType.Bool32:  	value.Value = Utils.ToInt32 (IOProvider.ReadBytes (offset' 4)' Utils.Endianness.Little) != 0;  	readSize = 4;  	break;  case FieldType.Bool8:  	value.Value = IOProvider.ReadBytes (offset' 1) [0] != 0;  	readSize = 1;  	break;  case FieldType.CharASCII:  	value.Value = (char)IOProvider.ReadBytes (offset' 1) [0];  	readSize = 1;  	break;  case FieldType.CharUTF16:  	value.Value = Encoding.Unicode.GetString (IOProvider.ReadBytes (offset' 2)) [0];  	readSize = 2;  	break;  case FieldType.Double:  	{  		long data = Utils.ToInt64 (IOProvider.ReadBytes (offset' 8)' Utils.Endianness.Little);  		value.Value = *(double*)&data;  		readSize = 8;  	}  	break;  case FieldType.Int16:  	value.Value = (short)Utils.ToUInt16 (IOProvider.ReadBytes (offset' 2)' Utils.Endianness.Little);  	readSize = 2;  	break;  case FieldType.Int32:  	value.Value = Utils.ToInt32 (IOProvider.ReadBytes (offset' 4)' Utils.Endianness.Little);  	readSize = 4;  	break;  case FieldType.Int64:  	value.Value = Utils.ToInt64 (IOProvider.ReadBytes (offset' 8)' Utils.Endianness.Little);  	readSize = 8;  	break;  case FieldType.Int8:  	value.Value = (sbyte)IOProvider.ReadBytes (offset' 1) [0];  	readSize = 1;  	break;  case FieldType.PVoid:  	value.Value = IOProvider.ReadBytes (offset' IntPtr.Size).ToIntPtr ();  	readSize = IntPtr.Size;  	break;  case FieldType.Single:  	{  		int data = Utils.ToInt32 (IOProvider.ReadBytes (offset' 4)' Utils.Endianness.Little);  		value.Value = *(float*)&data;  		readSize = 4;  	}  	break;  case FieldType.StringASCII:  	{  		StringBuilder str = new StringBuilder ();  		if (field.VarLength == -1) {  			int i;  			for (i = 0; ; i++) {  				byte b = IOProvider.ReadBytes (offset.Increment (i)' 1) [0];  				if (b == 0)  					break;  				str.Append ((char)b);  			}  			readSize = i;  		}  		else {  			str.Append (Encoding.ASCII.GetString (IOProvider.ReadBytes (offset' field.VarLength)));  			readSize = field.VarLength;  		}  		value.Value = str.ToString ();  	}  	break;  case FieldType.StringUTF16:  	{  		StringBuilder str = new StringBuilder ();  		if (field.VarLength == -1) {  			int i;  			for (i = 0; ; i += 2) {  				byte[] b = IOProvider.ReadBytes (offset.Increment (i)' 2);  				if (Utils.IsEmpty (b))  					break;  				str.Append (Encoding.Unicode.GetString (b));  			}  			readSize = i;  		}  		else {  			str.Append (Encoding.Unicode.GetString (IOProvider.ReadBytes (offset' field.VarLength * 2)));  			// each char is 2 bytes  			readSize = field.VarLength;  		}  		value.Value = str.ToString ();  	}  	break;  case FieldType.Struct:  	{  		FieldValue[] valuesOut;  		StructDef struc = Structs [field.StructName];  		struc.IOProvider = this.IOProvider;  		struc.Offset = offset;  		struc.Structs = this.Structs;  		readSize = struc.Read (out valuesOut);  		value.Value = valuesOut;  		value.StructName = field.StructName;  	}  	break;  case FieldType.UInt16:  	value.Value = Utils.ToUInt16 (IOProvider.ReadBytes (offset' 2)' Utils.Endianness.Little);  	readSize = 2;  	break;  case FieldType.UInt32:  	value.Value = Utils.ToUInt32 (IOProvider.ReadBytes (offset' 4)' Utils.Endianness.Little);  	readSize = 4;  	break;  case FieldType.UInt64:  	value.Value = (ulong)Utils.ToInt64 (IOProvider.ReadBytes (offset' 8)' Utils.Endianness.Little);  	readSize = 8;  	break;  case FieldType.UInt8:  	value.Value = IOProvider.ReadBytes (offset' 1) [0];  	readSize = 1;  	break;  default:  	readSize = 0;  	break;  }  
Magic Number,ProcessHacker.Structs,StructDef,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Structs\StructDef.cs,ReadOnce,The following statement contains a magic number: switch (field.Type) {  case FieldType.Bool32:  	value.Value = Utils.ToInt32 (IOProvider.ReadBytes (offset' 4)' Utils.Endianness.Little) != 0;  	readSize = 4;  	break;  case FieldType.Bool8:  	value.Value = IOProvider.ReadBytes (offset' 1) [0] != 0;  	readSize = 1;  	break;  case FieldType.CharASCII:  	value.Value = (char)IOProvider.ReadBytes (offset' 1) [0];  	readSize = 1;  	break;  case FieldType.CharUTF16:  	value.Value = Encoding.Unicode.GetString (IOProvider.ReadBytes (offset' 2)) [0];  	readSize = 2;  	break;  case FieldType.Double:  	{  		long data = Utils.ToInt64 (IOProvider.ReadBytes (offset' 8)' Utils.Endianness.Little);  		value.Value = *(double*)&data;  		readSize = 8;  	}  	break;  case FieldType.Int16:  	value.Value = (short)Utils.ToUInt16 (IOProvider.ReadBytes (offset' 2)' Utils.Endianness.Little);  	readSize = 2;  	break;  case FieldType.Int32:  	value.Value = Utils.ToInt32 (IOProvider.ReadBytes (offset' 4)' Utils.Endianness.Little);  	readSize = 4;  	break;  case FieldType.Int64:  	value.Value = Utils.ToInt64 (IOProvider.ReadBytes (offset' 8)' Utils.Endianness.Little);  	readSize = 8;  	break;  case FieldType.Int8:  	value.Value = (sbyte)IOProvider.ReadBytes (offset' 1) [0];  	readSize = 1;  	break;  case FieldType.PVoid:  	value.Value = IOProvider.ReadBytes (offset' IntPtr.Size).ToIntPtr ();  	readSize = IntPtr.Size;  	break;  case FieldType.Single:  	{  		int data = Utils.ToInt32 (IOProvider.ReadBytes (offset' 4)' Utils.Endianness.Little);  		value.Value = *(float*)&data;  		readSize = 4;  	}  	break;  case FieldType.StringASCII:  	{  		StringBuilder str = new StringBuilder ();  		if (field.VarLength == -1) {  			int i;  			for (i = 0; ; i++) {  				byte b = IOProvider.ReadBytes (offset.Increment (i)' 1) [0];  				if (b == 0)  					break;  				str.Append ((char)b);  			}  			readSize = i;  		}  		else {  			str.Append (Encoding.ASCII.GetString (IOProvider.ReadBytes (offset' field.VarLength)));  			readSize = field.VarLength;  		}  		value.Value = str.ToString ();  	}  	break;  case FieldType.StringUTF16:  	{  		StringBuilder str = new StringBuilder ();  		if (field.VarLength == -1) {  			int i;  			for (i = 0; ; i += 2) {  				byte[] b = IOProvider.ReadBytes (offset.Increment (i)' 2);  				if (Utils.IsEmpty (b))  					break;  				str.Append (Encoding.Unicode.GetString (b));  			}  			readSize = i;  		}  		else {  			str.Append (Encoding.Unicode.GetString (IOProvider.ReadBytes (offset' field.VarLength * 2)));  			// each char is 2 bytes  			readSize = field.VarLength;  		}  		value.Value = str.ToString ();  	}  	break;  case FieldType.Struct:  	{  		FieldValue[] valuesOut;  		StructDef struc = Structs [field.StructName];  		struc.IOProvider = this.IOProvider;  		struc.Offset = offset;  		struc.Structs = this.Structs;  		readSize = struc.Read (out valuesOut);  		value.Value = valuesOut;  		value.StructName = field.StructName;  	}  	break;  case FieldType.UInt16:  	value.Value = Utils.ToUInt16 (IOProvider.ReadBytes (offset' 2)' Utils.Endianness.Little);  	readSize = 2;  	break;  case FieldType.UInt32:  	value.Value = Utils.ToUInt32 (IOProvider.ReadBytes (offset' 4)' Utils.Endianness.Little);  	readSize = 4;  	break;  case FieldType.UInt64:  	value.Value = (ulong)Utils.ToInt64 (IOProvider.ReadBytes (offset' 8)' Utils.Endianness.Little);  	readSize = 8;  	break;  case FieldType.UInt8:  	value.Value = IOProvider.ReadBytes (offset' 1) [0];  	readSize = 1;  	break;  default:  	readSize = 0;  	break;  }  
Magic Number,ProcessHacker.Structs,StructDef,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Structs\StructDef.cs,ReadOnce,The following statement contains a magic number: switch (field.Type) {  case FieldType.Bool32:  	value.Value = Utils.ToInt32 (IOProvider.ReadBytes (offset' 4)' Utils.Endianness.Little) != 0;  	readSize = 4;  	break;  case FieldType.Bool8:  	value.Value = IOProvider.ReadBytes (offset' 1) [0] != 0;  	readSize = 1;  	break;  case FieldType.CharASCII:  	value.Value = (char)IOProvider.ReadBytes (offset' 1) [0];  	readSize = 1;  	break;  case FieldType.CharUTF16:  	value.Value = Encoding.Unicode.GetString (IOProvider.ReadBytes (offset' 2)) [0];  	readSize = 2;  	break;  case FieldType.Double:  	{  		long data = Utils.ToInt64 (IOProvider.ReadBytes (offset' 8)' Utils.Endianness.Little);  		value.Value = *(double*)&data;  		readSize = 8;  	}  	break;  case FieldType.Int16:  	value.Value = (short)Utils.ToUInt16 (IOProvider.ReadBytes (offset' 2)' Utils.Endianness.Little);  	readSize = 2;  	break;  case FieldType.Int32:  	value.Value = Utils.ToInt32 (IOProvider.ReadBytes (offset' 4)' Utils.Endianness.Little);  	readSize = 4;  	break;  case FieldType.Int64:  	value.Value = Utils.ToInt64 (IOProvider.ReadBytes (offset' 8)' Utils.Endianness.Little);  	readSize = 8;  	break;  case FieldType.Int8:  	value.Value = (sbyte)IOProvider.ReadBytes (offset' 1) [0];  	readSize = 1;  	break;  case FieldType.PVoid:  	value.Value = IOProvider.ReadBytes (offset' IntPtr.Size).ToIntPtr ();  	readSize = IntPtr.Size;  	break;  case FieldType.Single:  	{  		int data = Utils.ToInt32 (IOProvider.ReadBytes (offset' 4)' Utils.Endianness.Little);  		value.Value = *(float*)&data;  		readSize = 4;  	}  	break;  case FieldType.StringASCII:  	{  		StringBuilder str = new StringBuilder ();  		if (field.VarLength == -1) {  			int i;  			for (i = 0; ; i++) {  				byte b = IOProvider.ReadBytes (offset.Increment (i)' 1) [0];  				if (b == 0)  					break;  				str.Append ((char)b);  			}  			readSize = i;  		}  		else {  			str.Append (Encoding.ASCII.GetString (IOProvider.ReadBytes (offset' field.VarLength)));  			readSize = field.VarLength;  		}  		value.Value = str.ToString ();  	}  	break;  case FieldType.StringUTF16:  	{  		StringBuilder str = new StringBuilder ();  		if (field.VarLength == -1) {  			int i;  			for (i = 0; ; i += 2) {  				byte[] b = IOProvider.ReadBytes (offset.Increment (i)' 2);  				if (Utils.IsEmpty (b))  					break;  				str.Append (Encoding.Unicode.GetString (b));  			}  			readSize = i;  		}  		else {  			str.Append (Encoding.Unicode.GetString (IOProvider.ReadBytes (offset' field.VarLength * 2)));  			// each char is 2 bytes  			readSize = field.VarLength;  		}  		value.Value = str.ToString ();  	}  	break;  case FieldType.Struct:  	{  		FieldValue[] valuesOut;  		StructDef struc = Structs [field.StructName];  		struc.IOProvider = this.IOProvider;  		struc.Offset = offset;  		struc.Structs = this.Structs;  		readSize = struc.Read (out valuesOut);  		value.Value = valuesOut;  		value.StructName = field.StructName;  	}  	break;  case FieldType.UInt16:  	value.Value = Utils.ToUInt16 (IOProvider.ReadBytes (offset' 2)' Utils.Endianness.Little);  	readSize = 2;  	break;  case FieldType.UInt32:  	value.Value = Utils.ToUInt32 (IOProvider.ReadBytes (offset' 4)' Utils.Endianness.Little);  	readSize = 4;  	break;  case FieldType.UInt64:  	value.Value = (ulong)Utils.ToInt64 (IOProvider.ReadBytes (offset' 8)' Utils.Endianness.Little);  	readSize = 8;  	break;  case FieldType.UInt8:  	value.Value = IOProvider.ReadBytes (offset' 1) [0];  	readSize = 1;  	break;  default:  	readSize = 0;  	break;  }  
Magic Number,ProcessHacker.Structs,StructDef,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Structs\StructDef.cs,ReadOnce,The following statement contains a magic number: switch (field.Type) {  case FieldType.Bool32:  	value.Value = Utils.ToInt32 (IOProvider.ReadBytes (offset' 4)' Utils.Endianness.Little) != 0;  	readSize = 4;  	break;  case FieldType.Bool8:  	value.Value = IOProvider.ReadBytes (offset' 1) [0] != 0;  	readSize = 1;  	break;  case FieldType.CharASCII:  	value.Value = (char)IOProvider.ReadBytes (offset' 1) [0];  	readSize = 1;  	break;  case FieldType.CharUTF16:  	value.Value = Encoding.Unicode.GetString (IOProvider.ReadBytes (offset' 2)) [0];  	readSize = 2;  	break;  case FieldType.Double:  	{  		long data = Utils.ToInt64 (IOProvider.ReadBytes (offset' 8)' Utils.Endianness.Little);  		value.Value = *(double*)&data;  		readSize = 8;  	}  	break;  case FieldType.Int16:  	value.Value = (short)Utils.ToUInt16 (IOProvider.ReadBytes (offset' 2)' Utils.Endianness.Little);  	readSize = 2;  	break;  case FieldType.Int32:  	value.Value = Utils.ToInt32 (IOProvider.ReadBytes (offset' 4)' Utils.Endianness.Little);  	readSize = 4;  	break;  case FieldType.Int64:  	value.Value = Utils.ToInt64 (IOProvider.ReadBytes (offset' 8)' Utils.Endianness.Little);  	readSize = 8;  	break;  case FieldType.Int8:  	value.Value = (sbyte)IOProvider.ReadBytes (offset' 1) [0];  	readSize = 1;  	break;  case FieldType.PVoid:  	value.Value = IOProvider.ReadBytes (offset' IntPtr.Size).ToIntPtr ();  	readSize = IntPtr.Size;  	break;  case FieldType.Single:  	{  		int data = Utils.ToInt32 (IOProvider.ReadBytes (offset' 4)' Utils.Endianness.Little);  		value.Value = *(float*)&data;  		readSize = 4;  	}  	break;  case FieldType.StringASCII:  	{  		StringBuilder str = new StringBuilder ();  		if (field.VarLength == -1) {  			int i;  			for (i = 0; ; i++) {  				byte b = IOProvider.ReadBytes (offset.Increment (i)' 1) [0];  				if (b == 0)  					break;  				str.Append ((char)b);  			}  			readSize = i;  		}  		else {  			str.Append (Encoding.ASCII.GetString (IOProvider.ReadBytes (offset' field.VarLength)));  			readSize = field.VarLength;  		}  		value.Value = str.ToString ();  	}  	break;  case FieldType.StringUTF16:  	{  		StringBuilder str = new StringBuilder ();  		if (field.VarLength == -1) {  			int i;  			for (i = 0; ; i += 2) {  				byte[] b = IOProvider.ReadBytes (offset.Increment (i)' 2);  				if (Utils.IsEmpty (b))  					break;  				str.Append (Encoding.Unicode.GetString (b));  			}  			readSize = i;  		}  		else {  			str.Append (Encoding.Unicode.GetString (IOProvider.ReadBytes (offset' field.VarLength * 2)));  			// each char is 2 bytes  			readSize = field.VarLength;  		}  		value.Value = str.ToString ();  	}  	break;  case FieldType.Struct:  	{  		FieldValue[] valuesOut;  		StructDef struc = Structs [field.StructName];  		struc.IOProvider = this.IOProvider;  		struc.Offset = offset;  		struc.Structs = this.Structs;  		readSize = struc.Read (out valuesOut);  		value.Value = valuesOut;  		value.StructName = field.StructName;  	}  	break;  case FieldType.UInt16:  	value.Value = Utils.ToUInt16 (IOProvider.ReadBytes (offset' 2)' Utils.Endianness.Little);  	readSize = 2;  	break;  case FieldType.UInt32:  	value.Value = Utils.ToUInt32 (IOProvider.ReadBytes (offset' 4)' Utils.Endianness.Little);  	readSize = 4;  	break;  case FieldType.UInt64:  	value.Value = (ulong)Utils.ToInt64 (IOProvider.ReadBytes (offset' 8)' Utils.Endianness.Little);  	readSize = 8;  	break;  case FieldType.UInt8:  	value.Value = IOProvider.ReadBytes (offset' 1) [0];  	readSize = 1;  	break;  default:  	readSize = 0;  	break;  }  
Magic Number,ProcessHacker.Structs,StructDef,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Structs\StructDef.cs,ReadOnce,The following statement contains a magic number: switch (field.Type) {  case FieldType.Bool32:  	value.Value = Utils.ToInt32 (IOProvider.ReadBytes (offset' 4)' Utils.Endianness.Little) != 0;  	readSize = 4;  	break;  case FieldType.Bool8:  	value.Value = IOProvider.ReadBytes (offset' 1) [0] != 0;  	readSize = 1;  	break;  case FieldType.CharASCII:  	value.Value = (char)IOProvider.ReadBytes (offset' 1) [0];  	readSize = 1;  	break;  case FieldType.CharUTF16:  	value.Value = Encoding.Unicode.GetString (IOProvider.ReadBytes (offset' 2)) [0];  	readSize = 2;  	break;  case FieldType.Double:  	{  		long data = Utils.ToInt64 (IOProvider.ReadBytes (offset' 8)' Utils.Endianness.Little);  		value.Value = *(double*)&data;  		readSize = 8;  	}  	break;  case FieldType.Int16:  	value.Value = (short)Utils.ToUInt16 (IOProvider.ReadBytes (offset' 2)' Utils.Endianness.Little);  	readSize = 2;  	break;  case FieldType.Int32:  	value.Value = Utils.ToInt32 (IOProvider.ReadBytes (offset' 4)' Utils.Endianness.Little);  	readSize = 4;  	break;  case FieldType.Int64:  	value.Value = Utils.ToInt64 (IOProvider.ReadBytes (offset' 8)' Utils.Endianness.Little);  	readSize = 8;  	break;  case FieldType.Int8:  	value.Value = (sbyte)IOProvider.ReadBytes (offset' 1) [0];  	readSize = 1;  	break;  case FieldType.PVoid:  	value.Value = IOProvider.ReadBytes (offset' IntPtr.Size).ToIntPtr ();  	readSize = IntPtr.Size;  	break;  case FieldType.Single:  	{  		int data = Utils.ToInt32 (IOProvider.ReadBytes (offset' 4)' Utils.Endianness.Little);  		value.Value = *(float*)&data;  		readSize = 4;  	}  	break;  case FieldType.StringASCII:  	{  		StringBuilder str = new StringBuilder ();  		if (field.VarLength == -1) {  			int i;  			for (i = 0; ; i++) {  				byte b = IOProvider.ReadBytes (offset.Increment (i)' 1) [0];  				if (b == 0)  					break;  				str.Append ((char)b);  			}  			readSize = i;  		}  		else {  			str.Append (Encoding.ASCII.GetString (IOProvider.ReadBytes (offset' field.VarLength)));  			readSize = field.VarLength;  		}  		value.Value = str.ToString ();  	}  	break;  case FieldType.StringUTF16:  	{  		StringBuilder str = new StringBuilder ();  		if (field.VarLength == -1) {  			int i;  			for (i = 0; ; i += 2) {  				byte[] b = IOProvider.ReadBytes (offset.Increment (i)' 2);  				if (Utils.IsEmpty (b))  					break;  				str.Append (Encoding.Unicode.GetString (b));  			}  			readSize = i;  		}  		else {  			str.Append (Encoding.Unicode.GetString (IOProvider.ReadBytes (offset' field.VarLength * 2)));  			// each char is 2 bytes  			readSize = field.VarLength;  		}  		value.Value = str.ToString ();  	}  	break;  case FieldType.Struct:  	{  		FieldValue[] valuesOut;  		StructDef struc = Structs [field.StructName];  		struc.IOProvider = this.IOProvider;  		struc.Offset = offset;  		struc.Structs = this.Structs;  		readSize = struc.Read (out valuesOut);  		value.Value = valuesOut;  		value.StructName = field.StructName;  	}  	break;  case FieldType.UInt16:  	value.Value = Utils.ToUInt16 (IOProvider.ReadBytes (offset' 2)' Utils.Endianness.Little);  	readSize = 2;  	break;  case FieldType.UInt32:  	value.Value = Utils.ToUInt32 (IOProvider.ReadBytes (offset' 4)' Utils.Endianness.Little);  	readSize = 4;  	break;  case FieldType.UInt64:  	value.Value = (ulong)Utils.ToInt64 (IOProvider.ReadBytes (offset' 8)' Utils.Endianness.Little);  	readSize = 8;  	break;  case FieldType.UInt8:  	value.Value = IOProvider.ReadBytes (offset' 1) [0];  	readSize = 1;  	break;  default:  	readSize = 0;  	break;  }  
Magic Number,ProcessHacker.Structs,StructDef,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Structs\StructDef.cs,ReadOnce,The following statement contains a magic number: switch (field.Type) {  case FieldType.Bool32:  	value.Value = Utils.ToInt32 (IOProvider.ReadBytes (offset' 4)' Utils.Endianness.Little) != 0;  	readSize = 4;  	break;  case FieldType.Bool8:  	value.Value = IOProvider.ReadBytes (offset' 1) [0] != 0;  	readSize = 1;  	break;  case FieldType.CharASCII:  	value.Value = (char)IOProvider.ReadBytes (offset' 1) [0];  	readSize = 1;  	break;  case FieldType.CharUTF16:  	value.Value = Encoding.Unicode.GetString (IOProvider.ReadBytes (offset' 2)) [0];  	readSize = 2;  	break;  case FieldType.Double:  	{  		long data = Utils.ToInt64 (IOProvider.ReadBytes (offset' 8)' Utils.Endianness.Little);  		value.Value = *(double*)&data;  		readSize = 8;  	}  	break;  case FieldType.Int16:  	value.Value = (short)Utils.ToUInt16 (IOProvider.ReadBytes (offset' 2)' Utils.Endianness.Little);  	readSize = 2;  	break;  case FieldType.Int32:  	value.Value = Utils.ToInt32 (IOProvider.ReadBytes (offset' 4)' Utils.Endianness.Little);  	readSize = 4;  	break;  case FieldType.Int64:  	value.Value = Utils.ToInt64 (IOProvider.ReadBytes (offset' 8)' Utils.Endianness.Little);  	readSize = 8;  	break;  case FieldType.Int8:  	value.Value = (sbyte)IOProvider.ReadBytes (offset' 1) [0];  	readSize = 1;  	break;  case FieldType.PVoid:  	value.Value = IOProvider.ReadBytes (offset' IntPtr.Size).ToIntPtr ();  	readSize = IntPtr.Size;  	break;  case FieldType.Single:  	{  		int data = Utils.ToInt32 (IOProvider.ReadBytes (offset' 4)' Utils.Endianness.Little);  		value.Value = *(float*)&data;  		readSize = 4;  	}  	break;  case FieldType.StringASCII:  	{  		StringBuilder str = new StringBuilder ();  		if (field.VarLength == -1) {  			int i;  			for (i = 0; ; i++) {  				byte b = IOProvider.ReadBytes (offset.Increment (i)' 1) [0];  				if (b == 0)  					break;  				str.Append ((char)b);  			}  			readSize = i;  		}  		else {  			str.Append (Encoding.ASCII.GetString (IOProvider.ReadBytes (offset' field.VarLength)));  			readSize = field.VarLength;  		}  		value.Value = str.ToString ();  	}  	break;  case FieldType.StringUTF16:  	{  		StringBuilder str = new StringBuilder ();  		if (field.VarLength == -1) {  			int i;  			for (i = 0; ; i += 2) {  				byte[] b = IOProvider.ReadBytes (offset.Increment (i)' 2);  				if (Utils.IsEmpty (b))  					break;  				str.Append (Encoding.Unicode.GetString (b));  			}  			readSize = i;  		}  		else {  			str.Append (Encoding.Unicode.GetString (IOProvider.ReadBytes (offset' field.VarLength * 2)));  			// each char is 2 bytes  			readSize = field.VarLength;  		}  		value.Value = str.ToString ();  	}  	break;  case FieldType.Struct:  	{  		FieldValue[] valuesOut;  		StructDef struc = Structs [field.StructName];  		struc.IOProvider = this.IOProvider;  		struc.Offset = offset;  		struc.Structs = this.Structs;  		readSize = struc.Read (out valuesOut);  		value.Value = valuesOut;  		value.StructName = field.StructName;  	}  	break;  case FieldType.UInt16:  	value.Value = Utils.ToUInt16 (IOProvider.ReadBytes (offset' 2)' Utils.Endianness.Little);  	readSize = 2;  	break;  case FieldType.UInt32:  	value.Value = Utils.ToUInt32 (IOProvider.ReadBytes (offset' 4)' Utils.Endianness.Little);  	readSize = 4;  	break;  case FieldType.UInt64:  	value.Value = (ulong)Utils.ToInt64 (IOProvider.ReadBytes (offset' 8)' Utils.Endianness.Little);  	readSize = 8;  	break;  case FieldType.UInt8:  	value.Value = IOProvider.ReadBytes (offset' 1) [0];  	readSize = 1;  	break;  default:  	readSize = 0;  	break;  }  
Magic Number,ProcessHacker.Structs,StructDef,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Structs\StructDef.cs,ReadOnce,The following statement contains a magic number: switch (field.Type) {  case FieldType.Bool32:  	value.Value = Utils.ToInt32 (IOProvider.ReadBytes (offset' 4)' Utils.Endianness.Little) != 0;  	readSize = 4;  	break;  case FieldType.Bool8:  	value.Value = IOProvider.ReadBytes (offset' 1) [0] != 0;  	readSize = 1;  	break;  case FieldType.CharASCII:  	value.Value = (char)IOProvider.ReadBytes (offset' 1) [0];  	readSize = 1;  	break;  case FieldType.CharUTF16:  	value.Value = Encoding.Unicode.GetString (IOProvider.ReadBytes (offset' 2)) [0];  	readSize = 2;  	break;  case FieldType.Double:  	{  		long data = Utils.ToInt64 (IOProvider.ReadBytes (offset' 8)' Utils.Endianness.Little);  		value.Value = *(double*)&data;  		readSize = 8;  	}  	break;  case FieldType.Int16:  	value.Value = (short)Utils.ToUInt16 (IOProvider.ReadBytes (offset' 2)' Utils.Endianness.Little);  	readSize = 2;  	break;  case FieldType.Int32:  	value.Value = Utils.ToInt32 (IOProvider.ReadBytes (offset' 4)' Utils.Endianness.Little);  	readSize = 4;  	break;  case FieldType.Int64:  	value.Value = Utils.ToInt64 (IOProvider.ReadBytes (offset' 8)' Utils.Endianness.Little);  	readSize = 8;  	break;  case FieldType.Int8:  	value.Value = (sbyte)IOProvider.ReadBytes (offset' 1) [0];  	readSize = 1;  	break;  case FieldType.PVoid:  	value.Value = IOProvider.ReadBytes (offset' IntPtr.Size).ToIntPtr ();  	readSize = IntPtr.Size;  	break;  case FieldType.Single:  	{  		int data = Utils.ToInt32 (IOProvider.ReadBytes (offset' 4)' Utils.Endianness.Little);  		value.Value = *(float*)&data;  		readSize = 4;  	}  	break;  case FieldType.StringASCII:  	{  		StringBuilder str = new StringBuilder ();  		if (field.VarLength == -1) {  			int i;  			for (i = 0; ; i++) {  				byte b = IOProvider.ReadBytes (offset.Increment (i)' 1) [0];  				if (b == 0)  					break;  				str.Append ((char)b);  			}  			readSize = i;  		}  		else {  			str.Append (Encoding.ASCII.GetString (IOProvider.ReadBytes (offset' field.VarLength)));  			readSize = field.VarLength;  		}  		value.Value = str.ToString ();  	}  	break;  case FieldType.StringUTF16:  	{  		StringBuilder str = new StringBuilder ();  		if (field.VarLength == -1) {  			int i;  			for (i = 0; ; i += 2) {  				byte[] b = IOProvider.ReadBytes (offset.Increment (i)' 2);  				if (Utils.IsEmpty (b))  					break;  				str.Append (Encoding.Unicode.GetString (b));  			}  			readSize = i;  		}  		else {  			str.Append (Encoding.Unicode.GetString (IOProvider.ReadBytes (offset' field.VarLength * 2)));  			// each char is 2 bytes  			readSize = field.VarLength;  		}  		value.Value = str.ToString ();  	}  	break;  case FieldType.Struct:  	{  		FieldValue[] valuesOut;  		StructDef struc = Structs [field.StructName];  		struc.IOProvider = this.IOProvider;  		struc.Offset = offset;  		struc.Structs = this.Structs;  		readSize = struc.Read (out valuesOut);  		value.Value = valuesOut;  		value.StructName = field.StructName;  	}  	break;  case FieldType.UInt16:  	value.Value = Utils.ToUInt16 (IOProvider.ReadBytes (offset' 2)' Utils.Endianness.Little);  	readSize = 2;  	break;  case FieldType.UInt32:  	value.Value = Utils.ToUInt32 (IOProvider.ReadBytes (offset' 4)' Utils.Endianness.Little);  	readSize = 4;  	break;  case FieldType.UInt64:  	value.Value = (ulong)Utils.ToInt64 (IOProvider.ReadBytes (offset' 8)' Utils.Endianness.Little);  	readSize = 8;  	break;  case FieldType.UInt8:  	value.Value = IOProvider.ReadBytes (offset' 1) [0];  	readSize = 1;  	break;  default:  	readSize = 0;  	break;  }  
Magic Number,ProcessHacker.Structs,StructDef,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Structs\StructDef.cs,ReadOnce,The following statement contains a magic number: switch (field.Type) {  case FieldType.Bool32:  	value.Value = Utils.ToInt32 (IOProvider.ReadBytes (offset' 4)' Utils.Endianness.Little) != 0;  	readSize = 4;  	break;  case FieldType.Bool8:  	value.Value = IOProvider.ReadBytes (offset' 1) [0] != 0;  	readSize = 1;  	break;  case FieldType.CharASCII:  	value.Value = (char)IOProvider.ReadBytes (offset' 1) [0];  	readSize = 1;  	break;  case FieldType.CharUTF16:  	value.Value = Encoding.Unicode.GetString (IOProvider.ReadBytes (offset' 2)) [0];  	readSize = 2;  	break;  case FieldType.Double:  	{  		long data = Utils.ToInt64 (IOProvider.ReadBytes (offset' 8)' Utils.Endianness.Little);  		value.Value = *(double*)&data;  		readSize = 8;  	}  	break;  case FieldType.Int16:  	value.Value = (short)Utils.ToUInt16 (IOProvider.ReadBytes (offset' 2)' Utils.Endianness.Little);  	readSize = 2;  	break;  case FieldType.Int32:  	value.Value = Utils.ToInt32 (IOProvider.ReadBytes (offset' 4)' Utils.Endianness.Little);  	readSize = 4;  	break;  case FieldType.Int64:  	value.Value = Utils.ToInt64 (IOProvider.ReadBytes (offset' 8)' Utils.Endianness.Little);  	readSize = 8;  	break;  case FieldType.Int8:  	value.Value = (sbyte)IOProvider.ReadBytes (offset' 1) [0];  	readSize = 1;  	break;  case FieldType.PVoid:  	value.Value = IOProvider.ReadBytes (offset' IntPtr.Size).ToIntPtr ();  	readSize = IntPtr.Size;  	break;  case FieldType.Single:  	{  		int data = Utils.ToInt32 (IOProvider.ReadBytes (offset' 4)' Utils.Endianness.Little);  		value.Value = *(float*)&data;  		readSize = 4;  	}  	break;  case FieldType.StringASCII:  	{  		StringBuilder str = new StringBuilder ();  		if (field.VarLength == -1) {  			int i;  			for (i = 0; ; i++) {  				byte b = IOProvider.ReadBytes (offset.Increment (i)' 1) [0];  				if (b == 0)  					break;  				str.Append ((char)b);  			}  			readSize = i;  		}  		else {  			str.Append (Encoding.ASCII.GetString (IOProvider.ReadBytes (offset' field.VarLength)));  			readSize = field.VarLength;  		}  		value.Value = str.ToString ();  	}  	break;  case FieldType.StringUTF16:  	{  		StringBuilder str = new StringBuilder ();  		if (field.VarLength == -1) {  			int i;  			for (i = 0; ; i += 2) {  				byte[] b = IOProvider.ReadBytes (offset.Increment (i)' 2);  				if (Utils.IsEmpty (b))  					break;  				str.Append (Encoding.Unicode.GetString (b));  			}  			readSize = i;  		}  		else {  			str.Append (Encoding.Unicode.GetString (IOProvider.ReadBytes (offset' field.VarLength * 2)));  			// each char is 2 bytes  			readSize = field.VarLength;  		}  		value.Value = str.ToString ();  	}  	break;  case FieldType.Struct:  	{  		FieldValue[] valuesOut;  		StructDef struc = Structs [field.StructName];  		struc.IOProvider = this.IOProvider;  		struc.Offset = offset;  		struc.Structs = this.Structs;  		readSize = struc.Read (out valuesOut);  		value.Value = valuesOut;  		value.StructName = field.StructName;  	}  	break;  case FieldType.UInt16:  	value.Value = Utils.ToUInt16 (IOProvider.ReadBytes (offset' 2)' Utils.Endianness.Little);  	readSize = 2;  	break;  case FieldType.UInt32:  	value.Value = Utils.ToUInt32 (IOProvider.ReadBytes (offset' 4)' Utils.Endianness.Little);  	readSize = 4;  	break;  case FieldType.UInt64:  	value.Value = (ulong)Utils.ToInt64 (IOProvider.ReadBytes (offset' 8)' Utils.Endianness.Little);  	readSize = 8;  	break;  case FieldType.UInt8:  	value.Value = IOProvider.ReadBytes (offset' 1) [0];  	readSize = 1;  	break;  default:  	readSize = 0;  	break;  }  
Magic Number,ProcessHacker.Structs,StructDef,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Structs\StructDef.cs,ReadOnce,The following statement contains a magic number: switch (field.Type) {  case FieldType.Bool32:  	value.Value = Utils.ToInt32 (IOProvider.ReadBytes (offset' 4)' Utils.Endianness.Little) != 0;  	readSize = 4;  	break;  case FieldType.Bool8:  	value.Value = IOProvider.ReadBytes (offset' 1) [0] != 0;  	readSize = 1;  	break;  case FieldType.CharASCII:  	value.Value = (char)IOProvider.ReadBytes (offset' 1) [0];  	readSize = 1;  	break;  case FieldType.CharUTF16:  	value.Value = Encoding.Unicode.GetString (IOProvider.ReadBytes (offset' 2)) [0];  	readSize = 2;  	break;  case FieldType.Double:  	{  		long data = Utils.ToInt64 (IOProvider.ReadBytes (offset' 8)' Utils.Endianness.Little);  		value.Value = *(double*)&data;  		readSize = 8;  	}  	break;  case FieldType.Int16:  	value.Value = (short)Utils.ToUInt16 (IOProvider.ReadBytes (offset' 2)' Utils.Endianness.Little);  	readSize = 2;  	break;  case FieldType.Int32:  	value.Value = Utils.ToInt32 (IOProvider.ReadBytes (offset' 4)' Utils.Endianness.Little);  	readSize = 4;  	break;  case FieldType.Int64:  	value.Value = Utils.ToInt64 (IOProvider.ReadBytes (offset' 8)' Utils.Endianness.Little);  	readSize = 8;  	break;  case FieldType.Int8:  	value.Value = (sbyte)IOProvider.ReadBytes (offset' 1) [0];  	readSize = 1;  	break;  case FieldType.PVoid:  	value.Value = IOProvider.ReadBytes (offset' IntPtr.Size).ToIntPtr ();  	readSize = IntPtr.Size;  	break;  case FieldType.Single:  	{  		int data = Utils.ToInt32 (IOProvider.ReadBytes (offset' 4)' Utils.Endianness.Little);  		value.Value = *(float*)&data;  		readSize = 4;  	}  	break;  case FieldType.StringASCII:  	{  		StringBuilder str = new StringBuilder ();  		if (field.VarLength == -1) {  			int i;  			for (i = 0; ; i++) {  				byte b = IOProvider.ReadBytes (offset.Increment (i)' 1) [0];  				if (b == 0)  					break;  				str.Append ((char)b);  			}  			readSize = i;  		}  		else {  			str.Append (Encoding.ASCII.GetString (IOProvider.ReadBytes (offset' field.VarLength)));  			readSize = field.VarLength;  		}  		value.Value = str.ToString ();  	}  	break;  case FieldType.StringUTF16:  	{  		StringBuilder str = new StringBuilder ();  		if (field.VarLength == -1) {  			int i;  			for (i = 0; ; i += 2) {  				byte[] b = IOProvider.ReadBytes (offset.Increment (i)' 2);  				if (Utils.IsEmpty (b))  					break;  				str.Append (Encoding.Unicode.GetString (b));  			}  			readSize = i;  		}  		else {  			str.Append (Encoding.Unicode.GetString (IOProvider.ReadBytes (offset' field.VarLength * 2)));  			// each char is 2 bytes  			readSize = field.VarLength;  		}  		value.Value = str.ToString ();  	}  	break;  case FieldType.Struct:  	{  		FieldValue[] valuesOut;  		StructDef struc = Structs [field.StructName];  		struc.IOProvider = this.IOProvider;  		struc.Offset = offset;  		struc.Structs = this.Structs;  		readSize = struc.Read (out valuesOut);  		value.Value = valuesOut;  		value.StructName = field.StructName;  	}  	break;  case FieldType.UInt16:  	value.Value = Utils.ToUInt16 (IOProvider.ReadBytes (offset' 2)' Utils.Endianness.Little);  	readSize = 2;  	break;  case FieldType.UInt32:  	value.Value = Utils.ToUInt32 (IOProvider.ReadBytes (offset' 4)' Utils.Endianness.Little);  	readSize = 4;  	break;  case FieldType.UInt64:  	value.Value = (ulong)Utils.ToInt64 (IOProvider.ReadBytes (offset' 8)' Utils.Endianness.Little);  	readSize = 8;  	break;  case FieldType.UInt8:  	value.Value = IOProvider.ReadBytes (offset' 1) [0];  	readSize = 1;  	break;  default:  	readSize = 0;  	break;  }  
Magic Number,ProcessHacker.Structs,StructDef,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Structs\StructDef.cs,ReadOnce,The following statement contains a magic number: switch (field.Type) {  case FieldType.Bool32:  	value.Value = Utils.ToInt32 (IOProvider.ReadBytes (offset' 4)' Utils.Endianness.Little) != 0;  	readSize = 4;  	break;  case FieldType.Bool8:  	value.Value = IOProvider.ReadBytes (offset' 1) [0] != 0;  	readSize = 1;  	break;  case FieldType.CharASCII:  	value.Value = (char)IOProvider.ReadBytes (offset' 1) [0];  	readSize = 1;  	break;  case FieldType.CharUTF16:  	value.Value = Encoding.Unicode.GetString (IOProvider.ReadBytes (offset' 2)) [0];  	readSize = 2;  	break;  case FieldType.Double:  	{  		long data = Utils.ToInt64 (IOProvider.ReadBytes (offset' 8)' Utils.Endianness.Little);  		value.Value = *(double*)&data;  		readSize = 8;  	}  	break;  case FieldType.Int16:  	value.Value = (short)Utils.ToUInt16 (IOProvider.ReadBytes (offset' 2)' Utils.Endianness.Little);  	readSize = 2;  	break;  case FieldType.Int32:  	value.Value = Utils.ToInt32 (IOProvider.ReadBytes (offset' 4)' Utils.Endianness.Little);  	readSize = 4;  	break;  case FieldType.Int64:  	value.Value = Utils.ToInt64 (IOProvider.ReadBytes (offset' 8)' Utils.Endianness.Little);  	readSize = 8;  	break;  case FieldType.Int8:  	value.Value = (sbyte)IOProvider.ReadBytes (offset' 1) [0];  	readSize = 1;  	break;  case FieldType.PVoid:  	value.Value = IOProvider.ReadBytes (offset' IntPtr.Size).ToIntPtr ();  	readSize = IntPtr.Size;  	break;  case FieldType.Single:  	{  		int data = Utils.ToInt32 (IOProvider.ReadBytes (offset' 4)' Utils.Endianness.Little);  		value.Value = *(float*)&data;  		readSize = 4;  	}  	break;  case FieldType.StringASCII:  	{  		StringBuilder str = new StringBuilder ();  		if (field.VarLength == -1) {  			int i;  			for (i = 0; ; i++) {  				byte b = IOProvider.ReadBytes (offset.Increment (i)' 1) [0];  				if (b == 0)  					break;  				str.Append ((char)b);  			}  			readSize = i;  		}  		else {  			str.Append (Encoding.ASCII.GetString (IOProvider.ReadBytes (offset' field.VarLength)));  			readSize = field.VarLength;  		}  		value.Value = str.ToString ();  	}  	break;  case FieldType.StringUTF16:  	{  		StringBuilder str = new StringBuilder ();  		if (field.VarLength == -1) {  			int i;  			for (i = 0; ; i += 2) {  				byte[] b = IOProvider.ReadBytes (offset.Increment (i)' 2);  				if (Utils.IsEmpty (b))  					break;  				str.Append (Encoding.Unicode.GetString (b));  			}  			readSize = i;  		}  		else {  			str.Append (Encoding.Unicode.GetString (IOProvider.ReadBytes (offset' field.VarLength * 2)));  			// each char is 2 bytes  			readSize = field.VarLength;  		}  		value.Value = str.ToString ();  	}  	break;  case FieldType.Struct:  	{  		FieldValue[] valuesOut;  		StructDef struc = Structs [field.StructName];  		struc.IOProvider = this.IOProvider;  		struc.Offset = offset;  		struc.Structs = this.Structs;  		readSize = struc.Read (out valuesOut);  		value.Value = valuesOut;  		value.StructName = field.StructName;  	}  	break;  case FieldType.UInt16:  	value.Value = Utils.ToUInt16 (IOProvider.ReadBytes (offset' 2)' Utils.Endianness.Little);  	readSize = 2;  	break;  case FieldType.UInt32:  	value.Value = Utils.ToUInt32 (IOProvider.ReadBytes (offset' 4)' Utils.Endianness.Little);  	readSize = 4;  	break;  case FieldType.UInt64:  	value.Value = (ulong)Utils.ToInt64 (IOProvider.ReadBytes (offset' 8)' Utils.Endianness.Little);  	readSize = 8;  	break;  case FieldType.UInt8:  	value.Value = IOProvider.ReadBytes (offset' 1) [0];  	readSize = 1;  	break;  default:  	readSize = 0;  	break;  }  
Magic Number,ProcessHacker.Structs,StructDef,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Structs\StructDef.cs,ReadOnce,The following statement contains a magic number: switch (field.Type) {  case FieldType.Bool32:  	value.Value = Utils.ToInt32 (IOProvider.ReadBytes (offset' 4)' Utils.Endianness.Little) != 0;  	readSize = 4;  	break;  case FieldType.Bool8:  	value.Value = IOProvider.ReadBytes (offset' 1) [0] != 0;  	readSize = 1;  	break;  case FieldType.CharASCII:  	value.Value = (char)IOProvider.ReadBytes (offset' 1) [0];  	readSize = 1;  	break;  case FieldType.CharUTF16:  	value.Value = Encoding.Unicode.GetString (IOProvider.ReadBytes (offset' 2)) [0];  	readSize = 2;  	break;  case FieldType.Double:  	{  		long data = Utils.ToInt64 (IOProvider.ReadBytes (offset' 8)' Utils.Endianness.Little);  		value.Value = *(double*)&data;  		readSize = 8;  	}  	break;  case FieldType.Int16:  	value.Value = (short)Utils.ToUInt16 (IOProvider.ReadBytes (offset' 2)' Utils.Endianness.Little);  	readSize = 2;  	break;  case FieldType.Int32:  	value.Value = Utils.ToInt32 (IOProvider.ReadBytes (offset' 4)' Utils.Endianness.Little);  	readSize = 4;  	break;  case FieldType.Int64:  	value.Value = Utils.ToInt64 (IOProvider.ReadBytes (offset' 8)' Utils.Endianness.Little);  	readSize = 8;  	break;  case FieldType.Int8:  	value.Value = (sbyte)IOProvider.ReadBytes (offset' 1) [0];  	readSize = 1;  	break;  case FieldType.PVoid:  	value.Value = IOProvider.ReadBytes (offset' IntPtr.Size).ToIntPtr ();  	readSize = IntPtr.Size;  	break;  case FieldType.Single:  	{  		int data = Utils.ToInt32 (IOProvider.ReadBytes (offset' 4)' Utils.Endianness.Little);  		value.Value = *(float*)&data;  		readSize = 4;  	}  	break;  case FieldType.StringASCII:  	{  		StringBuilder str = new StringBuilder ();  		if (field.VarLength == -1) {  			int i;  			for (i = 0; ; i++) {  				byte b = IOProvider.ReadBytes (offset.Increment (i)' 1) [0];  				if (b == 0)  					break;  				str.Append ((char)b);  			}  			readSize = i;  		}  		else {  			str.Append (Encoding.ASCII.GetString (IOProvider.ReadBytes (offset' field.VarLength)));  			readSize = field.VarLength;  		}  		value.Value = str.ToString ();  	}  	break;  case FieldType.StringUTF16:  	{  		StringBuilder str = new StringBuilder ();  		if (field.VarLength == -1) {  			int i;  			for (i = 0; ; i += 2) {  				byte[] b = IOProvider.ReadBytes (offset.Increment (i)' 2);  				if (Utils.IsEmpty (b))  					break;  				str.Append (Encoding.Unicode.GetString (b));  			}  			readSize = i;  		}  		else {  			str.Append (Encoding.Unicode.GetString (IOProvider.ReadBytes (offset' field.VarLength * 2)));  			// each char is 2 bytes  			readSize = field.VarLength;  		}  		value.Value = str.ToString ();  	}  	break;  case FieldType.Struct:  	{  		FieldValue[] valuesOut;  		StructDef struc = Structs [field.StructName];  		struc.IOProvider = this.IOProvider;  		struc.Offset = offset;  		struc.Structs = this.Structs;  		readSize = struc.Read (out valuesOut);  		value.Value = valuesOut;  		value.StructName = field.StructName;  	}  	break;  case FieldType.UInt16:  	value.Value = Utils.ToUInt16 (IOProvider.ReadBytes (offset' 2)' Utils.Endianness.Little);  	readSize = 2;  	break;  case FieldType.UInt32:  	value.Value = Utils.ToUInt32 (IOProvider.ReadBytes (offset' 4)' Utils.Endianness.Little);  	readSize = 4;  	break;  case FieldType.UInt64:  	value.Value = (ulong)Utils.ToInt64 (IOProvider.ReadBytes (offset' 8)' Utils.Endianness.Little);  	readSize = 8;  	break;  case FieldType.UInt8:  	value.Value = IOProvider.ReadBytes (offset' 1) [0];  	readSize = 1;  	break;  default:  	readSize = 0;  	break;  }  
Magic Number,ProcessHacker.Structs,StructDef,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Structs\StructDef.cs,ReadOnce,The following statement contains a magic number: value.Value = Utils.ToInt32 (IOProvider.ReadBytes (offset' 4)' Utils.Endianness.Little) != 0;  
Magic Number,ProcessHacker.Structs,StructDef,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Structs\StructDef.cs,ReadOnce,The following statement contains a magic number: readSize = 4;  
Magic Number,ProcessHacker.Structs,StructDef,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Structs\StructDef.cs,ReadOnce,The following statement contains a magic number: value.Value = Encoding.Unicode.GetString (IOProvider.ReadBytes (offset' 2)) [0];  
Magic Number,ProcessHacker.Structs,StructDef,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Structs\StructDef.cs,ReadOnce,The following statement contains a magic number: readSize = 2;  
Magic Number,ProcessHacker.Structs,StructDef,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Structs\StructDef.cs,ReadOnce,The following statement contains a magic number: readSize = 8;  
Magic Number,ProcessHacker.Structs,StructDef,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Structs\StructDef.cs,ReadOnce,The following statement contains a magic number: value.Value = (short)Utils.ToUInt16 (IOProvider.ReadBytes (offset' 2)' Utils.Endianness.Little);  
Magic Number,ProcessHacker.Structs,StructDef,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Structs\StructDef.cs,ReadOnce,The following statement contains a magic number: readSize = 2;  
Magic Number,ProcessHacker.Structs,StructDef,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Structs\StructDef.cs,ReadOnce,The following statement contains a magic number: value.Value = Utils.ToInt32 (IOProvider.ReadBytes (offset' 4)' Utils.Endianness.Little);  
Magic Number,ProcessHacker.Structs,StructDef,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Structs\StructDef.cs,ReadOnce,The following statement contains a magic number: readSize = 4;  
Magic Number,ProcessHacker.Structs,StructDef,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Structs\StructDef.cs,ReadOnce,The following statement contains a magic number: value.Value = Utils.ToInt64 (IOProvider.ReadBytes (offset' 8)' Utils.Endianness.Little);  
Magic Number,ProcessHacker.Structs,StructDef,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Structs\StructDef.cs,ReadOnce,The following statement contains a magic number: readSize = 8;  
Magic Number,ProcessHacker.Structs,StructDef,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Structs\StructDef.cs,ReadOnce,The following statement contains a magic number: readSize = 4;  
Magic Number,ProcessHacker.Structs,StructDef,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Structs\StructDef.cs,ReadOnce,The following statement contains a magic number: if (field.VarLength == -1) {  	int i;  	for (i = 0; ; i += 2) {  		byte[] b = IOProvider.ReadBytes (offset.Increment (i)' 2);  		if (Utils.IsEmpty (b))  			break;  		str.Append (Encoding.Unicode.GetString (b));  	}  	readSize = i;  }  else {  	str.Append (Encoding.Unicode.GetString (IOProvider.ReadBytes (offset' field.VarLength * 2)));  	// each char is 2 bytes  	readSize = field.VarLength;  }  
Magic Number,ProcessHacker.Structs,StructDef,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Structs\StructDef.cs,ReadOnce,The following statement contains a magic number: if (field.VarLength == -1) {  	int i;  	for (i = 0; ; i += 2) {  		byte[] b = IOProvider.ReadBytes (offset.Increment (i)' 2);  		if (Utils.IsEmpty (b))  			break;  		str.Append (Encoding.Unicode.GetString (b));  	}  	readSize = i;  }  else {  	str.Append (Encoding.Unicode.GetString (IOProvider.ReadBytes (offset' field.VarLength * 2)));  	// each char is 2 bytes  	readSize = field.VarLength;  }  
Magic Number,ProcessHacker.Structs,StructDef,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Structs\StructDef.cs,ReadOnce,The following statement contains a magic number: if (field.VarLength == -1) {  	int i;  	for (i = 0; ; i += 2) {  		byte[] b = IOProvider.ReadBytes (offset.Increment (i)' 2);  		if (Utils.IsEmpty (b))  			break;  		str.Append (Encoding.Unicode.GetString (b));  	}  	readSize = i;  }  else {  	str.Append (Encoding.Unicode.GetString (IOProvider.ReadBytes (offset' field.VarLength * 2)));  	// each char is 2 bytes  	readSize = field.VarLength;  }  
Magic Number,ProcessHacker.Structs,StructDef,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Structs\StructDef.cs,ReadOnce,The following statement contains a magic number: for (i = 0; ; i += 2) {  	byte[] b = IOProvider.ReadBytes (offset.Increment (i)' 2);  	if (Utils.IsEmpty (b))  		break;  	str.Append (Encoding.Unicode.GetString (b));  }  
Magic Number,ProcessHacker.Structs,StructDef,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Structs\StructDef.cs,ReadOnce,The following statement contains a magic number: for (i = 0; ; i += 2) {  	byte[] b = IOProvider.ReadBytes (offset.Increment (i)' 2);  	if (Utils.IsEmpty (b))  		break;  	str.Append (Encoding.Unicode.GetString (b));  }  
Magic Number,ProcessHacker.Structs,StructDef,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Structs\StructDef.cs,ReadOnce,The following statement contains a magic number: i += 2
Magic Number,ProcessHacker.Structs,StructDef,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Structs\StructDef.cs,ReadOnce,The following statement contains a magic number: str.Append (Encoding.Unicode.GetString (IOProvider.ReadBytes (offset' field.VarLength * 2)));  
Magic Number,ProcessHacker.Structs,StructDef,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Structs\StructDef.cs,ReadOnce,The following statement contains a magic number: value.Value = Utils.ToUInt16 (IOProvider.ReadBytes (offset' 2)' Utils.Endianness.Little);  
Magic Number,ProcessHacker.Structs,StructDef,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Structs\StructDef.cs,ReadOnce,The following statement contains a magic number: readSize = 2;  
Magic Number,ProcessHacker.Structs,StructDef,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Structs\StructDef.cs,ReadOnce,The following statement contains a magic number: value.Value = Utils.ToUInt32 (IOProvider.ReadBytes (offset' 4)' Utils.Endianness.Little);  
Magic Number,ProcessHacker.Structs,StructDef,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Structs\StructDef.cs,ReadOnce,The following statement contains a magic number: readSize = 4;  
Magic Number,ProcessHacker.Structs,StructDef,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Structs\StructDef.cs,ReadOnce,The following statement contains a magic number: value.Value = (ulong)Utils.ToInt64 (IOProvider.ReadBytes (offset' 8)' Utils.Endianness.Little);  
Magic Number,ProcessHacker.Structs,StructDef,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Structs\StructDef.cs,ReadOnce,The following statement contains a magic number: readSize = 8;  
Magic Number,ProcessHacker.Structs,StructParser,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Structs\StructParser.cs,EatNumber,The following statement contains a magic number: while (i < text.Length) {  	// allow hex numbers and floating-point numbers  	if (sb.Length == 1 && sb [0] == '0') {  		if (!char.IsDigit (text [i]) && char.ToLower (text [i]) != 'x' && text [i] != '.')  			break;  	}  	else if (sb.Length >= 2 && sb [0] == '0' && char.ToLower (sb [1]) == 'x') {  		if (!(char.IsDigit (text [i]) || char.ToLower (text [i]) == 'a' || char.ToLower (text [i]) == 'b' || char.ToLower (text [i]) == 'c' || char.ToLower (text [i]) == 'd' || char.ToLower (text [i]) == 'e' || char.ToLower (text [i]) == 'f'))  			break;  	}  	else {  		if (!char.IsDigit (text [i]))  			break;  	}  	sb.Append (text [i]);  	i++;  }  
Magic Number,ProcessHacker.Structs,StructParser,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Structs\StructParser.cs,EatNumber,The following statement contains a magic number: if (sb.Length == 1 && sb [0] == '0') {  	if (!char.IsDigit (text [i]) && char.ToLower (text [i]) != 'x' && text [i] != '.')  		break;  }  else if (sb.Length >= 2 && sb [0] == '0' && char.ToLower (sb [1]) == 'x') {  	if (!(char.IsDigit (text [i]) || char.ToLower (text [i]) == 'a' || char.ToLower (text [i]) == 'b' || char.ToLower (text [i]) == 'c' || char.ToLower (text [i]) == 'd' || char.ToLower (text [i]) == 'e' || char.ToLower (text [i]) == 'f'))  		break;  }  else {  	if (!char.IsDigit (text [i]))  		break;  }  
Magic Number,ProcessHacker.Structs,StructParser,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Structs\StructParser.cs,EatNumber,The following statement contains a magic number: if (sb.Length >= 2 && sb [0] == '0' && char.ToLower (sb [1]) == 'x') {  	if (!(char.IsDigit (text [i]) || char.ToLower (text [i]) == 'a' || char.ToLower (text [i]) == 'b' || char.ToLower (text [i]) == 'c' || char.ToLower (text [i]) == 'd' || char.ToLower (text [i]) == 'e' || char.ToLower (text [i]) == 'f'))  		break;  }  else {  	if (!char.IsDigit (text [i]))  		break;  }  
Missing Default,Be.Windows.Forms,HexBox,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\Be.Windows.Forms.HexBox\HexBox.cs,OnPaintBackground,The following switch statement is missing a default case: switch (_borderStyle) {  case BorderStyle.Fixed3D: {  	if (TextBoxRenderer.IsSupported) {  		VisualStyleElement state = VisualStyleElement.TextBox.TextEdit.Normal;  		Color backColor = this.BackColor;  		if (this.Enabled) {  			if (this.ReadOnly)  				state = VisualStyleElement.TextBox.TextEdit.ReadOnly;  			else if (this.Focused)  				state = VisualStyleElement.TextBox.TextEdit.Focused;  		}  		else {  			state = VisualStyleElement.TextBox.TextEdit.Disabled;  			backColor = this.BackColorDisabled;  		}  		VisualStyleRenderer vsr = new VisualStyleRenderer (state);  		vsr.DrawBackground (e.Graphics' this.ClientRectangle);  		Rectangle rectContent = vsr.GetBackgroundContentRectangle (e.Graphics' this.ClientRectangle);  		e.Graphics.FillRectangle (new SolidBrush (backColor)' rectContent);  	}  	else {  		// draw background  		e.Graphics.FillRectangle (new SolidBrush (BackColor)' ClientRectangle);  		// draw default border  		ControlPaint.DrawBorder3D (e.Graphics' ClientRectangle' Border3DStyle.Sunken);  	}  	break;  }  case BorderStyle.FixedSingle: {  	// draw background  	e.Graphics.FillRectangle (new SolidBrush (BackColor)' ClientRectangle);  	// draw fixed single border  	ControlPaint.DrawBorder (e.Graphics' ClientRectangle' Color.Black' ButtonBorderStyle.Solid);  	break;  }  }  
Missing Default,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,menuProcess_Popup,The following switch statement is missing a default case: switch (phandle.GetPriorityClass ()) {  case ProcessPriorityClass.RealTime:  	realTimeMenuItem.Checked = true;  	break;  case ProcessPriorityClass.High:  	highMenuItem.Checked = true;  	break;  case ProcessPriorityClass.AboveNormal:  	aboveNormalMenuItem.Checked = true;  	break;  case ProcessPriorityClass.Normal:  	normalMenuItem.Checked = true;  	break;  case ProcessPriorityClass.BelowNormal:  	belowNormalMenuItem.Checked = true;  	break;  case ProcessPriorityClass.Idle:  	idleMenuItem.Checked = true;  	break;  }  
Missing Default,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,menuProcess_Popup,The following switch statement is missing a default case: switch (phandle.GetIoPriority ()) {  case 0:  	ioPriority0ThreadMenuItem.Checked = true;  	break;  case 1:  	ioPriority1ThreadMenuItem.Checked = true;  	break;  case 2:  	ioPriority2ThreadMenuItem.Checked = true;  	break;  case 3:  	ioPriority3ThreadMenuItem.Checked = true;  	break;  }  
Missing Default,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,menuProcess_Popup,The following switch statement is missing a default case: switch (windowHandle.GetPlacement ().ShowState) {  case ShowWindowType.ShowMinimized:  	minimizeProcessMenuItem.Enabled = false;  	break;  case ShowWindowType.ShowMaximized:  	maximizeProcessMenuItem.Enabled = false;  	break;  case ShowWindowType.ShowNormal:  	restoreProcessMenuItem.Enabled = false;  	break;  }  
Missing Default,ProcessHacker,HackerWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HackerWindow.cs,WndProc,The following switch statement is missing a default case: switch (m.Msg) {  // Magic number - PH uses this to detect previous instances.  case 0x9991: {  	this.Visible = true;  	if (this.WindowState == FormWindowState.Minimized) {  		this.Location = Settings.Instance.WindowLocation;  		this.Size = Settings.Instance.WindowSize;  		this.WindowState = FormWindowState.Normal;  	}  	m.Result = new IntPtr (0x1119);  	return;  }  //break;  case (int)WindowMessage.SysCommand:  	{  		if (m.WParam.ToInt32 () == 0xf020)// SC_MINIMIZE  		 {  			try {  				if (this.WindowState == FormWindowState.Normal && this.Visible) {  					Settings.Instance.WindowLocation = this.Location;  					Settings.Instance.WindowSize = this.Size;  				}  				if (this.GetIconsVisibleCount () > 0 && Settings.Instance.HideWhenMinimized) {  					this.Visible = false;  					return;  				}  			}  			catch {  			}  		}  	}  	break;  case (int)WindowMessage.Paint:  	this.Painting ();  	break;  case (int)WindowMessage.Activate:  case (int)WindowMessage.KillFocus:  	{  		if (treeProcesses != null && treeProcesses.Tree != null)  			treeProcesses.Tree.Invalidate ();  	}  	break;  case (int)WindowMessage.WtsSessionChange:  	{  		WtsSessionChangeEvent changeEvent = (WtsSessionChangeEvent)m.WParam.ToInt32 ();  		if (changeEvent == WtsSessionChangeEvent.SessionLogon || changeEvent == WtsSessionChangeEvent.SessionLogoff) {  			try {  				this.UpdateSessions ();  			}  			catch (Exception ex) {  				Logging.Log (ex);  			}  		}  	}  	break;  case (int)WindowMessage.SettingChange:  	{  		// Refresh icon sizes.  		this.ExecuteOnIcons (icon => icon.Size = UsageIcon.GetSmallIconSize ());  		// Refresh the tree view visual style.  		treeProcesses.Tree.RefreshVisualStyles ();  	}  	break;  }  
Missing Default,ProcessHacker,HiddenProcessesWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HiddenProcessesWindow.cs,OpenProcess,The following switch statement is missing a default case: switch (comboMethod.SelectedItem.ToString ()) {  case "Brute Force":  	return new ProcessHandle (pid' access);  case "CSR Handles":  	return this.OpenProcessCsr (pid' access);  }  
Missing Default,ProcessHacker,HiddenProcessesWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\HiddenProcessesWindow.cs,Scan,The following switch statement is missing a default case: switch (comboMethod.SelectedItem.ToString ()) {  case "Brute Force":  	this.ScanBruteForce ();  	break;  case "CSR Handles":  	this.ScanCsrHandles ();  	break;  }  
Missing Default,ProcessHacker,ProcessWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\ProcessWindow.cs,WndProc,The following switch statement is missing a default case: switch (m.Msg) {  case (int)WindowMessage.Paint:  	{  		if (_isFirstPaint) {  			_isFirstPaint = false;  			this.LoadStage1 ();  		}  	}  	break;  }  
Missing Default,ProcessHacker,SearchWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\SearchWindow.cs,SearchWindow,The following switch statement is missing a default case: switch (so.Type) {  case SearchType.Literal:  	tabControl.SelectedTab = tabLiteral;  	break;  case SearchType.Regex:  	tabControl.SelectedTab = tabRegex;  	break;  case SearchType.String:  	tabControl.SelectedTab = tabString;  	break;  case SearchType.Heap:  	tabControl.SelectedTab = tabHeap;  	break;  case SearchType.Struct:  	tabControl.SelectedTab = tabStruct;  	break;  }  
Missing Default,ProcessHacker,OptionsWindow,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Forms\OptionsWindow.cs,WndProc,The following switch statement is missing a default case: switch (m.Msg) {  case (int)WindowMessage.Paint:  	{  		if (_isFirstPaint) {  			this.LoadStage1 ();  		}  		_isFirstPaint = false;  	}  	break;  }  
Missing Default,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,CalculateButtonAutoSize,The following switch statement is missing a default case: switch (TextImageRelation) {  case TextImageRelation.Overlay:  	ret_size.Height = Math.Max (Text.Length == 0 ? 0 : text_size.Height' image_size.Height);  	ret_size.Width = Math.Max (text_size.Width' image_size.Width);  	break;  case TextImageRelation.ImageAboveText:  case TextImageRelation.TextAboveImage:  	ret_size.Height = text_size.Height + image_size.Height;  	ret_size.Width = Math.Max (text_size.Width' image_size.Width);  	break;  case TextImageRelation.ImageBeforeText:  case TextImageRelation.TextBeforeImage:  	ret_size.Height = Math.Max (text_size.Height' image_size.Height);  	ret_size.Width = text_size.Width + image_size.Width;  	break;  }  
Missing Default,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,CalculateButtonTextAndImageLayout,The following switch statement is missing a default case: switch (TextImageRelation) {  case TextImageRelation.Overlay:  	// Overlay is easy' text always goes here  	textRectangle = OverlayObjectRect (ref content_rect' ref text_size' TextAlign);  	// Rectangle.Inflate(content_rect' -4' -4);  	//Offset on Windows 98 style when button is pressed  	if (_state == PushButtonState.Pressed && !Application.RenderWithVisualStyles)  		textRectangle.Offset (1' 1);  	// Image is dependent on ImageAlign  	if (Image != null)  		imageRectangle = OverlayObjectRect (ref content_rect' ref image_size' ImageAlign);  	break;  case TextImageRelation.ImageAboveText:  	content_rect.Inflate (-4' -4);  	LayoutTextAboveOrBelowImage (content_rect' false' text_size' image_size' out textRectangle' out imageRectangle);  	break;  case TextImageRelation.TextAboveImage:  	content_rect.Inflate (-4' -4);  	LayoutTextAboveOrBelowImage (content_rect' true' text_size' image_size' out textRectangle' out imageRectangle);  	break;  case TextImageRelation.ImageBeforeText:  	content_rect.Inflate (-4' -4);  	LayoutTextBeforeOrAfterImage (content_rect' false' text_size' image_size' out textRectangle' out imageRectangle);  	break;  case TextImageRelation.TextBeforeImage:  	content_rect.Inflate (-4' -4);  	LayoutTextBeforeOrAfterImage (content_rect' true' text_size' image_size' out textRectangle' out imageRectangle);  	break;  }  
Missing Default,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,GetHorizontalAlignment,The following switch statement is missing a default case: switch (align) {  case System.Drawing.ContentAlignment.BottomLeft:  case System.Drawing.ContentAlignment.MiddleLeft:  case System.Drawing.ContentAlignment.TopLeft:  	return HorizontalAlignment.Left;  case System.Drawing.ContentAlignment.BottomCenter:  case System.Drawing.ContentAlignment.MiddleCenter:  case System.Drawing.ContentAlignment.TopCenter:  	return HorizontalAlignment.Center;  case System.Drawing.ContentAlignment.BottomRight:  case System.Drawing.ContentAlignment.MiddleRight:  case System.Drawing.ContentAlignment.TopRight:  	return HorizontalAlignment.Right;  }  
Missing Default,wyDay.Controls,SplitButton,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\SplitButton.cs,GetVerticalAlignment,The following switch statement is missing a default case: switch (align) {  case System.Drawing.ContentAlignment.TopLeft:  case System.Drawing.ContentAlignment.TopCenter:  case System.Drawing.ContentAlignment.TopRight:  	return VerticalAlignment.Top;  case System.Drawing.ContentAlignment.MiddleLeft:  case System.Drawing.ContentAlignment.MiddleCenter:  case System.Drawing.ContentAlignment.MiddleRight:  	return VerticalAlignment.Center;  case System.Drawing.ContentAlignment.BottomLeft:  case System.Drawing.ContentAlignment.BottomCenter:  case System.Drawing.ContentAlignment.BottomRight:  	return VerticalAlignment.Bottom;  }  
Missing Default,ProcessHacker.Components,ExtendedListView,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ExtendedListView.cs,WndProc,The following switch statement is missing a default case: switch (m.Msg) {  case LVM_HitTest:  	{  		if (_doubleClickCheckHackActive) {  			m.Result = (-1).ToIntPtr ();  			_doubleClickCheckHackActive = false;  			return;  		}  	}  	break;  case (int)WindowMessage.Reflect + (int)WindowMessage.Notify:  	this.OnWmReflectNotify (ref m);  	break;  case WM_LButtonUp://handle LButtonUp event and allow groups to be collapsed   {  	base.DefWndProc (ref m);  	break;  }  //todo: mouse flicker bug:  http://blogs.msdn.com/oldnewthing/archive/2006/11/21/1115695.aspx  }  
Missing Default,ProcessHacker.Components,HandleList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\HandleList.cs,ShowHandleProperties,The following switch statement is missing a default case: switch (typeName.ToLowerInvariant ()) {  // Objects with separate property windows:  case "file":  case "job":  case "key":  case "token":  case "process":  	{  		Button b = new Button ();  		b.FlatStyle = FlatStyle.System;  		b.Text = "Properties";  		b.Click += (sender' e) =>  {  			try {  				switch (typeName.ToLowerInvariant ()) {  				case "file":  					{  						FileUtils.ShowProperties (name);  					}  					break;  				case "job":  					{  						dupHandle = new GenericHandle (phandle' handle' (int)JobObjectAccess.Query);  						(new JobWindow (JobObjectHandle.FromHandle (dupHandle))).ShowDialog ();  					}  					break;  				case "key":  					{  						try {  							PhUtils.OpenKeyInRegedit (PhUtils.GetForegroundWindow ()' name);  						}  						catch (Exception ex) {  							PhUtils.ShowException ("Unable to open the Registry Editor"' ex);  						}  					}  					break;  				case "token":  					{  						(new TokenWindow (new RemoteTokenHandle (phandle' handle))).ShowDialog ();  					}  					break;  				case "process":  					{  						int pid;  						if (KProcessHacker.Instance != null) {  							pid = KProcessHacker.Instance.KphGetProcessId (phandle' handle);  						}  						else {  							dupHandle = new GenericHandle (phandle' handle' (int)OSVersion.MinProcessQueryInfoAccess);  							pid = ProcessHandle.FromHandle (dupHandle).GetProcessId ();  						}  						Program.GetProcessWindow (Program.ProcessProvider.Dictionary [pid]' f => Program.FocusWindow (f));  					}  					break;  				}  			}  			catch (Exception ex) {  				PhUtils.ShowException ("Unable to show object properties"' ex);  			}  		};  		control.Controls.Add (b);  	}  	break;  case "event":  	{  		dupHandle = new GenericHandle (phandle' handle' (int)EventAccess.QueryState);  		var eventProps = new EventProperties (EventHandle.FromHandle (dupHandle));  		control.Controls.Add (eventProps);  	}  	break;  case "eventpair":  	{  		dupHandle = new GenericHandle (phandle' handle' (int)EventPairAccess.All);  		var eventPairProps = new EventPairProperties (EventPairHandle.FromHandle (dupHandle));  		control.Controls.Add (eventPairProps);  	}  	break;  case "mutant":  	{  		dupHandle = new GenericHandle (phandle' handle' (int)MutantAccess.QueryState);  		var mutantProps = new MutantProperties (MutantHandle.FromHandle (dupHandle));  		control.Controls.Add (mutantProps);  	}  	break;  case "section":  	{  		dupHandle = new GenericHandle (phandle' handle' (int)SectionAccess.Query);  		var sectionProps = new SectionProperties (SectionHandle.FromHandle (dupHandle));  		control.Controls.Add (sectionProps);  	}  	break;  case "semaphore":  	{  		dupHandle = new GenericHandle (phandle' handle' (int)SemaphoreAccess.QueryState);  		var semaphoreProps = new SemaphoreProperties (SemaphoreHandle.FromHandle (dupHandle));  		control.Controls.Add (semaphoreProps);  	}  	break;  case "timer":  	{  		dupHandle = new GenericHandle (phandle' handle' (int)TimerAccess.QueryState);  		var timerProps = new TimerProperties (TimerHandle.FromHandle (dupHandle));  		control.Controls.Add (timerProps);  	}  	break;  case "tmrm":  	{  		dupHandle = new GenericHandle (phandle' handle' (int)ResourceManagerAccess.QueryInformation);  		var tmRmProps = new TmRmProperties (ResourceManagerHandle.FromHandle (dupHandle));  		control.Controls.Add (tmRmProps);  	}  	break;  case "tmtm":  	{  		dupHandle = new GenericHandle (phandle' handle' (int)TmAccess.QueryInformation);  		var tmTmProps = new TmTmProperties (TmHandle.FromHandle (dupHandle));  		control.Controls.Add (tmTmProps);  	}  	break;  }  
Missing Default,ProcessHacker.Components,HandleList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\HandleList.cs,ShowHandleProperties,The following switch statement is missing a default case: switch (typeName.ToLowerInvariant ()) {  case "file":  	{  		FileUtils.ShowProperties (name);  	}  	break;  case "job":  	{  		dupHandle = new GenericHandle (phandle' handle' (int)JobObjectAccess.Query);  		(new JobWindow (JobObjectHandle.FromHandle (dupHandle))).ShowDialog ();  	}  	break;  case "key":  	{  		try {  			PhUtils.OpenKeyInRegedit (PhUtils.GetForegroundWindow ()' name);  		}  		catch (Exception ex) {  			PhUtils.ShowException ("Unable to open the Registry Editor"' ex);  		}  	}  	break;  case "token":  	{  		(new TokenWindow (new RemoteTokenHandle (phandle' handle))).ShowDialog ();  	}  	break;  case "process":  	{  		int pid;  		if (KProcessHacker.Instance != null) {  			pid = KProcessHacker.Instance.KphGetProcessId (phandle' handle);  		}  		else {  			dupHandle = new GenericHandle (phandle' handle' (int)OSVersion.MinProcessQueryInfoAccess);  			pid = ProcessHandle.FromHandle (dupHandle).GetProcessId ();  		}  		Program.GetProcessWindow (Program.ProcessProvider.Dictionary [pid]' f => Program.FocusWindow (f));  	}  	break;  }  
Missing Default,ProcessHacker.Components,TaskDialog,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\TaskDialog\TaskDialog.cs,PrivateCallback,The following switch statement is missing a default case: switch (args.Notification) {  case TaskDialogNotification.ButtonClicked:  case TaskDialogNotification.RadioButtonClicked:  	args.ButtonId = (int)wparam;  	break;  case TaskDialogNotification.HyperlinkClicked:  	args.Hyperlink = Marshal.PtrToStringUni (lparam);  	break;  case TaskDialogNotification.Timer:  	args.TimerTickCount = (uint)wparam;  	break;  case TaskDialogNotification.VerificationClicked:  	args.VerificationFlagChecked = (wparam != UIntPtr.Zero);  	break;  case TaskDialogNotification.ExpandoButtonClicked:  	args.Expanded = (wparam != UIntPtr.Zero);  	break;  }  
Missing Default,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,menuThread_Popup,The following switch statement is missing a default case: switch (thandle.GetBasePriorityWin32 ()) {  case ThreadPriorityLevel.TimeCritical:  	timeCriticalThreadMenuItem.Checked = true;  	break;  case ThreadPriorityLevel.Highest:  	highestThreadMenuItem.Checked = true;  	break;  case ThreadPriorityLevel.AboveNormal:  	aboveNormalThreadMenuItem.Checked = true;  	break;  case ThreadPriorityLevel.Normal:  	normalThreadMenuItem.Checked = true;  	break;  case ThreadPriorityLevel.BelowNormal:  	belowNormalThreadMenuItem.Checked = true;  	break;  case ThreadPriorityLevel.Lowest:  	lowestThreadMenuItem.Checked = true;  	break;  case ThreadPriorityLevel.Idle:  	idleThreadMenuItem.Checked = true;  	break;  }  
Missing Default,ProcessHacker.Components,ThreadList,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\ThreadList.cs,menuThread_Popup,The following switch statement is missing a default case: switch (thandle.GetIoPriority ()) {  case 0:  	ioPriority0ThreadMenuItem.Checked = true;  	break;  case 1:  	ioPriority1ThreadMenuItem.Checked = true;  	break;  case 2:  	ioPriority2ThreadMenuItem.Checked = true;  	break;  case 3:  	ioPriority3ThreadMenuItem.Checked = true;  	break;  }  
Missing Default,TaskbarLib,JumpListManager,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\Components\TaskbarLib\JumpLists\JumpListManager.cs,Refresh,The following switch statement is missing a default case: switch (EnabledAutoDestinationType) {  case ApplicationDestinationType.Frequent:  	HResult appendKnownCategoryFrequentResult = _customDestinationList.AppendKnownCategory (KnownDestCategory.FREQUENT);  	appendKnownCategoryFrequentResult.ThrowIf ();  	break;  case ApplicationDestinationType.Recent:  	HResult appendKnownCategoryRecentResult = _customDestinationList.AppendKnownCategory (KnownDestCategory.RECENT);  	appendKnownCategoryRecentResult.ThrowIf ();  	break;  }  
Missing Default,Debugger.Interop,MTA2STA,C:\repos\prresearcher_pr-Researcher\process-Researcher\ProcessHacker\SharpDevelop\MTA2STA.cs,TriggerInvoke,The following switch statement is missing a default case: switch (callMethod) {  case CallMethod.DirectCall:  	PerformAllCalls ();  	break;  case CallMethod.Manual:  	// Nothing we can do - someone else must call SoftWait or Pulse  	break;  case CallMethod.HiddenForm:  case CallMethod.HiddenFormWithTimeout:  	hiddenForm.BeginInvoke ((MethodInvoker)PerformAllCalls);  	break;  }  
